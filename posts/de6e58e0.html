<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.ico">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="很久之前看王爽老师的《汇编语言》写的笔记，可能不太准确，先做个存档吧。">
<meta property="og:type" content="article">
<meta property="og:title" content="x86汇编基础">
<meta property="og:url" content="http://example.com/posts/de6e58e0.html">
<meta property="og:site_name" content="v5le0n9&#39;s garden">
<meta property="og:description" content="很久之前看王爽老师的《汇编语言》写的笔记，可能不太准确，先做个存档吧。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/posts/de6e58e0/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E4%B8%BE%E4%BE%8B.png">
<meta property="og:image" content="http://example.com/posts/de6e58e0/%E6%AE%B5%E5%89%8D%E7%BC%80.PNG">
<meta property="og:image" content="http://example.com/posts/de6e58e0/ASCII%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6.jpg">
<meta property="og:image" content="http://example.com/posts/de6e58e0/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%B0%8F%E7%BB%93.png">
<meta property="article:published_time" content="2022-04-11T05:16:29.411Z">
<meta property="article:modified_time" content="2022-11-17T06:29:41.476Z">
<meta property="article:author" content="v5le0n9">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/posts/de6e58e0/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E4%B8%BE%E4%BE%8B.png">

<link rel="canonical" href="http://example.com/posts/de6e58e0.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>x86汇编基础 | v5le0n9's garden</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="v5le0n9's garden" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">v5le0n9's garden</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">小凉的秘密基地</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/v5le0n9" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/de6e58e0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="v5le0n9">
      <meta itemprop="description" content="小呀小二郎呀背着个书包上学堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="v5le0n9's garden">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          x86汇编基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-11 13:16:29" itemprop="dateCreated datePublished" datetime="2022-04-11T13:16:29+08:00">2022-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-17 14:29:41" itemprop="dateModified" datetime="2022-11-17T14:29:41+08:00">2022-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">Windows安全</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>很久之前看王爽老师的《汇编语言》写的笔记，可能不太准确，先做个存档吧。</p>
<span id="more"></span>
<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><p>汇编指令是机器指令的助记符，同机器指令一一对应。</p>
<p>每一种CPU都有自己的汇编指令集。</p>
<p>CPU可以直接使用的信息在存储器中存放。</p>
<p>指令和数据没有任何区别，都是二进制信息。</p>
<p>存储单元从零开始顺序编号。</p>
<p>存储器的存储单元可以存储1B，即8个二进制位。微机存储器的容量是以<strong>字节</strong>为最小单位来计算的。</p>
<p>1B=8b, 1KB=1024B, 1MB=1024KB, 1GB=1024MB, 1TB=1024GB</p>
<p>地址总线：</p>
<ul>
<li>CPU是通过地址总线来指定存储单元的</li>
<li>地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址</li>
<li>一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单元(B)</li>
</ul>
<p>数据总线：</p>
<ul>
<li>CPU与内存或其他器件之间的数据传送是通过数据总线来进行的</li>
<li>数据总线的宽度决定了CPU和外界的数据传送速度，8根数据总线一次可传送一个8位二进制数据(即1B)</li>
</ul>
<p>控制总线：</p>
<ul>
<li>CPU对外部器件的控制是通过控制总线来进行的</li>
<li>有多少根控制总线就意味着CPU提供了对外部器件的多少种控制</li>
<li>控制总线的宽度决定了CPU对外部器件的控制能力</li>
</ul>
<h1 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2. 寄存器"></a>2. 寄存器</h1><p>内部总线实现CPU内部各个器件之间的连接，外部总线实现CPU和主板上其他器件的联系。</p>
<h2 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h2><p>AX, BX, CX, DX</p>
<p>以AX为例，数据18，二进制表示10010，小端序</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>AX</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>14</td>
<td>13</td>
<td>12</td>
<td>11</td>
<td>10</td>
<td>9</td>
<td>8</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td></td>
<td>8~15</td>
<td>AH</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0~7</td>
<td>AL</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>AH和AL可以看成是一个字型数据的高8位和低8位，也可以看成是两个独立的字节型数据。</p>
<h2 id="2-2-几条汇编指令"><a href="#2-2-几条汇编指令" class="headerlink" title="2.2 几条汇编指令"></a>2.2 几条汇编指令</h2><img src="/posts/de6e58e0/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E4%B8%BE%E4%BE%8B.png" class="" title="汇编指令举例">
<p>汇编指令不区分大小写。</p>
<p>原AX=0000H，BX=0000H</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>程序段中的指令</th>
<th>指令执行后AX中的数据</th>
<th>指令执行后BX中的数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov ax, 4E20H</td>
<td>4E20H</td>
<td>0000H</td>
</tr>
<tr>
<td>add ax, 1406H</td>
<td>6226H</td>
<td>0000H</td>
</tr>
<tr>
<td>mov bx, 2000H</td>
<td>6226H</td>
<td>2000H</td>
</tr>
<tr>
<td>add ax, bx</td>
<td>8226H</td>
<td>2000H</td>
</tr>
<tr>
<td>mov bx, ax</td>
<td>8226H</td>
<td>8226H</td>
</tr>
<tr>
<td>add ax, bx</td>
<td><strong>044CH</strong></td>
<td>8226H</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-3-物理地址"><a href="#2-3-物理地址" class="headerlink" title="2.3 物理地址"></a>2.3 物理地址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理地址=段地址×16+偏移地址=基础地址+偏移地址</span><br></pre></td></tr></table></figure>
<p>CPU可以用不同的段地址和偏移地址形成同一个物理地址。</p>
<p>偏移地址16位，变化范围0~FFFFH，仅用偏移地址来寻址最多可寻$2^{16}B=2^{6}KB=64KB$个内存单元。</p>
<h2 id="2-4-CS-和-IP"><a href="#2-4-CS-和-IP" class="headerlink" title="2.4 CS 和 IP"></a>2.4 CS 和 IP</h2><p>CS为代码段寄存器(存放段地址)，IP为指令指针寄存器(存放偏移地址)。</p>
<p>同时修改CS、IP的内容：jmp 段地址：偏移地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 3:0B16	执行后：CS=0003H,IP=0B16H,CPU将从00030H+0B16H=00B46H处读取指令</span><br></pre></td></tr></table></figure>
<p>仅修改IP的内容：jmp 某一合法寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp ax	执行指令前：ax=1000H,CS=2000H,IP=0003H</span><br><span class="line">		执行指令后：ax=1000H,CS=2000H,IP=1000H</span><br></pre></td></tr></table></figure>
<p>8086CPU工作过程：</p>
<ol>
<li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器</li>
<li>IP指向下一条指令</li>
<li>执行指令（转到1，重复）</li>
</ol>
<h1 id="3-内存访问"><a href="#3-内存访问" class="headerlink" title="3. 内存访问"></a>3. 内存访问</h1><p>字单元：存放一个字型数据(16位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。</p>
<p>起始地址为N的字单元简称为N地址字单元。比如一个字单元由2、3两个内存单元组成，则这个字单元的起始地址为2。</p>
<h2 id="3-1-DS-和-address"><a href="#3-1-DS-和-address" class="headerlink" title="3.1 DS 和 [address]"></a>3.1 DS 和 [address]</h2><p>DS为数据段寄存器(存放段地址)，[address]表示一个内存单元(存放偏移地址)。</p>
<h2 id="3-2-mov指令-add、sub指令同"><a href="#3-2-mov指令-add、sub指令同" class="headerlink" title="3.2 mov指令(add、sub指令同)"></a>3.2 mov指令(add、sub指令同)</h2><ol>
<li>将数据直接送入寄存器：mov 寄存器，数据</li>
<li><p>将一个寄存器中的内容送人另一个寄存器：mov 寄存器，寄存器</p>
</li>
<li><p>将一个内存单元中的内容送入一个寄存器中：mov 寄存器，内存单元地址</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将10000H(1000:0)中的数据读到al中:</span><br><span class="line">mov bx, 1000H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov al, [0]</span><br></pre></td></tr></table></figure>
<ol>
<li>mov 内存单元，寄存器</li>
<li>mov 段寄存器，寄存器</li>
</ol>
<p>8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器，所以<code>mov ds,1000H</code>这条指令是非法的，只好用一个寄存器来进行中转，即先将1000H送入一个通用寄存器，再将通用寄存器的内容送入ds。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将al中的数据送入内存单元10000H中:</span><br><span class="line">mov bx, 1000H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov [0], al</span><br></pre></td></tr></table></figure>
<h2 id="3-3-CPU提供的栈机制"><a href="#3-3-CPU提供的栈机制" class="headerlink" title="3.3 CPU提供的栈机制"></a>3.3 CPU提供的栈机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ax 表示将寄存器ax中的数据送入栈中</span><br><span class="line">pop ax 	表示从栈顶取出数据送入ax</span><br></pre></td></tr></table></figure>
<p>8086CPU的入栈和出栈操作都是以字为单位进行的。</p>
<p>CPU如何知道栈顶位置？SS:SP，任意时刻，SS:SP指向栈顶元素。</p>
<p>push ax由以下两步完成：</p>
<ol>
<li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</li>
<li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶</li>
</ol>
<p>pop ax由以下两步完成：</p>
<ol>
<li>将SS:SP指向的内存单元处的数据送入ax中</li>
<li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</li>
</ol>
<h2 id="3-4-push指令-pop指令同"><a href="#3-4-push指令-pop指令同" class="headerlink" title="3.4 push指令(pop指令同)"></a>3.4 push指令(pop指令同)</h2><ol>
<li>将一个寄存器中的数据入栈：push 寄存器</li>
<li>将一个段寄存器中的数据入栈：push 段寄存器</li>
<li>将一个内存字单元处的字入栈：push 内存单元</li>
</ol>
<p>指令执行时，CPU要知道内存单元的地址，可以在push、pop指令中只给出内存单元的偏移地址，段地址在指令执行时，CPU从DS中取得。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">push [0]		;将1000:0处的字压入栈</span><br><span class="line">pop [2]			;出栈的数据送入1000:2处</span><br></pre></td></tr></table></figure>
<p>将10000H~1000FH这段空间当作栈，初始状态栈是空的，将ax, bx, DS中的数据入栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax		;设置栈的段地址</span><br><span class="line">mov sp,0010H	;设置栈的偏移地址,因栈为空,所以sp=000FH+0002H=0010H</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push ds</span><br></pre></td></tr></table></figure>
<p>push、pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为0~FFFFH</p>
<p>一个栈段的容量最大为64KB。</p>
<p>在10000H处写入字型数据2266H</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">方法一</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,2266H</span><br><span class="line">mov [0],ax</span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,2</span><br><span class="line">mov ax,2266H</span><br><span class="line">push ax</span><br></pre></td></tr></table></figure>
<h2 id="3-5-段的综述"><a href="#3-5-段的综述" class="headerlink" title="3.5 段的综述"></a>3.5 段的综述</h2><p>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问。</p>
<p>对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码中的指令。</p>
<p>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作的时候，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来用。</p>
<p>CPU将内存中的某段内容当作代码，是因CS:IP指向了那里；CPU将某段内存当作栈，是因为SS:SP指向了那里。</p>
<h1 id="4-第一个程序"><a href="#4-第一个程序" class="headerlink" title="4. 第一个程序"></a>4. 第一个程序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>在汇编语言程序中包含两种指令：伪指令、汇编指令。汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。伪指令没有对应的机器指令，最终不被CPU执行。伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。</p>
<h2 id="4-1-伪指令"><a href="#4-1-伪指令" class="headerlink" title="4.1 伪指令"></a>4.1 伪指令</h2><h3 id="4-1-1-XXX-segment-……-XXX-ends"><a href="#4-1-1-XXX-segment-……-XXX-ends" class="headerlink" title="4.1.1 XXX segment …… XXX ends"></a>4.1.1 XXX segment …… XXX ends</h3><p>segment和ends的功能是定义一个段，segment说明一个段开始，ends说明一个段结束。</p>
<p>一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。</p>
<h3 id="4-1-2-end"><a href="#4-1-2-end" class="headerlink" title="4.1.2 end"></a>4.1.2 end</h3><p>end是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译。</p>
<h3 id="4-1-3-assume"><a href="#4-1-3-assume" class="headerlink" title="4.1.3 assume"></a>4.1.3 assume</h3><p>这条伪指令的含义为“假设”，它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。</p>
<h2 id="4-2-汇编指令"><a href="#4-2-汇编指令" class="headerlink" title="4.2 汇编指令"></a>4.2 汇编指令</h2><h2 id="4-3-标号"><a href="#4-3-标号" class="headerlink" title="4.3 标号"></a>4.3 标号</h2><p>一个标号指代了一个地址，比如“codesg”。codesg在segment前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</p>
<h2 id="4-4-程序的结构"><a href="#4-4-程序的结构" class="headerlink" title="4.4 程序的结构"></a>4.4 程序的结构</h2><p>编程运算$2^3$</p>
<ol>
<li>定义一个段，名称为abc</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure>
<ol>
<li>在这个段中写入汇编指令，来实现我们的任务</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure>
<ol>
<li>指出程序要在何处结束</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ol>
<li>abc被当作代码段来用，所以应该将abc和cs联系起来</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ol>
<li>程序返回</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ol>
<li>语法错误和逻辑错误</li>
</ol>
<h2 id="4-5-编译"><a href="#4-5-编译" class="headerlink" title="4.5 编译"></a>4.5 编译</h2><p>源程序文件.asm-&gt;目标文件.obj</p>
<h2 id="4-6-连接"><a href="#4-6-连接" class="headerlink" title="4.6 连接"></a>4.6 连接</h2><p>目标文件.obj-&gt;可执行文件.exe</p>
<h1 id="5-bx-和loop指令"><a href="#5-bx-和loop指令" class="headerlink" title="5. [bx]和loop指令"></a>5. [bx]和loop指令</h1><p>[bx]同样表示一个内存单元，它的偏移地址在bx中。</p>
<p>“()”中的元素可以有3种类型：①寄存器名；②段寄存器名；③内存单元的物理地址。</p>
<p>(ax)表示ax中的内容，(20000H)表示内存20000H单元的内容，((ds)<em>16+(bx))表示ds中的内容为ADR1，bx中的内容为ADR2，内存ADR1\</em>16+ADR2单元的内容，即内存ADR1:ADR2单元的内容。</p>
<p>约定idata表示常量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[idata]</span><br><span class="line">mov ax,idata</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]		;(ax)=((ds)*16+(bx))</span><br><span class="line">mov [bx],ax		;((ds)*16+(bx))=(ax)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc bx			;inc bx的含义是bx中的内容加1</span><br></pre></td></tr></table></figure>
<h2 id="5-1-loop指令"><a href="#5-1-loop指令" class="headerlink" title="5.1 loop指令"></a>5.1 loop指令</h2><p>loop指令的格式：loop 标号</p>
<p>CPU执行loop指令的时候要进行两步操作：</p>
<ol>
<li>(cx)=(cx)-1</li>
<li>判断cx中的值，不为零则转至标号处执行程序，为零则向下执行</li>
</ol>
<p>编程运算$2^{12}$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,2</span><br><span class="line">	mov cx,11</span><br><span class="line">s:	add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">	mov ax,4c00H</span><br><span class="line">	int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>cx和loop指令相配合实现循环功能：①在cx中存放循环次数；②loop指令中的标号所标识地址要在前面；③要循环执行的程序段，要写在标号和loop指令的中间。</p>
<p><strong>在汇编源程序，数据不能以字母开头</strong>，所以要在前面加0。<code>A000H</code>在汇编源程序中要写为<code>0A000H</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,[0]		;(al)=0,将常量0送入al中(mov al,0含义相同)</span><br><span class="line">mov al,ds:[0]	;(al)=((ds)*16+0),将内存单元中的数据送入al中</span><br><span class="line">mov al,[bx]		;(al)=((ds)*16+(bx)),将内存单元中的数据送入al中</span><br><span class="line">mov al,ds:[bx]	;与mov al,[bx]含义相同</span><br></pre></td></tr></table></figure>
<p>（1）在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须用”[]“来表示存储单元，如果在”[]“里用一个常量idata直接给出内存单元的偏移地址，就要在”[]“的前面显式地给出段地址所在的寄存器。比如<code>mov al,ds:[0]</code></p>
<p>如果没有在”[]“的前面显式地给出段地址所在的段寄存器，那么编译器会把指令中的[idata]解释为data，比如<code>mov al,[0]</code></p>
<p>（2）如果在”[]“里用寄存器，比如bx，间接给出内存单元的偏移地址，则段地址默认在ds中。当然也可以显式地给出段地址所在的段寄存器。</p>
<h2 id="5-2-一段安全的空间"><a href="#5-2-一段安全的空间" class="headerlink" title="5.2 一段安全的空间"></a>5.2 一段安全的空间</h2><p>我们需要直接向一段内存中写入内容，这段内存空间不应存放系统或其他程序的数据或代码，否则写入操作很可能引发错误。DOS方式下，一般情况，0:200~0:2ff空间中没有系统或其他程序的数据或代码。</p>
<h2 id="5-3-loop和-bx-的联合应用"><a href="#5-3-loop和-bx-的联合应用" class="headerlink" title="5.3 loop和[bx]的联合应用"></a>5.3 loop和[bx]的联合应用</h2><p>在循环中，源始单元ffff:X和目标单元0020:X的偏移地址X是变量，可以用bx来存放。</p>
<h2 id="5-4-段前缀"><a href="#5-4-段前缀" class="headerlink" title="5.4 段前缀"></a>5.4 段前缀</h2><img src="/posts/de6e58e0/%E6%AE%B5%E5%89%8D%E7%BC%80.PNG" class="" title="段前缀">
<h1 id="6-包含多个段的程序"><a href="#6-包含多个段的程序" class="headerlink" title="6. 包含多个段的程序"></a>6. 包含多个段的程序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov ax,0</span><br><span class="line">	</span><br><span class="line">	mov cx,8</span><br><span class="line">s:add ax,cs:[bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>dw即define word，定义字型数据。</p>
<p>程序在运行的时候CS中存放代码段的段地址，所以可以从CS中得到它们的段地址。dw定义的数据处于代码段的最开始，所以偏移地址为0，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。程序运行时，它们的地址就是cs:0, cs:2, cs:4, cs:6, cs:8, cs:a, cs:c, cs:e。</p>
<p>end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。<code>end 标号</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">start:	mov bx,0		;程序的第一条指令</span><br><span class="line">		mov ax,0</span><br><span class="line">	</span><br><span class="line">        mov cx,8</span><br><span class="line">    s:add ax,cs:[bx]</span><br><span class="line">        add bx,2</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h2 id="6-1-在代码段中使用栈"><a href="#6-1-在代码段中使用栈" class="headerlink" title="6.1 在代码段中使用栈"></a>6.1 在代码段中使用栈</h2><p>程序运行时，定义的数据存放在cs:0~cs:F单元中，共8个字单元。依次将这8个字单元中的数据入栈，然后再依次出栈到这8个字单元中，从而实现数据的逆序存放。（将cs:10~cs:2F的内存空间当作栈来用）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">			;用dw定义16个字型数据，在程序加载后，将取得16个字的内存空间存放这16个数据</span><br><span class="line">			;在后面的程序中将这段空间当作栈来使用</span><br><span class="line">start:	mov ax,cs</span><br><span class="line">		mov ss,ax</span><br><span class="line">		mov sp,30h		;将设置栈顶ss:sp指向cs:30</span><br><span class="line">		</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,8</span><br><span class="line">s:		push cs:[bx]</span><br><span class="line">		add bx,2</span><br><span class="line">		loop s			;将代码段0~15单元中的8个字型数据依次入栈</span><br><span class="line">		</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,8</span><br><span class="line">s0:		pop cs:[bx]</span><br><span class="line">		add bx,2</span><br><span class="line">		loop s0			;出栈8个字型数据到代码段0~15单元中</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start				;指明程序的入口在start处</span><br></pre></td></tr></table></figure>
<h2 id="6-2-将数据、代码、栈放入不同的段"><a href="#6-2-将数据、代码、栈放入不同的段" class="headerlink" title="6.2 将数据、代码、栈放入不同的段"></a>6.2 将数据、代码、栈放入不同的段</h2><p>在前面的内容中，我们在程序中用到了数据和栈，将数据、栈和代码都放到了一个段里面。我们在编程的时候要注意何处是数据，何处是栈，何处是代码。这样做会产生两个问题：</p>
<ol>
<li>把它们放到一个段中使程序显得混乱</li>
<li>前面数据中处理的数据很少，用到的栈空间也小，加上没有多长的代码，放到一个段里面没有问题。但如果数据、栈、代码需要的空间超过64KB，就不能放在一个段中（8086模式中一个段的容量不能大于64KB）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line">stack segment</span><br><span class="line">	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:	mov ax,stack	;将名为stack段的段地址送入ax</span><br><span class="line">		mov ss,ax</span><br><span class="line">		mov sp,20h		</span><br><span class="line">;设置栈顶ss:sp指向stack:20(在整个程序中是cs:30,但在栈段是从0:10~0:2F,所以是stack:20)</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax		;ds指向data段</span><br><span class="line">		mov bx,0		;ds:bx指向data段中的第一个单元</span><br><span class="line">		</span><br><span class="line">		mov cx,8</span><br><span class="line">s:		push [bx]</span><br><span class="line">		add bx,2</span><br><span class="line">		loop s			;将data段中的0~15单元中的8个字型数据依次入栈</span><br><span class="line">		</span><br><span class="line">		mov cx,8</span><br><span class="line">s0:		pop [bx]</span><br><span class="line">		add bx,2</span><br><span class="line">		loop s0			;依次出栈8个字型数据到data段的0~15单元中</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h1 id="7-更灵活的定位内存地址的方法"><a href="#7-更灵活的定位内存地址的方法" class="headerlink" title="7. 更灵活的定位内存地址的方法"></a>7. 更灵活的定位内存地址的方法</h1><h2 id="7-1-and和or指令"><a href="#7-1-and和or指令" class="headerlink" title="7.1 and和or指令"></a>7.1 and和or指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">and指令:逻辑与指令，按位进行与运算(1and1=1,1and0=0,0and0=0)</span><br><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br><span class="line">执行后:al=00100011B</span><br><span class="line"></span><br><span class="line">or指令:逻辑或指令，按位进行或运算(1or1=1,1or0=1,0or0=0)</span><br><span class="line">mov al,01100011B</span><br><span class="line">or al,00111011B</span><br><span class="line">执行后:al=01111011B</span><br></pre></td></tr></table></figure>
<h2 id="7-2-ASCII码"><a href="#7-2-ASCII码" class="headerlink" title="7.2 ASCII码"></a>7.2 ASCII码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;61h,b-&gt;62h</span><br></pre></td></tr></table></figure>
<h2 id="7-3-以字符形式给出的数据"><a href="#7-3-以字符形式给出的数据" class="headerlink" title="7.3 以字符形式给出的数据"></a>7.3 以字符形式给出的数据</h2><p>在汇编程序中，用’’的方式指明数据是以字符的形式给出的，编译器将它们转化为相对应的ASCII码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	db &#x27;unIX&#x27;</span><br><span class="line">	db &#x27;foRK&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:	mov al,&#x27;a&#x27;</span><br><span class="line">		mov bl,&#x27;b&#x27;</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h2 id="7-4-大小写转换的问题"><a href="#7-4-大小写转换的问题" class="headerlink" title="7.4 大小写转换的问题"></a>7.4 大小写转换的问题</h2><p>在codesg中填写代码，将tadasg中的第一个字符串转化为大写，第二个字符串转化为小写。</p>
<img src="/posts/de6e58e0/ASCII%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6.jpg" class="" title="ASCII码表">
<p>方法一：小写字母的ASCII码值比大写字母的ASCII码值大20H。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;BaSiC&#x27;</span><br><span class="line">	db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:	mov ax,datasg</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,5</span><br><span class="line">	s:	mov al,[bx]</span><br><span class="line">		如果(al)&gt;61H,则为小写字母的ASCII码,则:sub al,20h</span><br><span class="line">		mov [bx],al</span><br><span class="line">		inc bx</span><br><span class="line">		loop s</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>方法二：大写字母的第6位全为0，小写字母的第6位全为1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;BaSiC&#x27;</span><br><span class="line">	db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:	mov ax,datasg</span><br><span class="line">		mov ds,ax		;设置ds指向datasg段</span><br><span class="line">		mov bx,0		;设置(bx)=0,ds:bx指向&#x27;BaSiC&#x27;的第一个字母</span><br><span class="line">		mov cx,5</span><br><span class="line">	s:	mov al,[bx]		;将ASCII码从ds:bx所指向的单元中取出</span><br><span class="line">		and al,11011111B;将al中的ASCII码的第6位置0,变为大写字母</span><br><span class="line">		mov [bx],al</span><br><span class="line">		inc bx</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">		mov bx,5		;设置(bx)=5,ds:bx指向&#x27;iNfOrMaTiOn&#x27;的第一个字母</span><br><span class="line">		mov cx,11</span><br><span class="line">	s0: mov al,[bx]</span><br><span class="line">		or al,00100000B</span><br><span class="line">		mov [bx],al</span><br><span class="line">		inc bx</span><br><span class="line">		loop s0</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h2 id="7-5-bx-idata"><a href="#7-5-bx-idata" class="headerlink" title="7.5 [bx+idata]"></a>7.5 [bx+idata]</h2><p>[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata</p>
<p>mov ax,[bx+200]-&gt;(ax)=((ds)*16+(bx)+200)</p>
<p>简化7.4方法二(但这个一定要两个字符串长度相同)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    mov ax,datasg</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov bx,0</span><br><span class="line"></span><br><span class="line">    mov cx,5</span><br><span class="line">s:	mov al,[bx]		;定位第一个字符串中的字符</span><br><span class="line">	and al,11011111b</span><br><span class="line">	mov [bx],al</span><br><span class="line">	mov al,[5+bx]	;定位第二个字符串中的字符</span><br><span class="line">	or al,00100000b</span><br><span class="line">	mov [5+bx],al</span><br><span class="line">	inc bx</span><br><span class="line">	loop s</span><br></pre></td></tr></table></figure>
<p>[bx]=0[bx]，[5+bx]=5[bx]</p>
<h2 id="7-6-SI-和-DI"><a href="#7-6-SI-和-DI" class="headerlink" title="7.6 SI 和 DI"></a>7.6 SI 和 DI</h2><p>si 和 di不能够分成两个8位寄存器来使用。</p>
<p>用ds:si指向要复制的源始字符串，用ds:di指向复制的目的空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line"> db &#x27;welcome to masm!&#x27;</span><br><span class="line"> db &#x27;................&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:	mov ax,datasg</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov si,0</span><br><span class="line">		mov di,16		;复制到它后面的数据区，后面数据区的偏移地址为16</span><br><span class="line">		</span><br><span class="line">		mov cx,8		;一次复制2个字节，一共循环8次</span><br><span class="line">	s:	mov ax,[si]</span><br><span class="line">		mov [di],ax</span><br><span class="line">		add si,2</span><br><span class="line">		add di,2</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>利用[bx(si或di)+idata]的方式使程序变简洁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">start:	mov ax,datasg</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov si,0</span><br><span class="line">		mov cx,8</span><br><span class="line">	s:	mov ax,0[si]</span><br><span class="line">		mov 16[si],ax</span><br><span class="line">		add si,2</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h2 id="7-7-bx-si-和-bx-di"><a href="#7-7-bx-si-和-bx-di" class="headerlink" title="7.7 [bx+si]和[bx+di]"></a>7.7 [bx+si]和[bx+di]</h2><p>[bx+si]表示一个内存单元，它的偏移地址为(bx)+(si)，[bx+di]同。</p>
<p>mov ax,[bx+si]-&gt;(ax)=((ds)*16+(bx)+(si))</p>
<p>mov ax,[bx+si]=mov ax,[bx][si]</p>
<h2 id="7-8-bx-si-idata-和-bx-di-idata"><a href="#7-8-bx-si-idata-和-bx-di-idata" class="headerlink" title="7.8 [bx+si+idata]和[bx+di+idata]"></a>7.8 [bx+si+idata]和[bx+di+idata]</h2><p>[bx+si+idata]表示一个内存单元，它的偏移地址为(bx)+(si)+idata，[bx+di+idata]同。</p>
<p>mov ax,[bx+si+idata]-&gt;(ax)=((ds)*16+(bx)+(si)+idata)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  mov ax,[bx+si+idata]</span><br><span class="line">= mov ax,idata[bx][si]</span><br><span class="line">= mov ax,[bx].idata[si]</span><br><span class="line">= mov ax,[bx][si].idata</span><br></pre></td></tr></table></figure>
<h2 id="7-9-不同寻址方式的灵活应用"><a href="#7-9-不同寻址方式的灵活应用" class="headerlink" title="7.9 不同寻址方式的灵活应用"></a>7.9 不同寻址方式的灵活应用</h2><p>编程，将datasg段中每个单词首字母改为大写字母(用bx定位每行的起始地址，用3定位要修改的列，用[bx+idata]对目标单元进行寻址)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;1..file.........&#x27;	;16个字节</span><br><span class="line">	db &#x27;2..edit.........&#x27;</span><br><span class="line">	db &#x27;3..search.......&#x27;</span><br><span class="line">	db &#x27;4..view.........&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start: 	mov ax,datasg</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,4</span><br><span class="line">	s:  mov al,[bx+3]</span><br><span class="line">		and al,11011111b</span><br><span class="line">        mov [bx+3],al</span><br><span class="line">		add bx,16</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>编程，将datasg段中每个单词改为大写字母(用bx定位每行的起始地址，用si定位要修改的列，用[bx+si]方式对目标单元进行寻址)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;ibm.............&#x27;</span><br><span class="line">	db &#x27;dec.............&#x27;</span><br><span class="line">	db &#x27;dos.............&#x27;</span><br><span class="line">	db &#x27;vax.............&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:	mov ax,datasg</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,4</span><br><span class="line">	s0: mov dx,cx			;将外层循环的cx值保存在dx中</span><br><span class="line">		mov si,0</span><br><span class="line">		</span><br><span class="line">		mov cx,3			;cx设置为内层循环的次数</span><br><span class="line">	s:	mov al,[bx+si]</span><br><span class="line">		and al,11011111b</span><br><span class="line">		mov [bx+si],al</span><br><span class="line">		inc si</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">		add bx,16</span><br><span class="line">		mov cx,dx			;用dx中存放的外层循环的计数值恢复cx</span><br><span class="line">		loop s0</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>如果dx也被用了呢？所有寄存器都被用了呢？可以使用内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;ibm.............&#x27;</span><br><span class="line">	db &#x27;dec.............&#x27;</span><br><span class="line">	db &#x27;dos.............&#x27;</span><br><span class="line">	db &#x27;vax.............&#x27;</span><br><span class="line">	dw 0					;定义一个字，用来暂存cx</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:	mov ax,datasg</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,4</span><br><span class="line">	s0: mov ds:[40h],cx		;将外层循环的cx值保存在datasg:40h单元中</span><br><span class="line">		mov si,0</span><br><span class="line">		</span><br><span class="line">		mov cx,3			;cx设置为内层循环的次数</span><br><span class="line">	s:	mov al,[bx+si]</span><br><span class="line">		and al,11011111b</span><br><span class="line">		mov [bx+si],al</span><br><span class="line">		inc si</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">		add bx,16</span><br><span class="line">		mov cx,ds:[40h]		;用datasg:40h单元中的值恢复cx</span><br><span class="line">		loop s0</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>如果需要保存多个数据，需要记住哪个数据暂存在哪个单元中，这样程序容易混乱。一般来说，在需要暂存数据的时候，我们都应该使用栈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg,ss:stacksg</span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;ibm.............&#x27;</span><br><span class="line">	db &#x27;dec.............&#x27;</span><br><span class="line">	db &#x27;dos.............&#x27;</span><br><span class="line">	db &#x27;vax.............&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">stacksg segment</span><br><span class="line">	dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:	mov ax,stacksg</span><br><span class="line">		mov ss,ax</span><br><span class="line">		mov sp,16</span><br><span class="line">		mov ax,datasg</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,4</span><br><span class="line">	s0: push cx				;将外层循环的cx值压栈</span><br><span class="line">		mov si,0</span><br><span class="line">		</span><br><span class="line">		mov cx,3			;cx设置为内层循环的次数</span><br><span class="line">	s:	mov al,[bx+si]</span><br><span class="line">		and al,11011111b</span><br><span class="line">		mov [bx+si],al</span><br><span class="line">		inc si</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">		add bx,16</span><br><span class="line">		pop cx				;从栈顶弹出原cx的值恢复cx</span><br><span class="line">		loop s0</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h1 id="8-数据处理"><a href="#8-数据处理" class="headerlink" title="8. 数据处理"></a>8. 数据处理</h1><p>reg表示一个寄存器，sreg表示一个段寄存器。</p>
<p>reg有ax, bx, cx, dx, ah, al, bh, bl, ch, cl, dh, dl, sp, bp, si, di</p>
<p>sreg有ds, ss, cs, es</p>
<h2 id="8-1-bx-si-di和bp"><a href="#8-1-bx-si-di和bp" class="headerlink" title="8.1 bx, si, di和bp"></a>8.1 bx, si, di和bp</h2><ol>
<li>在8086CPU中又有这4个寄存器可以在“[]”中进行内存单元寻址</li>
<li>在“[]”中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si, bx和di, bp和si, bp和di</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bp+di]</span><br></pre></td></tr></table></figure>
<ol>
<li>只要在“[]”中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bp]				(ax)=((ss)*16+(bp))</span><br><span class="line">mov ax,[bp+si+idata]	(ax)=((ss)*16+(bp)+(si)+idata)</span><br></pre></td></tr></table></figure>
<h2 id="8-2-数据的位置"><a href="#8-2-数据的位置" class="headerlink" title="8.2 数据的位置"></a>8.2 数据的位置</h2><p>指令在执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>指令执行前数据的位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov bx,[0]</td>
<td>内存，ds:0单元</td>
</tr>
<tr>
<td>mov bx,ax</td>
<td>CPU内部，ax寄存器</td>
</tr>
<tr>
<td>mov bx,1</td>
<td>CPU内部，指令缓冲器</td>
</tr>
</tbody>
</table>
</div>
<h3 id="8-2-1-数据位置的表达"><a href="#8-2-1-数据位置的表达" class="headerlink" title="8.2.1 数据位置的表达"></a>8.2.1 数据位置的表达</h3><ol>
<li>立即数(idata)</li>
<li>寄存器</li>
<li>段地址(SA)和偏移地址(EA)</li>
</ol>
<h3 id="8-2-2-寻址方式"><a href="#8-2-2-寻址方式" class="headerlink" title="8.2.2 寻址方式"></a>8.2.2 寻址方式</h3><img src="/posts/de6e58e0/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%B0%8F%E7%BB%93.png" class="" title="寻址方式">
<h2 id="8-3-数据的长度"><a href="#8-3-数据的长度" class="headerlink" title="8.3 数据的长度"></a>8.3 数据的长度</h2><p>8086CPU可以处理两种尺寸的数据，byte和word。</p>
<ol>
<li>通过寄存器名指明要处理的数据的尺寸</li>
<li>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte</li>
</ol>
<p>例如下面的指令中，用word ptr指明了指令访问的内存单元是一个字单元</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]</span><br></pre></td></tr></table></figure>
<p>下面的指令中，用byte ptr指明了指令访问的内存单元是一个字节单元</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr ds:[0],1</span><br><span class="line">add byte ptr [bx],2</span><br></pre></td></tr></table></figure>
<ol>
<li>其他方法</li>
</ol>
<p>有些指令默认了访问的是字单元还是字节单元，比如push [1000H]就不用指明访问的是字单元还是字节单元。因为push指令只进行字操作。</p>
<h2 id="8-4-div指令"><a href="#8-4-div指令" class="headerlink" title="8.4 div指令"></a>8.4 div指令</h2><p>div是除法指令，使用div做除法时应注意以下问题</p>
<ol>
<li>除数：有8位和16位两种，在一个reg或内存单元中。</li>
<li>被除数：默认放在AX  或  DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。</li>
<li>结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br><span class="line"></span><br><span class="line">div byte ptr ds:[0]</span><br><span class="line">含义:(al)=(ax)/((ds)*16+0)的商</span><br><span class="line">	(ah)=(ax)/((ds)*16+0)的余数</span><br><span class="line">	</span><br><span class="line">div word ptr es:[0]</span><br><span class="line">含义:(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商</span><br><span class="line">	(dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数</span><br></pre></td></tr></table></figure>
<p>编程，利用除法指令计算100001/100</p>
<p>被除数100001大于65535，不能用ax寄存器存放，所以只能用dx和ax两个寄存器联合存放100001，也就是说要进行16位的除法。除数100小于255，可以在一个8位寄存器中存放，但是因为被除数是32位的，除数应为16位，所以要用一个16位寄存器来存放除数100。</p>
<p>因为要分别为dx和ax赋100001的高16位值和低16位值，所以应先将100001表示为16进制形式：186A1H</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86a1h		;(dx)*10000H+(ax)=100001h</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure>
<p>程序执行后，(ax)=03E8H(即1000)，(dx)=1(余数为1)</p>
<h2 id="8-5-伪指令dd"><a href="#8-5-伪指令dd" class="headerlink" title="8.5 伪指令dd"></a>8.5 伪指令dd</h2><p>dd(double word)双字型数据</p>
<p>用div计算data段中第一个数据除以第二个数据后的结果，商存在第三个数据的存储单元中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">	dd 100001</span><br><span class="line">	dw 100</span><br><span class="line">	dw 0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov ax,ds:[0]		;ds:[0]字单元中的低16位存储在ax中</span><br><span class="line">	mov dx,ds:[2]		;ds:[2]字单元中的高16位存储在dx中</span><br><span class="line">	div word ptr ds:[4]	;用dx:ax中的32位数据除以ds:[4]字单元中的数据</span><br><span class="line">	mov ds:[6],ax		;将商存储在ds:[6]字单元中</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure>
<h2 id="8-6-dup"><a href="#8-6-dup" class="headerlink" title="8.6 dup"></a>8.6 dup</h2><p>dup是一个操作符，在汇编语言中同db, dw, dd等一样，也是由编译器识别处理的符号。它是和db, dw, dd等数据定义伪指令配合使用，用来进行数据的重复。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0)			;定义了3个字节,它们的值都是0,相当于db 0,0,0</span><br><span class="line">db 3 dup (0,1,2)		;db 0,1,2,0,1,2,0,1,2</span><br><span class="line">db 3 dup (&#x27;abc&#x27;,&#x27;ABC&#x27;)</span><br></pre></td></tr></table></figure>
<p>dup使用格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db 重复的次数 dup (重复的字节型数据)</span><br><span class="line">dw 重复的次数 dup (重复的字型数据)</span><br><span class="line">dd 重复的次数 dup (重复的双字型数据)</span><br></pre></td></tr></table></figure>
<h1 id="9-转移指令的原理"><a href="#9-转移指令的原理" class="headerlink" title="9. 转移指令的原理"></a>9. 转移指令的原理</h1><p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。转移指令就是可以控制CPU执行内存中某处代码的指令。</p>
<p>8086CPU的转移行为有以下几类</p>
<ul>
<li>只修改IP时，称为段内转移，比如：jmp ax</li>
<li>同时修改CS和IP时，称为段间转移，比如：jmp 1000:0</li>
</ul>
<p>由于转移指令对IP的修改范围不同，段内转移又分为短转移和近转移</p>
<ul>
<li>短转移IP的修改范围为-128~127</li>
<li>近转移IP的修改范围为-32768~32767</li>
</ul>
<p>8086CPU的转移指令分为以下几类</p>
<ul>
<li>无条件转移指令(jmp)</li>
<li>条件转移指令</li>
<li>循环指令(loop)</li>
<li>过程</li>
<li>中断</li>
</ul>
<h2 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h2><p>操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:	mov ax,offset start		;相当于mov ax,0(指令长度为3字节)</span><br><span class="line">	s:	mov ax,offset s			;相当于mov ax,3</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>程序在运行中将s处的一条指令复制到s0处</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cd:codesg</span><br><span class="line">codesg segment</span><br><span class="line">s:	mov ax,bx			;mov ax,bx的机器码占两个字节</span><br><span class="line">	mov si,offset s</span><br><span class="line">	mov di,offset s0</span><br><span class="line">	mov ax,cs:[si]</span><br><span class="line">	mov cs:[di],ax</span><br><span class="line">s0:	nop					;nop机器码占一个字节</span><br><span class="line">	nop</span><br><span class="line">codesg ends</span><br><span class="line">end s</span><br></pre></td></tr></table></figure>
<h2 id="9-2-jmp指令"><a href="#9-2-jmp指令" class="headerlink" title="9.2 jmp指令"></a>9.2 jmp指令</h2><p>jmp为无条件转移指令，可以指修改IP，也可以同时修改CS和IP。</p>
<p>jmp指令要给出两种信息：</p>
<ol>
<li>转移的目的地址</li>
<li>转移的距离(段间转移、段内短转移、段内近转移)</li>
</ol>
<h3 id="9-2-1-依据位移进行转移的jmp指令"><a href="#9-2-1-依据位移进行转移的jmp指令" class="headerlink" title="9.2.1 依据位移进行转移的jmp指令"></a>9.2.1 依据位移进行转移的jmp指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号(转到标号处执行指令)：(IP)=(IP)+8位位移</span><br></pre></td></tr></table></figure>
<p>这种格式的jmp指令实现的是段内短转移，它对IP的修改范围为-128~127，向前转移时最多可以越过128个字节，向后转移最多可以越过127个字节。</p>
<p>CPU在执行jmp指令的时候并不需要转移的目的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:	mov ax,0</span><br><span class="line">		jmp short s</span><br><span class="line">		add ax,1</span><br><span class="line">	s:	inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp near ptr 标号：(IP)=(IP)+16位位移</span><br></pre></td></tr></table></figure>
<p>这种格式的jmp指令实现的是段内近转移，它对IP的修改范围为-32768~32767，向前转移时最多可以越过32768个字节，向后转移最多可以越过32767个字节。</p>
<h3 id="9-2-2-转移的目的地址在指令中的jmp指令"><a href="#9-2-2-转移的目的地址在指令中的jmp指令" class="headerlink" title="9.2.2 转移的目的地址在指令中的jmp指令"></a>9.2.2 转移的目的地址在指令中的jmp指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp far ptr 标号：(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址</span><br></pre></td></tr></table></figure>
<p>这种格式的jmp指令实现的是段间转移，又称远转移。far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:	mov ax,0</span><br><span class="line">		mov bx,0</span><br><span class="line">		jmp far ptr s</span><br><span class="line">		db 256 dup (0)</span><br><span class="line">	s:	add ax,1</span><br><span class="line">		inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h3 id="9-2-3-转移地址在寄存器中的-jmp指令"><a href="#9-2-3-转移地址在寄存器中的-jmp指令" class="headerlink" title="9.2.3 转移地址在寄存器中的 jmp指令"></a>9.2.3 转移地址在寄存器中的 jmp指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 16位reg：(IP)=(16位reg)</span><br></pre></td></tr></table></figure>
<h3 id="9-2-4-转移地址在内存中的jmp指令"><a href="#9-2-4-转移地址在内存中的jmp指令" class="headerlink" title="9.2.4 转移地址在内存中的jmp指令"></a>9.2.4 转移地址在内存中的jmp指令</h3><p>转移地址在内存中的jmp指令有两种格式：</p>
<ol>
<li>jmp word ptr 内存单元地址(段内转移)</li>
</ol>
<p>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br></pre></td></tr></table></figure>
<p>执行后，(IP)=0123H</p>
<ol>
<li>jmp dword ptr 内存单元地址(段间转移)</li>
</ol>
<p>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</p>
<p>(CS)=(内存单元地址+2)，(IP)=(内存单元地址)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure>
<p>执行后，(CS)=0，(IP)=0123h，CS:IP指向0000:0123</p>
<h2 id="9-3-jcxz指令"><a href="#9-3-jcxz指令" class="headerlink" title="9.3 jcxz指令"></a>9.3 jcxz指令</h2><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jcxz 标号(如果(cx)=0,转移到标号处执行)：当(cx)=0时，(IP)=(IP)+8位位移</span><br><span class="line">if((cx)==0) jmp short 标号;</span><br></pre></td></tr></table></figure>
<h2 id="9-4-loop指令"><a href="#9-4-loop指令" class="headerlink" title="9.4 loop指令"></a>9.4 loop指令</h2><p>loop指令是循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop 标号((cx)=(cx)-1,如果(cx)≠0，转移到标号处执行)：如果(cx)≠0,(IP)=(IP)+8位位移</span><br><span class="line">(cx)--;</span><br><span class="line">if((cx)!=0) jmp short 标号;</span><br></pre></td></tr></table></figure>
<h1 id="10-call和ret指令"><a href="#10-call和ret指令" class="headerlink" title="10. call和ret指令"></a>10. call和ret指令</h1><p>call和ret指令都是转移指令，他们都修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序的设计。</p>
<h2 id="10-1-ret和retf"><a href="#10-1-ret和retf" class="headerlink" title="10.1 ret和retf"></a>10.1 ret和retf</h2><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</p>
<h3 id="10-1-1-ret指令"><a href="#10-1-1-ret指令" class="headerlink" title="10.1.1 ret指令"></a>10.1.1 ret指令</h3><p>CPU执行ret指令时，进行下面2步操作：</p>
<ol>
<li>(IP)=((SS)*16+(SP))</li>
<li>(SP)=(SP)+2</li>
</ol>
<p>CPU执行ret指令时相当于进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br></pre></td></tr></table></figure>
<h3 id="10-1-2-retf指令"><a href="#10-1-2-retf指令" class="headerlink" title="10.1.2 retf指令"></a>10.1.2 retf指令</h3><p>CPU执行retf指令时，进行下面4步操作：</p>
<ol>
<li>(IP)=((SS)*16+(SP))</li>
<li>(SP)=(SP)+2</li>
<li>(CS)=((SS)*16+(SP))</li>
<li>(SP)=(SP)+2</li>
</ol>
<p>CPU执行retf指令时相当于进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br></pre></td></tr></table></figure>
<h2 id="10-2-call指令"><a href="#10-2-call指令" class="headerlink" title="10.2 call指令"></a>10.2 call指令</h2><p>CPU执行call指令时，进行2步操作：</p>
<ol>
<li>将当前的IP或CS和IP压入栈中</li>
<li>转移</li>
</ol>
<p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。</p>
<h3 id="10-2-1-依据位移进行转移的call指令"><a href="#10-2-1-依据位移进行转移的call指令" class="headerlink" title="10.2.1 依据位移进行转移的call指令"></a>10.2.1 依据位移进行转移的call指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 标号(将当前的IP压栈后，转到标号处执行指令)</span><br></pre></td></tr></table></figure>
<p>CPU执行此种格式的call指令时，进行如下操作：</p>
<ol>
<li>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)</li>
<li>(IP)=(IP)+16位位移</li>
</ol>
<p>CPU执行“call 标号“时，相当于进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure>
<h3 id="10-2-2-转移的目的地址在指令中的call指令"><a href="#10-2-2-转移的目的地址在指令中的call指令" class="headerlink" title="10.2.2 转移的目的地址在指令中的call指令"></a>10.2.2 转移的目的地址在指令中的call指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call far ptr 标号</span><br></pre></td></tr></table></figure>
<p>实现的是段间转移。</p>
<p>CPU执行此种格式的call指令时，进行如下操作：</p>
<ol>
<li><p>(sp)=(sp)-2</p>
<p>((ss)*16+(sp))=(CS)</p>
<p>(sp)=(sp)-2</p>
<p>((ss)*16+(sp))=(IP)</p>
</li>
<li><p>(CS)=标号所在段的段地址</p>
<p>(IP)=标号在段中的偏移地址</p>
</li>
</ol>
<p>CPU执行“call far ptr 标号“时，相当于进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure>
<h3 id="10-2-3-转移地址在寄存器中的call指令"><a href="#10-2-3-转移地址在寄存器中的call指令" class="headerlink" title="10.2.3 转移地址在寄存器中的call指令"></a>10.2.3 转移地址在寄存器中的call指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 16位reg</span><br></pre></td></tr></table></figure>
<p>CPU执行此种格式的call指令时，进行如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(sp)=(sp)-2</span><br><span class="line">((ss)*16+(sp))=(IP)</span><br><span class="line">(IP)=(16位reg)</span><br></pre></td></tr></table></figure>
<p>CPU执行“call 16位reg“时，相当于进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16位reg</span><br></pre></td></tr></table></figure>
<h3 id="10-2-4-转移地址在内存中的call指令"><a href="#10-2-4-转移地址在内存中的call指令" class="headerlink" title="10.2.4 转移地址在内存中的call指令"></a>10.2.4 转移地址在内存中的call指令</h3><p>转移地址在内存中的call指令有两种格式：</p>
<ol>
<li>call word ptr 内存单元地址</li>
</ol>
<p>CPU执行“call word ptr 内存单元地址“时，相当于进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">call word ptr ds:[0]</span><br></pre></td></tr></table></figure>
<p>执行后，(IP)=0123h，(sp)=0EH</p>
<ol>
<li>call dword ptr 内存单元地址</li>
</ol>
<p>CPU执行“call dword ptr 内存单元地址“时，相当于进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">call dword ptr ds:[0]</span><br></pre></td></tr></table></figure>
<p>执行后，(CS)=0，(IP)=0123H，(sp)=0CH</p>
<h2 id="10-3-call和ret的配合使用"><a href="#10-3-call和ret的配合使用" class="headerlink" title="10.3 call和ret的配合使用"></a>10.3 call和ret的配合使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cd:code</span><br><span class="line">code segment</span><br><span class="line">start:	mov ax,1</span><br><span class="line">		mov cx,3</span><br><span class="line">		call s</span><br><span class="line">		mov bx,ax		;(bx)=8</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">	s:	add ax,ax</span><br><span class="line">		loop s</span><br><span class="line">		ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h2 id="10-4-mul指令"><a href="#10-4-mul指令" class="headerlink" title="10.4 mul指令"></a>10.4 mul指令</h2><p>mul指令是乘法指令，使用mul做乘法时要注意两点：</p>
<ol>
<li>两个相乘的数：要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认放在AX中，另一个放在16位reg或内存字单元中</li>
<li>结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中存放，低位在AX中存放</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元</span><br><span class="line"></span><br><span class="line">mul byte ptr ds:[0]</span><br><span class="line">含义：(ax)=(al)*((ds)*16+0)</span><br><span class="line"></span><br><span class="line">mul word ptr [bx+si+8]</span><br><span class="line">含义：(ax)=(ax)*((ds)*16+(bx)+(si)+8)结果的低16位</span><br><span class="line">	 (dx)=(ax)*((ds)*16+(bx)+(si)+8)结果的高16位</span><br></pre></td></tr></table></figure>
<p>计算100*10。(100和10小于255，可以做8位乘法)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,100</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure>
<p>结果：(ax)=1000(03E8H)</p>
<p>计算100*10000。(100小于255，但10000大于255，所以必须做16位乘法)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,100</span><br><span class="line">mov bx,10000	</span><br><span class="line">mul bx</span><br></pre></td></tr></table></figure>
<p>结果：(ax)=4240h，(dx)=000FH（F4240H=1000000）</p>
<h1 id="11-标志寄存器"><a href="#11-标志寄存器" class="headerlink" title="11. 标志寄存器"></a>11. 标志寄存器</h1><p>标志寄存器作用：</p>
<ol>
<li>用来存储相关指令的某些执行结果</li>
<li>用来为CPU执行相关指令提供行为依据</li>
<li>用来控制CPU的相关工作方式</li>
</ol>
<p>flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>15</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>OF</td>
<td>DF</td>
<td>IF</td>
<td>TF</td>
<td>SF</td>
<td>ZF</td>
<td></td>
<td>AF</td>
<td></td>
<td>PF</td>
<td></td>
<td>CF</td>
</tr>
</tbody>
</table>
</div>
<p>8086中flag寄存器只有标注的这些位有特殊的含义，其它8086CPU没有使用。</p>
<h2 id="11-1-ZF标志"><a href="#11-1-ZF标志" class="headerlink" title="11.1 ZF标志"></a>11.1 ZF标志</h2><p>flag的第6位是ZF，零标志位。它记录相关指令执行后，其结果是否为0。如果为0，ZF=1；否则ZF=0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure>
<p>执行后，(ax)=0，ZF=1</p>
<h2 id="11-2-PF标志"><a href="#11-2-PF标志" class="headerlink" title="11.2 PF标志"></a>11.2 PF标志</h2><p>flag的第2位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果1的个数为偶数，PF=1；否则PF=0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,10</span><br></pre></td></tr></table></figure>
<p>执行后，结果为11=00001011B，其中有3个1，PF=0</p>
<h2 id="11-3-SF标志"><a href="#11-3-SF标志" class="headerlink" title="11.3 SF标志"></a>11.3 SF标志</h2><p>flag的第7位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果结果为负，SF=1；否则SF=0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001B		;al=-127</span><br><span class="line">add al,1</span><br></pre></td></tr></table></figure>
<p>结果：(al)=10000010B，SF=1</p>
<h2 id="11-4-CF标志"><a href="#11-4-CF标志" class="headerlink" title="11.4 CF标志"></a>11.4 CF标志</h2><p>flag的第0位是CF，进位标志位。一般情况下，在进行<strong>无符号数运算</strong>时，它记录了运算结果的最高有效位向更高位的进位值，或从更高位借位。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>假想的更高位</td>
<td>最高有效位</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>当两数相加时，有可能产生从最高有效位向更高位的进位。CPU在运算的时候，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上。8086CPU就用flag的CF位来记录这个进位值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,98H</span><br><span class="line">add al,al		;98h+98h=130h=0001 0011 0000B</span><br></pre></td></tr></table></figure>
<p>执行后，(al)=30H，CF=1，CF记录了从最高有效位向更高位的进位值。</p>
<h2 id="11-5-OF标志"><a href="#11-5-OF标志" class="headerlink" title="11.5 OF标志"></a>11.5 OF标志</h2><p>flag的第11位是OF，溢出标志位。一般情况下，OF记录了<strong>有符号数运算</strong>的结果是否发生了溢出。如果发生溢出，OF=1；否则OF=0。</p>
<p>对于8位的有符号数据，机器所能表示的范围就是-128~127；对于16位的有符号数据，机器所能表示的范围是-32768~32767。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,0F0H		;0f0h=240=-16	240-128*2=-16</span><br><span class="line">add al,78H		;78h=120=-8</span><br></pre></td></tr></table></figure>
<p>执行后，对于无符号运算，0F0H+78H=168H=0001 0110 1000B，CF=1；对于有符号数，-16-8=-24，OF=0。</p>
<h2 id="11-6-adc指令"><a href="#11-6-adc指令" class="headerlink" title="11.6 adc指令"></a>11.6 adc指令</h2><p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc 操作对象1,操作对象2</span><br></pre></td></tr></table></figure>
<p>操作对象1=操作对象1+操作对象2+CF</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2		;(ax)=2</span><br><span class="line">mov bx,1		;(bx)=1</span><br><span class="line">sub bx,ax		;(bx)=-1=FFFFH		CF=1</span><br><span class="line">adc ax,1		;(ax)=(ax)+1+CF=4</span><br></pre></td></tr></table></figure>
<h2 id="11-7-sbb指令"><a href="#11-7-sbb指令" class="headerlink" title="11.7 sbb指令"></a>11.7 sbb指令</h2><p>sbb是带借位减法指令，它利用了CF位上记录的借位值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbb 操作对象1,操作对象2</span><br></pre></td></tr></table></figure>
<p>操作对象1=操作对象1-操作对象2-CF</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H		;(bx)=1000h</span><br><span class="line">mov ax,003EH		;(ax)=003eh</span><br><span class="line">sub bx,2000H		;(bx)=1000h-2000h=F000H		CF=1</span><br><span class="line">sbb ax,0020H		;(ax)=(ax)-20h-1=1D</span><br></pre></td></tr></table></figure>
<h2 id="11-8-cmp指令"><a href="#11-8-cmp指令" class="headerlink" title="11.8 cmp指令"></a>11.8 cmp指令</h2><p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp 操作对象1,操作对象2</span><br></pre></td></tr></table></figure>
<p>计算操作对象1-操作对象2但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,8		;(ax)=8</span><br><span class="line">mov bx,3		;(bx)=3</span><br><span class="line">cmp ax,bx		;(ax)-(bx)=5=0101b</span><br></pre></td></tr></table></figure>
<p>指令执行后，零标志位ZF=0，奇偶标志位PF=1，符号标志位SF=0，进位标志位CF=0，溢出标志位OF=0</p>
<p>如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正；反之亦然。</p>
<h2 id="11-9-检测比较结果的条件转移指令"><a href="#11-9-检测比较结果的条件转移指令" class="headerlink" title="11.9 检测比较结果的条件转移指令"></a>11.9 检测比较结果的条件转移指令</h2><p>除了jcxz指令外，CPU还提供了其他条件转移指令，大多数条件转移指令都检测标志寄存器的相关标志位，根据检测结果来决定是否修改IP。这些条件转移指令通常和cmp相配合使用，类似call和ret配合。</p>
<p>因为cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，所以根据cmp指令的比较结果进行转移的指令也分为两种，即根据无符号数的比较结果进行转移的条件转移指令(它们检测ZF、CF的值)和根据有符号数的比较结果进行转移的条件转移指令(SF、OF、ZF)。</p>
<p>常用的根据无符号数的比较结果进行转移的条件转移指令</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>全称</th>
<th>含义</th>
<th>检测的相关标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td>je</td>
<td>jump equal</td>
<td>等于则转移</td>
<td>zf=1</td>
</tr>
<tr>
<td>jne</td>
<td>jump not equal</td>
<td>不等于则转移</td>
<td>zf=0</td>
</tr>
<tr>
<td>jb</td>
<td>jump below</td>
<td>低于则转移</td>
<td>cf=1</td>
</tr>
<tr>
<td>jnb</td>
<td>jmp not below</td>
<td>不低于则转移</td>
<td>cf=0</td>
</tr>
<tr>
<td>ja</td>
<td>jump above</td>
<td>高于则转移</td>
<td>cf=0且zf=0</td>
</tr>
<tr>
<td>jna</td>
<td>jump not above</td>
<td>不高于则转移</td>
<td>cf=1或zf=1</td>
</tr>
<tr>
<td>jz</td>
<td>jump zero</td>
<td>零则转移</td>
<td>zf=1</td>
</tr>
<tr>
<td>jnz</td>
<td>jump not zero</td>
<td>非零则转移</td>
<td>zf=0</td>
</tr>
</tbody>
</table>
</div>
<p>编程统计data段中数值为8的字节的个数，用ax保存统计结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">	db 8,11,8,1,8,5,63,38</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov bx,0			;ds:bx指向第一个字节</span><br><span class="line">		mov ax,0			;初始化累加器</span><br><span class="line">		mov cx,8</span><br><span class="line">s:		cmp byte ptr [bx],8	;和8进行比较</span><br><span class="line">		jne next			;如果不相等则转到next，继续循环</span><br><span class="line">		inc ax				;如果相等将计数加1</span><br><span class="line">next:	inc bx</span><br><span class="line">		loop s				;程序执行后(ax)=3</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure>
<h2 id="11-10-DF标志和串传送指令"><a href="#11-10-DF标志和串传送指令" class="headerlink" title="11.10 DF标志和串传送指令"></a>11.10 DF标志和串传送指令</h2><p>flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。</p>
<p>df=0    每次操作后si、di递增；</p>
<p>df=1    每次操作后si、di递减。</p>
<h3 id="11-10-1-串传送指令"><a href="#11-10-1-串传送指令" class="headerlink" title="11.10.1 串传送指令"></a>11.10.1 串传送指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movsb</span><br></pre></td></tr></table></figure>
<p>执行movsb指令相当于进行下面操作：</p>
<ol>
<li><p>((es)<em>16+(di))=((ds)\</em>16+(si))</p>
</li>
<li><p>如果df=0则 (si)=(si)+1;(di)=(di)+1</p>
<p>如果df=1则 (si)=(si)-1;(di)=(di)-1</p>
</li>
</ol>
<p>movsb的功能是将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df的值，将si和递增或递减。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movsw</span><br></pre></td></tr></table></figure>
<p>movsw的功能是将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器df的值，将si和递增2或递减2。</p>
<p>movsb和movsw进行的是串传送操作的一个步骤，一般来说，movsb和movsw都和rep配合使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rep movsb</span><br></pre></td></tr></table></figure>
<p>用汇编语法来描述就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s:	movsb</span><br><span class="line">	loop s</span><br></pre></td></tr></table></figure>
<p>rep的作用是根据cx的值，重复执行后面的串传送指令。由于每执行一次movsb指令si和di都会递增或递减后一个或前一个单元，则rep movsb就可以循环实现(cx)个字符的传送。</p>
<p>由于df位决定着串传送指令执行后si和di改变的方向，所以CPU应该提供相应的指令来对df位进行设置，从而使人能够决定传送的方向。</p>
<p>8086CPU提供下面两条指令对df位进行设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cld指令:将标志寄存器的df位置0</span><br><span class="line">std指令:将标志寄存器的df位置1</span><br></pre></td></tr></table></figure>
<p>编程，用串传送指令，将data段中的第一个字符串复制到它后面的空间中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">	db &#x27;Welcome to masm!&#x27;</span><br><span class="line">	db 16 dup (0)</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>
<p>①传送的原始位置：ds:si    data:0</p>
<p>②传送的目的位置：es:di    data:10h</p>
<p>③传送的长度：cx                (cx)=16</p>
<p>④传送的方向：df                df=1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0			;ds:si指向data:0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,16			;es:di指向data:0010</span><br><span class="line">mov cx,16</span><br><span class="line">cld					;df=0,正向传送</span><br><span class="line">rep movsb</span><br></pre></td></tr></table></figure>
<h2 id="11-11-pushf和popf"><a href="#11-11-pushf和popf" class="headerlink" title="11.11 pushf和popf"></a>11.11 pushf和popf</h2><p>pushf的功能是将标志寄存器的值压栈，popf是从栈中弹出数据，送入标志寄存器中。</p>
<h1 id="12-内中断"><a href="#12-内中断" class="headerlink" title="12. 内中断"></a>12. 内中断</h1><p>任何一个通用的CPU，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。中断的意思是CPU不再接着(刚执行完的指令)向下执行，而是转去处理这个特殊信息。</p>
<p>对于8086CPU，当内部有下面的情况发生的时候将产生相应的中断信息：</p>
<ol>
<li>除法错误，比如执行div指令产生的除法溢出    0</li>
<li>单步执行                                                               1</li>
<li>执行into指令                                                        4</li>
<li>执行int指令，该指令的格式为int n，指令中的n为字节型立即数，是提供给CPU的中断类型码</li>
</ol>
<h2 id="12-1-中断处理程序"><a href="#12-1-中断处理程序" class="headerlink" title="12.1 中断处理程序"></a>12.1 中断处理程序</h2><p>CPU收到中断信息后，应该转去执行该中断信息的处理程序。中断信息中包含有标识中断源的类型码，根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。中断向量表在0000:0000~0000:03FF的1024个单元存放着。在中断向量表中，一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。</p>
<h2 id="12-2-中断过程"><a href="#12-2-中断过程" class="headerlink" title="12.2 中断过程"></a>12.2 中断过程</h2><p>用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的。CPU硬件完成这个工作的过程被称为中断过程。</p>
<p>中断过程：</p>
<ol>
<li>(从中断信息中)取得中断类型码N</li>
<li>标志寄存器的值入栈(因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)  pushf</li>
<li>设置标志寄存器的第8位TF和第9位IF为0  TF=0，IF=0</li>
<li>CS的内容入栈   push CS</li>
<li>IP的内容入栈    push IP</li>
<li>从内存地址为中断类型码<em>4 和中断类型码\</em>4+2 的两个字单元中读取中断处理程序的入口地址设置IP和CS   (IP)=(N*4)，(CS)=(N*4+2)</li>
</ol>
<h2 id="12-3-中断处理程序和iret指令"><a href="#12-3-中断处理程序和iret指令" class="headerlink" title="12.3 中断处理程序和iret指令"></a>12.3 中断处理程序和iret指令</h2><p>中断处理程序的编写步骤：</p>
<ol>
<li>保存用到的寄存器</li>
<li>处理中断</li>
<li>恢复用到的寄存器</li>
<li>用iret指令返回</li>
</ol>
<p>iret指令的功能用汇编语法描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure>
<p>iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。</p>
<h2 id="12-4-单步中断"><a href="#12-4-单步中断" class="headerlink" title="12.4 单步中断"></a>12.4 单步中断</h2><p>CPU在执行完一条指令后，如果检测到标志寄存器的TF=1，则产生单步中断，引发中断过程。</p>
<h1 id="13-int指令"><a href="#13-int指令" class="headerlink" title="13. int指令"></a>13. int指令</h1><p>int n也是内中断的一种。</p>
<h2 id="13-1-BIOS中断例程"><a href="#13-1-BIOS中断例程" class="headerlink" title="13.1 BIOS中断例程"></a>13.1 BIOS中断例程</h2><p>int 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。</p>
<p>(ah)=2表示调用第10h号中断例程的2号子程序，功能为设置光标位置。</p>
<p>(ah)=9表示调用第10h号中断例程的9号子程序，功能为在光标位置显示字符，可以提供要显示的字符、颜色属性、页号、字符重复个数作为参数。</p>
<p>bl中的颜色属性的格式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>BL</td>
<td>R</td>
<td>G</td>
<td>B</td>
<td>I</td>
<td>R</td>
<td>G</td>
<td>B</td>
</tr>
<tr>
<td>闪烁</td>
<td></td>
<td>4~6背景</td>
<td></td>
<td>高亮</td>
<td></td>
<td>0~2前景</td>
</tr>
</tbody>
</table>
</div>
<p>编程，在屏幕的5行12列显示3个红底高亮闪烁绿色的’a’。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ah,2				;置光标</span><br><span class="line">	mov bh,0				;第0页</span><br><span class="line">	mov dh,5				;dh中放行号</span><br><span class="line">	mov dl,12				;dl中放列号</span><br><span class="line">	int 10h</span><br><span class="line">	</span><br><span class="line">	mov ah,9				;在光标位置显示字符</span><br><span class="line">	mov al,&#x27;a&#x27;				;字符</span><br><span class="line">	mov bl,11001010b		;颜色属性</span><br><span class="line">	mov bh,0				;第0页</span><br><span class="line">	mov cx,3				;字符重复个数</span><br><span class="line">	int 10h</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="13-2-DOS中断例程"><a href="#13-2-DOS中断例程" class="headerlink" title="13.2 DOS中断例程"></a>13.2 DOS中断例程</h2><p>int 21h中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。</p>
<p>前面一直使用的是int 21h中断例程的4ch号功能，即程序返回功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,4ch		;程序返回</span><br><span class="line">mov al,0		;返回值</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>
<p>(ah)=9表示调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。</p>
<p>编程，在屏幕的5行12列显示字符串“Welcome to masm!”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	db &#x27;Welcome to masm!&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:	mov ah,2				;置光标</span><br><span class="line">		mov bh,0				;第0页</span><br><span class="line">		mov dh,5				;dh中放行号</span><br><span class="line">		mov dl,12				;dl中放列号</span><br><span class="line">		int 10h</span><br><span class="line">		</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov dx,0				;ds:dx指向字符串的首地址data:0</span><br><span class="line">		mov ah,9</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h1 id="14-端口"><a href="#14-端口" class="headerlink" title="14. 端口"></a>14. 端口</h1><p>在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下三种芯片</p>
<ol>
<li>各种接口卡(网卡、显卡)上的接口芯片，它们控制接口卡进行工作</li>
<li>主板上的接口芯片，CPU通过它们对部分外设进行访问</li>
<li>其他芯片，用来存储相关的系统信息，或进行相关的出入输出处理</li>
</ol>
<p>从CPU的角度，将寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。</p>
<p>CPU可以直接读写以下3个地方的数据：</p>
<ol>
<li>CPU内部的寄存器</li>
<li>内存单元</li>
<li>端口</li>
</ol>
<h2 id="14-1-端口的读写"><a href="#14-1-端口的读写" class="headerlink" title="14.1 端口的读写"></a>14.1 端口的读写</h2><p>因为端口所在的芯片和CPU通过总线相连，所以端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口，端口地址的范围为0~65535</p>
<p>端口的读写指令只有两条：in和out，分别用于从端口读取数据和往端口写入数据。</p>
<p><strong>访问内存：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[8]				;假设执行前(ds)=0</span><br></pre></td></tr></table></figure>
<p>①CPU通过地址线将地址信息8发出</p>
<p>②CPU通过控制线发出内存读命令，选中存储器芯片并通知它将要从中读取数据</p>
<p>③存储器将8号单元中的数据通过数据线送入CPU</p>
<p><strong>访问端口：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al,60h					;从60h号端口读入一个字节</span><br></pre></td></tr></table></figure>
<p>①CPU通过地址线将地址信息60h发出</p>
<p>②CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它将要从中读取数据</p>
<p>③端口所在的芯片将60h端口中的数据通过数据线送入CPU</p>
<p>注：在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位时用ax。</p>
<p>对0~255以内的端口进行读写时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al,20h				;从20h端口读入一个字节</span><br><span class="line">out 20h,al				;往20h端口写入一个字节</span><br></pre></td></tr></table></figure>
<p>对256~65535的端口进行读写时，端口号放在dx中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx,3f8h				;将端口号3f8h送入dx</span><br><span class="line">in al,dx				;从3f8h端口读入一个字节</span><br><span class="line">out dx,al				;往3f8h端口写入一个字节</span><br></pre></td></tr></table></figure>
<h2 id="14-2-shl和shr指令"><a href="#14-2-shl和shr指令" class="headerlink" title="14.2 shl和shr指令"></a>14.2 shl和shr指令</h2><p>shl和shr是逻辑移位指令。</p>
<p>shl是逻辑左移指令，它的功能为：</p>
<ul>
<li>将一个寄存器或内存单元中的数据向左移位</li>
<li>将最后移出的一位写入CF中</li>
<li>最低位用0补充</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">shl al,1					;将al中的数据左移一位</span><br></pre></td></tr></table></figure>
<p>执行后(al)=10010000b，CF=0</p>
<p>shr是逻辑右移指令：</p>
<ul>
<li>将一个寄存器或内存单元中的数据向右移位</li>
<li>将最后移出的一位写入CF中</li>
<li>最高位用0补充</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001b</span><br><span class="line">shr al,1</span><br></pre></td></tr></table></figure>
<p>执行后(al)=01000000b，CF=1</p>
<h2 id="14-3-CMOS-RAM芯片"><a href="#14-3-CMOS-RAM芯片" class="headerlink" title="14.3 CMOS RAM芯片"></a>14.3 CMOS RAM芯片</h2><p>CMOS特征：</p>
<ol>
<li>包含一个实时钟和一个有128个存储单元的RAM存储器</li>
<li>该芯片靠电池供电，关机后其内部的实时钟仍可正常工作，RAM中的信息不丢失</li>
<li>128个字节的RAM中，内部实时钟占用0~0dh单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。</li>
<li>芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口读写CMOS</li>
<li>70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS单元中读取的数据，或要写入到其中的数据。CPU对CMOS的读写分两步进行，读CMOS的2号单元：①将2送入端口70h；②从端口71h读出2号单元的内容</li>
</ol>
<p>在CMOS中，存放这当前的时间：年、月、日、时、分、秒。这6个信息的长度都为1个字节。存放单元为：秒：0        分：2        时：4        日：7        月：8        年：9</p>
<p>这些数据以BCD码的方式存放。BCD码是以4位二进制数表示十进制数码的编码方法。数值26，用BCD码表示为：0010 0110</p>
<p>1个字节表示2个BCD码，高4位的BCD码表示十位，低4位的BCD码表示个位。</p>
<p>编程，在屏幕中间显示当前的月份</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:	mov al,8		</span><br><span class="line">		out 70h,al			;从8号单元读出当前月份的BCD码</span><br><span class="line">		in al,71h			;从数据端口71h中取得指定单元中的数据</span><br><span class="line">		</span><br><span class="line">		mov ah,al			;al中为从CMOS的8号单元中读出的数据</span><br><span class="line">		mov cl,4</span><br><span class="line">		shr ah,cl			;ah中为月份的十位数码值</span><br><span class="line">		and al,00001111b	;al中为月份的个位数码值</span><br><span class="line">		</span><br><span class="line">		add ah,30h</span><br><span class="line">		add al,30h			;显示对应的ASCII码字符</span><br><span class="line">		</span><br><span class="line">		mov bx,0b800h</span><br><span class="line">		mov es,bx</span><br><span class="line">		mov byte ptr es:[160*12+40*2],ah		;显示月份的十位数码</span><br><span class="line">		mov byte ptr es:[160*12+40*2+2],al		;显示月份的个位数码</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h1 id="15-外中断"><a href="#15-外中断" class="headerlink" title="15. 外中断"></a>15. 外中断</h1><p>外设输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关芯片送到外设。</p>
<p>在PC系统中，外中断源一共有以下两类：</p>
<ol>
<li>可屏蔽中断</li>
</ol>
<p>可屏蔽中断是CPU可以不响应的外中断。CPU是否响应要看标志寄存器的IF位。如果IF=1，CPU在执行完当前指令后响应中断，引发中断过程；如果IF=0，不响应可屏蔽中断。</p>
<p>8086CPU提供设置IF的指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sti		;设置IF=1</span><br><span class="line">cli		;设置IF=0</span><br></pre></td></tr></table></figure>
<ol>
<li>不可屏蔽中断</li>
</ol>
<p>不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。对于8086CPU，不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码。则不可屏蔽中断的中断过程为：</p>
<p>①标志寄存器入栈，IF=0，TF=0</p>
<p>②CS、IP入栈</p>
<p>③(IP)=8，(CS)=(0ah)</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="v5le0n9 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="v5le0n9 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/1c971db4.html" rel="prev" title="pwn基础入门">
      <i class="fa fa-chevron-left"></i> pwn基础入门
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/77cd4175.html" rel="next" title="README">
      README <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">1. 基础知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">2. 寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">2.1 通用寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%87%A0%E6%9D%A1%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="nav-text">2.2 几条汇编指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="nav-text">2.3 物理地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-CS-%E5%92%8C-IP"><span class="nav-text">2.4 CS 和 IP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="nav-text">3. 内存访问</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-DS-%E5%92%8C-address"><span class="nav-text">3.1 DS 和 [address]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-mov%E6%8C%87%E4%BB%A4-add%E3%80%81sub%E6%8C%87%E4%BB%A4%E5%90%8C"><span class="nav-text">3.2 mov指令(add、sub指令同)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-CPU%E6%8F%90%E4%BE%9B%E7%9A%84%E6%A0%88%E6%9C%BA%E5%88%B6"><span class="nav-text">3.3 CPU提供的栈机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-push%E6%8C%87%E4%BB%A4-pop%E6%8C%87%E4%BB%A4%E5%90%8C"><span class="nav-text">3.4 push指令(pop指令同)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E6%AE%B5%E7%9A%84%E7%BB%BC%E8%BF%B0"><span class="nav-text">3.5 段的综述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F"><span class="nav-text">4. 第一个程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="nav-text">4.1 伪指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-XXX-segment-%E2%80%A6%E2%80%A6-XXX-ends"><span class="nav-text">4.1.1 XXX segment …… XXX ends</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2-end"><span class="nav-text">4.1.2 end</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-3-assume"><span class="nav-text">4.1.3 assume</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="nav-text">4.2 汇编指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E6%A0%87%E5%8F%B7"><span class="nav-text">4.3 标号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">4.4 程序的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E7%BC%96%E8%AF%91"><span class="nav-text">4.5 编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-%E8%BF%9E%E6%8E%A5"><span class="nav-text">4.6 连接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-bx-%E5%92%8Cloop%E6%8C%87%E4%BB%A4"><span class="nav-text">5. [bx]和loop指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-loop%E6%8C%87%E4%BB%A4"><span class="nav-text">5.1 loop指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E4%B8%80%E6%AE%B5%E5%AE%89%E5%85%A8%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="nav-text">5.2 一段安全的空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-loop%E5%92%8C-bx-%E7%9A%84%E8%81%94%E5%90%88%E5%BA%94%E7%94%A8"><span class="nav-text">5.3 loop和[bx]的联合应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E6%AE%B5%E5%89%8D%E7%BC%80"><span class="nav-text">5.4 段前缀</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="nav-text">6. 包含多个段的程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88"><span class="nav-text">6.1 在代码段中使用栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E5%B0%86%E6%95%B0%E6%8D%AE%E3%80%81%E4%BB%A3%E7%A0%81%E3%80%81%E6%A0%88%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%AE%B5"><span class="nav-text">6.2 将数据、代码、栈放入不同的段</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">7. 更灵活的定位内存地址的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-and%E5%92%8Cor%E6%8C%87%E4%BB%A4"><span class="nav-text">7.1 and和or指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-ASCII%E7%A0%81"><span class="nav-text">7.2 ASCII码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E4%BB%A5%E5%AD%97%E7%AC%A6%E5%BD%A2%E5%BC%8F%E7%BB%99%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-text">7.3 以字符形式给出的数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">7.4 大小写转换的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-bx-idata"><span class="nav-text">7.5 [bx+idata]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-SI-%E5%92%8C-DI"><span class="nav-text">7.6 SI 和 DI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-7-bx-si-%E5%92%8C-bx-di"><span class="nav-text">7.7 [bx+si]和[bx+di]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-8-bx-si-idata-%E5%92%8C-bx-di-idata"><span class="nav-text">7.8 [bx+si+idata]和[bx+di+idata]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-9-%E4%B8%8D%E5%90%8C%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8"><span class="nav-text">7.9 不同寻址方式的灵活应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="nav-text">8. 数据处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-bx-si-di%E5%92%8Cbp"><span class="nav-text">8.1 bx, si, di和bp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">8.2 数据的位置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1-%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%A1%A8%E8%BE%BE"><span class="nav-text">8.2.1 数据位置的表达</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-2-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-text">8.2.2 寻址方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-%E6%95%B0%E6%8D%AE%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-text">8.3 数据的长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-div%E6%8C%87%E4%BB%A4"><span class="nav-text">8.4 div指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-%E4%BC%AA%E6%8C%87%E4%BB%A4dd"><span class="nav-text">8.5 伪指令dd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-dup"><span class="nav-text">8.6 dup</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-text">9. 转移指令的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-%E6%93%8D%E4%BD%9C%E7%AC%A6offset"><span class="nav-text">9.1 操作符offset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-jmp%E6%8C%87%E4%BB%A4"><span class="nav-text">9.2 jmp指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-1-%E4%BE%9D%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="nav-text">9.2.1 依据位移进行转移的jmp指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-2-%E8%BD%AC%E7%A7%BB%E7%9A%84%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9C%A8%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="nav-text">9.2.2 转移的目的地址在指令中的jmp指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-3-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84-jmp%E6%8C%87%E4%BB%A4"><span class="nav-text">9.2.3 转移地址在寄存器中的 jmp指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-4-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84jmp%E6%8C%87%E4%BB%A4"><span class="nav-text">9.2.4 转移地址在内存中的jmp指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-jcxz%E6%8C%87%E4%BB%A4"><span class="nav-text">9.3 jcxz指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-loop%E6%8C%87%E4%BB%A4"><span class="nav-text">9.4 loop指令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-call%E5%92%8Cret%E6%8C%87%E4%BB%A4"><span class="nav-text">10. call和ret指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-ret%E5%92%8Cretf"><span class="nav-text">10.1 ret和retf</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-1-ret%E6%8C%87%E4%BB%A4"><span class="nav-text">10.1.1 ret指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-2-retf%E6%8C%87%E4%BB%A4"><span class="nav-text">10.1.2 retf指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-call%E6%8C%87%E4%BB%A4"><span class="nav-text">10.2 call指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-1-%E4%BE%9D%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84call%E6%8C%87%E4%BB%A4"><span class="nav-text">10.2.1 依据位移进行转移的call指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-2-%E8%BD%AC%E7%A7%BB%E7%9A%84%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%9C%A8%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84call%E6%8C%87%E4%BB%A4"><span class="nav-text">10.2.2 转移的目的地址在指令中的call指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-3-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84call%E6%8C%87%E4%BB%A4"><span class="nav-text">10.2.3 转移地址在寄存器中的call指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-4-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84call%E6%8C%87%E4%BB%A4"><span class="nav-text">10.2.4 转移地址在内存中的call指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-call%E5%92%8Cret%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-text">10.3 call和ret的配合使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-4-mul%E6%8C%87%E4%BB%A4"><span class="nav-text">10.4 mul指令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">11. 标志寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-ZF%E6%A0%87%E5%BF%97"><span class="nav-text">11.1 ZF标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-PF%E6%A0%87%E5%BF%97"><span class="nav-text">11.2 PF标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-SF%E6%A0%87%E5%BF%97"><span class="nav-text">11.3 SF标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-4-CF%E6%A0%87%E5%BF%97"><span class="nav-text">11.4 CF标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-5-OF%E6%A0%87%E5%BF%97"><span class="nav-text">11.5 OF标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-6-adc%E6%8C%87%E4%BB%A4"><span class="nav-text">11.6 adc指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-7-sbb%E6%8C%87%E4%BB%A4"><span class="nav-text">11.7 sbb指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-8-cmp%E6%8C%87%E4%BB%A4"><span class="nav-text">11.8 cmp指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-9-%E6%A3%80%E6%B5%8B%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="nav-text">11.9 检测比较结果的条件转移指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-10-DF%E6%A0%87%E5%BF%97%E5%92%8C%E4%B8%B2%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="nav-text">11.10 DF标志和串传送指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-10-1-%E4%B8%B2%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="nav-text">11.10.1 串传送指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-11-pushf%E5%92%8Cpopf"><span class="nav-text">11.11 pushf和popf</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-%E5%86%85%E4%B8%AD%E6%96%AD"><span class="nav-text">12. 内中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-text">12.1 中断处理程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-%E4%B8%AD%E6%96%AD%E8%BF%87%E7%A8%8B"><span class="nav-text">12.2 中断过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%92%8Ciret%E6%8C%87%E4%BB%A4"><span class="nav-text">12.3 中断处理程序和iret指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-4-%E5%8D%95%E6%AD%A5%E4%B8%AD%E6%96%AD"><span class="nav-text">12.4 单步中断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-int%E6%8C%87%E4%BB%A4"><span class="nav-text">13. int指令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1-BIOS%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B"><span class="nav-text">13.1 BIOS中断例程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-2-DOS%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B"><span class="nav-text">13.2 DOS中断例程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-%E7%AB%AF%E5%8F%A3"><span class="nav-text">14. 端口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%AF%BB%E5%86%99"><span class="nav-text">14.1 端口的读写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-shl%E5%92%8Cshr%E6%8C%87%E4%BB%A4"><span class="nav-text">14.2 shl和shr指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-3-CMOS-RAM%E8%8A%AF%E7%89%87"><span class="nav-text">14.3 CMOS RAM芯片</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-%E5%A4%96%E4%B8%AD%E6%96%AD"><span class="nav-text">15. 外中断</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="v5le0n9"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">v5le0n9</p>
  <div class="site-description" itemprop="description">小呀小二郎呀背着个书包上学堂</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/Leong_Vinson" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;Leong_Vinson" rel="noopener" target="_blank"><i class="fab fa-cuttlefish fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/v5le0n9" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;v5le0n9" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:v5le0n9@163.com" title="E-Mail → mailto:v5le0n9@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.zz1syyd.com/" title="https:&#x2F;&#x2F;www.zz1syyd.com&#x2F;" rel="noopener" target="_blank">zz1syyd</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://one-null-pointer.github.io/" title="https:&#x2F;&#x2F;one-null-pointer.github.io&#x2F;" rel="noopener" target="_blank">liaoyue</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">v5le0n9</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.4m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">20:55</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '7c58e80079a2457b610d',
      clientSecret: 'fc16b1b0fdfb278016ebe41c20f3743c3c927466',
      repo        : 'comments.github.io',
      owner       : 'v5le0n9',
      admin       : ['v5le0n9'],
      id          : 'fbfcb8cc0c02ec87d8c9573782d02af9',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
