<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.ico">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇笔记是学习看雪“非虫”的《Android软件安全与逆向分析》一书中的内容所写。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android软件安全与逆向分析">
<meta property="og:url" content="http://example.com/posts/d368aa06.html">
<meta property="og:site_name" content="v5le0n9&#39;s garden">
<meta property="og:description" content="这篇笔记是学习看雪“非虫”的《Android软件安全与逆向分析》一书中的内容所写。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/posts/d368aa06/2.1.1.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/2.1.2.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/2.1.3.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/2.1.4.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/2.1.5.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/2.1.6.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/2.1.7.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/2.2.1.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/2.2.2.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/2.2.3.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/2.2.4.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/3.1.1.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/3.1.2.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/4.2.1.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/4.2.4.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/4.2.2.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/4.2.3.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/4.2.5.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/4.2.6.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/4.2.7.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/4.3.1.jpg">
<meta property="og:image" content="http://example.com/posts/d368aa06/4.4.1.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/4.4.2.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/4.4.3.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/5.1.2.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/7.1.1.jpg">
<meta property="og:image" content="http://example.com/posts/d368aa06/7.2.1.jpg">
<meta property="og:image" content="http://example.com/posts/d368aa06/7.2.3.jpg">
<meta property="og:image" content="http://example.com/posts/d368aa06/7.2.2.jpg">
<meta property="og:image" content="http://example.com/posts/d368aa06/7.2.4.jpg">
<meta property="og:image" content="http://example.com/posts/d368aa06/7.2.5.jpg">
<meta property="og:image" content="http://example.com/posts/d368aa06/7.2.6.png">
<meta property="og:image" content="http://example.com/posts/d368aa06/11.1.1.jpg">
<meta property="article:published_time" content="2022-07-31T08:30:47.469Z">
<meta property="article:modified_time" content="2022-08-18T11:17:26.254Z">
<meta property="article:author" content="v5le0n9">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/posts/d368aa06/2.1.1.png">

<link rel="canonical" href="http://example.com/posts/d368aa06.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Android软件安全与逆向分析 | v5le0n9's garden</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="v5le0n9's garden" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">v5le0n9's garden</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">小凉的秘密基地</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/v5le0n9" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/posts/d368aa06.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="v5le0n9">
      <meta itemprop="description" content="小呀小二郎呀背着个书包上学堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="v5le0n9's garden">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android软件安全与逆向分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-31 16:30:47" itemprop="dateCreated datePublished" datetime="2022-07-31T16:30:47+08:00">2022-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-18 19:17:26" itemprop="dateModified" datetime="2022-08-18T19:17:26+08:00">2022-08-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android%E9%80%86%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">Android逆向</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>46k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>42 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇笔记是学习看雪“非虫”的《Android软件安全与逆向分析》一书中的内容所写。</p>
<span id="more"></span>
<h1 id="1-Windows下环境搭建"><a href="#1-Windows下环境搭建" class="headerlink" title="1. Windows下环境搭建"></a>1. Windows下环境搭建</h1><h2 id="1-1-安装JDK"><a href="#1-1-安装JDK" class="headerlink" title="1.1 安装JDK"></a>1.1 安装JDK</h2><p><a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/downloads/">https://www.oracle.com/java/technologies/downloads/</a></p>
<p>一定一定要安装Java8，我被其他版本搞死了。安装完成后，在CMD窗口输入以下三条命令，都有信息出来则表明安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">javac</span><br><span class="line">javap</span><br></pre></td></tr></table></figure>
<h2 id="1-2-安装Android-SDK"><a href="#1-2-安装Android-SDK" class="headerlink" title="1.2 安装Android SDK"></a>1.2 安装Android SDK</h2><p><a target="_blank" rel="noopener" href="https://dl.google.com/android/installer_r24.4.1-windows.exe">https://dl.google.com/android/installer_r24.4.1-windows.exe</a></p>
<p>SDK要放在没有空格的路径中，否则在配置Android Studio时会报错。安装完成后，“以管理员身份运行”android-sdk目录下的<code>SDK Manager.exe</code>，为了方便后续操作，安卓系统选择Android 9(API 28)，其余默认安装就好。安装完成后该目录下会多出来很多文件夹，将tools文件夹和platform-tools文件夹添加到系统的PATH环境变量中。</p>
<p>在CMD窗口输入以下两条命令，都有信息出来则表明安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emulator -version</span><br><span class="line">adb version</span><br></pre></td></tr></table></figure>
<p>如果输入第一条命令后显示如下错误，说明已经安装，提示是说命令格式不对。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\v5le0n9&gt;emulator -version</span><br><span class="line">emulator: ERROR: No AVD specified. Use &#x27;@foo&#x27; or &#x27;-avd foo&#x27; to launch a virtual device named &#x27;foo&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-安装Android-NDK"><a href="#1-3-安装Android-NDK" class="headerlink" title="1.3 安装Android NDK"></a>1.3 安装Android NDK</h2><p><a target="_blank" rel="noopener" href="https://dl.google.com/android/repository/android-ndk-r25-windows.zip">https://dl.google.com/android/repository/android-ndk-r25-windows.zip</a></p>
<p>傻瓜式操作，最好也不要放在有空格的路径中。</p>
<h2 id="1-4-安装Android-Studio"><a href="#1-4-安装Android-Studio" class="headerlink" title="1.4 安装Android Studio"></a>1.4 安装Android Studio</h2><p><a target="_blank" rel="noopener" href="http://redirector.gvt1.com/edgedl/android/studio/install/2021.1.1.22/android-studio-2021.1.1.22-windows.exe">http://redirector.gvt1.com/edgedl/android/studio/install/2021.1.1.22/android-studio-2021.1.1.22-windows.exe</a></p>
<p>在官网下载将https修改为http即可下载，否则会一直打不开页面。</p>
<h1 id="2-分析Android程序"><a href="#2-分析Android程序" class="headerlink" title="2. 分析Android程序"></a>2. 分析Android程序</h1><h2 id="2-1-编写Android程序"><a href="#2-1-编写Android程序" class="headerlink" title="2.1 编写Android程序"></a>2.1 编写Android程序</h2><p>使用Android Studio创建一个Empty Activity，命名为crackme。</p>
<p>首先设计显示界面。打开工程的<code>activity_main.xml</code>布局文件，添加用户名与注册码编辑框。</p>
<img src="/posts/d368aa06/2.1.1.png" class="" title="设计界面">
<p>接着编写<code>MainActivity.java</code>，将注册的核心算法设计好，输入框与用户输入连接起来。在<code>MainActivity</code>类中添加一个<code>checkSN()</code>方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkSN</span><span class="params">(String username, String sn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((username == <span class="literal">null</span>) || (username.length() == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>((sn == <span class="literal">null</span>) || (sn.length() != <span class="number">16</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">digest</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);<span class="comment">//返回实现MD5摘要算法的 MessageDigest 对象</span></span><br><span class="line">        digest.reset();<span class="comment">//将待摘要数据重置，即初始化</span></span><br><span class="line">        digest.update(username.getBytes());<span class="comment">//将username转化为字节数组，作为待摘要数据</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = digest.digest();<span class="comment">//执行摘要算法，结果存入字节数组</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes)</span><br><span class="line">        &#123;<span class="comment">//从字节数组中依次取出1个字节</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">hexstr</span> <span class="operator">=</span> Integer.toHexString(b &amp; <span class="number">0xff</span>);<span class="comment">//将每个字节转化为十六进制字符串</span></span><br><span class="line">            <span class="keyword">if</span> (hexstr.length() == <span class="number">1</span>)</span><br><span class="line">            &#123;<span class="comment">//如果得出的结果长度为1，则在前面加0，保证每个字节转字符串后加入序列时是两个字符</span></span><br><span class="line">                hexstr = <span class="string">&quot;0&quot;</span> + hexstr;</span><br><span class="line">            &#125;</span><br><span class="line">            sb1.append(hexstr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;sb1.length(); i+=<span class="number">2</span>)</span><br><span class="line">            sb2.append(sb1.charAt(i));<span class="comment">//将摘要的奇位数作为sn</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userSN</span> <span class="operator">=</span> sb2.toString();</span><br><span class="line">        <span class="keyword">if</span>(!userSN.equalsIgnoreCase(sn))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(NoSuchAlgorithmException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>MessageDigest 类为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法。信息摘要是安全的单向哈希函数，它接收任意大小的数据，并输出固定长度的哈希值。MessageDigest 对象开始被初始化，该对象通过使用 update() 方法处理数据。任何时候都可以调用 reset() 方法重置摘要。一旦所有需要更新的数据都已经被更新了，应该调用 digest() 方法之一完成哈希计算。对于给定数量的更新数据，digest() 方法只能被调用一次。在调用 digest() 之后，MessageDigest 对象被重新设置成其初始状态。</p>
<p>在 StringBuilder 上的主要操作是 append() 和 insert() 方法。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串生成器中。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。它们原理一样。</p>
<p>charAt(int index)方法是一个能够用来检索特定索引下的字符的String实例的方法。</p>
</blockquote>
<p>在<code>OnCreate()</code>方法中加入注册按钮点击事件的监听器，如果用户名与注册码匹配就弹出注册成功的提示，不匹配则提示无效的用户名或注册码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    setTitle(R.string.unregister);</span><br><span class="line">    <span class="type">EditText</span> <span class="variable">edit_username</span> <span class="operator">=</span> (EditText) findViewById(R.id.editTextTextPersonName);</span><br><span class="line">    <span class="type">EditText</span> <span class="variable">edit_sn</span> <span class="operator">=</span> (EditText) findViewById(R.id.editTextTextPersonName2);</span><br><span class="line">    <span class="type">Button</span> <span class="variable">btn_register</span> <span class="operator">=</span> (Button) findViewById(R.id.button);</span><br><span class="line">    btn_register.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!checkSN(edit_username.getText().toString().trim(), edit_sn.getText().toString().trim()))</span><br><span class="line">                Toast.makeText(MainActivity.<span class="built_in">this</span>, R.string.unsuccessed, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="built_in">this</span>, R.string.successed, Toast.LENGTH_SHORT).show();</span><br><span class="line">                btn_register.setEnabled(<span class="literal">false</span>);</span><br><span class="line">                setTitle(R.string.registered);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时<code>R.string.xxxx</code>出错，这是因为我们还没在<code>strings.xml</code>中定义这些字符串。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;unregister&quot;</span>&gt;</span>程序未注册<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;registered&quot;</span>&gt;</span>程序已注册<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;successed&quot;</span>&gt;</span>注册成功！<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;unsuccessed&quot;</span>&gt;</span>注册失败！<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="/posts/d368aa06/2.1.2.png" class="" title="定义字符串">
<p>设置好后，代码就不报错了。使用Genymotion插件启动虚拟设备，点击绿色三角符号将项目打包成APK发送至虚拟设备并在虚拟设备上运行。</p>
<p>别忘了弄布局，否则下图就是反面教材。</p>
<img src="/posts/d368aa06/2.1.3.png" class="" title="设计界面">
<p>我们刚才在<code>strings.xml</code>中定义的字符串可以在设计界面时就设置好。</p>
<img src="/posts/d368aa06/2.1.4.png" class="" title="设计界面">
<p>可以用hint属性(灰色)来提示用户输入，如果用text属性(黑色)会直接在框中输入，用户如果需要输入则要删掉框中文本再输入，text属性如果使用一般是默认值。</p>
<img src="/posts/d368aa06/2.1.5.png" class="" title="设计界面">
<p>效果如下图，有内味了。</p>
<img src="/posts/d368aa06/2.1.6.png" class="" title="效果图">
<h2 id="2-2-破解Android程序"><a href="#2-2-破解Android程序" class="headerlink" title="2.2 破解Android程序"></a>2.2 破解Android程序</h2><p>破解Android程序的第一步就是要将APK文件反编译，生成Smali格式的反汇编代码，阅读Smali文件的代码来理解程序的运行机制，或更进一步反编译成Java源码，更好理解程序流程。</p>
<p>将APK文件反汇编成Smali格式需要用到<a target="_blank" rel="noopener" href="https://ibotpeaches.github.io/Apktool/">Apktool</a>工具，官网也很明确地给出了用法，两个命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反汇编APK文件：apktool d[ecode] [OPTS] &lt;file.apk&gt; [&lt;dir&gt;]</span><br><span class="line">编译APK文件：apktool b[uild] [OPTS] [&lt;app_path&gt;] [&lt;out_file&gt;]</span><br></pre></td></tr></table></figure>
<p>也可以用<a target="_blank" rel="noopener" href="https://down.52pojie.cn/Tools/Android_Tools/AndroidKiller_v1.3.1.zip">Android Killer</a>图形化工具(下称AK)，它集成了apktool工具和APK签名工具，可以查看和修改Smali代码，将APK文件安装到虚拟设备等，所以还挺方便的。</p>
<p>点击Android Studio(下称AS)中的小锤子图标(Make Project)将上面代码打包成APK文件放到本地，路径为<code>D:\Java\Android\crackme\app\build\intermediates\apk\debug\app-debug.apk</code>，也可能在<code>D:\Java\Android\crackme\app\build\outputs\apk\debug\app-debug.apk</code>，多找找。将该APK文件反汇编成Smali代码到当前目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Java\Android\crackme\app\build\intermediates\apk\debug&gt; apktool d app-debug.apk</span><br><span class="line">I: Using Apktool 2.6.1 on app-debug.apk</span><br><span class="line">I: Loading resource table...</span><br><span class="line">I: Decoding AndroidManifest.xml with resources...</span><br><span class="line">I: Loading resource table from file: C:\Users\dell\AppData\Local\apktool\framework\1.apk</span><br><span class="line">I: Regular manifest package...</span><br><span class="line">I: Decoding file-resources...</span><br><span class="line">I: Decoding values */* XMLs...</span><br><span class="line">I: Baksmaling classes.dex...</span><br><span class="line">I: Baksmaling classes3.dex...</span><br><span class="line">I: Baksmaling classes2.dex...</span><br><span class="line">I: Copying assets and libs...</span><br><span class="line">I: Copying unknown files...</span><br><span class="line">I: Copying original files...</span><br><span class="line">PS D:\Java\Android\crackme\app\build\intermediates\apk\debug&gt;</span><br></pre></td></tr></table></figure>
<p>如何寻找突破口是分析一个程序的关键。对于一般的Android来说，错误提示信息通常是指引关键代码的风向标。在错误提示附近一般是程序的核心验证代码。错误提示是Android程序中的字符串资源，开发Android程序时，这些字符串可能硬编码到源码中，也可能引用自<code>res\values\strings.xml</code>。APK在打包时，<code>strings.xml</code>中的字符串被加密存储为<code>resources.arsc</code>文件保存到APK程序包中，APK被成功反编译后这个文件也被解密出来了。</p>
<p>如果是硬编码，字符串以Unicode编码的方式写在了Smali代码中；如果是<code>strings.xml</code>中，字符串就是我们看到的文本模样。</p>
<img src="/posts/d368aa06/2.1.7.png" class="" title="strings.xml">
<p>开发Android程序时，<code>strings.xml</code>文件中的所有字符串资源都在<code>R.java</code>文件的String类被标识，每个字符串都有唯一的int类型索引值，使用Apktool反编译APK文件后，所有的索引值保存在<code>strings.xml</code>文件同目录下的<code>public.xml</code>文件中。</p>
<img src="/posts/d368aa06/2.2.1.png" class="" title="public.xml">
<p>unsuccessed的id值为0x7f0e006d，在smali目录中搜索含有内容为0x7f0e006d的文件，最后发现只有<code>MainActivity$1.smali</code>文件一处调用，代码如下：</p>
<img src="/posts/d368aa06/2.2.2.png" class="" title="查找0x7f0e006d">
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"># virtual methods</span><br><span class="line">.method public onClick(Landroid/view/View;)V</span><br><span class="line">    .locals 3</span><br><span class="line">    .param p1, &quot;v&quot;    # Landroid/view/View;</span><br><span class="line"></span><br><span class="line">    .line 29</span><br><span class="line">    iget-object v0, p0, Lcom/example/crackme/MainActivity$1;-&gt;this$0:Lcom/example/crackme/MainActivity;</span><br><span class="line"></span><br><span class="line">    iget-object v1, p0, Lcom/example/crackme/MainActivity$1;-&gt;val$edit_username:Landroid/widget/EditText;</span><br><span class="line"># 取用户名存到v1</span><br><span class="line">    invoke-virtual &#123;v1&#125;, Landroid/widget/EditText;-&gt;getText()Landroid/text/Editable;</span><br><span class="line"></span><br><span class="line">    move-result-object v1</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v1&#125;, Ljava/lang/Object;-&gt;toString()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v1</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v1&#125;, Ljava/lang/String;-&gt;trim()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v1</span><br><span class="line"></span><br><span class="line">    iget-object v2, p0, Lcom/example/crackme/MainActivity$1;-&gt;val$edit_sn:Landroid/widget/EditText;</span><br><span class="line"># 取注册码存到v2</span><br><span class="line">    invoke-virtual &#123;v2&#125;, Landroid/widget/EditText;-&gt;getText()Landroid/text/Editable;</span><br><span class="line"></span><br><span class="line">    move-result-object v2</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v2&#125;, Ljava/lang/Object;-&gt;toString()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v2</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v2&#125;, Ljava/lang/String;-&gt;trim()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v2</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v0, v1, v2&#125;, Lcom/example/crackme/MainActivity;-&gt;access$000(Lcom/example/crackme/MainActivity;Ljava/lang/String;Ljava/lang/String;)Z</span><br><span class="line"># 将v0、v1、v2放进MainActivity中的access$000中进行运算，返回值为Boolean类型</span><br><span class="line">    move-result v0</span><br><span class="line"># 将结果放到v0</span><br><span class="line">    const/4 v1, 0x0</span><br><span class="line"></span><br><span class="line">    if-nez v0, :cond_0</span><br><span class="line"># 如果v0不等于0，则跳到:cond_0。否则继续往下执行。</span><br><span class="line"># 继续往下执行就会执行到0x7f0e006d的地方，也就是注册失败。所以一定要跳到:cond_0</span><br><span class="line"># 将if-nez修改为if-eqz</span><br><span class="line">    .line 30</span><br><span class="line">    iget-object v0, p0, Lcom/example/crackme/MainActivity$1;-&gt;this$0:Lcom/example/crackme/MainActivity;</span><br><span class="line"></span><br><span class="line">    const v2, 0x7f0e006d # unsuccessed</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v0, v2, v1&#125;, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;II)Landroid/widget/Toast;</span><br><span class="line"></span><br><span class="line">    move-result-object v0</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0&#125;, Landroid/widget/Toast;-&gt;show()V</span><br><span class="line"></span><br><span class="line">    goto :goto_0</span><br><span class="line"></span><br><span class="line">    .line 33</span><br><span class="line">    :cond_0</span><br><span class="line">    iget-object v0, p0, Lcom/example/crackme/MainActivity$1;-&gt;this$0:Lcom/example/crackme/MainActivity;</span><br><span class="line"></span><br><span class="line">    const v2, 0x7f0e006b # successed</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v0, v2, v1&#125;, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;II)Landroid/widget/Toast;</span><br><span class="line"></span><br><span class="line">    move-result-object v0</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0&#125;, Landroid/widget/Toast;-&gt;show()V</span><br><span class="line"></span><br><span class="line">    .line 34</span><br><span class="line">    iget-object v0, p0, Lcom/example/crackme/MainActivity$1;-&gt;val$btn_register:Landroid/widget/Button;</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0, v1&#125;, Landroid/widget/Button;-&gt;setEnabled(Z)V</span><br><span class="line"></span><br><span class="line">    .line 35</span><br><span class="line">    iget-object v0, p0, Lcom/example/crackme/MainActivity$1;-&gt;this$0:Lcom/example/crackme/MainActivity;</span><br><span class="line"></span><br><span class="line">    const v1, 0x7f0e0068 # registered</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0, v1&#125;, Lcom/example/crackme/MainActivity;-&gt;setTitle(I)V</span><br><span class="line"></span><br><span class="line">    .line 37</span><br><span class="line">    :goto_0</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>
<p>修改完后保存，使用Apktool编译。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool b app-debug</span><br></pre></td></tr></table></figure>
<p>天啊编译完还要签名，还要配置签名工具。答应我，用AK就好，点击“编译”它就会自动编译并签名，很方便。</p>
<img src="/posts/d368aa06/2.2.3.png" class="" title="查找0x7f0e006d">
<img src="/posts/d368aa06/2.2.4.png" class="" title="注册成功">
<h1 id="3-进入Android-Dalvik虚拟机"><a href="#3-进入Android-Dalvik虚拟机" class="headerlink" title="3. 进入Android Dalvik虚拟机"></a>3. 进入Android Dalvik虚拟机</h1><h2 id="3-1-Dalvik虚拟机与Java虚拟机的区别"><a href="#3-1-Dalvik虚拟机与Java虚拟机的区别" class="headerlink" title="3.1 Dalvik虚拟机与Java虚拟机的区别"></a>3.1 Dalvik虚拟机与Java虚拟机的区别</h2><p>Dalvik虚拟机与传统的Java虚拟机有着许多不同点，两者并不兼容，它们显著的不同点主要表现在以下几个方面：</p>
<ul>
<li><p>Java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码。</p>
<p>传统的Java程序经过编译，生成Java字节码保存在class文件中，Java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中，Dalvik虚拟机通过解释DEX文件来执行这些字节码。</p>
</li>
<li><p>Dalvik可执行文件体积更小。</p>
<p>Android SDK中有一个叫dx(现名为d8)的工具负责将Java字节码转换为Dalvik字节码。dx工具对Java常量池的压缩，使得相同的字符串、常量在DEX文件中只出现一次，从而减少了文件的体积。</p>
<img src="/posts/d368aa06/3.1.1.png" class="" title="Java文件转换为DEX文件">
</li>
<li><p>Java虚拟机与Dalvik虚拟机架构不同。</p>
<p>Java虚拟机基于栈架构。程序在运行时虚拟机需要频繁地从栈上读取或写入数据，这个过程需要更多的指令分派与内存访问次数。</p>
<p>Dalvik虚拟机基于寄存器架构。数据的访问通过寄存器间直接传递。</p>
</li>
</ul>
<p>编写简单的Java代码来对比Java字节码与Dalvik字节码的区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hello.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">return</span> (a + b) * (a - b);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        System.out.println(hello.foo(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译成class文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Hello.java</span><br></pre></td></tr></table></figure>
<p>编译<code>Hello.class</code>生成Java字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\dell\Desktop&gt; javap -c Hello.class</span><br><span class="line">Compiled from &quot;Hello.java&quot;</span><br><span class="line">public class Hello &#123;</span><br><span class="line">  public Hello();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public int foo(int, int);</span><br><span class="line">    Code:</span><br><span class="line">       0: iload_1</span><br><span class="line">       1: iload_2</span><br><span class="line">       2: iadd</span><br><span class="line">       3: iload_1</span><br><span class="line">       4: iload_2</span><br><span class="line">       5: isub</span><br><span class="line">       6: imul</span><br><span class="line">       7: ireturn</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class Hello</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      11: aload_1</span><br><span class="line">      12: iconst_5</span><br><span class="line">      13: iconst_3</span><br><span class="line">      14: invokevirtual #5                  // Method foo:(II)I</span><br><span class="line">      17: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      20: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将class文件编译成DEX文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar dx.jar --dex --output=Hello.dex Hello.class</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行jar包命令：java -jar xxx.jar</p>
</blockquote>
<p>使用<code>dexdump.exe</code>将<code>Hello.dex</code>文件编译成Dalvik字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Java\Android\sdk\build-tools\30.0.3&gt; .\dexdump.exe -d C:\Users\Dell\Desktop\Hello.dex</span><br><span class="line">Processing &#x27;C:\Users\Dell\Desktop\Hello.dex&#x27;...</span><br><span class="line">Opened &#x27;C:\Users\Dell\Desktop\Hello.dex&#x27;, DEX version &#x27;035&#x27;</span><br><span class="line">Class #0            -</span><br><span class="line">  Class descriptor  : &#x27;LHello;&#x27;</span><br><span class="line">  Access flags      : 0x0001 (PUBLIC)</span><br><span class="line">  Superclass        : &#x27;Ljava/lang/Object;&#x27;</span><br><span class="line">  Interfaces        -</span><br><span class="line">  Static fields     -</span><br><span class="line">  Instance fields   -</span><br><span class="line">  Direct methods    -</span><br><span class="line">    #0              : (in LHello;)</span><br><span class="line">      name          : &#x27;&lt;init&gt;&#x27;</span><br><span class="line">      type          : &#x27;()V&#x27;</span><br><span class="line">      access        : 0x10001 (PUBLIC CONSTRUCTOR)</span><br><span class="line">      code          -</span><br><span class="line">      registers     : 1</span><br><span class="line">      ins           : 1</span><br><span class="line">      outs          : 1</span><br><span class="line">      insns size    : 4 16-bit code units</span><br><span class="line">00014c:                                        |[00014c] Hello.&lt;init&gt;:()V</span><br><span class="line">00015c: 7010 0400 0000                         |0000: invoke-direct &#123;v0&#125;, Ljava/lang/Object;.&lt;init&gt;:()V // method@0004</span><br><span class="line">000162: 0e00                                   |0003: return-void</span><br><span class="line">      catches       : (none)</span><br><span class="line">      positions     :</span><br><span class="line">        0x0000 line=1</span><br><span class="line">      locals        :</span><br><span class="line">        0x0000 - 0x0004 reg=0 this LHello;</span><br><span class="line"></span><br><span class="line">    #1              : (in LHello;)</span><br><span class="line">      name          : &#x27;main&#x27;</span><br><span class="line">      type          : &#x27;([Ljava/lang/String;)V&#x27;</span><br><span class="line">      access        : 0x0009 (PUBLIC STATIC)</span><br><span class="line">      code          -</span><br><span class="line">      registers     : 5</span><br><span class="line">      ins           : 1</span><br><span class="line">      outs          : 3</span><br><span class="line">      insns size    : 17 16-bit code units</span><br><span class="line">000164:                                        |[000164] Hello.main:([Ljava/lang/String;)V</span><br><span class="line">000174: 2200 0100                              |0000: new-instance v0, LHello; // type@0001</span><br><span class="line">000178: 7010 0000 0000                         |0002: invoke-direct &#123;v0&#125;, LHello;.&lt;init&gt;:()V // method@0000</span><br><span class="line">00017e: 6201 0000                              |0005: sget-object v1, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000</span><br><span class="line">000182: 1252                                   |0007: const/4 v2, #int 5 // #5</span><br><span class="line">000184: 1233                                   |0008: const/4 v3, #int 3 // #3</span><br><span class="line">000186: 6e30 0100 2003                         |0009: invoke-virtual &#123;v0, v2, v3&#125;, LHello;.foo:(II)I // method@0001</span><br><span class="line">00018c: 0a00                                   |000c: move-result v0</span><br><span class="line">00018e: 6e20 0300 0100                         |000d: invoke-virtual &#123;v1, v0&#125;, Ljava/io/PrintStream;.println:(I)V // method@0003</span><br><span class="line">000194: 0e00                                   |0010: return-void</span><br><span class="line">      catches       : (none)</span><br><span class="line">      positions     :</span><br><span class="line">        0x0000 line=9</span><br><span class="line">        0x0005 line=10</span><br><span class="line">        0x0010 line=11</span><br><span class="line">      locals        :</span><br><span class="line">        0x0000 - 0x0011 reg=4 (null) [Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  Virtual methods   -</span><br><span class="line">    #0              : (in LHello;)</span><br><span class="line">      name          : &#x27;foo&#x27;</span><br><span class="line">      type          : &#x27;(II)I&#x27;</span><br><span class="line">      access        : 0x0001 (PUBLIC)</span><br><span class="line">      code          -</span><br><span class="line">      registers     : 5</span><br><span class="line">      ins           : 3</span><br><span class="line">      outs          : 0</span><br><span class="line">      insns size    : 6 16-bit code units</span><br><span class="line">000198:                                        |[000198] Hello.foo:(II)I</span><br><span class="line">0001a8: 9000 0304                              |0000: add-int v0, v3, v4</span><br><span class="line">0001ac: 9101 0304                              |0002: sub-int v1, v3, v4</span><br><span class="line">0001b0: b210                                   |0004: mul-int/2addr v0, v1</span><br><span class="line">0001b2: 0f00                                   |0005: return v0</span><br><span class="line">      catches       : (none)</span><br><span class="line">      positions     :</span><br><span class="line">        0x0000 line=5</span><br><span class="line">      locals        :</span><br><span class="line">        0x0000 - 0x0006 reg=2 this LHello;</span><br><span class="line">        0x0000 - 0x0006 reg=3 (null) I</span><br><span class="line">        0x0000 - 0x0006 reg=4 (null) I</span><br><span class="line"></span><br><span class="line">  source_file_idx   : 1 (Hello.java)</span><br></pre></td></tr></table></figure>
<p>可以看到，它们用各自的字节码描述<code>foo()</code>函数，Java需要8条指令，而Dalivik只需4条指令。</p>
<h2 id="3-2-Android系统架构"><a href="#3-2-Android系统架构" class="headerlink" title="3.2 Android系统架构"></a>3.2 Android系统架构</h2><p>Android系统架构采用分层思想，这样的好处是拥有减少各层之间的依赖性、便于独立分发、容易收敛问题和错误等优点。Android系统由Linux内核、函数库、Android运行时、应用程序框架、应用程序组成。Dalvik虚拟机属于Android运行时环境，它与一些核心库共同承担Android应用程序的运行工作。</p>
<img src="/posts/d368aa06/3.1.2.png" class="" title="Android系统架构">
<p>Android系统启动加载完内核后，第一个执行的是init进程，init进程首先要做的是设备的初始化工作，然后读取<code>inic.rc</code>文件并启动系统中的重要外部程序Zygote。Zygote进程是Android所有进程的孵化器进程，它启动后会首先初始化Dalvik虚拟机，然后启动system_server并进入Zygote模式，通过socket等候命令。当执行一个Android应用程序时，system_server进程通过socket方式发送命令给Zygote，Zygote收到命令后通过fork自身创建一个Dalvik虚拟机的实例来执行应用程序的入口函数，这样一个程序就启动完成了。</p>
<p>Zygote提供了三种创建进程的方法：</p>
<ul>
<li>fork()，创建一个Zygote进程；</li>
<li>forkAndSpecialize()，创建一个非Zygote进程；</li>
<li>forSystemServer()，创建一个系统服务进程。</li>
</ul>
<p>当进程fork成功后，执行的工作就交给了Dalvik虚拟机。Dalvik虚拟机首先通过<code>loadClassFromDex()</code>函数完成类的装载工作，每个类被成功解析后都会拥有一个ClassObject类型的数据结构存储在运行时环境中，虚拟机使用gDvm.loadedClasses全局哈希表来存储与查询所有装载进来的类，字节码验证器使用<code>dvmVerifyCodeFlow()</code>函数对装入的代码进行校验，接着虚拟机调用<code>FindClass()</code>函数查找并装载main方法类，随后调用<code>dvmInterpret()</code>函数初始化解释器并执行字节码流。</p>
<h2 id="3-3-DEX文件反汇编"><a href="#3-3-DEX文件反汇编" class="headerlink" title="3.3 DEX文件反汇编"></a>3.3 DEX文件反汇编</h2><p>DEX文件的反汇编工具我们用BakSmali，BakSmali提供反汇编功能的同时，还支持使用Smali工具打包反汇编代码重新生成DEX文件，这个功能被广泛应用于APK文件的修改、补丁、破解等场合。（如果是class文件转换为DEX文件可用<code>dx.jar</code>或<code>smali.jar</code>工具）</p>
<p>反汇编DEX文件，在baksmaliout目录下生成<code>Hello.smali</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar baksmali.jar d -o baksmaliout Hello.dex</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">.class public LHello;</span><br><span class="line">.super Ljava/lang/Object;</span><br><span class="line">.source &quot;Hello.java&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># direct methods</span><br><span class="line">.method public constructor &lt;init&gt;()V</span><br><span class="line">    .registers 1</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 1</span><br><span class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line">.method public static main([Ljava/lang/String;)V</span><br><span class="line">    .registers 5</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 9</span><br><span class="line">    new-instance v0, LHello;</span><br><span class="line"></span><br><span class="line">    invoke-direct &#123;v0&#125;, LHello;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    .line 10</span><br><span class="line">    sget-object v1, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line">    const/4 v2, 0x5</span><br><span class="line"></span><br><span class="line">    const/4 v3, 0x3</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0, v2, v3&#125;, LHello;-&gt;foo(II)I</span><br><span class="line"></span><br><span class="line">    move-result v0</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v1, v0&#125;, Ljava/io/PrintStream;-&gt;println(I)V</span><br><span class="line"></span><br><span class="line">    .line 11</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># virtual methods</span><br><span class="line">.method public foo(II)I</span><br><span class="line">    .registers 5</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 5</span><br><span class="line">    add-int v0, p1, p2</span><br><span class="line"></span><br><span class="line">    sub-int v1, p1, p2</span><br><span class="line"></span><br><span class="line">    mul-int/2addr v0, v1</span><br><span class="line"></span><br><span class="line">    return v0</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>
<p>有关Smali与Dalvik的语法知识可以看我之前写的一篇笔记<a target="_blank" rel="noopener" href="https://v5le0n9.github.io/posts/15be101a.html#1-%E5%88%9D%E8%AF%86APK%E3%80%81Dalvik%E5%AD%97%E8%8A%82%E7%A0%81%E4%BB%A5%E5%8F%8ASmali">初识APK、Dalvik字节码以及Smali</a>，虽然不全但应该够用。</p>
<h1 id="4-Android可执行文件"><a href="#4-Android可执行文件" class="headerlink" title="4. Android可执行文件"></a>4. Android可执行文件</h1><p>DEX文件是由Java代码编译得到的Dalvik虚拟机能直接执行的文件。分析Android程序大多数时候是在和DEX文件打交道。</p>
<h2 id="4-1-Android程序的生成步骤"><a href="#4-1-Android程序的生成步骤" class="headerlink" title="4.1 Android程序的生成步骤"></a>4.1 Android程序的生成步骤</h2><ol>
<li>打包资源文件，生成<code>R.java</code>文件；</li>
<li>处理aidl文件，生成相应的Java文件；</li>
<li>编译工程源码，生成相应的class文件；</li>
<li>转换所有的class文件，生成<code>classes.dex</code>文件；</li>
<li>打包生成APK文件；</li>
<li>对APK文件进行签名；</li>
<li>对签名后的APK文件进行对齐处理。</li>
</ol>
<h2 id="4-2-DEX文件格式"><a href="#4-2-DEX文件格式" class="headerlink" title="4.2 DEX文件格式"></a>4.2 DEX文件格式</h2><p>DEX文件使用到的数据类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>u1</td>
<td>等同于uint8_t，1字节的无符号数</td>
</tr>
<tr>
<td>u2</td>
<td>等同于uint16_t，2字节的无符号数</td>
</tr>
<tr>
<td>u3</td>
<td>等同于uint32_t，4字节的无符号数</td>
</tr>
<tr>
<td>u4</td>
<td>等同于uint64_t，8字节的无符号数</td>
</tr>
<tr>
<td>sleb128</td>
<td>有符号LEB128，可变长度1~5字节</td>
</tr>
<tr>
<td>uleb128</td>
<td>无符号LEB128，可变长度1~5字节</td>
</tr>
<tr>
<td>uleb128p1</td>
<td>无符号LEB128值加1，可变长度1~5字节</td>
</tr>
</tbody>
</table>
</div>
<p>sleb128、uleb128、uleb128p1是DEX文件中特有的LEB128数据类型。其中每个LEB128由1~5个字节组成，所有的字节组合在一起表示一个32位的数据。</p>
<img src="/posts/d368aa06/4.2.1.png" class="" title="LEB128数据类型">
<p>每个字节只有7位有效位，如果第1个字节的最高位为1，标识LEB128需要用到第2个字节，如果第2个字节的最高位为1，表示会用到第3个字节，以此类推，直到最后的字节最高位为0。LEB128最多只会使用到5个字节，如果第5个字节的最高位仍为1，表示该DEX文件无效，Dalvik虚拟机在验证DEX文件时会失败返回。</p>
<p>DEX文件是由多个结构体组合而成。一个DEX文件由9部分组成，分别为dex header、string_ids、type_ids、proto_ids、field_ids、method_ids、class_def、data、link_data。</p>
<img src="/posts/d368aa06/4.2.4.png" class="" title="DEX文件结构">
<h3 id="4-2-1-dex-header"><a href="#4-2-1-dex-header" class="headerlink" title="4.2.1 dex header"></a>4.2.1 dex header</h3><p>dex header指定了DEX文件的一些属性，并记录了其它8部分数据结构在DEX文件中的物理偏移与大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexHeader</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u1      magic[<span class="number">8</span>];<span class="comment">//魔数，标识DEX文件</span></span><br><span class="line">    u4      checksum; <span class="comment">//adler32校验</span></span><br><span class="line">    u1      signature[kSHA1DigestLen];<span class="comment">//SHA-1哈希值 </span></span><br><span class="line">    u4      file_size; <span class="comment">//DEX文件大小</span></span><br><span class="line">    u4      header_size; <span class="comment">//DexHeader大小</span></span><br><span class="line">    u4      endian_tag; <span class="comment">//字节序标记</span></span><br><span class="line">    u4      link_size; <span class="comment">//链接段大小</span></span><br><span class="line">    u4      link_off; <span class="comment">//链接段偏移</span></span><br><span class="line">    u4      map_off;<span class="comment">//DexMapList的文件偏移</span></span><br><span class="line">    u4      string_ids_size; <span class="comment">//DexStringId的个数</span></span><br><span class="line">    u4      string_ids_off; <span class="comment">//DexStringId的文件偏移</span></span><br><span class="line">    u4      type_ids_size; <span class="comment">//DexTypeId的个数</span></span><br><span class="line">    u4      type_ids_off; <span class="comment">//DexTypeId的文件偏移</span></span><br><span class="line">    u4      proto_ids_size; <span class="comment">//DexProtoId的个数</span></span><br><span class="line">    u4      proto_ids_off; <span class="comment">//DexProtoId的文件偏移</span></span><br><span class="line">    u4      field_ids_size;<span class="comment">//DexFieldId的个数</span></span><br><span class="line">    u4      field_ids_off;<span class="comment">//DexFieldId的文件偏移</span></span><br><span class="line">    u4      method_ids_size; <span class="comment">//DexMethodId的个数</span></span><br><span class="line">    u4      method_ids_off; <span class="comment">//DexMethodId的文件偏移</span></span><br><span class="line">    u4      class_defs_size; <span class="comment">//DexClassDef的个数</span></span><br><span class="line">    u4      class_defs_off; <span class="comment">//DexClassDef的文件偏移</span></span><br><span class="line">    u4      data_size;<span class="comment">//数据段的大小</span></span><br><span class="line">    u4      data_off; <span class="comment">//数据段的文件偏移</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>magic：表示了一个有效的DEX文件，目前它的值固定为64 65 78 0a 30 33 35 00。</li>
<li>checksum：DEX文件的校验和，通过它来判断DEX文件是否被损坏或篡改。</li>
<li>signature：识别最佳化之前的DEX文件。</li>
<li>header_size：记录了DexHeader结构本身占用的字节数，为0x70。</li>
<li>endian_tag：指定了dex运行环境的cpu字节序，预设值ENDIAN_CONSTANT等于0x12345678，默认采用Little-Endian字节序。</li>
<li>link_size和link_off：指定链接段的大小与文件偏移，大多数情况下它们的值都为0。</li>
<li>map_off：指定了DexMapList结构的文件偏移。</li>
</ul>
<img src="/posts/d368aa06/4.2.2.png" class="" title="DEX文件格式">
<h3 id="4-2-2-DexMapList"><a href="#4-2-2-DexMapList" class="headerlink" title="4.2.2 DexMapList"></a>4.2.2 DexMapList</h3><p>Dalvik虚拟机解析DEX文件的内容，最终将其映射成DexMapList数据结构。DexHeader结构的map_off字段指明了DexMapList结构在DEX文件中的偏移。</p>
<p>DexMapList数据结构声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMapList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    size;<span class="comment">//DexMapItem的个数</span></span><br><span class="line">    DexMapItem    <span class="built_in">list</span>[<span class="number">1</span>];<span class="comment">//DexMapItem结构</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>size字段表示接下来有多少个DexMapItem结构，它的声明如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMapItem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u2    type;<span class="comment">//kDexType开头的类型</span></span><br><span class="line">    u2    unused;<span class="comment">//未使用，用于字节对齐</span></span><br><span class="line">    u4    size;<span class="comment">//指定类型的个数</span></span><br><span class="line">    u4    offset;<span class="comment">//指定类型数据的文件偏移</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>type字段为一个枚举常量，通过类型名称很容易判断它的具体类型。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    kDexTypeHeaderItem				= <span class="number">0x0000</span>,</span><br><span class="line">    kDexTypeStringIdItem			= <span class="number">0x0001</span>,</span><br><span class="line">    kDexTypeTypeIdItem				= <span class="number">0x0002</span>,</span><br><span class="line">    kDexTypeProtoIdItem				= <span class="number">0x0003</span>,</span><br><span class="line">    kDexTypeFieldIdItem				= <span class="number">0x0004</span>,</span><br><span class="line">    kDexTypeMethodIdItem			= <span class="number">0x0005</span>,	</span><br><span class="line">    kDexTypeClassDefItem			= <span class="number">0x0006</span>,</span><br><span class="line">    kDexTypeMapList					= <span class="number">0x1000</span>,</span><br><span class="line">    kDexTypeTypeList				= <span class="number">0x1001</span>,</span><br><span class="line">    kDexTypeAnnotationSetRefItem	= <span class="number">0x1002</span>,</span><br><span class="line">    kDexTypeAnnotationSetItem		= <span class="number">0x1003</span>,</span><br><span class="line">    kDexTypeClassDataItem			= <span class="number">0x2000</span>,</span><br><span class="line">    kDexTypeCodeItem				= <span class="number">0x2001</span>,</span><br><span class="line">    kDexTypeStringDataItem			= <span class="number">0x2002</span>,</span><br><span class="line">    kDexTypeDebugInfoItem			= <span class="number">0x2003</span>,</span><br><span class="line">    kDexTypeAnnotationItem			= <span class="number">0x2004</span>,</span><br><span class="line">    kDexTypeEncodeArrayItem			= <span class="number">0x2005</span>,</span><br><span class="line">    kDexTypeAnnotationsDirectoryItem= <span class="number">0x2006</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>size字段制定了特定类型的个数，它们以特定的类型在DEX文件中连续存放。</li>
<li>offset字段为该类型的文件起始偏移地址。</li>
</ul>
<p>以<code>Hello.dex</code>为例，在dex header中找到DexMapList数据结构的物理偏移地址为0x290。</p>
<img src="/posts/d368aa06/4.2.3.png" class="" title="DEX文件格式">
<p>读取0x290处的一个双字值为0x0d，表明紧跟着13个DexMapItem结构。使用010 Editor的DEX模板分析DEX文件一目了然。</p>
<h3 id="4-2-3-string-ids"><a href="#4-2-3-string-ids" class="headerlink" title="4.2.3 string_ids"></a>4.2.3 string_ids</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexStringId</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    stringDataOff;<span class="comment">//字符串数据偏移</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>DexStringId结构只有一个stringDataOff字段，直接指向字符串数据。</p>
<img src="/posts/d368aa06/4.2.5.png" class="" title="DexStringId">
<p>这里的字符串数据并非普通的ASCII字符串，它是由MUTF-8编码来表示的，不同于UTF-8。MUTF-8字符串的头部存放的是由uleb128编码的字符的个数，后面才是真正的字符串，最后以空字符0表示字符串结尾。</p>
<h3 id="4-2-4-type-ids"><a href="#4-2-4-type-ids" class="headerlink" title="4.2.4 type_ids"></a>4.2.4 type_ids</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeId</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    descriptorIdx;<span class="comment">//指向DexStringId列表的索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>descriptorIdx为指向DexStringId列表的索引，它对应的字符串代表了具体类的类型。</p>
<img src="/posts/d368aa06/4.2.6.png" class="" title="DexTypeId">
<h3 id="4-2-5-proto-ids"><a href="#4-2-5-proto-ids" class="headerlink" title="4.2.5 proto_ids"></a>4.2.5 proto_ids</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexProtoId</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    shortyIdx;<span class="comment">//指向DexStringId列表的索引</span></span><br><span class="line">    u4    returnTypeIdx;<span class="comment">//指向DexTypeId列表的索引</span></span><br><span class="line">    u4    parametersOff;<span class="comment">//指向DexTypeList的偏移</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>DexProtoId是一个方法声明结构体，shortyIdx为方法声明字符串，returnTypeIdx为方法返回类型字符串，parametersOff指向一个DexTypeList结构体，存放了方法的参数列表，DexTypeList声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    size;<span class="comment">//DexTypeItem的个数</span></span><br><span class="line">    DexTypeItem     <span class="built_in">list</span>[<span class="number">1</span>];<span class="comment">//DexTypeItem结构</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>DexTypeItem声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeItem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u2    typeIdx;<span class="comment">//指向DexTypeId列表的索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>DexTypeItem中的typeIdx最终也是指向一个字符串。</p>
<img src="/posts/d368aa06/4.2.7.png" class="" title="DexProtoId">
<h3 id="4-2-6-field-ids"><a href="#4-2-6-field-ids" class="headerlink" title="4.2.6 field_ids"></a>4.2.6 field_ids</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFieldId</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u2    classIdx;<span class="comment">//类的类型，指向DexTypeId列表的索引</span></span><br><span class="line">    u2    typeIdx;<span class="comment">//字段类型，指向DexTypeId列表的索引</span></span><br><span class="line">    u4    nameIdx;<span class="comment">//字段名，指向DexStringId列表的索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>DexFieldId结构中的数据全部是索引值，指明了字段所在的类、字段的类型以及字段名。</p>
<h3 id="4-2-7-method-ids"><a href="#4-2-7-method-ids" class="headerlink" title="4.2.7 method_ids"></a>4.2.7 method_ids</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethodId</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u2    classIdx;<span class="comment">//类的类型，指向DexTypeId列表的索引</span></span><br><span class="line">    u2    protoIdx;<span class="comment">//声明类型，指向DexProtoId列表的索引</span></span><br><span class="line">    u4    nameIdx;<span class="comment">//方法名，指向DexStringId列表的索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>DexMethodId结构的数据也都是索引，指明了方法所在的类、方法的声明以及方法名。</p>
<h3 id="4-2-8-class-def"><a href="#4-2-8-class-def" class="headerlink" title="4.2.8 class_def"></a>4.2.8 class_def</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassDef</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    classIdx;<span class="comment">//类的类型，执行DexTypeId列表的索引</span></span><br><span class="line">    u4    accessFlags;<span class="comment">//访问标志</span></span><br><span class="line">    u4    superclassIdx;<span class="comment">//父类类型，指向DexTypeId列表的索引</span></span><br><span class="line">    u4    interfacesOff;<span class="comment">//接口，指向DexTypeList的偏移</span></span><br><span class="line">    u4    sourceFileIdx;<span class="comment">//源文件名，指向DexStringId列表的索引</span></span><br><span class="line">    u4    annotationsOff;<span class="comment">//注解，指向DexAnnotationsDirectoryItem结构</span></span><br><span class="line">    u4    classDataOff;<span class="comment">//指向DexClassData结构的偏移</span></span><br><span class="line">    u4    staticValuesOff;<span class="comment">//指向DexEncodedArray结构的偏移，记录类中的静态数据  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-9-data"><a href="#4-2-9-data" class="headerlink" title="4.2.9 data"></a>4.2.9 data</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DexClassDataHeader    header;<span class="comment">//指定字段与方法的个数</span></span><br><span class="line">    DexField *    staticFields;<span class="comment">//静态字段，DexField结构</span></span><br><span class="line">    DexField *    instanceFields;<span class="comment">//实例字段，DexField结构</span></span><br><span class="line">    DexMethod *    directMethods;<span class="comment">//直接方法，DexMethod结构</span></span><br><span class="line">    DexMethod *    virtualMethods;<span class="comment">//虚方法，DexMethod结构</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>DexClassDataHeader结构记录了当前类中字段与方法的数目，它的声明如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassDataHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    staticFieldsSize;<span class="comment">//静态字段个数</span></span><br><span class="line">    u4    instanceFieldsSize;<span class="comment">//实例字段个数</span></span><br><span class="line">    u4    directMethodsSize;<span class="comment">//直接方法个数</span></span><br><span class="line">    u4    virtualMethodsSize;<span class="comment">//虚方法个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>DexField结构描述了字段的类型与访问标志，它的结构声明如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFiled</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    fieldIdx;<span class="comment">//指向DexFieldId的索引</span></span><br><span class="line">    u4    accessFlags;<span class="comment">//访问标志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>accessFlags字段与DexClassDef中的相应字段的类型相同。</p>
<ul>
<li>DexMethod结构描述方法的原型、名称、访问标志以及代码数据块，它的声明如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethod</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    methodIdx;<span class="comment">//指向DexMethodId的索引</span></span><br><span class="line">    u4    accessFlags;<span class="comment">//访问标志</span></span><br><span class="line">    u4    codeOff;<span class="comment">//指向DexCode结构的偏移</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>DexCode描述了方法更详细的信息以及方法中指令的内容，它的声明如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexCode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u2    registersSize;<span class="comment">//使用的寄存器个数</span></span><br><span class="line">    u2    insSize;<span class="comment">//参数个数</span></span><br><span class="line">    u2    outsSize;<span class="comment">//调用其他方法时使用的寄存器个数</span></span><br><span class="line">    u2    triesSize;<span class="comment">//Try/Catch个数</span></span><br><span class="line">    u4    debugInfoOff;<span class="comment">//指向调试信息的偏移</span></span><br><span class="line">    u4    insnsSize;<span class="comment">//指令集个数，以2字节为单位</span></span><br><span class="line">    u2    insns[<span class="number">1</span>];<span class="comment">//指令集</span></span><br><span class="line">    <span class="comment">//2字节空间用于结构对齐</span></span><br><span class="line">    <span class="comment">//try_item[triesSize]    DexTry结构</span></span><br><span class="line">    <span class="comment">//Try/Catch中handler的个数</span></span><br><span class="line">    <span class="comment">//catc_handler_item[handlersSize]    DexCatchHandler结构</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-ODEX文件格式"><a href="#4-3-ODEX文件格式" class="headerlink" title="4.3 ODEX文件格式"></a>4.3 ODEX文件格式</h2><p>ODEX是OptimizedDEX的缩写，表示经过优化的DEX文件。ODEX文件仅存在于Android 4.4以前，ART模式下DEX则被优化为OAT文件。</p>
<p>ODEX有两种存在方式：一种是从APK程序中提取出来，与APK文件存放在同一目录且文件后缀为<code>.odex</code>的文件，这类ODEX文件多是Android ROM的系统程序；另一种是dalvik-cache缓存文件，这类ODEX文件仍然以<code>.dex</code>为后缀，存放在<code>cache/dalvik-cache</code>目录，保存的形式为“apk路径@apk名@classes.dex”，例如“system@app@Calculator.apk@classes.dex”表示安装在<code>system/app</code>目录下<code>Calculator.apk</code>程序的ODEX文件。</p>
<p>由于Android程序的APK文件为ZIP压缩包格式，Dalvik虚拟机每次加载它们时需要从APK中读取<code>classes.dex</code>文件，这会耗费很多CPU时间。而采用ODEX方式优化的DEX文件，已经包含了加载DEX必须的依赖库文件列表，Dalvik虚拟机只需检测并加载所需的依赖库即可执行相应的DEX文件，这大大缩短了读取DEX文件所需的时间，而对于部分Android系统的ROM，由于将系统App全部转换成外置的ODEX文件与APK文件放在同一目录，这样系统在启动加载这些程序时会节省更多的时间，启动速度自然也会更快。</p>
<h3 id="4-3-1-生成ODEX文件"><a href="#4-3-1-生成ODEX文件" class="headerlink" title="4.3.1 生成ODEX文件"></a>4.3.1 生成ODEX文件</h3><p>下载<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1D4D2-1IM-rWiOtj8c8tMKA">dexopt-wrapper</a>(提取码：w9nc)工具，将dexopt-wrapper程序push到Android设备(Android 4.4可行，Android 9出错)上并赋予执行权限，执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb push dexopt-wrapper /data/local</span><br><span class="line">adb shell chmod 777 /data/local/dexopt-wrapper</span><br></pre></td></tr></table></figure>
<p>将<code>Hello.dex</code>文件改名为<code>classes.dex</code>并打包成ZIP文件，将ZIP文件push到与dexopt-wrapper工具同目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push classes.zip /data/local</span><br></pre></td></tr></table></figure>
<p>调用dexopt-wrapper来生成ODEX文件，进入<code>/data/local</code>运行dexopt-wrapper工具：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@vbox86p:/data/local # ./dexopt-wrapper classes.zip Hello.odex</span><br><span class="line">--- BEGIN &#x27;classes.zip&#x27; (bootstrap=0) ---</span><br><span class="line">--- waiting for verify+opt, pid=2191</span><br><span class="line">--- would reduce privs here</span><br><span class="line">--- END &#x27;classes.zip&#x27; (success) ---</span><br><span class="line">root@vbox86p:/data/local #</span><br></pre></td></tr></table></figure>
<p>将ODEX文件pull出来以备后续分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /data/local/Hello.odex</span><br></pre></td></tr></table></figure>
<h3 id="4-3-2-ODEX文件结构"><a href="#4-3-2-ODEX文件结构" class="headerlink" title="4.3.2 ODEX文件结构"></a>4.3.2 ODEX文件结构</h3><p>ODEX文件的结构可以理解为DEX文件的一个父集(超集)，ODEX文件在DEX文件头部添加了一些数据，在DEX文件尾部添加了DEX文件的依赖库以及一些辅助数据。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">odex文件头</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">dex文件</td>
</tr>
<tr>
<td style="text-align:center">依赖库</td>
</tr>
<tr>
<td style="text-align:center">辅助数据</td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-3-2-1-odex文件头"><a href="#4-3-2-1-odex文件头" class="headerlink" title="4.3.2.1 odex文件头"></a>4.3.2.1 odex文件头</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexOptHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u1    magic[<span class="number">8</span>];<span class="comment">//魔数，用于标识ODEX文件</span></span><br><span class="line">    u4    dexOffset;<span class="comment">//dex文件头偏移</span></span><br><span class="line">    u4    dexLength;<span class="comment">//dex文件总长度</span></span><br><span class="line">    u4    depsOffset;<span class="comment">//odex依赖库列表偏移</span></span><br><span class="line">    u4    depsLength;<span class="comment">//依赖库列表总长度</span></span><br><span class="line">    u4    optOffset;<span class="comment">//辅助数据偏移</span></span><br><span class="line">    u4    optLength;<span class="comment">//辅助数据总长度</span></span><br><span class="line">    u4    flags;<span class="comment">//标志</span></span><br><span class="line">    u4    checksum;<span class="comment">//依赖库与辅助数据的校验和</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>magic：标识一个有效的ODEX文件，值为64 65 79 0A 30 33 36 00。</li>
<li>dexOffset：dex文件头的偏移，总为0x28，也就是说odex文件头大小为0x28。</li>
<li>flags：DexoptFlags中的常量，标识了Dalvik虚拟机加载ODEX时的优化与验证选项。</li>
<li>checksum：ODEX文件的校验和，标识了ODEX是否有效。</li>
</ul>
<h4 id="4-3-2-2-依赖库"><a href="#4-3-2-2-依赖库" class="headerlink" title="4.3.2.2 依赖库"></a>4.3.2.2 依赖库</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dependences</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    modWhen;<span class="comment">//时间戳</span></span><br><span class="line">    u4    crc;<span class="comment">//校验</span></span><br><span class="line">    u4    DALVIK_VM_BUILD;<span class="comment">//Dalvik虚拟机版本号</span></span><br><span class="line">    u4    numDeps;<span class="comment">//依赖库个数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        u4    len;<span class="comment">//name字符串的长度</span></span><br><span class="line">        u1    name[len];<span class="comment">//依赖库的名称</span></span><br><span class="line">        kSHA1DigestLen signature;<span class="comment">//SHA-1哈希值</span></span><br><span class="line">    &#125;table[numDeps];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>modWhen：记录优化前<code>classes.dex</code>的时间戳。</li>
<li>crc：优化前<code>classes.dex</code>的crc校验值。</li>
</ul>
<h4 id="4-3-2-3-辅助数据"><a href="#4-3-2-3-辅助数据" class="headerlink" title="4.3.2.3 辅助数据"></a>4.3.2.3 辅助数据</h4><p>依赖库紧接着为3个Chunk块，它们被Dalvik虚拟机加载到一个称为auxillary的段中。</p>
<h5 id="4-3-2-3-1-ChunkDexClassLookup"><a href="#4-3-2-3-1-ChunkDexClassLookup" class="headerlink" title="4.3.2.3.1 ChunkDexClassLookup"></a>4.3.2.3.1 ChunkDexClassLookup</h5><p>数据通过<code>writeChunk()</code>函数写入，该函数中定义了1个header。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> raw[<span class="number">8</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        u4    type;</span><br><span class="line">        u4    size;</span><br><span class="line">    &#125;ts;</span><br><span class="line">&#125;header;</span><br></pre></td></tr></table></figure>
<p>这个header结构占用了8个字节，<code>writeChunk()</code>函数在写入具体的结构时会先填充这个结构。</p>
<ul>
<li>其中的type字段为1个以kDexChunk开头的枚举常量，它的值定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    kDexChunkClassLookup			= <span class="number">0x434c4b50</span>,</span><br><span class="line">    kDexChunkRegisterMaps			= <span class="number">0x524d4150</span>,</span><br><span class="line">    kDexChunkEnd					= <span class="number">0x41454e44</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>size则为需要填充的数据的字节数。写入kDexChunkClassLookup结构时<code>writeOptData()</code>函数向<code>writeChunk()</code>函数传递了1个DexClassLookup结构的指针，它的结构声明如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassLookup</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> numEntries;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        u4 classDescriptorHash;</span><br><span class="line">        <span class="type">int</span> classDescriptorOffset;</span><br><span class="line">        <span class="type">int</span> classDefOffset;</span><br><span class="line">    &#125;table[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Dalvik虚拟机通过DexClassLoopup结构来检索DEX文件中所有的类，其中size字段为本结构的字节数，numEntries字段为接下来的table结构的项数，通常值为2，而table结构用来描述了类的信息，classDescriptorHash字段和classDescriptorOffset字段为类的哈希值与类的描述，classDefOffset字段指向DexClassDef结构的指针。</p>
<p>根据上面的分析，可以总结出ChunkDexClassLookup的结构声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ChunkDexClassLookup</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Header header;</span><br><span class="line">    DexClassLookup lookup;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="4-3-2-3-2-ChunkRegisterMapPool"><a href="#4-3-2-3-2-ChunkRegisterMapPool" class="headerlink" title="4.3.2.3.2 ChunkRegisterMapPool"></a>4.3.2.3.2 ChunkRegisterMapPool</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ChunkRegisterMapool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Header header;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">RegisterMapClassPool</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            u4 numClasses;</span><br><span class="line">            u4 classDataOffset[<span class="number">1</span>];</span><br><span class="line">        &#125;classpool;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">RegisterMapMethodPool</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            u2 methodCount;</span><br><span class="line">            u4 methodData[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;lookup;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="4-3-2-3-3-ChunkEnd"><a href="#4-3-2-3-3-ChunkEnd" class="headerlink" title="4.3.2.3.3 ChunkEnd"></a>4.3.2.3.3 ChunkEnd</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ChunkEnd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Header header;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/posts/d368aa06/4.3.1.jpg" class="" title="odex文件格式">
<h2 id="4-4-Anroid程序另类破解方法"><a href="#4-4-Anroid程序另类破解方法" class="headerlink" title="4.4 Anroid程序另类破解方法"></a>4.4 Anroid程序另类破解方法</h2><p>Android程序的代码都存储在DEX文件中，通过修改代码中的执行路径是否就可以达到破解的目的呢？那么如何定位程序的破解点呢？IDA Pro可以非常方便地找到程序破解点对应的文件偏移。</p>
<p>用到我们之前编写的crackme程序，将<code>app-debug.apk</code>解压，有3个DEX文件，可用AK查看我们编写的代码在哪个DEX文件中。我的是在<code>classes3.dex</code>中，将其载入IDA Pro。Search -&gt; Text(快捷键Alt + T)，查找失败字符串的id值，定位到相关的Smali字节码附近。</p>
<img src="/posts/d368aa06/4.4.1.png" class="" title="IDA分析">
<p>选中关键跳那一行，去到Hex View-1视图，高亮部分就是我们选中的关键跳指令的二进制代码，为<code>39 00 0D 00</code>。第1个字节39是if-nez指令的操作码，而if-eqz指令的操作码为38，所以将39改为38即可。选中39右键 -&gt; Edit，修改为38，右键 -&gt; Apply changes。在工具栏 Edit -&gt; Patch program -&gt; Apply patches to input file即可。</p>
<p>APK程序安装时会调用dexopt对DEX进行验证和优化，DEX文件中DexHeader头的checksum字段标识了DEX文件的合法性，被篡改过的DEX文件在验证时计算checksum会失败，导致程序安装失败，因此，我们需要重新计算并写入checksum值。下载<a target="_blank" rel="noopener" href="https://down.52pojie.cn/Tools/Android_Tools/DexFixer.zip">DexFixer</a>工具，将修改过的DEX文件载入即可。(Win 11不兼容此工具)</p>
<img src="/posts/d368aa06/4.4.2.png" class="" title="DexFixer修复DEX文件">
<p>将修复后的DEX文件重新放回原处，删除app-debug目录中的META-INF文件夹，压缩成ZIP文件，改后缀名为<code>.apk</code>，使用AK的签名工具给APK文件进行签名，安装到Android设备，同样也可以成功注册。</p>
<img src="/posts/d368aa06/4.4.3.png" class="" title="APK签名">
<h1 id="5-静态分析Android程序"><a href="#5-静态分析Android程序" class="headerlink" title="5. 静态分析Android程序"></a>5. 静态分析Android程序</h1><h2 id="5-1-AndroidManifest-xml"><a href="#5-1-AndroidManifest-xml" class="headerlink" title="5.1 AndroidManifest.xml"></a>5.1 AndroidManifest.xml</h2><p>每个APK文件都包含有一个AndroidManifest.xml文件，它记录着软件的一些基本信息，包括软件的报名、运行的系统版本、用到的组件等。</p>
<p>一个Android程序由一个或多个Activity以及其它组件组成，每个Activity都是相同级别的，不同的Activity实现不同的功能。每个Activity都是Android程序的一个显示“页面”，主要负责数据的处理及展示工作。</p>
<p>每个Android程序有且只有一个主Activity（隐藏程序除外，它没有主Activity），它是程序启动的第一个Activity。<code>app-debug.apk</code>的<code>AndroidManifest.xml</code>如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> standalone=<span class="string">&quot;no&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">android:compileSdkVersion</span>=<span class="string">&quot;31&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">android:compileSdkVersionCodename</span>=<span class="string">&quot;12&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">package</span>=<span class="string">&quot;com.example.crackme&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">platformBuildVersionCode</span>=<span class="string">&quot;31&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">platformBuildVersionName</span>=<span class="string">&quot;12&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:appComponentFactory</span>=<span class="string">&quot;androidx.core.app.CoreComponentFactory&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:debuggable</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.Crackme&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> </span></span><br><span class="line"><span class="tag">                  <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">                  <span class="attr">android:name</span>=<span class="string">&quot;com.example.crackme.MainActivity&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-1-1-manifest标签"><a href="#5-1-1-manifest标签" class="headerlink" title="5.1.1 manifest标签"></a>5.1.1 manifest标签</h3><p>所有的XML文件都必须包含manifest标签，这是文件的根节点。它必须要包含application标签，并且指明<code>xmlns:android</code>和<code>package</code>属性。</p>
<h4 id="5-1-1-1-xmlns-android"><a href="#5-1-1-1-xmlns-android" class="headerlink" title="5.1.1.1 xmlns:android"></a>5.1.1.1 xmlns:android</h4><p>这个属性定义了Andrid命名空间，必须设置成”<a target="_blank" rel="noopener" href="http://schemas.android.com/apk/res/android&quot;，不能手动修改。">http://schemas.android.com/apk/res/android&quot;，不能手动修改。</a></p>
<h4 id="5-1-1-2-package"><a href="#5-1-1-2-package" class="headerlink" title="5.1.1.2 package"></a>5.1.1.2 package</h4><p>这是一个完整的Java语言风格包名。包名由英文字母（大小写均可）、数字和下划线组成。每个独立的名字必须以字母开头。</p>
<p>构建APK的时候，构建系统使用这个属性来做两件事：</p>
<ul>
<li>生成<code>R.java</code>类时用这个名字作为命名空间（用于访问App的资源）。比如：package被设置成com.sample.teapot，那么生成的R类就是：com.sample.teapot.R</li>
<li>用来生成在manifest文件中定义的类的完整类名。比如package被设置成com.sample.teapot，并且activity元素被声明成<activity android:name=".MainActivity">，完整的类名就是com.sample.teapot.MainActivity。</li>
</ul>
<p>包名也代表着唯一的application ID，用来发布应用。但是，要注意的一点是：在APK构建过程的最后一步，package名会被build.gradle文件中的applicationId属性取代。如果这两个属性值一样，那么万事大吉，如果不一样，那就要小心了。</p>
<h4 id="5-1-1-3-adnroid-versionCode"><a href="#5-1-1-3-adnroid-versionCode" class="headerlink" title="5.1.1.3 adnroid:versionCode"></a>5.1.1.3 adnroid:versionCode</h4><p>内部的版本号。用来表明版本的更新。这个数字不会显示给用户。显示给用户的是android:versionName。这个数字必须是整数。不能用16进制，也就是说不接受”0x1”这种参数。</p>
<h4 id="5-1-1-4-android-versionName"><a href="#5-1-1-4-android-versionName" class="headerlink" title="5.1.1.4 android:versionName"></a>5.1.1.4 android:versionName</h4><p>显示给用户看的版本号。</p>
<h3 id="5-1-2-uses-feature标签"><a href="#5-1-2-uses-feature标签" class="headerlink" title="5.1.2 uses-feature标签"></a>5.1.2 uses-feature标签</h3><p>uses-feature标签是manifest标签里的元素，Google Play利用这个标签的值从不符合应用需要的设备上将应用过滤。</p>
<p>它的作用是将App所依赖的硬件或者软件条件告诉别人，说明了App的哪些功能可以随设备的变化而变化。</p>
<p>使用的时候要注意，必须在单独的<uses-feature>元素中指定每个功能，如果要多个功能，需要多个<uses-feture>元素。比如要求设备同时具有蓝牙和相机功能：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.bluetooth&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.camera&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-1-2-1-android-name"><a href="#5-1-2-1-android-name" class="headerlink" title="5.1.2.1 android:name"></a>5.1.2.1 android:name</h4><p>该属性以字符串形式指定了APP要用的硬件或软件功能。</p>
<h4 id="5-1-2-2-android-required"><a href="#5-1-2-2-android-required" class="headerlink" title="5.1.2.2 android:required"></a>5.1.2.2 android:required</h4><p>这项属性如果值为true表示需要这项功能，否则应用无法工作，如果为false表示应用在必要时会使用该功能，但是如果没有此功能应用也能工作。</p>
<h4 id="5-1-2-3-android-glEsVersion"><a href="#5-1-2-3-android-glEsVersion" class="headerlink" title="5.1.2.3 android:glEsVersion"></a>5.1.2.3 android:glEsVersion</h4><p>指明应用需要的Opengl ES版本。高16位表示主版本号，低16位表示次版本号。例如，如果是要3.2的版本，就是0x00030002。如果定义多个glEsVersion，应用会自动启用最高的设置。</p>
<h3 id="5-1-3-application标签"><a href="#5-1-3-application标签" class="headerlink" title="5.1.3 application标签"></a>5.1.3 application标签</h3><p>该标签也是manifest标签中的一个元素，描述了应用的配置。这是一个必备的元素，它包含了很多子元素来描述应用的组件，它的属性影响到所有的子组件。许多属性（例如icon、label、permission、process、taskAffinity和allowTaskReparenting）都可以设置成默认值。</p>
<h4 id="5-1-3-1-android-allowBackup"><a href="#5-1-3-1-android-allowBackup" class="headerlink" title="5.1.3.1 android:allowBackup"></a>5.1.3.1 android:allowBackup</h4><p>表示是否允许App加入到备份还原的结构中。如果设置成false，那么应用就不会备份还原。默认值为true。</p>
<h4 id="5-1-3-2-android-fullBackupContent"><a href="#5-1-3-2-android-fullBackupContent" class="headerlink" title="5.1.3.2 android:fullBackupContent"></a>5.1.3.2 android:fullBackupContent</h4><p>这个属性指向了一个XML文件，该文件中包含了在进行自动备份时的完全备份规则。这些规则定义了哪些文件需要备份。此属性是一个可选属性。默认情况下，自动备份包含了大部分App文件。</p>
<h4 id="5-1-3-3-android-supportsRtl"><a href="#5-1-3-3-android-supportsRtl" class="headerlink" title="5.1.3.3 android:supportsRtl"></a>5.1.3.3 android:supportsRtl</h4><p>声明App是否支持RTL（Right To  Left）布局。如果设置成true，并且targetSdkVersion被设置成17或更高。很多RTL  API会被集火，这样你的应用就可以显示RTL布局了。如果设置成false或者targetSdkVersion被设置成16或更低，RTL  API就不起作用了。该属性的默认的值是false。</p>
<h4 id="5-1-3-4-android-icon"><a href="#5-1-3-4-android-icon" class="headerlink" title="5.1.3.4 android:icon"></a>5.1.3.4 android:icon</h4><p>App的图标，以及每个组件的默认图标。可以在组件中自定义图标。这个属性必须设置成一个引用，指向一个可绘制的资源，这个资源必须包含图片。系统不设置默认图标。</p>
<h4 id="5-1-3-5-android-label"><a href="#5-1-3-5-android-label" class="headerlink" title="5.1.3.5 android:label"></a>5.1.3.5 android:label</h4><p>一个用户可读的标签，以及所有组件的默认标签。子组件可以用它们的label属性定义自己的标签，如果没有定义，那么就用这个标签。</p>
<p>标签必须设置成一个字符串资源的引用。这样它们就能和其他东西一样被定位，比如@string/app_name。当然，为了开发方便，你也可以定义一个原始字符串。</p>

<h4 id="5-1-3-6-android-theme"><a href="#5-1-3-6-android-theme" class="headerlink" title="5.1.3.6 android:theme"></a>5.1.3.6 android:theme</h4><p>该属性定义了应用使用的主题的，它是一个指向style资源的引用。各个activity也可以用自己的theme属性设置自己的主题。</p>
<h4 id="5-1-3-7-android-name"><a href="#5-1-3-7-android-name" class="headerlink" title="5.1.3.7 android:name"></a>5.1.3.7 android:name</h4><p>Application子类的全名。包括前面的路径。例如com.sample.teapot.TeapotApplication。当应用启动时，这个类的实例被第一个创建。这个属性是可选的，大多数APP都不需要这个属性。在没有这个属性的时候，Android会启动一个Application类的实例。</p>
<h3 id="5-1-4-activity标签"><a href="#5-1-4-activity标签" class="headerlink" title="5.1.4 activity标签"></a>5.1.4 activity标签</h3><p>activity标签是application标签中的一个元素，声明一个实现应用可视化界面的Activity（Activity类子类）。这是application标签中必要的子标签。所有Activity都必须由清单文件中的activity标签表示。任何未在该处声明的Activity对系统都不可见，并且永远不会被执行。</p>
<h4 id="5-1-4-1-android-name"><a href="#5-1-4-1-android-name" class="headerlink" title="5.1.4.1 android:name"></a>5.1.4.1 android:name</h4><p>Activity类的名称，是Activity类的子类。该属性值为完全限定类名称，例如com.sample.teapot.TeapotNativeActivity。为了方便起见，如果第一个字符是点（’.’），就需要加上manifest标签中的包名。应用一旦发布，不应更改该名称。该元素没有默认值，必须指定该名称。</p>
<h4 id="5-1-4-2-android-label"><a href="#5-1-4-2-android-label" class="headerlink" title="5.1.4.2 android:label"></a>5.1.4.2 android:label</h4><p>Activity标签，可以被用户读取。该标签会在Activity激活时显示在屏幕上。如果未设置，用application中的label属性。对属性的设置要求和application中一样。</p>
<h4 id="5-1-4-3-android-configChanges"><a href="#5-1-4-3-android-configChanges" class="headerlink" title="5.1.4.3 android:configChanges"></a>5.1.4.3 android:configChanges</h4><p>列出 Activity 将自行处理的配置更改消息。在运行时发生配置更改时，默认情况下会关闭 Activity 然后将其重新启动，但使用该属性声明配置将阻止 Activity 重新启动。 Activity 反而会保持运行状态，并且系统会调用其 onConfigurationChanged()方法。</p>
<p>注：应避免使用该属性，并且只应在万不得已的情况下使用。</p>
<p>该属性可以设置的项很多，这里列出常用的项：</p>
<ul>
<li><p>orientation<br> 屏幕方向发生了变化，比如用户旋转了设备</p>
</li>
<li><p>keyboardHidden<br> 键盘无障碍功能发生了变化，比如用户显示了硬件键盘</p>
</li>
<li><p>android:launchMode<br> 关于如何启动Activity的指令。一共有四种指令：<br> “standard”<br> “singleTop”<br> “singleTask”<br> “singleInstance”<br>默认情况下是standard。这些模式被分为两大类：</p>
<p>“standard”和”singleTop”是一类。该模式的Activity可以多次实例化。实例可属于任何任务，并且可以位于Activity堆栈中的任何位置。</p>
<p>“singleTask”和”singleInstance”是一类。该模式只能启动任务，它们始终位于Activity堆栈的根位置。此外，设备一次只能保留一个Activity实例。</p>
<p>设置成singleTask后，系统在新任务的根位置创建Activity并向其传送Intent。如果已经存在一个Activity实例，则系统会通过调用该实例的onNewIntent()方法向其传送Intent而不是创建一个新的Activity实例。</p>
</li>
</ul>
<h4 id="5-1-4-4-android-theme"><a href="#5-1-4-4-android-theme" class="headerlink" title="5.1.4.4 android:theme"></a>5.1.4.4 android:theme</h4><p>设定主题格式，与application标签中的theme属性类似。</p>
<h3 id="5-1-5-meta-data标签"><a href="#5-1-5-meta-data标签" class="headerlink" title="5.1.5 meta-data标签"></a>5.1.5 meta-data标签</h3><p>activity标签中的元素，指定额外的数据项，该数据项是一个name-value对，提供给其父组件。这些数据会组成一个Bundle对象，可以由PackageItemInfo.metaData字段使用。虽然可以使用多个meta-data标签，但是不推荐这么使用。如果有多个数据项要指定，推荐做法是：将多个数据项合并成一个资源，然后使用一个meta-data标签包含进去。</p>
<p>该标签有三个属性：</p>
<ul>
<li>android:name：数据项名称，这是一个唯一值。</li>
<li>android:resource：一个资源的引用。</li>
<li>android:value：数据项的值。</li>
</ul>
<h3 id="5-1-6-intent-filter标签"><a href="#5-1-6-intent-filter标签" class="headerlink" title="5.1.6 intent-filter标签"></a>5.1.6 intent-filter标签</h3><p>activity标签中的元素，指明这个activity可以以什么样的意图(intent)启动。</p>
<h3 id="5-1-7-action标签"><a href="#5-1-7-action标签" class="headerlink" title="5.1.7 action标签"></a>5.1.7 action标签</h3><p>intent-filter标签中的元素，表示activity作为一个什么动作启动，android.intent.action.MAIN表示作为主activity启动。</p>
<h3 id="5-1-8-category标签"><a href="#5-1-8-category标签" class="headerlink" title="5.1.8 category标签"></a>5.1.8 category标签</h3><p>intent-filter标签中的元素，这是action元素的额外类别信息，android.intent.category.LAUNCHER表示这个activity为当前应用程序优先级最高的Activity。</p>
<img src="/posts/d368aa06/5.1.2.png" class="" title="总结">
<h2 id="5-2-定位关键代码的6种方法"><a href="#5-2-定位关键代码的6种方法" class="headerlink" title="5.2 定位关键代码的6种方法"></a>5.2 定位关键代码的6种方法</h2><ul>
<li><p>信息反馈法</p>
<p>运行目标程序，然后根据程序运行时给出的反馈信息作为突破口寻找关键代码。比如在2.2时破解程序就是通过“注册失败”信息来定位关键代码的。通常情况下，程序中用到的字符串会存储在<code>strings.xml</code>文件或硬编码到程序代码中。如果是前者，字符串在程序中会以id的形式访问，只需在反汇编代码中搜索字符串的id值即可找到调用代码处；如果是后者，在反汇编代码中直接搜索字符串即可。</p>
</li>
<li><p>特征函数法</p>
<p>这种定位代码的方法与信息反馈法类似。在信息反馈法中，无论程序给出什么样的反馈信息，终究是需要调用Android SDK中提供的相关API函数来完成的。比如弹出“注册失败”的提示信息就需要调用<code>Toast.MakeText().Show()</code>方法，在反汇编代码中直接搜索Toast应该很快就能定位到调用代码。</p>
</li>
<li><p>顺序查看法</p>
<p>顺序查看法是指从软件的启动代码开始，逐行向下分析，掌握软件的执行流程，这种分析方法在病毒分析时经常用到。</p>
</li>
<li><p>代码注入法</p>
<p>属于动态调试，它的原理是手动修改APK文件的反汇编代码，加入Log输出，配合LogCat查看程序执行到特定点时的状态数据。这种方法在解密程序数据时经常使用。</p>
</li>
<li><p>栈跟踪法</p>
<p>动态调试方法，它的原理是输出运行时的栈跟踪信息，然后查看栈上的函数调用序列来理解方法的执行流程。</p>
</li>
<li><p>Method Profiling</p>
<p>Method Profiling（方法剖析）属于动态调试，主要用于热点分析和性能优化。该功能除了可以记录每个函数占用的CPU时间之外，还能够跟踪所有的函数调用关系，并提供比栈跟踪法更详细的函数调用序列报告。</p>
</li>
</ul>
<h2 id="5-3-使用IDA-Pro静态分析Android程序"><a href="#5-3-使用IDA-Pro静态分析Android程序" class="headerlink" title="5.3 使用IDA Pro静态分析Android程序"></a>5.3 使用IDA Pro静态分析Android程序</h2><p>使用IDA Pro分析DEX文件与使用AK分析APK文件都是差不多的，看的都是Smali代码，而且IDA需要手动解压APK文件提取出DEX文件，修改完后还需打包签名，所以用AK不香吗？希望IDA以后能打我脸。</p>
<h1 id="6-Android-NDK程序"><a href="#6-Android-NDK程序" class="headerlink" title="6. Android NDK程序"></a>6. Android NDK程序</h1><h2 id="6-1-Android原生程序与Android-NDK程序的区别"><a href="#6-1-Android原生程序与Android-NDK程序的区别" class="headerlink" title="6.1 Android原生程序与Android NDK程序的区别"></a>6.1 Android原生程序与Android NDK程序的区别</h2><p>原生程序应该是Java编写的，Android NDK程序是通过JNI(Java Native Interface)提供的API函数将原生C/C++代码与Java代码进行数据交换，使得使用C/C++代码也能写出功能强大的程序，甚至将大部分的Java代码转移到C/C++代码中来。</p>
<p>静态分析Android NDK程序与分析传统的原生程序有些不同，传统的原生程序中只调用了原生API函数，使用IDA Pro分析它们时会被自动识别出来，因此分析的难度转移到了理解ARM指令集序列的含义上。而Android NDK程序使用了JNI接口函数，在分析它们时IDA Pro并不能识别它们，这使得分析工作变得比较艰难。</p>
<h2 id="6-2-分析Android-NDK程序"><a href="#6-2-分析Android-NDK程序" class="headerlink" title="6.2 分析Android NDK程序"></a>6.2 分析Android NDK程序</h2><p>如果使用C++代码来调用JNI接口函数，JNIEnv被定义成了_JNIEnv结构体，该结构体的第一个字段就是一个JNINativeInterface结构体的指针。</p>
<p>如果C代码调用JNI接口函数，JNIEnv则直接被定义成JNINativeInterface结构体的指针。</p>
<p>因此可以将JNIEnv的首地址解释成JNINativeInterface的首地址来使用，通过首地址加上索引值就能找到具体的函数。</p>
<h1 id="7-动态调试Android程序"><a href="#7-动态调试Android程序" class="headerlink" title="7. 动态调试Android程序"></a>7. 动态调试Android程序</h1><p>DDMS(Dalvik Debug Monitor Server，Dalvik调试监视器服务)提供了设备截屏、查看运行的线程信息、文件浏览、LogCat、Method Profiling、广播状态信息、模拟电话呼叫、接收SMS、虚拟地理坐标等功能。它的文件浏览、LogCat、Method Profiling是使用最多的功能。文件浏览可以查看需要分析的程序在安装目录下生成的文件，分析这些文件的内容可以对程序的设置及生成的数据有初步的了解；LogCat则可以输出软件运行时的调试信息；Method Profilng用于跟踪程序的执行流程。</p>
<p>在Android SDK的tools目录下有一个<code>ddms.bat</code>，它就是DDMS的启动文件。</p>
<h2 id="7-1-使用LogCat查看调试信息"><a href="#7-1-使用LogCat查看调试信息" class="headerlink" title="7.1 使用LogCat查看调试信息"></a>7.1 使用LogCat查看调试信息</h2><p>Android SDK提供了android.util.Log类来输出调试信息。该类提供了<code>Log.v()</code>、<code>Log.d()</code>、<code>Log.i()</code>、<code>Log.w()</code>以及<code>Log.e()</code>等5个调试信息输出方法。</p>
<ul>
<li>v表示输出VERBOSE类型的信息</li>
<li>d表示输出DEBUG类型的信息</li>
<li>i表示输出INFO类型的信息</li>
<li>w表示输出WARN类型的信息</li>
<li>e表示输出ERROR类型的信息</li>
</ul>
<p>启动Android设备，就可在DDMS中查看该设备所有运行中的进程。</p>
<img src="/posts/d368aa06/7.1.1.jpg" class="" title="DDMS查看Android设备进程">
<p>去AS中查看LogCat信息会更加详细。</p>
<h2 id="7-2-定位关键代码"><a href="#7-2-定位关键代码" class="headerlink" title="7.2 定位关键代码"></a>7.2 定位关键代码</h2><h3 id="7-2-1-代码注入法"><a href="#7-2-1-代码注入法" class="headerlink" title="7.2.1 代码注入法"></a>7.2.1 代码注入法</h3><p>通常一个程序在发布时不会保留Log输出信息，要想在程序的特定位置输出信息还需手动进行代码注入，所谓代码注入是指首先反编译Android程序，然后在反汇编出的Smali文件中添加Log调用的代码，最后重新打包程序运行来查看输出结果。</p>
<p>同样分析<code>app-debug.apk</code>中的Smali代码，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line">.method private checkSN(Ljava/lang/String;Ljava/lang/String;)Z</span><br><span class="line">    .locals 11</span><br><span class="line">    .param p1, &quot;username&quot;    # Ljava/lang/String;</span><br><span class="line">    .param p2, &quot;sn&quot;    # Ljava/lang/String;</span><br><span class="line">    .annotation system Ldalvik/annotation/MethodParameters;</span><br><span class="line">        accessFlags = &#123;</span><br><span class="line">            0x0,</span><br><span class="line">            0x0</span><br><span class="line">        &#125;</span><br><span class="line">        names = &#123;</span><br><span class="line">            &quot;username&quot;,</span><br><span class="line">            &quot;sn&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    .end annotation</span><br><span class="line"></span><br><span class="line">    .line 39</span><br><span class="line">    const/4 v0, 0x0</span><br><span class="line"></span><br><span class="line">    if-eqz p1, :cond_7#检查username是否为空</span><br><span class="line"></span><br><span class="line">    :try_start_0</span><br><span class="line">    invoke-virtual &#123;p1&#125;, Ljava/lang/String;-&gt;length()I#获取username长度</span><br><span class="line"></span><br><span class="line">    move-result v1</span><br><span class="line"></span><br><span class="line">    if-nez v1, :cond_0#检查username长度是否为0</span><br><span class="line"></span><br><span class="line">    goto/16 :goto_3</span><br><span class="line"></span><br><span class="line">    .line 41</span><br><span class="line">    :cond_0</span><br><span class="line">    if-eqz p2, :cond_6#检查sn是否为空</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p2&#125;, Ljava/lang/String;-&gt;length()I#获取sn长度</span><br><span class="line"></span><br><span class="line">    move-result v1</span><br><span class="line"></span><br><span class="line">    const/16 v2, 0x10#v2=16</span><br><span class="line"></span><br><span class="line">    if-eq v1, v2, :cond_1#判断sn长度是否为16</span><br><span class="line"></span><br><span class="line">    goto :goto_2</span><br><span class="line"></span><br><span class="line">    .line 43</span><br><span class="line">    :cond_1</span><br><span class="line">    const-string v1, &quot;MD5&quot;</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v1&#125;, Ljava/security/MessageDigest;-&gt;getInstance(Ljava/lang/String;)Ljava/security/MessageDigest;</span><br><span class="line"></span><br><span class="line">    move-result-object v1</span><br><span class="line"></span><br><span class="line">    .line 44</span><br><span class="line">    .local v1, &quot;digest&quot;:Ljava/security/MessageDigest;</span><br><span class="line">    invoke-virtual &#123;v1&#125;, Ljava/security/MessageDigest;-&gt;reset()V</span><br><span class="line"></span><br><span class="line">    .line 45</span><br><span class="line">    invoke-virtual &#123;p1&#125;, Ljava/lang/String;-&gt;getBytes()[B#将username转换为字节数组</span><br><span class="line"></span><br><span class="line">    move-result-object v2</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v1, v2&#125;, Ljava/security/MessageDigest;-&gt;update([B)V</span><br><span class="line"></span><br><span class="line">    .line 46</span><br><span class="line">    invoke-virtual &#123;v1&#125;, Ljava/security/MessageDigest;-&gt;digest()[B#username进行MD5摘要运算</span><br><span class="line"></span><br><span class="line">    move-result-object v2</span><br><span class="line"></span><br><span class="line">    .line 47</span><br><span class="line">    .local v2, &quot;bytes&quot;:[B</span><br><span class="line">    new-instance v3, Ljava/lang/StringBuilder;</span><br><span class="line"></span><br><span class="line">    invoke-direct &#123;v3&#125;, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    .line 48</span><br><span class="line">    .local v3, &quot;sb1&quot;:Ljava/lang/StringBuilder;</span><br><span class="line">    new-instance v4, Ljava/lang/StringBuilder;</span><br><span class="line"></span><br><span class="line">    invoke-direct &#123;v4&#125;, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    .line 49</span><br><span class="line">    .local v4, &quot;sb2&quot;:Ljava/lang/StringBuilder;</span><br><span class="line">    array-length v5, v2#v5取username进行MD5摘要结果的长度</span><br><span class="line"></span><br><span class="line">    const/4 v6, 0x0#v6=0</span><br><span class="line"></span><br><span class="line">    :goto_0</span><br><span class="line">    const/4 v7, 0x1#v7=1</span><br><span class="line"></span><br><span class="line">    if-ge v6, v5, :cond_3</span><br><span class="line"></span><br><span class="line">    aget-byte v8, v2, v6#从v2中取下标为6的字节存入v8</span><br><span class="line"></span><br><span class="line">    .line 51</span><br><span class="line">    .local v8, &quot;b&quot;:B</span><br><span class="line">    and-int/lit16 v9, v8, 0xff#v8与0xff相与存入v9</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v9&#125;, Ljava/lang/Integer;-&gt;toHexString(I)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v9</span><br><span class="line"></span><br><span class="line">    .line 52</span><br><span class="line">    .local v9, &quot;hexstr&quot;:Ljava/lang/String;</span><br><span class="line">    invoke-virtual &#123;v9&#125;, Ljava/lang/String;-&gt;length()I#获取v9的长度存到v10</span><br><span class="line"></span><br><span class="line">    move-result v10</span><br><span class="line"></span><br><span class="line">    if-ne v10, v7, :cond_2#如果长度为1，继续往下执行</span><br><span class="line"></span><br><span class="line">    .line 54</span><br><span class="line">    new-instance v7, Ljava/lang/StringBuilder;</span><br><span class="line"></span><br><span class="line">    invoke-direct &#123;v7&#125;, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    const-string v10, &quot;0&quot;</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v7, v10&#125;, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v7, v9&#125;, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v7&#125;, Ljava/lang/StringBuilder;-&gt;toString()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v7</span><br><span class="line"></span><br><span class="line">    move-object v9, v7</span><br><span class="line"></span><br><span class="line">    .line 56</span><br><span class="line">    :cond_2</span><br><span class="line">    invoke-virtual &#123;v3, v9&#125;, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder;#将v9的结果加入到v3</span><br><span class="line"></span><br><span class="line">    .line 49</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">    .end local v8    # &quot;b&quot;:B</span><br><span class="line">    .end local v9    # &quot;hexstr&quot;:Ljava/lang/String;</span><br><span class="line">    add-int/lit8 v6, v6, 0x1</span><br><span class="line"></span><br><span class="line">    goto :goto_0</span><br><span class="line"></span><br><span class="line">    .line 58</span><br><span class="line">    :cond_3</span><br><span class="line">    const/4 v5, 0x0#v5=0</span><br><span class="line"></span><br><span class="line">    .local v5, &quot;i&quot;:I</span><br><span class="line">    :goto_1</span><br><span class="line">    invoke-virtual &#123;v3&#125;, Ljava/lang/StringBuilder;-&gt;length()I#获取v3的长度到v6</span><br><span class="line"></span><br><span class="line">    move-result v6</span><br><span class="line"></span><br><span class="line">    if-ge v5, v6, :cond_4</span><br><span class="line"></span><br><span class="line">    .line 59</span><br><span class="line">    invoke-virtual &#123;v3, v5&#125;, Ljava/lang/StringBuilder;-&gt;charAt(I)C#取v3下标为v5的字符到v6</span><br><span class="line"></span><br><span class="line">    move-result v6</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v4, v6&#125;, Ljava/lang/StringBuilder;-&gt;append(C)Ljava/lang/StringBuilder;#将v6加入到v4</span><br><span class="line"></span><br><span class="line">    .line 58</span><br><span class="line">    add-int/lit8 v5, v5, 0x2#v5自增2</span><br><span class="line"></span><br><span class="line">    goto :goto_1</span><br><span class="line"></span><br><span class="line">    .line 60</span><br><span class="line">    .end local v5    # &quot;i&quot;:I</span><br><span class="line">    :cond_4</span><br><span class="line">    invoke-virtual &#123;v4&#125;, Ljava/lang/StringBuilder;-&gt;toString()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v5#获取v4内容到v5</span><br><span class="line"></span><br><span class="line">    .line 61</span><br><span class="line">    .local v5, &quot;userSN&quot;:Ljava/lang/String;</span><br><span class="line">    invoke-virtual &#123;v5, p2&#125;, Ljava/lang/String;-&gt;equalsIgnoreCase(Ljava/lang/String;)Z#判断v5与sn的内容是否相等，返回值存到v6</span><br><span class="line"></span><br><span class="line">    move-result v6</span><br><span class="line">    :try_end_0</span><br><span class="line">    .catch Ljava/security/NoSuchAlgorithmException; &#123;:try_start_0 .. :try_end_0&#125; :catch_0</span><br><span class="line"></span><br><span class="line">    if-nez v6, :cond_5</span><br><span class="line"></span><br><span class="line">    .line 62</span><br><span class="line">    return v0</span><br><span class="line"></span><br><span class="line">    .line 68</span><br><span class="line">    .end local v1    # &quot;digest&quot;:Ljava/security/MessageDigest;</span><br><span class="line">    .end local v2    # &quot;bytes&quot;:[B</span><br><span class="line">    .end local v3    # &quot;sb1&quot;:Ljava/lang/StringBuilder;</span><br><span class="line">    .end local v4    # &quot;sb2&quot;:Ljava/lang/StringBuilder;</span><br><span class="line">    .end local v5    # &quot;userSN&quot;:Ljava/lang/String;</span><br><span class="line">    :cond_5</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">    .line 69</span><br><span class="line">    return v7</span><br><span class="line"></span><br><span class="line">    .line 42</span><br><span class="line">    :cond_6</span><br><span class="line">    :goto_2</span><br><span class="line">    return v0</span><br><span class="line"></span><br><span class="line">    .line 64</span><br><span class="line">    :catch_0</span><br><span class="line">    move-exception v1</span><br><span class="line"></span><br><span class="line">    .line 66</span><br><span class="line">    .local v1, &quot;e&quot;:Ljava/security/NoSuchAlgorithmException;</span><br><span class="line">    invoke-virtual &#123;v1&#125;, Ljava/security/NoSuchAlgorithmException;-&gt;printStackTrace()V</span><br><span class="line"></span><br><span class="line">    .line 67</span><br><span class="line">    return v0</span><br><span class="line"></span><br><span class="line">    .line 40</span><br><span class="line">    .end local v1    # &quot;e&quot;:Ljava/security/NoSuchAlgorithmException;</span><br><span class="line">    :cond_7</span><br><span class="line">    :goto_3</span><br><span class="line">    return v0</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>
<p><code>.line 61</code>是关键，如果前面分析不出来，那我们用LogCat将v5打印出来，不就知道v5的值是多少了吗？我们尽量不用它设置区间范围的寄存器，所以将该方法的寄存器加1，<code>.locals 11</code>修改为<code>.locals 12</code>，原本程序只需要用v0~v10，那我们用v11就好。在<code>.line 61</code>里注入<code>Log.v()</code>输出v5的值，插入下面两条代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const-string v11, &quot;realSN&quot;</span><br><span class="line">invoke-static &#123;v11, v5&#125;, Landroid/util/Log;-&gt;v(Ljava/lang/String;Ljava/lang/Sting;)I</span><br></pre></td></tr></table></figure>
<p>在<code>.line 61</code>处的代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.line 61</span><br><span class="line">.local v5, &quot;userSN&quot;:Ljava/lang/String;</span><br><span class="line">const-string v11, &quot;realSN&quot;</span><br><span class="line">invoke-static &#123;v11, v5&#125;, Landroid/util/Log;-&gt;v(Ljava/lang/String;Ljava/lang/Sting;)I</span><br><span class="line">invoke-virtual &#123;v5, p2&#125;, Ljava/lang/String;-&gt;equalsIgnoreCase(Ljava/lang/String;)Z</span><br><span class="line"></span><br><span class="line">move-result v6</span><br></pre></td></tr></table></figure>
<p>到达<code>.line 61</code>处需要输入16位注册码，点击注册。发现闪退。回到LogCat查看信息，发现它说在android.util.Log包中没找到v()方法。怎么可能呢？我觉得可能是编写这个程序时没有导入android.util.Log包，导致利用不了该包中的方法。</p>
<img src="/posts/d368aa06/7.2.1.jpg" class="" title="错误">
<p>如果用的是AK，可以直接在需要添加Log代码处右键 -&gt; 插入代码 -&gt; Log，会在需要添加代码的地方插入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const-string v0, &quot;you message&quot;</span><br><span class="line"></span><br><span class="line">invoke-static &#123;v0&#125;, Lcom/android/killer/Log;-&gt;LogStr(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure>
<p>此时将插入的代码修改一下，寄存器的值改为v5即可，部分<code>.line 61</code>的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.line 61</span><br><span class="line">.local v5, &quot;userSN&quot;:Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">invoke-static &#123;v5&#125;, Lcom/android/killer/Log;-&gt;LogStr(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">invoke-virtual &#123;v5, p2&#125;, Ljava/lang/String;-&gt;equalsIgnoreCase(Ljava/lang/String;)Z</span><br><span class="line"></span><br><span class="line">move-result v6</span><br></pre></td></tr></table></figure>
<p>再次运行，输入16位注册码，点击注册。此时LogCat信息中显示正确的注册码。</p>
<img src="/posts/d368aa06/7.2.3.jpg" class="" title="正确注册码">
<p>可以在程序中验证该注册码是否正确。</p>
<img src="/posts/d368aa06/7.2.2.jpg" class="" title="注册成功">
<h3 id="7-2-2-栈跟踪法"><a href="#7-2-2-栈跟踪法" class="headerlink" title="7.2.2 栈跟踪法"></a>7.2.2 栈跟踪法</h3><p>栈跟踪法同样属于代码注入的范畴。它主要是手动向反汇编后的Smali文件中加入栈跟踪信息输出的代码。与注入Log输出的代码不同的是，栈跟踪法只需知道大概的代码注入点。而且注入代码后的反馈信息比Log注入要详细得多。比如在<code>app-debug.apk</code>中，输入错误注册码会弹出Toast()，我们想知道这个Toast()是何时被调用的。</p>
<p>采用5.2所讲的特征函数法，在反汇编代码中查找Toast，发现有2个Toast.show()方法。而且它们的上面是字符串的id值。通过查找发现0x7f0e006c是注册失败，0x7f0e006a是注册成功。</p>
<img src="/posts/d368aa06/7.2.4.jpg" class="" title="特征函数法查找">
<p>因为我们是去到了注册失败的那条路，所以在注册失败即<code>.line 26</code>中，Toast.show()方法后添加输出栈跟踪信息的代码即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new-instance v0, Ljava/lang/Exception;</span><br><span class="line">const-string v1, &quot;print trace&quot;</span><br><span class="line">invoke-direct &#123;v0, v1&#125;, Ljava/lang/Exception;-&gt;&lt;init&gt;(Ljava/lang/String;)V</span><br><span class="line">invoke-virtual &#123;v0&#125;, Ljava/lang/Exception;-&gt;printStackTrace()V</span><br></pre></td></tr></table></figure>
<p>在LogCat中输出警告信息：</p>
<img src="/posts/d368aa06/7.2.5.jpg" class="" title="特征函数法查找">
<p>栈跟踪信息记录了程序从启动到<code>printStackTrace()</code>被执行期间所有被调用过的方法。从下往上查看栈跟踪信息，找到第一条以<code>com.example.crackme</code>开头的信息，发现最开始调用的是<code>OnClick()</code>方法，然后是<code>OnCreate()</code>方法。如此一来，函数的执行流程就一清二楚了。</p>
<h3 id="7-2-3-Method-Profiling"><a href="#7-2-3-Method-Profiling" class="headerlink" title="7.2.3 Method Profiling"></a>7.2.3 Method Profiling</h3><p>Method Profiling相当于OD的trace功能，它的作用是在执行程序时记录下每个被调用的API名称。</p>
<p>在DDMS中选中需要关注的程序，点击工具栏中的<code>Start Method Profiling</code>，在程序中执行想要分析的操作，操作完后点击<code>Stop Method Profiling</code>，等待片刻就会弹出TraceView窗口。</p>
<img src="/posts/d368aa06/7.2.6.png" class="" title="TraceView窗口">
<p>任意一个调用方法都有Parents和Children子项，其中Parents表示该方法被哪个方法调用，Children表示该方法调用了哪些方法。</p>
<p>如果我们想要Method Profiling的代码一开始就执行了，要想对它使用Method Profiling就需要查找开始点与结束点，然后手动注入代码。在android.os.Debug类中，提供了<code>startMethodTracing()</code>与<code>stopMethodTracing()</code>两个方法来开启与关闭Method Profiling。</p>
<p>Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android.os.Debug.startMethodTracing(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">a();</span><br><span class="line">android.os.Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure>
<p>字符串“123”为trace文件名，上面的代码在执行后会在SD卡的根目录中生成<code>123.trace</code>文件，这个文件包含了a()方法执行过程中所有的方法调用与CPU占用时间等信息。生成的文件可以将它pull出来，用Android SDK中tools目录下的traceview打开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceview 123.trace</span><br></pre></td></tr></table></figure>
<p>另外，注入的代码在运行时需要往SD卡中写入文件，因此还需要在反编译的<code>AndroidManifest.xml</code>文件中添加SD卡写入权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission adnroid:name=&quot;android.permission.WRITE_EXTERNAL_STORACE&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>如果确定不了开始点与结束点，可以在Activity的<code>OnCreate()</code>方法中注入<code>startMethodTracing()</code>代码，反汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const-string v0, &quot;123&quot;</span><br><span class="line">invoke-static &#123;v0&#125;, Landroid/os/Debug;-&gt;startMethodTracing(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure>
<p>在<code>OnStop()</code>方法中注入<code>stopMethodTracing()</code>代码，反汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;&#125;, Landroid/os/Debug;-&gt;stopMethodTracing()V</span><br></pre></td></tr></table></figure>
<p>这样当程序打开并关闭后就会生成<code>123.trace</code>文件，然后使用traceview工具分析即可。</p>
<h2 id="7-3-使用IDA-Pro动态调试so文件"><a href="#7-3-使用IDA-Pro动态调试so文件" class="headerlink" title="7.3 使用IDA Pro动态调试so文件"></a>7.3 使用IDA Pro动态调试so文件</h2><p>详情请看我的另一篇文章：<a target="_blank" rel="noopener" href="https://v5le0n9.github.io/posts/15be101a.html#9-IDA%E5%8A%A8%E6%80%81%E7%A0%B4%E8%A7%A3%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81">Android逆向入门教程 9.IDA动态破解登录验证</a></p>
<h1 id="8-Android软件的破解技术"><a href="#8-Android软件的破解技术" class="headerlink" title="8. Android软件的破解技术"></a>8. Android软件的破解技术</h1><h2 id="8-1-试用版软件"><a href="#8-1-试用版软件" class="headerlink" title="8.1 试用版软件"></a>8.1 试用版软件</h2><p>免费试用版软件是Android平台上比较常见的一种商业软件，这种软件的自我保护能力一般较弱，通常可以手动破解。</p>
<h3 id="8-1-1-试用版软件的种类"><a href="#8-1-1-试用版软件的种类" class="headerlink" title="8.1.1 试用版软件的种类"></a>8.1.1 试用版软件的种类</h3><p>Android平台的试用版软件大致分为三类：免费试用版、演示版与限制功能版免费版。</p>
<p>免费试用版的软件通常有一个免费试用期限或次数限制，当达到了期限或免费次数后，软件会提示过期，提醒用户购买软件。</p>
<p>演示版软件一般只提供软件的部分功能供用户使用，此类软件通常是“免费”的，用户要想使用软件的全部功能则需要向软件作者购买正式版的软件，作者会提供完整版的安装包及使用权限。</p>
<p>限制功能免费版的软件通常将软件根据功能分成几个级别，例如免费版、高级版、专业版等。免费版只提供最基础的功能，而专业版或高级版则提供更多或全部功能，根据作者的授权风格不同，这三种级别的软件可能使用同一个软件安装包，通过不同的授权来区别使用权限，或使用不同的安装包提供不同的软件功能。</p>
<h3 id="8-1-2-实例破解——针对授权KEY方式的破解"><a href="#8-1-2-实例破解——针对授权KEY方式的破解" class="headerlink" title="8.1.2 实例破解——针对授权KEY方式的破解"></a>8.1.2 实例破解——针对授权KEY方式的破解</h3><p>破解试用版软件的前提是试用软件中提供了软件的完整功能（即有些功能显示灰色，需要购买才能使用），否则即使解除了软件的授权限制也无法使用完整的功能，失去了破解的意义。</p>
<p>在使用授权KEY方式分辨授权类型时，可能会用到<code>createPackageContext()</code>方法，它可以创建其它程序的Context，通过这个Context可以访问其它软件包的资源，甚至可以执行其它软件包的代码。但这个方法可能抛出java.lang.SecurityException异常，这个异常为安全异常，通常一个软件是不能够创建其它程序Context的，除非它们拥有相同的用户ID与签名。用户ID是一个字符串标识，在程序<code>AndroidManifest.xml</code>文件的manifest标签中指定，格式为android:sharedUserId=”xxx.xxx.xxx”，当两个程序中指定了相同的用户ID时，这两个程序将运行在同一个进程空间，它们之间的资源此时可以相互访问，如果它们的签名也相同的话，还可以相互执行软件包之间的代码。</p>
<h2 id="8-2-序列号保护"><a href="#8-2-序列号保护" class="headerlink" title="8.2 序列号保护"></a>8.2 序列号保护</h2><p>序列号保护又称为注册码保护。通常在购买这种保护方式的软件是，用户需要向软件作者提供注册信息(用户名或机器码)，软件作者通过自己编写的“算号”程序计算出注册码发回给用户，用户使用这个注册码完成整个注册过程。“算号”软件也称为注册机，在计算可逆加密算法程序的注册码时，它通常是软件加密算法的一个逆过程。</p>
<p>序列号保护建议：</p>
<ul>
<li><p>序列号加入机器码验证，做到一机一码。</p>
</li>
<li><p>使用NDK编写注册模块。将软件注册版提供的功能进行加密，例如对相关代码或数据使用AES、DES等加密算法进行加密，软件在运行时检测注册信息，如果是注册版用户则根据注册信息生成正确的解密密钥，最后使用这个密钥对注册版功能进行解密。</p>
<p>根据注册信息生成密钥的一种思路可以是：在判断用户注册码正确的情况下，取注册码的前8位对其每个字节进行异或运算，然后使用这8位异或后的字节作为加密密钥，对注册功能代码的解密密钥进行AES/DES加密运算(AES/DEX的加密密钥即为解密密钥)，将生成的加密数据写入程序的配置文件(SharedProferences或File都可以)，软件在运行时读取该数据对代码进行解密，解密成功即说明是注册版用户。</p>
</li>
<li><p>加入其它类型的保护方式，多种保护方式结合。</p>
</li>
</ul>
<h2 id="8-3-网络验证"><a href="#8-3-网络验证" class="headerlink" title="8.3 网络验证"></a>8.3 网络验证</h2><p>网络验证是指软件在运行时需要联网进行一些验证。网络连接方式可以是Socket连接与HTTP连接，验证的内容可以是软件注册信息验证、代码完整性验证以及软件功能解密等。</p>
<h3 id="8-3-1-网络验证保护思路"><a href="#8-3-1-网络验证保护思路" class="headerlink" title="8.3.1 网络验证保护思路"></a>8.3.1 网络验证保护思路</h3><p>软件通过网络向验证服务器请求反馈信息，这些信息可能是静态的(例如服务器上的某个文件)，也可能是动态的(例如传递一些特定的参数访问服务器的ASP或PHP脚本，服务器根据不同的参数返回不同的数据)，还有可能是交互的(例如软件定义了一套与服务器交互的协议，通过Socket方式进行通信)。</p>
<p>对于静态的反馈信息，分析人员能够手动访问网络获取所有信息的内容，这样的软件在破解时相对简单，只需要找到验证点补丁上相应的信息即可。</p>
<p>动态的反馈信息处理起来则比较麻烦，由于无法得知完整的信息内容，就需要尝试构造不用参数的信息来获取返回结果，这可能需要多次运行软件，并且效果可能并不理想，尤其在参数与反馈信息被加密的情况下，还需要花大量的时间来对信息进行解密。</p>
<p>交互式的网络验证是最难破解的，交互式网络验证的服务器能够对信息进行更好的控制，这种验证多用于对软件功能的保护以及对软件使用者合法性的检测上，软件功能保护将软件的核心功能从客户端转向了服务端，客户端软件只是成为了一个数据显示工具，而合法性检测例如常见的“心跳包”检测，一旦软件与服务器断开连接，软件就拒绝提供任何功能或者干脆停止运行。</p>
<h3 id="8-3-2-实例破解——针对网络验证静态方式的破解"><a href="#8-3-2-实例破解——针对网络验证静态方式的破解" class="headerlink" title="8.3.2 实例破解——针对网络验证静态方式的破解"></a>8.3.2 实例破解——针对网络验证静态方式的破解</h3><p>既然软件会联网访问服务器上的数据，那么可以先找出服务器的地址。除了使用静态分析查找服务器地址外，还可以通过网络抓包的方式来获取，网络抓包工具可以使用Android移植版的tcpdump工具，该工具在Android模拟器的<code>system/xbin</code>目录下。</p>
<p>执行抓包命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell tcpdump -p -vv 0 -w /sdcard/capture.pcap</span><br></pre></td></tr></table></figure>
<p>导出包文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sdcard/capture.pcap</span><br></pre></td></tr></table></figure>
<p>导出后可用Wireshark查看流量包，筛选出HTTP与TCP数据包，找到网址。</p>
<p>之后再根据网址的静态内容嵌入到Smali代码中，去掉网络验证即可。（具体实现还没有找到好的例子，以后可能补上）</p>
<h2 id="8-4-重启验证"><a href="#8-4-重启验证" class="headerlink" title="8.4 重启验证"></a>8.4 重启验证</h2><p>重启验证是一种常见的软件保护技术，它的保护强度与开发人员重启验证的保护思路有关。</p>
<h3 id="8-4-1-重启验证保护思路"><a href="#8-4-1-重启验证保护思路" class="headerlink" title="8.4.1 重启验证保护思路"></a>8.4.1 重启验证保护思路</h3><p>重启验证的通常做法是：在软件注册时不直接提示注册成功与否，而是将注册信息保存下来，然后在下次启动时读取并验证，如果失败则软件仍未注册，成功则开启注册版的功能。</p>
<p>Android系统保存信息的方法有限，只能是内部存储、外部存储、数据库与SharedProferences等4种方式。破解者通常可以在短时间内找到注册信息的保存位置，因此，在实际使用重启验证的过程中，注册信息必须要加密存储才能保证其保护强度。几种常见的保护方案如下：</p>
<ul>
<li>单一保护。重启验证保护模块使用Java代码编写，注册信息加密保存到内部存储中。</li>
<li>单一保护。重启验证保护模块使用Native代码编写，注册信息加密保存到内部存储中。</li>
<li>多重保护。重启验证保护模块使用Native代码编写，并在代码中加入网络验证。</li>
</ul>
<h1 id="9-Android程序的反破解技术"><a href="#9-Android程序的反破解技术" class="headerlink" title="9. Android程序的反破解技术"></a>9. Android程序的反破解技术</h1><p>逆向Android程序的整个过程可分为反编译、静态分析、动态调试、重编译4个环节，从这4个环节出发，分析如何在每个环节中保护Android程序。</p>
<h2 id="9-1-对抗反编译"><a href="#9-1-对抗反编译" class="headerlink" title="9.1 对抗反编译"></a>9.1 对抗反编译</h2><p>对抗反编译是指APK文件无法通过反编译工具(如Apktool、BakSmali、dex2jar)对其进行反编译，或者反编译后无法得到软件正确的反汇编代码。</p>
<p>对抗反编译工具的思路是：寻找反编译工具在处理APK或DEX文件时的缺陷，然后在自己的软件中加以利用，让反编译工具处理这些“特制”的APK文件时抛出异常而反编译失败。这样编写出来的软件能够在手机上正常使用，但在反编译工具的眼里却是一个“畸形”的文件。</p>
<p>如何查找反编译工具的缺陷？两种方式：阅读反编译工具源码和压力测试。</p>
<p><strong>阅读反编译工具源码</strong></p>
<p>目前大多数Android软件的反汇编工具都是开源的，可以很方便通过阅读源码来查找缺陷。查找的思路可以根据APK文件的处理环节来展开，例如资源文件处理、DEX文件校验、DEX文件类代码解析等。但通常情况下，反编译工具在发布前都经过多次测试，要想找出代码的缺陷非常困难。因此这种方法具体实施起来比较困难。</p>
<p><strong>压力测试</strong></p>
<p>收集大量的APK文件存放进一个目录，编写脚本或程序调用反编译工具对目录下的所有APK文件进行反编译。不同的软件从大小、内容到结构组织都不尽相同，反编译工具在处理它们时有可能会出现异常。从反编译的出错信息中查找反编译工具的缺陷，然后在软件开发中加以利用。</p>
<h2 id="9-2-对抗静态分析"><a href="#9-2-对抗静态分析" class="headerlink" title="9.2 对抗静态分析"></a>9.2 对抗静态分析</h2><h3 id="9-2-1-代码混淆技术"><a href="#9-2-1-代码混淆技术" class="headerlink" title="9.2.1 代码混淆技术"></a>9.2.1 代码混淆技术</h3><p>使用Native代码代替Java代码是很好的代码保护手段，Google在Android 2.3的SDK中正式加入了ProGuard代码混淆工具。</p>
<p>ProGuard提供了压缩、混淆、优化Java代码以及反混淆栈跟踪的功能。ProGuard默认情况下会对class文件中所有的类、方法以及字段进行混淆，经过混淆的类会面目全非。</p>
<h3 id="9-2-2-NDK保护"><a href="#9-2-2-NDK保护" class="headerlink" title="9.2.2 NDK保护"></a>9.2.2 NDK保护</h3><p>用Native代码代替Java代码。</p>
<h3 id="9-2-3-外壳保护"><a href="#9-2-3-外壳保护" class="headerlink" title="9.2.3 外壳保护"></a>9.2.3 外壳保护</h3><p>外壳保护是一种代码加密技术，在Windows平台的软件中广泛被使用。经过外壳保护的软件，展现在分析人员面前的是外壳的代码，因此很大程度上保护了软件被人破解。</p>
<p>Java代码由于其语言自身的特殊性，没有外壳保护的概念，只能通过混淆方式对其进行保护。外壳保护重点针对使用Android NDK编写的Native代码，逆向Native代码本身就很困难了，再加上外壳保护难上加难。目前已知可用于ARM Linux内核程序的加壳工具只有UPX。</p>
<h2 id="9-3-对抗动态调试"><a href="#9-3-对抗动态调试" class="headerlink" title="9.3 对抗动态调试"></a>9.3 对抗动态调试</h2><h3 id="9-3-1-检测调试器"><a href="#9-3-1-检测调试器" class="headerlink" title="9.3.1 检测调试器"></a>9.3.1 检测调试器</h3><p>动态调试使用调试器来挂钩软件，获取软件运行时的数据，我们可以在软件中加入检测调试器的代码，当检测到软件被调试器连接时，中止软件的运行。</p>
<p>在<code>AndroidManifest.xml</code>文件中application标签中加入<code>android:debuggable=&quot;false&quot;</code>让程序不可调试，这样如果别人想调试该程序就必然会修改它的值，我们在代码中检查它的值来判断程序是否被修改过，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((getApplicationInfo().flags &amp;= ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Log.e(<span class="string">&quot;com.droider.antidebug&quot;</span>,<span class="string">&quot;程序被修改为可调试状态&quot;</span>);</span><br><span class="line">    android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ApplicationInfo.FLAG_DEBUGGABLE</code>对应<code>android:debuggable=&quot;true&quot;</code>，如果该标志被置位，说明程序被修改，此时可以果断中止程序运行。</p>
<p>另外，Android SDK中提供了一个方法方便程序员来检测调试器是否已经连接，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.os.Debug.isDebuggerContected()</span><br></pre></td></tr></table></figure>
<p>如果方法返回true，说明调试器已经连接。我们可以随机地在软件中插入这行代码来检测调试器，碰到有调试器连接就果断地结束运行。</p>
<h3 id="9-3-2-检测模拟器"><a href="#9-3-2-检测模拟器" class="headerlink" title="9.3.2 检测模拟器"></a>9.3.2 检测模拟器</h3><p>软件发布后会安装到用户的手机中运行，如果发现软件运行在模拟器中，很显然不合常理，可能是有人试图破解或分析它。</p>
<p>模拟器与真机有着许多差异，可以输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop</span><br></pre></td></tr></table></figure>
<p>查看并对比它们的属性值，经过对比发现，有如下几个属性值可以用来判断软件是否运行在模拟器中：</p>
<ul>
<li>ro.product.model：该值在模拟器中为sdk，通常在真机中它的值为手机型号。</li>
<li>ro.build.tags：该值在模拟器中为test-keys，通常在真机中它的值为release-keys。</li>
<li>ro.kernel.qemu：该值在模拟器中为1，通常在真机中没有该属性。</li>
</ul>
<h2 id="9-4-防止重编译"><a href="#9-4-防止重编译" class="headerlink" title="9.4 防止重编译"></a>9.4 防止重编译</h2><h3 id="9-4-1-检查签名"><a href="#9-4-1-检查签名" class="headerlink" title="9.4.1 检查签名"></a>9.4.1 检查签名</h3><p>破解者通常不可能拥有与开发人员相同的密钥文件（密钥文件被盗除外），因此签名成了Android软件一种有效的身份标识。如果软件运行时的签名与自己发布时的不同，说明软件被篡改过。</p>
<p>Android SDK中提供了检测软件签名的方法，可以调用PackageManager类的<code>getPackageInfo()</code>方法。由于返回的签名较长，可用其Hash值在代码中进行比较。</p>
<h3 id="9-4-2-校验保护"><a href="#9-4-2-校验保护" class="headerlink" title="9.4.2 校验保护"></a>9.4.2 校验保护</h3><p>重编译Android软件的实质是重新编译<code>classes.dex</code>文件，代码经过重新编译后，生成的<code>classes.dex</code>文件的Hash值已经改变，我们可以检查程序的安装后<code>classes.dex</code>文件的Hash值来判断软件是否被重打包过。</p>
<h1 id="10-Android系统攻击与防范"><a href="#10-Android系统攻击与防范" class="headerlink" title="10. Android系统攻击与防范"></a>10. Android系统攻击与防范</h1><h2 id="10-1-Anroid手机ROOT原理"><a href="#10-1-Anroid手机ROOT原理" class="headerlink" title="10.1 Anroid手机ROOT原理"></a>10.1 Anroid手机ROOT原理</h2><p>手机ROOT是通过已经公布的Android系统本地提权漏洞，借助漏洞利用程序来提升系统的用户权限。手机ROOT分为临时ROOT与永久ROOT。临时ROOT是指临时性的获取系统root权限，不对系统进行任何修改，而永久ROOT是指修改Android系统，手机可以随时获取root权限。</p>
<h2 id="10-2-ROM安全"><a href="#10-2-ROM安全" class="headerlink" title="10.2 ROM安全"></a>10.2 ROM安全</h2><p>ROM，只读存储器。手机ROM指的是存放手机固件代码的存储器，可以理解为手机的“系统”，类似于Windows系统安装光盘。</p>
<h3 id="10-2-1-ROM的种类"><a href="#10-2-1-ROM的种类" class="headerlink" title="10.2.1 ROM的种类"></a>10.2.1 ROM的种类</h3><p>根据ROM制作者不同，Android系统的ROM分为如下三类：</p>
<ul>
<li>官方ROM：手机出厂时被刷入的ROM。</li>
<li>第三方ROM：由第三方ROM制作团队或厂商制作的ROM。</li>
<li>民间个人版ROM：个人在官方ROM或第三方ROM的基础上进行修改而成的ROM。</li>
</ul>
<h1 id="11-DroidKongFu变种病毒实例分析"><a href="#11-DroidKongFu变种病毒实例分析" class="headerlink" title="11. DroidKongFu变种病毒实例分析"></a>11. DroidKongFu变种病毒实例分析</h1><img src="/posts/d368aa06/11.1.1.jpg" class="" title="DroidKongFu变种病毒执行流程图">
    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="v5le0n9 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="v5le0n9 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/78ecec07.html" rel="prev" title="Android移动安全相关工具">
      <i class="fa fa-chevron-left"></i> Android移动安全相关工具
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/80f0c627.html" rel="next" title="利用Frida脱App壳">
      利用Frida脱App壳 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Windows%E4%B8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-text">1. Windows下环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%AE%89%E8%A3%85JDK"><span class="nav-text">1.1 安装JDK</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E5%AE%89%E8%A3%85Android-SDK"><span class="nav-text">1.2 安装Android SDK</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%AE%89%E8%A3%85Android-NDK"><span class="nav-text">1.3 安装Android NDK</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E5%AE%89%E8%A3%85Android-Studio"><span class="nav-text">1.4 安装Android Studio</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%88%86%E6%9E%90Android%E7%A8%8B%E5%BA%8F"><span class="nav-text">2. 分析Android程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E7%BC%96%E5%86%99Android%E7%A8%8B%E5%BA%8F"><span class="nav-text">2.1 编写Android程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E7%A0%B4%E8%A7%A3Android%E7%A8%8B%E5%BA%8F"><span class="nav-text">2.2 破解Android程序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E8%BF%9B%E5%85%A5Android-Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-text">3. 进入Android Dalvik虚拟机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8EJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">3.1 Dalvik虚拟机与Java虚拟机的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-text">3.2 Android系统架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-DEX%E6%96%87%E4%BB%B6%E5%8F%8D%E6%B1%87%E7%BC%96"><span class="nav-text">3.3 DEX文件反汇编</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Android%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-text">4. Android可执行文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Android%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E6%88%90%E6%AD%A5%E9%AA%A4"><span class="nav-text">4.1 Android程序的生成步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-DEX%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-text">4.2 DEX文件格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-dex-header"><span class="nav-text">4.2.1 dex header</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-DexMapList"><span class="nav-text">4.2.2 DexMapList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-string-ids"><span class="nav-text">4.2.3 string_ids</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-4-type-ids"><span class="nav-text">4.2.4 type_ids</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-5-proto-ids"><span class="nav-text">4.2.5 proto_ids</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-6-field-ids"><span class="nav-text">4.2.6 field_ids</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-7-method-ids"><span class="nav-text">4.2.7 method_ids</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-8-class-def"><span class="nav-text">4.2.8 class_def</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-9-data"><span class="nav-text">4.2.9 data</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-ODEX%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-text">4.3 ODEX文件格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-%E7%94%9F%E6%88%90ODEX%E6%96%87%E4%BB%B6"><span class="nav-text">4.3.1 生成ODEX文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-ODEX%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-text">4.3.2 ODEX文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-1-odex%E6%96%87%E4%BB%B6%E5%A4%B4"><span class="nav-text">4.3.2.1 odex文件头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-2-%E4%BE%9D%E8%B5%96%E5%BA%93"><span class="nav-text">4.3.2.2 依赖库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-3-%E8%BE%85%E5%8A%A9%E6%95%B0%E6%8D%AE"><span class="nav-text">4.3.2.3 辅助数据</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-2-3-1-ChunkDexClassLookup"><span class="nav-text">4.3.2.3.1 ChunkDexClassLookup</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-2-3-2-ChunkRegisterMapPool"><span class="nav-text">4.3.2.3.2 ChunkRegisterMapPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-2-3-3-ChunkEnd"><span class="nav-text">4.3.2.3.3 ChunkEnd</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-Anroid%E7%A8%8B%E5%BA%8F%E5%8F%A6%E7%B1%BB%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95"><span class="nav-text">4.4 Anroid程序另类破解方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Android%E7%A8%8B%E5%BA%8F"><span class="nav-text">5. 静态分析Android程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-AndroidManifest-xml"><span class="nav-text">5.1 AndroidManifest.xml</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-manifest%E6%A0%87%E7%AD%BE"><span class="nav-text">5.1.1 manifest标签</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-1-xmlns-android"><span class="nav-text">5.1.1.1 xmlns:android</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-2-package"><span class="nav-text">5.1.1.2 package</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-3-adnroid-versionCode"><span class="nav-text">5.1.1.3 adnroid:versionCode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-4-android-versionName"><span class="nav-text">5.1.1.4 android:versionName</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-uses-feature%E6%A0%87%E7%AD%BE"><span class="nav-text">5.1.2 uses-feature标签</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-1-android-name"><span class="nav-text">5.1.2.1 android:name</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-2-android-required"><span class="nav-text">5.1.2.2 android:required</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-3-android-glEsVersion"><span class="nav-text">5.1.2.3 android:glEsVersion</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-application%E6%A0%87%E7%AD%BE"><span class="nav-text">5.1.3 application标签</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-1-android-allowBackup"><span class="nav-text">5.1.3.1 android:allowBackup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-2-android-fullBackupContent"><span class="nav-text">5.1.3.2 android:fullBackupContent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-3-android-supportsRtl"><span class="nav-text">5.1.3.3 android:supportsRtl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-4-android-icon"><span class="nav-text">5.1.3.4 android:icon</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-5-android-label"><span class="nav-text">5.1.3.5 android:label</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-6-android-theme"><span class="nav-text">5.1.3.6 android:theme</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-7-android-name"><span class="nav-text">5.1.3.7 android:name</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-4-activity%E6%A0%87%E7%AD%BE"><span class="nav-text">5.1.4 activity标签</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-1-android-name"><span class="nav-text">5.1.4.1 android:name</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-2-android-label"><span class="nav-text">5.1.4.2 android:label</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-3-android-configChanges"><span class="nav-text">5.1.4.3 android:configChanges</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-4-android-theme"><span class="nav-text">5.1.4.4 android:theme</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-5-meta-data%E6%A0%87%E7%AD%BE"><span class="nav-text">5.1.5 meta-data标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-6-intent-filter%E6%A0%87%E7%AD%BE"><span class="nav-text">5.1.6 intent-filter标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-7-action%E6%A0%87%E7%AD%BE"><span class="nav-text">5.1.7 action标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-8-category%E6%A0%87%E7%AD%BE"><span class="nav-text">5.1.8 category标签</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E5%AE%9A%E4%BD%8D%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-text">5.2 定位关键代码的6种方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E4%BD%BF%E7%94%A8IDA-Pro%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Android%E7%A8%8B%E5%BA%8F"><span class="nav-text">5.3 使用IDA Pro静态分析Android程序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-Android-NDK%E7%A8%8B%E5%BA%8F"><span class="nav-text">6. Android NDK程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-Android%E5%8E%9F%E7%94%9F%E7%A8%8B%E5%BA%8F%E4%B8%8EAndroid-NDK%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">6.1 Android原生程序与Android NDK程序的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E5%88%86%E6%9E%90Android-NDK%E7%A8%8B%E5%BA%8F"><span class="nav-text">6.2 分析Android NDK程序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95Android%E7%A8%8B%E5%BA%8F"><span class="nav-text">7. 动态调试Android程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E4%BD%BF%E7%94%A8LogCat%E6%9F%A5%E7%9C%8B%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF"><span class="nav-text">7.1 使用LogCat查看调试信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E5%AE%9A%E4%BD%8D%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81"><span class="nav-text">7.2 定位关键代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%B3%95"><span class="nav-text">7.2.1 代码注入法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-%E6%A0%88%E8%B7%9F%E8%B8%AA%E6%B3%95"><span class="nav-text">7.2.2 栈跟踪法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-Method-Profiling"><span class="nav-text">7.2.3 Method Profiling</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E4%BD%BF%E7%94%A8IDA-Pro%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so%E6%96%87%E4%BB%B6"><span class="nav-text">7.3 使用IDA Pro动态调试so文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-Android%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%A0%B4%E8%A7%A3%E6%8A%80%E6%9C%AF"><span class="nav-text">8. Android软件的破解技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-%E8%AF%95%E7%94%A8%E7%89%88%E8%BD%AF%E4%BB%B6"><span class="nav-text">8.1 试用版软件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-1-%E8%AF%95%E7%94%A8%E7%89%88%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-text">8.1.1 试用版软件的种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-2-%E5%AE%9E%E4%BE%8B%E7%A0%B4%E8%A7%A3%E2%80%94%E2%80%94%E9%92%88%E5%AF%B9%E6%8E%88%E6%9D%83KEY%E6%96%B9%E5%BC%8F%E7%9A%84%E7%A0%B4%E8%A7%A3"><span class="nav-text">8.1.2 实例破解——针对授权KEY方式的破解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-%E5%BA%8F%E5%88%97%E5%8F%B7%E4%BF%9D%E6%8A%A4"><span class="nav-text">8.2 序列号保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81"><span class="nav-text">8.3 网络验证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-1-%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E4%BF%9D%E6%8A%A4%E6%80%9D%E8%B7%AF"><span class="nav-text">8.3.1 网络验证保护思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-2-%E5%AE%9E%E4%BE%8B%E7%A0%B4%E8%A7%A3%E2%80%94%E2%80%94%E9%92%88%E5%AF%B9%E7%BD%91%E7%BB%9C%E9%AA%8C%E8%AF%81%E9%9D%99%E6%80%81%E6%96%B9%E5%BC%8F%E7%9A%84%E7%A0%B4%E8%A7%A3"><span class="nav-text">8.3.2 实例破解——针对网络验证静态方式的破解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-%E9%87%8D%E5%90%AF%E9%AA%8C%E8%AF%81"><span class="nav-text">8.4 重启验证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-1-%E9%87%8D%E5%90%AF%E9%AA%8C%E8%AF%81%E4%BF%9D%E6%8A%A4%E6%80%9D%E8%B7%AF"><span class="nav-text">8.4.1 重启验证保护思路</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-Android%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%8D%E7%A0%B4%E8%A7%A3%E6%8A%80%E6%9C%AF"><span class="nav-text">9. Android程序的反破解技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-%E5%AF%B9%E6%8A%97%E5%8F%8D%E7%BC%96%E8%AF%91"><span class="nav-text">9.1 对抗反编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-%E5%AF%B9%E6%8A%97%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"><span class="nav-text">9.2 对抗静态分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-1-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF"><span class="nav-text">9.2.1 代码混淆技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-2-NDK%E4%BF%9D%E6%8A%A4"><span class="nav-text">9.2.2 NDK保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-3-%E5%A4%96%E5%A3%B3%E4%BF%9D%E6%8A%A4"><span class="nav-text">9.2.3 外壳保护</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-%E5%AF%B9%E6%8A%97%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95"><span class="nav-text">9.3 对抗动态调试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-1-%E6%A3%80%E6%B5%8B%E8%B0%83%E8%AF%95%E5%99%A8"><span class="nav-text">9.3.1 检测调试器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-2-%E6%A3%80%E6%B5%8B%E6%A8%A1%E6%8B%9F%E5%99%A8"><span class="nav-text">9.3.2 检测模拟器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-%E9%98%B2%E6%AD%A2%E9%87%8D%E7%BC%96%E8%AF%91"><span class="nav-text">9.4 防止重编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-1-%E6%A3%80%E6%9F%A5%E7%AD%BE%E5%90%8D"><span class="nav-text">9.4.1 检查签名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-2-%E6%A0%A1%E9%AA%8C%E4%BF%9D%E6%8A%A4"><span class="nav-text">9.4.2 校验保护</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-Android%E7%B3%BB%E7%BB%9F%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E8%8C%83"><span class="nav-text">10. Android系统攻击与防范</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-Anroid%E6%89%8B%E6%9C%BAROOT%E5%8E%9F%E7%90%86"><span class="nav-text">10.1 Anroid手机ROOT原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-ROM%E5%AE%89%E5%85%A8"><span class="nav-text">10.2 ROM安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-1-ROM%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-text">10.2.1 ROM的种类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-DroidKongFu%E5%8F%98%E7%A7%8D%E7%97%85%E6%AF%92%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-text">11. DroidKongFu变种病毒实例分析</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="v5le0n9"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">v5le0n9</p>
  <div class="site-description" itemprop="description">小呀小二郎呀背着个书包上学堂</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/Leong_Vinson" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;Leong_Vinson" rel="noopener" target="_blank"><i class="fab fa-cuttlefish fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/v5le0n9" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;v5le0n9" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:v5le0n9@163.com" title="E-Mail → mailto:v5le0n9@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.zz1syyd.com/" title="https:&#x2F;&#x2F;www.zz1syyd.com&#x2F;" rel="noopener" target="_blank">zz1syyd</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://one-null-pointer.github.io/" title="https:&#x2F;&#x2F;one-null-pointer.github.io&#x2F;" rel="noopener" target="_blank">liaoyue</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">v5le0n9</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:51</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '7c58e80079a2457b610d',
      clientSecret: 'fc16b1b0fdfb278016ebe41c20f3743c3c927466',
      repo        : 'comments.github.io',
      owner       : 'v5le0n9',
      admin       : ['v5le0n9'],
      id          : 'b734a7aa34a8fbd87e4ad8fc8b2cba5c',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
